// SPDX-License-Identifier: MIT

// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/ERC721.sol)



pragma solidity ^0.8.4;



import "@openzeppelin/contracts/token/ERC721/ERC721.sol";

import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";

import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol";

import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Pausable.sol";

import "@openzeppelin/contracts/access/AccessControlEnumerable.sol";

import "@openzeppelin/contracts/utils/Context.sol";

import "@openzeppelin/contracts/utils/Counters.sol";

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

/*

  ___                _            _           _   ___ 

 |  _|              | |          | |         | | |_  |

 | |    _ __ ___  __| | __ _  ___| |_ ___  __| |   | |

 | |   | '__/ _ \/ _` |/ _` |/ __| __/ _ \/ _` |   | |

 | |   | | |  __/ (_| | (_| | (__| ||  __/ (_| |   | |

 | |_  |_|  \___|\__,_|\__,_|\___|\__\___|\__,_|  _| |

 |___|                                           |___|



                         ___________

                       /           /|

                      /           / |

                     /___________/  |

                    |           |   |

                    |    <3     |  / 

                    |___________| /

                     `-.______.-'   

discord: https://discord.gg/Uqycpn5YaZ

twitter: https://twitter.com/_redactedNFT

website: https://www.redactednft.com/

x: https://x.com/_redactedNFT



thank you to the wonderfull community that made this happen

*/



/**

 * @dev {ERC721} token, including:

 *

 *  - ability for holders to burn (destroy) their tokens

 *  - a minter role that allows for token minting (creation)

 *  - a pauser role that allows to stop all token transfers

 *  - token ID and URI autogeneration

 *

 * This contract uses {AccessControl} to lock permissioned functions using the

 * different roles - head to its documentation for details.

 *

 * The account that deploys the contract will be granted the minter and pauser

 * roles, as well as the default admin role, which will let it grant both minter

 * and pauser roles to other accounts.

 *

 * _Deprecated in favor of https://wizard.openzeppelin.com/[Contracts Wizard]._

 */

contract redactednft is

    Context,

    AccessControlEnumerable,

    ERC721Enumerable,

    ERC721Burnable,

    ERC721Pausable

{

    using Counters for Counters.Counter;

    using SafeERC20 for IERC20;

    using Strings for uint256;



    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");

    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");



    Counters.Counter private _tokenIdTracker;



    string private _baseTokenURI;



   

    address public liquidStakingDerivative; // lido steth

    address public recipient; // receiver of dev fee

    address public royaltyReceiver; // 

    address public royaltyReceiver2; // 

    address public bufferedAddress; // buffered ticketing (os)

    uint256 public bufferedNFTid; // buffered ticketing (os)

    address public lido; // interface address

    address public owner; // rarible claimage thing to set royalties



    uint256 public EndingTime;

    uint256 public deploytime;

    uint256 public maxLength;

    uint256 public pot;

    uint256 public totalInVaults;

    uint256 public price; // startingprice



    bool public active;

    

    // indexNr

    uint256 public Index;

    // for each nft there is mintingprice

    mapping(uint256 => uint256) public nftPrice;

    // for each nftID there is last ticket tracked

    mapping(uint256 => uint256) public nftLatestSpot;

    // index for what address is on top

    mapping(uint256 => address) public rewardAddress;

    // for each address there is bool wether or not it is whitelisted for ticketing

    mapping(address => bool) public activeMarkets;

    // for each address there is uint wether or not it is whitelisted for minting

    mapping(address => uint256) public whitelisted;

    // for each address there is max that they can mint

    mapping(address => uint256) public whitelisted2;

    // for each round there is bool wether or not the winners have been payed

    bool public winnersPaid;

    // for each address there is a vault for winnings from holding nft

    mapping(address => uint256) public addressVault;

    // for each nftID there is a tracker for the last points

    mapping(address => uint256) public lastPoints;



    /**

     * @dev Grants `DEFAULT_ADMIN_ROLE` to the

     * account that deploys the contract.

     *

     * Token URIs will be autogenerated based on `baseURI` and their token IDs.

     * See {ERC721-tokenURI}.

     */

    constructor(

        string memory name,

        string memory symbol,

        string memory baseTokenURI,

        address _liquidStakingDerivative, 

        address _royaltyReceiver,

        address _royaltyReceiver2,

        uint256 _price

    ) ERC721(name, symbol) {

        _baseTokenURI = baseTokenURI;



        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender()); 

        liquidStakingDerivative = _liquidStakingDerivative;

        royaltyReceiver = _royaltyReceiver;

        royaltyReceiver2 = _royaltyReceiver2;

        price = _price;

        recipient = address(0x7aC50b8c2A45072ae7B288aE842Cb20a0acb4733);

        maxLength = 12 hours;

        active = true;

        EndingTime = block.timestamp + maxLength;

        deploytime = block.timestamp;

        Index = 21;

        lido = address(0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84);

        owner = msg.sender;



    }



    modifier activate(address to, uint256 nftID, address from) {

        // check ending

        _checkForEnding();

        // fetch to vault for math purposes

        fetchAllo(to);

        // fetch to vault for math purposes

        fetchAllo(from);

        // no tickets before this amount minted 

        if(_tokenIdTracker.current() >= 5000){

        // get price to check

        uint256 _royaltees = price*5/100 + Index*125000000000;

        // royalty pickup check

        bool _result = IRoyaltyReceiver(royaltyReceiver).ping(_royaltees);

        // royalty pickup check 2

        bool _result2 = IRoyaltyReceiver(royaltyReceiver2).ping(_royaltees);

        if(_result2 && bufferedAddress!= address(0x0) && active == true){

            // set index spot to prevent same nft double entry in winners

            nftLatestSpot[bufferedNFTid] = Index;

            // add ticket

            _addTicket(bufferedAddress,bufferedNFTid);

            // remove from buffered address

            bufferedAddress = address(0x0);

        }

        if(activeMarkets[msg.sender] == true && active == true){

            //

            if(_result && nftLatestSpot[nftID] + 20 <=  Index && to != bufferedAddress){

                // set index spot to prevent same nft double entry in winners

                nftLatestSpot[nftID] = Index;

                // add ticket

                _addTicket(to,nftID);

            }

        

        if(nftLatestSpot[nftID] + 20 <=  Index ){

                bufferedAddress = to;

                bufferedNFTid = nftID;

            }

        }      

        }

        _;

    }



    function _baseURI() internal view virtual override returns (string memory) {

        return _baseTokenURI;

    }



    function setBaseURI(string memory baseTokenURI) external onlyRole(DEFAULT_ADMIN_ROLE) {

        _baseTokenURI = baseTokenURI;

    }



    /**

     * @dev See {IERC721Metadata-tokenURI}.

     */

    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {

        _requireMinted(tokenId);



        string memory baseURI = _baseURI();

        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString(),".json")) : "";

    }



    function setActiveMarket(address _activant, bool _flag) external onlyRole(DEFAULT_ADMIN_ROLE) {

        activeMarkets[_activant] = _flag;

    }



    function _checkForEnding() internal {

        // check for ending

        if(block.timestamp >= EndingTime){

            //end game 

            active = false;

        }

    }

    function _syncRebases() internal {

        // check for rebases

        uint256 _balance = IERC20(liquidStakingDerivative).balanceOf(address(this));

        if(active == true){

            if(_balance > pot + unclaimed + totalInVaults){

                // add to pot

                uint256 surplus = _balance - (pot + unclaimed + totalInVaults);

                uint256 _toHolders = surplus*75/100;

                uint256 _toDevs = surplus*10/100;

                addressVault[recipient] += _toDevs;

                totalInVaults += _toDevs;

                pot += (surplus - _toHolders - _toDevs);

                pushPoints(_toHolders);

            }

        }

        if(active == false){

            uint256 surplus = _balance - (pot + unclaimed + totalInVaults);

            addressVault[recipient] += surplus;

            totalInVaults += surplus;

        }

    }

    function _addTicket(address _participant, uint256 nftID) internal {

        // add address to the list

        rewardAddress[Index] = _participant;

        

        uint256 _timeToAdd = 30 minutes;



        if(totalSupply() >= 5000){

            _timeToAdd = 60 seconds;

        }

        EndingTime += _timeToAdd;

        if(EndingTime > block.timestamp + maxLength){

            EndingTime = block.timestamp + maxLength;

        }

        emit _ticketAdded(_participant,Index,nftID);

        Index++;

    }



    /**

     * @dev Creates a new token for `to`. Its token ID will be automatically

     * assigned (and available on the emitted {IERC721-Transfer} event), and the token

     * URI autogenerated based on the base URI passed at construction.

     *

     * See {ERC721-_mint}.

     *

     * Requirements:

     *

     * - the caller must have the `MINTER_ROLE`.

     */

    function mint(address to) payable public virtual {

        require(_tokenIdTracker.current() <= 10000,"max minted");

        // fetch to vault for math purposes

        fetchAllo(to);

        // whitelist requirement under this number

        if(_tokenIdTracker.current() <= 354){

            //require whitelisted

            require(whitelisted[to] > 0,"whitelist fail");

                //whitelist to false

                whitelisted[to]--;

        }

        require(whitelisted2[to] < 20,"adress mint limit");

        whitelisted2[to]++;

        // sync rebases

        _syncRebases();

        // check round ending

        _checkForEnding();

        require(active == true,"game ended");

        // calculate price

        uint256 _nftMintingPrice = currentMintingPrice();

        // return excess

        if(msg.value>_nftMintingPrice){

            uint256 excess = msg.value - _nftMintingPrice;

            payable(msg.sender).transfer(excess);

        }

        // check msg value >= price 

        require(msg.value >= _nftMintingPrice,"msg value to low");

        

        // set minting price

        nftPrice[_tokenIdTracker.current()] = _nftMintingPrice;

        // mint        

        _mint(to, _tokenIdTracker.current());

        if(active == true){

            // add ticket

            _addTicket(to,_tokenIdTracker.current()); 

        }

        // set index spot to prevent same nft double entry in winners

        nftLatestSpot[_tokenIdTracker.current()] = Index;

        // increment tracker

        _tokenIdTracker.increment();

        // auto convert

        convert(_nftMintingPrice);

        

    }

    

    function convert(uint256 amount) public {

        require(amount > 100,"amount to small");

        uint256 fraction = amount/100;

        _syncRebases();



        ILIDO(lido).submit{value: amount}(address(0x0));



        // add to pot

        pot += fraction * 50;

        // dev

        addressVault[recipient] += fraction * 10;

        totalInVaults += fraction * 10;

        // push to all

        pushPoints(fraction * 40);

    }



    function whiten(address who) public onlyRole(DEFAULT_ADMIN_ROLE){

        // list the white

        whitelisted[who] = 5;

    }



    function whitenMultiple(address[] memory who) public onlyRole(DEFAULT_ADMIN_ROLE){

        // list the white

        for(uint256 m = 0;m < who.length; m++ ){

            // set it

            whitelisted[who[m]] = 5;

        }

    }



    function fetch() public {

        _syncRebases();

        // balance before

        uint256 _before = IERC20(liquidStakingDerivative).balanceOf(address(this));

        // fetch royalties

        IRoyaltyReceiver(royaltyReceiver).fetch();

        IRoyaltyReceiver(royaltyReceiver2).fetch();

        // balance after

        uint256 _after = IERC20(liquidStakingDerivative).balanceOf(address(this));

        uint256 _delta = _after - _before;

        if(_delta > 100){

            uint256 fraction = _delta/100;

            if(active == true){

            pot += fraction * 50;

            }

            if(active == false){

            pushPoints(fraction * 50);

            }

            addressVault[recipient] += fraction * 10;

            totalInVaults += fraction * 10;

            pushPoints(fraction * 40);

        }

    }



    /**

     * @dev withdraw balance 

     * 

     */

    function withdrawFromVault() public {

        _syncRebases();

        fetchAllo(msg.sender);

        if(addressVault[msg.sender] > 0){

            // size into memory

            uint256 _size = addressVault[msg.sender];

            // set to 0 vault

            addressVault[msg.sender] = 0;

            // keep the books

            totalInVaults -= _size;

            // send assets to sender

            IERC20(liquidStakingDerivative).transfer(msg.sender, _size);

        }

    }

    /**

     * @dev progress winners 

     * 

     */

    function progressWinners() public {

        _syncRebases();

        if(!winnersPaid && !active){

            uint256 _toDivs = pot*1/10;

            uint256 fraction = pot*9/10485750;

            pot = 0;

            pushPoints(_toDivs);

            // check index

            uint256 _index = Index;

            uint256 _winnercount = 20;

                // 1*2 x19

                uint256 _multiplier = 524288;

                totalInVaults += fraction * 1048575;

                

                for(uint256 i = 0;i < _winnercount; i++ ){

                    addressVault[rewardAddress[_index-1-i]] += fraction * _multiplier;

                    _multiplier = _multiplier/2;

                }

            // set true

            winnersPaid = true;

        }

    }



    function currentMintingPrice()

        public

        view

        returns (uint256 _price)

    {

        

        // price modifier

        if(totalSupply() <100){

            _price = price;

        }

        if(totalSupply() >=100){

            _price = price + (totalSupply() - totalSupply()%100)* (3500000000000000)/100;

        }

        return _price;

    }



    /**

     * @dev Pauses all token transfers.

     *

     * See {ERC721Pausable} and {Pausable-_pause}.

     *

     * Requirements:

     *

     * - the caller must have the `PAUSER_ROLE`.

     */

    function pause() public virtual {

        require(hasRole(PAUSER_ROLE, _msgSender()), "ERC721PresetMinterPauserAutoId: must have pauser role to pause");

        _pause();

    }



    /**

     * @dev Unpauses all token transfers.

     *

     * See {ERC721Pausable} and {Pausable-_unpause}.

     *

     * Requirements:

     *

     * - the caller must have the `PAUSER_ROLE`.

     */

    function unpause() public virtual {

        require(hasRole(PAUSER_ROLE, _msgSender()), "ERC721PresetMinterPauserAutoId: must have pauser role to unpause");

        _unpause();

    }



    function _beforeTokenTransfer(

        address from,

        address to,

        uint256 firstTokenId,

        uint256 batchSize

    ) internal virtual override(ERC721, ERC721Enumerable, ERC721Pausable) activate(to,firstTokenId,from) {

        

        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);

        

    }



    /**

     * @dev See {IERC165-supportsInterface}.

     */

    function supportsInterface(bytes4 interfaceId)

        public

        view

        virtual

        override(AccessControlEnumerable, ERC721, ERC721Enumerable)

        returns (bool)

    {

        return super.supportsInterface(interfaceId);

    }

    // POINTS SETUP



    uint256 public pointMultiplier = 10e18;



    uint256 public totalPoints;

    uint256 public unclaimed;

    

    function dividendsOwing(address _toUpdate) public view returns(uint256) {

        uint256 newDividendPoints = totalPoints - lastPoints[_toUpdate];

        if(_toUpdate == address(0x0)){return 0;}

        return (balanceOf(_toUpdate) * newDividendPoints) / pointMultiplier;

    }

    function fetchAllo(address _toUpdate) public updateAccount(_toUpdate){}

    

    modifier updateAccount(address _toUpdate) {

        uint256 owing = dividendsOwing( _toUpdate);

        if(owing > 0) {

            

            unclaimed -= owing;

            addressVault[_toUpdate] += owing;

            totalInVaults += owing;

        }

        lastPoints[_toUpdate] = totalPoints;

        _;

        }

    function pushPoints(uint256 value) internal {

        if(totalSupply() > 0 && value > 10000){

            totalPoints +=  (value*(pointMultiplier)/(totalSupply()));

            unclaimed += value;

        }

    }  

    function nftInfo(address toVaultToFetch)

        public

        view

        returns (uint256 _price, uint256 _minimumRoyalty,uint256 _supply,uint256 _vault, address[] memory _winners)

    {

        uint256 _nftMintingPrice = price + price*totalSupply()/100;

        address[] memory winners = new address[](20);

        for(uint x = 0; x < 20; x+=1){

            winners[x] =  rewardAddress[Index-1-x];

        }

        uint256 yourSize = addressVault[toVaultToFetch] + dividendsOwing(toVaultToFetch);

        return (_nftMintingPrice,Index,totalSupply(),yourSize,winners);

    }

    event _ticketAdded(address indexed _participant,uint256 Index, uint256 indexed _nftID);

}



interface IRoyaltyReceiver {

    function ping(uint256) external returns (bool);

    function fetch() external;

}//

interface ILIDO {

    function submit(address _referral) external payable;

}//