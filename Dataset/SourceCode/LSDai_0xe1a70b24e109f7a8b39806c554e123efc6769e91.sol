{{

  "language": "Solidity",

  "sources": {

    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"

    },

    "@openzeppelin/contracts/utils/math/Math.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/math/SafeMath.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/math/SignedMath.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/Strings.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"

    },

    "contracts/interfaces/IDai.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IDai is IERC20 {\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function permit(\n    address holder,\n    address spender,\n    uint256 nonce,\n    uint256 expiry,\n    bool allowed,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  function nonces(address owner) external view returns (uint256);\n}\n"

    },

    "contracts/interfaces/IJoin.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\ninterface IJoin {\n  function join(address, uint256) external;\n\n  function exit(address, uint256) external;\n}\n"

    },

    "contracts/interfaces/ILSDai.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title LSDai interface\n * @dev extention of ERC20 interface, with LSDai-specific events\n */\ninterface ILSDai is IERC20 {\n  /**\n   * @notice An executed shares transfer from `sender` to `recipient`.\n   *\n   * @dev emitted in pair with an ERC20-defined `Transfer` event.\n   */\n  event TransferShares(address indexed from, address indexed to, uint256 sharesValue);\n\n  /**\n   * @notice An executed `burnShares` request\n   *\n   * @dev Reports simultaneously burnt shares amount\n   * and corresponding stETH amount.\n   * The stETH amount is calculated twice: before and after the burning incurred rebase.\n   *\n   * @param account holder of the burnt shares\n   * @param preRebaseTokenAmount amount of stETH the burnt shares corresponded to before the burn\n   * @param postRebaseTokenAmount amount of stETH the burnt shares corresponded to after the burn\n   * @param sharesAmount amount of burnt shares\n   */\n  event SharesBurnt(\n    address indexed account, uint256 preRebaseTokenAmount, uint256 postRebaseTokenAmount, uint256 sharesAmount\n  );\n\n  /**\n   * @dev emitted when the DAI deposit cap is set. set `setDepositCap` for more details.\n   */\n  event DepositCapSet(uint256 depositCap);\n\n  /**\n   * @dev emitted when the withdrawal fee is set. set `setWithdrawalFee` for more details.\n   */\n  event WithdrawalFeeSet(uint256 withdrawalFee);\n\n  /**\n   * @dev emitted when the interest fee is set. set `setInterestFee` for more details.\n   */\n  event InterestFeeSet(uint256 interestFee);\n\n  /**\n   * @dev emitted when the fee recipient is set. set `setFeeRecipient` for more details.\n   */\n  event FeeRecipientSet(address indexed recipient);\n\n  /**\n   * @notice The DAI deposit cap.\n   * @dev can be changed by the owner of the contract.\n   */\n  function depositCap() external view returns (uint256);\n\n  /**\n   * @notice the fee recipient.\n   * @dev can be changed by the owner of the contract.\n   */\n  function feeRecipient() external view returns (address);\n\n  /**\n   * @dev Updates the fee recipient. Only callable by the owner.\n   * @param recipient The new fee recipient.\n   */\n  function setFeeRecipient(address recipient) external;\n\n  /**\n   * @notice sets the DAI deposit cap.\n   * @dev can be changed by the owner of the contract.\n   * @param cap the new DAI deposit cap.\n   */\n  function setDepositCap(uint256 cap) external;\n\n  /**\n   * @notice the interest fee percentage in basis points (1/100 of a percent)\n   */\n  function interestFee() external view returns (uint256);\n\n  /**\n   * @notice sets the interest fee percentage in basis points (1/100 of a percent)\n   * @param fee the new interest fee percentage in basis points (1/100 of a percent)\n   */\n  function setInterestFee(uint256 fee) external;\n\n  /**\n   * @notice the withdrawal fee percentage in basis points (1/100 of a percent)\n   */\n  function withdrawalFee() external view returns (uint256);\n\n  /**\n   * @notice sets the withdrawal fee percentage in basis points (1/100 of a percent)\n   * @param fee the new withdrawal fee percentage in basis points (1/100 of a percent)\n   */\n  function setWithdrawalFee(uint256 fee) external;\n\n  /**\n   * @dev initializes the contract.\n   * @param _depositCap the DAI deposit cap.\n   * @param _interestFee the interest fee percentage in basis points (1/100 of a percent)\n   * @param _withdrawalFee the withdrawal fee percentage in basis points (1/100 of a percent)\n   * @param _feeRecipient the address of the fee recipient\n   */\n  function initialize(uint256 _depositCap, uint256 _interestFee, uint256 _withdrawalFee, address _feeRecipient)\n    external\n    returns (bool);\n\n  /**\n   * @dev rebase the total pooled DAI, user balance and total supply of LSDAI.\n   * Can only be called by anyone\n   */\n  function rebase() external;\n\n  /**\n   * @return the amount of tokens in existence.\n   *\n   * @dev Always equals to `_getTotalPooledDai()` since token amount\n   * is pegged to the total amount of DAI controlled by the protocol.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @return the amount of total LSDAI shares\n   */\n  function totalShares() external view returns (uint256);\n\n  ////////////////////////////////////////\n  // User functions //////////////////////\n  ////////////////////////////////////////\n\n  /// getters ///\n  /**\n   * @return the amount of shares owned by `_account`.\n   */\n  function sharesOf(address account) external view returns (uint256);\n\n  /**\n   * @notice Returns the amount of LSDai tokens owned by the `account`.\n   * @dev Balances are dynamic and equal the `account`'s share in the amount of the\n   * total DAI controlled by the protocol. See `sharesOf`.\n   * @param account The address of the account to check the balance of.\n   * @return The amount of LSDai tokens owned by the `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Deposit DAI and mint LSDAI.\n   * @param to The address to mint LSDAI to.\n   * @param daiAmount The amount of DAI to deposit.\n   * @return amount of LSDAI minted.\n   */\n  function deposit(address to, uint256 daiAmount) external returns (uint256);\n\n  /**\n   * @dev Deposit DAI and mint LSDAI using ERC20 permit.\n   * @param to The address to mint LSDAI to.\n   * @param daiAmount The amount of DAI to deposit.\n   * @param permitNonce The nonce of the permit signature.\n   * @param permitExpiry The deadline timestamp, type(uint256).max for no deadline.\n   * @param permitV The recovery byte of the signature.\n   * @param permitR Half of the ECDSA signature pair.\n   * @param permitS Half of the ECDSA signature pair.\n   * @return amount amount of LSDAI minted.\n   */\n  function depositWithPermit(\n    address to,\n    uint256 daiAmount,\n    uint256 permitNonce,\n    uint256 permitExpiry,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external returns (uint256);\n\n  /**\n   * Withdraw DAI from the contract\n   * @param daiAmount The amount of LSDAI to withdraw. wad is denominated in dai\n   */\n  function withdraw(uint256 daiAmount) external returns (bool);\n\n  /**\n   * @notice Returns the amount of LSDai shares that corresponds to `daiAmount` protocol-controlled DAI.\n   * @param daiAmount The amount of protocol-controlled DAI.\n   * @return The amount of LSDai shares that corresponds to `daiAmount` protocol-controlled DAI.\n   */\n  function getSharesByPooledDai(uint256 daiAmount) external view returns (uint256);\n\n  /**\n   * @notice Returns the amount of protocol-controlled DAI that corresponds to `sharesAmount` LSDai shares.\n   * @param sharesAmount The amount of LSDai shares.\n   * @return The amount of protocol-controlled DAI that corresponds to `sharesAmount` LSDai shares.\n   */\n  function getPooledDaiByShares(uint256 sharesAmount) external view returns (uint256);\n}\n"

    },

    "contracts/interfaces/IPot.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\ninterface IPot {\n  function chi() external view returns (uint256);\n\n  function rho() external view returns (uint256);\n\n  function dsr() external view returns (uint256);\n\n  function drip() external returns (uint256);\n\n  function join(uint256) external;\n\n  function exit(uint256) external;\n\n  /**\n   * @notice Return the balance of a given address in this contract. Normalised Savings Dai [wad]\n   */\n  function pie(address) external view returns (uint256);\n}\n"

    },

    "contracts/interfaces/IVat.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\ninterface IVat {\n  function hope(address) external;\n}\n"

    },

    "contracts/libraries/RMath.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n/**\n * @title RMath - math library\n * @notice based on MakerDAO's math function in DSRManager\n */\nlibrary RMath {\n  // --- Math ---\n  uint256 constant RAY = 10 ** 27;\n\n  function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n    // always rounds down\n    z = SafeMath.mul(x, y) / RAY;\n  }\n\n  function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n    // always rounds down\n    z = SafeMath.mul(x, RAY) / y;\n  }\n\n  function rdivup(uint256 x, uint256 y) internal pure returns (uint256 z) {\n    // always rounds up\n    z = SafeMath.add(SafeMath.mul(x, RAY), SafeMath.sub(y, 1)) / y;\n  }\n\n  function rpow(uint256 x, uint256 n) internal pure returns (uint256 z) {\n    assembly {\n      switch x\n      case 0 {\n        switch n\n        case 0 { z := RAY }\n        default { z := 0 }\n      }\n      default {\n        switch mod(n, 2)\n        case 0 { z := RAY }\n        default { z := x }\n        let half := div(RAY, 2) // for rounding.\n        for { n := div(n, 2) } n { n := div(n, 2) } {\n          let xx := mul(x, x)\n          if iszero(eq(div(xx, x), x)) { revert(0, 0) }\n          let xxRound := add(xx, half)\n          if lt(xxRound, xx) { revert(0, 0) }\n          x := div(xxRound, RAY)\n          if mod(n, 2) {\n            let zx := mul(z, x)\n            if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0, 0) }\n            let zxRound := add(zx, half)\n            if lt(zxRound, zx) { revert(0, 0) }\n            z := div(zxRound, RAY)\n          }\n        }\n      }\n    }\n  }\n}\n"

    },

    "contracts/LSDai.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\n// Custom Ownable logic from OZ\nimport {Ownable} from \"./Ownable.sol\";\n\n// Interfaces\nimport {ILSDai} from \"./interfaces/ILSDai.sol\";\n\n// DSR helpers\nimport {RMath} from \"./libraries/RMath.sol\";\nimport {IDai} from \"./interfaces/IDai.sol\";\nimport {IPot} from \"./interfaces/IPot.sol\";\nimport {IJoin} from \"./interfaces/IJoin.sol\";\nimport {IVat} from \"./interfaces/IVat.sol\";\n\n/**\n * @title LSDAI\n * @dev LSDai is a rebasing token that earns interest on DAI deposited in the MakerDAO DSR.\n */\ncontract LSDai is Ownable, ILSDai {\n  error LSDai__AlreadyInitialized();\n  error LSDai__DepositCap();\n  error LSDai__WithdrawalFeeHigh();\n  error LSDai__InterestFeeHigh();\n  error LSDai__TransferToZeroAddress();\n  error LSDai__TransferFromZeroAddress();\n  error LSDai__TransferToLSDaiContract();\n  error LSDai__MintToZeroAddress();\n  error LSDai__BurnFromZeroAddress();\n  error LSDai__SharesAmountExceedsBalance();\n  error LSDai__AmountExceedsBalance();\n  error LSDai__FeeRecipientZeroAddress();\n  error LSDai__RebaseOverflow(uint256 preRebaseTotalPooledDai, uint256 postRebaseTotalPooledDai);\n\n  using SafeMath for uint256;\n  ///////////////////////////\n  //     ERC20 storage     //\n  ///////////////////////////\n\n  /**\n   * @dev Returns the name of the token.\n   */\n  string public name;\n\n  /**\n   * @dev Returns the symbol of the token, usually a shorter version of the\n   * name.\n   */\n  string public symbol;\n\n  /**\n   * @dev Returns the number of decimals used to get its user representation.\n   */\n  uint256 public immutable decimals = 18;\n\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  mapping(address => mapping(address => uint256)) private _allowances;\n\n  /*//////////////////////////////////////////////////////////////\n                                 LSDAI STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @dev LSDAI is initialized.\n   */\n  bool private _initialized;\n\n  /**\n   * @dev LSDAI deposit cap. This is the maximum amount of DAI that can be deposited.\n   */\n  uint256 public depositCap;\n\n  /**\n   * @dev Address shares\n   */\n  mapping(address => uint256) private _shares;\n\n  /**\n   * @dev Total shares of LSDAI\n   */\n  uint256 private _totalLsdaiShares;\n\n  /**\n   * @notice Total amount of DAI controlled by LSDAI at MakerDAO DSR.\n   * @dev This value must be updated before depositing or withdrawing.\n   */\n  uint256 private _totalPooledDai;\n\n  /**\n   * @dev the total amount of pot shares\n   */\n  uint256 private _totalPotShares;\n\n  ///////////////////////////\n  // LSDAI Fee Information //\n  ///////////////////////////\n  /**\n   * @notice Interest fee taken on interest earned, in basis points.\n   */\n  uint256 public interestFee;\n\n  /**\n   * @notice Withdrawal fee taken on exit, in basis points.\n   */\n  uint256 public withdrawalFee;\n\n  /**\n   * @notice Fee recipient address.\n   */\n  address public feeRecipient;\n\n  ///////////////////////////\n  // MakerDAO DSR Contracts //\n  ///////////////////////////\n  IVat public immutable vat = IVat(0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B);\n  IPot public immutable pot = IPot(0x197E90f9FAD81970bA7976f33CbD77088E5D7cf7);\n  IJoin public immutable daiJoin = IJoin(0x9759A6Ac90977b93B58547b4A71c78317f391A28);\n  IDai public immutable dai = IDai(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n\n  /**\n   * @dev initializes the contract.\n   * @param _depositCap the DAI deposit cap.\n   * @param _interestFee the interest fee percentage in basis points (1/100 of a percent)\n   * @param _withdrawalFee the withdrawal fee percentage in basis points (1/100 of a percent)\n   * @param _feeRecipient the address of the fee recipient\n   */\n  function initialize(uint256 _depositCap, uint256 _interestFee, uint256 _withdrawalFee, address _feeRecipient)\n    external\n    returns (bool)\n  {\n    if (_initialized) {\n      revert LSDai__AlreadyInitialized();\n    }\n\n    // Transfer ownership to message sender\n    _transferOwnership(msg.sender);\n\n    // Set ERC20 name and symbol\n    name = \"Liquid Savings DAI\";\n    symbol = \"LSDAI\";\n\n    // Set initial deposit cap to 10m DAI\n    setDepositCap(_depositCap);\n    // Set fee information\n    setFeeRecipient(_feeRecipient);\n    setWithdrawalFee(_withdrawalFee);\n    setInterestFee(_interestFee);\n\n    _initialized = true;\n\n    // Setup the LSDAI contract to be able to interact with the MakerDAO contracts and DAI token\n    vat.hope(address(daiJoin));\n    vat.hope(address(pot));\n    dai.approve(address(daiJoin), type(uint256).max);\n\n    return true;\n  }\n\n  /**\n   * @return the amount of shares owned by `_account`.\n   */\n  function sharesOf(address account) public view returns (uint256) {\n    return _shares[account];\n  }\n\n  /**\n   * @dev returns the amount of pot shares the LSDAI contract has in the DSR pot contract\n   */\n  function potShares() external view returns (uint256) {\n    return pot.pie(address(this));\n  }\n\n  /**\n   * @dev Deposit DAI and mint LSDAI.\n   * @param to The address to mint LSDAI to.\n   * @param daiAmount The amount of DAI to deposit.\n   * @return amount of LSDAI minted.\n   */\n  function deposit(address to, uint256 daiAmount) external returns (uint256) {\n    dai.transferFrom(msg.sender, address(this), daiAmount);\n    return _deposit(to, daiAmount);\n  }\n\n  /**\n   * @dev Deposit DAI and mint LSDAI.\n   * @param to The address to mint LSDAI to.\n   * @param daiAmount The amount of DAI to deposit.\n   * @param permitNonce The nonce of the permit signature.\n   * @param permitExpiry The deadline timestamp, type(uint256).max for no deadline.\n   * @param permitV The recovery byte of the signature.\n   * @param permitR Half of the ECDSA signature pair.\n   * @param permitS Half of the ECDSA signature pair.\n   * @return amount of LSDAI minted.\n   */\n  function depositWithPermit(\n    address to,\n    uint256 daiAmount,\n    uint256 permitNonce,\n    uint256 permitExpiry,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external returns (uint256) {\n    dai.permit(msg.sender, address(this), permitNonce, permitExpiry, true, permitV, permitR, permitS);\n    dai.transferFrom(msg.sender, address(this), daiAmount);\n    return _deposit(to, daiAmount);\n  }\n\n  /**\n   * Withdraw DAI from the contract\n   * @param daiAmount The amount of LSDAI to withdraw. wad is denominated in dai\n   */\n  function withdraw(uint256 daiAmount) external returns (bool) {\n    return _withdraw(msg.sender, msg.sender, daiAmount, withdrawalFee);\n  }\n\n  /**\n   * Withdraw DAI from the contract to a specified address instead of the sender\n   * @param to The address to withdraw LSDAI to.\n   * @param daiAmount The amount of LSDAI to withdraw. wad is denominated in dai\n   */\n  function withdrawTo(address to, uint256 daiAmount) external returns (bool) {\n    return _withdraw(msg.sender, to, daiAmount, withdrawalFee);\n  }\n\n  /**\n   * @dev withdraws the pending protocol fees from the DSR pot to the `feeRecipient`. Only callable by the owner.\n   */\n  function collectFees() external onlyOwner returns (bool) {\n    return _withdraw(feeRecipient, feeRecipient, balanceOf(feeRecipient), 0);\n  }\n\n  /**\n   * @dev Updates the withdrawal fee, possible values between 0 and 0.2%. Only callable by the owner.\n   * @param fee The new withdrawal fee, in basis points.\n   */\n  function setWithdrawalFee(uint256 fee) public onlyOwner {\n    if (fee > 20) {\n      revert LSDai__WithdrawalFeeHigh();\n    }\n\n    withdrawalFee = fee;\n\n    emit WithdrawalFeeSet(fee);\n  }\n\n  /**\n   * @dev Updates the interest fee. Only callable by the owner.\n   * @param fee The new interest fee, in basis points.\n   */\n  function setInterestFee(uint256 fee) public onlyOwner {\n    // Cap at 5% (500 basis points)\n    if (fee > 500) {\n      revert LSDai__InterestFeeHigh();\n    }\n\n    interestFee = fee;\n\n    emit InterestFeeSet(fee);\n  }\n\n  /**\n   * @dev Updates the fee recipient. Only callable by the owner.\n   * @param recipient The new fee recipient.\n   */\n  function setFeeRecipient(address recipient) public onlyOwner {\n    if (recipient == address(0)) {\n      revert LSDai__FeeRecipientZeroAddress();\n    }\n\n    feeRecipient = recipient;\n\n    emit FeeRecipientSet(recipient);\n  }\n\n  /**\n   * @return the amount of tokens owned by the `account`.\n   *\n   * @dev Balances are dynamic and equal the `account`'s share in the amount of the\n   * total DAI controlled by the protocol. See `sharesOf`.\n   */\n  function balanceOf(address account) public view virtual override returns (uint256) {\n    return getPooledDaiByShares(sharesOf(account));\n  }\n\n  /**\n   * @return the amount of shares that corresponds to `daiAmount` protocol-controlled DAI.\n   * @param daiAmount The amount of protocol-controlled DAI.\n   */\n  function getSharesByPooledDai(uint256 daiAmount) public view returns (uint256) {\n    // Prevent division by zero\n    if (_totalPooledDai == 0) {\n      return daiAmount;\n    }\n\n    return daiAmount.mul(_totalLsdaiShares).div(_totalPooledDai);\n  }\n\n  /**\n   * @return the amount of DAI that corresponds to `sharesAmount` token shares.\n   * @param sharesAmount The amount of LSDAI shares.\n   */\n  function getPooledDaiByShares(uint256 sharesAmount) public view returns (uint256) {\n    return sharesAmount.mul(_totalPooledDai).div(_totalLsdaiShares);\n  }\n\n  /**\n   * @return the amount of tokens in existence.\n   *\n   * @dev Always equals to `_getTotalPooledDai()` since token amount\n   * is pegged to the total amount of DAI controlled by the protocol.\n   */\n  function totalSupply() public view override returns (uint256) {\n    return _getTotalPooledDai();\n  }\n\n  /**\n   * @return the amount of total LSDAI shares\n   */\n  function totalShares() public view returns (uint256) {\n    return _totalLsdaiShares;\n  }\n\n  /**\n   * @dev rebase the total pooled DAI, user balance and total supply of LSDAI.\n   * Can only be called by anyone\n   */\n  function rebase() external {\n    uint256 chi = _getMostRecentChi();\n    _rebase(chi, true);\n  }\n\n  /**\n   * @notice Sets deposit cap. Exclusive for the owner.\n   */\n  function setDepositCap(uint256 cap) public onlyOwner {\n    depositCap = cap;\n\n    emit DepositCapSet(cap);\n  }\n\n  /**\n   * Returns DAI balance at the MakerDAO DSR contract.\n   */\n  function getTotalPotSharesValue() external view returns (uint256) {\n    uint256 chi = (block.timestamp > pot.rho())\n      ? (RMath.rpow(pot.dsr(), block.timestamp - pot.rho()) * pot.chi()) / RMath.RAY\n      : pot.chi();\n\n    // total pooled DAI is the total shares times the chi\n    return (_totalPotShares * chi) / RMath.RAY;\n  }\n\n  ///////////////////////////////////////\n  ///////// Internal functions /////////\n  /////////////////////////////////////\n\n  /**\n   * @dev Deposit DAI and mint LSDAI.\n   * @param _to The address to mint LSDAI to.\n   * @param _daiAmount The amount of DAI to deposit.\n   * @return shares amount of LSDAI minted.\n   */\n  function _deposit(address _to, uint256 _daiAmount) internal returns (uint256 shares) {\n    // Check if the deposit cap is reached\n    if (depositCap > 0 && _getTotalPooledDai().add(_daiAmount) > depositCap) {\n      revert LSDai__DepositCap();\n    }\n\n    uint256 chi = _getMostRecentChi();\n\n    // Calculate the amount of pot shares to mint\n    uint256 potSharesAmount = RMath.rdiv(_daiAmount, chi);\n\n    // Mint the shares to the user\n    shares = getSharesByPooledDai(_daiAmount);\n    _mintShares(_to, shares);\n\n    // Increase the total amount of DAI pooled\n    _totalPooledDai = _totalPooledDai.add(_daiAmount);\n    // Keep track of total pot shares controlled by LSDAI\n    _totalPotShares = _totalPotShares.add(potSharesAmount);\n\n    // Mint LSDAI at 1:1 ratio to DAI\n    emit Transfer(address(0), _to, _daiAmount);\n\n    // Join the DSR on behalf of the user\n    daiJoin.join(address(this), _daiAmount);\n    pot.join(potSharesAmount);\n  }\n\n  /**\n   * Withdraw shares back to DAI\n   * @param _from The address to withdraw LSDAI from.\n   * @param _to The address to withdraw DAI to.\n   * @param _daiAmount The amount of LSDAI to withdraw. wad is denominated in (1/chi) * dai\n   * @param _withdrawFee The fee to be charged on the withdrawal, in basis points.\n   */\n  function _withdraw(address _from, address _to, uint256 _daiAmount, uint256 _withdrawFee) internal returns (bool) {\n    uint256 currentDaiBalance = balanceOf(_from);\n    // Check if the user has enough LSDAI\n    if (_daiAmount > currentDaiBalance) {\n      revert LSDai__AmountExceedsBalance();\n    }\n    uint256 chi = _getMostRecentChi();\n\n    // Split the amount into the fee and the actual withdrawal\n    uint256 feeAmount = _daiAmount.mul(_withdrawFee).div(10_000);\n    // Amount going to the user\n    uint256 withdrawAmount = _daiAmount.sub(feeAmount);\n\n    // Transfer the fee shares to fee recipient\n    // and burn the withdraw shares from the user\n    uint256 feeShares = getSharesByPooledDai(feeAmount);\n    uint256 withdrawShares = getSharesByPooledDai(withdrawAmount);\n\n    // Decrease the total amount of DAI pooled\n    _totalPooledDai = _totalPooledDai.sub(withdrawAmount);\n\n    _transferShares(_from, feeRecipient, feeShares);\n    _burnShares(_from, withdrawShares);\n\n    // Withdraw from the DSR, roudning up ensures we get at least the amount of DAI requested\n    uint256 withdrawPotShares = RMath.rdivup(withdrawAmount, chi);\n    // Reduce the total pot shares controlled by LSDAI\n    _totalPotShares = _totalPotShares.sub(withdrawPotShares);\n\n    // Burn LSDAI at 1:1 ratio to DAI\n    emit Transfer(_from, address(0), withdrawAmount);\n\n    // Get back the DAI from the DSR to the contract\n    pot.exit(withdrawPotShares);\n\n    daiJoin.exit(address(this), withdrawAmount); // wad is in dai units\n\n    // Send it over\n    return dai.transfer(_to, withdrawAmount);\n  }\n\n  /**\n   * @notice Destroys `_sharesAmount` shares from `_account`'s holdings, decreasing the total amount of shares.\n   * @dev This doesn't decrease the token total supply.\n   *\n   * Requirements:\n   *\n   * - `_account` cannot be the zero address.\n   * - `_account` must hold at least `_sharesAmount` shares.\n   * - the contract must not be paused.\n   */\n  function _burnShares(address _account, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n    if (_account == address(0)) {\n      revert LSDai__BurnFromZeroAddress();\n    }\n\n    uint256 accountShares = _shares[_account];\n\n    if (_sharesAmount > accountShares) {\n      revert LSDai__SharesAmountExceedsBalance();\n    }\n\n    uint256 preRebaseTokenAmount = getPooledDaiByShares(_sharesAmount);\n\n    newTotalShares = _totalLsdaiShares.sub(_sharesAmount);\n\n    _totalLsdaiShares = newTotalShares;\n\n    _shares[_account] = accountShares.sub(_sharesAmount);\n\n    uint256 postRebaseTokenAmount = getPooledDaiByShares(_sharesAmount);\n\n    emit SharesBurnt(_account, preRebaseTokenAmount, postRebaseTokenAmount, _sharesAmount);\n\n    // Notice: we're not emitting a Transfer event to the zero address here since shares burn\n    // works by redistributing the amount of tokens corresponding to the burned shares between\n    // all other token holders. The total supply of the token doesn't change as the result.\n    // This is equivalent to performing a send from `address` to each other token holder address,\n    // but we cannot reflect this as it would require sending an unbounded number of events.\n\n    // We're emitting `SharesBurnt` event to provide an explicit rebase log record nonetheless.\n  }\n\n  /**\n   * @dev See {IERC20-allowance}.\n   */\n  function allowance(address owner, address spender) public view virtual override returns (uint256) {\n    return _allowances[owner][spender];\n  }\n\n  /**\n   * @dev See {IERC20-approve}.\n   *\n   * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n   * `transferFrom`. This is semantically equivalent to an infinite approval.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function approve(address spender, uint256 amount) public virtual override returns (bool) {\n    address owner = msg.sender;\n    _approve(owner, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Moves `_amount` tokens from the caller's account to the `_recipient` account.\n   *\n   * @return a boolean value indicating whether the operation succeeded.\n   * Emits a `Transfer` event.\n   * Emits a `TransferShares` event.\n   *\n   * Requirements:\n   *\n   * - `_recipient` cannot be the zero address.\n   * - the caller must have a balance of at least `_amount`.\n   * - the contract must not be paused.\n   *\n   * @dev The `_amount` argument is the amount of tokens, not shares.\n   */\n  function transfer(address _recipient, uint256 _amount) public override returns (bool) {\n    _transfer(msg.sender, _recipient, _amount);\n    return true;\n  }\n\n  /**\n   * @notice Moves `_amount` tokens from `_sender` to `_recipient` using the\n   * allowance mechanism. `_amount` is then deducted from the caller's\n   * allowance.\n   *\n   * @return a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a `Transfer` event.\n   * Emits a `TransferShares` event.\n   * Emits an `Approval` event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `_sender` and `_recipient` cannot be the zero addresses.\n   * - `_sender` must have a balance of at least `_amount`.\n   * - the caller must have allowance for `_sender`'s tokens of at least `_amount`.\n   * - the contract must not be paused.\n   *\n   * @dev The `_amount` argument is the amount of tokens, not shares.\n   */\n  function transferFrom(address _sender, address _recipient, uint256 _amount) external override returns (bool) {\n    _spendAllowance(_sender, msg.sender, _amount);\n    _transfer(_sender, _recipient, _amount);\n    return true;\n  }\n\n  /**\n   * @notice Moves `_sharesAmount` token shares from the caller's account to the `_recipient` account.\n   *\n   * @return amount of transferred tokens.\n   * Emits a `TransferShares` event.\n   * Emits a `Transfer` event.\n   *\n   * Requirements:\n   *\n   * - `_recipient` cannot be the zero address.\n   * - the caller must have at least `_sharesAmount` shares.\n   * - the contract must not be paused.\n   *\n   * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n   */\n  function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256) {\n    _transferShares(msg.sender, _recipient, _sharesAmount);\n    uint256 tokensAmount = getPooledDaiByShares(_sharesAmount);\n    _emitTransferEvents(msg.sender, _recipient, tokensAmount, _sharesAmount);\n    return tokensAmount;\n  }\n\n  /**\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {IERC20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n    address owner = msg.sender;\n    _approve(owner, spender, allowance(owner, spender) + addedValue);\n    return true;\n  }\n\n  /**\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {IERC20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   * - `spender` must have allowance for the caller of at least\n   * `subtractedValue`.\n   */\n  function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n    address owner = msg.sender;\n    uint256 currentAllowance = allowance(owner, spender);\n    require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n    unchecked {\n      _approve(owner, spender, currentAllowance - subtractedValue);\n    }\n\n    return true;\n  }\n\n  /**\n   * @notice Moves `_sharesAmount` token shares from the `_sender` account to the `_recipient` account.\n   *\n   * @return amount of transferred tokens.\n   * Emits a `TransferShares` event.\n   * Emits a `Transfer` event.\n   *\n   * Requirements:\n   *\n   * - `_sender` and `_recipient` cannot be the zero addresses.\n   * - `_sender` must have at least `_sharesAmount` shares.\n   * - the caller must have allowance for `_sender`'s tokens of at least `getPooledDaiByShares(_sharesAmount)`.\n   * - the contract must not be paused.\n   *\n   * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n   */\n  function transferSharesFrom(address _sender, address _recipient, uint256 _sharesAmount) external returns (uint256) {\n    uint256 tokensAmount = getPooledDaiByShares(_sharesAmount);\n    _spendAllowance(_sender, msg.sender, tokensAmount);\n    _transferShares(_sender, _recipient, _sharesAmount);\n    _emitTransferEvents(_sender, _recipient, tokensAmount, _sharesAmount);\n    return tokensAmount;\n  }\n\n  /**\n   * @notice Moves `_amount` tokens from `_sender` to `_recipient`.\n   * Emits a `Transfer` event.\n   * Emits a `TransferShares` event.\n   */\n  function _transfer(address _sender, address _recipient, uint256 _amount) internal {\n    uint256 _sharesToTransfer = getSharesByPooledDai(_amount);\n    _transferShares(_sender, _recipient, _sharesToTransfer);\n    _emitTransferEvents(_sender, _recipient, _amount, _sharesToTransfer);\n  }\n\n  /**\n   * @notice Moves `_sharesAmount` shares from `_sender` to `_recipient`.\n   *\n   * Requirements:\n   *\n   * - `_sender` cannot be the zero address.\n   * - `_recipient` cannot be the zero address or the `LSDai` token contract itself\n   * - `_sender` must hold at least `_sharesAmount` shares.\n   * - the contract must not be paused.\n   */\n  function _transferShares(address _sender, address _recipient, uint256 _sharesAmount) internal {\n    if (_sender == address(0)) {\n      revert LSDai__TransferFromZeroAddress();\n    }\n    if (_recipient == address(0)) {\n      revert LSDai__TransferToZeroAddress();\n    }\n\n    if (_recipient == address(this)) {\n      revert LSDai__TransferToLSDaiContract();\n    }\n\n    // _whenNotStopped();\n\n    uint256 currentSenderShares = _shares[_sender];\n\n    if (_sharesAmount > currentSenderShares) {\n      revert LSDai__SharesAmountExceedsBalance();\n    }\n\n    _shares[_sender] = currentSenderShares.sub(_sharesAmount);\n    _shares[_recipient] = _shares[_recipient].add(_sharesAmount);\n  }\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n   *\n   * This internal function is equivalent to `approve`, and can be used to\n   * e.g. set automatic allowances for certain subsystems, etc.\n   *\n   * Emits an {Approval} event.\n   *\n   * Requirements:\n   *\n   * - `owner` cannot be the zero address.\n   * - `spender` cannot be the zero address.\n   */\n  function _approve(address owner, address spender, uint256 amount) internal {\n    require(owner != address(0), \"ERC20: approve from the zero address\");\n    require(spender != address(0), \"ERC20: approve to the zero address\");\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  /**\n   * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n   *\n   * Does not update the allowance amount in case of infinite allowance.\n   * Revert if not enough allowance is available.\n   *\n   * Might emit an {Approval} event.\n   */\n  function _spendAllowance(address owner, address spender, uint256 amount) internal {\n    uint256 currentAllowance = allowance(owner, spender);\n    if (currentAllowance != type(uint256).max) {\n      require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n      unchecked {\n        _approve(owner, spender, currentAllowance - amount);\n      }\n    }\n  }\n\n  /**\n   * @dev Emits {Transfer} and {TransferShares} events\n   */\n  function _emitTransferEvents(address _from, address _to, uint256 _tokenAmount, uint256 _sharesAmount) internal {\n    emit Transfer(_from, _to, _tokenAmount);\n    emit TransferShares(_from, _to, _sharesAmount);\n  }\n\n  /**\n   * @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.\n   * @dev This doesn't increase the token total supply.\n   *\n   * NB: The method doesn't check protocol pause relying on the external enforcement.\n   *\n   * Requirements:\n   *\n   * - `_to` cannot be the zero address.\n   * - the contract must not be paused.\n   */\n  function _mintShares(address _to, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n    if (_to == address(0)) {\n      revert LSDai__TransferToZeroAddress();\n    }\n\n    newTotalShares = _totalLsdaiShares.add(_sharesAmount);\n\n    /// @todo research a better place for the storage location for the total shares\n    _totalLsdaiShares = newTotalShares;\n\n    _shares[_to] = _shares[_to].add(_sharesAmount);\n  }\n\n  /**\n   * @dev updates the total amount of DAI controlled by LSDai.\n   * @param chi If overrideChi is greater than 0, it will use that chi instead of the most recent chi.\n   * @param requireSuccess If true, it will revert if the delta pooled DAI underflows or overflows.\n   * It also calcuates the fees on the accrued interest and appends them to the protocol fee pot.chi();\n   */\n  function _rebase(uint256 chi, bool requireSuccess) internal {\n    uint256 preRebaseTotalPooledDai = _totalPooledDai;\n    // total pooled DAI is the total shares times the chi\n    uint256 postRebaseTotalPooledDai = (_totalPotShares * chi) / RMath.RAY;\n\n    // Change in total pooled DAI is the total pooled DAI before fees minus the total pooled DAI after fees\n    (bool isOk, uint256 deltaTotalPooledDai) = postRebaseTotalPooledDai.trySub(_totalPooledDai); // Interest earned since last rebase\n\n    // Revert with custom error in event of underflow/overflow\n    if (isOk == false && requireSuccess == true) {\n      revert LSDai__RebaseOverflow(preRebaseTotalPooledDai, postRebaseTotalPooledDai);\n    } else if (isOk == false) {\n      return;\n    }\n\n    // Update total pooled DAI\n    _totalPooledDai = postRebaseTotalPooledDai;\n\n    // Get the fees on accrued interest\n    uint256 protocolFeeDaiAmount = _calcInterestFees(deltaTotalPooledDai);\n\n    // Mint LSdai shares to the protocol\n    uint256 protocolFeeLsdaiShares = getSharesByPooledDai(protocolFeeDaiAmount);\n    _mintShares(feeRecipient, protocolFeeLsdaiShares);\n  }\n\n  /**\n   * Returns the total supply of LSDAI by converting the DSR shares to DAI\n   */\n  function _getTotalPooledDai() internal view returns (uint256) {\n    return _totalPooledDai;\n  }\n\n  /**\n   * @dev Calculates the fees on the accrued interest\n   * @param _daiAmount The change in total pooled DAI since the last rebase\n   */\n  function _calcInterestFees(uint256 _daiAmount) internal view returns (uint256 protocolFee) {\n    if (interestFee == 0) {\n      return 0;\n    }\n\n    protocolFee = _daiAmount.mul(interestFee).div(10_000);\n  }\n\n  /**\n   * @dev returns most recent chi (the rate accumulator) by calling drip if necessary\n   */\n  function _getMostRecentChi() internal returns (uint256) {\n    if (block.timestamp > pot.rho()) {\n      return pot.drip();\n    }\n    return pot.chi();\n  }\n}\n"

    },

    "contracts/Ownable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable {\n  address private _owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    _checkOwner();\n    _;\n  }\n\n  /**\n   * @dev Returns the address of the current owner.\n   */\n  function owner() public view virtual returns (address) {\n    return _owner;\n  }\n\n  /**\n   * @dev Throws if the sender is not the owner.\n   */\n  function _checkOwner() internal view virtual {\n    require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n  }\n\n  /**\n   * @dev Leaves the contract without owner. It will not be possible to call\n   * `onlyOwner` functions. Can only be called by the current owner.\n   *\n   * NOTE: Renouncing ownership will leave the contract without an owner,\n   * thereby disabling any functionality that is only available to the owner.\n   */\n  function renounceOwnership() public virtual onlyOwner {\n    _transferOwnership(address(0));\n  }\n\n  /**\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\n   * Can only be called by the current owner.\n   */\n  function transferOwnership(address newOwner) public virtual onlyOwner {\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n    _transferOwnership(newOwner);\n  }\n\n  /**\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\n   * Internal function without access restriction.\n   */\n  function _transferOwnership(address newOwner) internal virtual {\n    address oldOwner = _owner;\n    _owner = newOwner;\n    emit OwnershipTransferred(oldOwner, newOwner);\n  }\n}\n"

    }

  },

  "settings": {

    "optimizer": {

      "enabled": true,

      "runs": 200

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "libraries": {}

  }

}}