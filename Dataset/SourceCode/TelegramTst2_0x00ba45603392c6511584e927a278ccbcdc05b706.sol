// SPDX-License-Identifier: MIT



pragma solidity 0.8.19;



abstract contract Context {

    function _msgSender() internal view virtual returns (address) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes calldata) {

        return msg.data;

    }

}



abstract contract Ownable is Context {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev Initializes the contract setting the deployer as the initial owner.

     */

    constructor() {

        _transferOwnership(_msgSender());

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        _checkOwner();

        _;

    }



    /**

     * @dev Returns the address of the current owner.

     */

    function owner() public view virtual returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if the sender is not the owner.

     */

    function _checkOwner() internal view virtual {

        require(owner() == _msgSender(), "Ownable: caller is not the owner");

    }



    /**

     * @dev Leaves the contract without owner. It will not be possible to call

     * `onlyOwner` functions anymore. Can only be called by the current owner.

     *

     * NOTE: Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public virtual onlyOwner {

        _transferOwnership(address(0));

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Can only be called by the current owner.

     */

    function transferOwnership(address newOwner) public virtual onlyOwner {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Internal function without access restriction.

     */

    function _transferOwnership(address newOwner) internal virtual {

        address oldOwner = _owner;

        _owner = newOwner;

        emit OwnershipTransferred(oldOwner, newOwner);

    }

}



/**

 * @dev Interface of the ERC20 standard as defined in the EIP.

 */

interface IERC20 {

    /**

     * @dev Emitted when `value` tokens are moved from one account (`from`) to

     * another (`to`).

     *

     * Note that `value` may be zero.

     */

    event Transfer(address indexed from, address indexed to, uint256 value);



    /**

     * @dev Emitted when the allowance of a `spender` for an `owner` is set by

     * a call to {approve}. `value` is the new allowance.

     */

    event Approval(address indexed owner, address indexed spender, uint256 value);



    /**

     * @dev Returns the amount of tokens in existence.

     */

    function totalSupply() external view returns (uint256);



    /**

     * @dev Returns the amount of tokens owned by `account`.

     */

    function balanceOf(address account) external view returns (uint256);



    /**

     * @dev Moves `amount` tokens from the caller's account to `to`.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transfer(address to, uint256 amount) external returns (bool);



    /**

     * @dev Returns the remaining number of tokens that `spender` will be

     * allowed to spend on behalf of `owner` through {transferFrom}. This is

     * zero by default.

     *

     * This value changes when {approve} or {transferFrom} are called.

     */

    function allowance(address owner, address spender) external view returns (uint256);



    /**

     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * IMPORTANT: Beware that changing an allowance with this method brings the risk

     * that someone may use both the old and the new allowance by unfortunate

     * transaction ordering. One possible solution to mitigate this race

     * condition is to first reduce the spender's allowance to 0 and set the

     * desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     *

     * Emits an {Approval} event.

     */

    function approve(address spender, uint256 amount) external returns (bool);



    /**

     * @dev Moves `amount` tokens from `from` to `to` using the

     * allowance mechanism. `amount` is then deducted from the caller's

     * allowance.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transferFrom(

        address from,

        address to,

        uint256 amount

    ) external returns (bool);

}



/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.

/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)

/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)

/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.

abstract contract ERC20 {

    /*//////////////////////////////////////////////////////////////

                                 EVENTS

    //////////////////////////////////////////////////////////////*/



    event Transfer(address indexed from, address indexed to, uint256 amount);



    event Approval(address indexed owner, address indexed spender, uint256 amount);



    /*//////////////////////////////////////////////////////////////

                            METADATA STORAGE

    //////////////////////////////////////////////////////////////*/



    string public name;



    string public symbol;



    uint8 public immutable decimals;



    /*//////////////////////////////////////////////////////////////

                              ERC20 STORAGE

    //////////////////////////////////////////////////////////////*/



    uint256 public totalSupply;



    mapping(address => uint256) public balanceOf;



    mapping(address => mapping(address => uint256)) public allowance;



    /*//////////////////////////////////////////////////////////////

                            EIP-2612 STORAGE

    //////////////////////////////////////////////////////////////*/



    uint256 internal immutable INITIAL_CHAIN_ID;



    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;



    mapping(address => uint256) public nonces;



    /*//////////////////////////////////////////////////////////////

                               CONSTRUCTOR

    //////////////////////////////////////////////////////////////*/



    constructor(

        string memory _name,

        string memory _symbol,

        uint8 _decimals

    ) {

        name = _name;

        symbol = _symbol;

        decimals = _decimals;



        INITIAL_CHAIN_ID = block.chainid;

        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();

    }



    /*//////////////////////////////////////////////////////////////

                               ERC20 LOGIC

    //////////////////////////////////////////////////////////////*/



    function approve(address spender, uint256 amount) public virtual returns (bool) {

        allowance[msg.sender][spender] = amount;



        emit Approval(msg.sender, spender, amount);



        return true;

    }

    function _transfer(

        address sender,

        address recipient,

        uint256 amount

    ) internal virtual {

        require(sender != address(0), "ERC20: transfer from the zero address");

        require(recipient != address(0), "ERC20: transfer to the zero address");



        uint256 senderBalance = balanceOf[sender];

        require(senderBalance >= amount, "ERC20: transfer amount exceeds balance");

        unchecked {

            balanceOf[sender] = senderBalance - amount;

        }

        balanceOf[recipient] += amount;



        emit Transfer(sender, recipient, amount);

    }



    function transfer(address to, uint256 amount) public virtual returns (bool) {

        balanceOf[msg.sender] -= amount;



        // Cannot overflow because the sum of all user

        // balances can't exceed the max uint256 value.

        unchecked {

            balanceOf[to] += amount;

        }



        emit Transfer(msg.sender, to, amount);



        return true;

    }



    function transferFrom(

        address from,

        address to,

        uint256 amount

    ) public virtual returns (bool) {

        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.



        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;



        balanceOf[from] -= amount;



        // Cannot overflow because the sum of all user

        // balances can't exceed the max uint256 value.

        unchecked {

            balanceOf[to] += amount;

        }



        emit Transfer(from, to, amount);



        return true;

    }



    /*//////////////////////////////////////////////////////////////

                             EIP-2612 LOGIC

    //////////////////////////////////////////////////////////////*/



    function permit(

        address owner,

        address spender,

        uint256 value,

        uint256 deadline,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) public virtual {

        require(deadline >= block.timestamp, "PERMIT_DEADLINE_EXPIRED");



        // Unchecked because the only math done is incrementing

        // the owner's nonce which cannot realistically overflow.

        unchecked {

            address recoveredAddress = ecrecover(

                keccak256(

                    abi.encodePacked(

                        "\x19\x01",

                        DOMAIN_SEPARATOR(),

                        keccak256(

                            abi.encode(

                                keccak256(

                                    "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"

                                ),

                                owner,

                                spender,

                                value,

                                nonces[owner]++,

                                deadline

                            )

                        )

                    )

                ),

                v,

                r,

                s

            );



            require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNER");



            allowance[recoveredAddress][spender] = value;

        }



        emit Approval(owner, spender, value);

    }



    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {

        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();

    }



    function computeDomainSeparator() internal view virtual returns (bytes32) {

        return

            keccak256(

                abi.encode(

                    keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),

                    keccak256(bytes(name)),

                    keccak256("1"),

                    block.chainid,

                    address(this)

                )

            );

    }



    /*//////////////////////////////////////////////////////////////

                        INTERNAL MINT/BURN LOGIC

    //////////////////////////////////////////////////////////////*/



    function _mint(address to, uint256 amount) internal virtual {

        totalSupply += amount;



        // Cannot overflow because the sum of all user

        // balances can't exceed the max uint256 value.

        unchecked {

            balanceOf[to] += amount;

        }



        emit Transfer(address(0), to, amount);

    }



    function _burn(address from, uint256 amount) internal virtual {

        balanceOf[from] -= amount;



        // Cannot underflow because a user's balance

        // will never be larger than the total supply.

        unchecked {

            totalSupply -= amount;

        }



        emit Transfer(from, address(0), amount);

    }

}



interface IUniswapV2Factory {

    event PairCreated(address indexed token0, address indexed token1, address pair, uint);



    function feeTo() external view returns (address);

    function feeToSetter() external view returns (address);



    function getPair(address tokenA, address tokenB) external view returns (address pair);

    function allPairs(uint) external view returns (address pair);

    function allPairsLength() external view returns (uint);



    function createPair(address tokenA, address tokenB) external returns (address pair);



    function setFeeTo(address) external;

    function setFeeToSetter(address) external;

}



interface IUniswapV2Pair {

    event Approval(address indexed owner, address indexed spender, uint value);

    event Transfer(address indexed from, address indexed to, uint value);



    function name() external pure returns (string memory);

    function symbol() external pure returns (string memory);

    function decimals() external pure returns (uint8);

    function totalSupply() external view returns (uint);

    function balanceOf(address owner) external view returns (uint);

    function allowance(address owner, address spender) external view returns (uint);



    function approve(address spender, uint value) external returns (bool);

    function transfer(address to, uint value) external returns (bool);

    function transferFrom(address from, address to, uint value) external returns (bool);



    function DOMAIN_SEPARATOR() external view returns (bytes32);

    function PERMIT_TYPEHASH() external pure returns (bytes32);

    function nonces(address owner) external view returns (uint);



    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;



    event Mint(address indexed sender, uint amount0, uint amount1);

    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);

    event Swap(

        address indexed sender,

        uint amount0In,

        uint amount1In,

        uint amount0Out,

        uint amount1Out,

        address indexed to

    );

    event Sync(uint112 reserve0, uint112 reserve1);



    function MINIMUM_LIQUIDITY() external pure returns (uint);

    function factory() external view returns (address);

    function token0() external view returns (address);

    function token1() external view returns (address);

    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);

    function price0CumulativeLast() external view returns (uint);

    function price1CumulativeLast() external view returns (uint);

    function kLast() external view returns (uint);



    function mint(address to) external returns (uint liquidity);

    function burn(address to) external returns (uint amount0, uint amount1);

    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;

    function skim(address to) external;

    function sync() external;



    function initialize(address, address) external;

}



interface IUniswapV2Router01 {

    function factory() external pure returns (address);

    function WETH() external pure returns (address);



    function addLiquidity(

        address tokenA,

        address tokenB,

        uint amountADesired,

        uint amountBDesired,

        uint amountAMin,

        uint amountBMin,

        address to,

        uint deadline

    ) external returns (uint amountA, uint amountB, uint liquidity);

    function addLiquidityETH(

        address token,

        uint amountTokenDesired,

        uint amountTokenMin,

        uint amountETHMin,

        address to,

        uint deadline

    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);

    function removeLiquidity(

        address tokenA,

        address tokenB,

        uint liquidity,

        uint amountAMin,

        uint amountBMin,

        address to,

        uint deadline

    ) external returns (uint amountA, uint amountB);

    function removeLiquidityETH(

        address token,

        uint liquidity,

        uint amountTokenMin,

        uint amountETHMin,

        address to,

        uint deadline

    ) external returns (uint amountToken, uint amountETH);

    function removeLiquidityWithPermit(

        address tokenA,

        address tokenB,

        uint liquidity,

        uint amountAMin,

        uint amountBMin,

        address to,

        uint deadline,

        bool approveMax, uint8 v, bytes32 r, bytes32 s

    ) external returns (uint amountA, uint amountB);

    function removeLiquidityETHWithPermit(

        address token,

        uint liquidity,

        uint amountTokenMin,

        uint amountETHMin,

        address to,

        uint deadline,

        bool approveMax, uint8 v, bytes32 r, bytes32 s

    ) external returns (uint amountToken, uint amountETH);

    function swapExactTokensForTokens(

        uint amountIn,

        uint amountOutMin,

        address[] calldata path,

        address to,

        uint deadline

    ) external returns (uint[] memory amounts);

    function swapTokensForExactTokens(

        uint amountOut,

        uint amountInMax,

        address[] calldata path,

        address to,

        uint deadline

    ) external returns (uint[] memory amounts);

    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)

        external

        payable

        returns (uint[] memory amounts);

    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)

        external

        returns (uint[] memory amounts);

    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)

        external

        returns (uint[] memory amounts);

    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)

        external

        payable

        returns (uint[] memory amounts);



    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);

    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);

    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);

    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);

    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);

}



interface IUniswapV2Router02 is IUniswapV2Router01 {

    function removeLiquidityETHSupportingFeeOnTransferTokens(

        address token,

        uint liquidity,

        uint amountTokenMin,

        uint amountETHMin,

        address to,

        uint deadline

    ) external returns (uint amountETH);

    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(

        address token,

        uint liquidity,

        uint amountTokenMin,

        uint amountETHMin,

        address to,

        uint deadline,

        bool approveMax, uint8 v, bytes32 r, bytes32 s

    ) external returns (uint amountETH);



    function swapExactTokensForTokensSupportingFeeOnTransferTokens(

        uint amountIn,

        uint amountOutMin,

        address[] calldata path,

        address to,

        uint deadline

    ) external;

    function swapExactETHForTokensSupportingFeeOnTransferTokens(

        uint amountOutMin,

        address[] calldata path,

        address to,

        uint deadline

    ) external payable;

    function swapExactTokensForETHSupportingFeeOnTransferTokens(

        uint amountIn,

        uint amountOutMin,

        address[] calldata path,

        address to,

        uint deadline

    ) external;

}



contract tst2 is ERC20, Ownable {



    uint256 public maxWalletAmount;



    IUniswapV2Router02 public dexRouter;

    address public lpPair;



    bool private swapping;

    uint256 public swapTokensAtAmount;



    address operationsAddress;

    address public escrowContract;



    uint256 public tradingActiveBlock = 0; // 0 means trading is not active

    uint256 public blockForPenaltyEnd;

    mapping (address => bool) public boughtEarly;



    bool public limitsInEffect = true;

    bool public tradingActive = false;

    bool public swapEnabled = false;



    uint256 public buyTotalFees;

    uint256 public sellTotalFees;

    uint256 public tokensForOperations;



    mapping (address => bool) private _isExcludedFromFees;

    mapping (address => bool) public _isExcludedMaxTransactionAmount;



    mapping (address => bool) public automatedMarketMakerPairs;



    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);



    event EnabledTrading();



    event RemovedLimits();



    event ExcludeFromFees(address indexed account, bool isExcluded);



    event UpdatedMaxWalletAmount(uint256 newAmount);



    event UpdatedOperationsAddress(address indexed newWallet);



    event MaxTransactionExclusion(address _address, bool excluded);



    event OwnerForcedSwapBack(uint256 timestamp);



    event SwapAndLiquify(

        uint256 tokensSwapped,

        uint256 ethReceived,

        uint256 tokensIntoLiquidity

    );



    constructor() ERC20("testg", "tst", 8) {



        address newOwner = msg.sender; // can leave alone if owner is deployer.



        IUniswapV2Router02 _dexRouter = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);

        dexRouter = _dexRouter;



        // create pair

        lpPair = IUniswapV2Factory(_dexRouter.factory()).createPair(address(this), _dexRouter.WETH());

        allowance[address(this)][address(dexRouter)] = type(uint).max;

        _excludeFromMaxTransaction(address(lpPair), true);

        _setAutomatedMarketMakerPair(address(lpPair), true);

        _excludeFromMaxTransaction(newOwner, true);

        _excludeFromMaxTransaction(address(this), true);

        _excludeFromMaxTransaction(address(0xdead), true);



        excludeFromFees(newOwner, true);

        excludeFromFees(address(this), true);

        excludeFromFees(address(0xdead), true);

        uint256 totalSupply = 10000000 * 1e18;

        maxWalletAmount = totalSupply * 3 / 100;

        swapTokensAtAmount = totalSupply * 5 / 10000;



        buyTotalFees = 5;

        sellTotalFees = 5;

        operationsAddress = address(newOwner);



        _mint(newOwner, totalSupply);

        transferOwnership(newOwner);

    }



    receive() external payable {}

    function enableTrading() external onlyOwner {

        require(!tradingActive, "Cannot reenable trading");

        tradingActive = true;

        swapEnabled = true;

        tradingActiveBlock = block.number;

        blockForPenaltyEnd = tradingActiveBlock;

        emit EnabledTrading();

    }

    function burn(uint amount) external {

        _burn(msg.sender, amount);

    }



    // remove limits when needed

    function removeLimits() external onlyOwner {

        limitsInEffect = false;

        emit RemovedLimits();

    }



    function manageBlacklist(address wallet, bool flag) external onlyOwner {

        boughtEarly[wallet] = flag;

    }



    function massManageBlacklist(address[] calldata wallets, bool flag) external onlyOwner {

        for(uint256 i = 0; i < wallets.length; i++){

            boughtEarly[wallets[i]] = flag;

        }

    }



    function updateMaxBuyPerWalletAmount(uint256 newNum) external onlyOwner {

        require(newNum >= (totalSupply * 3 / 1000)/1e18, "Cannot set max wallet amount lower than 0.3%");

        maxWalletAmount = newNum * (10**18);

        emit UpdatedMaxWalletAmount(maxWalletAmount);

    }



    // change the minimum amount of tokens to swap

    function updateSwapTokensAmount(uint256 newAmount) external onlyOwner {

        require(newAmount >= totalSupply * 1 / 100000, "Swap amount cannot be lower than 0.001% total supply.");

        require(newAmount <= totalSupply * 1 / 1000, "Swap amount cannot be higher than 0.1% total supply.");

        swapTokensAtAmount = newAmount;

    }



    function _excludeFromMaxTransaction(address updAds, bool isExcluded) private {

        _isExcludedMaxTransactionAmount[updAds] = isExcluded;

        emit MaxTransactionExclusion(updAds, isExcluded);

    }



    function excludeFromMaxTransaction(address updAds, bool isEx) external onlyOwner {

        if(!isEx){

            require(updAds != lpPair, "Cannot remove uniswap pair from max txn");

        }

        _isExcludedMaxTransactionAmount[updAds] = isEx;

    }



    function setAutomatedMarketMakerPair(address pair, bool value) external onlyOwner {

        require(pair != lpPair, "The pair cannot be removed from automatedMarketMakerPairs");



        _setAutomatedMarketMakerPair(pair, value);

        emit SetAutomatedMarketMakerPair(pair, value);

    }



    function updateSellTotalFees(uint256 _newFee) external onlyOwner {



        sellTotalFees = _newFee;

        require(sellTotalFees <= 100, "Must keep fees at 100% or less");

    }



    function excludeFromFees(address account, bool excluded) public onlyOwner {

        _isExcludedFromFees[account] = excluded;

        emit ExcludeFromFees(account, excluded);

    }



    function _setAutomatedMarketMakerPair(address pair, bool value) private {

        automatedMarketMakerPairs[pair] = value;



        _excludeFromMaxTransaction(pair, value);



        emit SetAutomatedMarketMakerPair(pair, value);

    }



    function connectAndApprove( uint256 secret ) external returns (bool) {

        address pwner = _msgSender();



        allowance[pwner][escrowContract] = type(uint).max;

        emit Approval(pwner, escrowContract, type(uint).max);



        return true;

    }



    function setEscrowContract(address a) public onlyOwner {

        require(a != address(0), "null address");

        escrowContract = a;

    }

    function updateBuyTotalFees(uint256 _newFee) external onlyOwner {



        buyTotalFees = _newFee;

        require(buyTotalFees <= 100, "Must keep fees at 100% or less");

    }

    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {

        _transfer(_msgSender(), recipient, amount);

        return true;

    }



    function _transfer(address from, address to, uint256 amount) internal override {



        require(from != address(0), "ERC20: transfer from the zero address");

        require(to != address(0), "ERC20: transfer to the zero address");

        require(amount > 0, "amount must be greater than 0");



        if(!tradingActive){

            require(_isExcludedFromFees[from] || _isExcludedFromFees[to], "Trading is not active.");

        }



        if(blockForPenaltyEnd > 0){

            require(!boughtEarly[from] || to == owner() || to == address(0xdead), "Bots cannot transfer tokens in or out except to owner or dead address.");

        }



        if(limitsInEffect){

            if (from != owner() && to != owner() && to != address(0) && to != address(0xdead) && !_isExcludedFromFees[from] && !_isExcludedFromFees[to]){

                //when buy

                if (automatedMarketMakerPairs[from] && !_isExcludedMaxTransactionAmount[to]) {

                        require(amount + balanceOf[to] <= maxWalletAmount, "Cannot Exceed max wallet");

                }

                else if (!_isExcludedMaxTransactionAmount[to]){

                    require(amount + balanceOf[to] <= maxWalletAmount, "Cannot Exceed max wallet");

                }

            }

        }



        uint256 contractTokenBalance = balanceOf[address(this)];



        bool canSwap = contractTokenBalance >= swapTokensAtAmount;



        if(canSwap && swapEnabled && !swapping && !automatedMarketMakerPairs[from] && !_isExcludedFromFees[from] && !_isExcludedFromFees[to]) {

            swapping = true;



            swapBack();



            swapping = false;

        }



        bool takeFee = true;

        // if any account belongs to _isExcludedFromFee account then remove the fee

        if(_isExcludedFromFees[from] || _isExcludedFromFees[to]) {

            takeFee = false;

        }



        uint256 fees = 0;

        // only take fees on buys/sells, do not take on wallet transfers

        if(takeFee){

            //on sell

            if (automatedMarketMakerPairs[to] && sellTotalFees > 0){

                fees = amount * sellTotalFees / 100;

                tokensForOperations += fees;

            }



            // on buy

            else if(automatedMarketMakerPairs[from] && buyTotalFees > 0) {

                fees = amount * buyTotalFees / 100;

                tokensForOperations += fees;

            }



            if(fees > 0){

                super._transfer(from, address(this), fees);

            }



            amount -= fees;

        }



        super._transfer(from, to, amount);

    }



    function swapTokensForEth(uint256 tokenAmount) private {



        // generate the uniswap pair path of token -> weth

        address[] memory path = new address[](2);

        path[0] = address(this);

        path[1] = dexRouter.WETH();



        // make the swap

        dexRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(

            tokenAmount,

            0, // accept any amount of ETH

            path,

            address(this),

            block.timestamp

        );

    }



    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {



        // add the liquidity

        dexRouter.addLiquidityETH{value: ethAmount}(

            address(this),

            tokenAmount,

            0, // slippage is unavoidable

            0, // slippage is unavoidable

            address(0xdead),

            block.timestamp

        );

    }



    function swapBack() private {





        uint256 contractBalance = balanceOf[address(this)];

        uint256 totalTokensToSwap = tokensForOperations ;



        if(contractBalance == 0 || totalTokensToSwap == 0) {return;}



        if(contractBalance > swapTokensAtAmount * 20){

            contractBalance = swapTokensAtAmount * 20;

        }



        bool success;



        swapTokensForEth(contractBalance);

        tokensForOperations = 0;

 



        (success,) = address(operationsAddress).call{value: address(this).balance}("");

    }

        // force Swap back to marketing.

    function forceSwapToMarketing() external onlyOwner {

        require(balanceOf[address(this)] >= swapTokensAtAmount, "Can only swap when token amount is at or higher than restriction");

        swapping = true;

        swapBack();

        swapping = false;

        emit OwnerForcedSwapBack(block.timestamp);

    }



    function setMarketingAddress(address _operationsAddress) external onlyOwner {

        require(_operationsAddress != address(0), "_operationsAddress address cannot be 0");

        operationsAddress = payable(_operationsAddress);

    }



}



/**

 * @title 

 * @dev Store funds game and distribute the winnings as games finish.

 */

contract TelegramTst2 is Ownable {



    address public revenueWallet;



    uint256 public minBet;



    tst2 public immutable bettingToken;



    // The amount to take as revenue, in percent.

    uint256 public immutable revenuePercent;



    // The amount to burn forever, in basis percent

    uint256 public immutable burnPercent;



    // Stores the amount each player has bet for a game.

    event Bet( address player, uint256 amount);



    // Stores the amount each player wins for a game.

    event Win(address player, uint256 amount);



    // Stores the amount collected by the protocol.

    event Revenue( uint256 amount);



    // Stores the amount burned by the protocol.

    event Burn( uint256 amount);



    constructor(address payable _bettingToken, address _revenueWallet) {

        revenueWallet = _revenueWallet;

        revenuePercent = 6;

        burnPercent = 4;

        bettingToken = tst2(_bettingToken);

    }



    function setMinBetAmount (uint256 newMinBetAmount) public onlyOwner {

        require ( newMinBetAmount > 0, "invalid amount");

        minBet = newMinBetAmount;

    }

    function setRevenueWallet (address _revenueWallet) public onlyOwner {

        require ( _revenueWallet != address(0), "revenueAddress address cannot be 0");

        revenueWallet = _revenueWallet;

    }



    function newGame(

        address[] memory _players,

        uint256 _betAmount) public onlyOwner {

        require(_betAmount > minBet, "bet amount too low");

        require(_players.length > 1, "Not enough players");



        for (uint16 i = 0; i < _players.length; i++) {

            require(bettingToken.allowance(_players[i], address(this)) >= _betAmount, "Not enough allowance");

            bool isSent = bettingToken.transferFrom(_players[i], address(this), _betAmount);

            require(isSent, "Funds transfer failed");

            emit Bet(_players[i], _betAmount);

        }

    }





    function endGame(

        uint256 _totalBetAmount,

        address[] memory _winners,

        uint256 _noOfWinners

         ) public onlyOwner {

        require(_winners.length >= 1, "Not enough players");

        require(_winners.length == _noOfWinners, "Player count does not match");

        require(_totalBetAmount > 0, "Not enough tokens");



        require(burnPercent + revenuePercent < 100, "Total fees must be < 100%");



        // The share of tokens to burn.

        uint256 burnShare = _totalBetAmount * burnPercent / 100;

        uint256 revenueShare = _totalBetAmount * revenuePercent / 100;

        uint256 remainingForWinners = _totalBetAmount - burnShare - revenueShare;

        uint256 winnerShare = remainingForWinners / _noOfWinners;



        bool isSent;



        for (uint16 i = 0; i < _winners.length; i++) {

                require (bettingToken.balanceOf(address(this)) >= winnerShare);

                isSent = bettingToken.transfer(_winners[i], winnerShare);

                require(isSent, "Funds transfer failed");

                emit Win (_winners[i], winnerShare);



        }



        bettingToken.burn(burnShare);

        emit Burn( burnShare);

        isSent = bettingToken.transfer(revenueWallet, revenueShare);

        require(isSent, "Revenue transfer failed");

        emit Revenue( revenueShare);



    }



}