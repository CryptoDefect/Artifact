// SPDX-License-Identifier: MIT





/**

 * @author - Roi Di Segni (@sheeeev66 of @thecoredevs)

 */



pragma solidity ^0.8.7;



/**

 * @dev Library for reading and writing primitive types to specific storage slots.

 *

 * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.

 * This library helps with reading and writing to such slots without the need for inline assembly.

 *

 * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.

 */

library StorageSlot {

    struct AddressSlot {

        address value;

    }



    struct BooleanSlot {

        bool value;

    }



    /**

     * @dev Returns an `AddressSlot` with member `value` located at `slot`.

     */

    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {

        assembly {

            r.slot := slot

        }

    }



    /**

     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.

     */

    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {

        assembly {

            r.slot := slot

        }

    }

}



library Address {

    /**

     * @dev Returns true if `account` is a contract.

     *

     * [IMPORTANT]

     * ====

     * It is unsafe to assume that an address for which this function returns

     * false is an externally-owned account (EOA) and not a contract.

     *

     * Among others, `isContract` will return false for the following

     * types of addresses:

     *

     *  - an externally-owned account

     *  - a contract in construction

     *  - an address where a contract will be created

     *  - an address where a contract lived, but was destroyed

     * ====

     *

     * [IMPORTANT]

     * ====

     * You shouldn't rely on `isContract` to protect against flash loan attacks!

     *

     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets

     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract

     * constructor.

     * ====

     */

    function isContract(address account) internal view returns (bool) {

        // This method relies on extcodesize/address.code.length, which returns 0

        // for contracts in construction, since the code is only stored at the end

        // of the constructor execution.



        return account.code.length > 0;

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but performing a delegate call.

     *

     * _Available since v3.4._

     */

    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {

        return functionDelegateCall(target, data, "Address: low-level delegate call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],

     * but performing a delegate call.

     *

     * _Available since v3.4._

     */

    function functionDelegateCall(

        address target,

        bytes memory data,

        string memory errorMessage

    ) internal returns (bytes memory) {

        (bool success, bytes memory returndata) = target.delegatecall(data);

        return verifyCallResultFromTarget(target, success, returndata, errorMessage);

    }



    /**

     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling

     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.

     *

     * _Available since v4.8._

     */

    function verifyCallResultFromTarget(

        address target,

        bool success,

        bytes memory returndata,

        string memory errorMessage

    ) internal view returns (bytes memory) {

        if (success) {

            if (returndata.length == 0) {

                // only check isContract if the call was successful and the return data is empty

                // otherwise we already know that it was a contract

                require(isContract(target), "Address: call to non-contract");

            }

            return returndata;

        } else {

            _revert(returndata, errorMessage);

        }

    }



    function _revert(bytes memory returndata, string memory errorMessage) private pure {

        // Look for revert reason and bubble it up if present

        if (returndata.length > 0) {

            // The easiest way to bubble the revert reason is using memory via assembly

            /// @solidity memory-safe-assembly

            assembly {

                let returndata_size := mload(returndata)

                revert(add(32, returndata), returndata_size)

            }

        } else {

            revert(errorMessage);

        }

    }

}



/**

 * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM

 * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to

 * be specified by overriding the virtual {_implementation} function.

 *

 * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a

 * different contract through the {_delegate} function.

 *

 * The success and return data of the delegated call will be returned back to the caller of the proxy.

 */

abstract contract Proxy {

    /**

     * @dev Delegates the current call to `implementation`.

     *

     * This function does not return to its internal call site, it will return directly to the external caller.

     */

    function _delegate(address implementation) internal virtual {

        assembly {

            // Copy msg.data. We take full control of memory in this inline assembly

            // block because it will not return to Solidity code. We overwrite the

            // Solidity scratch pad at memory position 0.

            calldatacopy(0, 0, calldatasize())



            // Call the implementation.

            // out and outsize are 0 because we don't know the size yet.

            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)



            // Copy the returned data.

            returndatacopy(0, 0, returndatasize())



            switch result

            // delegatecall returns 0 on error.

            case 0 {

                revert(0, returndatasize())

            }

            default {

                return(0, returndatasize())

            }

        }

    }



    /**

     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function

     * and {_fallback} should delegate.

     */

    function _implementation() internal view virtual returns (address);



    /**

     * @dev Delegates the current call to the address returned by `_implementation()`.

     *

     * This function does not return to its internal call site, it will return directly to the external caller.

     */

    function _fallback() internal virtual {

        _beforeFallback();

        _delegate(_implementation());

    }



    /**

     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other

     * function in the contract matches the call data.

     */

    fallback() external payable virtual {

        _fallback();

    }



    /**

     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data

     * is empty.

     */

    receive() external payable virtual {

        _fallback();

    }



    /**

     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`

     * call, or as part of the Solidity `fallback` or `receive` functions.

     *

     * If overridden should call `super._beforeFallback()`.

     */

    function _beforeFallback() internal virtual {}

}



/**

 * @dev This abstract contract provides getters and event emitting update functions for

 * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.

 */

abstract contract ERC1967Upgrade {

    // This is the keccak-256 hash of "eip1967.proxy.rollback" subtracted by 1

    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;



    /**

     * @dev Storage slot with the address of the current implementation.

     * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1, and is

     * validated in the constructor.

     */

    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;



    /**

     * @dev Emitted when the implementation is upgraded.

     */

    event Upgraded(address indexed implementation);



    /**

     * @dev Returns the current implementation address.

     */

    function _getImplementation() internal view returns (address) {

        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;

    }



    /**

     * @dev Stores a new address in the EIP1967 implementation slot.

     */

    function _setImplementation(address newImplementation) private {

        require(Address.isContract(newImplementation), "ERC1967: new implementation is not a contract");

        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;

    }



    /**

     * @dev Perform implementation upgrade

     *

     * Emits an {Upgraded} event.

     */

    function _upgradeTo(address newImplementation) internal {

        _setImplementation(newImplementation);

        emit Upgraded(newImplementation);

    }



    /**

     * @dev Perform implementation upgrade with additional setup call.

     *

     * Emits an {Upgraded} event.

     */

    function _upgradeToAndCall(

        address newImplementation,

        bytes memory data,

        bool forceCall

    ) internal {

        _upgradeTo(newImplementation);

        if (data.length > 0 || forceCall) {

            Address.functionDelegateCall(newImplementation, data);

        }

    }



    /**

     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.

     *

     * Emits an {Upgraded} event.

     */

    function _upgradeToAndCallSecure(

        address newImplementation,

        bytes memory data,

        bool forceCall

    ) internal {

        address oldImplementation = _getImplementation();



        // Initial upgrade and setup call

        _setImplementation(newImplementation);

        if (data.length > 0 || forceCall) {

            Address.functionDelegateCall(newImplementation, data);

        }



        // Perform rollback test if not already in progress

        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);

        if (!rollbackTesting.value) {

            // Trigger rollback using upgradeTo from the new implementation

            rollbackTesting.value = true;

            Address.functionDelegateCall(

                newImplementation,

                abi.encodeWithSignature("upgradeTo(address)", oldImplementation)

            );

            rollbackTesting.value = false;

            // Check rollback was effective

            require(oldImplementation == _getImplementation(), "ERC1967Upgrade: upgrade breaks further upgrades");

            // Finally reset to the new implementation and log the upgrade

            _upgradeTo(newImplementation);

        }

    }



    /**

     * @dev Storage slot with the admin of the contract.

     * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1, and is

     * validated in the constructor.

     */

    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;



    /**

     * @dev Emitted when the admin account has changed.

     */

    event AdminChanged(address previousAdmin, address newAdmin);



    /**

     * @dev Returns the current admin.

     */

    function _getAdmin() internal view returns (address) {

        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;

    }



    /**

     * @dev Stores a new address in the EIP1967 admin slot.

     */

    function _setAdmin(address newAdmin) private {

        require(newAdmin != address(0), "ERC1967: new admin is the zero address");

        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;

    }



    /**

     * @dev Changes the admin of the proxy.

     *

     * Emits an {AdminChanged} event.

     */

    function _changeAdmin(address newAdmin) internal {

        emit AdminChanged(_getAdmin(), newAdmin);

        _setAdmin(newAdmin);

    }

}



/**

 * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an

 * implementation address that can be changed. This address is stored in storage in the location specified by

 * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the

 * implementation behind the proxy.

 */

contract ERC1967Proxy is Proxy, ERC1967Upgrade {

    /**

     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.

     *

     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded

     * function call, and allows initializing the storage of the proxy like a Solidity constructor.

     */

    constructor(address _logic, bytes memory _data) payable {

        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1));

        _upgradeToAndCall(_logic, _data, false);

    }



    /**

     * @dev Returns the current implementation address.

     */

    function _implementation() internal view virtual override returns (address impl) {

        return ERC1967Upgrade._getImplementation();

    }

}



contract ShroomiesProxy is ERC1967Proxy {



    modifier onlyAdmin() {

        require(msg.sender == _getAdmin(), "Only Admin Function!");

        _;

    }

    

    constructor (address _logic, bytes memory _data) ERC1967Proxy(_logic, _data) {

        _changeAdmin(msg.sender);

    }



    function getAdmin() external view returns(address) {

        return _getAdmin();

    }



    function implementation() external view returns(address) {

        return _implementation();

    }

    

    function changeAdmin(address newAdmin) external onlyAdmin {

        _changeAdmin(newAdmin);

    }



    function upgradeTo(address _newImplementation) external onlyAdmin {

        _upgradeTo(_newImplementation);

    }



    function upgradeToAndCall(address newImplementation, bytes memory data) external onlyAdmin {

        _upgradeToAndCall(newImplementation, data, false);

    }

}