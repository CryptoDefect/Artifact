{{

  "language": "Solidity",

  "sources": {

    "contracts/market/client/MarketClientProxy.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { IAccessControlUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol\";\nimport { IMarketClientProxy } from \"../../interfaces/IMarketClientProxy.sol\";\nimport { IMarketController } from \"../../interfaces/IMarketController.sol\";\nimport { SeenConstants } from \"../../domain/SeenConstants.sol\";\nimport { MarketClientLib } from \"./MarketClientLib.sol\";\nimport { Proxy } from \"./Proxy.sol\";\n\n/**\n * @title MarketClientProxy\n *\n * @notice Delegates calls to a market client implementation contract,\n * such that functions on it execute in the context (address, storage)\n * of this proxy, allowing the implementation contract to be upgraded\n * without losing the accumulated state data.\n *\n * Market clients are the contracts in the system that communicate with\n * the MarketController as clients of the MarketDiamond rather than acting\n * as facets of the MarketDiamond. They include SeenHausNFT, ItemsTicketer,\n * and LotsTicketer.\n *\n * Each Market Client contract will be deployed behind its own proxy for\n * future upgradability.\n *\n * @author Cliff Hall <cliff@futurescale.com> (https://twitter.com/seaofarrows)\n */\ncontract MarketClientProxy is IMarketClientProxy, SeenConstants, Proxy {\n\n    /**\n * @dev Modifier that checks that the caller has a specific role.\n *\n * Reverts if caller doesn't have role.\n *\n * See: {AccessController.hasRole}\n */\n    modifier onlyRole(bytes32 role) {\n        require(MarketClientLib.hasRole(role), \"Caller doesn't have role\");\n        _;\n    }\n\n    constructor(\n        address _accessController,\n        address _marketController,\n        address _impl\n    ) {\n\n        // Get the ProxyStorage struct\n        MarketClientLib.ProxyStorage storage ps = MarketClientLib.proxyStorage();\n\n        // Store the AccessController address\n        ps.accessController = IAccessControlUpgradeable(_accessController);\n\n        // Store the MarketController address\n        ps.marketController = IMarketController(_marketController);\n\n        // Store the implementation address\n        ps.implementation = _impl;\n\n    }\n\n    /**\n     * @dev Returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation()\n    internal\n    view\n    override\n    returns (address) {\n\n        // Get the ProxyStorage struct\n        MarketClientLib.ProxyStorage storage ps = MarketClientLib.proxyStorage();\n\n        // Return the current implementation address\n        return ps.implementation;\n\n    }\n\n    /**\n     * @dev Set the implementation address\n     */\n    function setImplementation(address _impl)\n    external\n    onlyRole(UPGRADER)\n    override\n    {\n        // Get the ProxyStorage struct\n        MarketClientLib.ProxyStorage storage ps = MarketClientLib.proxyStorage();\n\n        // Store the implementation address\n        ps.implementation = _impl;\n\n        // Notify listeners about state change\n        emit Upgraded(_impl);\n\n    }\n\n    /**\n     * @dev Get the implementation address\n     */\n    function getImplementation()\n    external\n    view\n    override\n    returns (address) {\n        return _implementation();\n    }\n\n    /**\n     * @notice Set the Seen.Haus AccessController\n     *\n     * Emits an AccessControllerAddressChanged event.\n     *\n     * @param _accessController - the Seen.Haus AccessController address\n     */\n    function setAccessController(address _accessController)\n    external\n    onlyRole(UPGRADER)\n    override\n    {\n        // Get the ProxyStorage struct\n        MarketClientLib.ProxyStorage storage ps = MarketClientLib.proxyStorage();\n\n        // Store the AccessController address\n        ps.accessController = IAccessControlUpgradeable(_accessController);\n\n        // Notify listeners about state change\n        emit AccessControllerAddressChanged(_accessController);\n    }\n\n    /**\n     * @notice Gets the address of the Seen.Haus AccessController contract.\n     *\n     * @return the address of the AccessController contract\n     */\n    function getAccessController()\n    public\n    view\n    override\n    returns(IAccessControlUpgradeable)\n    {\n        // Get the ProxyStorage struct\n        MarketClientLib.ProxyStorage storage ps = MarketClientLib.proxyStorage();\n\n        // Return the current AccessController address\n        return ps.accessController;\n    }\n\n    /**\n     * @notice Set the Seen.Haus MarketController\n     *\n     * Emits an MarketControllerAddressChanged event.\n     *\n     * @param _marketController - the Seen.Haus MarketController address\n     */\n    function setMarketController(address _marketController)\n    external\n    onlyRole(UPGRADER)\n    override\n    {\n        // Get the ProxyStorage struct\n        MarketClientLib.ProxyStorage storage ps = MarketClientLib.proxyStorage();\n\n        // Store the MarketController address\n        ps.marketController = IMarketController(_marketController);\n\n        // Notify listeners about state change\n        emit MarketControllerAddressChanged(_marketController);\n    }\n\n    /**\n     * @notice Gets the address of the Seen.Haus MarketController contract.\n     *\n     * @return the address of the MarketController contract\n     */\n    function getMarketController()\n    public\n    override\n    view\n    returns(IMarketController)\n    {\n        // Get the ProxyStorage struct\n        MarketClientLib.ProxyStorage storage ps = MarketClientLib.proxyStorage();\n\n        // Return the current MarketController address\n        return ps.marketController;\n    }\n\n}"

    },

    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"

    },

    "contracts/interfaces/IMarketClientProxy.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport { IAccessControlUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol\";\nimport { IMarketController } from \"./IMarketController.sol\";\n\n/**\n * @title IMarketClientProxy\n *\n * @notice Allows upgrading the implementation, market controller, and access controller\n * of a MarketClientProxy\n *\n * The ERC-165 identifier for this interface is: 0x9bc69c79\n *\n * @author Cliff Hall <cliff@futurescale.com> (https://twitter.com/seaofarrows)\n */\ninterface IMarketClientProxy {\n\n    // Events\n    event Upgraded(address indexed implementation);\n    event MarketControllerAddressChanged(address indexed marketController);\n    event AccessControllerAddressChanged(address indexed accessController);\n\n    /**\n     * @dev Set the implementation address\n     */\n    function setImplementation(address _implementation) external;\n\n    /**\n     * @dev Get the implementation address\n     */\n    function getImplementation() external view returns (address);\n\n    /**\n     * @notice Set the Seen.Haus AccessController\n     *\n     * Emits an AccessControllerAddressChanged event.\n     *\n     * @param _accessController - the Seen.Haus AccessController address\n     */\n    function setAccessController(address _accessController) external;\n\n    /**\n     * @notice Gets the address of the Seen.Haus AccessController contract.\n     *\n     * @return the address of the AccessController contract\n     */\n    function getAccessController() external view returns (IAccessControlUpgradeable);\n\n    /**\n     * @notice Set the Seen.Haus MarketController\n     *\n     * Emits an MarketControllerAddressChanged event.\n     *\n     * @param _marketController - the Seen.Haus MarketController address\n     */\n    function setMarketController(address _marketController) external;\n\n    /**\n     * @notice Gets the address of the Seen.Haus MarketController contract.\n     *\n     * @return the address of the MarketController contract\n     */\n    function getMarketController() external view returns(IMarketController);\n\n}"

    },

    "contracts/interfaces/IMarketController.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"./IMarketConfig.sol\";\nimport \"./IMarketConfigAdditional.sol\";\nimport \"./IMarketClerk.sol\";\n\n/**\n * @title IMarketController\n *\n * @notice Manages configuration and consignments used by the Seen.Haus contract suite.\n *\n * The ERC-165 identifier for this interface is: 0xbb8dba77\n *\n * @author Cliff Hall <cliff@futurescale.com> (https://twitter.com/seaofarrows)\n */\ninterface IMarketController is IMarketClerk, IMarketConfig, IMarketConfigAdditional {}"

    },

    "contracts/domain/SeenConstants.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\n/**\n * @title SeenConstants\n *\n * @notice Constants used by the Seen.Haus contract ecosystem.\n *\n * @author Cliff Hall <cliff@futurescale.com> (https://twitter.com/seaofarrows)\n */\ncontract SeenConstants {\n\n    // Endpoint will serve dynamic metadata composed of ticket and ticketed item's info\n    string internal constant ESCROW_TICKET_URI = \"https://api.seen.haus/ticket/metadata/\";\n\n    // Access Control Roles\n    bytes32 internal constant ADMIN = keccak256(\"ADMIN\");                   // Deployer and any other admins as needed\n    bytes32 internal constant SELLER = keccak256(\"SELLER\");                 // Approved sellers amd Seen.Haus reps\n    bytes32 internal constant MINTER = keccak256(\"MINTER\");                 // Approved artists and Seen.Haus reps\n    bytes32 internal constant ESCROW_AGENT = keccak256(\"ESCROW_AGENT\");     // Seen.Haus Physical Item Escrow Agent\n    bytes32 internal constant MARKET_HANDLER = keccak256(\"MARKET_HANDLER\"); // Market Handler contracts\n    bytes32 internal constant UPGRADER = keccak256(\"UPGRADER\");             // Performs contract upgrades\n    bytes32 internal constant MULTISIG = keccak256(\"MULTISIG\");             // Admin role of MARKET_HANDLER & UPGRADER\n\n}"

    },

    "contracts/market/client/MarketClientLib.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol\";\nimport \"../../interfaces/IMarketController.sol\";\n\n/**\n * @title MarketClientLib\n *\n * Maintains the implementation address and the access and market controller addresses.\n *\n * @author Cliff Hall <cliff@futurescale.com> (https://twitter.com/seaofarrows)\n */\nlibrary MarketClientLib {\n\n    struct ProxyStorage {\n\n        // The Seen.Haus AccessController address\n        IAccessControlUpgradeable accessController;\n\n        // The Seen.Haus MarketController address\n        IMarketController marketController;\n\n        // The implementation address\n        address implementation;\n    }\n\n    /**\n     * @dev Storage slot with the address of the Seen.Haus AccessController\n     * This is obviously not a standard EIP-1967 slot.\n     */\n    bytes32 internal constant PROXY_SLOT = keccak256('Seen.Haus.MarketClientProxy');\n\n    /**\n     * @notice Get the Proxy storage slot\n     *\n     * @return ps - Proxy storage slot cast to ProxyStorage\n     */\n    function proxyStorage() internal pure returns (ProxyStorage storage ps) {\n        bytes32 position = PROXY_SLOT;\n        assembly {\n            ps.slot := position\n        }\n    }\n\n    /**\n     * @dev Checks that the caller has a specific role.\n     *\n     * Reverts if caller doesn't have role.\n     *\n     * See: {AccessController.hasRole}\n     */\n    function hasRole(bytes32 role) internal view returns (bool) {\n        ProxyStorage storage ps = proxyStorage();\n        return ps.accessController.hasRole(role, msg.sender);\n    }\n\n}"

    },

    "contracts/market/client/Proxy.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"

    },

    "contracts/interfaces/IMarketConfig.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"../domain/SeenTypes.sol\";\n\n/**\n * @title IMarketController\n *\n * @notice Manages configuration and consignments used by the Seen.Haus contract suite.\n * @dev Contributes its events and functions to the IMarketController interface\n *\n * The ERC-165 identifier for this interface is: 0x57f9f26d\n *\n * @author Cliff Hall <cliff@futurescale.com> (https://twitter.com/seaofarrows)\n */\ninterface IMarketConfig {\n\n    /// Events\n    event NFTAddressChanged(address indexed nft);\n    event EscrowTicketerAddressChanged(address indexed escrowTicketer, SeenTypes.Ticketer indexed ticketerType);\n    event StakingAddressChanged(address indexed staking);\n    event MultisigAddressChanged(address indexed multisig);\n    event VipStakerAmountChanged(uint256 indexed vipStakerAmount);\n    event PrimaryFeePercentageChanged(uint16 indexed feePercentage);\n    event SecondaryFeePercentageChanged(uint16 indexed feePercentage);\n    event MaxRoyaltyPercentageChanged(uint16 indexed maxRoyaltyPercentage);\n    event OutBidPercentageChanged(uint16 indexed outBidPercentage);\n    event DefaultTicketerTypeChanged(SeenTypes.Ticketer indexed ticketerType);\n\n    /**\n     * @notice Sets the address of the xSEEN ERC-20 staking contract.\n     *\n     * Emits a NFTAddressChanged event.\n     *\n     * @param _nft - the address of the nft contract\n     */\n    function setNft(address _nft) external;\n\n    /**\n     * @notice The nft getter\n     */\n    function getNft() external view returns (address);\n\n    /**\n     * @notice Sets the address of the Seen.Haus lots-based escrow ticketer contract.\n     *\n     * Emits a EscrowTicketerAddressChanged event.\n     *\n     * @param _lotsTicketer - the address of the items-based escrow ticketer contract\n     */\n    function setLotsTicketer(address _lotsTicketer) external;\n\n    /**\n     * @notice The lots-based escrow ticketer getter\n     */\n    function getLotsTicketer() external view returns (address);\n\n    /**\n     * @notice Sets the address of the Seen.Haus items-based escrow ticketer contract.\n     *\n     * Emits a EscrowTicketerAddressChanged event.\n     *\n     * @param _itemsTicketer - the address of the items-based escrow ticketer contract\n     */\n    function setItemsTicketer(address _itemsTicketer) external;\n\n    /**\n     * @notice The items-based escrow ticketer getter\n     */\n    function getItemsTicketer() external view returns (address);\n\n    /**\n     * @notice Sets the address of the xSEEN ERC-20 staking contract.\n     *\n     * Emits a StakingAddressChanged event.\n     *\n     * @param _staking - the address of the staking contract\n     */\n    function setStaking(address payable _staking) external;\n\n    /**\n     * @notice The staking getter\n     */\n    function getStaking() external view returns (address payable);\n\n    /**\n     * @notice Sets the address of the Seen.Haus multi-sig wallet.\n     *\n     * Emits a MultisigAddressChanged event.\n     *\n     * @param _multisig - the address of the multi-sig wallet\n     */\n    function setMultisig(address payable _multisig) external;\n\n    /**\n     * @notice The multisig getter\n     */\n    function getMultisig() external view returns (address payable);\n\n    /**\n     * @notice Sets the VIP staker amount.\n     *\n     * Emits a VipStakerAmountChanged event.\n     *\n     * @param _vipStakerAmount - the minimum amount of xSEEN ERC-20 a caller must hold to participate in VIP events\n     */\n    function setVipStakerAmount(uint256 _vipStakerAmount) external;\n\n    /**\n     * @notice The vipStakerAmount getter\n     */\n    function getVipStakerAmount() external view returns (uint256);\n\n    /**\n     * @notice Sets the marketplace fee percentage.\n     * Emits a PrimaryFeePercentageChanged event.\n     *\n     * @param _primaryFeePercentage - the percentage that will be taken as a fee from the net of a Seen.Haus primary sale or auction\n     *\n     * N.B. Represent percentage value as an unsigned int by multiplying the percentage by 100:\n     * e.g, 1.75% = 175, 100% = 10000\n     */\n    function setPrimaryFeePercentage(uint16 _primaryFeePercentage) external;\n\n    /**\n     * @notice Sets the marketplace fee percentage.\n     * Emits a SecondaryFeePercentageChanged event.\n     *\n     * @param _secondaryFeePercentage - the percentage that will be taken as a fee from the net of a Seen.Haus secondary sale or auction (after royalties)\n     *\n     * N.B. Represent percentage value as an unsigned int by multiplying the percentage by 100:\n     * e.g, 1.75% = 175, 100% = 10000\n     */\n    function setSecondaryFeePercentage(uint16 _secondaryFeePercentage) external;\n\n    /**\n     * @notice The primaryFeePercentage and secondaryFeePercentage getter\n     */\n    function getFeePercentage(SeenTypes.Market _market) external view returns (uint16);\n\n    /**\n     * @notice Sets the external marketplace maximum royalty percentage.\n     *\n     * Emits a MaxRoyaltyPercentageChanged event.\n     *\n     * @param _maxRoyaltyPercentage - the maximum percentage of a Seen.Haus sale or auction that will be paid as a royalty\n     */\n    function setMaxRoyaltyPercentage(uint16 _maxRoyaltyPercentage) external;\n\n    /**\n     * @notice The maxRoyaltyPercentage getter\n     */\n    function getMaxRoyaltyPercentage() external view returns (uint16);\n\n    /**\n     * @notice Sets the marketplace auction outbid percentage.\n     *\n     * Emits a OutBidPercentageChanged event.\n     *\n     * @param _outBidPercentage - the minimum percentage a Seen.Haus auction bid must be above the previous bid to prevail\n     */\n    function setOutBidPercentage(uint16 _outBidPercentage) external;\n\n    /**\n     * @notice The outBidPercentage getter\n     */\n    function getOutBidPercentage() external view returns (uint16);\n\n    /**\n     * @notice Sets the default escrow ticketer type.\n     *\n     * Emits a DefaultTicketerTypeChanged event.\n     *\n     * Reverts if _ticketerType is Ticketer.Default\n     * Reverts if _ticketerType is already the defaultTicketerType\n     *\n     * @param _ticketerType - the new default escrow ticketer type.\n     */\n    function setDefaultTicketerType(SeenTypes.Ticketer _ticketerType) external;\n\n    /**\n     * @notice The defaultTicketerType getter\n     */\n    function getDefaultTicketerType() external view returns (SeenTypes.Ticketer);\n\n    /**\n     * @notice Get the Escrow Ticketer to be used for a given consignment\n     *\n     * If a specific ticketer has not been set for the consignment,\n     * the default escrow ticketer will be returned.\n     *\n     * @param _consignmentId - the id of the consignment\n     * @return ticketer = the address of the escrow ticketer to use\n     */\n    function getEscrowTicketer(uint256 _consignmentId) external view returns (address ticketer);\n}"

    },

    "contracts/interfaces/IMarketConfigAdditional.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"../domain/SeenTypes.sol\";\n\n/**\n * @title IMarketController\n *\n * @notice Manages configuration and consignments used by the Seen.Haus contract suite.\n * @dev Contributes its events and functions to the IMarketController interface\n *\n * The ERC-165 identifier for this interface is: 0x57f9f26d\n *\n * @author Cliff Hall <cliff@futurescale.com> (https://twitter.com/seaofarrows)\n */\ninterface IMarketConfigAdditional {\n\n    /// Events\n    event AllowExternalTokensOnSecondaryChanged(bool indexed status);\n    event EscrowAgentFeeChanged(address indexed escrowAgent, uint16 fee);\n    \n    /**\n     * @notice Sets whether or not external tokens can be listed on secondary market\n     *\n     * Emits an AllowExternalTokensOnSecondaryChanged event.\n     *\n     * @param _status - boolean of whether or not external tokens are allowed\n     */\n    function setAllowExternalTokensOnSecondary(bool _status) external;\n\n    /**\n     * @notice The allowExternalTokensOnSecondary getter\n     */\n    function getAllowExternalTokensOnSecondary() external view returns (bool status);\n\n        /**\n     * @notice The escrow agent fee getter\n     */\n    function getEscrowAgentFeeBasisPoints(address _escrowAgentAddress) external view returns (uint16);\n\n    /**\n     * @notice The escrow agent fee setter\n     */\n    function setEscrowAgentFeeBasisPoints(address _escrowAgentAddress, uint16 _basisPoints) external;\n}"

    },

    "contracts/interfaces/IMarketClerk.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport \"../domain/SeenTypes.sol\";\n\n/**\n * @title IMarketClerk\n *\n * @notice Manages consignments for the Seen.Haus contract suite.\n *\n * The ERC-165 identifier for this interface is: 0xec74481a\n *\n * @author Cliff Hall <cliff@futurescale.com> (https://twitter.com/seaofarrows)\n */\ninterface IMarketClerk is IERC1155ReceiverUpgradeable, IERC721ReceiverUpgradeable {\n\n    /// Events\n    event ConsignmentTicketerChanged(uint256 indexed consignmentId, SeenTypes.Ticketer indexed ticketerType);\n    event ConsignmentFeeChanged(uint256 indexed consignmentId, uint16 customConsignmentFee);\n    event ConsignmentPendingPayoutSet(uint256 indexed consignmentId, uint256 amount);\n    event ConsignmentRegistered(address indexed consignor, address indexed seller, SeenTypes.Consignment consignment);\n    event ConsignmentMarketed(address indexed consignor, address indexed seller, uint256 indexed consignmentId);\n    event ConsignmentReleased(uint256 indexed consignmentId, uint256 amount, address releasedTo);\n\n    /**\n     * @notice The nextConsignment getter\n     */\n    function getNextConsignment() external view returns (uint256);\n\n    /**\n     * @notice The consignment getter\n     */\n    function getConsignment(uint256 _consignmentId) external view returns (SeenTypes.Consignment memory);\n\n    /**\n     * @notice Get the remaining supply of the given consignment.\n     *\n     * @param _consignmentId - the id of the consignment\n     * @return uint256 - the remaining supply held by the MarketController\n     */\n    function getUnreleasedSupply(uint256 _consignmentId) external view returns(uint256);\n\n    /**\n     * @notice Get the consignor of the given consignment\n     *\n     * @param _consignmentId - the id of the consignment\n     * @return  address - consigner's address\n     */\n    function getConsignor(uint256 _consignmentId) external view returns(address);\n\n    /**\n     * @notice Registers a new consignment for sale or auction.\n     *\n     * Emits a ConsignmentRegistered event.\n     *\n     * @param _market - the market for the consignment. See {SeenTypes.Market}\n     * @param _consignor - the address executing the consignment transaction\n     * @param _seller - the seller of the consignment\n     * @param _tokenAddress - the contract address issuing the NFT behind the consignment\n     * @param _tokenId - the id of the token being consigned\n     * @param _supply - the amount of the token being consigned\n     *\n     * @return Consignment - the registered consignment\n     */\n    function registerConsignment(\n        SeenTypes.Market _market,\n        address _consignor,\n        address payable _seller,\n        address _tokenAddress,\n        uint256 _tokenId,\n        uint256 _supply\n    )\n    external\n    returns(SeenTypes.Consignment memory);\n\n    /**\n      * @notice Update consignment to indicate it has been marketed\n      *\n      * Emits a ConsignmentMarketed event.\n      *\n      * Reverts if consignment has already been marketed.\n      * A consignment is considered as marketed if it has a marketHandler other than Unhandled. See: {SeenTypes.MarketHandler}\n      *\n      * @param _consignmentId - the id of the consignment\n      */\n    function marketConsignment(uint256 _consignmentId, SeenTypes.MarketHandler _marketHandler) external;\n\n    /**\n     * @notice Release the consigned item to a given address\n     *\n     * Emits a ConsignmentReleased event.\n     *\n     * Reverts if caller is does not have MARKET_HANDLER role.\n     *\n     * @param _consignmentId - the id of the consignment\n     * @param _amount - the amount of the consigned supply to release\n     * @param _releaseTo - the address to transfer the consigned token balance to\n     */\n    function releaseConsignment(uint256 _consignmentId, uint256 _amount, address _releaseTo) external;\n\n    /**\n     * @notice Clears the pending payout value of a consignment\n     *\n     * Emits a ConsignmentPayoutSet event.\n     *\n     * Reverts if:\n     *  - caller is does not have MARKET_HANDLER role.\n     *  - consignment doesn't exist\n     *\n     * @param _consignmentId - the id of the consignment\n     * @param _amount - the amount of that the consignment's pendingPayout must be set to\n     */\n    function setConsignmentPendingPayout(uint256 _consignmentId, uint256 _amount) external;\n\n    /**\n     * @notice Set the type of Escrow Ticketer to be used for a consignment\n     *\n     * Default escrow ticketer is Ticketer.Lots. This only needs to be called\n     * if overriding to Ticketer.Items for a given consignment.\n     *\n     * Emits a ConsignmentTicketerSet event.\n     * Reverts if consignment is not registered.\n     *\n     * @param _consignmentId - the id of the consignment\n     * @param _ticketerType - the type of ticketer to use. See: {SeenTypes.Ticketer}\n     */\n    function setConsignmentTicketer(uint256 _consignmentId, SeenTypes.Ticketer _ticketerType) external;\n\n    /**\n     * @notice Set a custom fee percentage on a consignment (e.g. for \"official\" SEEN x Artist drops)\n     *\n     * Default escrow ticketer is Ticketer.Lots. This only needs to be called\n     * if overriding to Ticketer.Items for a given consignment.\n     *\n     * Emits a ConsignmentFeeChanged event.\n     *\n     * Reverts if consignment doesn't exist     *\n     *\n     * @param _consignmentId - the id of the consignment\n     * @param _customFeePercentageBasisPoints - the custom fee percentage basis points to use\n     *\n     * N.B. _customFeePercentageBasisPoints percentage value as an unsigned int by multiplying the percentage by 100:\n     * e.g, 1.75% = 175, 100% = 10000\n     */\n    function setConsignmentCustomFee(uint256 _consignmentId, uint16 _customFeePercentageBasisPoints) external;\n\n}"

    },

    "contracts/domain/SeenTypes.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\n/**\n * @title SeenTypes\n *\n * @notice Enums and structs used by the Seen.Haus contract ecosystem.\n *\n * @author Cliff Hall <cliff@futurescale.com> (https://twitter.com/seaofarrows)\n */\ncontract SeenTypes {\n\n    enum Market {\n        Primary,\n        Secondary\n    }\n\n    enum MarketHandler {\n        Unhandled,\n        Auction,\n        Sale\n    }\n\n    enum Clock {\n        Live,\n        Trigger\n    }\n\n    enum Audience {\n        Open,\n        Staker,\n        VipStaker\n    }\n\n    enum Outcome {\n        Pending,\n        Closed,\n        Canceled\n    }\n\n    enum State {\n        Pending,\n        Running,\n        Ended\n    }\n\n    enum Ticketer {\n        Default,\n        Lots,\n        Items\n    }\n\n    struct Token {\n        address payable creator;\n        uint16 royaltyPercentage;\n        bool isPhysical;\n        uint256 id;\n        uint256 supply;\n        string uri;\n    }\n\n    struct Consignment {\n        Market market;\n        MarketHandler marketHandler;\n        address payable seller;\n        address tokenAddress;\n        uint256 tokenId;\n        uint256 supply;\n        uint256 id;\n        bool multiToken;\n        bool released;\n        uint256 releasedSupply;\n        uint16 customFeePercentageBasisPoints;\n        uint256 pendingPayout;\n    }\n\n    struct Auction {\n        address payable buyer;\n        uint256 consignmentId;\n        uint256 start;\n        uint256 duration;\n        uint256 reserve;\n        uint256 bid;\n        Clock clock;\n        State state;\n        Outcome outcome;\n    }\n\n    struct Sale {\n        uint256 consignmentId;\n        uint256 start;\n        uint256 price;\n        uint256 perTxCap;\n        State state;\n        Outcome outcome;\n    }\n\n    struct EscrowTicket {\n        uint256 amount;\n        uint256 consignmentId;\n        uint256 id;\n        string itemURI;\n    }\n\n}"

    },

    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\n    /**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"

    },

    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"

    },

    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"

    }

  },

  "settings": {

    "optimizer": {

      "enabled": true,

      "runs": 200,

      "details": {

        "yul": true

      }

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "libraries": {}

  }

}}