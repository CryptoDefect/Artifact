/**

 *Submitted for verification at Etherscan.io on 2023-05-02

*/



// Created by Byt, Inc. https://byt.io

// SPDX-License-Identifier: MIT



pragma solidity ^0.8.17;



/*

 * @dev Provides information about the current execution context, including the

 * sender of the transaction and its data. While these are generally available

 * via msg.sender and msg.data, they should not be accessed in such a direct

 * manner, since when dealing with meta-transactions the account sending and

 * paying for execution may not be the actual sender (as far as an application

 * is concerned).

 *

 * This contract is only required for intermediate, library-like contracts.

 */

abstract contract Context {

    function _msgSender() internal view virtual returns (address) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes calldata) {

        return msg.data;

    }

}



/**

 * @dev Interface of the ERC20 standard as defined in the EIP.

 */

interface IERC20 {

    /**

     * @dev Returns the amount of tokens in existence.

     */

    function totalSupply() external view returns (uint256);



    /**

     * @dev Returns the amount of tokens owned by `account`.

     */

    function balanceOf(address account) external view returns (uint256);



    /**

     * @dev Moves `amount` tokens from the caller's account to `recipient`.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transfer(address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Returns the remaining number of tokens that `spender` will be

     * allowed to spend on behalf of `owner` through {transferFrom}. This is

     * zero by default.

     *

     * This value changes when {approve} or {transferFrom} are called.

     */

    function allowance(address owner, address spender) external view returns (uint256);



    /**

     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * IMPORTANT: Beware that changing an allowance with this method brings the risk

     * that someone may use both the old and the new allowance by unfortunate

     * transaction ordering. One possible solution to mitigate this race

     * condition is to first reduce the spender's allowance to 0 and set the

     * desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     *

     * Emits an {Approval} event.

     */

    function approve(address spender, uint256 amount) external returns (bool);



    /**

     * @dev Moves `amount` tokens from `sender` to `recipient` using the

     * allowance mechanism. `amount` is then deducted from the caller's

     * allowance.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Emitted when `value` tokens are moved from one account (`from`) to

     * another (`to`).

     *

     * Note that `value` may be zero.

     */

    event Transfer(address indexed from, address indexed to, uint256 value);



    /**

     * @dev Emitted when the allowance of a `spender` for an `owner` is set by

     * a call to {approve}. `value` is the new allowance.

     */

    event Approval(address indexed owner, address indexed spender, uint256 value);

}



/**

 * @dev Contract module which provides a basic access control mechanism, where

 * there is an account (an owner) that can be granted exclusive access to

 * specific functions.

 *

 * By default, the owner account will be the one that deploys the contract. This

 * can later be changed with {transferOwnership}.

 *

 * This module is used through inheritance. It will make available the modifier

 * `onlyOwner`, which can be applied to your functions to restrict their use to

 * the owner.

 */

abstract contract Ownable is Context {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev Initializes the contract setting the deployer as the initial owner.

     */

    constructor() {

        _setOwner(_msgSender());

    }



    /**

     * @dev Returns the address of the current owner.

     */

    function owner() public view virtual returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        require(owner() == _msgSender(), "Ownable: caller is not the owner");

        _;

    }



    /**

     * @dev Leaves the contract without owner. It will not be possible to call

     * `onlyOwner` functions anymore. Can only be called by the current owner.

     *

     * NOTE: Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public virtual onlyOwner {

        _setOwner(address(0));

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Can only be called by the current owner.

     */

    function transferOwnership(address newOwner) public virtual onlyOwner {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        _setOwner(newOwner);

    }



    function _setOwner(address newOwner) private {

        address oldOwner = _owner;

        _owner = newOwner;

        emit OwnershipTransferred(oldOwner, newOwner);

    }

}



/**

 * @dev Collection of functions related to the address type

 */

library Address {

    /**

     * @dev Returns true if `account` is a contract.

     *

     * [IMPORTANT]

     * ====

     * It is unsafe to assume that an address for which this function returns

     * false is an externally-owned account (EOA) and not a contract.

     *

     * Among others, `isContract` will return false for the following

     * types of addresses:

     *

     *  - an externally-owned account

     *  - a contract in construction

     *  - an address where a contract will be created

     *  - an address where a contract lived, but was destroyed

     * ====

     */

    function isContract(address account) internal view returns (bool) {

        // This method relies on extcodesize, which returns 0 for contracts in

        // construction, since the code is only stored at the end of the

        // constructor execution.



        uint256 size;

        assembly {

            size := extcodesize(account)

        }

        return size > 0;

    }



    /**

     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to

     * `recipient`, forwarding all available gas and reverting on errors.

     *

     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost

     * of certain opcodes, possibly making contracts go over the 2300 gas limit

     * imposed by `transfer`, making them unable to receive funds via

     * `transfer`. {sendValue} removes this limitation.

     *

     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].

     *

     * IMPORTANT: because control is transferred to `recipient`, care must be

     * taken to not create reentrancy vulnerabilities. Consider using

     * {ReentrancyGuard} or the

     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].

     */

    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        (bool success, ) = recipient.call{value: amount}("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }



    /**

     * @dev Performs a Solidity function call using a low level `call`. A

     * plain `call` is an unsafe replacement for a function call: use this

     * function instead.

     *

     * If `target` reverts with a revert reason, it is bubbled up by this

     * function (like regular Solidity function calls).

     *

     * Returns the raw returned data. To convert to the expected return value,

     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].

     *

     * Requirements:

     *

     * - `target` must be a contract.

     * - calling `target` with `data` must not revert.

     *

     * _Available since v3.1._

     */

    function functionCall(address target, bytes memory data) internal returns (bytes memory) {

        return functionCall(target, data, "Address: low-level call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with

     * `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCall(

        address target,

        bytes memory data,

        string memory errorMessage

    ) internal returns (bytes memory) {

        return functionCallWithValue(target, data, 0, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but also transferring `value` wei to `target`.

     *

     * Requirements:

     *

     * - the calling contract must have an ETH balance of at least `value`.

     * - the called Solidity function must be `payable`.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(

        address target,

        bytes memory data,

        uint256 value

    ) internal returns (bytes memory) {

        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");

    }



    /**

     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but

     * with `errorMessage` as a fallback revert reason when `target` reverts.

     *

     * _Available since v3.1._

     */

    function functionCallWithValue(

        address target,

        bytes memory data,

        uint256 value,

        string memory errorMessage

    ) internal returns (bytes memory) {

        require(address(this).balance >= value, "Address: insufficient balance for call");

        require(isContract(target), "Address: call to non-contract");



        (bool success, bytes memory returndata) = target.call{value: value}(data);

        return _verifyCallResult(success, returndata, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but performing a static call.

     *

     * _Available since v3.3._

     */

    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {

        return functionStaticCall(target, data, "Address: low-level static call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],

     * but performing a static call.

     *

     * _Available since v3.3._

     */

    function functionStaticCall(

        address target,

        bytes memory data,

        string memory errorMessage

    ) internal view returns (bytes memory) {

        require(isContract(target), "Address: static call to non-contract");



        (bool success, bytes memory returndata) = target.staticcall(data);

        return _verifyCallResult(success, returndata, errorMessage);

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],

     * but performing a delegate call.

     *

     * _Available since v3.4._

     */

    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {

        return functionDelegateCall(target, data, "Address: low-level delegate call failed");

    }



    /**

     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],

     * but performing a delegate call.

     *

     * _Available since v3.4._

     */

    function functionDelegateCall(

        address target,

        bytes memory data,

        string memory errorMessage

    ) internal returns (bytes memory) {

        require(isContract(target), "Address: delegate call to non-contract");



        (bool success, bytes memory returndata) = target.delegatecall(data);

        return _verifyCallResult(success, returndata, errorMessage);

    }



    function _verifyCallResult(

        bool success,

        bytes memory returndata,

        string memory errorMessage

    ) private pure returns (bytes memory) {

        if (success) {

            return returndata;

        } else {

            // Look for revert reason and bubble it up if present

            if (returndata.length > 0) {

                // The easiest way to bubble the revert reason is using memory via assembly



                assembly {

                    let returndata_size := mload(returndata)

                    revert(add(32, returndata), returndata_size)

                }

            } else {

                revert(errorMessage);

            }

        }

    }

}



/**

 * @dev String operations.

 */

library Strings {

    bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";



    /**

     * @dev Converts a `uint256` to its ASCII `string` decimal representation.

     */

    function toString(uint256 value) internal pure returns (string memory) {

        // Inspired by OraclizeAPI's implementation - MIT licence

        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol



        if (value == 0) {

            return "0";

        }

        uint256 temp = value;

        uint256 digits;

        while (temp != 0) {

            digits++;

            temp /= 10;

        }

        bytes memory buffer = new bytes(digits);

        while (value != 0) {

            digits -= 1;

            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));

            value /= 10;

        }

        return string(buffer);

    }



    /**

     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.

     */

    function toHexString(uint256 value) internal pure returns (string memory) {

        if (value == 0) {

            return "0x00";

        }

        uint256 temp = value;

        uint256 length = 0;

        while (temp != 0) {

            length++;

            temp >>= 8;

        }

        return toHexString(value, length);

    }



    /**

     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.

     */

    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {

        bytes memory buffer = new bytes(2 * length + 2);

        buffer[0] = "0";

        buffer[1] = "x";

        for (uint256 i = 2 * length + 1; i > 1; --i) {

            buffer[i] = _HEX_SYMBOLS[value & 0xf];

            value >>= 4;

        }

        require(value == 0, "Strings: hex length insufficient");

        return string(buffer);

    }

}



/**

 * @dev Wrappers over Solidity's arithmetic operations with added overflow

 * checks.

 *

 * Arithmetic operations in Solidity wrap on overflow. This can easily result

 * in bugs, because programmers usually assume that an overflow raises an

 * error, which is the standard behavior in high level programming languages.

 * `SafeMath` restores this intuition by reverting the transaction when an

 * operation overflows.

 *

 * Using this library instead of the unchecked operations eliminates an entire

 * class of bugs, so it's recommended to use it always.

 *

 *

 * @dev original library functions truncated to only needed functions reducing

 * deployed bytecode.

 */

library SafeMath {



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     *

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b <= a, "SafeMath: subtraction overflow");

        return a - b;

    }



    /**

     * @dev Returns the multiplication of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `*` operator.

     *

     * Requirements:

     *

     * - Multiplication cannot overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        if (a == 0) return 0;

        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");

        return c;

    }



    /**

     * @dev Returns the integer division of two unsigned integers, reverting on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b > 0, "SafeMath: division by zero");

        return a / b;

    }

}



/**

 * @dev Contract module that helps prevent reentrant calls to a function.

 *

 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier

 * available, which can be applied to functions to make sure there are no nested

 * (reentrant) calls to them.

 *

 * Note that because there is a single `nonReentrant` guard, functions marked as

 * `nonReentrant` may not call one another. This can be worked around by making

 * those functions `private`, and then adding `external` `nonReentrant` entry

 * points to them.

 *

 * TIP: If you would like to learn more about reentrancy and alternative ways

 * to protect against it, check out our blog post

 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].

 */

abstract contract ReentrancyGuard {

    // Booleans are more expensive than uint256 or any type that takes up a full

    // word because each write operation emits an extra SLOAD to first read the

    // slot's contents, replace the bits taken up by the boolean, and then write

    // back. This is the compiler's defense against contract upgrades and

    // pointer aliasing, and it cannot be disabled.



    // The values being non-zero value makes deployment a bit more expensive,

    // but in exchange the refund on every call to nonReentrant will be lower in

    // amount. Since refunds are capped to a percentage of the total

    // transaction's gas, it is best to keep them low in cases like this one, to

    // increase the likelihood of the full refund coming into effect.

    uint256 private constant _NOT_ENTERED = 1;

    uint256 private constant _ENTERED = 2;



    uint256 private _status;



    constructor() {

        _status = _NOT_ENTERED;

    }



    /**

     * @dev Prevents a contract from calling itself, directly or indirectly.

     * Calling a `nonReentrant` function from another `nonReentrant`

     * function is not supported. It is possible to prevent this from happening

     * by making the `nonReentrant` function external, and make it call a

     * `private` function that does the actual work.

     */

    modifier nonReentrant() {

        // On the first call to nonReentrant, _notEntered will be true

        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");



        // Any calls to nonReentrant after this point will fail

        _status = _ENTERED;



        _;



        // By storing the original value once again, a refund is triggered (see

        // https://eips.ethereum.org/EIPS/eip-2200)

        _status = _NOT_ENTERED;

    }

}





/**

 * @dev Interface of the ERC165 standard, as defined in the

 * https://eips.ethereum.org/EIPS/eip-165[EIP].

 *

 * Implementers can declare support of contract interfaces, which can then be

 * queried by others ({ERC165Checker}).

 *

 * For an implementation, see {ERC165}.

 */

interface IERC165 {

    /**

     * @dev Returns true if this contract implements the interface defined by

     * `interfaceId`. See the corresponding

     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]

     * to learn more about how these ids are created.

     *

     * This function call must use less than 30 000 gas.

     */

    function supportsInterface(bytes4 interfaceId) external view returns (bool);

}





/**

 * @dev Implementation of the {IERC165} interface.

 *

 * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check

 * for the additional interface id that will be supported. For example:

 *

 * ```solidity

 * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {

 *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);

 * }

 * ```

 *

 * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.

 */

abstract contract ERC165 is IERC165 {

    /**

     * @dev See {IERC165-supportsInterface}.

     */

    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {

        return interfaceId == type(IERC165).interfaceId;

    }

}





/**

 * @title ERC721 token receiver interface

 * @dev Interface for any contract that wants to support safeTransfers

 * from ERC721 asset contracts.

 */

interface IERC721Receiver {

    /**

     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}

     * by `operator` from `from`, this function is called.

     *

     * It must return its Solidity selector to confirm the token transfer.

     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.

     *

     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.

     */

    function onERC721Received(

        address operator,

        address from,

        uint256 tokenId,

        bytes calldata data

    ) external returns (bytes4);

}





/**

 * @dev Required interface of an ERC721 compliant contract.

 */

interface IERC721 is IERC165 {

    /**

     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.

     */

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);



    /**

     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.

     */

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);



    /**

     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.

     */

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);



    /**

     * @dev Returns the number of tokens in ``owner``'s account.

     */

    function balanceOf(address owner) external view returns (uint256 balance);



    /**

     * @dev Returns the owner of the `tokenId` token.

     *

     * Requirements:

     *

     * - `tokenId` must exist.

     */

    function ownerOf(uint256 tokenId) external view returns (address owner);



    /**

     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients

     * are aware of the ERC721 protocol to prevent tokens from being forever locked.

     *

     * Requirements:

     *

     * - `from` cannot be the zero address.

     * - `to` cannot be the zero address.

     * - `tokenId` token must exist and be owned by `from`.

     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.

     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.

     *

     * Emits a {Transfer} event.

     */

    function safeTransferFrom(

        address from,

        address to,

        uint256 tokenId

    ) external;



    /**

     * @dev Transfers `tokenId` token from `from` to `to`.

     *

     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.

     *

     * Requirements:

     *

     * - `from` cannot be the zero address.

     * - `to` cannot be the zero address.

     * - `tokenId` token must be owned by `from`.

     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.

     *

     * Emits a {Transfer} event.

     */

    function transferFrom(

        address from,

        address to,

        uint256 tokenId

    ) external;



    /**

     * @dev Gives permission to `to` to transfer `tokenId` token to another account.

     * The approval is cleared when the token is transferred.

     *

     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.

     *

     * Requirements:

     *

     * - The caller must own the token or be an approved operator.

     * - `tokenId` must exist.

     *

     * Emits an {Approval} event.

     */

    function approve(address to, uint256 tokenId) external;



    /**

     * @dev Returns the account approved for `tokenId` token.

     *

     * Requirements:

     *

     * - `tokenId` must exist.

     */

    function getApproved(uint256 tokenId) external view returns (address operator);



    /**

     * @dev Approve or remove `operator` as an operator for the caller.

     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.

     *

     * Requirements:

     *

     * - The `operator` cannot be the caller.

     *

     * Emits an {ApprovalForAll} event.

     */

    function setApprovalForAll(address operator, bool _approved) external;



    /**

     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.

     *

     * See {setApprovalForAll}

     */

    function isApprovedForAll(address owner, address operator) external view returns (bool);



    /**

     * @dev Safely transfers `tokenId` token from `from` to `to`.

     *

     * Requirements:

     *

     * - `from` cannot be the zero address.

     * - `to` cannot be the zero address.

     * - `tokenId` token must exist and be owned by `from`.

     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.

     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.

     *

     * Emits a {Transfer} event.

     */

    function safeTransferFrom(

        address from,

        address to,

        uint256 tokenId,

        bytes calldata data

    ) external;

}





/**

 * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension

 * @dev See https://eips.ethereum.org/EIPS/eip-721

 */

interface IERC721Enumerable is IERC721 {

    /**

     * @dev Returns the total amount of tokens stored by the contract.

     */

    function totalSupply() external view returns (uint256);



    /**

     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.

     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.

     */

    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);



    /**

     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.

     * Use along with {totalSupply} to enumerate all tokens.

     */

    function tokenByIndex(uint256 index) external view returns (uint256);

}





/**

 * @title ERC-721 Non-Fungible Token Standard, optional metadata extension

 * @dev See https://eips.ethereum.org/EIPS/eip-721

 */

interface IERC721Metadata is IERC721 {

    /**

     * @dev Returns the token collection name.

     */

    function name() external view returns (string memory);



    /**

     * @dev Returns the token collection symbol.

     */

    function symbol() external view returns (string memory);



    /**

     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.

     */

    function tokenURI(uint256 tokenId) external view returns (string memory);

}





/**

 * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including

 * the Metadata and Enumerable extension. Built to optimize for lower gas during batch mints.

 *

 * Assumes serials are sequentially minted starting at 0 (e.g. 0, 1, 2, 3..).

 *

 * Assumes the number of issuable tokens (collection size) is capped and fits in a uint128.

 *

 * Does not support burning tokens to address(0).

 */

contract ERC721A is

  Context,

  ERC165,

  IERC721,

  IERC721Metadata,

  IERC721Enumerable

{

  using Address for address;

  using Strings for uint256;



  struct TokenOwnership {

    address addr;

    uint64 startTimestamp;

  }



  struct AddressData {

    uint128 balance;

    uint128 numberMinted;

  }



  uint256 private currentIndex = 0;



  uint256 internal immutable collectionSize;

  uint256 internal immutable maxBatchSize;



  // Token name

  string private _name;



  // Token symbol

  string private _symbol;



  // Mapping from token ID to ownership details

  // An empty struct value does not necessarily mean the token is unowned. See ownershipOf implementation for details.

  mapping(uint256 => TokenOwnership) private _ownerships;



  // Mapping owner address to address data

  mapping(address => AddressData) private _addressData;



  // Mapping from token ID to approved address

  mapping(uint256 => address) private _tokenApprovals;



  // Mapping from owner to operator approvals

  mapping(address => mapping(address => bool)) private _operatorApprovals;



  /**

   * @dev

   * `maxBatchSize` refers to how much a minter can mint at a time.

   * `collectionSize_` refers to how many tokens are in the collection.

   */

  constructor(

    string memory name_,

    string memory symbol_,

    uint256 maxBatchSize_,

    uint256 collectionSize_

  ) {

    require(

      collectionSize_ > 0,

      "ERC721A: collection must have a nonzero supply"

    );

    require(maxBatchSize_ > 0, "ERC721A: max batch size must be nonzero");

    _name = name_;

    _symbol = symbol_;

    maxBatchSize = maxBatchSize_;

    collectionSize = collectionSize_;

  }



  /**

   * @dev See {IERC721Enumerable-totalSupply}.

   */

  function totalSupply() public view override returns (uint256) {

    return currentIndex;

  }



  /**

   * @dev See {IERC721Enumerable-tokenByIndex}.

   */

  function tokenByIndex(uint256 index) public view override returns (uint256) {

    require(index < totalSupply(), "ERC721A: global index out of bounds");

    return index;

  }



  /**

   * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.

   * This read function is O(collectionSize). If calling from a separate contract, be sure to test gas first.

   * It may also degrade with extremely large collection sizes (e.g >> 10000), test for your use case.

   */

  function tokenOfOwnerByIndex(address owner, uint256 index)

    public

    view

    override

    returns (uint256)

  {

    require(index < balanceOf(owner), "ERC721A: owner index out of bounds");

    uint256 numMintedSoFar = totalSupply();

    uint256 tokenIdsIdx = 0;

    address currOwnershipAddr = address(0);

    for (uint256 i = 0; i < numMintedSoFar; i++) {

      TokenOwnership memory ownership = _ownerships[i];

      if (ownership.addr != address(0)) {

        currOwnershipAddr = ownership.addr;

      }

      if (currOwnershipAddr == owner) {

        if (tokenIdsIdx == index) {

          return i;

        }

        tokenIdsIdx++;

      }

    }

    revert("ERC721A: unable to get token of owner by index");

  }



  /**

   * @dev See {IERC165-supportsInterface}.

   */

  function supportsInterface(bytes4 interfaceId)

    public

    view

    virtual

    override(ERC165, IERC165)

    returns (bool)

  {

    return

      interfaceId == type(IERC721).interfaceId ||

      interfaceId == type(IERC721Metadata).interfaceId ||

      interfaceId == type(IERC721Enumerable).interfaceId ||

      super.supportsInterface(interfaceId);

  }



  /**

   * @dev See {IERC721-balanceOf}.

   */

  function balanceOf(address owner) public view override returns (uint256) {

    require(owner != address(0), "ERC721A: balance query for the zero address");

    return uint256(_addressData[owner].balance);

  }



  function _numberMinted(address owner) internal view returns (uint256) {

    require(

      owner != address(0),

      "ERC721A: number minted query for the zero address"

    );

    return uint256(_addressData[owner].numberMinted);

  }



  function ownershipOf(uint256 tokenId)

    internal

    view

    returns (TokenOwnership memory)

  {

    require(_exists(tokenId), "ERC721A: owner query for nonexistent token");



    uint256 lowestTokenToCheck;

    if (tokenId >= maxBatchSize) {

      lowestTokenToCheck = tokenId - maxBatchSize + 1;

    }



    for (uint256 curr = tokenId; curr >= lowestTokenToCheck; curr--) {

      TokenOwnership memory ownership = _ownerships[curr];

      if (ownership.addr != address(0)) {

        return ownership;

      }

    }



    revert("ERC721A: unable to determine the owner of token");

  }



  /**

   * @dev See {IERC721-ownerOf}.

   */

  function ownerOf(uint256 tokenId) public view override returns (address) {

    return ownershipOf(tokenId).addr;

  }



  /**

   * @dev See {IERC721Metadata-name}.

   */

  function name() public view virtual override returns (string memory) {

    return _name;

  }



  /**

   * @dev See {IERC721Metadata-symbol}.

   */

  function symbol() public view virtual override returns (string memory) {

    return _symbol;

  }



  /**

   * @dev See {IERC721Metadata-tokenURI}.

   */

  function tokenURI(uint256 tokenId)

    public

    view

    virtual

    override

    returns (string memory)

  {

    require(

      _exists(tokenId),

      "ERC721Metadata: URI query for nonexistent token"

    );



    string memory baseURI = _baseURI();

    return

      bytes(baseURI).length > 0

        ? string(abi.encodePacked(baseURI, tokenId.toString()))

        : "";

  }



  /**

   * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each

   * token will be the concatenation of the `baseURI` and the `tokenId`. Empty

   * by default, can be overriden in child contracts.

   */

  function _baseURI() internal view virtual returns (string memory) {

    return "";

  }



  /**

   * @dev See {IERC721-approve}.

   */

  function approve(address to, uint256 tokenId) public virtual override {

    address owner = ERC721A.ownerOf(tokenId);

    require(to != owner, "ERC721A: approval to current owner");



    require(

      _msgSender() == owner || isApprovedForAll(owner, _msgSender()),

      "ERC721A: approve caller is not owner nor approved for all"

    );



    _approve(to, tokenId, owner);

  }



  /**

   * @dev See {IERC721-getApproved}.

   */

  function getApproved(uint256 tokenId) public view override returns (address) {

    require(_exists(tokenId), "ERC721A: approved query for nonexistent token");



    return _tokenApprovals[tokenId];

  }



  /**

   * @dev See {IERC721-setApprovalForAll}.

   */

  function setApprovalForAll(address operator, bool approved) public virtual override {

    require(operator != _msgSender(), "ERC721A: approve to caller");



    _operatorApprovals[_msgSender()][operator] = approved;

    emit ApprovalForAll(_msgSender(), operator, approved);

  }



  /**

   * @dev See {IERC721-isApprovedForAll}.

   */

  function isApprovedForAll(address owner, address operator)

    public

    view

    virtual

    override

    returns (bool)

  {

    return _operatorApprovals[owner][operator];

  }



  /**

   * @dev See {IERC721-transferFrom}.

   */

  function transferFrom(

    address from,

    address to,

    uint256 tokenId

  ) public virtual override {

    _transfer(from, to, tokenId);

  }



  /**

   * @dev See {IERC721-safeTransferFrom}.

   */

  function safeTransferFrom(

    address from,

    address to,

    uint256 tokenId

  ) public virtual override {

    safeTransferFrom(from, to, tokenId, "");

  }



  /**

   * @dev See {IERC721-safeTransferFrom}.

   */

  function safeTransferFrom(

    address from,

    address to,

    uint256 tokenId,

    bytes memory _data

  ) public virtual override {

    _transfer(from, to, tokenId);

    require(

      _checkOnERC721Received(from, to, tokenId, _data),

      "ERC721A: transfer to non ERC721Receiver implementer"

    );

  }



  /**

   * @dev Returns whether `tokenId` exists.

   *

   * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.

   *

   * Tokens start existing when they are minted (`_mint`),

   */

  function _exists(uint256 tokenId) internal view returns (bool) {

    return tokenId < currentIndex;

  }



  function _safeMint(address to, uint256 quantity) internal {

    _safeMint(to, quantity, "");

  }



  /**

   * @dev Mints `quantity` tokens and transfers them to `to`.

   *

   * Requirements:

   *

   * - there must be `quantity` tokens remaining unminted in the total collection.

   * - `to` cannot be the zero address.

   * - `quantity` cannot be larger than the max batch size.

   *

   * Emits a {Transfer} event.

   */

  function _safeMint(

    address to,

    uint256 quantity,

    bytes memory _data

  ) internal {

    uint256 startTokenId = currentIndex;

    require(to != address(0), "ERC721A: mint to the zero address");

    // We know if the first token in the batch doesn't exist, the other ones don't as well, because of serial ordering.

    require(!_exists(startTokenId), "ERC721A: token already minted");

    require(quantity <= maxBatchSize, "ERC721A: quantity to mint too high");



    _beforeTokenTransfers(address(0), to, startTokenId, quantity);



    AddressData memory addressData = _addressData[to];

    _addressData[to] = AddressData(

      addressData.balance + uint128(quantity),

      addressData.numberMinted + uint128(quantity)

    );

    _ownerships[startTokenId] = TokenOwnership(to, uint64(block.timestamp));



    uint256 updatedIndex = startTokenId;



    for (uint256 i = 0; i < quantity; i++) {

      emit Transfer(address(0), to, updatedIndex);

      require(

        _checkOnERC721Received(address(0), to, updatedIndex, _data),

        "ERC721A: transfer to non ERC721Receiver implementer"

      );

      updatedIndex++;

    }



    currentIndex = updatedIndex;

    _afterTokenTransfers(address(0), to, startTokenId, quantity);

  }



  /**

   * @dev Transfers `tokenId` from `from` to `to`. 

   *

   * Requirements:

   *

   * - `to` cannot be the zero address.

   * - `tokenId` token must be owned by `from`.

   *

   * Emits a {Transfer} event.

   */

  function _transfer(

    address from,

    address to,

    uint256 tokenId

  ) private {

    TokenOwnership memory prevOwnership = ownershipOf(tokenId);



    bool isApprovedOrOwner = (_msgSender() == prevOwnership.addr ||

      getApproved(tokenId) == _msgSender() ||

      isApprovedForAll(prevOwnership.addr, _msgSender()));



    require(

      isApprovedOrOwner,

      "ERC721A: transfer caller is not owner nor approved"

    );



    require(

      prevOwnership.addr == from,

      "ERC721A: transfer from incorrect owner"

    );

    require(to != address(0), "ERC721A: transfer to the zero address");



    _beforeTokenTransfers(from, to, tokenId, 1);



    // Clear approvals from the previous owner

    _approve(address(0), tokenId, prevOwnership.addr);



    _addressData[from].balance -= 1;

    _addressData[to].balance += 1;

    _ownerships[tokenId] = TokenOwnership(to, uint64(block.timestamp));



    // If the ownership slot of tokenId+1 is not explicitly set, that means the transfer initiator owns it.

    // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.

    uint256 nextTokenId = tokenId + 1;

    if (_ownerships[nextTokenId].addr == address(0)) {

      if (_exists(nextTokenId)) {

        _ownerships[nextTokenId] = TokenOwnership(

          prevOwnership.addr,

          prevOwnership.startTimestamp

        );

      }

    }



    emit Transfer(from, to, tokenId);

    _afterTokenTransfers(from, to, tokenId, 1);

  }



  /**

   * @dev Approve `to` to operate on `tokenId`

   *

   * Emits a {Approval} event.

   */

  function _approve(

    address to,

    uint256 tokenId,

    address owner

  ) private {

    _tokenApprovals[tokenId] = to;

    emit Approval(owner, to, tokenId);

  }



  uint256 public nextOwnerToExplicitlySet = 0;



  /**

   * @dev Explicitly set `owners` to eliminate loops in future calls of ownerOf().

   */

  function _setOwnersExplicit(uint256 quantity) internal {

    uint256 oldNextOwnerToSet = nextOwnerToExplicitlySet;

    require(quantity > 0, "quantity must be nonzero");

    uint256 endIndex = oldNextOwnerToSet + quantity - 1;

    if (endIndex > collectionSize - 1) {

      endIndex = collectionSize - 1;

    }

    // We know if the last one in the group exists, all in the group exist, due to serial ordering.

    require(_exists(endIndex), "not enough minted yet for this cleanup");

    for (uint256 i = oldNextOwnerToSet; i <= endIndex; i++) {

      if (_ownerships[i].addr == address(0)) {

        TokenOwnership memory ownership = ownershipOf(i);

        _ownerships[i] = TokenOwnership(

          ownership.addr,

          ownership.startTimestamp

        );

      }

    }

    nextOwnerToExplicitlySet = endIndex + 1;

  }



  /**

   * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.

   * The call is not executed if the target address is not a contract.

   *

   * @param from address representing the previous owner of the given token ID

   * @param to target address that will receive the tokens

   * @param tokenId uint256 ID of the token to be transferred

   * @param _data bytes optional data to send along with the call

   * @return bool whether the call correctly returned the expected magic value

   */

  function _checkOnERC721Received(

    address from,

    address to,

    uint256 tokenId,

    bytes memory _data

  ) private returns (bool) {

    if (to.isContract()) {

      try

        IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data)

      returns (bytes4 retval) {

        return retval == IERC721Receiver(to).onERC721Received.selector;

      } catch (bytes memory reason) {

        if (reason.length == 0) {

          revert("ERC721A: transfer to non ERC721Receiver implementer");

        } else {

          assembly {

            revert(add(32, reason), mload(reason))

          }

        }

      }

    } else {

      return true;

    }

  }



  /**

   * @dev Hook that is called before a set of serially-ordered token ids are about to be transferred. This includes minting.

   *

   * startTokenId - the first token id to be transferred

   * quantity - the amount to be transferred

   *

   * Calling conditions:

   *

   * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be

   * transferred to `to`.

   * - When `from` is zero, `tokenId` will be minted for `to`.

   */

  function _beforeTokenTransfers(

    address from,

    address to,

    uint256 startTokenId,

    uint256 quantity

  ) internal virtual {}



  /**

   * @dev Hook that is called after a set of serially-ordered token ids have been transferred. This includes

   * minting.

   *

   * startTokenId - the first token id to be transferred

   * quantity - the amount to be transferred

   *

   * Calling conditions:

   *

   * - when `from` and `to` are both non-zero.

   * - `from` and `to` are never both zero.

   */

  function _afterTokenTransfers(

    address from,

    address to,

    uint256 startTokenId,

    uint256 quantity

  ) internal virtual {}

}



interface IOperatorFilterRegistry {

    /**

     * @notice Returns true if operator is not filtered for a given token, either by address or codeHash. Also returns

     *         true if supplied registrant address is not registered.

     */

    function isOperatorAllowed(address registrant, address operator) external view returns (bool);



    /**

     * @notice Registers an address with the registry. May be called by address itself or by EIP-173 owner.

     */

    function register(address registrant) external;



    /**

     * @notice Registers an address with the registry and "subscribes" to another address's filtered operators and codeHashes.

     */

    function registerAndSubscribe(address registrant, address subscription) external;



    /**

     * @notice Registers an address with the registry and copies the filtered operators and codeHashes from another

     *         address without subscribing.

     */

    function registerAndCopyEntries(address registrant, address registrantToCopy) external;



    /**

     * @notice Unregisters an address with the registry and removes its subscription. May be called by address itself or by EIP-173 owner.

     *         Note that this does not remove any filtered addresses or codeHashes.

     *         Also note that any subscriptions to this registrant will still be active and follow the existing filtered addresses and codehashes.

     */

    function unregister(address addr) external;



    /**

     * @notice Update an operator address for a registered address - when filtered is true, the operator is filtered.

     */

    function updateOperator(address registrant, address operator, bool filtered) external;



    /**

     * @notice Update multiple operators for a registered address - when filtered is true, the operators will be filtered. Reverts on duplicates.

     */

    function updateOperators(address registrant, address[] calldata operators, bool filtered) external;



    /**

     * @notice Update a codeHash for a registered address - when filtered is true, the codeHash is filtered.

     */

    function updateCodeHash(address registrant, bytes32 codehash, bool filtered) external;



    /**

     * @notice Update multiple codeHashes for a registered address - when filtered is true, the codeHashes will be filtered. Reverts on duplicates.

     */

    function updateCodeHashes(address registrant, bytes32[] calldata codeHashes, bool filtered) external;



    /**

     * @notice Subscribe an address to another registrant's filtered operators and codeHashes. Will remove previous

     *         subscription if present.

     *         Note that accounts with subscriptions may go on to subscribe to other accounts - in this case,

     *         subscriptions will not be forwarded. Instead the former subscription's existing entries will still be

     *         used.

     */

    function subscribe(address registrant, address registrantToSubscribe) external;



    /**

     * @notice Unsubscribe an address from its current subscribed registrant, and optionally copy its filtered operators and codeHashes.

     */

    function unsubscribe(address registrant, bool copyExistingEntries) external;



    /**

     * @notice Get the subscription address of a given registrant, if any.

     */

    function subscriptionOf(address addr) external returns (address registrant);



    /**

     * @notice Get the set of addresses subscribed to a given registrant.

     *         Note that order is not guaranteed as updates are made.

     */

    function subscribers(address registrant) external returns (address[] memory);



    /**

     * @notice Get the subscriber at a given index in the set of addresses subscribed to a given registrant.

     *         Note that order is not guaranteed as updates are made.

     */

    function subscriberAt(address registrant, uint256 index) external returns (address);



    /**

     * @notice Copy filtered operators and codeHashes from a different registrantToCopy to addr.

     */

    function copyEntriesOf(address registrant, address registrantToCopy) external;



    /**

     * @notice Returns true if operator is filtered by a given address or its subscription.

     */

    function isOperatorFiltered(address registrant, address operator) external returns (bool);



    /**

     * @notice Returns true if the hash of an address's code is filtered by a given address or its subscription.

     */

    function isCodeHashOfFiltered(address registrant, address operatorWithCode) external returns (bool);



    /**

     * @notice Returns true if a codeHash is filtered by a given address or its subscription.

     */

    function isCodeHashFiltered(address registrant, bytes32 codeHash) external returns (bool);



    /**

     * @notice Returns a list of filtered operators for a given address or its subscription.

     */

    function filteredOperators(address addr) external returns (address[] memory);



    /**

     * @notice Returns the set of filtered codeHashes for a given address or its subscription.

     *         Note that order is not guaranteed as updates are made.

     */

    function filteredCodeHashes(address addr) external returns (bytes32[] memory);



    /**

     * @notice Returns the filtered operator at the given index of the set of filtered operators for a given address or

     *         its subscription.

     *         Note that order is not guaranteed as updates are made.

     */

    function filteredOperatorAt(address registrant, uint256 index) external returns (address);



    /**

     * @notice Returns the filtered codeHash at the given index of the list of filtered codeHashes for a given address or

     *         its subscription.

     *         Note that order is not guaranteed as updates are made.

     */

    function filteredCodeHashAt(address registrant, uint256 index) external returns (bytes32);



    /**

     * @notice Returns true if an address has registered

     */

    function isRegistered(address addr) external returns (bool);



    /**

     * @dev Convenience method to compute the code hash of an arbitrary contract

     */

    function codeHashOf(address addr) external returns (bytes32);

}



/**

 * @title  OperatorFilterer

 * @notice Abstract contract whose constructor automatically registers and optionally subscribes to or copies another

 *         registrant's entries in the OperatorFilterRegistry.

 * @dev    This smart contract is meant to be inherited by token contracts so they can use the following:

 *         - `onlyAllowedOperator` modifier for `transferFrom` and `safeTransferFrom` methods.

 *         - `onlyAllowedOperatorApproval` modifier for `approve` and `setApprovalForAll` methods.

 *         Please note that if your token contract does not provide an owner with EIP-173, it must provide

 *         administration methods on the contract itself to interact with the registry otherwise the subscription

 *         will be locked to the options set during construction.

 */



abstract contract OperatorFilterer {

    /// @dev Emitted when an operator is not allowed.

    error OperatorNotAllowed(address operator);



    IOperatorFilterRegistry public iOperatorFilterRegistry;



    /// @dev The constructor that is called when the contract is being deployed.

    constructor(address subscriptionOrRegistrantToCopy, bool subscribe) {

        // If an inheriting token contract is deployed to a network without the registry deployed, the modifier

        // will not revert, but the contract will need to be registered with the registry once it is deployed in

        // order for the modifier to filter addresses.

        if (address(iOperatorFilterRegistry).code.length > 0) {

            if (subscribe) {

                iOperatorFilterRegistry.registerAndSubscribe(address(this), subscriptionOrRegistrantToCopy);

            } else {

                if (subscriptionOrRegistrantToCopy != address(0)) {

                    iOperatorFilterRegistry.registerAndCopyEntries(address(this), subscriptionOrRegistrantToCopy);

                } else {

                    iOperatorFilterRegistry.register(address(this));

                }

            }

        }

    }



    /**

     * @dev A helper function to check if an operator is allowed.

     */

    modifier onlyAllowedOperator(address from) virtual {

        // Allow spending tokens from addresses with balance

        // Note that this still allows listings and marketplaces with escrow to transfer tokens if transferred

        // from an EOA.

        if (from != msg.sender) {

            _checkFilterOperator(msg.sender);

        }

        _;

    }



    /**

     * @dev A helper function to check if an operator approval is allowed.

     */

    modifier onlyAllowedOperatorApproval(address operator) virtual {

        _checkFilterOperator(operator);

        _;

    }



    /**

     * @dev A helper function to check if an operator is allowed.

     */

    function _checkFilterOperator(address operator) internal view virtual {

        // Check registry code length to facilitate testing in environments without a deployed registry.

        if (address(iOperatorFilterRegistry).code.length > 0) {

            // under normal circumstances, this function will revert rather than return false, but inheriting contracts

            // may specify their own OperatorFilterRegistry implementations, which may behave differently

            if (!iOperatorFilterRegistry.isOperatorAllowed(address(this), operator)) {

                revert OperatorNotAllowed(operator);

            }

        }

    }

}



// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/ECDSA.sol)

/**

 * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.

 *

 * These functions can be used to verify that a message was signed by the holder

 * of the private keys of a given address.

 */

library ECDSA {

  using Strings for uint256;

    enum RecoverError {

        NoError,

        InvalidSignature,

        InvalidSignatureLength,

        InvalidSignatureS,

        InvalidSignatureV // Deprecated in v4.8

    }



    function _throwError(RecoverError error) private pure {

        if (error == RecoverError.NoError) {

            return; // no error: do nothing

        } else if (error == RecoverError.InvalidSignature) {

            revert("ECDSA: invalid signature");

        } else if (error == RecoverError.InvalidSignatureLength) {

            revert("ECDSA: invalid signature length");

        } else if (error == RecoverError.InvalidSignatureS) {

            revert("ECDSA: invalid signature 's' value");

        }

    }



    /**

     * @dev Returns the address that signed a hashed message (`hash`) with

     * `signature` or error string. This address can then be used for verification purposes.

     *

     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:

     * this function rejects them by requiring the `s` value to be in the lower

     * half order, and the `v` value to be either 27 or 28.

     *

     * IMPORTANT: `hash` _must_ be the result of a hash operation for the

     * verification to be secure: it is possible to craft signatures that

     * recover to arbitrary addresses for non-hashed data. A safe way to ensure

     * this is by receiving a hash of the original message (which may otherwise

     * be too long), and then calling {toEthSignedMessageHash} on it.

     *

     * Documentation for signature generation:

     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]

     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]

     *

     * _Available since v4.3._

     */

    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {

        if (signature.length == 65) {

            bytes32 r;

            bytes32 s;

            uint8 v;

            // ecrecover takes the signature parameters, and the only way to get them

            // currently is to use assembly.

            /// @solidity memory-safe-assembly

            assembly {

                r := mload(add(signature, 0x20))

                s := mload(add(signature, 0x40))

                v := byte(0, mload(add(signature, 0x60)))

            }

            return tryRecover(hash, v, r, s);

        } else {

            return (address(0), RecoverError.InvalidSignatureLength);

        }

    }



    /**

     * @dev Returns the address that signed a hashed message (`hash`) with

     * `signature`. This address can then be used for verification purposes.

     *

     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:

     * this function rejects them by requiring the `s` value to be in the lower

     * half order, and the `v` value to be either 27 or 28.

     *

     * IMPORTANT: `hash` _must_ be the result of a hash operation for the

     * verification to be secure: it is possible to craft signatures that

     * recover to arbitrary addresses for non-hashed data. A safe way to ensure

     * this is by receiving a hash of the original message (which may otherwise

     * be too long), and then calling {toEthSignedMessageHash} on it.

     */

    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {

        (address recovered, RecoverError error) = tryRecover(hash, signature);

        _throwError(error);

        return recovered;

    }



    /**

     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.

     *

     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]

     *

     * _Available since v4.3._

     */

    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {

        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);

        uint8 v = uint8((uint256(vs) >> 255) + 27);

        return tryRecover(hash, v, r, s);

    }



    /**

     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.

     *

     * _Available since v4.2._

     */

    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {

        (address recovered, RecoverError error) = tryRecover(hash, r, vs);

        _throwError(error);

        return recovered;

    }



    /**

     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,

     * `r` and `s` signature fields separately.

     *

     * _Available since v4.3._

     */

    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {

        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature

        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines

        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most

        // signatures from current libraries generate a unique signature with an s-value in the lower half order.

        //

        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value

        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or

        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept

        // these malleable signatures as well.

        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {

            return (address(0), RecoverError.InvalidSignatureS);

        }



        // If the signature is valid (and not malleable), return the signer address

        address signer = ecrecover(hash, v, r, s);

        if (signer == address(0)) {

            return (address(0), RecoverError.InvalidSignature);

        }



        return (signer, RecoverError.NoError);

    }



    /**

     * @dev Overload of {ECDSA-recover} that receives the `v`,

     * `r` and `s` signature fields separately.

     */

    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {

        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);

        _throwError(error);

        return recovered;

    }



    /**

     * @dev Returns an Ethereum Signed Message, created from a `hash`. This

     * produces hash corresponding to the one signed with the

     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]

     * JSON-RPC method as part of EIP-191.

     *

     * See {recover}.

     */

    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {

        // 32 is the length in bytes of hash,

        // enforced by the type signature above

        /// @solidity memory-safe-assembly

        assembly {

            mstore(0x00, "\x19Ethereum Signed Message:\n32")

            mstore(0x1c, hash)

            message := keccak256(0x00, 0x3c)

        }

    }



    /**

     * @dev Returns an Ethereum Signed Message, created from `s`. This

     * produces hash corresponding to the one signed with the

     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]

     * JSON-RPC method as part of EIP-191.

     *

     * See {recover}.

     */

    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {

        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n", Strings.toString(s.length), s));

    }



    /**

     * @dev Returns an Ethereum Signed Typed Data, created from a

     * `domainSeparator` and a `structHash`. This produces hash corresponding

     * to the one signed with the

     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]

     * JSON-RPC method as part of EIP-712.

     *

     * See {recover}.

     */

    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {

        /// @solidity memory-safe-assembly

        assembly {

            let ptr := mload(0x40)

            mstore(ptr, "\x19\x01")

            mstore(add(ptr, 0x02), domainSeparator)

            mstore(add(ptr, 0x22), structHash)

            data := keccak256(ptr, 0x42)

        }

    }



    /**

     * @dev Returns an Ethereum Signed Data with intended validator, created from a

     * `validator` and `data` according to the version 0 of EIP-191.

     *

     * See {recover}.

     */

    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {

        return keccak256(abi.encodePacked("\x19\x00", validator, data));

    }

}



// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)



/**

 * @dev Interface of the ERC1271 standard signature validation method for

 * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].

 *

 * _Available since v4.1._

 */

interface IERC1271 {

    /**

     * @dev Should return whether the signature provided is valid for the provided data

     * @param hash      Hash of the data to be signed

     * @param signature Signature byte array associated with _data

     */

    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);

}



// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/SignatureChecker.sol)

/**

 * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA

 * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like

 * Argent and Gnosis Safe.

 *

 * _Available since v4.1._

 */

library SignatureChecker {

    /**

     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the

     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.

     *

     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus

     * change through time. It could return true at block N and false at block N+1 (or the opposite).

     */

    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature) internal view returns (bool) {

        (address recovered, ECDSA.RecoverError error) = ECDSA.tryRecover(hash, signature);

        return

            (error == ECDSA.RecoverError.NoError && recovered == signer) ||

            isValidERC1271SignatureNow(signer, hash, signature);

    }



    /**

     * @dev Checks if a signature is valid for a given signer and data hash. The signature is validated

     * against the signer smart contract using ERC1271.

     *

     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus

     * change through time. It could return true at block N and false at block N+1 (or the opposite).

     */

    function isValidERC1271SignatureNow(

        address signer,

        bytes32 hash,

        bytes memory signature

    ) internal view returns (bool) {

        (bool success, bytes memory result) = signer.staticcall(

            abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)

        );

        return (success &&

            result.length >= 32 &&

            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));

    }

}



contract SSLegends is Ownable, ERC721A, ReentrancyGuard, OperatorFilterer {

  using ECDSA for bytes32;

  using SafeMath for uint256;



  event OperatorFilterRegistryAddressUpdated(address newRegistry);



  address public signer;



  uint256 public immutable maxPerAddressDuringMint;

  uint256 public immutable amountForWhitelistAndPublic;



  uint256 public maxWhitelistMints;

  uint256 public maxPublicMintsPerTxn;



  address payoutWallet1;

  address payoutWallet2;

  address rerollPayoutWallet;



  uint256 secondaryPartyFee;



  uint256 public saleStartTime;

  uint256 public whitelistStartTime;

  uint256 public goldlistStartTime;





  uint256 public publicSaleCost;

  uint256 public whitelistSaleCost;



  bytes32[] _whitelistRootHash;



  //Using a mapping to track whitelist mints for wallets

  mapping(address => uint256) public whitelistMints;

  //Using a mapping to track goldlist mints for wallets

  mapping(address => uint256) public goldlistMints;

  //Using a mapping for nonces to validate signatures

  mapping(address => uint256) public addressNonce;

  //Mapping to tell if a token was whitelist minted

  mapping(uint256 => bool) public isTokenWhitelistMinted;



  event TokenReRoll(

    uint256 indexed allotmentId

  );



  event GoldlistMint(

    uint256[] allotmentIds,

    uint256[] tokenIds

  );



  event WhitelistMint(

    uint256 startingTokenId,

    uint256 quantity

  );



  constructor(

    uint256 maxBatchSize_,

    uint256 collectionSize_,

    uint256 amountForWhitelistAndPublic_,

    address ioperatorFilterRegistry_,

    address subscriptionOrRegistrantToCopy

  ) ERC721A("Steady Stack Legends", "SSL", maxBatchSize_, collectionSize_) OperatorFilterer(subscriptionOrRegistrantToCopy, true) {

    maxPerAddressDuringMint = maxBatchSize_;

    amountForWhitelistAndPublic = amountForWhitelistAndPublic_;

    require(

      amountForWhitelistAndPublic_ <= collectionSize_,

      "larger collection size needed"

    );

    publicSaleCost = 0.6 ether;

    whitelistSaleCost = 0.5 ether;

    maxWhitelistMints = 1;

    maxPublicMintsPerTxn = 1;

    secondaryPartyFee = 20;

    payoutWallet1 = address(0xA571c6075Ea2DF601909E914E36198528CE610E3);

    payoutWallet2 = address(0xaF62166f50b13Db316C6111Da92E4c694a75EBbd);

    rerollPayoutWallet = address(0x735553423d83572ccd809c587a72d147852DcEB3);



    iOperatorFilterRegistry = IOperatorFilterRegistry(ioperatorFilterRegistry_);

    if (subscriptionOrRegistrantToCopy != address(0)) {

      iOperatorFilterRegistry.registerAndCopyEntries(

        address(this),

        subscriptionOrRegistrantToCopy

      );

    } else {

      iOperatorFilterRegistry.register(address(this));

    }

  }



  function setIOperatorFilterRegistry(address _iOperatorFilterRegistry) external onlyOwner {

    iOperatorFilterRegistry = IOperatorFilterRegistry(_iOperatorFilterRegistry);

    emit OperatorFilterRegistryAddressUpdated(_iOperatorFilterRegistry);

  }



  function updatePayoutWallet(address _newPayoutWallet, bool firstWallet) external onlyOwner{

    if(firstWallet){

      payoutWallet1 = _newPayoutWallet;

    }

    else{

      payoutWallet2 = _newPayoutWallet;

    }

  }



  function updateRerollPayoutWallet(address _newRerollPayoutWallet) external onlyOwner{

      rerollPayoutWallet = _newRerollPayoutWallet;

  }



  function addToWhitelistRootHash(bytes32 _hash) public onlyOwner{

        _whitelistRootHash.push(_hash);

  }



  function clearWhitelist() external onlyOwner{

    delete _whitelistRootHash;

  }



  function setWhitelistStartTime(uint256 _time) external onlyOwner {

    whitelistStartTime = _time;

    goldlistStartTime = _time;

  }



  function setGoldlistStartTimeExplicit(uint256 _time) external onlyOwner{

    goldlistStartTime = _time;

  }



  function setSaleStartTime(uint256 _time) external onlyOwner {

    saleStartTime = _time;

  }



  function setWhitelistSaleCost(uint256 _cost) public onlyOwner{

    whitelistSaleCost = _cost;

  }



  function setPublicSaleCost(uint256 _cost) external onlyOwner {

    publicSaleCost = _cost;

  }



  function getMintedTokenIds(uint256 startingIndex, uint256 quantity) internal pure returns (uint256[] memory) {

      // Create an array with the specified length

      uint256[] memory tokenIds = new uint256[](quantity);



      // Iterate through the loop to populate the array

      for (uint256 i = 0; i < quantity; i++) {

          tokenIds[i] = startingIndex + i;

      }



      return tokenIds;

  }



  function reRoll(uint256 allotmentId, uint256 reRollCost, uint256 nonce, bytes calldata signature) external payable {

    require(verifyRerollSignature(msg.sender, allotmentId, reRollCost, nonce, signature), "invalid re-roll data");

    require(addressNonce[msg.sender] == nonce, "incorrect nonce");

    refundIfOver(reRollCost);

    addressNonce[msg.sender] = addressNonce[msg.sender] + 1;

    payable(rerollPayoutWallet).transfer(reRollCost);

    emit TokenReRoll(allotmentId);

  }



  function publicMint(uint256 quantity) external payable {

    require(saleStartTime != 0 && block.timestamp >= saleStartTime, "sale has not started yet");

    require(totalSupply() + quantity <= amountForWhitelistAndPublic, "not enough remaining to support desired mint amount");

    require(quantity < maxPublicMintsPerTxn, "Can't mint that many in a single transaction");



    uint256 totalCost = publicSaleCost * quantity;

    _safeMint(_msgSender(), quantity);

    refundIfOver(totalCost);

  }



  function goldlistMint(uint256[] calldata allotmentIds, uint256 nonce, bytes calldata signature) external {

    uint256 quantity = allotmentIds.length;



    require(verifyMintSignature(msg.sender, allotmentIds, nonce, signature), "Invalid signature");

    require(addressNonce[msg.sender] == nonce, "incorrect nonce");

    require(goldlistStartTime != 0 && block.timestamp >= goldlistStartTime, "The sale has not started yet");



    uint256[] memory tokenIds = getMintedTokenIds(totalSupply(), quantity);



    _safeMint(_msgSender(), quantity);



    goldlistMints[_msgSender()] += quantity;

    addressNonce[msg.sender] = addressNonce[msg.sender] + 1;

    emit GoldlistMint(allotmentIds, tokenIds);

  }



  function whitelistMint(uint256 quantity, uint256 spotInWhitelist, uint256 maxMints, bytes32[] memory proof) external payable {

    require(whitelistValidated(_msgSender(), spotInWhitelist, maxMints, proof), "You're not on the whitelist");

    require(whitelistStartTime != 0 && block.timestamp >= whitelistStartTime, "The sale has not started yet");

    require(totalSupply() + quantity <= amountForWhitelistAndPublic, "not enough remaining reserved for whitelist to support desired mint amount");

    require(whitelistMints[_msgSender()] + quantity <= maxWhitelistMints, "This address already whitelist minted");



    uint256 premintIndex = totalSupply();

    isTokenWhitelistMinted[premintIndex] = true;



    whitelistMints[_msgSender()] += quantity;



    _safeMint(_msgSender(), quantity);

    refundIfOver(whitelistSaleCost * quantity);

    emit WhitelistMint(premintIndex, quantity);

  }



  function refundIfOver(uint256 price) private {

    require(msg.value >= price, "Need to send more ETH.");

    if (msg.value > price) {

      payable(_msgSender()).transfer(msg.value - price);

    }

  }



  function getCurrentCost() public view returns (uint256) {

    if(saleStartTime != 0 && block.timestamp >= saleStartTime) {

      return publicSaleCost;

    }

    else {

      return whitelistSaleCost;

    }

  }



  function setApprovalForAll(address operator, bool approved) public override onlyAllowedOperatorApproval(operator) {

      super.setApprovalForAll(operator, approved);

  }



  function approve(address operator, uint256 tokenId) public override onlyAllowedOperatorApproval(operator) {

      super.approve(operator, tokenId);

  }



  function transferFrom(address from, address to, uint256 tokenId) public override onlyAllowedOperator(from) {

      super.transferFrom(from, to, tokenId);

  }



  function safeTransferFrom(address from, address to, uint256 tokenId) public override onlyAllowedOperator(from) {

      super.safeTransferFrom(from, to, tokenId);

  }



  function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)

      public

      override

      onlyAllowedOperator(from)

  {

      super.safeTransferFrom(from, to, tokenId, data);

  }



  function emergencyMint(uint256 quantity, address _To) external onlyOwner {

    require(totalSupply() + quantity <= collectionSize, "too many already minted");

    _safeMint(_To, quantity);

  }



  function setSigner(address signer_) external onlyOwner {

      require(signer_ != address(0), "Signer cannot be the zero address");

      signer = signer_;

  }



  function verifyRerollSignature(address walletAddress, uint256 allotmentId, uint256 reRollCost, uint256 nonce, bytes calldata signature) internal view returns (bool) {

        require(signer != address(0), "Signer not set");

        bytes32 hash = keccak256(abi.encodePacked(walletAddress, allotmentId, reRollCost, nonce));

        bytes32 signedHash = hash.toEthSignedMessageHash();



        return SignatureChecker.isValidSignatureNow(signer, signedHash, signature);

  }



  function verifyMintSignature(address walletAddress, uint256[] calldata allotmentIds, uint256 nonce, bytes calldata signature) internal view returns (bool) {

        require(signer != address(0), "Signer not set");

        bytes32 hash = keccak256(abi.encodePacked(walletAddress, allotmentIds, nonce));

        bytes32 signedHash = hash.toEthSignedMessageHash();



        return SignatureChecker.isValidSignatureNow(signer, signedHash, signature);

  }



   // Merkle leaf validator function for storing whitelists off chain saving massive gas

  function whitelistValidated(address wallet, uint256 index, uint256 amount, bytes32[] memory proof) internal view returns (bool) {



        // Compute the merkle root

        bytes32 node = keccak256(abi.encodePacked(index, wallet, amount));

        uint256 path = index;

        for (uint16 i = 0; i < proof.length; i++) {

            if ((path & 0x01) == 1) {

                node = keccak256(abi.encodePacked(proof[i], node));

            } else {

                node = keccak256(abi.encodePacked(node, proof[i]));

            }

            path /= 2;

        }



        // Check the merkle proof against the root hash array

        for(uint i = 0; i < _whitelistRootHash.length; i++)

        {

            if (node == _whitelistRootHash[i])

            {

                return true;

            }

        }



        return false;

    }



  // metadata URI

  string private _baseTokenURI;



  function _baseURI() internal view virtual override returns (string memory) {

    return _baseTokenURI;

  }



  function setBaseURI(string calldata baseURI) external onlyOwner {

    _baseTokenURI = baseURI;

  }



  /*

    * @dev Withdraw all ether from this contract and send to prespecified 

    * wallets (Callable by anyone)

  */

  function withdraw() external {

      uint256 balance = address(this).balance;

      uint256 walletBalance = balance.mul(secondaryPartyFee).div(100);

      payable(payoutWallet1).transfer(walletBalance);

      payable(payoutWallet2).transfer(balance.sub(walletBalance));

  }



  /**

    * @dev Withdraw all erc20 of the signature argument address from this contract and send to prespecified 

    * wallets (Callable by anyone)

  */

  function withdrawERC20(address _token) external {

      IERC20 targetToken = IERC20(_token);

      uint256 balance = targetToken.balanceOf(address(this));

      uint256 walletBalance = balance.mul(secondaryPartyFee).div(100);

      require(balance > 0, "Nothing to withdraw");



      targetToken.transferFrom(address(this), payoutWallet1, walletBalance);

      targetToken.transferFrom(address(this), payoutWallet2, balance.sub(walletBalance));

  }



  function setOwnersExplicit(uint256 quantity) external onlyOwner nonReentrant {

    _setOwnersExplicit(quantity);

  }



  function numberMinted(address owner) public view returns (uint256) {

    return _numberMinted(owner);

  }



  function getOwnershipData(uint256 tokenId)

    external

    view

    returns (TokenOwnership memory)

  {

    return ownershipOf(tokenId);

  }

}