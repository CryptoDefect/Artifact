/**

 *Submitted for verification at Etherscan.io on 2023-05-17

*/



// SPDX-License-Identifier: MIT

/*    _                     _                         _ _             _     

 *   | |                   (_)    _                  | (_)           | |    

 *   | | ___   _ _   _ _ __ _   _| |_    ___  _ __ __| |_ _ __   __ _| |___ 

 *   | |/ / | | | | | | '__| | |_   _|  / _ \| '__/ _` | | '_ \ / _` | / __|

 *   |   <| |_| | |_| | |  | |   |_|   | (_) | | | (_| | | | | | (_| | \__ \

 *   |_|\_\\__, |\__,_|_|  |_|          \___/|_|  \__,_|_|_| |_|\__,_|_|___/

 *          __/ |                                                           

 *         |___/                                                            

*/

pragma solidity ^0.8.19;



library Strings {

    bytes16 private constant _SYMBOLS = "0123456789abcdef";

    uint8 private constant _ADDRESS_LENGTH = 20;



    function toString(uint256 value) internal pure returns (string memory) {

        unchecked {

            uint256 length = Math.log10(value) + 1;

            string memory buffer = new string(length);

            uint256 ptr;

            assembly {

                ptr := add(buffer, add(32, length))

            }

            while (true) {

                ptr--;

                assembly {

                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))

                }

                value /= 10;

                if (value == 0) break;

            }

            return buffer;

        }

    }



    function toString(int256 value) internal pure returns (string memory) {

        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMath.abs(value))));

    }



    function toHexString(uint256 value) internal pure returns (string memory) {

        unchecked {

            return toHexString(value, Math.log256(value) + 1);

        }

    }



    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {

        bytes memory buffer = new bytes(2 * length + 2);

        buffer[0] = "0";

        buffer[1] = "x";

        for (uint256 i = 2 * length + 1; i > 1; --i) {

            buffer[i] = _SYMBOLS[value & 0xf];

            value >>= 4;

        }

        require(value == 0, "Strings: hex length insufficient");

        return string(buffer);

    }



    function toHexString(address addr) internal pure returns (string memory) {

        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);

    }



    function equal(string memory a, string memory b) internal pure returns (bool) {

        return keccak256(bytes(a)) == keccak256(bytes(b));

    }

}



abstract contract Context {

    function _msgSender() internal view virtual returns (address) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes calldata) {

        return msg.data;

    }

}



library Address {

    function isContract(address account) internal view returns (bool) {



        return account.code.length > 0;

    }



    function sendValue(address payable recipient, uint256 amount) internal {

        require(address(this).balance >= amount, "Address: insufficient balance");



        (bool success, ) = recipient.call{value: amount}("");

        require(success, "Address: unable to send value, recipient may have reverted");

    }



    function functionCall(address target, bytes memory data) internal returns (bytes memory) {

        return functionCallWithValue(target, data, 0, "Address: low-level call failed");

    }



    function functionCall(

        address target,

        bytes memory data,

        string memory errorMessage

    ) internal returns (bytes memory) {

        return functionCallWithValue(target, data, 0, errorMessage);

    }



    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {

        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");

    }



    function functionCallWithValue(

        address target,

        bytes memory data,

        uint256 value,

        string memory errorMessage

    ) internal returns (bytes memory) {

        require(address(this).balance >= value, "Address: insufficient balance for call");

        (bool success, bytes memory returndata) = target.call{value: value}(data);

        return verifyCallResultFromTarget(target, success, returndata, errorMessage);

    }



    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {

        return functionStaticCall(target, data, "Address: low-level static call failed");

    }



    function functionStaticCall(

        address target,

        bytes memory data,

        string memory errorMessage

    ) internal view returns (bytes memory) {

        (bool success, bytes memory returndata) = target.staticcall(data);

        return verifyCallResultFromTarget(target, success, returndata, errorMessage);

    }



    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {

        return functionDelegateCall(target, data, "Address: low-level delegate call failed");

    }



    function functionDelegateCall(

        address target,

        bytes memory data,

        string memory errorMessage

    ) internal returns (bytes memory) {

        (bool success, bytes memory returndata) = target.delegatecall(data);

        return verifyCallResultFromTarget(target, success, returndata, errorMessage);

    }



    function verifyCallResultFromTarget(

        address target,

        bool success,

        bytes memory returndata,

        string memory errorMessage

    ) internal view returns (bytes memory) {

        if (success) {

            if (returndata.length == 0) {

                require(isContract(target), "Address: call to non-contract");

            }

            return returndata;

        } else {

            _revert(returndata, errorMessage);

        }

    }



    function verifyCallResult(

        bool success,

        bytes memory returndata,

        string memory errorMessage

    ) internal pure returns (bytes memory) {

        if (success) {

            return returndata;

        } else {

            _revert(returndata, errorMessage);

        }

    }



    function _revert(bytes memory returndata, string memory errorMessage) private pure {

        if (returndata.length > 0) {

            assembly {

                let returndata_size := mload(returndata)

                revert(add(32, returndata), returndata_size)

            }

        } else {

            revert(errorMessage);

        }

    }

}



library Base64 {

    string internal constant _TABLE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";



    function encode(bytes memory data) internal pure returns (string memory) {

        if (data.length == 0) return "";



        string memory table = _TABLE;



        string memory result = new string(4 * ((data.length + 2) / 3));



        assembly {

            let tablePtr := add(table, 1)



            let resultPtr := add(result, 32)



            for {

                let dataPtr := data

                let endPtr := add(data, mload(data))

            } lt(dataPtr, endPtr) {



            } {

                dataPtr := add(dataPtr, 3)

                let input := mload(dataPtr)



                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))

                resultPtr := add(resultPtr, 1)



                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))

                resultPtr := add(resultPtr, 1)



                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))

                resultPtr := add(resultPtr, 1)



                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))

                resultPtr := add(resultPtr, 1)

            }



            switch mod(mload(data), 3)

            case 1 {

                mstore8(sub(resultPtr, 1), 0x3d)

                mstore8(sub(resultPtr, 2), 0x3d)

            }

            case 2 {

                mstore8(sub(resultPtr, 1), 0x3d)

            }

        }

        return result;

    }

}



library Math {

    enum Rounding {

        Down,

        Up,

        Zero

    }



    function max(uint256 a, uint256 b) internal pure returns (uint256) {

        return a > b ? a : b;

    }



    function min(uint256 a, uint256 b) internal pure returns (uint256) {

        return a < b ? a : b;

    }



    function average(uint256 a, uint256 b) internal pure returns (uint256) {

        return (a & b) + (a ^ b) / 2;

    }



    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {

        return a == 0 ? 0 : (a - 1) / b + 1;

    }



    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {

        unchecked {

            uint256 prod0;

            uint256 prod1;

            assembly {

                let mm := mulmod(x, y, not(0))

                prod0 := mul(x, y)

                prod1 := sub(sub(mm, prod0), lt(mm, prod0))

            }



            if (prod1 == 0) {

                return prod0 / denominator;

            }



            require(denominator > prod1, "Math: mulDiv overflow");



            uint256 remainder;

            assembly {

                remainder := mulmod(x, y, denominator)



                prod1 := sub(prod1, gt(remainder, prod0))

                prod0 := sub(prod0, remainder)

            }



            uint256 twos = denominator & (~denominator + 1);

            assembly {

                denominator := div(denominator, twos)



                prod0 := div(prod0, twos)



                twos := add(div(sub(0, twos), twos), 1)

            }



            prod0 |= prod1 * twos;



            uint256 inverse = (3 * denominator) ^ 2;



            inverse *= 2 - denominator * inverse;

            inverse *= 2 - denominator * inverse;

            inverse *= 2 - denominator * inverse;

            inverse *= 2 - denominator * inverse;

            inverse *= 2 - denominator * inverse;

            inverse *= 2 - denominator * inverse;



            result = prod0 * inverse;

            return result;

        }

    }



    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {

        uint256 result = mulDiv(x, y, denominator);

        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {

            result += 1;

        }

        return result;

    }



    function sqrt(uint256 a) internal pure returns (uint256) {

        if (a == 0) {

            return 0;

        }



        uint256 result = 1 << (log2(a) >> 1);



        unchecked {

            result = (result + a / result) >> 1;

            result = (result + a / result) >> 1;

            result = (result + a / result) >> 1;

            result = (result + a / result) >> 1;

            result = (result + a / result) >> 1;

            result = (result + a / result) >> 1;

            result = (result + a / result) >> 1;

            return min(result, a / result);

        }

    }



    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {

        unchecked {

            uint256 result = sqrt(a);

            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);

        }

    }



    function log2(uint256 value) internal pure returns (uint256) {

        uint256 result = 0;

        unchecked {

            if (value >> 128 > 0) {

                value >>= 128;

                result += 128;

            }

            if (value >> 64 > 0) {

                value >>= 64;

                result += 64;

            }

            if (value >> 32 > 0) {

                value >>= 32;

                result += 32;

            }

            if (value >> 16 > 0) {

                value >>= 16;

                result += 16;

            }

            if (value >> 8 > 0) {

                value >>= 8;

                result += 8;

            }

            if (value >> 4 > 0) {

                value >>= 4;

                result += 4;

            }

            if (value >> 2 > 0) {

                value >>= 2;

                result += 2;

            }

            if (value >> 1 > 0) {

                result += 1;

            }

        }

        return result;

    }



    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {

        unchecked {

            uint256 result = log2(value);

            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);

        }

    }



    function log10(uint256 value) internal pure returns (uint256) {

        uint256 result = 0;

        unchecked {

            if (value >= 10 ** 64) {

                value /= 10 ** 64;

                result += 64;

            }

            if (value >= 10 ** 32) {

                value /= 10 ** 32;

                result += 32;

            }

            if (value >= 10 ** 16) {

                value /= 10 ** 16;

                result += 16;

            }

            if (value >= 10 ** 8) {

                value /= 10 ** 8;

                result += 8;

            }

            if (value >= 10 ** 4) {

                value /= 10 ** 4;

                result += 4;

            }

            if (value >= 10 ** 2) {

                value /= 10 ** 2;

                result += 2;

            }

            if (value >= 10 ** 1) {

                result += 1;

            }

        }

        return result;

    }



    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {

        unchecked {

            uint256 result = log10(value);

            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);

        }

    }



    function log256(uint256 value) internal pure returns (uint256) {

        uint256 result = 0;

        unchecked {

            if (value >> 128 > 0) {

                value >>= 128;

                result += 16;

            }

            if (value >> 64 > 0) {

                value >>= 64;

                result += 8;

            }

            if (value >> 32 > 0) {

                value >>= 32;

                result += 4;

            }

            if (value >> 16 > 0) {

                value >>= 16;

                result += 2;

            }

            if (value >> 8 > 0) {

                result += 1;

            }

        }

        return result;

    }



    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {

        unchecked {

            uint256 result = log256(value);

            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);

        }

    }

}



library SignedMath {

    function max(int256 a, int256 b) internal pure returns (int256) {

        return a > b ? a : b;

    }



    function min(int256 a, int256 b) internal pure returns (int256) {

        return a < b ? a : b;

    }



    function average(int256 a, int256 b) internal pure returns (int256) {

        int256 x = (a & b) + ((a ^ b) >> 1);

        return x + (int256(uint256(x) >> 255) & (a ^ b));

    }



    function abs(int256 n) internal pure returns (uint256) {

        unchecked {

            return uint256(n >= 0 ? n : -n);

        }

    }

}

// End of openzeppelin libraries



interface IERC721Receiver {

    function onERC721Received(

        address operator,

        address from,

        uint256 tokenId,

        bytes calldata data

    ) external returns (bytes4);

}



interface IERC165 {

    function supportsInterface(bytes4 interfaceId) external view returns (bool);

}



abstract contract ERC165 is IERC165 {

    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {

        return interfaceId == type(IERC165).interfaceId;

    }

}



interface IERC721 is IERC165 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);



    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);



    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);



    function balanceOf(address owner) external view returns (uint256 balance);



    function ownerOf(uint256 tokenId) external view returns (address owner);



    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;



    function safeTransferFrom(address from, address to, uint256 tokenId) external;



    function transferFrom(address from, address to, uint256 tokenId) external;



    function approve(address to, uint256 tokenId) external;



    function setApprovalForAll(address operator, bool approved) external;



    function getApproved(uint256 tokenId) external view returns (address operator);



    function isApprovedForAll(address owner, address operator) external view returns (bool);

}



interface IERC721Metadata is IERC721 {

    function name() external view returns (string memory);



    function symbol() external view returns (string memory);



    function tokenURI(uint256 tokenId) external view returns (string memory);

}



contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {

    using Address for address;

    using Strings for uint256;



    string private _name;



    string private _symbol;



    mapping(uint256 => address) private _owners;



    mapping(address => uint256) private _balances;



    mapping(uint256 => address) private _tokenApprovals;



    mapping(address => mapping(address => bool)) private _operatorApprovals;



    constructor(string memory name_, string memory symbol_) {

        _name = name_;

        _symbol = symbol_;

    }



    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {

        return

            interfaceId == type(IERC721).interfaceId ||

            interfaceId == type(IERC721Metadata).interfaceId ||

            super.supportsInterface(interfaceId);

    }



    function balanceOf(address owner) public view virtual override returns (uint256) {

        require(owner != address(0), "ERC721: address zero is not a valid owner");

        return _balances[owner];

    }



    function ownerOf(uint256 tokenId) public view virtual override returns (address) {

        address owner = _ownerOf(tokenId);

        require(owner != address(0), "ERC721: invalid token ID");

        return owner;

    }



    function name() public view virtual override returns (string memory) {

        return _name;

    }



    function symbol() public view virtual override returns (string memory) {

        return _symbol;

    }



    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {

        _requireMinted(tokenId);



        string memory baseURI = _baseURI();

        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";

    }



    function _baseURI() internal view virtual returns (string memory) {

        return "";

    }



    function approve(address to, uint256 tokenId) public virtual override {

        address owner = ERC721.ownerOf(tokenId);

        require(to != owner, "ERC721: approval to current owner");

        require(

            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),

            "ERC721: approve caller is not token owner or approved for all"

        );



        _approve(to, tokenId);

    }



    function getApproved(uint256 tokenId) public view virtual override returns (address) {

        _requireMinted(tokenId);

        return _tokenApprovals[tokenId];

    }



    function setApprovalForAll(address operator, bool approved) public virtual override {

        _setApprovalForAll(_msgSender(), operator, approved);

    }



    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {

        return _operatorApprovals[owner][operator];

    }



    function transferFrom(address from, address to, uint256 tokenId) public virtual override {

        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");

        _transfer(from, to, tokenId);

    }



    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {

        safeTransferFrom(from, to, tokenId, "");

    }



    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {

        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");

        _safeTransfer(from, to, tokenId, data);

    }



    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {

        _transfer(from, to, tokenId);

        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");

    }



    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {

        return _owners[tokenId];

    }



    function _exists(uint256 tokenId) internal view virtual returns (bool) {

        return _ownerOf(tokenId) != address(0);

    }



    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {

        address owner = ERC721.ownerOf(tokenId);

        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);

    }



    function _safeMint(address to, uint256 tokenId) internal virtual {

        _safeMint(to, tokenId, "");

    }



    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {

        _mint(to, tokenId);

        require(

            _checkOnERC721Received(address(0), to, tokenId, data),

            "ERC721: transfer to non ERC721Receiver implementer"

        );

    }



    function _mint(address to, uint256 tokenId) internal virtual {

        require(to != address(0), "ERC721: mint to the zero address");

        require(!_exists(tokenId), "ERC721: token already minted");

        _beforeTokenTransfer(address(0), to, tokenId, 1);

        require(!_exists(tokenId), "ERC721: token already minted");



        unchecked {

            _balances[to] += 1;

        }

        _owners[tokenId] = to;

        emit Transfer(address(0), to, tokenId);

        _afterTokenTransfer(address(0), to, tokenId, 1);

    }



    function _burn(uint256 tokenId) internal virtual {

        address owner = ERC721.ownerOf(tokenId);

        _beforeTokenTransfer(owner, address(0), tokenId, 1);

        owner = ERC721.ownerOf(tokenId);

        delete _tokenApprovals[tokenId];



        unchecked {

            _balances[owner] -= 1;

        }

        delete _owners[tokenId];

        emit Transfer(owner, address(0), tokenId);

        _afterTokenTransfer(owner, address(0), tokenId, 1);

    }



    function _transfer(address from, address to, uint256 tokenId) internal virtual {

        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");

        require(to != address(0), "ERC721: transfer to the zero address");

        _beforeTokenTransfer(from, to, tokenId, 1);

        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");

        delete _tokenApprovals[tokenId];



        unchecked {

            _balances[from] -= 1;

            _balances[to] += 1;

        }

        _owners[tokenId] = to;

        emit Transfer(from, to, tokenId);

        _afterTokenTransfer(from, to, tokenId, 1);

    }



    function _approve(address to, uint256 tokenId) internal virtual {

        _tokenApprovals[tokenId] = to;

        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);

    }



    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {

        require(owner != operator, "ERC721: approve to caller");

        _operatorApprovals[owner][operator] = approved;

        emit ApprovalForAll(owner, operator, approved);

    }



    function _requireMinted(uint256 tokenId) internal view virtual {

        require(_exists(tokenId), "ERC721: invalid token ID");

    }



    function _checkOnERC721Received(

        address from,

        address to,

        uint256 tokenId,

        bytes memory data

    ) private returns (bool) {

        if (to.isContract()) {

            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {

                return retval == IERC721Receiver.onERC721Received.selector;

            } catch (bytes memory reason) {

                if (reason.length == 0) {

                    revert("ERC721: transfer to non ERC721Receiver implementer");

                } else {

                    assembly {

                        revert(add(32, reason), mload(reason))

                    }

                }

            }

        } else {

            return true;

        }

    }



    function _beforeTokenTransfer(

        address from,

        address to,

        uint256 /* firstTokenId */,

        uint256 batchSize

    ) internal virtual {

        if (batchSize > 1) {

            if (from != address(0)) {

                _balances[from] -= batchSize;

            }

            if (to != address(0)) {

                _balances[to] += batchSize;

            }

        }

    }



    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}

}



contract Kyuri is ERC721 {

    address private _owner;

    address public admin;

    address public artist;

    address public author;

    uint public totalArticle;



    uint public maxSupply;

    uint public totalSupply;

    bool public isClosed;

    uint public pigFee;



    uint public totalVotes;

    uint public totalCandidates;

    bool public isPaused;

    uint public regFee;



    struct Pig {

        uint pigId;

        string name;

        uint cost;

        string image;

        bool isOwned;

        string taproot;

        bool isClaimed;

    }



    struct Candidate {

        uint canId;

        string name;

        string image;

        bool resigned;

        uint countVotes;

    }



    struct Voter {

        bool authorised;

        uint whom;

        bool voted;

    }



    struct Article {

        uint artId;

        string hash;

        bool disabled;

    }



    mapping(uint => Pig) pigs;

    mapping(uint => Candidate) public candidates;

    mapping(uint => Article) public articles;

    mapping(address => Voter) public voters;



    modifier ownerOnly() {

        require(msg.sender == _owner);

        _;

    }



    modifier adminOnly() {

        require(msg.sender == admin);

        _;

    }



    modifier artistOnly() {

        require(msg.sender == artist);

        _;

    }



    modifier authorOnly() {

        require(msg.sender == author);

        _;

    }



    constructor() ERC721("cucumber", "KYURI")

    {

        _owner = msg.sender;

    }



    function changeOwner(address newOwner) public ownerOnly {

        _owner = newOwner;

    }



    function owner() public view returns(address) {

        return _owner;

    }



    function modifyCost(uint _id, uint _cost) public ownerOnly {

        require(pigs[_id].isOwned == false);

        pigs[_id].cost = _cost;

    }



    function verifyClaim(uint _id, bool _claim) public ownerOnly {

        pigs[_id].isClaimed = _claim;

    }



    function tag(uint _id, string memory _taproot) public ownerOnly {

        pigs[_id].taproot = _taproot;

    }



    function setPigFee(uint _cost) public ownerOnly {

        pigFee = _cost;

    }



    function redeem(address _to, uint _amount) public ownerOnly {

        (bool success, ) = _to.call{value: _amount}("");

        require(success);

    }



    function assignArtist(address _artist) public ownerOnly {

        artist = _artist;

    }



    function closeShop(bool _close) public ownerOnly {

        isClosed = _close;

    }



    function list(string memory _name, uint _cost, string memory _image) public artistOnly {

        maxSupply++;

        pigs[maxSupply] = Pig(maxSupply, _name, _cost, _image, false, "", false);

    }



    function editPig(uint _id, string memory _name, string memory _image) public artistOnly {

        require(pigs[_id].isOwned == false);

        pigs[_id].name = _name;

        pigs[_id].image = _image;

    }



    function getBalance() public view returns (uint) {

        return address(this).balance;

    }



    function getPig(uint _id) public view returns (Pig memory) {

        return pigs[_id];

    }



    function claimPig(uint _id, string memory _taproot) public payable {

        require(ERC721.ownerOf(_id) == msg.sender);

        require(pigs[_id].isClaimed == false);

        require(msg.value >= pigFee);

        pigs[_id].taproot = _taproot;

    }



    function modifyPig(uint _id, string memory _name, string memory _image) public payable {

        require(ERC721.ownerOf(_id) == msg.sender);

        require(msg.value >= pigFee);

        pigs[_id].name = _name;

        pigs[_id].image = _image;

    }



    function mint(uint _id) public payable {

        require(!isClosed);

        require(_id != 0);

        require(_id <= maxSupply);

        require(pigs[_id].isOwned == false);

        require(msg.value >= pigs[_id].cost);

        voters[msg.sender].authorised = true;

        pigs[_id].isOwned = true;

        totalSupply++;

        _safeMint(msg.sender, _id);

    }



    function tokenURI(uint _id) override(ERC721) public view returns (string memory) {

        string memory json = Base64.encode(

            bytes(string(

                abi.encodePacked(

                    '{'

                    '"name": "', pigs[_id].name, '",',

                    '"image": "', pigs[_id].image, '"',

                    '}'

                )

            ))

        );

        return string(abi.encodePacked('data:application/json;base64,', json));

    }



    function assignAdmin(address _admin) public ownerOnly {

        admin = _admin;

    }



    function setRegFee(uint _cost) public ownerOnly {

        regFee = _cost;

    }



    function pausePoll(bool _pause) public adminOnly {

        isPaused = _pause;

    }



    function addCandidate(string memory _name, string memory _image) public adminOnly {

        totalCandidates++;

        candidates[totalCandidates] = Candidate(totalCandidates, _name, _image, false, 0);

    }



    function modifyCandidate(uint _id, string memory _name, string memory _image) public adminOnly {

        candidates[_id].name = _name;

        candidates[_id].image = _image;

    }



    function resetVotes(uint _id) public adminOnly {

        candidates[_id].countVotes = 0;

    }



    function disableCandidate(uint _id, bool _resigned) public adminOnly {

        candidates[_id].resigned = _resigned;

    }



    function resetVoter(address _voterAddress) public adminOnly {

        voters[_voterAddress].voted = false;

    }



    function resetTotalVotes() public adminOnly {

        totalVotes = 0;

    }



    function selfRegister() public payable {

        require(!isPaused);

        require(ERC721.balanceOf(msg.sender) > 0);

        require(msg.value >= regFee);

        voters[msg.sender].authorised = true;

    }



    function vote(uint _id) public {

        require(!isPaused);

        require(!voters[msg.sender].voted);

        require(!candidates[_id].resigned);

        require(ERC721.balanceOf(msg.sender) > 0);

        require(voters[msg.sender].authorised);

        voters[msg.sender].whom = _id;

        voters[msg.sender].voted = true;

        candidates[_id].countVotes += ERC721.balanceOf(msg.sender);

        totalVotes += ERC721.balanceOf(msg.sender);

    }



    function assignAuthor(address _author) public ownerOnly {

        author = _author;

    }



    function addArticle(string memory _hash) public ownerOnly {

        totalArticle++;

        articles[totalArticle] = Article(totalArticle, _hash, false);

  }



    function disableArticle(uint _id, bool _disabled) public authorOnly {

        articles[_id].disabled = _disabled;

  }



    function editArticle(uint _id, string memory _hash) public authorOnly {

        articles[_id].hash = _hash;

  }

}