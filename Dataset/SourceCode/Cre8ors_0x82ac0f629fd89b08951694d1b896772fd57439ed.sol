{{

  "language": "Solidity",

  "sources": {

    "lib/ERC721A/contracts/ERC721A.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// ERC721A Contracts v4.2.3\n// Creator: Chiru Labs\n\npragma solidity ^0.8.4;\n\nimport './IERC721A.sol';\n\n/**\n * @dev Interface of ERC721 token receiver.\n */\ninterface ERC721A__IERC721Receiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n/**\n * @title ERC721A\n *\n * @dev Implementation of the [ERC721](https://eips.ethereum.org/EIPS/eip-721)\n * Non-Fungible Token Standard, including the Metadata extension.\n * Optimized for lower gas during batch mints.\n *\n * Token IDs are minted in sequential order (e.g. 0, 1, 2, 3, ...)\n * starting from `_startTokenId()`.\n *\n * Assumptions:\n *\n * - An owner cannot have more than 2**64 - 1 (max value of uint64) of supply.\n * - The maximum token ID cannot exceed 2**256 - 1 (max value of uint256).\n */\ncontract ERC721A is IERC721A {\n    // Bypass for a `--via-ir` bug (https://github.com/chiru-labs/ERC721A/pull/364).\n    struct TokenApprovalRef {\n        address value;\n    }\n\n    // =============================================================\n    //                           CONSTANTS\n    // =============================================================\n\n    // Mask of an entry in packed address data.\n    uint256 private constant _BITMASK_ADDRESS_DATA_ENTRY = (1 << 64) - 1;\n\n    // The bit position of `numberMinted` in packed address data.\n    uint256 private constant _BITPOS_NUMBER_MINTED = 64;\n\n    // The bit position of `numberBurned` in packed address data.\n    uint256 private constant _BITPOS_NUMBER_BURNED = 128;\n\n    // The bit position of `aux` in packed address data.\n    uint256 private constant _BITPOS_AUX = 192;\n\n    // Mask of all 256 bits in packed address data except the 64 bits for `aux`.\n    uint256 private constant _BITMASK_AUX_COMPLEMENT = (1 << 192) - 1;\n\n    // The bit position of `startTimestamp` in packed ownership.\n    uint256 private constant _BITPOS_START_TIMESTAMP = 160;\n\n    // The bit mask of the `burned` bit in packed ownership.\n    uint256 private constant _BITMASK_BURNED = 1 << 224;\n\n    // The bit position of the `nextInitialized` bit in packed ownership.\n    uint256 private constant _BITPOS_NEXT_INITIALIZED = 225;\n\n    // The bit mask of the `nextInitialized` bit in packed ownership.\n    uint256 private constant _BITMASK_NEXT_INITIALIZED = 1 << 225;\n\n    // The bit position of `extraData` in packed ownership.\n    uint256 private constant _BITPOS_EXTRA_DATA = 232;\n\n    // Mask of all 256 bits in a packed ownership except the 24 bits for `extraData`.\n    uint256 private constant _BITMASK_EXTRA_DATA_COMPLEMENT = (1 << 232) - 1;\n\n    // The mask of the lower 160 bits for addresses.\n    uint256 private constant _BITMASK_ADDRESS = (1 << 160) - 1;\n\n    // The maximum `quantity` that can be minted with {_mintERC2309}.\n    // This limit is to prevent overflows on the address data entries.\n    // For a limit of 5000, a total of 3.689e15 calls to {_mintERC2309}\n    // is required to cause an overflow, which is unrealistic.\n    uint256 private constant _MAX_MINT_ERC2309_QUANTITY_LIMIT = 5000;\n\n    // The `Transfer` event signature is given by:\n    // `keccak256(bytes(\"Transfer(address,address,uint256)\"))`.\n    bytes32 private constant _TRANSFER_EVENT_SIGNATURE =\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\n\n    // =============================================================\n    //                            STORAGE\n    // =============================================================\n\n    // The next token ID to be minted.\n    uint256 private _currentIndex;\n\n    // The number of tokens burned.\n    uint256 private _burnCounter;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to ownership details\n    // An empty struct value does not necessarily mean the token is unowned.\n    // See {_packedOwnershipOf} implementation for details.\n    //\n    // Bits Layout:\n    // - [0..159]   `addr`\n    // - [160..223] `startTimestamp`\n    // - [224]      `burned`\n    // - [225]      `nextInitialized`\n    // - [232..255] `extraData`\n    mapping(uint256 => uint256) private _packedOwnerships;\n\n    // Mapping owner address to address data.\n    //\n    // Bits Layout:\n    // - [0..63]    `balance`\n    // - [64..127]  `numberMinted`\n    // - [128..191] `numberBurned`\n    // - [192..255] `aux`\n    mapping(address => uint256) private _packedAddressData;\n\n    // Mapping from token ID to approved address.\n    mapping(uint256 => TokenApprovalRef) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // =============================================================\n    //                          CONSTRUCTOR\n    // =============================================================\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n        _currentIndex = _startTokenId();\n    }\n\n    // =============================================================\n    //                   TOKEN COUNTING OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Returns the starting token ID.\n     * To change the starting token ID, please override this function.\n     */\n    function _startTokenId() internal view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev Returns the next token ID to be minted.\n     */\n    function _nextTokenId() internal view virtual returns (uint256) {\n        return _currentIndex;\n    }\n\n    /**\n     * @dev Returns the total number of tokens in existence.\n     * Burned tokens will reduce the count.\n     * To get the total number of tokens minted, please see {_totalMinted}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        // Counter underflow is impossible as _burnCounter cannot be incremented\n        // more than `_currentIndex - _startTokenId()` times.\n        unchecked {\n            return _currentIndex - _burnCounter - _startTokenId();\n        }\n    }\n\n    /**\n     * @dev Returns the total amount of tokens minted in the contract.\n     */\n    function _totalMinted() internal view virtual returns (uint256) {\n        // Counter underflow is impossible as `_currentIndex` does not decrement,\n        // and it is initialized to `_startTokenId()`.\n        unchecked {\n            return _currentIndex - _startTokenId();\n        }\n    }\n\n    /**\n     * @dev Returns the total number of tokens burned.\n     */\n    function _totalBurned() internal view virtual returns (uint256) {\n        return _burnCounter;\n    }\n\n    // =============================================================\n    //                    ADDRESS DATA OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Returns the number of tokens in `owner`'s account.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\n        return _packedAddressData[owner] & _BITMASK_ADDRESS_DATA_ENTRY;\n    }\n\n    /**\n     * Returns the number of tokens minted by `owner`.\n     */\n    function _numberMinted(address owner) internal view returns (uint256) {\n        return (_packedAddressData[owner] >> _BITPOS_NUMBER_MINTED) & _BITMASK_ADDRESS_DATA_ENTRY;\n    }\n\n    /**\n     * Returns the number of tokens burned by or on behalf of `owner`.\n     */\n    function _numberBurned(address owner) internal view returns (uint256) {\n        return (_packedAddressData[owner] >> _BITPOS_NUMBER_BURNED) & _BITMASK_ADDRESS_DATA_ENTRY;\n    }\n\n    /**\n     * Returns the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\n     */\n    function _getAux(address owner) internal view returns (uint64) {\n        return uint64(_packedAddressData[owner] >> _BITPOS_AUX);\n    }\n\n    /**\n     * Sets the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\n     * If there are multiple variables, please pack them into a uint64.\n     */\n    function _setAux(address owner, uint64 aux) internal virtual {\n        uint256 packed = _packedAddressData[owner];\n        uint256 auxCasted;\n        // Cast `aux` with assembly to avoid redundant masking.\n        assembly {\n            auxCasted := aux\n        }\n        packed = (packed & _BITMASK_AUX_COMPLEMENT) | (auxCasted << _BITPOS_AUX);\n        _packedAddressData[owner] = packed;\n    }\n\n    // =============================================================\n    //                            IERC165\n    // =============================================================\n\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        // The interface IDs are constants representing the first 4 bytes\n        // of the XOR of all function selectors in the interface.\n        // See: [ERC165](https://eips.ethereum.org/EIPS/eip-165)\n        // (e.g. `bytes4(i.functionA.selector ^ i.functionB.selector ^ ...)`)\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\n            interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.\n            interfaceId == 0x5b5e139f; // ERC165 interface ID for ERC721Metadata.\n    }\n\n    // =============================================================\n    //                        IERC721Metadata\n    // =============================================================\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, _toString(tokenId))) : '';\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, it can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return '';\n    }\n\n    // =============================================================\n    //                     OWNERSHIPS OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        return address(uint160(_packedOwnershipOf(tokenId)));\n    }\n\n    /**\n     * @dev Gas spent here starts off proportional to the maximum mint batch size.\n     * It gradually moves to O(1) as tokens get transferred around over time.\n     */\n    function _ownershipOf(uint256 tokenId) internal view virtual returns (TokenOwnership memory) {\n        return _unpackedOwnership(_packedOwnershipOf(tokenId));\n    }\n\n    /**\n     * @dev Returns the unpacked `TokenOwnership` struct at `index`.\n     */\n    function _ownershipAt(uint256 index) internal view virtual returns (TokenOwnership memory) {\n        return _unpackedOwnership(_packedOwnerships[index]);\n    }\n\n    /**\n     * @dev Initializes the ownership slot minted at `index` for efficiency purposes.\n     */\n    function _initializeOwnershipAt(uint256 index) internal virtual {\n        if (_packedOwnerships[index] == 0) {\n            _packedOwnerships[index] = _packedOwnershipOf(index);\n        }\n    }\n\n    /**\n     * Returns the packed ownership data of `tokenId`.\n     */\n    function _packedOwnershipOf(uint256 tokenId) private view returns (uint256 packed) {\n        if (_startTokenId() <= tokenId) {\n            packed = _packedOwnerships[tokenId];\n            // If not burned.\n            if (packed & _BITMASK_BURNED == 0) {\n                // If the data at the starting slot does not exist, start the scan.\n                if (packed == 0) {\n                    if (tokenId >= _currentIndex) revert OwnerQueryForNonexistentToken();\n                    // Invariant:\n                    // There will always be an initialized ownership slot\n                    // (i.e. `ownership.addr != address(0) && ownership.burned == false`)\n                    // before an unintialized ownership slot\n                    // (i.e. `ownership.addr == address(0) && ownership.burned == false`)\n                    // Hence, `tokenId` will not underflow.\n                    //\n                    // We can directly compare the packed value.\n                    // If the address is zero, packed will be zero.\n                    for (;;) {\n                        unchecked {\n                            packed = _packedOwnerships[--tokenId];\n                        }\n                        if (packed == 0) continue;\n                        return packed;\n                    }\n                }\n                // Otherwise, the data exists and is not burned. We can skip the scan.\n                // This is possible because we have already achieved the target condition.\n                // This saves 2143 gas on transfers of initialized tokens.\n                return packed;\n            }\n        }\n        revert OwnerQueryForNonexistentToken();\n    }\n\n    /**\n     * @dev Returns the unpacked `TokenOwnership` struct from `packed`.\n     */\n    function _unpackedOwnership(uint256 packed) private pure returns (TokenOwnership memory ownership) {\n        ownership.addr = address(uint160(packed));\n        ownership.startTimestamp = uint64(packed >> _BITPOS_START_TIMESTAMP);\n        ownership.burned = packed & _BITMASK_BURNED != 0;\n        ownership.extraData = uint24(packed >> _BITPOS_EXTRA_DATA);\n    }\n\n    /**\n     * @dev Packs ownership data into a single uint256.\n     */\n    function _packOwnershipData(address owner, uint256 flags) private view returns (uint256 result) {\n        assembly {\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\n            owner := and(owner, _BITMASK_ADDRESS)\n            // `owner | (block.timestamp << _BITPOS_START_TIMESTAMP) | flags`.\n            result := or(owner, or(shl(_BITPOS_START_TIMESTAMP, timestamp()), flags))\n        }\n    }\n\n    /**\n     * @dev Returns the `nextInitialized` flag set if `quantity` equals 1.\n     */\n    function _nextInitializedFlag(uint256 quantity) private pure returns (uint256 result) {\n        // For branchless setting of the `nextInitialized` flag.\n        assembly {\n            // `(quantity == 1) << _BITPOS_NEXT_INITIALIZED`.\n            result := shl(_BITPOS_NEXT_INITIALIZED, eq(quantity, 1))\n        }\n    }\n\n    // =============================================================\n    //                      APPROVAL OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account. See {ERC721A-_approve}.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     */\n    function approve(address to, uint256 tokenId) public payable virtual override {\n        _approve(to, tokenId, true);\n    }\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\n\n        return _tokenApprovals[tokenId].value;\n    }\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom}\n     * for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _operatorApprovals[_msgSenderERC721A()][operator] = approved;\n        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);\n    }\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted. See {_mint}.\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return\n            _startTokenId() <= tokenId &&\n            tokenId < _currentIndex && // If within bounds,\n            _packedOwnerships[tokenId] & _BITMASK_BURNED == 0; // and not burned.\n    }\n\n    /**\n     * @dev Returns whether `msgSender` is equal to `approvedAddress` or `owner`.\n     */\n    function _isSenderApprovedOrOwner(\n        address approvedAddress,\n        address owner,\n        address msgSender\n    ) private pure returns (bool result) {\n        assembly {\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\n            owner := and(owner, _BITMASK_ADDRESS)\n            // Mask `msgSender` to the lower 160 bits, in case the upper bits somehow aren't clean.\n            msgSender := and(msgSender, _BITMASK_ADDRESS)\n            // `msgSender == owner || msgSender == approvedAddress`.\n            result := or(eq(msgSender, owner), eq(msgSender, approvedAddress))\n        }\n    }\n\n    /**\n     * @dev Returns the storage slot and value for the approved address of `tokenId`.\n     */\n    function _getApprovedSlotAndAddress(uint256 tokenId)\n        private\n        view\n        returns (uint256 approvedAddressSlot, address approvedAddress)\n    {\n        TokenApprovalRef storage tokenApproval = _tokenApprovals[tokenId];\n        // The following is equivalent to `approvedAddress = _tokenApprovals[tokenId].value`.\n        assembly {\n            approvedAddressSlot := tokenApproval.slot\n            approvedAddress := sload(approvedAddressSlot)\n        }\n    }\n\n    // =============================================================\n    //                      TRANSFER OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token\n     * by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public payable virtual override {\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\n\n        if (address(uint160(prevOwnershipPacked)) != from) revert TransferFromIncorrectOwner();\n\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\n\n        // The nested ifs save around 20+ gas over a compound boolean condition.\n        if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\n            if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\n\n        if (to == address(0)) revert TransferToZeroAddress();\n\n        _beforeTokenTransfers(from, to, tokenId, 1);\n\n        // Clear approvals from the previous owner.\n        assembly {\n            if approvedAddress {\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\n                sstore(approvedAddressSlot, 0)\n            }\n        }\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\n        unchecked {\n            // We can directly increment and decrement the balances.\n            --_packedAddressData[from]; // Updates: `balance -= 1`.\n            ++_packedAddressData[to]; // Updates: `balance += 1`.\n\n            // Updates:\n            // - `address` to the next owner.\n            // - `startTimestamp` to the timestamp of transfering.\n            // - `burned` to `false`.\n            // - `nextInitialized` to `true`.\n            _packedOwnerships[tokenId] = _packOwnershipData(\n                to,\n                _BITMASK_NEXT_INITIALIZED | _nextExtraData(from, to, prevOwnershipPacked)\n            );\n\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\n                uint256 nextTokenId = tokenId + 1;\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\n                if (_packedOwnerships[nextTokenId] == 0) {\n                    // If the next slot is within bounds.\n                    if (nextTokenId != _currentIndex) {\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\n                    }\n                }\n            }\n        }\n\n        emit Transfer(from, to, tokenId);\n        _afterTokenTransfers(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public payable virtual override {\n        safeTransferFrom(from, to, tokenId, '');\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token\n     * by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public payable virtual override {\n        transferFrom(from, to, tokenId);\n        if (to.code.length != 0)\n            if (!_checkContractOnERC721Received(from, to, tokenId, _data)) {\n                revert TransferToNonERC721ReceiverImplementer();\n            }\n    }\n\n    /**\n     * @dev Hook that is called before a set of serially-ordered token IDs\n     * are about to be transferred. This includes minting.\n     * And also called before burning one token.\n     *\n     * `startTokenId` - the first token ID to be transferred.\n     * `quantity` - the amount to be transferred.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, `tokenId` will be burned by `from`.\n     * - `from` and `to` are never both zero.\n     */\n    function _beforeTokenTransfers(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after a set of serially-ordered token IDs\n     * have been transferred. This includes minting.\n     * And also called after one token has been burned.\n     *\n     * `startTokenId` - the first token ID to be transferred.\n     * `quantity` - the amount to be transferred.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` has been minted for `to`.\n     * - When `to` is zero, `tokenId` has been burned by `from`.\n     * - `from` and `to` are never both zero.\n     */\n    function _afterTokenTransfers(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal virtual {}\n\n    /**\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target contract.\n     *\n     * `from` - Previous owner of the given token ID.\n     * `to` - Target address that will receive the token.\n     * `tokenId` - Token ID to be transferred.\n     * `_data` - Optional data to send along with the call.\n     *\n     * Returns whether the call correctly returned the expected magic value.\n     */\n    function _checkContractOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        try ERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(), from, tokenId, _data) returns (\n            bytes4 retval\n        ) {\n            return retval == ERC721A__IERC721Receiver(to).onERC721Received.selector;\n        } catch (bytes memory reason) {\n            if (reason.length == 0) {\n                revert TransferToNonERC721ReceiverImplementer();\n            } else {\n                assembly {\n                    revert(add(32, reason), mload(reason))\n                }\n            }\n        }\n    }\n\n    // =============================================================\n    //                        MINT OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Mints `quantity` tokens and transfers them to `to`.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `quantity` must be greater than 0.\n     *\n     * Emits a {Transfer} event for each mint.\n     */\n    function _mint(address to, uint256 quantity) internal virtual {\n        uint256 startTokenId = _currentIndex;\n        if (quantity == 0) revert MintZeroQuantity();\n\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\n\n        // Overflows are incredibly unrealistic.\n        // `balance` and `numberMinted` have a maximum limit of 2**64.\n        // `tokenId` has a maximum limit of 2**256.\n        unchecked {\n            // Updates:\n            // - `balance += quantity`.\n            // - `numberMinted += quantity`.\n            //\n            // We can directly add to the `balance` and `numberMinted`.\n            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\n\n            // Updates:\n            // - `address` to the owner.\n            // - `startTimestamp` to the timestamp of minting.\n            // - `burned` to `false`.\n            // - `nextInitialized` to `quantity == 1`.\n            _packedOwnerships[startTokenId] = _packOwnershipData(\n                to,\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\n            );\n\n            uint256 toMasked;\n            uint256 end = startTokenId + quantity;\n\n            // Use assembly to loop and emit the `Transfer` event for gas savings.\n            // The duplicated `log4` removes an extra check and reduces stack juggling.\n            // The assembly, together with the surrounding Solidity code, have been\n            // delicately arranged to nudge the compiler into producing optimized opcodes.\n            assembly {\n                // Mask `to` to the lower 160 bits, in case the upper bits somehow aren't clean.\n                toMasked := and(to, _BITMASK_ADDRESS)\n                // Emit the `Transfer` event.\n                log4(\n                    0, // Start of data (0, since no data).\n                    0, // End of data (0, since no data).\n                    _TRANSFER_EVENT_SIGNATURE, // Signature.\n                    0, // `address(0)`.\n                    toMasked, // `to`.\n                    startTokenId // `tokenId`.\n                )\n\n                // The `iszero(eq(,))` check ensures that large values of `quantity`\n                // that overflows uint256 will make the loop run out of gas.\n                // The compiler will optimize the `iszero` away for performance.\n                for {\n                    let tokenId := add(startTokenId, 1)\n                } iszero(eq(tokenId, end)) {\n                    tokenId := add(tokenId, 1)\n                } {\n                    // Emit the `Transfer` event. Similar to above.\n                    log4(0, 0, _TRANSFER_EVENT_SIGNATURE, 0, toMasked, tokenId)\n                }\n            }\n            if (toMasked == 0) revert MintToZeroAddress();\n\n            _currentIndex = end;\n        }\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\n    }\n\n    /**\n     * @dev Mints `quantity` tokens and transfers them to `to`.\n     *\n     * This function is intended for efficient minting only during contract creation.\n     *\n     * It emits only one {ConsecutiveTransfer} as defined in\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309),\n     * instead of a sequence of {Transfer} event(s).\n     *\n     * Calling this function outside of contract creation WILL make your contract\n     * non-compliant with the ERC721 standard.\n     * For full ERC721 compliance, substituting ERC721 {Transfer} event(s) with the ERC2309\n     * {ConsecutiveTransfer} event is only permissible during contract creation.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `quantity` must be greater than 0.\n     *\n     * Emits a {ConsecutiveTransfer} event.\n     */\n    function _mintERC2309(address to, uint256 quantity) internal virtual {\n        uint256 startTokenId = _currentIndex;\n        if (to == address(0)) revert MintToZeroAddress();\n        if (quantity == 0) revert MintZeroQuantity();\n        if (quantity > _MAX_MINT_ERC2309_QUANTITY_LIMIT) revert MintERC2309QuantityExceedsLimit();\n\n        _beforeTokenTransfers(address(0), to, startTokenId, quantity);\n\n        // Overflows are unrealistic due to the above check for `quantity` to be below the limit.\n        unchecked {\n            // Updates:\n            // - `balance += quantity`.\n            // - `numberMinted += quantity`.\n            //\n            // We can directly add to the `balance` and `numberMinted`.\n            _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\n\n            // Updates:\n            // - `address` to the owner.\n            // - `startTimestamp` to the timestamp of minting.\n            // - `burned` to `false`.\n            // - `nextInitialized` to `quantity == 1`.\n            _packedOwnerships[startTokenId] = _packOwnershipData(\n                to,\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\n            );\n\n            emit ConsecutiveTransfer(startTokenId, startTokenId + quantity - 1, address(0), to);\n\n            _currentIndex = startTokenId + quantity;\n        }\n        _afterTokenTransfers(address(0), to, startTokenId, quantity);\n    }\n\n    /**\n     * @dev Safely mints `quantity` tokens and transfers them to `to`.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement\n     * {IERC721Receiver-onERC721Received}, which is called for each safe transfer.\n     * - `quantity` must be greater than 0.\n     *\n     * See {_mint}.\n     *\n     * Emits a {Transfer} event for each mint.\n     */\n    function _safeMint(\n        address to,\n        uint256 quantity,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, quantity);\n\n        unchecked {\n            if (to.code.length != 0) {\n                uint256 end = _currentIndex;\n                uint256 index = end - quantity;\n                do {\n                    if (!_checkContractOnERC721Received(address(0), to, index++, _data)) {\n                        revert TransferToNonERC721ReceiverImplementer();\n                    }\n                } while (index < end);\n                // Reentrancy protection.\n                if (_currentIndex != end) revert();\n            }\n        }\n    }\n\n    /**\n     * @dev Equivalent to `_safeMint(to, quantity, '')`.\n     */\n    function _safeMint(address to, uint256 quantity) internal virtual {\n        _safeMint(to, quantity, '');\n    }\n\n    // =============================================================\n    //                       APPROVAL OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Equivalent to `_approve(to, tokenId, false)`.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _approve(to, tokenId, false);\n    }\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the\n     * zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(\n        address to,\n        uint256 tokenId,\n        bool approvalCheck\n    ) internal virtual {\n        address owner = ownerOf(tokenId);\n\n        if (approvalCheck)\n            if (_msgSenderERC721A() != owner)\n                if (!isApprovedForAll(owner, _msgSenderERC721A())) {\n                    revert ApprovalCallerNotOwnerNorApproved();\n                }\n\n        _tokenApprovals[tokenId].value = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    // =============================================================\n    //                        BURN OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Equivalent to `_burn(tokenId, false)`.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        _burn(tokenId, false);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {\n        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);\n\n        address from = address(uint160(prevOwnershipPacked));\n\n        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);\n\n        if (approvalCheck) {\n            // The nested ifs save around 20+ gas over a compound boolean condition.\n            if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))\n                if (!isApprovedForAll(from, _msgSenderERC721A())) revert TransferCallerNotOwnerNorApproved();\n        }\n\n        _beforeTokenTransfers(from, address(0), tokenId, 1);\n\n        // Clear approvals from the previous owner.\n        assembly {\n            if approvedAddress {\n                // This is equivalent to `delete _tokenApprovals[tokenId]`.\n                sstore(approvedAddressSlot, 0)\n            }\n        }\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\n        unchecked {\n            // Updates:\n            // - `balance -= 1`.\n            // - `numberBurned += 1`.\n            //\n            // We can directly decrement the balance, and increment the number burned.\n            // This is equivalent to `packed -= 1; packed += 1 << _BITPOS_NUMBER_BURNED;`.\n            _packedAddressData[from] += (1 << _BITPOS_NUMBER_BURNED) - 1;\n\n            // Updates:\n            // - `address` to the last owner.\n            // - `startTimestamp` to the timestamp of burning.\n            // - `burned` to `true`.\n            // - `nextInitialized` to `true`.\n            _packedOwnerships[tokenId] = _packOwnershipData(\n                from,\n                (_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) | _nextExtraData(from, address(0), prevOwnershipPacked)\n            );\n\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\n                uint256 nextTokenId = tokenId + 1;\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\n                if (_packedOwnerships[nextTokenId] == 0) {\n                    // If the next slot is within bounds.\n                    if (nextTokenId != _currentIndex) {\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\n                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;\n                    }\n                }\n            }\n        }\n\n        emit Transfer(from, address(0), tokenId);\n        _afterTokenTransfers(from, address(0), tokenId, 1);\n\n        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\n        unchecked {\n            _burnCounter++;\n        }\n    }\n\n    // =============================================================\n    //                     EXTRA DATA OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Directly sets the extra data for the ownership data `index`.\n     */\n    function _setExtraDataAt(uint256 index, uint24 extraData) internal virtual {\n        uint256 packed = _packedOwnerships[index];\n        if (packed == 0) revert OwnershipNotInitializedForExtraData();\n        uint256 extraDataCasted;\n        // Cast `extraData` with assembly to avoid redundant masking.\n        assembly {\n            extraDataCasted := extraData\n        }\n        packed = (packed & _BITMASK_EXTRA_DATA_COMPLEMENT) | (extraDataCasted << _BITPOS_EXTRA_DATA);\n        _packedOwnerships[index] = packed;\n    }\n\n    /**\n     * @dev Called during each token transfer to set the 24bit `extraData` field.\n     * Intended to be overridden by the cosumer contract.\n     *\n     * `previousExtraData` - the value of `extraData` before transfer.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, `tokenId` will be burned by `from`.\n     * - `from` and `to` are never both zero.\n     */\n    function _extraData(\n        address from,\n        address to,\n        uint24 previousExtraData\n    ) internal view virtual returns (uint24) {}\n\n    /**\n     * @dev Returns the next extra data for the packed ownership data.\n     * The returned result is shifted into position.\n     */\n    function _nextExtraData(\n        address from,\n        address to,\n        uint256 prevOwnershipPacked\n    ) private view returns (uint256) {\n        uint24 extraData = uint24(prevOwnershipPacked >> _BITPOS_EXTRA_DATA);\n        return uint256(_extraData(from, to, extraData)) << _BITPOS_EXTRA_DATA;\n    }\n\n    // =============================================================\n    //                       OTHER OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Returns the message sender (defaults to `msg.sender`).\n     *\n     * If you are writing GSN compatible contracts, you need to override this function.\n     */\n    function _msgSenderERC721A() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    /**\n     * @dev Converts a uint256 to its ASCII string decimal representation.\n     */\n    function _toString(uint256 value) internal pure virtual returns (string memory str) {\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\n            // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.\n            let m := add(mload(0x40), 0xa0)\n            // Update the free memory pointer to allocate.\n            mstore(0x40, m)\n            // Assign the `str` to the end.\n            str := sub(m, 0x20)\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end of the memory to calculate the length later.\n            let end := str\n\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            // prettier-ignore\n            for { let temp := value } 1 {} {\n                str := sub(str, 1)\n                // Write the character to the pointer.\n                // The ASCII index of the '0' character is 48.\n                mstore8(str, add(48, mod(temp, 10)))\n                // Keep dividing `temp` until zero.\n                temp := div(temp, 10)\n                // prettier-ignore\n                if iszero(temp) { break }\n            }\n\n            let length := sub(end, str)\n            // Move the pointer 32 bytes leftwards to make room for the length.\n            str := sub(str, 0x20)\n            // Store the length.\n            mstore(str, length)\n        }\n    }\n}\n"

    },

    "lib/ERC721A/contracts/IERC721A.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// ERC721A Contracts v4.2.3\n// Creator: Chiru Labs\n\npragma solidity ^0.8.4;\n\n/**\n * @dev Interface of ERC721A.\n */\ninterface IERC721A {\n    /**\n     * The caller must own the token or be an approved operator.\n     */\n    error ApprovalCallerNotOwnerNorApproved();\n\n    /**\n     * The token does not exist.\n     */\n    error ApprovalQueryForNonexistentToken();\n\n    /**\n     * Cannot query the balance for the zero address.\n     */\n    error BalanceQueryForZeroAddress();\n\n    /**\n     * Cannot mint to the zero address.\n     */\n    error MintToZeroAddress();\n\n    /**\n     * The quantity of tokens minted must be more than zero.\n     */\n    error MintZeroQuantity();\n\n    /**\n     * The token does not exist.\n     */\n    error OwnerQueryForNonexistentToken();\n\n    /**\n     * The caller must own the token or be an approved operator.\n     */\n    error TransferCallerNotOwnerNorApproved();\n\n    /**\n     * The token must be owned by `from`.\n     */\n    error TransferFromIncorrectOwner();\n\n    /**\n     * Cannot safely transfer to a contract that does not implement the\n     * ERC721Receiver interface.\n     */\n    error TransferToNonERC721ReceiverImplementer();\n\n    /**\n     * Cannot transfer to the zero address.\n     */\n    error TransferToZeroAddress();\n\n    /**\n     * The token does not exist.\n     */\n    error URIQueryForNonexistentToken();\n\n    /**\n     * The `quantity` minted with ERC2309 exceeds the safety limit.\n     */\n    error MintERC2309QuantityExceedsLimit();\n\n    /**\n     * The `extraData` cannot be set on an unintialized ownership slot.\n     */\n    error OwnershipNotInitializedForExtraData();\n\n    // =============================================================\n    //                            STRUCTS\n    // =============================================================\n\n    struct TokenOwnership {\n        // The address of the owner.\n        address addr;\n        // Stores the start time of ownership with minimal overhead for tokenomics.\n        uint64 startTimestamp;\n        // Whether the token has been burned.\n        bool burned;\n        // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\n        uint24 extraData;\n    }\n\n    // =============================================================\n    //                         TOKEN COUNTERS\n    // =============================================================\n\n    /**\n     * @dev Returns the total number of tokens in existence.\n     * Burned tokens will reduce the count.\n     * To get the total number of tokens minted, please see {_totalMinted}.\n     */\n    function totalSupply() external view returns (uint256);\n\n    // =============================================================\n    //                            IERC165\n    // =============================================================\n\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n    // =============================================================\n    //                            IERC721\n    // =============================================================\n\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables\n     * (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in `owner`'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`,\n     * checking first that contract recipients are aware of the ERC721 protocol\n     * to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move\n     * this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external payable;\n\n    /**\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\n     * whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token\n     * by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the\n     * zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external payable;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom}\n     * for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    // =============================================================\n    //                        IERC721Metadata\n    // =============================================================\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n\n    // =============================================================\n    //                           IERC2309\n    // =============================================================\n\n    /**\n     * @dev Emitted when tokens in `fromTokenId` to `toTokenId`\n     * (inclusive) is transferred from `from` to `to`, as defined in the\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.\n     *\n     * See {_mintERC2309} for more details.\n     */\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\n}\n"

    },

    "lib/ERC721H/src/ERC721ACH.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {IERC721ACH} from \"./interfaces/IERC721ACH.sol\";\nimport {ERC721AC} from \"ERC721C/erc721c/ERC721AC.sol\";\nimport {IERC721A} from \"erc721a/contracts/IERC721A.sol\";\nimport {IBeforeTokenTransfersHook} from \"./interfaces/IBeforeTokenTransfersHook.sol\";\nimport {IAfterTokenTransfersHook} from \"./interfaces/IAfterTokenTransfersHook.sol\";\nimport {IOwnerOfHook} from \"./interfaces/IOwnerOfHook.sol\";\n\n/**\n * @title ERC721ACH\n * @author Cre8ors Inc.\n * @notice This contract extends Limit Break's ERC721-AC implementation with hook functionality.\n *  It allows the contract owner to set hooks that modify the behavior of core ERC721\n *  functions. Each hook type can be associated with a contract that implements the\n *  corresponding hook's logic. Only the contract owner can set or change these hooks.\n */\ncontract ERC721ACH is IERC721ACH, ERC721AC {\n    /**\n     * @dev This mapping associates hook types with their corresponding contract addresses.\n     * Each hook type can be associated with a contract that implements the hook's logic.\n     * Only the contract owner can set or change these hooks.\n     */\n    mapping(HookType => address) public hooks;\n\n    /**\n     * @dev Contract constructor.\n     * @param _contractName The name of the token contract.\n     * @param _contractSymbol The symbol of the token contract.\n     */\n    constructor(\n        string memory _contractName,\n        string memory _contractSymbol\n    ) ERC721AC(_contractName, _contractSymbol) {}\n\n    /// @inheritdoc IERC721A\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override returns (bool) {\n        return super.supportsInterface(interfaceId);\n    }\n\n    /////////////////////////////////////////////////\n    /// ERC721 overrides\n    /////////////////////////////////////////////////\n\n    /**\n     * @notice Before token transfer hook. This function is called before any token transfer.\n     * This includes minting and burning.\n     * @param from The source address.\n     * @param to The destination address.\n     * @param startTokenId The ID of the first token to be transferred.\n     * @param quantity The number of tokens to be transferred.\n     */\n    function _beforeTokenTransfers(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal virtual override {\n        super._beforeTokenTransfers(from, to, startTokenId, quantity);\n        IBeforeTokenTransfersHook hook = IBeforeTokenTransfersHook(\n            hooks[HookType.BeforeTokenTransfers]\n        );\n        if (address(hook) != address(0)) {\n            hook.beforeTokenTransfersHook(from, to, startTokenId, quantity);\n        }\n    }\n\n    /**\n     * @notice After token transfer hook. This function is called after any token transfer.\n     * This includes minting and burning.\n     * @param from The source address.\n     * @param to The destination address.\n     * @param startTokenId The ID of the first token to be transferred.\n     * @param quantity The number of tokens to be transferred.\n     */\n    function _afterTokenTransfers(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal virtual override {\n        super._afterTokenTransfers(from, to, startTokenId, quantity);\n        IAfterTokenTransfersHook hook = IAfterTokenTransfersHook(\n            hooks[HookType.AfterTokenTransfers]\n        );\n        if (address(hook) != address(0)) {\n            hook.afterTokenTransfersHook(from, to, startTokenId, quantity);\n        }\n    }\n\n    /**\n     * @notice Returns the owner of the `tokenId` token.\n     * @dev The owner of a token is also its approver by default.\n     * @param tokenId The ID of the token to query.\n     * @return owner of the `tokenId` token.\n     */\n    function ownerOf(\n        uint256 tokenId\n    ) public view virtual override returns (address owner) {\n        bool runSuper;\n        IOwnerOfHook hook = IOwnerOfHook(hooks[HookType.OwnerOf]);\n\n        if (address(hook) != address(0)) {\n            (owner, runSuper) = hook.ownerOfHook(tokenId);\n        } else {\n            runSuper = true;\n        }\n\n        if (runSuper) {\n            owner = super.ownerOf(tokenId);\n        }\n    }\n\n    /**\n     * @notice Returns the address of the contract that implements the logic for the given hook type.\n     * @param hookType The type of the hook to query.\n     * @return address of the contract that implements the hook's logic.\n     */\n    function getHook(HookType hookType) external view returns (address) {\n        return hooks[hookType];\n    }\n\n    /////////////////////////////////////////////////\n    /// ERC721C Override\n    /////////////////////////////////////////////////\n\n    /**\n     * @notice This internal function is used to ensure that the caller is the contract owner.\n     * @dev Throws if called by any account other than the owner.\n     */\n    function _requireCallerIsContractOwner() internal view virtual override {}\n\n    /////////////////////////////////////////////////\n    /// ERC721H Admin Controls\n    /////////////////////////////////////////////////\n\n    /**\n     * @notice Updates the contract address for a specific hook type.\n     * @dev Throws if called by any account other than the owner.\n     * Emits a {UpdatedHook} event.\n     * @param hookType The type of the hook to set.\n     * @param hookAddress The address of the contract that implements the hook's logic.\n     */\n    function setHook(\n        HookType hookType,\n        address hookAddress\n    ) external virtual onlyOwner {\n        hooks[hookType] = hookAddress;\n        emit UpdatedHook(msg.sender, hookType, hookAddress);\n    }\n\n    /**\n     * @notice This modifier checks if the caller is the contract owner.\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _requireCallerIsContractOwner();\n\n        _;\n    }\n}\n"

    },

    "lib/ERC721H/src/interfaces/IAfterTokenTransfersHook.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\n/// @title IAfterTokenTransfersHook\n/// @dev Interface that defines hooks to be executed After token transfers.\ninterface IAfterTokenTransfersHook {\n    /**\n     * @notice Emitted when the after token transfers hook is used.\n     * @param from Address from which the tokens are being transferred.\n     * @param to Address to which the tokens are being transferred.\n     * @param startTokenId The starting ID of the tokens being transferred.\n     * @param quantity The number of tokens being transferred.\n     */\n    event AfterTokenTransfersHookUsed(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    );\n\n    /**\n     * @notice Provides a custom implementation for the token transfers process.\n     * @param from Address from which the tokens are being transferred.\n     * @param to Address to which the tokens are being transferred.\n     * @param startTokenId The starting ID of the tokens being transferred.\n     * @param quantity The number of tokens being transferred.\n     */\n    function afterTokenTransfersHook(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) external;\n}\n"

    },

    "lib/ERC721H/src/interfaces/IBeforeTokenTransfersHook.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\n/// @title IBeforeTokenTransfersHook\n/// @dev Interface that defines hooks to be executed before token transfers.\ninterface IBeforeTokenTransfersHook {\n    /**\n     * @notice Emitted when the before token transfers hook is used.\n     * @param from Address from which the tokens are being transferred.\n     * @param to Address to which the tokens are being transferred.\n     * @param startTokenId The starting ID of the tokens being transferred.\n     * @param quantity The number of tokens being transferred.\n     */\n    event BeforeTokenTransfersHookUsed(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    );\n\n    /**\n     * @notice Provides a custom implementation for the token transfers process.\n     * @param from Address from which the tokens are being transferred.\n     * @param to Address to which the tokens are being transferred.\n     * @param startTokenId The starting ID of the tokens being transferred.\n     * @param quantity The number of tokens being transferred.\n     */\n    function beforeTokenTransfersHook(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) external;\n}\n"

    },

    "lib/ERC721H/src/interfaces/IERC721ACH.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\ninterface IERC721ACH {\n    /**\n     * @dev Enumerated list of all available hook types for the ERC721ACH contract.\n     */\n    enum HookType {\n        /// @notice Hook for custom logic before a token transfer occurs.\n        BeforeTokenTransfers,\n        /// @notice Hook for custom logic after a token transfer occurs.\n        AfterTokenTransfers,\n        /// @notice Hook for custom logic for ownerOf() function.\n        OwnerOf\n    }\n\n    /**\n     * @notice An event that gets emitted when a hook is updated.\n     * @param setter The address that set the hook.\n     * @param hookType The type of the hook that was set.\n     * @param hookAddress The address of the contract that implements the hook.\n     */\n    event UpdatedHook(\n        address indexed setter,\n        HookType hookType,\n        address indexed hookAddress\n    );\n\n    /**\n     * @notice Sets the contract address for a specified hook type.\n     * @param hookType The type of hook to set, as defined in the HookType enum.\n     * @param hookAddress The address of the contract implementing the hook interface.\n     */\n    function setHook(HookType hookType, address hookAddress) external;\n\n    /**\n     * @notice Returns the contract address for a specified hook type.\n     * @param hookType The type of hook to set, as defined in the HookType enum.\n     * @return The address of the contract implementing the hook interface.\n     */\n    function getHook(HookType hookType) external view returns (address);\n}\n"

    },

    "lib/ERC721H/src/interfaces/IOwnerOfHook.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\n/// @title IOwnerOfHook\n/// @dev Interface that defines hooks for retrieving the owner of a token.\ninterface IOwnerOfHook {\n    /**\n     * @notice Emitted when the owner of hook is used.\n     * @param tokenId The ID of the token whose owner is being retrieved.\n     * @param owner The address of the owner of the token.\n     */\n    event OwnerOfHookUsed(uint256 tokenId, address owner);\n\n    /**\n     * @notice Provides a custom implementation for the owner retrieval process.\n     * @param tokenId The ID of the token whose owner is being retrieved.\n     * @return A tuple with The address of the owner of the token and A bool flag whether to run `super.ownerOf` or not\n     */\n    function ownerOfHook(uint256 tokenId) external view returns (address, bool);\n}\n"

    },

    "lib/creator-token-contracts/contracts/access/OwnablePermissions.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\n\nabstract contract OwnablePermissions is Context {\n    function _requireCallerIsContractOwner() internal view virtual;\n}\n"

    },

    "lib/creator-token-contracts/contracts/erc721c/ERC721AC.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../utils/CreatorTokenBase.sol\";\nimport \"erc721a/contracts/ERC721A.sol\";\n\n/**\n * @title ERC721AC\n * @author Limit Break, Inc.\n * @notice Extends Azuki's ERC721-A implementation with Creator Token functionality, which\n *         allows the contract owner to update the transfer validation logic by managing a security policy in\n *         an external transfer validation security policy registry.  See {CreatorTokenTransferValidator}.\n */\nabstract contract ERC721AC is ERC721A, CreatorTokenBase {\n\n    constructor(string memory name_, string memory symbol_) CreatorTokenBase() ERC721A(name_, symbol_) {}\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(ICreatorToken).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /// @dev Ties the erc721a _beforeTokenTransfers hook to more granular transfer validation logic\n    function _beforeTokenTransfers(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal virtual override {\n        for (uint256 i = 0; i < quantity;) {\n            _validateBeforeTransfer(from, to, startTokenId + i);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Ties the erc721a _afterTokenTransfer hook to more granular transfer validation logic\n    function _afterTokenTransfers(\n        address from,\n        address to,\n        uint256 startTokenId,\n        uint256 quantity\n    ) internal virtual override {\n        for (uint256 i = 0; i < quantity;) {\n            _validateAfterTransfer(from, to, startTokenId + i);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _msgSenderERC721A() internal view virtual override returns (address) {\n        return _msgSender();\n    }\n}\n"

    },

    "lib/creator-token-contracts/contracts/interfaces/ICreatorToken.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ICreatorTokenTransferValidator.sol\";\n\ninterface ICreatorToken {\n    event TransferValidatorUpdated(address oldValidator, address newValidator);\n\n    function getTransferValidator() external view returns (ICreatorTokenTransferValidator);\n    function getSecurityPolicy() external view returns (CollectionSecurityPolicy memory);\n    function getWhitelistedOperators() external view returns (address[] memory);\n    function getPermittedContractReceivers() external view returns (address[] memory);\n    function isOperatorWhitelisted(address operator) external view returns (bool);\n    function isContractReceiverPermitted(address receiver) external view returns (bool);\n    function isTransferAllowed(address caller, address from, address to) external view returns (bool);\n}\n"

    },

    "lib/creator-token-contracts/contracts/interfaces/ICreatorTokenTransferValidator.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./IEOARegistry.sol\";\nimport \"./ITransferSecurityRegistry.sol\";\nimport \"./ITransferValidator.sol\";\n\ninterface ICreatorTokenTransferValidator is ITransferSecurityRegistry, ITransferValidator, IEOARegistry {}"

    },

    "lib/creator-token-contracts/contracts/interfaces/IEOARegistry.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\ninterface IEOARegistry is IERC165 {\n    function isVerifiedEOA(address account) external view returns (bool);\n}"

    },

    "lib/creator-token-contracts/contracts/interfaces/ITransferSecurityRegistry.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../utils/TransferPolicy.sol\";\n\ninterface ITransferSecurityRegistry {\n    event AddedToAllowlist(AllowlistTypes indexed kind, uint256 indexed id, address indexed account);\n    event CreatedAllowlist(AllowlistTypes indexed kind, uint256 indexed id, string indexed name);\n    event ReassignedAllowlistOwnership(AllowlistTypes indexed kind, uint256 indexed id, address indexed newOwner);\n    event RemovedFromAllowlist(AllowlistTypes indexed kind, uint256 indexed id, address indexed account);\n    event SetAllowlist(AllowlistTypes indexed kind, address indexed collection, uint120 indexed id);\n    event SetTransferSecurityLevel(address indexed collection, TransferSecurityLevels level);\n\n    function createOperatorWhitelist(string calldata name) external returns (uint120);\n    function createPermittedContractReceiverAllowlist(string calldata name) external returns (uint120);\n    function reassignOwnershipOfOperatorWhitelist(uint120 id, address newOwner) external;\n    function reassignOwnershipOfPermittedContractReceiverAllowlist(uint120 id, address newOwner) external;\n    function renounceOwnershipOfOperatorWhitelist(uint120 id) external;\n    function renounceOwnershipOfPermittedContractReceiverAllowlist(uint120 id) external;\n    function setTransferSecurityLevelOfCollection(address collection, TransferSecurityLevels level) external;\n    function setOperatorWhitelistOfCollection(address collection, uint120 id) external;\n    function setPermittedContractReceiverAllowlistOfCollection(address collection, uint120 id) external;\n    function addOperatorToWhitelist(uint120 id, address operator) external;\n    function addPermittedContractReceiverToAllowlist(uint120 id, address receiver) external;\n    function removeOperatorFromWhitelist(uint120 id, address operator) external;\n    function removePermittedContractReceiverFromAllowlist(uint120 id, address receiver) external;\n    function getCollectionSecurityPolicy(address collection) external view returns (CollectionSecurityPolicy memory);\n    function getWhitelistedOperators(uint120 id) external view returns (address[] memory);\n    function getPermittedContractReceivers(uint120 id) external view returns (address[] memory);\n    function isOperatorWhitelisted(uint120 id, address operator) external view returns (bool);\n    function isContractReceiverPermitted(uint120 id, address receiver) external view returns (bool);\n}"

    },

    "lib/creator-token-contracts/contracts/interfaces/ITransferValidator.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../utils/TransferPolicy.sol\";\n\ninterface ITransferValidator {\n    function applyCollectionTransferPolicy(address caller, address from, address to) external view;\n}"

    },

    "lib/creator-token-contracts/contracts/utils/CreatorTokenBase.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../access/OwnablePermissions.sol\";\nimport \"../interfaces/ICreatorToken.sol\";\nimport \"../interfaces/ICreatorTokenTransferValidator.sol\";\nimport \"../utils/TransferValidation.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC165.sol\";\n\n/**\n * @title CreatorTokenBase\n * @author Limit Break, Inc.\n * @notice CreatorTokenBase is an abstract contract that provides basic functionality for managing token \n * transfer policies through an implementation of ICreatorTokenTransferValidator. This contract is intended to be used\n * as a base for creator-specific token contracts, enabling customizable transfer restrictions and security policies.\n *\n * <h4>Features:</h4>\n * <ul>Ownable: This contract can have an owner who can set and update the transfer validator.</ul>\n * <ul>TransferValidation: Implements the basic token transfer validation interface.</ul>\n * <ul>ICreatorToken: Implements the interface for creator tokens, providing view functions for token security policies.</ul>\n *\n * <h4>Benefits:</h4>\n * <ul>Provides a flexible and modular way to implement custom token transfer restrictions and security policies.</ul>\n * <ul>Allows creators to enforce policies such as whitelisted operators and permitted contract receivers.</ul>\n * <ul>Can be easily integrated into other token contracts as a base contract.</ul>\n *\n * <h4>Intended Usage:</h4>\n * <ul>Use as a base contract for creator token implementations that require advanced transfer restrictions and \n *   security policies.</ul>\n * <ul>Set and update the ICreatorTokenTransferValidator implementation contract to enforce desired policies for the \n *   creator token.</ul>\n */\nabstract contract CreatorTokenBase is OwnablePermissions, TransferValidation, ICreatorToken {\n    \n    error CreatorTokenBase__InvalidTransferValidatorContract();\n    error CreatorTokenBase__SetTransferValidatorFirst();\n\n    address public constant DEFAULT_TRANSFER_VALIDATOR = address(0x0000721C310194CcfC01E523fc93C9cCcFa2A0Ac);\n    TransferSecurityLevels public constant DEFAULT_TRANSFER_SECURITY_LEVEL = TransferSecurityLevels.One;\n    uint120 public constant DEFAULT_OPERATOR_WHITELIST_ID = uint120(1);\n\n    ICreatorTokenTransferValidator private transferValidator;\n\n    /**\n     * @notice Allows the contract owner to set the transfer validator to the official validator contract\n     *         and set the security policy to the recommended default settings.\n     * @dev    May be overridden to change the default behavior of an individual collection.\n     */\n    function setToDefaultSecurityPolicy() public virtual {\n        _requireCallerIsContractOwner();\n        setTransferValidator(DEFAULT_TRANSFER_VALIDATOR);\n        ICreatorTokenTransferValidator(DEFAULT_TRANSFER_VALIDATOR).setTransferSecurityLevelOfCollection(address(this), DEFAULT_TRANSFER_SECURITY_LEVEL);\n        ICreatorTokenTransferValidator(DEFAULT_TRANSFER_VALIDATOR).setOperatorWhitelistOfCollection(address(this), DEFAULT_OPERATOR_WHITELIST_ID);\n    }\n\n    /**\n     * @notice Allows the contract owner to set the transfer validator to a custom validator contract\n     *         and set the security policy to their own custom settings.\n     */\n    function setToCustomValidatorAndSecurityPolicy(\n        address validator, \n        TransferSecurityLevels level, \n        uint120 operatorWhitelistId, \n        uint120 permittedContractReceiversAllowlistId) public {\n        _requireCallerIsContractOwner();\n\n        setTransferValidator(validator);\n\n        ICreatorTokenTransferValidator(validator).\n            setTransferSecurityLevelOfCollection(address(this), level);\n\n        ICreatorTokenTransferValidator(validator).\n            setOperatorWhitelistOfCollection(address(this), operatorWhitelistId);\n\n        ICreatorTokenTransferValidator(validator).\n            setPermittedContractReceiverAllowlistOfCollection(address(this), permittedContractReceiversAllowlistId);\n    }\n\n    /**\n     * @notice Allows the contract owner to set the security policy to their own custom settings.\n     * @dev    Reverts if the transfer validator has not been set.\n     */\n    function setToCustomSecurityPolicy(\n        TransferSecurityLevels level, \n        uint120 operatorWhitelistId, \n        uint120 permittedContractReceiversAllowlistId) public {\n        _requireCallerIsContractOwner();\n\n        ICreatorTokenTransferValidator validator = getTransferValidator();\n        if (address(validator) == address(0)) {\n            revert CreatorTokenBase__SetTransferValidatorFirst();\n        }\n\n        validator.setTransferSecurityLevelOfCollection(address(this), level);\n        validator.setOperatorWhitelistOfCollection(address(this), operatorWhitelistId);\n        validator.setPermittedContractReceiverAllowlistOfCollection(address(this), permittedContractReceiversAllowlistId);\n    }\n\n    /**\n     * @notice Sets the transfer validator for the token contract.\n     *\n     * @dev    Throws when provided validator contract is not the zero address and doesn't support \n     *         the ICreatorTokenTransferValidator interface. \n     * @dev    Throws when the caller is not the contract owner.\n     *\n     * @dev    <h4>Postconditions:</h4>\n     *         1. The transferValidator address is updated.\n     *         2. The `TransferValidatorUpdated` event is emitted.\n     *\n     * @param transferValidator_ The address of the transfer validator contract.\n     */\n    function setTransferValidator(address transferValidator_) public {\n        _requireCallerIsContractOwner();\n\n        bool isValidTransferValidator = false;\n\n        if(transferValidator_.code.length > 0) {\n            try IERC165(transferValidator_).supportsInterface(type(ICreatorTokenTransferValidator).interfaceId) \n                returns (bool supportsInterface) {\n                isValidTransferValidator = supportsInterface;\n            } catch {}\n        }\n\n        if(transferValidator_ != address(0) && !isValidTransferValidator) {\n            revert CreatorTokenBase__InvalidTransferValidatorContract();\n        }\n\n        emit TransferValidatorUpdated(address(transferValidator), transferValidator_);\n\n        transferValidator = ICreatorTokenTransferValidator(transferValidator_);\n    }\n\n    /**\n     * @notice Returns the transfer validator contract address for this token contract.\n     */\n    function getTransferValidator() public view override returns (ICreatorTokenTransferValidator) {\n        return transferValidator;\n    }\n\n    /**\n     * @notice Returns the security policy for this token contract, which includes:\n     *         Transfer security level, operator whitelist id, permitted contract receiver allowlist id.\n     */\n    function getSecurityPolicy() public view override returns (CollectionSecurityPolicy memory) {\n        if (address(transferValidator) != address(0)) {\n            return transferValidator.getCollectionSecurityPolicy(address(this));\n        }\n\n        return CollectionSecurityPolicy({\n            transferSecurityLevel: TransferSecurityLevels.Zero,\n            operatorWhitelistId: 0,\n            permittedContractReceiversId: 0\n        });\n    }\n\n    /**\n     * @notice Returns the list of all whitelisted operators for this token contract.\n     * @dev    This can be an expensive call and should only be used in view-only functions.\n     */\n    function getWhitelistedOperators() public view override returns (address[] memory) {\n        if (address(transferValidator) != address(0)) {\n            return transferValidator.getWhitelistedOperators(\n                transferValidator.getCollectionSecurityPolicy(address(this)).operatorWhitelistId);\n        }\n\n        return new address[](0);\n    }\n\n    /**\n     * @notice Returns the list of permitted contract receivers for this token contract.\n     * @dev    This can be an expensive call and should only be used in view-only functions.\n     */\n    function getPermittedContractReceivers() public view override returns (address[] memory) {\n        if (address(transferValidator) != address(0)) {\n            return transferValidator.getPermittedContractReceivers(\n                transferValidator.getCollectionSecurityPolicy(address(this)).permittedContractReceiversId);\n        }\n\n        return new address[](0);\n    }\n\n    /**\n     * @notice Checks if an operator is whitelisted for this token contract.\n     * @param operator The address of the operator to check.\n     */\n    function isOperatorWhitelisted(address operator) public view override returns (bool) {\n        if (address(transferValidator) != address(0)) {\n            return transferValidator.isOperatorWhitelisted(\n                transferValidator.getCollectionSecurityPolicy(address(this)).operatorWhitelistId, operator);\n        }\n\n        return false;\n    }\n\n    /**\n     * @notice Checks if a contract receiver is permitted for this token contract.\n     * @param receiver The address of the receiver to check.\n     */\n    function isContractReceiverPermitted(address receiver) public view override returns (bool) {\n        if (address(transferValidator) != address(0)) {\n            return transferValidator.isContractReceiverPermitted(\n                transferValidator.getCollectionSecurityPolicy(address(this)).permittedContractReceiversId, receiver);\n        }\n\n        return false;\n    }\n\n    /**\n     * @notice Determines if a transfer is allowed based on the token contract's security policy.  Use this function\n     *         to simulate whether or not a transfer made by the specified `caller` from the `from` address to the `to`\n     *         address would be allowed by this token's security policy.\n     *\n     * @notice This function only checks the security policy restrictions and does not check whether token ownership\n     *         or approvals are in place. \n     *\n     * @param caller The address of the simulated caller.\n     * @param from   The address of the sender.\n     * @param to     The address of the receiver.\n     * @return       True if the transfer is allowed, false otherwise.\n     */\n    function isTransferAllowed(address caller, address from, address to) public view override returns (bool) {\n        if (address(transferValidator) != address(0)) {\n            try transferValidator.applyCollectionTransferPolicy(caller, from, to) {\n                return true;\n            } catch {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Pre-validates a token transfer, reverting if the transfer is not allowed by this token's security policy.\n     *      Inheriting contracts are responsible for overriding the _beforeTokenTransfer function, or its equivalent\n     *      and calling _validateBeforeTransfer so that checks can be properly applied during token transfers.\n     *\n     * @dev Throws when the transfer doesn't comply with the collection's transfer policy, if the transferValidator is\n     *      set to a non-zero address.\n     *\n     * @param caller  The address of the caller.\n     * @param from    The address of the sender.\n     * @param to      The address of the receiver.\n     */\n    function _preValidateTransfer(\n        address caller, \n        address from, \n        address to, \n        uint256 /*tokenId*/, \n        uint256 /*value*/) internal virtual override {\n        if (address(transferValidator) != address(0)) {\n            transferValidator.applyCollectionTransferPolicy(caller, from, to);\n        }\n    }\n}\n"

    },

    "lib/creator-token-contracts/contracts/utils/TransferPolicy.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nenum AllowlistTypes {\n    Operators,\n    PermittedContractReceivers\n}\n\nenum ReceiverConstraints {\n    None,\n    NoCode,\n    EOA\n}\n\nenum CallerConstraints {\n    None,\n    OperatorWhitelistEnableOTC,\n    OperatorWhitelistDisableOTC\n}\n\nenum StakerConstraints {\n    None,\n    CallerIsTxOrigin,\n    EOA\n}\n\nenum TransferSecurityLevels {\n    Zero,\n    One,\n    Two,\n    Three,\n    Four,\n    Five,\n    Six\n}\n\nstruct TransferSecurityPolicy {\n    CallerConstraints callerConstraints;\n    ReceiverConstraints receiverConstraints;\n}\n\nstruct CollectionSecurityPolicy {\n    TransferSecurityLevels transferSecurityLevel;\n    uint120 operatorWhitelistId;\n    uint120 permittedContractReceiversId;\n}\n"

    },

    "lib/creator-token-contracts/contracts/utils/TransferValidation.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\n\n/**\n * @title TransferValidation\n * @author Limit Break, Inc.\n * @notice A mix-in that can be combined with ERC-721 contracts to provide more granular hooks.\n * Openzeppelin's ERC721 contract only provides hooks for before and after transfer.  This allows\n * developers to validate or customize transfers within the context of a mint, a burn, or a transfer.\n */\nabstract contract TransferValidation is Context {\n    \n    error ShouldNotMintToBurnAddress();\n\n    /// @dev Inheriting contracts should call this function in the _beforeTokenTransfer function to get more granular hooks.\n    function _validateBeforeTransfer(address from, address to, uint256 tokenId) internal virtual {\n        bool fromZeroAddress = from == address(0);\n        bool toZeroAddress = to == address(0);\n\n        if(fromZeroAddress && toZeroAddress) {\n            revert ShouldNotMintToBurnAddress();\n        } else if(fromZeroAddress) {\n            _preValidateMint(_msgSender(), to, tokenId, msg.value);\n        } else if(toZeroAddress) {\n            _preValidateBurn(_msgSender(), from, tokenId, msg.value);\n        } else {\n            _preValidateTransfer(_msgSender(), from, to, tokenId, msg.value);\n        }\n    }\n\n    /// @dev Inheriting contracts should call this function in the _afterTokenTransfer function to get more granular hooks.\n    function _validateAfterTransfer(address from, address to, uint256 tokenId) internal virtual {\n        bool fromZeroAddress = from == address(0);\n        bool toZeroAddress = to == address(0);\n\n        if(fromZeroAddress && toZeroAddress) {\n            revert ShouldNotMintToBurnAddress();\n        } else if(fromZeroAddress) {\n            _postValidateMint(_msgSender(), to, tokenId, msg.value);\n        } else if(toZeroAddress) {\n            _postValidateBurn(_msgSender(), from, tokenId, msg.value);\n        } else {\n            _postValidateTransfer(_msgSender(), from, to, tokenId, msg.value);\n        }\n    }\n\n    /// @dev Optional validation hook that fires before a mint\n    function _preValidateMint(address caller, address to, uint256 tokenId, uint256 value) internal virtual {}\n\n    /// @dev Optional validation hook that fires after a mint\n    function _postValidateMint(address caller, address to, uint256 tokenId, uint256 value) internal virtual {}\n\n    /// @dev Optional validation hook that fires before a burn\n    function _preValidateBurn(address caller, address from, uint256 tokenId, uint256 value) internal virtual {}\n\n    /// @dev Optional validation hook that fires after a burn\n    function _postValidateBurn(address caller, address from, uint256 tokenId, uint256 value) internal virtual {}\n\n    /// @dev Optional validation hook that fires before a transfer\n    function _preValidateTransfer(address caller, address from, address to, uint256 tokenId, uint256 value) internal virtual {}\n\n    /// @dev Optional validation hook that fires after a transfer\n    function _postValidateTransfer(address caller, address from, address to, uint256 tokenId, uint256 value) internal virtual {}\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/access/AccessControl.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(account),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/access/IAccessControl.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/interfaces/IERC165.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165.sol\";\n"

    },

    "lib/openzeppelin-contracts/contracts/interfaces/IERC2981.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (interfaces/IERC2981.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface for the NFT Royalty Standard.\n *\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\n *\n * _Available since v4.5._\n */\ninterface IERC2981 is IERC165 {\n    /**\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\n     */\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount);\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/utils/Context.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/utils/Strings.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     *\n     * _Available since v4.7._\n     */\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     *\n     * _Available since v4.7._\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/utils/math/Math.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"

    },

    "src/Cre8iveAdmin.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {AccessControl} from \"lib/openzeppelin-contracts/contracts/access/AccessControl.sol\";\n\n/**\n ██████╗██████╗ ███████╗ █████╗  ██████╗ ██████╗ ███████╗\n██╔════╝██╔══██╗██╔════╝██╔══██╗██╔═══██╗██╔══██╗██╔════╝\n██║     ██████╔╝█████╗  ╚█████╔╝██║   ██║██████╔╝███████╗\n██║     ██╔══██╗██╔══╝  ██╔══██╗██║   ██║██╔══██╗╚════██║\n╚██████╗██║  ██║███████╗╚█████╔╝╚██████╔╝██║  ██║███████║\n ╚═════╝╚═╝  ╚═╝╚══════╝ ╚════╝  ╚═════╝ ╚═╝  ╚═╝╚══════╝                                                       \n */\n/// @dev inspiration: https://etherscan.io/address/0x23581767a106ae21c074b2276d25e5c3e136a68b#code\ncontract Cre8iveAdmin is AccessControl {\n    /// @notice Access control roles\n    bytes32 public immutable MINTER_ROLE = keccak256(\"MINTER\");\n    bytes32 public immutable SALES_MANAGER_ROLE = keccak256(\"SALES_MANAGER\");\n    /// @notice Role of administrative users allowed to expel a CRE8OR from the Warehouse.\n    /// @dev See expelFromWarehouse().\n    bytes32 public constant EXPULSION_ROLE = keccak256(\"EXPULSION_ROLE\");\n\n    /// @notice Missing the given role or admin access\n    error AdminAccess_MissingRoleOrAdmin(bytes32 role);\n\n    constructor(address _initialOwner) {\n        // Setup the owner role\n        _setupRole(DEFAULT_ADMIN_ROLE, _initialOwner);\n    }\n\n    /////////////////////////////////////////////////\n    /// MODIFIERS\n    /////////////////////////////////////////////////\n\n    /// @notice Only a given role has access or admin\n    /// @param role role to check for alongside the admin role\n    modifier onlyRoleOrAdmin(bytes32 role) {\n        if (\n            !hasRole(DEFAULT_ADMIN_ROLE, msg.sender) &&\n            !hasRole(role, msg.sender)\n        ) {\n            revert AdminAccess_MissingRoleOrAdmin(role);\n        }\n\n        _;\n    }\n}\n"

    },

    "src/Cre8ors.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {ERC721ACH} from \"ERC721H/ERC721ACH.sol\";\nimport {IERC721ACH} from \"ERC721H/interfaces/IERC721ACH.sol\";\nimport {IERC721A} from \"erc721a/contracts/IERC721A.sol\";\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {IERC2981, IERC165} from \"@openzeppelin/contracts/interfaces/IERC2981.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {MerkleProof} from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport {IERC721Drop} from \"./interfaces/IERC721Drop.sol\";\nimport {IMetadataRenderer} from \"./interfaces/IMetadataRenderer.sol\";\nimport {ERC721DropStorageV1} from \"./storage/ERC721DropStorageV1.sol\";\nimport {OwnableSkeleton} from \"./utils/OwnableSkeleton.sol\";\nimport {IOwnable} from \"./interfaces/IOwnable.sol\";\nimport {Cre8iveAdmin} from \"./Cre8iveAdmin.sol\";\n\n/**\n ██████╗██████╗ ███████╗ █████╗  ██████╗ ██████╗ ███████╗\n██╔════╝██╔══██╗██╔════╝██╔══██╗██╔═══██╗██╔══██╗██╔════╝\n██║     ██████╔╝█████╗  ╚█████╔╝██║   ██║██████╔╝███████╗\n██║     ██╔══██╗██╔══╝  ██╔══██╗██║   ██║██╔══██╗╚════██║\n╚██████╗██║  ██║███████╗╚█████╔╝╚██████╔╝██║  ██║███████║\n ╚═════╝╚═╝  ╚═╝╚══════╝ ╚════╝  ╚═════╝ ╚═╝  ╚═╝╚══════╝                                                       \n */\n/// @dev inspiration: https://github.com/ourzora/zora-drops-contracts\ncontract Cre8ors is\n    Cre8iveAdmin,\n    ERC721ACH,\n    IERC2981,\n    ReentrancyGuard,\n    IERC721Drop,\n    OwnableSkeleton,\n    ERC721DropStorageV1\n{\n    /// @dev This is the max mint batch size for the optimized ERC721ACH mint contract\n    uint256 internal constant MAX_MINT_BATCH_SIZE = 8;\n\n    /// @dev Gas limit to send funds\n    uint256 internal constant FUNDS_SEND_GAS_LIMIT = 210_000;\n\n    constructor(\n        string memory _contractName,\n        string memory _contractSymbol,\n        address _initialOwner,\n        address payable _fundsRecipient,\n        uint64 _editionSize,\n        uint16 _royaltyBPS,\n        SalesConfiguration memory _salesConfig,\n        IMetadataRenderer _metadataRenderer\n    )\n        ERC721ACH(_contractName, _contractSymbol)\n        ReentrancyGuard()\n        Cre8iveAdmin(_initialOwner)\n    {\n        // Set ownership to original sender of contract call\n        _setOwner(_initialOwner);\n        // Update salesConfig\n        salesConfig = _salesConfig;\n        // Setup config variables\n        config.editionSize = _editionSize;\n        config.metadataRenderer = _metadataRenderer;\n        config.royaltyBPS = _royaltyBPS;\n        config.fundsRecipient = _fundsRecipient;\n    }\n\n    /// @dev Getter for admin role associated with the contract to handle metadata\n    /// @return boolean if address is admin\n    function isAdmin(address user) external view returns (bool) {\n        return hasRole(DEFAULT_ADMIN_ROLE, user);\n    }\n\n    /// @notice mint function\n    /// @dev This allows the user to purchase an edition\n    /// @dev at the given price in the contract.\n    function purchase(\n        uint256 quantity\n    )\n        external\n        payable\n        nonReentrant\n        canMintTokens(quantity)\n        onlyPublicSaleActive\n        returns (uint256)\n    {\n        uint256 salePrice = salesConfig.publicSalePrice;\n\n        if (msg.value != salePrice * quantity) {\n            revert Purchase_WrongPrice(salePrice * quantity);\n        }\n\n        // If max purchase per address == 0 there is no limit.\n        // Any other number, the per address mint limit is that.\n        if (\n            salesConfig.maxSalePurchasePerAddress != 0 &&\n            _numberMinted(_msgSender()) +\n                quantity -\n                presaleMintsByAddress[_msgSender()] >\n            salesConfig.maxSalePurchasePerAddress\n        ) {\n            revert Purchase_TooManyForAddress();\n        }\n\n        _mintNFTs(_msgSender(), quantity);\n        uint256 firstMintedTokenId = _lastMintedTokenId() - quantity;\n\n        emit IERC721Drop.Sale({\n            to: _msgSender(),\n            quantity: quantity,\n            pricePerToken: salePrice,\n            firstPurchasedTokenId: firstMintedTokenId\n        });\n        return firstMintedTokenId;\n    }\n\n    /// @notice Merkle-tree based presale purchase function\n    /// @param quantity quantity to purchase\n    /// @param maxQuantity max quantity that can be purchased via merkle proof #\n    /// @param pricePerToken price that each token is purchased at\n    /// @param merkleProof proof for presale mint\n    function purchasePresale(\n        uint256 quantity,\n        uint256 maxQuantity,\n        uint256 pricePerToken,\n        bytes32[] calldata merkleProof\n    )\n        external\n        payable\n        nonReentrant\n        canMintTokens(quantity)\n        onlyPresaleActive\n        returns (uint256)\n    {\n        if (\n            !MerkleProof.verify(\n                merkleProof,\n                salesConfig.presaleMerkleRoot,\n                keccak256(\n                    // address, uint256, uint256\n                    abi.encode(msg.sender, maxQuantity, pricePerToken)\n                )\n            )\n        ) {\n            revert Presale_MerkleNotApproved();\n        }\n\n        if (msg.value != pricePerToken * quantity) {\n            revert Purchase_WrongPrice(pricePerToken * quantity);\n        }\n\n        presaleMintsByAddress[_msgSender()] += quantity;\n        if (presaleMintsByAddress[_msgSender()] > maxQuantity) {\n            revert Presale_TooManyForAddress();\n        }\n\n        _mintNFTs(_msgSender(), quantity);\n        uint256 firstMintedTokenId = _lastMintedTokenId() - quantity;\n\n        emit IERC721Drop.Sale({\n            to: _msgSender(),\n            quantity: quantity,\n            pricePerToken: pricePerToken,\n            firstPurchasedTokenId: firstMintedTokenId\n        });\n\n        return firstMintedTokenId;\n    }\n\n    /// @notice Mint admin\n    /// @param recipient recipient to mint to\n    /// @param quantity quantity to mint\n    function adminMint(\n        address recipient,\n        uint256 quantity\n    )\n        external\n        onlyRoleOrAdmin(MINTER_ROLE)\n        canMintTokens(quantity)\n        returns (uint256)\n    {\n        _mintNFTs(recipient, quantity);\n\n        return _lastMintedTokenId();\n    }\n\n    /// @dev This mints multiple editions to the given list of addresses.\n    /// @param recipients list of addresses to send the newly minted editions to\n    function adminMintAirdrop(\n        address[] calldata recipients\n    )\n        external\n        override\n        onlyRoleOrAdmin(MINTER_ROLE)\n        canMintTokens(recipients.length)\n        returns (uint256)\n    {\n        uint256 atId = _nextTokenId();\n        uint256 startAt = atId;\n\n        unchecked {\n            for (\n                uint256 endAt = atId + recipients.length;\n                atId < endAt;\n                atId++\n            ) {\n                _mintNFTs(recipients[atId - startAt], 1);\n            }\n        }\n        return _lastMintedTokenId();\n    }\n\n    /// @dev ERC2981 - Get royalty information for token\n    /// @param _salePrice Sale price for the token\n    function royaltyInfo(\n        uint256,\n        uint256 _salePrice\n    ) external view override returns (address receiver, uint256 royaltyAmount) {\n        if (config.fundsRecipient == address(0)) {\n            return (config.fundsRecipient, 0);\n        }\n        return (\n            config.fundsRecipient,\n            (_salePrice * config.royaltyBPS) / 10_000\n        );\n    }\n\n    /// @notice Function to mint NFTs\n    /// @dev (important: Does not enforce max supply limit, enforce that limit earlier)\n    /// @dev This batches in size of 8 as per recommended by ERC721ACH creators\n    /// @param to address to mint NFTs to\n    /// @param quantity number of NFTs to mint\n    function _mintNFTs(address to, uint256 quantity) internal {\n        do {\n            uint256 toMint = quantity > MAX_MINT_BATCH_SIZE\n                ? MAX_MINT_BATCH_SIZE\n                : quantity;\n            _mint({to: to, quantity: toMint});\n            quantity -= toMint;\n        } while (quantity > 0);\n    }\n\n    /// @param tokenId Token ID to burn\n    /// @notice User burn function for token id\n    function burn(uint256 tokenId) public {\n        _burn(tokenId, true);\n    }\n\n    /// @notice Sale details\n    /// @return IERC721Drop.SaleDetails sale information details\n    function saleDetails()\n        external\n        view\n        returns (IERC721Drop.ERC20SaleDetails memory)\n    {\n        return\n            IERC721Drop.ERC20SaleDetails({\n                erc20PaymentToken: salesConfig.erc20PaymentToken,\n                publicSaleActive: _publicSaleActive(),\n                presaleActive: _presaleActive(),\n                publicSalePrice: salesConfig.publicSalePrice,\n                publicSaleStart: salesConfig.publicSaleStart,\n                publicSaleEnd: salesConfig.publicSaleEnd,\n                presaleStart: salesConfig.presaleStart,\n                presaleEnd: salesConfig.presaleEnd,\n                presaleMerkleRoot: salesConfig.presaleMerkleRoot,\n                totalMinted: _totalMinted(),\n                maxSupply: config.editionSize,\n                maxSalePurchasePerAddress: salesConfig.maxSalePurchasePerAddress\n            });\n    }\n\n    /// @dev Number of NFTs the user has minted per address\n    /// @param minter to get counts for\n    function mintedPerAddress(\n        address minter\n    ) external view override returns (IERC721Drop.AddressMintDetails memory) {\n        return\n            IERC721Drop.AddressMintDetails({\n                presaleMints: presaleMintsByAddress[minter],\n                publicMints: _numberMinted(minter) -\n                    presaleMintsByAddress[minter],\n                totalMints: _numberMinted(minter)\n            });\n    }\n\n    /////////////////////////////////////////////////\n    /// ADMIN\n    /////////////////////////////////////////////////\n\n    /// @dev Set new owner for royalties / opensea\n    /// @param newOwner new owner to set\n    function setOwner(address newOwner) public onlyAdmin {\n        _setOwner(newOwner);\n    }\n\n    /// @notice Set a different funds recipient\n    /// @param newRecipientAddress new funds recipient address\n    function setFundsRecipient(\n        address payable newRecipientAddress\n    ) external onlyRoleOrAdmin(SALES_MANAGER_ROLE) {\n        // TODO(iain): funds recipient cannot be 0?\n        config.fundsRecipient = newRecipientAddress;\n        emit FundsRecipientChanged(newRecipientAddress, _msgSender());\n    }\n\n    /// @dev This sets the sales configuration\n    // / @param publicSalePrice New public sale price\n    function setSaleConfiguration(\n        address erc20PaymentToken,\n        uint104 publicSalePrice,\n        uint32 maxSalePurchasePerAddress,\n        uint64 publicSaleStart,\n        uint64 publicSaleEnd,\n        uint64 presaleStart,\n        uint64 presaleEnd,\n        bytes32 presaleMerkleRoot\n    ) external onlyAdmin onlyRoleOrAdmin(SALES_MANAGER_ROLE) {\n        salesConfig.erc20PaymentToken = erc20PaymentToken;\n        salesConfig.publicSalePrice = publicSalePrice;\n        salesConfig.maxSalePurchasePerAddress = maxSalePurchasePerAddress;\n        salesConfig.publicSaleStart = publicSaleStart;\n        salesConfig.publicSaleEnd = publicSaleEnd;\n        salesConfig.presaleStart = presaleStart;\n        salesConfig.presaleEnd = presaleEnd;\n        salesConfig.presaleMerkleRoot = presaleMerkleRoot;\n\n        emit SalesConfigChanged(_msgSender());\n    }\n\n    /// @notice Set a new metadata renderer\n    /// @param newRenderer new renderer address to use\n    /// @param setupRenderer data to setup new renderer with\n    function setMetadataRenderer(\n        IMetadataRenderer newRenderer,\n        bytes memory setupRenderer\n    ) external onlyAdmin {\n        config.metadataRenderer = newRenderer;\n\n        if (setupRenderer.length > 0) {\n            newRenderer.initializeWithData(setupRenderer);\n        }\n\n        emit UpdatedMetadataRenderer({\n            sender: msg.sender,\n            renderer: newRenderer\n        });\n    }\n\n    /// @notice Receive Ether function\n    receive() external payable {}\n\n    /// @notice This withdraws ETH from the contract to the contract owner.\n    function withdraw() external nonReentrant {\n        address sender = _msgSender();\n\n        // Get fee amount\n        uint256 funds = address(this).balance;\n\n        if (\n            !hasRole(DEFAULT_ADMIN_ROLE, sender) &&\n            !hasRole(SALES_MANAGER_ROLE, sender) &&\n            sender != config.fundsRecipient\n        ) {\n            revert Access_WithdrawNotAllowed();\n        }\n\n        // Payout recipient\n        (bool successFunds, ) = config.fundsRecipient.call{\n            value: funds,\n            gas: FUNDS_SEND_GAS_LIMIT\n        }(\"\");\n        if (!successFunds) {\n            revert Withdraw_FundsSendFailure();\n        }\n    }\n\n    /////////////////////////////////////////////////\n    /// ERC721C - cre8or royalties\n    /////////////////////////////////////////////////\n\n    /// @notice ERC721C required override\n    function _requireCallerIsContractOwner() internal view override onlyAdmin {}\n\n    /////////////////////////////////////////////////\n    /// UTILITY FUNCTIONS\n    /////////////////////////////////////////////////\n\n    /// @notice Getter for last minted token ID (gets next token id and subtracts 1)\n    function _lastMintedTokenId() public view returns (uint256) {\n        return _nextTokenId() - 1;\n    }\n\n    /// @notice time between start - end\n    function _publicSaleActive() internal view returns (bool) {\n        return\n            salesConfig.publicSaleStart <= block.timestamp &&\n            salesConfig.publicSaleEnd > block.timestamp;\n    }\n\n    /// @notice time between presaleStart - presaleEnd\n    function _presaleActive() internal view returns (bool) {\n        return\n            salesConfig.presaleStart <= block.timestamp &&\n            salesConfig.presaleEnd > block.timestamp;\n    }\n\n    /////////////////////////////////////////////////\n    /// MODIFIERS\n    /////////////////////////////////////////////////\n\n    /// @notice Only allow for users with admin access\n    modifier onlyAdmin() {\n        if (!hasRole(DEFAULT_ADMIN_ROLE, msg.sender)) {\n            revert Access_OnlyAdmin();\n        }\n\n        _;\n    }\n\n    /// @notice Allows user to mint tokens at a quantity\n    modifier canMintTokens(uint256 quantity) {\n        if (quantity + _totalMinted() > config.editionSize) {\n            revert Mint_SoldOut();\n        }\n\n        _;\n    }\n\n    /// @notice Public sale active\n    modifier onlyPublicSaleActive() {\n        if (!_publicSaleActive()) {\n            revert Sale_Inactive();\n        }\n\n        _;\n    }\n\n    /// @notice Presale active\n    modifier onlyPresaleActive() {\n        if (!_presaleActive()) {\n            revert Presale_Inactive();\n        }\n\n        _;\n    }\n\n    /////////////////////////////////////////////////\n    /// OVERRIDES\n    /////////////////////////////////////////////////\n\n    /// @notice ERC165 supports interface\n    /// @param interfaceId interface id to check if supported\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view override(IERC165, ERC721ACH, AccessControl) returns (bool) {\n        return\n            super.supportsInterface(interfaceId) ||\n            type(IOwnable).interfaceId == interfaceId ||\n            type(IERC2981).interfaceId == interfaceId ||\n            type(IERC721Drop).interfaceId == interfaceId ||\n            type(IERC721A).interfaceId == interfaceId;\n    }\n\n    /// @notice Simple override for owner interface.\n    /// @return user owner address\n    function owner()\n        public\n        view\n        override(OwnableSkeleton, IERC721Drop)\n        returns (address)\n    {\n        return super.owner();\n    }\n\n    /// @notice Start token ID for minting (1-100 vs 0-99)\n    function _startTokenId() internal pure override returns (uint256) {\n        return 1;\n    }\n\n    /// @notice Token URI Getter, proxies to metadataRenderer\n    /// @param tokenId id of token to get URI for\n    /// @return Token URI\n    function tokenURI(\n        uint256 tokenId\n    ) public view override returns (string memory) {\n        if (!_exists(tokenId)) {\n            revert IERC721A.URIQueryForNonexistentToken();\n        }\n\n        return config.metadataRenderer.tokenURI(tokenId);\n    }\n\n    /// @dev Setup auto-approval for Zora v3 access to sell NFT\n    ///      Still requires approval for module\n    /// @param nftOwner owner of the nft\n    /// @param operator operator wishing to transfer/burn/etc the NFTs\n    function isApprovedForAll(\n        address nftOwner,\n        address operator\n    ) public view override returns (bool) {\n        if (operator == hooks[IERC721ACH.HookType.BeforeTokenTransfers]) {\n            return true;\n        }\n        return super.isApprovedForAll(nftOwner, operator);\n    }\n}\n"

    },

    "src/interfaces/IERC721Drop.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {IMetadataRenderer} from \"../interfaces/IMetadataRenderer.sol\";\n\n/**\n ██████╗██████╗ ███████╗ █████╗  ██████╗ ██████╗ ███████╗\n██╔════╝██╔══██╗██╔════╝██╔══██╗██╔═══██╗██╔══██╗██╔════╝\n██║     ██████╔╝█████╗  ╚█████╔╝██║   ██║██████╔╝███████╗\n██║     ██╔══██╗██╔══╝  ██╔══██╗██║   ██║██╔══██╗╚════██║\n╚██████╗██║  ██║███████╗╚█████╔╝╚██████╔╝██║  ██║███████║\n ╚═════╝╚═╝  ╚═╝╚══════╝ ╚════╝  ╚═════╝ ╚═╝  ╚═╝╚══════╝                                                       \n*/\n/// @notice Interface for Cre8ors Drop contract\ninterface IERC721Drop {\n    // Access errors\n\n    /// @notice Only admin can access this function\n    error Access_OnlyAdmin();\n    /// @notice Missing the given role or admin access\n    error Access_MissingRoleOrAdmin(bytes32 role);\n    /// @notice Withdraw is not allowed by this user\n    error Access_WithdrawNotAllowed();\n    /// @notice Cannot withdraw funds due to ETH send failure.\n    error Withdraw_FundsSendFailure();\n    /// @notice Missing the owner role.\n    error Access_OnlyOwner();\n    /// @notice Missing the owner role or approved nft access.\n    error Access_MissingOwnerOrApproved();\n\n    // Sale/Purchase errors\n    /// @notice Sale is inactive\n    error Sale_Inactive();\n    /// @notice Presale is inactive\n    error Presale_Inactive();\n    /// @notice Presale merkle root is invalid\n    error Presale_MerkleNotApproved();\n    /// @notice Wrong price for purchase\n    error Purchase_WrongPrice(uint256 correctPrice);\n    /// @notice NFT sold out\n    error Mint_SoldOut();\n    /// @notice Too many purchase for address\n    error Purchase_TooManyForAddress();\n    /// @notice Too many presale for address\n    error Presale_TooManyForAddress();\n\n    // Admin errors\n    /// @notice Royalty percentage too high\n    error Setup_RoyaltyPercentageTooHigh(uint16 maxRoyaltyBPS);\n    /// @notice Invalid admin upgrade address\n    error Admin_InvalidUpgradeAddress(address proposedAddress);\n    /// @notice Unable to finalize an edition not marked as open (size set to uint64_max_value)\n    error Admin_UnableToFinalizeNotOpenEdition();\n\n    /// @notice Event emitted for each sale\n    /// @param to address sale was made to\n    /// @param quantity quantity of the minted nfts\n    /// @param pricePerToken price for each token\n    /// @param firstPurchasedTokenId first purchased token ID (to get range add to quantity for max)\n    event Sale(\n        address indexed to,\n        uint256 indexed quantity,\n        uint256 indexed pricePerToken,\n        uint256 firstPurchasedTokenId\n    );\n\n    /// @notice Sales configuration has been changed\n    /// @dev To access new sales configuration, use getter function.\n    /// @param changedBy Changed by user\n    event SalesConfigChanged(address indexed changedBy);\n\n    /// @notice Event emitted when the funds recipient is changed\n    /// @param newAddress new address for the funds recipient\n    /// @param changedBy address that the recipient is changed by\n    event FundsRecipientChanged(\n        address indexed newAddress,\n        address indexed changedBy\n    );\n\n    /// @notice Event emitted when the funds are withdrawn from the minting contract\n    /// @param withdrawnBy address that issued the withdraw\n    /// @param withdrawnTo address that the funds were withdrawn to\n    /// @param amount amount that was withdrawn\n    event FundsWithdrawn(\n        address indexed withdrawnBy,\n        address indexed withdrawnTo,\n        uint256 amount\n    );\n\n    /// @notice Event emitted when an open mint is finalized and further minting is closed forever on the contract.\n    /// @param sender address sending close mint\n    /// @param numberOfMints number of mints the contract is finalized at\n    event OpenMintFinalized(address indexed sender, uint256 numberOfMints);\n\n    /// @notice Event emitted when metadata renderer is updated.\n    /// @param sender address of the updater\n    /// @param renderer new metadata renderer address\n    event UpdatedMetadataRenderer(address sender, IMetadataRenderer renderer);\n\n    /// @notice General configuration for NFT Minting and bookkeeping\n    struct Configuration {\n        /// @dev Metadata renderer (uint160)\n        IMetadataRenderer metadataRenderer;\n        /// @dev Total size of edition that can be minted (uint160+64 = 224)\n        uint64 editionSize;\n        /// @dev Royalty amount in bps (uint224+16 = 240)\n        uint16 royaltyBPS;\n        /// @dev Funds recipient for sale (new slot, uint160)\n        address payable fundsRecipient;\n    }\n\n    /// @notice Sales states and configuration\n    /// @dev Uses 3 storage slots\n    struct SalesConfiguration {\n        /// @dev Public sale price (max ether value > 1000 ether with this value)\n        uint104 publicSalePrice;\n        /// @dev ERC20 Token\n        address erc20PaymentToken;\n        /// @notice Purchase mint limit per address (if set to 0 === unlimited mints)\n        /// @dev Max purchase number per txn (90+32 = 122)\n        uint32 maxSalePurchasePerAddress;\n        /// @dev uint64 type allows for dates into 292 billion years\n        /// @notice Public sale start timestamp (136+64 = 186)\n        uint64 publicSaleStart;\n        /// @notice Public sale end timestamp (186+64 = 250)\n        uint64 publicSaleEnd;\n        /// @notice Presale start timestamp\n        /// @dev new storage slot\n        uint64 presaleStart;\n        /// @notice Presale end timestamp\n        uint64 presaleEnd;\n        /// @notice Presale merkle root\n        bytes32 presaleMerkleRoot;\n    }\n\n    /// @notice CRE8ORS - General configuration for Builder Rewards burn requirements\n    struct BurnConfiguration {\n        /// @dev Token to burn\n        address burnToken;\n        /// @dev Required number of tokens to burn\n        uint256 burnQuantity;\n    }\n\n    /// @notice Sales states and configuration\n    /// @dev Uses 3 storage slots\n    struct ERC20SalesConfiguration {\n        /// @notice Public sale price\n        /// @dev max ether value > 1000 ether with this value\n        uint104 publicSalePrice;\n        /// @dev ERC20 Token\n        address erc20PaymentToken;\n        /// @notice Purchase mint limit per address (if set to 0 === unlimited mints)\n        /// @dev Max purchase number per txn (90+32 = 122)\n        uint32 maxSalePurchasePerAddress;\n        /// @dev uint64 type allows for dates into 292 billion years\n        /// @notice Public sale start timestamp (136+64 = 186)\n        uint64 publicSaleStart;\n        /// @notice Public sale end timestamp (186+64 = 250)\n        uint64 publicSaleEnd;\n        /// @notice Presale start timestamp\n        /// @dev new storage slot\n        uint64 presaleStart;\n        /// @notice Presale end timestamp\n        uint64 presaleEnd;\n        /// @notice Presale merkle root\n        bytes32 presaleMerkleRoot;\n    }\n\n    /// @notice Return value for sales details to use with front-ends\n    struct SaleDetails {\n        // Synthesized status variables for sale and presale\n        bool publicSaleActive;\n        bool presaleActive;\n        // Price for public sale\n        uint256 publicSalePrice;\n        // Timed sale actions for public sale\n        uint64 publicSaleStart;\n        uint64 publicSaleEnd;\n        // Timed sale actions for presale\n        uint64 presaleStart;\n        uint64 presaleEnd;\n        // Merkle root (includes address, quantity, and price data for each entry)\n        bytes32 presaleMerkleRoot;\n        // Limit public sale to a specific number of mints per wallet\n        uint256 maxSalePurchasePerAddress;\n        // Information about the rest of the supply\n        // Total that have been minted\n        uint256 totalMinted;\n        // The total supply available\n        uint256 maxSupply;\n    }\n\n    /// @notice Return value for sales details to use with front-ends\n    struct ERC20SaleDetails {\n        /// @notice Synthesized status variables for sale\n        bool publicSaleActive;\n        /// @notice Synthesized status variables for presale\n        bool presaleActive;\n        /// @notice Price for public sale\n        uint256 publicSalePrice;\n        /// @notice ERC20 contract address for payment. address(0) for ETH.\n        address erc20PaymentToken;\n        /// @notice public sale start\n        uint64 publicSaleStart;\n        /// @notice public sale end\n        uint64 publicSaleEnd;\n        /// @notice Timed sale actions for presale start\n        uint64 presaleStart;\n        /// @notice Timed sale actions for presale end\n        uint64 presaleEnd;\n        /// @notice Merkle root (includes address, quantity, and price data for each entry)\n        bytes32 presaleMerkleRoot;\n        /// @notice Limit public sale to a specific number of mints per wallet\n        uint256 maxSalePurchasePerAddress;\n        /// @notice Total that have been minted\n        uint256 totalMinted;\n        /// @notice The total supply available\n        uint256 maxSupply;\n    }\n\n    /// @notice Return type of specific mint counts and details per address\n    struct AddressMintDetails {\n        /// Number of total mints from the given address\n        uint256 totalMints;\n        /// Number of presale mints from the given address\n        uint256 presaleMints;\n        /// Number of public mints from the given address\n        uint256 publicMints;\n    }\n\n    /// @notice External purchase function (payable in eth)\n    /// @param quantity to purchase\n    /// @return first minted token ID\n    function purchase(uint256 quantity) external payable returns (uint256);\n\n    /// @notice External purchase presale function (takes a merkle proof and matches to root) (payable in eth)\n    /// @param quantity to purchase\n    /// @param maxQuantity can purchase (verified by merkle root)\n    /// @param pricePerToken price per token allowed (verified by merkle root)\n    /// @param merkleProof input for merkle proof leaf verified by merkle root\n    /// @return first minted token ID\n    function purchasePresale(\n        uint256 quantity,\n        uint256 maxQuantity,\n        uint256 pricePerToken,\n        bytes32[] memory merkleProof\n    ) external payable returns (uint256);\n\n    /// @notice Function to return the global sales details for the given drop\n    function saleDetails() external view returns (ERC20SaleDetails memory);\n\n    /// @notice Function to return the specific sales details for a given address\n    /// @param minter address for minter to return mint information for\n    function mintedPerAddress(\n        address minter\n    ) external view returns (AddressMintDetails memory);\n\n    /// @notice This is the opensea/public owner setting that can be set by the contract admin\n    function owner() external view returns (address);\n\n    /// @notice Update the metadata renderer\n    /// @param newRenderer new address for renderer\n    /// @param setupRenderer data to call to bootstrap data for the new renderer (optional)\n    function setMetadataRenderer(\n        IMetadataRenderer newRenderer,\n        bytes memory setupRenderer\n    ) external;\n\n    /// @notice This is an admin mint function to mint a quantity to a specific address\n    /// @param to address to mint to\n    /// @param quantity quantity to mint\n    /// @return the id of the first minted NFT\n    function adminMint(address to, uint256 quantity) external returns (uint256);\n\n    /// @notice This is an admin mint function to mint a single nft each to a list of addresses\n    /// @param to list of addresses to mint an NFT each to\n    /// @return the id of the first minted NFT\n    function adminMintAirdrop(address[] memory to) external returns (uint256);\n\n    /// @dev Getter for admin role associated with the contract to handle metadata\n    /// @return boolean if address is admin\n    function isAdmin(address user) external view returns (bool);\n}\n"

    },

    "src/interfaces/IMetadataRenderer.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\n/**\n ██████╗██████╗ ███████╗ █████╗  ██████╗ ██████╗ ███████╗\n██╔════╝██╔══██╗██╔════╝██╔══██╗██╔═══██╗██╔══██╗██╔════╝\n██║     ██████╔╝█████╗  ╚█████╔╝██║   ██║██████╔╝███████╗\n██║     ██╔══██╗██╔══╝  ██╔══██╗██║   ██║██╔══██╗╚════██║\n╚██████╗██║  ██║███████╗╚█████╔╝╚██████╔╝██║  ██║███████║\n ╚═════╝╚═╝  ╚═╝╚══════╝ ╚════╝  ╚═════╝ ╚═╝  ╚═╝╚══════╝                                                     \n */\n\n/// @dev credit: https://github.com/ourzora/zora-drops-contracts\ninterface IMetadataRenderer {\n    function tokenURI(uint256) external view returns (string memory);\n\n    function contractURI() external view returns (string memory);\n\n    function initializeWithData(bytes memory initData) external;\n}\n"

    },

    "src/interfaces/IOwnable.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\n/**\n ██████╗██████╗ ███████╗ █████╗  ██████╗ ██████╗ ███████╗\n██╔════╝██╔══██╗██╔════╝██╔══██╗██╔═══██╗██╔══██╗██╔════╝\n██║     ██████╔╝█████╗  ╚█████╔╝██║   ██║██████╔╝███████╗\n██║     ██╔══██╗██╔══╝  ██╔══██╗██║   ██║██╔══██╗╚════██║\n╚██████╗██║  ██║███████╗╚█████╔╝╚██████╔╝██║  ██║███████║\n ╚═════╝╚═╝  ╚═╝╚══════╝ ╚════╝  ╚═════╝ ╚═╝  ╚═╝╚══════╝                                                     \n */\n\n/// @dev Contract module which provides a basic access control mechanism, where\n/// @dev there is an account (an owner) that can be granted exclusive access to\n/// @dev specific functions.\n/// @dev This ownership interface matches OZ's ownable interface.\n/// @dev credit: https://github.com/ourzora/zora-drops-contracts\ninterface IOwnable {\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() external view returns (address);\n}\n"

    },

    "src/storage/ERC721DropStorageV1.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {IERC721Drop} from \"../interfaces/IERC721Drop.sol\";\n\n/**\n ██████╗██████╗ ███████╗ █████╗  ██████╗ ██████╗ ███████╗\n██╔════╝██╔══██╗██╔════╝██╔══██╗██╔═══██╗██╔══██╗██╔════╝\n██║     ██████╔╝█████╗  ╚█████╔╝██║   ██║██████╔╝███████╗\n██║     ██╔══██╗██╔══╝  ██╔══██╗██║   ██║██╔══██╗╚════██║\n╚██████╗██║  ██║███████╗╚█████╔╝╚██████╔╝██║  ██║███████║\n ╚═════╝╚═╝  ╚═╝╚══════╝ ╚════╝  ╚═════╝ ╚═╝  ╚═╝╚══════╝                                                     \n */\n\n/// @dev origin: https://github.com/ourzora/zora-drops-contracts\ncontract ERC721DropStorageV1 {\n    /// @notice Configuration for NFT minting contract storage\n    IERC721Drop.Configuration public config;\n\n    /// @notice Sales configuration\n    IERC721Drop.SalesConfiguration public salesConfig;\n\n    /// @notice Burn configuration\n    IERC721Drop.BurnConfiguration public burnConfig;\n\n    /// @dev Mapping for presale mint counts by address to allow public mint limit\n    mapping(address => uint256) public presaleMintsByAddress;\n}\n"

    },

    "src/utils/OwnableSkeleton.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport {IOwnable} from \"../interfaces/IOwnable.sol\";\n\n/**\n ██████╗██████╗ ███████╗ █████╗  ██████╗ ██████╗ ███████╗\n██╔════╝██╔══██╗██╔════╝██╔══██╗██╔═══██╗██╔══██╗██╔════╝\n██║     ██████╔╝█████╗  ╚█████╔╝██║   ██║██████╔╝███████╗\n██║     ██╔══██╗██╔══╝  ██╔══██╗██║   ██║██╔══██╗╚════██║\n╚██████╗██║  ██║███████╗╚█████╔╝╚██████╔╝██║  ██║███████║\n ╚═════╝╚═╝  ╚═╝╚══════╝ ╚════╝  ╚═════╝ ╚═╝  ╚═╝╚══════╝                                                     \n */\n\n/// @dev Contract module which provides a basic access control mechanism, where\n/// @dev there is an account (an owner) that can be granted exclusive access to\n/// @dev specific functions.\n/// @dev This ownership interface matches OZ's ownable interface.\n/// @dev credit: https://github.com/ourzora/zora-drops-contracts\ncontract OwnableSkeleton is IOwnable {\n    address private _owner;\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    function _setOwner(address newAddress) internal {\n        emit OwnershipTransferred(_owner, newAddress);\n        _owner = newAddress;\n    }\n}\n"

    }

  },

  "settings": {

    "remappings": [

      "@openzeppelin/=lib/openzeppelin-contracts/",

      "@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/",

      "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",

      "ERC6551/=lib/ERC6551/src/",

      "ERC721A-Upgradeable/=lib/ERC721A-Upgradeable/contracts/",

      "ERC721A/=lib/ERC721A/contracts/",

      "ERC721C/=lib/creator-token-contracts/contracts/",

      "ERC721H/=lib/ERC721H/src/",

      "account-abstraction/=lib/account-abstraction/contracts/",

      "creator-token-contracts/=lib/creator-token-contracts/contracts/",

      "ds-test/=lib/forge-std/lib/ds-test/src/",

      "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",

      "erc6551/=lib/tokenbound/lib/reference/src/",

      "erc721a/=lib/ERC721A/",

      "forge-std/=lib/forge-std/src/",

      "hardhat/=lib/creator-token-contracts/node_modules/hardhat/",

      "murky/=lib/creator-token-contracts/lib/murky/src/",

      "openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/",

      "openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/",

      "reference/=lib/tokenbound/lib/reference/src/",

      "sstore2/=lib/ERC6551/lib/sstore2/contracts/",

      "tokenbound/=lib/tokenbound/src/"

    ],

    "optimizer": {

      "enabled": true,

      "runs": 200

    },

    "metadata": {

      "bytecodeHash": "ipfs"

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "evmVersion": "london",

    "libraries": {}

  }

}}