{{

  "language": "Solidity",

  "sources": {

    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"

    },

    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"

    },

    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"

    },

    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"

    },

    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"

    },

    "@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../ERC1967/ERC1967Upgrade.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is IERC1822Proxiable, ERC1967Upgrade {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");\n        _;\n    }\n\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate that the this implementation remains valid after an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n}\n"

    },

    "@openzeppelin/contracts/security/Pausable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"

    },

    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"

    },

    "@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20Permit.sol\";\nimport \"../ERC20.sol\";\nimport \"../../../utils/cryptography/draft-EIP712.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private constant _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    /**\n     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\n     * to reserve a slot.\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"

    },

    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"

    },

    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"

    },

    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"

    },

    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/Address.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/Context.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/Counters.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    address private immutable _CACHED_THIS;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _CACHED_THIS = address(this);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.3) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/StorageSlot.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/Strings.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"

    },

    "contracts/pendle/contracts/core/erc20/PendleERC20.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\n\n/**\n * @dev Pendle's ERC20 implementation, modified from @openzeppelin implementation\n * Changes are:\n * - comes with built-in reentrancy protection, storage-packed with totalSupply variable\n * - delete increaseAllowance / decreaseAllowance\n * - add nonReentrancy protection to transfer / transferFrom functions\n * - allow decimals to be passed in\n * - block self-transfer by default\n */\n// solhint-disable\ncontract PendleERC20 is Context, IERC20, IERC20Metadata {\n    uint8 private constant _NOT_ENTERED = 1;\n    uint8 private constant _ENTERED = 2;\n\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint248 private _totalSupply;\n    uint8 private _status;\n\n    string private _name;\n    string private _symbol;\n    uint8 public immutable decimals;\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Sets the values for {name}, {symbol} and {decimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_, uint8 decimals_) {\n        _name = name_;\n        _symbol = symbol_;\n        decimals = decimals_;\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(\n        address to,\n        uint256 amount\n    ) external virtual override nonReentrant returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(\n        address owner,\n        address spender\n    ) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) external virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external virtual override nonReentrant returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        require(from != to, \"ERC20: transfer to self\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += toUint248(amount);\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= toUint248(amount);\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    function toUint248(uint256 x) internal virtual returns (uint248) {\n        require(x <= type(uint248).max); // signed, lim = bit-1\n        return uint248(x);\n    }\n}\n"

    },

    "contracts/pendle/contracts/core/erc20/PendleERC20Permit.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./PendleERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\n/// @dev forked from OZ's ERC20Permit\ncontract PendleERC20Permit is PendleERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private constant _PERMIT_TYPEHASH =\n        keccak256(\n            \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n        );\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) PendleERC20(name_, symbol_, decimals_) EIP712(name_, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(\n            abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline)\n        );\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"

    },

    "contracts/pendle/contracts/core/libraries/ArrayLib.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.8.0;\n\nlibrary ArrayLib {\n    function sum(uint256[] memory input) internal pure returns (uint256) {\n        uint256 value = 0;\n        for (uint256 i = 0; i < input.length; ) {\n            value += input[i];\n            unchecked {\n                i++;\n            }\n        }\n        return value;\n    }\n\n    /// @notice return index of the element if found, else return uint256.max\n    function find(address[] memory array, address element) internal pure returns (uint256 index) {\n        uint256 length = array.length;\n        for (uint256 i = 0; i < length; ) {\n            if (array[i] == element) return i;\n            unchecked {\n                i++;\n            }\n        }\n        return type(uint256).max;\n    }\n\n    function append(\n        address[] memory inp,\n        address element\n    ) internal pure returns (address[] memory out) {\n        uint256 length = inp.length;\n        out = new address[](length + 1);\n        for (uint256 i = 0; i < length; ) {\n            out[i] = inp[i];\n            unchecked {\n                i++;\n            }\n        }\n        out[length] = element;\n    }\n\n    // various version of contains\n    function contains(address[] memory array, address element) internal pure returns (bool) {\n        uint256 length = array.length;\n        for (uint256 i = 0; i < length; ) {\n            if (array[i] == element) return true;\n            unchecked {\n                i++;\n            }\n        }\n        return false;\n    }\n\n    function contains(bytes4[] memory array, bytes4 element) internal pure returns (bool) {\n        uint256 length = array.length;\n        for (uint256 i = 0; i < length; ) {\n            if (array[i] == element) return true;\n            unchecked {\n                i++;\n            }\n        }\n        return false;\n    }\n}\n"

    },

    "contracts/pendle/contracts/core/libraries/BoringOwnableUpgradeable.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\ncontract BoringOwnableUpgradeableData {\n    address public owner;\n    address public pendingOwner;\n}\n\nabstract contract BoringOwnableUpgradeable is BoringOwnableUpgradeableData, Initializable {\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function __BoringOwnable_init() internal onlyInitializing {\n        owner = msg.sender;\n    }\n\n    /// @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.\n    /// Can only be invoked by the current `owner`.\n    /// @param newOwner Address of the new owner.\n    /// @param direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`.\n    /// @param renounce Allows the `newOwner` to be `address(0)` if `direct` and `renounce` is True. Has no effect otherwise.\n    function transferOwnership(address newOwner, bool direct, bool renounce) public onlyOwner {\n        if (direct) {\n            // Checks\n            require(newOwner != address(0) || renounce, \"Ownable: zero address\");\n\n            // Effects\n            emit OwnershipTransferred(owner, newOwner);\n            owner = newOwner;\n            pendingOwner = address(0);\n        } else {\n            // Effects\n            pendingOwner = newOwner;\n        }\n    }\n\n    /// @notice Needs to be called by `pendingOwner` to claim ownership.\n    function claimOwnership() public {\n        address _pendingOwner = pendingOwner;\n\n        // Checks\n        require(msg.sender == _pendingOwner, \"Ownable: caller != pending owner\");\n\n        // Effects\n        emit OwnershipTransferred(owner, _pendingOwner);\n        owner = _pendingOwner;\n        pendingOwner = address(0);\n    }\n\n    /// @notice Only allows the `owner` to execute the function.\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    uint256[48] private __gap;\n}\n"

    },

    "contracts/pendle/contracts/core/libraries/Errors.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nlibrary Errors {\n    // BulkSeller\n    error BulkInsufficientSyForTrade(uint256 currentAmount, uint256 requiredAmount);\n    error BulkInsufficientTokenForTrade(uint256 currentAmount, uint256 requiredAmount);\n    error BulkInSufficientSyOut(uint256 actualSyOut, uint256 requiredSyOut);\n    error BulkInSufficientTokenOut(uint256 actualTokenOut, uint256 requiredTokenOut);\n    error BulkInsufficientSyReceived(uint256 actualBalance, uint256 requiredBalance);\n    error BulkNotMaintainer();\n    error BulkNotAdmin();\n    error BulkSellerAlreadyExisted(address token, address SY, address bulk);\n    error BulkSellerInvalidToken(address token, address SY);\n    error BulkBadRateTokenToSy(uint256 actualRate, uint256 currentRate, uint256 eps);\n    error BulkBadRateSyToToken(uint256 actualRate, uint256 currentRate, uint256 eps);\n\n    // APPROX\n    error ApproxFail();\n    error ApproxParamsInvalid(uint256 guessMin, uint256 guessMax, uint256 eps);\n    error ApproxBinarySearchInputInvalid(\n        uint256 approxGuessMin,\n        uint256 approxGuessMax,\n        uint256 minGuessMin,\n        uint256 maxGuessMax\n    );\n\n    // MARKET + MARKET MATH CORE\n    error MarketExpired();\n    error MarketZeroAmountsInput();\n    error MarketZeroAmountsOutput();\n    error MarketZeroLnImpliedRate();\n    error MarketInsufficientPtForTrade(int256 currentAmount, int256 requiredAmount);\n    error MarketInsufficientPtReceived(uint256 actualBalance, uint256 requiredBalance);\n    error MarketInsufficientSyReceived(uint256 actualBalance, uint256 requiredBalance);\n    error MarketZeroTotalPtOrTotalAsset(int256 totalPt, int256 totalAsset);\n    error MarketExchangeRateBelowOne(int256 exchangeRate);\n    error MarketProportionMustNotEqualOne();\n    error MarketRateScalarBelowZero(int256 rateScalar);\n    error MarketScalarRootBelowZero(int256 scalarRoot);\n    error MarketProportionTooHigh(int256 proportion, int256 maxProportion);\n\n    error OracleUninitialized();\n    error OracleTargetTooOld(uint32 target, uint32 oldest);\n    error OracleZeroCardinality();\n\n    error MarketFactoryExpiredPt();\n    error MarketFactoryInvalidPt();\n    error MarketFactoryMarketExists();\n\n    error MarketFactoryLnFeeRateRootTooHigh(uint80 lnFeeRateRoot, uint256 maxLnFeeRateRoot);\n    error MarketFactoryReserveFeePercentTooHigh(\n        uint8 reserveFeePercent,\n        uint8 maxReserveFeePercent\n    );\n    error MarketFactoryZeroTreasury();\n    error MarketFactoryInitialAnchorTooLow(int256 initialAnchor, int256 minInitialAnchor);\n\n    // ROUTER\n    error RouterInsufficientLpOut(uint256 actualLpOut, uint256 requiredLpOut);\n    error RouterInsufficientSyOut(uint256 actualSyOut, uint256 requiredSyOut);\n    error RouterInsufficientPtOut(uint256 actualPtOut, uint256 requiredPtOut);\n    error RouterInsufficientYtOut(uint256 actualYtOut, uint256 requiredYtOut);\n    error RouterInsufficientPYOut(uint256 actualPYOut, uint256 requiredPYOut);\n    error RouterInsufficientTokenOut(uint256 actualTokenOut, uint256 requiredTokenOut);\n    error RouterExceededLimitSyIn(uint256 actualSyIn, uint256 limitSyIn);\n    error RouterExceededLimitPtIn(uint256 actualPtIn, uint256 limitPtIn);\n    error RouterExceededLimitYtIn(uint256 actualYtIn, uint256 limitYtIn);\n    error RouterInsufficientSyRepay(uint256 actualSyRepay, uint256 requiredSyRepay);\n    error RouterInsufficientPtRepay(uint256 actualPtRepay, uint256 requiredPtRepay);\n    error RouterNotAllSyUsed(uint256 netSyDesired, uint256 netSyUsed);\n\n    error RouterTimeRangeZero();\n    error RouterCallbackNotPendleMarket(address caller);\n    error RouterInvalidAction(bytes4 selector);\n    error RouterInvalidFacet(address facet);\n\n    error RouterKyberSwapDataZero();\n\n    // YIELD CONTRACT\n    error YCExpired();\n    error YCNotExpired();\n    error YieldContractInsufficientSy(uint256 actualSy, uint256 requiredSy);\n    error YCNothingToRedeem();\n    error YCPostExpiryDataNotSet();\n    error YCNoFloatingSy();\n\n    // YieldFactory\n    error YCFactoryInvalidExpiry();\n    error YCFactoryYieldContractExisted();\n    error YCFactoryZeroExpiryDivisor();\n    error YCFactoryZeroTreasury();\n    error YCFactoryInterestFeeRateTooHigh(uint256 interestFeeRate, uint256 maxInterestFeeRate);\n    error YCFactoryRewardFeeRateTooHigh(uint256 newRewardFeeRate, uint256 maxRewardFeeRate);\n\n    // SY\n    error SYInvalidTokenIn(address token);\n    error SYInvalidTokenOut(address token);\n    error SYZeroDeposit();\n    error SYZeroRedeem();\n    error SYInsufficientSharesOut(uint256 actualSharesOut, uint256 requiredSharesOut);\n    error SYInsufficientTokenOut(uint256 actualTokenOut, uint256 requiredTokenOut);\n\n    // SY-specific\n    error SYQiTokenMintFailed(uint256 errCode);\n    error SYQiTokenRedeemFailed(uint256 errCode);\n    error SYQiTokenRedeemRewardsFailed(uint256 rewardAccruedType0, uint256 rewardAccruedType1);\n    error SYQiTokenBorrowRateTooHigh(uint256 borrowRate, uint256 borrowRateMax);\n\n    error SYCurveInvalidPid();\n    error SYCurve3crvPoolNotFound();\n\n    error SYApeDepositAmountTooSmall(uint256 amountDeposited);\n    error SYBalancerInvalidPid();\n    error SYInvalidRewardToken(address token);\n\n    error SYStargateRedeemCapExceeded(uint256 amountLpDesired, uint256 amountLpRedeemable);\n\n    error SYBalancerReentrancy();\n\n    // Liquidity Mining\n    error VCInactivePool(address pool);\n    error VCPoolAlreadyActive(address pool);\n    error VCZeroVePendle(address user);\n    error VCExceededMaxWeight(uint256 totalWeight, uint256 maxWeight);\n    error VCEpochNotFinalized(uint256 wTime);\n    error VCPoolAlreadyAddAndRemoved(address pool);\n\n    error VEInvalidNewExpiry(uint256 newExpiry);\n    error VEExceededMaxLockTime();\n    error VEInsufficientLockTime();\n    error VENotAllowedReduceExpiry();\n    error VEZeroAmountLocked();\n    error VEPositionNotExpired();\n    error VEZeroPosition();\n    error VEZeroSlope(uint128 bias, uint128 slope);\n    error VEReceiveOldSupply(uint256 msgTime);\n\n    error GCNotPendleMarket(address caller);\n    error GCNotVotingController(address caller);\n\n    error InvalidWTime(uint256 wTime);\n    error ExpiryInThePast(uint256 expiry);\n    error ChainNotSupported(uint256 chainId);\n\n    error FDTotalAmountFundedNotMatch(uint256 actualTotalAmount, uint256 expectedTotalAmount);\n    error FDEpochLengthMismatch();\n    error FDInvalidPool(address pool);\n    error FDPoolAlreadyExists(address pool);\n    error FDInvalidNewFinishedEpoch(uint256 oldFinishedEpoch, uint256 newFinishedEpoch);\n    error FDInvalidStartEpoch(uint256 startEpoch);\n    error FDInvalidWTimeFund(uint256 lastFunded, uint256 wTime);\n    error FDFutureFunding(uint256 lastFunded, uint256 currentWTime);\n\n    error BDInvalidEpoch(uint256 epoch, uint256 startTime);\n\n    // Cross-Chain\n    error MsgNotFromSendEndpoint(uint16 srcChainId, bytes path);\n    error MsgNotFromReceiveEndpoint(address sender);\n    error InsufficientFeeToSendMsg(uint256 currentFee, uint256 requiredFee);\n    error ApproxDstExecutionGasNotSet();\n    error InvalidRetryData();\n\n    // GENERIC MSG\n    error ArrayLengthMismatch();\n    error ArrayEmpty();\n    error ArrayOutOfBounds();\n    error ZeroAddress();\n    error FailedToSendEther();\n\n    error OnlyLayerZeroEndpoint();\n    error OnlyYT();\n    error OnlyYCFactory();\n    error OnlyWhitelisted();\n\n    // Swap Aggregator\n    error SAInsufficientTokenIn(address tokenIn, uint256 amountExpected, uint256 amountActual);\n    error UnsupportedSelector(uint256 aggregatorType, bytes4 selector);\n}\n"

    },

    "contracts/pendle/contracts/core/libraries/math/Math.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity 0.8.17;\n\n/* solhint-disable private-vars-leading-underscore, reason-string */\n\nlibrary Math {\n    uint256 internal constant ONE = 1e18; // 18 decimal places\n    int256 internal constant IONE = 1e18; // 18 decimal places\n\n    function subMax0(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            return (a >= b ? a - b : 0);\n        }\n    }\n\n    function subNoNeg(int256 a, int256 b) internal pure returns (int256) {\n        require(a >= b, \"negative\");\n        return a - b; // no unchecked since if b is very negative, a - b might overflow\n    }\n\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        unchecked {\n            return product / ONE;\n        }\n    }\n\n    function mulDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 product = a * b;\n        unchecked {\n            return product / IONE;\n        }\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 aInflated = a * ONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function divDown(int256 a, int256 b) internal pure returns (int256) {\n        int256 aInflated = a * IONE;\n        unchecked {\n            return aInflated / b;\n        }\n    }\n\n    function rawDivUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b - 1) / b;\n    }\n\n    // @author Uniswap\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    function abs(int256 x) internal pure returns (uint256) {\n        return uint256(x > 0 ? x : -x);\n    }\n\n    function neg(int256 x) internal pure returns (int256) {\n        return x * (-1);\n    }\n\n    function neg(uint256 x) internal pure returns (int256) {\n        return Int(x) * (-1);\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x > y ? x : y);\n    }\n\n    function max(int256 x, int256 y) internal pure returns (int256) {\n        return (x > y ? x : y);\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\n        return (x < y ? x : y);\n    }\n\n    function min(int256 x, int256 y) internal pure returns (int256) {\n        return (x < y ? x : y);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               SIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Int(uint256 x) internal pure returns (int256) {\n        require(x <= uint256(type(int256).max));\n        return int256(x);\n    }\n\n    function Int128(int256 x) internal pure returns (int128) {\n        require(type(int128).min <= x && x <= type(int128).max);\n        return int128(x);\n    }\n\n    function Int128(uint256 x) internal pure returns (int128) {\n        return Int128(Int(x));\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               UNSIGNED CASTS\n    //////////////////////////////////////////////////////////////*/\n\n    function Uint(int256 x) internal pure returns (uint256) {\n        require(x >= 0);\n        return uint256(x);\n    }\n\n    function Uint32(uint256 x) internal pure returns (uint32) {\n        require(x <= type(uint32).max);\n        return uint32(x);\n    }\n\n    function Uint112(uint256 x) internal pure returns (uint112) {\n        require(x <= type(uint112).max);\n        return uint112(x);\n    }\n\n    function Uint96(uint256 x) internal pure returns (uint96) {\n        require(x <= type(uint96).max);\n        return uint96(x);\n    }\n\n    function Uint128(uint256 x) internal pure returns (uint128) {\n        require(x <= type(uint128).max);\n        return uint128(x);\n    }\n\n    function isAApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return mulDown(b, ONE - eps) <= a && a <= mulDown(b, ONE + eps);\n    }\n\n    function isAGreaterApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a >= b && a <= mulDown(b, ONE + eps);\n    }\n\n    function isASmallerApproxB(uint256 a, uint256 b, uint256 eps) internal pure returns (bool) {\n        return a <= b && a >= mulDown(b, ONE - eps);\n    }\n}\n"

    },

    "contracts/pendle/contracts/core/libraries/TokenHelper.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../../interfaces/IWETH.sol\";\n\nabstract contract TokenHelper {\n    using SafeERC20 for IERC20;\n    address internal constant NATIVE = address(0);\n    uint256 internal constant LOWER_BOUND_APPROVAL = type(uint96).max / 2; // some tokens use 96 bits for approval\n\n    function _transferIn(address token, address from, uint256 amount) internal {\n        if (token == NATIVE) require(msg.value == amount, \"eth mismatch\");\n        else if (amount != 0) IERC20(token).safeTransferFrom(from, address(this), amount);\n    }\n\n    function _transferFrom(IERC20 token, address from, address to, uint256 amount) internal {\n        if (amount != 0) token.safeTransferFrom(from, to, amount);\n    }\n\n    function _transferOut(address token, address to, uint256 amount) internal {\n        if (amount == 0) return;\n        if (token == NATIVE) {\n            (bool success, ) = to.call{ value: amount }(\"\");\n            require(success, \"eth send failed\");\n        } else {\n            IERC20(token).safeTransfer(to, amount);\n        }\n    }\n\n    function _transferOut(address[] memory tokens, address to, uint256[] memory amounts) internal {\n        uint256 numTokens = tokens.length;\n        require(numTokens == amounts.length, \"length mismatch\");\n        for (uint256 i = 0; i < numTokens; ) {\n            _transferOut(tokens[i], to, amounts[i]);\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    function _selfBalance(address token) internal view returns (uint256) {\n        return (token == NATIVE) ? address(this).balance : IERC20(token).balanceOf(address(this));\n    }\n\n    function _selfBalance(IERC20 token) internal view returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\n    /// @dev PLS PAY ATTENTION to tokens that requires the approval to be set to 0 before changing it\n    function _safeApprove(address token, address to, uint256 value) internal {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(IERC20.approve.selector, to, value)\n        );\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"Safe Approve\");\n    }\n\n    function _safeApproveInf(address token, address to) internal {\n        if (token == NATIVE) return;\n        if (IERC20(token).allowance(address(this), to) < LOWER_BOUND_APPROVAL) {\n            _safeApprove(token, to, 0);\n            _safeApprove(token, to, type(uint256).max);\n        }\n    }\n\n    function _wrap_unwrap_ETH(address tokenIn, address tokenOut, uint256 netTokenIn) internal {\n        if (tokenIn == NATIVE) IWETH(tokenOut).deposit{ value: netTokenIn }();\n        else IWETH(tokenIn).withdraw(netTokenIn);\n    }\n}\n"

    },

    "contracts/pendle/contracts/core/RewardManager/RewardManager.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"./RewardManagerAbstract.sol\";\n\n/// NOTE: This RewardManager is used with SY & YTv2 & PendleMarket. For YTv1, it will use RewardManagerAbstract\n/// NOTE: RewardManager must not have duplicated rewardTokens\nabstract contract RewardManager is RewardManagerAbstract {\n    using Math for uint256;\n    using ArrayLib for uint256[];\n\n    uint256 public lastRewardBlock;\n\n    mapping(address => RewardState) public rewardState;\n\n    uint256 internal constant INITIAL_REWARD_INDEX = 1;\n\n    function _updateRewardIndex()\n        internal\n        virtual\n        override\n        returns (address[] memory tokens, uint256[] memory indexes)\n    {\n        tokens = _getRewardTokens();\n        indexes = new uint256[](tokens.length);\n\n        if (tokens.length == 0) return (tokens, indexes);\n\n        if (lastRewardBlock != block.number) {\n            // if we have not yet update the index for this block\n            lastRewardBlock = block.number;\n\n            uint256 totalShares = _rewardSharesTotal();\n\n            _redeemExternalReward();\n\n            for (uint256 i = 0; i < tokens.length; ++i) {\n                address token = tokens[i];\n\n                // the entire token balance of the contract must be the rewards of the contract\n                uint256 accrued = _selfBalance(tokens[i]) - rewardState[token].lastBalance;\n                uint256 index = rewardState[token].index;\n\n                if (index == 0) index = INITIAL_REWARD_INDEX;\n                if (totalShares != 0) index += accrued.divDown(totalShares);\n\n                rewardState[token].index = index.Uint128();\n                rewardState[token].lastBalance += accrued.Uint128();\n            }\n        }\n\n        for (uint256 i = 0; i < tokens.length; i++) indexes[i] = rewardState[tokens[i]].index;\n    }\n\n    /// @dev this function doesn't need redeemExternal since redeemExternal is bundled in updateRewardIndex\n    /// @dev this function also has to update rewardState.lastBalance\n    function _doTransferOutRewards(\n        address user,\n        address receiver\n    ) internal virtual override returns (uint256[] memory rewardAmounts) {\n        address[] memory tokens = _getRewardTokens();\n        rewardAmounts = new uint256[](tokens.length);\n        for (uint256 i = 0; i < tokens.length; i++) {\n            rewardAmounts[i] = userReward[tokens[i]][user].accrued;\n            if (rewardAmounts[i] != 0) {\n                userReward[tokens[i]][user].accrued = 0;\n                rewardState[tokens[i]].lastBalance -= rewardAmounts[i].Uint128();\n                _transferOut(tokens[i], receiver, rewardAmounts[i]);\n            }\n        }\n    }\n\n    function _getRewardTokens() internal view virtual returns (address[] memory);\n\n    function _rewardSharesTotal() internal view virtual returns (uint256);\n}\n"

    },

    "contracts/pendle/contracts/core/RewardManager/RewardManagerAbstract.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"../../interfaces/IRewardManager.sol\";\n\nimport \"../libraries/ArrayLib.sol\";\nimport \"../libraries/TokenHelper.sol\";\nimport \"../libraries/math/Math.sol\";\n\nimport \"./RewardManagerAbstract.sol\";\n\n/// NOTE: RewardManager must not have duplicated rewardTokens\nabstract contract RewardManagerAbstract is IRewardManager, TokenHelper {\n    using Math for uint256;\n\n    struct RewardState {\n        uint128 index;\n        uint128 lastBalance;\n    }\n\n    struct UserReward {\n        uint128 index;\n        uint128 accrued;\n    }\n\n    // [token] => [user] => (index,accrued)\n    mapping(address => mapping(address => UserReward)) public userReward;\n\n    function _updateAndDistributeRewards(address user) internal virtual {\n        _updateAndDistributeRewardsForTwo(user, address(0));\n    }\n\n    function _updateAndDistributeRewardsForTwo(address user1, address user2) internal virtual {\n        (address[] memory tokens, uint256[] memory indexes) = _updateRewardIndex();\n        if (tokens.length == 0) return;\n\n        if (user1 != address(0) && user1 != address(this))\n            _distributeRewardsPrivate(user1, tokens, indexes);\n        if (user2 != address(0) && user2 != address(this))\n            _distributeRewardsPrivate(user2, tokens, indexes);\n    }\n\n    // should only be callable from `_updateAndDistributeRewardsForTwo` to guarantee user != address(0) && user != address(this)\n    function _distributeRewardsPrivate(\n        address user,\n        address[] memory tokens,\n        uint256[] memory indexes\n    ) private {\n        assert(user != address(0) && user != address(this));\n\n        uint256 userShares = _rewardSharesUser(user);\n\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            address token = tokens[i];\n            uint256 index = indexes[i];\n            uint256 userIndex = userReward[token][user].index;\n\n            if (userIndex == 0) {\n                userReward[token][user].index = index.Uint128();\n                continue;\n            }\n\n            if (userIndex == index) continue;\n\n            uint256 deltaIndex = index - userIndex;\n            uint256 rewardDelta = userShares.mulDown(deltaIndex);\n            uint256 rewardAccrued = userReward[token][user].accrued + rewardDelta;\n\n            userReward[token][user] = UserReward({\n                index: index.Uint128(),\n                accrued: rewardAccrued.Uint128()\n            });\n        }\n    }\n\n    function _updateRewardIndex()\n        internal\n        virtual\n        returns (address[] memory tokens, uint256[] memory indexes);\n\n    function _redeemExternalReward() internal virtual;\n\n    function _doTransferOutRewards(\n        address user,\n        address receiver\n    ) internal virtual returns (uint256[] memory rewardAmounts);\n\n    function _rewardSharesUser(address user) internal view virtual returns (uint256);\n}\n"

    },

    "contracts/pendle/contracts/core/StandardizedYield/implementations/BalancerStable/base/FixedPoint.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\n/* solhint-disable private-vars-leading-underscore */\n\n/**\n * @dev forked from https://etherscan.io/token/0x8e85e97ed19c0fa13b2549309965291fbbc0048b#code\n * with omitted overflow checks given solidity version\n */\n\nlibrary FixedPoint {\n    uint256 internal constant ONE = 1e18; // 18 decimal places\n    uint256 internal constant TWO = 2 * ONE;\n    uint256 internal constant FOUR = 4 * ONE;\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a * b) / ONE;\n    }\n\n    function mulUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        if (product == 0) {\n            return 0;\n        } else {\n            unchecked {\n                return ((product - 1) / ONE) + 1;\n            }\n        }\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"Zero division\");\n\n        if (a == 0) {\n            return 0;\n        } else {\n            uint256 aInflated = a * ONE;\n            return aInflated / b;\n        }\n    }\n\n    function divUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"Zero division\");\n\n        if (a == 0) {\n            return 0;\n        } else {\n            uint256 aInflated = a * ONE;\n            unchecked {\n                return ((aInflated - 1) / b) + 1;\n            }\n        }\n    }\n\n    function complement(uint256 x) internal pure returns (uint256) {\n        unchecked {\n            return (x < ONE) ? (ONE - x) : 0;\n        }\n    }\n}\n"

    },

    "contracts/pendle/contracts/core/StandardizedYield/implementations/BalancerStable/base/MetaStable/MetaStableMath.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\nimport \"../FixedPoint.sol\";\n\n// almost copy-paste from https://etherscan.io/token/0x1e19cf2d73a72ef1332c882f20534b6519be0276#code\nlibrary MetaStableMath {\n    using FixedPoint for uint256;\n\n    uint256 internal constant _MIN_AMP = 1;\n    uint256 internal constant _MAX_AMP = 5000;\n    uint256 internal constant _AMP_PRECISION = 1e3;\n\n    function _calculateInvariant(\n        uint256 amplificationParameter,\n        uint256[] memory balances,\n        bool roundUp\n    ) public pure returns (uint256) {\n        unchecked {\n            /**********************************************************************************************\n        // invariant                                                                                 //\n        // D = invariant                                                  D^(n+1)                    //\n        // A = amplification coefficient      A  n^n S + D = A D n^n + -----------                   //\n        // S = sum of balances                                             n^n P                     //\n        // P = product of balances                                                                   //\n        // n = number of tokens                                                                      //\n        **********************************************************************************************/\n            // We support rounding up or down.\n\n            uint256 sum = 0;\n            uint256 numTokens = balances.length;\n            for (uint256 i = 0; i < numTokens; i++) {\n                sum = sum.add(balances[i]);\n            }\n            if (sum == 0) {\n                return 0;\n            }\n\n            uint256 prevInvariant = 0;\n            uint256 invariant = sum;\n            uint256 ampTimesTotal = amplificationParameter * numTokens;\n\n            for (uint256 i = 0; i < 255; i++) {\n                uint256 P_D = balances[0] * numTokens;\n                for (uint256 j = 1; j < numTokens; j++) {\n                    P_D = div(mul(mul(P_D, balances[j]), numTokens), invariant, roundUp);\n                }\n                prevInvariant = invariant;\n                invariant = div(\n                    mul(mul(numTokens, invariant), invariant).add(\n                        div(mul(mul(ampTimesTotal, sum), P_D), _AMP_PRECISION, roundUp)\n                    ),\n                    mul(numTokens + 1, invariant).add(\n                        // No need to use checked arithmetic for the amp precision, the amp is guaranteed to be at least 1\n                        div(mul(ampTimesTotal - _AMP_PRECISION, P_D), _AMP_PRECISION, !roundUp)\n                    ),\n                    roundUp\n                );\n\n                if (invariant > prevInvariant) {\n                    if (invariant - prevInvariant <= 1) {\n                        return invariant;\n                    }\n                } else if (prevInvariant - invariant <= 1) {\n                    return invariant;\n                }\n            }\n\n            revert(\"Stable Invariant did not converge\");\n        }\n    }\n\n    function _calcBptOutGivenExactTokensIn(\n        uint256 amp,\n        uint256[] memory balances,\n        uint256[] memory amountsIn,\n        uint256 bptTotalSupply,\n        uint256 swapFeePercentage\n    ) internal pure returns (uint256) {\n        unchecked {\n            // BPT out, so we round down overall.\n\n            // First loop calculates the sum of all token balances, which will be used to calculate\n            // the current weights of each token, relative to this sum\n            uint256 sumBalances = 0;\n            for (uint256 i = 0; i < balances.length; i++) {\n                sumBalances = sumBalances.add(balances[i]);\n            }\n\n            // Calculate the weighted balance ratio without considering fees\n            uint256[] memory balanceRatiosWithFee = new uint256[](amountsIn.length);\n            // The weighted sum of token balance ratios with fee\n            uint256 invariantRatioWithFees = 0;\n            for (uint256 i = 0; i < balances.length; i++) {\n                uint256 currentWeight = balances[i].divDown(sumBalances);\n                balanceRatiosWithFee[i] = balances[i].add(amountsIn[i]).divDown(balances[i]);\n                invariantRatioWithFees = invariantRatioWithFees.add(\n                    balanceRatiosWithFee[i].mulDown(currentWeight)\n                );\n            }\n\n            // Second loop calculates new amounts in, taking into account the fee on the percentage excess\n            uint256[] memory newBalances = new uint256[](balances.length);\n            for (uint256 i = 0; i < balances.length; i++) {\n                uint256 amountInWithoutFee;\n\n                // Check if the balance ratio is greater than the ideal ratio to charge fees or not\n                if (balanceRatiosWithFee[i] > invariantRatioWithFees) {\n                    uint256 nonTaxableAmount = balances[i].mulDown(\n                        invariantRatioWithFees.sub(FixedPoint.ONE)\n                    );\n                    uint256 taxableAmount = amountsIn[i].sub(nonTaxableAmount);\n                    // No need to use checked arithmetic for the swap fee, it is guaranteed to be lower than 50%\n                    amountInWithoutFee = nonTaxableAmount.add(\n                        taxableAmount.mulDown(FixedPoint.ONE - swapFeePercentage)\n                    );\n                } else {\n                    amountInWithoutFee = amountsIn[i];\n                }\n\n                newBalances[i] = balances[i].add(amountInWithoutFee);\n            }\n\n            // Get current and new invariants, taking swap fees into account\n            uint256 currentInvariant = _calculateInvariant(amp, balances, true);\n            uint256 newInvariant = _calculateInvariant(amp, newBalances, false);\n            uint256 invariantRatio = newInvariant.divDown(currentInvariant);\n\n            // If the invariant didn't increase for any reason, we simply don't mint BPT\n            if (invariantRatio > FixedPoint.ONE) {\n                return bptTotalSupply.mulDown(invariantRatio - FixedPoint.ONE);\n            } else {\n                return 0;\n            }\n        }\n    }\n\n    function _calcTokenOutGivenExactBptIn(\n        uint256 amp,\n        uint256[] memory balances,\n        uint256 tokenIndex,\n        uint256 bptAmountIn,\n        uint256 bptTotalSupply,\n        uint256 swapFeePercentage\n    ) internal pure returns (uint256) {\n        unchecked {\n            // Token out, so we round down overall.\n\n            // Get the current and new invariants. Since we need a bigger new invariant, we round the current one up.\n            uint256 currentInvariant = _calculateInvariant(amp, balances, true);\n            uint256 newInvariant = bptTotalSupply.sub(bptAmountIn).divUp(bptTotalSupply).mulUp(\n                currentInvariant\n            );\n\n            // Calculate amount out without fee\n            uint256 newBalanceTokenIndex = _getTokenBalanceGivenInvariantAndAllOtherBalances(\n                amp,\n                balances,\n                newInvariant,\n                tokenIndex\n            );\n            uint256 amountOutWithoutFee = balances[tokenIndex].sub(newBalanceTokenIndex);\n\n            // First calculate the sum of all token balances, which will be used to calculate\n            // the current weight of each token\n            uint256 sumBalances = 0;\n            for (uint256 i = 0; i < balances.length; i++) {\n                sumBalances = sumBalances.add(balances[i]);\n            }\n\n            // We can now compute how much excess balance is being withdrawn as a result of the virtual swaps, which result\n            // in swap fees.\n            uint256 currentWeight = balances[tokenIndex].divDown(sumBalances);\n            uint256 taxablePercentage = currentWeight.complement();\n\n            // Swap fees are typically charged on 'token in', but there is no 'token in' here, so we apply it\n            // to 'token out'. This results in slightly larger price impact. Fees are rounded up.\n            uint256 taxableAmount = amountOutWithoutFee.mulUp(taxablePercentage);\n            uint256 nonTaxableAmount = amountOutWithoutFee.sub(taxableAmount);\n\n            // No need to use checked arithmetic for the swap fee, it is guaranteed to be lower than 50%\n            return nonTaxableAmount.add(taxableAmount.mulDown(FixedPoint.ONE - swapFeePercentage));\n        }\n    }\n\n    // The amplification parameter equals: A n^(n-1)\n    function _calcDueTokenProtocolSwapFeeAmount(\n        uint256 amplificationParameter,\n        uint256[] memory balances,\n        uint256 lastInvariant,\n        uint256 tokenIndex,\n        uint256 protocolSwapFeePercentage\n    ) internal pure returns (uint256) {\n        unchecked {\n            /**************************************************************************************************************\n        // oneTokenSwapFee - polynomial equation to solve                                                            //\n        // af = fee amount to calculate in one token                                                                 //\n        // bf = balance of fee token                                                                                 //\n        // f = bf - af (finalBalanceFeeToken)                                                                        //\n        // D = old invariant                                            D                     D^(n+1)                //\n        // A = amplification coefficient               f^2 + ( S - ----------  - D) * f -  ------------- = 0         //\n        // n = number of tokens                                    (A * n^n)               A * n^2n * P              //\n        // S = sum of final balances but f                                                                           //\n        // P = product of final balances but f                                                                       //\n        **************************************************************************************************************/\n\n            // Protocol swap fee amount, so we round down overall.\n\n            uint256 finalBalanceFeeToken = _getTokenBalanceGivenInvariantAndAllOtherBalances(\n                amplificationParameter,\n                balances,\n                lastInvariant,\n                tokenIndex\n            );\n\n            if (balances[tokenIndex] <= finalBalanceFeeToken) {\n                // This shouldn't happen outside of rounding errors, but have this safeguard nonetheless to prevent the Pool\n                // from entering a locked state in which joins and exits revert while computing accumulated swap fees.\n                return 0;\n            }\n\n            // Result is rounded down\n            uint256 accumulatedTokenSwapFees = balances[tokenIndex] - finalBalanceFeeToken;\n            return accumulatedTokenSwapFees.mulDown(protocolSwapFeePercentage);\n        }\n    }\n\n    // This function calculates the balance of a given token (tokenIndex)\n    // given all the other balances and the invariant\n    function _getTokenBalanceGivenInvariantAndAllOtherBalances(\n        uint256 amplificationParameter,\n        uint256[] memory balances,\n        uint256 invariant,\n        uint256 tokenIndex\n    ) internal pure returns (uint256) {\n        unchecked {\n            // Rounds result up overall\n\n            uint256 ampTimesTotal = amplificationParameter * balances.length;\n            uint256 sum = balances[0];\n            uint256 P_D = balances[0] * balances.length;\n            for (uint256 j = 1; j < balances.length; j++) {\n                P_D = divDown(mul(mul(P_D, balances[j]), balances.length), invariant);\n                sum = sum.add(balances[j]);\n            }\n            // No need to use safe math, based on the loop above `sum` is greater than or equal to `balances[tokenIndex]`\n            sum = sum - balances[tokenIndex];\n\n            uint256 inv2 = mul(invariant, invariant);\n            // We remove the balance from c by multiplying it\n            uint256 c = mul(\n                mul(divUp(inv2, mul(ampTimesTotal, P_D)), _AMP_PRECISION),\n                balances[tokenIndex]\n            );\n            uint256 b = sum.add(mul(divDown(invariant, ampTimesTotal), _AMP_PRECISION));\n\n            // We iterate to find the balance\n            uint256 prevTokenBalance = 0;\n            // We multiply the first iteration outside the loop with the invariant to set the value of the\n            // initial approximation.\n            uint256 tokenBalance = divUp(inv2.add(c), invariant.add(b));\n\n            for (uint256 i = 0; i < 255; i++) {\n                prevTokenBalance = tokenBalance;\n\n                tokenBalance = divUp(\n                    mul(tokenBalance, tokenBalance).add(c),\n                    mul(tokenBalance, 2).add(b).sub(invariant)\n                );\n\n                if (tokenBalance > prevTokenBalance) {\n                    if (tokenBalance - prevTokenBalance <= 1) {\n                        return tokenBalance;\n                    }\n                } else if (prevTokenBalance - tokenBalance <= 1) {\n                    return tokenBalance;\n                }\n            }\n\n            revert(\"Stable get balance did not converge\");\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    LEGACY MATH FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            uint256 c = a * b;\n            require(a == 0 || c / a == b);\n            return c;\n        }\n    }\n\n    function div(uint256 a, uint256 b, bool roundUp) internal pure returns (uint256) {\n        return roundUp ? divUp(a, b) : divDown(a, b);\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            require(b != 0);\n            return a / b;\n        }\n    }\n\n    function divUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            require(b != 0);\n\n            if (a == 0) {\n                return 0;\n            } else {\n                return 1 + (a - 1) / b;\n            }\n        }\n    }\n}\n"

    },

    "contracts/pendle/contracts/core/StandardizedYield/implementations/BalancerStable/base/MetaStable/MetaStablePreview.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\n\nimport \"../../../../../../interfaces/Balancer/IMetaStablePool.sol\";\nimport \"../../../../../../interfaces/Balancer/IRateProvider.sol\";\n\nimport \"../FixedPoint.sol\";\nimport \"./MetaStableMath.sol\";\nimport \"../StablePoolUserData.sol\";\n\nimport \"../StablePreviewBase.sol\";\nimport \"../../../../../libraries/BoringOwnableUpgradeable.sol\";\n\n// this contract will be upgradable for the first 3-6 months, then its upgradeability will be relinquished\ncontract MetaStablePreview is StablePreviewBase, BoringOwnableUpgradeable, UUPSUpgradeable {\n    using FixedPoint for uint256;\n    using MetaStableMath for uint256;\n    using StablePoolUserData for bytes;\n\n    struct ImmutableData {\n        address LP;\n        address[] poolTokens;\n        address[] rateProviders;\n        uint256[] rawScalingFactors;\n    }\n\n    constructor() initializer {}\n\n    function initialize() external initializer {\n        __BoringOwnable_init();\n    }\n\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n\n    function onJoinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData,\n        bytes memory poolImmutableData\n    ) internal view override returns (uint256 bptAmountOut) {\n        ImmutableData memory imd = abi.decode(poolImmutableData, (ImmutableData));\n\n        uint256[] memory caches = _cachePriceRatesIfNecessary(imd);\n\n        uint256[] memory scalingFactors = _scalingFactors(imd, caches);\n\n        // skip totalSupply == 0 case\n\n        _upscaleArray(balances, scalingFactors);\n        (bptAmountOut, , ) = _onJoinPool(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            scalingFactors,\n            userData,\n            imd\n        );\n\n        // skip _mintPoolTokens, _downscale\n    }\n\n    function onExitPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData,\n        bytes memory poolImmutableData\n    ) internal view virtual override returns (uint256 amountTokenOut) {\n        ImmutableData memory imd = abi.decode(poolImmutableData, (ImmutableData));\n\n        uint256[] memory caches = _cachePriceRatesIfNecessary(imd);\n\n        uint256[] memory scalingFactors = _scalingFactors(imd, caches);\n        _upscaleArray(balances, scalingFactors);\n\n        (, uint256[] memory amountsOut, ) = _onExitPool(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            scalingFactors,\n            userData,\n            imd\n        );\n\n        // skip burnPoolTokens\n\n        _downscaleDownArray(amountsOut, scalingFactors);\n        // skip _downscaleDownArray of dueProtocolFeeAmounts\n\n        for (uint256 i = 0; i < amountsOut.length; i++) {\n            if (amountsOut[i] > 0) {\n                amountTokenOut = amountsOut[i];\n            }\n        }\n    }\n\n    function _onJoinPool(\n        bytes32,\n        address,\n        address,\n        uint256[] memory balances,\n        uint256,\n        uint256 protocolSwapFeePercentage,\n        uint256[] memory scalingFactors,\n        bytes memory userData,\n        ImmutableData memory imd\n    ) internal view returns (uint256, uint256[] memory, uint256[] memory) {\n        // skip _updateOracle\n\n        uint256[] memory dueProtocolFeeAmounts = _getDueProtocolFeeAmounts(\n            balances,\n            protocolSwapFeePercentage,\n            imd\n        );\n\n        _mutateAmounts(balances, dueProtocolFeeAmounts, FixedPoint.sub);\n        (uint256 bptAmountOut, uint256[] memory amountsIn) = _doJoin(\n            balances,\n            scalingFactors,\n            userData,\n            imd\n        );\n\n        // skip _updateInvariantAfterJoin\n\n        return (bptAmountOut, amountsIn, dueProtocolFeeAmounts);\n    }\n\n    function _onExitPool(\n        bytes32,\n        address,\n        address,\n        uint256[] memory balances,\n        uint256,\n        uint256 protocolSwapFeePercentage,\n        uint256[] memory scalingFactors,\n        bytes memory userData,\n        ImmutableData memory imd\n    )\n        internal\n        view\n        virtual\n        returns (\n            uint256 bptAmountIn,\n            uint256[] memory amountsOut,\n            uint256[] memory dueProtocolFeeAmounts\n        )\n    {\n        // skip _updateOracle\n\n        dueProtocolFeeAmounts = _getDueProtocolFeeAmounts(\n            balances,\n            protocolSwapFeePercentage,\n            imd\n        );\n\n        _mutateAmounts(balances, dueProtocolFeeAmounts, FixedPoint.sub);\n\n        (bptAmountIn, amountsOut) = _doExit(balances, scalingFactors, userData, imd);\n\n        // skip pause case\n\n        // skip _updateInvariantAfterExit\n\n        return (bptAmountIn, amountsOut, dueProtocolFeeAmounts);\n    }\n\n    function _getDueProtocolFeeAmounts(\n        uint256[] memory balances,\n        uint256 protocolSwapFeePercentage,\n        ImmutableData memory imd\n    ) private view returns (uint256[] memory) {\n        uint256[] memory dueProtocolFeeAmounts = new uint256[](2);\n\n        if (protocolSwapFeePercentage == 0) {\n            return dueProtocolFeeAmounts;\n        }\n\n        uint256 chosenTokenIndex = 0;\n        uint256 maxBalance = balances[0];\n        for (uint256 i = 1; i < 2; ++i) {\n            uint256 currentBalance = balances[i];\n            if (currentBalance > maxBalance) {\n                chosenTokenIndex = i;\n                maxBalance = currentBalance;\n            }\n        }\n\n        (uint256 _lastInvariant, uint256 _lastInvariantAmp) = IMetaStablePool(imd.LP)\n            .getLastInvariant();\n        dueProtocolFeeAmounts[chosenTokenIndex] = MetaStableMath\n            ._calcDueTokenProtocolSwapFeeAmount(\n                _lastInvariantAmp,\n                balances,\n                _lastInvariant,\n                chosenTokenIndex,\n                protocolSwapFeePercentage\n            );\n\n        return dueProtocolFeeAmounts;\n    }\n\n    function _doJoin(\n        uint256[] memory balances,\n        uint256[] memory scalingFactors,\n        bytes memory userData,\n        ImmutableData memory imd\n    ) private view returns (uint256, uint256[] memory) {\n        return _joinExactTokensInForBPTOut(balances, scalingFactors, userData, imd);\n    }\n\n    function _joinExactTokensInForBPTOut(\n        uint256[] memory balances,\n        uint256[] memory scalingFactors,\n        bytes memory userData,\n        ImmutableData memory imd\n    ) private view returns (uint256, uint256[] memory) {\n        (uint256[] memory amountsIn, ) = userData.exactTokensInForBptOut();\n\n        _upscaleArray(amountsIn, scalingFactors);\n\n        (uint256 currentAmp, , ) = IMetaStablePool(imd.LP).getAmplificationParameter();\n        uint256 bptAmountOut = MetaStableMath._calcBptOutGivenExactTokensIn(\n            currentAmp,\n            balances,\n            amountsIn,\n            IMetaStablePool(imd.LP).totalSupply(),\n            IMetaStablePool(imd.LP).getSwapFeePercentage()\n        );\n\n        return (bptAmountOut, amountsIn);\n    }\n\n    function _doExit(\n        uint256[] memory balances,\n        uint256[] memory,\n        bytes memory userData,\n        ImmutableData memory imd\n    ) private view returns (uint256, uint256[] memory) {\n        return _exitExactBPTInForTokenOut(balances, userData, imd);\n    }\n\n    function _exitExactBPTInForTokenOut(\n        uint256[] memory balances,\n        bytes memory userData,\n        ImmutableData memory imd\n    ) private view returns (uint256, uint256[] memory) {\n        // This exit function is disabled if the contract is paused.\n\n        (uint256 bptAmountIn, uint256 tokenIndex) = userData.exactBptInForTokenOut();\n        // Note that there is no minimum amountOut parameter: this is handled by `IVault.exitPool`.\n\n        // We exit in a single token, so initialize amountsOut with zeros\n        uint256[] memory amountsOut = new uint256[](2);\n\n        // And then assign the result to the selected token\n        (uint256 currentAmp, , ) = IMetaStablePool(imd.LP).getAmplificationParameter();\n        amountsOut[tokenIndex] = MetaStableMath._calcTokenOutGivenExactBptIn(\n            currentAmp,\n            balances,\n            tokenIndex,\n            bptAmountIn,\n            IMetaStablePool(imd.LP).totalSupply(),\n            IMetaStablePool(imd.LP).getSwapFeePercentage()\n        );\n\n        return (bptAmountIn, amountsOut);\n    }\n\n    function _scalingFactors(\n        ImmutableData memory imd,\n        uint256[] memory caches\n    ) internal view virtual returns (uint256[] memory) {\n        uint256[] memory scalingFactors = new uint256[](2);\n\n        for (uint256 i = 0; i < 2; ++i) {\n            scalingFactors[i] = imd.rawScalingFactors[i].mulDown(_priceRate(caches, i));\n        }\n\n        return scalingFactors;\n    }\n\n    function _priceRate(\n        uint256[] memory caches,\n        uint256 index\n    ) internal view virtual returns (uint256) {\n        return caches[index] == 0 ? FixedPoint.ONE : caches[index];\n    }\n\n    function _cachePriceRatesIfNecessary(\n        ImmutableData memory imd\n    ) internal view returns (uint256[] memory res) {\n        res = new uint256[](2);\n        res[0] = _cachePriceRateIfNecessary(0, imd);\n        res[1] = _cachePriceRateIfNecessary(1, imd);\n    }\n\n    function _cachePriceRateIfNecessary(\n        uint256 index,\n        ImmutableData memory imd\n    ) internal view returns (uint256 res) {\n        if (!_hasRateProvider(imd, index)) return res;\n\n        uint256 expires;\n        (res, , expires) = IMetaStablePool(imd.LP).getPriceRateCache(\n            IERC20(imd.poolTokens[index])\n        );\n\n        if (block.timestamp > expires) {\n            res = IRateProvider(imd.rateProviders[index]).getRate();\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                               Helpers functions\n    //////////////////////////////////////////////////////////////*/\n\n    function _upscaleArray(\n        uint256[] memory amounts,\n        uint256[] memory scalingFactors\n    ) internal pure {\n        require(amounts.length == scalingFactors.length, \"Array length mismatch\");\n\n        uint256 length = amounts.length;\n        for (uint256 i = 0; i < length; ++i) {\n            amounts[i] = FixedPoint.mulDown(amounts[i], scalingFactors[i]);\n        }\n    }\n\n    function _downscaleDownArray(\n        uint256[] memory amounts,\n        uint256[] memory scalingFactors\n    ) internal pure {\n        require(amounts.length == scalingFactors.length, \"Array length mismatch\");\n\n        uint256 length = amounts.length;\n        for (uint256 i = 0; i < length; ++i) {\n            amounts[i] = FixedPoint.divDown(amounts[i], scalingFactors[i]);\n        }\n    }\n\n    function _mutateAmounts(\n        uint256[] memory toMutate,\n        uint256[] memory arguments,\n        function(uint256, uint256) pure returns (uint256) mutation\n    ) private pure {\n        for (uint256 i = 0; i < 2; ++i) {\n            toMutate[i] = mutation(toMutate[i], arguments[i]);\n        }\n    }\n\n    function _hasRateProvider(\n        ImmutableData memory imd,\n        uint256 index\n    ) internal pure returns (bool) {\n        return address(imd.rateProviders[index]) != address(0);\n    }\n}\n"

    },

    "contracts/pendle/contracts/core/StandardizedYield/implementations/BalancerStable/base/PendleAuraBalancerStableLPSYV2.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../../../../../interfaces/Balancer/IVault.sol\";\nimport \"../../../../../interfaces/Balancer/IRateProvider.sol\";\nimport \"../../../../../interfaces/Balancer/IBasePool.sol\";\nimport \"../../../../../interfaces/Balancer/IBalancerStablePreview.sol\";\nimport \"../../../../../interfaces/ConvexCurve/IBooster.sol\";\nimport \"../../../../../interfaces/ConvexCurve/IRewards.sol\";\n\nimport \"./StablePoolUserData.sol\";\nimport \"../../../../libraries/ArrayLib.sol\";\nimport \"../../../SYBaseWithRewards.sol\";\n\nabstract contract PendleAuraBalancerStableLPSYV2 is SYBaseWithRewards {\n    using ArrayLib for address[];\n\n    address internal constant BAL_TOKEN = 0xba100000625a3754423978a60c9317c58a424e3D;\n    address internal constant AURA_TOKEN = 0xC0c293ce456fF0ED870ADd98a0828Dd4d2903DBF;\n    address internal constant AURA_BOOSTER = 0xA57b8d98dAE62B26Ec3bcC4a365338157060B234;\n    address internal constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;\n    uint256 internal constant DEFAULT_GAS_REENTRANCY_CHECK = 7000;\n\n    address public immutable balLp;\n    bytes32 public immutable balPoolId;\n\n    uint256 public immutable auraPid;\n    address public immutable auraRewardManager;\n\n    IBalancerStablePreview public immutable previewHelper;\n\n    uint256 public gasForReentrancyCheck;\n    address[] public extraRewards;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _balLp,\n        uint256 _auraPid,\n        IBalancerStablePreview _previewHelper\n    ) SYBaseWithRewards(_name, _symbol, _balLp) {\n        balPoolId = IBasePool(_balLp).getPoolId();\n        auraPid = _auraPid;\n\n        (balLp, auraRewardManager) = _getPoolInfo(_auraPid);\n        if (balLp != _balLp) revert Errors.SYBalancerInvalidPid();\n\n        _safeApproveInf(_balLp, AURA_BOOSTER);\n\n        address[] memory tokens = _getPoolTokenAddresses();\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            _safeApproveInf(tokens[i], BALANCER_VAULT);\n        }\n\n        previewHelper = _previewHelper;\n        gasForReentrancyCheck = DEFAULT_GAS_REENTRANCY_CHECK;\n    }\n\n    function _getPoolInfo(uint256 _auraPid)\n        internal\n        view\n        returns (address _auraLp, address _auraRewardManager)\n    {\n        if (_auraPid > IBooster(AURA_BOOSTER).poolLength()) revert Errors.SYBalancerInvalidPid();\n        (_auraLp, , , _auraRewardManager, , ) = IBooster(AURA_BOOSTER).poolInfo(_auraPid);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    DEPOSIT/REDEEM USING BASE TOKENS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Either wraps LP, or also joins pool using exact tokenIn\n     */\n    function _deposit(address tokenIn, uint256 amount)\n        internal\n        virtual\n        override\n        returns (uint256 amountSharesOut)\n    {\n        if (tokenIn == balLp) {\n            amountSharesOut = amount;\n        } else {\n            amountSharesOut = _depositToBalancer(tokenIn, amount);\n        }\n        IBooster(AURA_BOOSTER).deposit(auraPid, amountSharesOut, true);\n    }\n\n    /**\n     * @notice Either unwraps LP, or also exits pool using exact LP for only `tokenOut`\n     */\n    function _redeem(\n        address receiver,\n        address tokenOut,\n        uint256 amountSharesToRedeem\n    ) internal virtual override returns (uint256 amountTokenOut) {\n        IRewards(auraRewardManager).withdrawAndUnwrap(amountSharesToRedeem, false);\n\n        if (tokenOut == balLp) {\n            amountTokenOut = amountSharesToRedeem;\n            _transferOut(tokenOut, receiver, amountTokenOut);\n        } else {\n            amountTokenOut = _redeemFromBalancer(receiver, tokenOut, amountSharesToRedeem);\n        }\n    }\n\n    function exchangeRate() external view override returns (uint256) {\n        _checkBalancerReadOnlyReentrancy();\n        return IRateProvider(balLp).getRate();\n    }\n\n    /*\n    * The `manageUserBalance` function is a non-view function that includes a reentrancy guard\n        in the form of `_require(_status != _ENTERED, Errors.REENTRANCY);`. To prevent\n        read-only reentrancy, it's important to ensure that our `manageUserBalance` has enough gas\n        to reach this check, so that it can fail if necessary.\n\n    * On the way to the check, there's at most one `COLD_SLOAD` plus miscellaneous decoding &\n        require, which we've found through testing to cost no more than 3200 gas. Therefore,\n        attaching 7000 gas should guarantee that it's always possible to reach the check.\n\n    * Once we've reached the check, one of two scenarios can occur:\n    1. The call doesn't pass the check, and reverts with error `BAL#400` ⇒ `response.length = 100`.\n    2. The call passes the check. Then, the call can either:\n        a. continue on to set the `status` variable to 2, causing the EVM to revert (since\n        the sub-call is a `staticcall`), and `response.length == 0`\n        b. run out of gas, which will also lead to a revert with `response.length == 0`\n    In both cases, to differentiate between 1 and 2, we check `response.length != 0`. If it's\n    true, then it's a read-only reentrancy. Otherwise, we're good (and we can ignore\n    differentiating between 2a and 2b).\n    */\n    function _checkBalancerReadOnlyReentrancy() internal view {\n        IVault.UserBalanceOp[] memory noop = new IVault.UserBalanceOp[](0);\n\n        (bool isSuccess, bytes memory response) = BALANCER_VAULT.staticcall{\n            gas: gasForReentrancyCheck\n        }(\n            abi.encodeWithSignature(\n                \"manageUserBalance((uint8,address,uint256,address,address)[])\",\n                noop\n            )\n        );\n\n        assert(!isSuccess);\n        if (response.length != 0) revert Errors.SYBalancerReentrancy();\n    }\n\n    function setGasForReentrancyCheck(uint256 newGas) external onlyOwner {\n        require(newGas >= DEFAULT_GAS_REENTRANCY_CHECK, \"lower than default\");\n        gasForReentrancyCheck = newGas;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    BALANCER-RELATED FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function _depositToBalancer(address tokenIn, uint256 amountTokenToDeposit)\n        internal\n        virtual\n        returns (uint256)\n    {\n        IVault.JoinPoolRequest memory request = _assembleJoinRequest(\n            tokenIn,\n            amountTokenToDeposit\n        );\n        IVault(BALANCER_VAULT).joinPool(balPoolId, address(this), address(this), request);\n\n        // amount shares out = amount LP received\n        return _selfBalance(balLp);\n    }\n\n    function _assembleJoinRequest(address tokenIn, uint256 amountTokenToDeposit)\n        internal\n        view\n        virtual\n        returns (IVault.JoinPoolRequest memory request)\n    {\n        // max amounts in\n        address[] memory assets = _getPoolTokenAddresses();\n\n        uint256 amountsLength = _getBPTIndex() < type(uint256).max\n            ? assets.length - 1\n            : assets.length;\n\n        uint256[] memory amountsIn = new uint256[](amountsLength);\n        uint256[] memory maxAmountsIn = new uint256[](assets.length);\n\n        uint256 index = assets.find(tokenIn);\n        uint256 indexSkipBPT = index > _getBPTIndex() ? index - 1 : index;\n        maxAmountsIn[index] = amountsIn[indexSkipBPT] = amountTokenToDeposit;\n\n        // encode user data\n        StablePoolUserData.JoinKind joinKind = StablePoolUserData\n            .JoinKind\n            .EXACT_TOKENS_IN_FOR_BPT_OUT;\n        uint256 minimumBPT = 0;\n\n        bytes memory userData = abi.encode(joinKind, amountsIn, minimumBPT);\n\n        // assemble joinpoolrequest\n        request = IVault.JoinPoolRequest(assets, maxAmountsIn, userData, false);\n    }\n\n    function _redeemFromBalancer(\n        address receiver,\n        address tokenOut,\n        uint256 amountLpToRedeem\n    ) internal virtual returns (uint256) {\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(receiver);\n\n        IVault.ExitPoolRequest memory request = _assembleExitRequest(tokenOut, amountLpToRedeem);\n        IVault(BALANCER_VAULT).exitPool(balPoolId, address(this), payable(receiver), request);\n\n        // calculate amount of tokens out\n        uint256 balanceAfter = IERC20(tokenOut).balanceOf(receiver);\n        return balanceAfter - balanceBefore;\n    }\n\n    function _assembleExitRequest(address tokenOut, uint256 amountLpToRedeem)\n        internal\n        view\n        virtual\n        returns (IVault.ExitPoolRequest memory request)\n    {\n        address[] memory assets = _getPoolTokenAddresses();\n        uint256[] memory minAmountsOut = new uint256[](assets.length);\n\n        // encode user data\n        StablePoolUserData.ExitKind exitKind = StablePoolUserData\n            .ExitKind\n            .EXACT_BPT_IN_FOR_ONE_TOKEN_OUT;\n        uint256 bptAmountIn = amountLpToRedeem;\n        uint256 exitTokenIndex = assets.find(tokenOut);\n\n        // must drop BPT index as well\n        exitTokenIndex = _getBPTIndex() < exitTokenIndex ? exitTokenIndex - 1 : exitTokenIndex;\n\n        bytes memory userData = abi.encode(exitKind, bptAmountIn, exitTokenIndex);\n\n        // assemble exitpoolrequest\n        request = IVault.ExitPoolRequest(assets, minAmountsOut, userData, false);\n    }\n\n    /// @dev this should return tokens in the same order as `IVault.getPoolTokens()`\n    function _getPoolTokenAddresses() internal view virtual returns (address[] memory res);\n\n    /// @dev should be overriden if and only if BPT is one of the pool tokens\n    function _getBPTIndex() internal view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                   PREVIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function _previewDeposit(address tokenIn, uint256 amountTokenToDeposit)\n        internal\n        view\n        virtual\n        override\n        returns (uint256 amountSharesOut)\n    {\n        if (tokenIn == balLp) {\n            amountSharesOut = amountTokenToDeposit;\n        } else {\n            IVault.JoinPoolRequest memory request = _assembleJoinRequest(\n                tokenIn,\n                amountTokenToDeposit\n            );\n            amountSharesOut = previewHelper.joinPoolPreview(\n                balPoolId,\n                address(this),\n                address(this),\n                request,\n                _getImmutablePoolData()\n            );\n        }\n    }\n\n    function _previewRedeem(address tokenOut, uint256 amountSharesToRedeem)\n        internal\n        view\n        virtual\n        override\n        returns (uint256 amountTokenOut)\n    {\n        if (tokenOut == balLp) {\n            amountTokenOut = amountSharesToRedeem;\n        } else {\n            IVault.ExitPoolRequest memory request = _assembleExitRequest(\n                tokenOut,\n                amountSharesToRedeem\n            );\n\n            amountTokenOut = previewHelper.exitPoolPreview(\n                balPoolId,\n                address(this),\n                address(this),\n                request,\n                _getImmutablePoolData()\n            );\n        }\n    }\n\n    function _getImmutablePoolData() internal view virtual returns (bytes memory);\n\n    /*///////////////////////////////////////////////////////////////\n                               REWARDS-RELATED\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice allows owner to add new reward tokens in in case Aura does so with their pools\n    function addRewardTokens(address token) external virtual onlyOwner {\n        if (token == BAL_TOKEN || token == AURA_TOKEN || extraRewards.contains(token))\n            revert Errors.SYInvalidRewardToken(token);\n\n        uint256 nRewardsAura = IRewards(auraRewardManager).extraRewardsLength();\n        for (uint256 i = 0; i < nRewardsAura; i++) {\n            if (token == IRewards(IRewards(auraRewardManager).extraRewards(i)).rewardToken()) {\n                extraRewards.push(token);\n                return;\n            }\n        }\n\n        revert Errors.SYInvalidRewardToken(token);\n    }\n\n    function extraRewardsLength() external view virtual returns (uint256) {\n        return extraRewards.length;\n    }\n\n    function _getRewardTokens() internal view virtual override returns (address[] memory res) {\n        uint256 extraRewardsLen = extraRewards.length;\n        res = new address[](2 + extraRewardsLen);\n        res[0] = BAL_TOKEN;\n        res[1] = AURA_TOKEN;\n        for (uint256 i = 0; i < extraRewardsLen; i++) {\n            res[2 + i] = extraRewards[i];\n        }\n    }\n\n    /// @dev if there is no extra rewards, we can call getReward with the 2nd arg (_claimExtra) to be false\n    /// which helps save even more gas\n    function _redeemExternalReward() internal virtual override {\n        uint256 extraRewardsLen = extraRewards.length;\n        if (extraRewardsLen == 0) IRewards(auraRewardManager).getReward(address(this), false);\n        else IRewards(auraRewardManager).getReward(address(this), true);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    MISC FUNCTIONS FOR METADATA\n    //////////////////////////////////////////////////////////////*/\n\n    function getTokensIn() public view virtual override returns (address[] memory res);\n\n    function getTokensOut() public view virtual override returns (address[] memory res);\n\n    function isValidTokenIn(address token) public view virtual override returns (bool);\n\n    function isValidTokenOut(address token) public view virtual override returns (bool);\n\n    function assetInfo()\n        external\n        view\n        returns (\n            AssetType assetType,\n            address assetAddress,\n            uint8 assetDecimals\n        )\n    {\n        return (AssetType.LIQUIDITY, balLp, IERC20Metadata(balLp).decimals());\n    }\n}\n"

    },

    "contracts/pendle/contracts/core/StandardizedYield/implementations/BalancerStable/base/StablePoolUserData.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\nlibrary StablePoolUserData {\n    enum JoinKind {\n        INIT,\n        EXACT_TOKENS_IN_FOR_BPT_OUT,\n        TOKEN_IN_FOR_EXACT_BPT_OUT\n    }\n    enum ExitKind {\n        EXACT_BPT_IN_FOR_ONE_TOKEN_OUT,\n        BPT_IN_FOR_EXACT_TOKENS_OUT\n    }\n\n    function exactTokensInForBptOut(\n        bytes memory self\n    ) internal pure returns (uint256[] memory amountsIn, uint256 minBPTAmountOut) {\n        (, amountsIn, minBPTAmountOut) = abi.decode(self, (JoinKind, uint256[], uint256));\n    }\n\n    function exactBptInForTokenOut(\n        bytes memory self\n    ) internal pure returns (uint256 bptAmountIn, uint256 tokenIndex) {\n        (, bptAmountIn, tokenIndex) = abi.decode(self, (ExitKind, uint256, uint256));\n    }\n}\n"

    },

    "contracts/pendle/contracts/core/StandardizedYield/implementations/BalancerStable/base/StablePreviewBase.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../../../../interfaces/Balancer/IVault.sol\";\nimport \"../../../../../interfaces/Balancer/IBalancerFees.sol\";\nimport \"../../../../../interfaces/Balancer/IBalancerStablePreview.sol\";\n\nabstract contract StablePreviewBase is IBalancerStablePreview {\n    address internal constant BALANCER_VAULT = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;\n    address internal constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address internal constant FEE_COLLECTOR = 0xce88686553686DA562CE7Cea497CE749DA109f9F;\n\n    enum PoolBalanceChangeKind {\n        JOIN,\n        EXIT\n    }\n\n    struct PoolBalanceChange {\n        IAsset[] assets;\n        uint256[] limits;\n        bytes userData;\n        bool useInternalBalance;\n    }\n\n    function joinPoolPreview(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        IVault.JoinPoolRequest memory request,\n        bytes memory data\n    ) external view returns (uint256 amountBptOut) {\n        amountBptOut = _joinOrExit(\n            PoolBalanceChangeKind.JOIN,\n            poolId,\n            sender,\n            payable(recipient),\n            _toPoolBalanceChange(request),\n            data\n        );\n    }\n\n    function exitPoolPreview(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        IVault.ExitPoolRequest memory request,\n        bytes memory data\n    ) external view returns (uint256 amountTokenOut) {\n        amountTokenOut = _joinOrExit(\n            PoolBalanceChangeKind.EXIT,\n            poolId,\n            sender,\n            recipient,\n            _toPoolBalanceChange(request),\n            data\n        );\n    }\n\n    function _joinOrExit(\n        PoolBalanceChangeKind kind,\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        PoolBalanceChange memory change,\n        bytes memory data\n    ) private view returns (uint256 amountBptOrTokensOut) {\n        IERC20[] memory tokens = _translateToIERC20(change.assets);\n        (uint256[] memory balances, uint256 lastChangeBlock) = _validateTokensAndGetBalances(\n            poolId,\n            tokens\n        );\n\n        amountBptOrTokensOut = _callPoolBalanceChange(\n            kind,\n            poolId,\n            sender,\n            recipient,\n            change,\n            balances,\n            lastChangeBlock,\n            data\n        );\n    }\n\n    function _callPoolBalanceChange(\n        PoolBalanceChangeKind kind,\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        PoolBalanceChange memory change,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        bytes memory data\n    ) private view returns (uint256 amountsChanged) {\n        if (kind == PoolBalanceChangeKind.JOIN) {\n            amountsChanged = onJoinPool(\n                poolId,\n                sender,\n                recipient,\n                balances,\n                lastChangeBlock,\n                _getProtocolSwapFeePercentage(),\n                change.userData,\n                data\n            );\n        } else {\n            amountsChanged = onExitPool(\n                poolId,\n                sender,\n                recipient,\n                balances,\n                lastChangeBlock,\n                _getProtocolSwapFeePercentage(),\n                change.userData,\n                data\n            );\n        }\n    }\n\n    function _getProtocolSwapFeePercentage() private view returns (uint256) {\n        return IBalancerFees(FEE_COLLECTOR).getSwapFeePercentage();\n    }\n\n    function _validateTokensAndGetBalances(\n        bytes32 poolId,\n        IERC20[] memory //expectedTokens\n    ) private view returns (uint256[] memory, uint256) {\n        (, uint256[] memory balances, uint256 lastChangeBlock) = IVault(BALANCER_VAULT)\n            .getPoolTokens(poolId);\n        return (balances, lastChangeBlock);\n    }\n\n    function _translateToIERC20(IAsset[] memory assets) internal pure returns (IERC20[] memory) {\n        IERC20[] memory tokens = new IERC20[](assets.length);\n        for (uint256 i = 0; i < assets.length; ++i) {\n            tokens[i] = _translateToIERC20(assets[i]);\n        }\n        return tokens;\n    }\n\n    function _translateToIERC20(IAsset asset) internal pure returns (IERC20) {\n        return address(asset) == address(0) ? IERC20(WETH) : IERC20(address(asset));\n    }\n\n    function _toPoolBalanceChange(\n        IVault.JoinPoolRequest memory request\n    ) private pure returns (PoolBalanceChange memory change) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            change := request\n        }\n    }\n\n    function _toPoolBalanceChange(\n        IVault.ExitPoolRequest memory request\n    ) private pure returns (PoolBalanceChange memory change) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            change := request\n        }\n    }\n\n    function onJoinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData,\n        bytes memory data\n    ) internal view virtual returns (uint256 bptAmountOut);\n\n    function onExitPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData,\n        bytes memory data\n    ) internal view virtual returns (uint256 amountTokenOut);\n}\n"

    },

    "contracts/pendle/contracts/core/StandardizedYield/implementations/BalancerStable/PendleAuraWethStafiEthSY.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"./base/PendleAuraBalancerStableLPSYV2.sol\";\nimport \"../../../../interfaces/IWETH.sol\";\nimport \"./base/MetaStable/MetaStablePreview.sol\";\n\ncontract PendleAuraWethStafiEthSY is PendleAuraBalancerStableLPSYV2 {\n    address internal constant STAFI_ETH = 0x9559Aaa82d9649C7A7b220E7c461d2E74c9a3593;\n    address internal constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    uint256 internal constant AURA_PID = 63;\n    address internal constant LP = 0xB08885e6026bab4333A80024Ec25a1a3e1FF2b8A;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        MetaStablePreview _previewHelper\n    ) PendleAuraBalancerStableLPSYV2(_name, _symbol, LP, AURA_PID, _previewHelper) {}\n\n    function _deposit(address tokenIn, uint256 amount)\n        internal\n        virtual\n        override\n        returns (uint256 amountSharesOut)\n    {\n        if (tokenIn == NATIVE) {\n            IWETH(WETH).deposit{ value: amount }();\n            amountSharesOut = super._deposit(WETH, amount);\n        } else {\n            amountSharesOut = super._deposit(tokenIn, amount);\n        }\n    }\n\n    function _redeem(\n        address receiver,\n        address tokenOut,\n        uint256 amountSharesToRedeem\n    ) internal virtual override returns (uint256) {\n        if (tokenOut == NATIVE) {\n            uint256 amountTokenOut = super._redeem(address(this), WETH, amountSharesToRedeem);\n            IWETH(WETH).withdraw(amountTokenOut);\n            _transferOut(NATIVE, receiver, amountTokenOut);\n            return amountTokenOut;\n        } else {\n            return super._redeem(receiver, tokenOut, amountSharesToRedeem);\n        }\n    }\n\n    function _previewDeposit(address tokenIn, uint256 amountTokenToDeposit)\n        internal\n        view\n        virtual\n        override\n        returns (uint256 amountSharesOut)\n    {\n        if (tokenIn == NATIVE) {\n            amountSharesOut = super._previewDeposit(WETH, amountTokenToDeposit);\n        } else {\n            amountSharesOut = super._previewDeposit(tokenIn, amountTokenToDeposit);\n        }\n    }\n\n    function _previewRedeem(address tokenOut, uint256 amountSharesToRedeem)\n        internal\n        view\n        virtual\n        override\n        returns (uint256 amountTokenOut)\n    {\n        if (tokenOut == NATIVE) {\n            amountTokenOut = super._previewRedeem(WETH, amountSharesToRedeem);\n        } else {\n            amountTokenOut = super._previewRedeem(tokenOut, amountSharesToRedeem);\n        }\n    }\n\n    function _getPoolTokenAddresses()\n        internal\n        view\n        virtual\n        override\n        returns (address[] memory res)\n    {\n        res = new address[](2);\n        res[0] = STAFI_ETH;\n        res[1] = WETH;\n    }\n\n    function _getRateProviders() internal view virtual returns (address[] memory res) {\n        res = new address[](2);\n        res[0] = 0x3D40f9dd83bd404fA4047c15da494E58C3c1f1ac;\n        res[1] = 0x0000000000000000000000000000000000000000;\n    }\n\n    function _getRawScalingFactors() internal view virtual returns (uint256[] memory res) {\n        res = new uint256[](2);\n        res[0] = 1e18;\n        res[1] = 1e18;\n    }\n\n    function _getImmutablePoolData() internal view virtual override returns (bytes memory) {\n        MetaStablePreview.ImmutableData memory res;\n        res.LP = LP;\n        res.poolTokens = _getPoolTokenAddresses();\n        res.rateProviders = _getRateProviders();\n        res.rawScalingFactors = _getRawScalingFactors();\n\n        return abi.encode(res);\n    }\n\n    function getTokensIn() public view virtual override returns (address[] memory res) {\n        res = new address[](4);\n        res[0] = LP;\n        res[1] = STAFI_ETH;\n        res[2] = WETH;\n        res[3] = NATIVE;\n    }\n\n    function getTokensOut() public view virtual override returns (address[] memory res) {\n        res = new address[](4);\n        res[0] = LP;\n        res[1] = STAFI_ETH;\n        res[2] = WETH;\n        res[3] = NATIVE;\n    }\n\n    function isValidTokenIn(address token) public view virtual override returns (bool) {\n        return (token == LP || token == STAFI_ETH || token == WETH || token == NATIVE);\n    }\n\n    function isValidTokenOut(address token) public view virtual override returns (bool) {\n        return (token == LP || token == STAFI_ETH || token == WETH || token == NATIVE);\n    }\n}\n"

    },

    "contracts/pendle/contracts/core/StandardizedYield/SYBase.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\nimport \"../../interfaces/IStandardizedYield.sol\";\n\nimport \"../erc20/PendleERC20Permit.sol\";\n\nimport \"../libraries/math/Math.sol\";\nimport \"../libraries/TokenHelper.sol\";\nimport \"../libraries/Errors.sol\";\nimport \"../libraries/BoringOwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nabstract contract SYBase is\n    IStandardizedYield,\n    PendleERC20Permit,\n    TokenHelper,\n    BoringOwnableUpgradeable,\n    Pausable\n{\n    using Math for uint256;\n\n    address public immutable yieldToken;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _yieldToken\n    ) PendleERC20Permit(_name, _symbol, IERC20Metadata(_yieldToken).decimals()) initializer {\n        yieldToken = _yieldToken;\n        __BoringOwnable_init();\n    }\n\n    // solhint-disable no-empty-blocks\n    receive() external payable {}\n\n    /*///////////////////////////////////////////////////////////////\n                    DEPOSIT/REDEEM USING BASE TOKENS\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @dev See {IStandardizedYield-deposit}\n     */\n    function deposit(\n        address receiver,\n        address tokenIn,\n        uint256 amountTokenToDeposit,\n        uint256 minSharesOut\n    ) external payable nonReentrant returns (uint256 amountSharesOut) {\n        if (!isValidTokenIn(tokenIn)) revert Errors.SYInvalidTokenIn(tokenIn);\n        if (amountTokenToDeposit == 0) revert Errors.SYZeroDeposit();\n\n        _transferIn(tokenIn, msg.sender, amountTokenToDeposit);\n\n        amountSharesOut = _deposit(tokenIn, amountTokenToDeposit);\n        if (amountSharesOut < minSharesOut)\n            revert Errors.SYInsufficientSharesOut(amountSharesOut, minSharesOut);\n\n        _mint(receiver, amountSharesOut);\n        emit Deposit(msg.sender, receiver, tokenIn, amountTokenToDeposit, amountSharesOut);\n    }\n\n    /**\n     * @dev See {IStandardizedYield-redeem}\n     */\n    function redeem(\n        address receiver,\n        uint256 amountSharesToRedeem,\n        address tokenOut,\n        uint256 minTokenOut,\n        bool burnFromInternalBalance\n    ) external nonReentrant returns (uint256 amountTokenOut) {\n        if (!isValidTokenOut(tokenOut)) revert Errors.SYInvalidTokenOut(tokenOut);\n        if (amountSharesToRedeem == 0) revert Errors.SYZeroRedeem();\n\n        if (burnFromInternalBalance) {\n            _burn(address(this), amountSharesToRedeem);\n        } else {\n            _burn(msg.sender, amountSharesToRedeem);\n        }\n\n        amountTokenOut = _redeem(receiver, tokenOut, amountSharesToRedeem);\n        if (amountTokenOut < minTokenOut)\n            revert Errors.SYInsufficientTokenOut(amountTokenOut, minTokenOut);\n        emit Redeem(msg.sender, receiver, tokenOut, amountSharesToRedeem, amountTokenOut);\n    }\n\n    /**\n     * @notice mint shares based on the deposited base tokens\n     * @param tokenIn base token address used to mint shares\n     * @param amountDeposited amount of base tokens deposited\n     * @return amountSharesOut amount of shares minted\n     */\n    function _deposit(\n        address tokenIn,\n        uint256 amountDeposited\n    ) internal virtual returns (uint256 amountSharesOut);\n\n    /**\n     * @notice redeems base tokens based on amount of shares to be burned\n     * @param tokenOut address of the base token to be redeemed\n     * @param amountSharesToRedeem amount of shares to be burned\n     * @return amountTokenOut amount of base tokens redeemed\n     */\n    function _redeem(\n        address receiver,\n        address tokenOut,\n        uint256 amountSharesToRedeem\n    ) internal virtual returns (uint256 amountTokenOut);\n\n    /*///////////////////////////////////////////////////////////////\n                               EXCHANGE-RATE\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @dev See {IStandardizedYield-exchangeRate}\n     */\n    function exchangeRate() external view virtual override returns (uint256 res);\n\n    /*///////////////////////////////////////////////////////////////\n                               REWARDS-RELATED\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @dev See {IStandardizedYield-claimRewards}\n     */\n    function claimRewards(\n        address /*user*/\n    ) external virtual override returns (uint256[] memory rewardAmounts) {\n        rewardAmounts = new uint256[](0);\n    }\n\n    /**\n     * @dev See {IStandardizedYield-getRewardTokens}\n     */\n    function getRewardTokens()\n        external\n        view\n        virtual\n        override\n        returns (address[] memory rewardTokens)\n    {\n        rewardTokens = new address[](0);\n    }\n\n    /**\n     * @dev See {IStandardizedYield-accruedRewards}\n     */\n    function accruedRewards(\n        address /*user*/\n    ) external view virtual override returns (uint256[] memory rewardAmounts) {\n        rewardAmounts = new uint256[](0);\n    }\n\n    function rewardIndexesCurrent() external virtual override returns (uint256[] memory indexes) {\n        indexes = new uint256[](0);\n    }\n\n    function rewardIndexesStored()\n        external\n        view\n        virtual\n        override\n        returns (uint256[] memory indexes)\n    {\n        indexes = new uint256[](0);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                MISC METADATA FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function previewDeposit(\n        address tokenIn,\n        uint256 amountTokenToDeposit\n    ) external view virtual returns (uint256 amountSharesOut) {\n        if (!isValidTokenIn(tokenIn)) revert Errors.SYInvalidTokenIn(tokenIn);\n        return _previewDeposit(tokenIn, amountTokenToDeposit);\n    }\n\n    function previewRedeem(\n        address tokenOut,\n        uint256 amountSharesToRedeem\n    ) external view virtual returns (uint256 amountTokenOut) {\n        if (!isValidTokenOut(tokenOut)) revert Errors.SYInvalidTokenOut(tokenOut);\n        return _previewRedeem(tokenOut, amountSharesToRedeem);\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function _beforeTokenTransfer(\n        address,\n        address,\n        uint256\n    ) internal virtual override whenNotPaused {}\n\n    function _previewDeposit(\n        address tokenIn,\n        uint256 amountTokenToDeposit\n    ) internal view virtual returns (uint256 amountSharesOut);\n\n    function _previewRedeem(\n        address tokenOut,\n        uint256 amountSharesToRedeem\n    ) internal view virtual returns (uint256 amountTokenOut);\n\n    function getTokensIn() public view virtual returns (address[] memory res);\n\n    function getTokensOut() public view virtual returns (address[] memory res);\n\n    function isValidTokenIn(address token) public view virtual returns (bool);\n\n    function isValidTokenOut(address token) public view virtual returns (bool);\n}\n"

    },

    "contracts/pendle/contracts/core/StandardizedYield/SYBaseWithRewards.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"../RewardManager/RewardManager.sol\";\nimport \"./SYBase.sol\";\n\n/// NOTE: yieldToken MUST NEVER BE a rewardToken, else the rewardManager will behave erroneously\nabstract contract SYBaseWithRewards is SYBase, RewardManager {\n    using Math for uint256;\n    using ArrayLib for address[];\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address _yieldToken\n    )\n        SYBase(_name, _symbol, _yieldToken) // solhint-disable-next-line no-empty-blocks\n    {}\n\n    /*///////////////////////////////////////////////////////////////\n                               REWARDS-RELATED\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @dev See {IStandardizedYield-claimRewards}\n     */\n    function claimRewards(address user)\n        external\n        virtual\n        override\n        nonReentrant\n        returns (uint256[] memory rewardAmounts)\n    {\n        _updateAndDistributeRewards(user);\n        rewardAmounts = _doTransferOutRewards(user, user);\n\n        emit ClaimRewards(user, _getRewardTokens(), rewardAmounts);\n    }\n\n    /**\n     * @dev See {IStandardizedYield-getRewardTokens}\n     */\n    function getRewardTokens()\n        external\n        view\n        virtual\n        override\n        returns (address[] memory rewardTokens)\n    {\n        rewardTokens = _getRewardTokens();\n    }\n\n    /**\n     * @dev See {IStandardizedYield-accruedRewards}\n     */\n    function accruedRewards(address user)\n        external\n        view\n        virtual\n        override\n        returns (uint256[] memory rewardAmounts)\n    {\n        address[] memory rewardTokens = _getRewardTokens();\n        rewardAmounts = new uint256[](rewardTokens.length);\n        for (uint256 i = 0; i < rewardTokens.length; ) {\n            rewardAmounts[i] = userReward[rewardTokens[i]][user].accrued;\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    function rewardIndexesCurrent()\n        external\n        override\n        nonReentrant\n        returns (uint256[] memory indexes)\n    {\n        _updateRewardIndex();\n        return rewardIndexesStored();\n    }\n\n    function rewardIndexesStored()\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory indexes)\n    {\n        address[] memory rewardTokens = _getRewardTokens();\n        indexes = new uint256[](rewardTokens.length);\n        for (uint256 i = 0; i < rewardTokens.length; ) {\n            indexes[i] = rewardState[rewardTokens[i]].index;\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /**\n     * @notice returns the total number of reward shares\n     * @dev this is simply the total supply of shares, as rewards shares are equivalent to SY shares\n     */\n    function _rewardSharesTotal() internal view virtual override returns (uint256) {\n        return totalSupply();\n    }\n\n    /**\n     * @notice returns the reward shares of (`user`)\n     * @dev this is simply the SY balance of (`user`), as rewards shares are equivalent to SY shares\n     */\n    function _rewardSharesUser(address user) internal view virtual override returns (uint256) {\n        return balanceOf(user);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            TRANSFER HOOKS\n    //////////////////////////////////////////////////////////////*/\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256\n    ) internal virtual override whenNotPaused {\n        _updateAndDistributeRewardsForTwo(from, to);\n    }\n}\n"

    },

    "contracts/pendle/contracts/interfaces/Balancer/IAsset.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\ninterface IAsset {}\n"

    },

    "contracts/pendle/contracts/interfaces/Balancer/IBalancerFees.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\ninterface IBalancerFees {\n    function getSwapFeePercentage() external view returns (uint256);\n}\n"

    },

    "contracts/pendle/contracts/interfaces/Balancer/IBalancerStablePreview.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"./IVault.sol\";\n\ninterface IBalancerStablePreview {\n    function joinPoolPreview(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        IVault.JoinPoolRequest memory request,\n        bytes memory data\n    ) external view returns (uint256 amountBptOut);\n\n    function exitPoolPreview(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        IVault.ExitPoolRequest memory request,\n        bytes memory data\n    ) external view returns (uint256 amountTokenOut);\n}\n"

    },

    "contracts/pendle/contracts/interfaces/Balancer/IBasePool.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IBasePool is IERC20 {\n    function onJoinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) external returns (uint256[] memory amountsIn, uint256[] memory dueProtocolFeeAmounts);\n\n    function onExitPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) external returns (uint256[] memory amountsOut, uint256[] memory dueProtocolFeeAmounts);\n\n    function getPoolId() external view returns (bytes32);\n\n    function getSwapFeePercentage() external view returns (uint256);\n}\n"

    },

    "contracts/pendle/contracts/interfaces/Balancer/IMetaStablePool.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"./IBasePool.sol\";\n\ninterface IMetaStablePool is IBasePool {\n    function getLastInvariant()\n        external\n        view\n        returns (uint256 lastInvariant, uint256 lastInvariantAmp);\n\n    function getAmplificationParameter()\n        external\n        view\n        returns (uint256 value, bool isUpdating, uint256 precision);\n\n    function getSwapFeePercentage() external view returns (uint256);\n\n    function getPriceRateCache(\n        IERC20 token\n    ) external view returns (uint256 rate, uint256 duration, uint256 expires);\n}\n"

    },

    "contracts/pendle/contracts/interfaces/Balancer/IRateProvider.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\ninterface IRateProvider {\n    function getRate() external view returns (uint256);\n}\n"

    },

    "contracts/pendle/contracts/interfaces/Balancer/IVault.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./IAsset.sol\";\n\ninterface IVault {\n    enum UserBalanceOpKind {\n        DEPOSIT_INTERNAL,\n        WITHDRAW_INTERNAL,\n        TRANSFER_INTERNAL,\n        TRANSFER_EXTERNAL\n    }\n\n    struct UserBalanceOp {\n        UserBalanceOpKind kind;\n        IAsset asset;\n        uint256 amount;\n        address sender;\n        address payable recipient;\n    }\n\n    struct JoinPoolRequest {\n        address[] assets;\n        uint256[] maxAmountsIn;\n        bytes userData;\n        bool fromInternalBalance;\n    }\n\n    function joinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        JoinPoolRequest memory request\n    ) external payable;\n\n    struct ExitPoolRequest {\n        address[] assets;\n        uint256[] minAmountsOut;\n        bytes userData;\n        bool toInternalBalance;\n    }\n\n    function exitPool(\n        bytes32 poolId,\n        address sender,\n        address payable recipient,\n        ExitPoolRequest memory request\n    ) external;\n\n    enum SwapKind {\n        GIVEN_IN,\n        GIVEN_OUT\n    }\n\n    struct SingleSwap {\n        bytes32 poolId;\n        SwapKind kind;\n        IAsset assetIn;\n        IAsset assetOut;\n        uint256 amount;\n        bytes userData;\n    }\n\n    struct FundManagement {\n        address sender;\n        bool fromInternalBalance;\n        address payable recipient;\n        bool toInternalBalance;\n    }\n\n    function swap(\n        SingleSwap memory singleSwap,\n        FundManagement memory funds,\n        uint256 limit,\n        uint256 deadline\n    ) external payable returns (uint256);\n\n    function getPoolTokens(bytes32 poolId)\n        external\n        view\n        returns (\n            IERC20[] memory tokens,\n            uint256[] memory balances,\n            uint256 lastChangeBlock\n        );\n\n    function WETH() external view returns (IERC20);\n\n    function getPool(bytes32 poolId) external view returns (address, uint8);\n\n    function getProtocolFeesCollector() external view returns (address);\n}\n"

    },

    "contracts/pendle/contracts/interfaces/ConvexCurve/IBooster.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\ninterface IBooster {\n    function crv() external view returns (address);\n\n    function poolLength() external view returns (uint256);\n\n    function poolInfo(\n        uint256\n    ) external view returns (address lpToken, address, address, address, address, bool);\n\n    function deposit(uint256 _pid, uint256 _amount, bool _stake) external returns (bool);\n\n    function depositAll(uint256 _pid, bool _stake) external returns (bool);\n\n    function withdraw(uint256 _pid, uint256 _amount) external returns (bool);\n\n    function withdrawAll(uint256 _pid) external returns (bool);\n}\n"

    },

    "contracts/pendle/contracts/interfaces/ConvexCurve/IRewards.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\ninterface IRewards {\n    function operator() external view returns (address);\n\n    function stake(address, uint256) external;\n\n    function stakeFor(address, uint256) external;\n\n    function withdraw(uint256, bool) external returns (bool);\n\n    function withdrawAndUnwrap(uint256, bool) external returns (bool);\n\n    function exit(address) external;\n\n    function getReward(address /*_account*/, bool /*_claimExtras*/) external;\n\n    function getReward() external;\n\n    function queueNewRewards(uint256) external;\n\n    function notifyRewardAmount(uint256) external;\n\n    function addExtraReward(address) external;\n\n    function rewardToken() external returns (address);\n\n    function rewardPerToken() external returns (uint256);\n\n    function rewardPerTokenStored() external view returns (uint256);\n\n    function extraRewardsLength() external view returns (uint256);\n\n    function extraRewards(uint256) external returns (address);\n\n    function stakingToken() external returns (address);\n\n    function lastTimeRewardApplicable() external view returns (uint256);\n}\n"

    },

    "contracts/pendle/contracts/interfaces/IRewardManager.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.17;\n\ninterface IRewardManager {\n    function userReward(\n        address token,\n        address user\n    ) external view returns (uint128 index, uint128 accrued);\n}\n"

    },

    "contracts/pendle/contracts/interfaces/IStandardizedYield.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\n\npragma solidity 0.8.17;\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\ninterface IStandardizedYield is IERC20Metadata {\n    /// @dev Emitted when any base tokens is deposited to mint shares\n    event Deposit(\n        address indexed caller,\n        address indexed receiver,\n        address indexed tokenIn,\n        uint256 amountDeposited,\n        uint256 amountSyOut\n    );\n\n    /// @dev Emitted when any shares are redeemed for base tokens\n    event Redeem(\n        address indexed caller,\n        address indexed receiver,\n        address indexed tokenOut,\n        uint256 amountSyToRedeem,\n        uint256 amountTokenOut\n    );\n\n    /// @dev check `assetInfo()` for more information\n    enum AssetType {\n        TOKEN,\n        LIQUIDITY\n    }\n\n    /// @dev Emitted when (`user`) claims their rewards\n    event ClaimRewards(address indexed user, address[] rewardTokens, uint256[] rewardAmounts);\n\n    /**\n     * @notice mints an amount of shares by depositing a base token.\n     * @param receiver shares recipient address\n     * @param tokenIn address of the base tokens to mint shares\n     * @param amountTokenToDeposit amount of base tokens to be transferred from (`msg.sender`)\n     * @param minSharesOut reverts if amount of shares minted is lower than this\n     * @return amountSharesOut amount of shares minted\n     * @dev Emits a {Deposit} event\n     *\n     * Requirements:\n     * - (`tokenIn`) must be a valid base token.\n     */\n    function deposit(\n        address receiver,\n        address tokenIn,\n        uint256 amountTokenToDeposit,\n        uint256 minSharesOut\n    ) external payable returns (uint256 amountSharesOut);\n\n    /**\n     * @notice redeems an amount of base tokens by burning some shares\n     * @param receiver recipient address\n     * @param amountSharesToRedeem amount of shares to be burned\n     * @param tokenOut address of the base token to be redeemed\n     * @param minTokenOut reverts if amount of base token redeemed is lower than this\n     * @param burnFromInternalBalance if true, burns from balance of `address(this)`, otherwise burns from `msg.sender`\n     * @return amountTokenOut amount of base tokens redeemed\n     * @dev Emits a {Redeem} event\n     *\n     * Requirements:\n     * - (`tokenOut`) must be a valid base token.\n     */\n    function redeem(\n        address receiver,\n        uint256 amountSharesToRedeem,\n        address tokenOut,\n        uint256 minTokenOut,\n        bool burnFromInternalBalance\n    ) external returns (uint256 amountTokenOut);\n\n    /**\n     * @notice exchangeRate * syBalance / 1e18 must return the asset balance of the account\n     * @notice vice-versa, if a user uses some amount of tokens equivalent to X asset, the amount of sy\n     he can mint must be X * exchangeRate / 1e18\n     * @dev SYUtils's assetToSy & syToAsset should be used instead of raw multiplication\n     & division\n     */\n    function exchangeRate() external view returns (uint256 res);\n\n    /**\n     * @notice claims reward for (`user`)\n     * @param user the user receiving their rewards\n     * @return rewardAmounts an array of reward amounts in the same order as `getRewardTokens`\n     * @dev\n     * Emits a `ClaimRewards` event\n     * See {getRewardTokens} for list of reward tokens\n     */\n    function claimRewards(address user) external returns (uint256[] memory rewardAmounts);\n\n    /**\n     * @notice get the amount of unclaimed rewards for (`user`)\n     * @param user the user to check for\n     * @return rewardAmounts an array of reward amounts in the same order as `getRewardTokens`\n     */\n    function accruedRewards(address user) external view returns (uint256[] memory rewardAmounts);\n\n    function rewardIndexesCurrent() external returns (uint256[] memory indexes);\n\n    function rewardIndexesStored() external view returns (uint256[] memory indexes);\n\n    /**\n     * @notice returns the list of reward token addresses\n     */\n    function getRewardTokens() external view returns (address[] memory);\n\n    /**\n     * @notice returns the address of the underlying yield token\n     */\n    function yieldToken() external view returns (address);\n\n    /**\n     * @notice returns all tokens that can mint this SY\n     */\n    function getTokensIn() external view returns (address[] memory res);\n\n    /**\n     * @notice returns all tokens that can be redeemed by this SY\n     */\n    function getTokensOut() external view returns (address[] memory res);\n\n    function isValidTokenIn(address token) external view returns (bool);\n\n    function isValidTokenOut(address token) external view returns (bool);\n\n    function previewDeposit(\n        address tokenIn,\n        uint256 amountTokenToDeposit\n    ) external view returns (uint256 amountSharesOut);\n\n    function previewRedeem(\n        address tokenOut,\n        uint256 amountSharesToRedeem\n    ) external view returns (uint256 amountTokenOut);\n\n    /**\n     * @notice This function contains information to interpret what the asset is\n     * @return assetType the type of the asset (0 for ERC20 tokens, 1 for AMM liquidity tokens)\n     * @return assetAddress the address of the asset\n     * @return assetDecimals the decimals of the asset\n     */\n    function assetInfo()\n        external\n        view\n        returns (AssetType assetType, address assetAddress, uint8 assetDecimals);\n}\n"

    },

    "contracts/pendle/contracts/interfaces/IWETH.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n/*\n * MIT License\n * ===========\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n */\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IWETH is IERC20 {\n    event Deposit(address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n"

    }

  },

  "settings": {

    "optimizer": {

      "enabled": true,

      "runs": 1000000

    },

    "viaIR": true,

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "libraries": {}

  }

}}