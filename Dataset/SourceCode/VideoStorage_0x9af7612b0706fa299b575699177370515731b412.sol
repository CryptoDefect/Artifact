{{

  "language": "Solidity",

  "sources": {

    "lib/solady/src/utils/Base64.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library to encode strings in Base64.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Base64.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Base64.sol)\n/// @author Modified from (https://github.com/Brechtpd/base64/blob/main/base64.sol) by Brecht Devos - <brecht@loopring.org>.\nlibrary Base64 {\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// See: https://datatracker.ietf.org/doc/html/rfc4648\n    /// @param fileSafe  Whether to replace '+' with '-' and '/' with '_'.\n    /// @param noPadding Whether to strip away the padding.\n    function encode(bytes memory data, bool fileSafe, bool noPadding)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let dataLength := mload(data)\n\n            if dataLength {\n                // Multiply by 4/3 rounded up.\n                // The `shl(2, ...)` is equivalent to multiplying by 4.\n                let encodedLength := shl(2, div(add(dataLength, 2), 3))\n\n                // Set `result` to point to the start of the free memory.\n                result := mload(0x40)\n\n                // Store the table into the scratch space.\n                // Offsetted by -1 byte so that the `mload` will load the character.\n                // We will rewrite the free memory pointer at `0x40` later with\n                // the allocated size.\n                // The magic constant 0x0230 will translate \"-_\" + \"+/\".\n                mstore(0x1f, \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\")\n                mstore(0x3f, sub(\"ghijklmnopqrstuvwxyz0123456789-_\", mul(iszero(fileSafe), 0x0230)))\n\n                // Skip the first slot, which stores the length.\n                let ptr := add(result, 0x20)\n                let end := add(ptr, encodedLength)\n\n                // Run over the input, 3 bytes at a time.\n                for {} 1 {} {\n                    data := add(data, 3) // Advance 3 bytes.\n                    let input := mload(data)\n\n                    // Write 4 bytes. Optimized for fewer stack operations.\n                    mstore8(0, mload(and(shr(18, input), 0x3F)))\n                    mstore8(1, mload(and(shr(12, input), 0x3F)))\n                    mstore8(2, mload(and(shr(6, input), 0x3F)))\n                    mstore8(3, mload(and(input, 0x3F)))\n                    mstore(ptr, mload(0x00))\n\n                    ptr := add(ptr, 4) // Advance 4 bytes.\n\n                    if iszero(lt(ptr, end)) { break }\n                }\n\n                // Allocate the memory for the string.\n                // Add 31 and mask with `not(31)` to round the\n                // free memory pointer up the next multiple of 32.\n                mstore(0x40, and(add(end, 31), not(31)))\n\n                // Equivalent to `o = [0, 2, 1][dataLength % 3]`.\n                let o := div(2, mod(dataLength, 3))\n\n                // Offset `ptr` and pad with '='. We can simply write over the end.\n                mstore(sub(ptr, o), shl(240, 0x3d3d))\n                // Set `o` to zero if there is padding.\n                o := mul(iszero(iszero(noPadding)), o)\n                // Zeroize the slot after the string.\n                mstore(sub(ptr, o), 0)\n                // Write the length of the string.\n                mstore(result, sub(encodedLength, o))\n            }\n        }\n    }\n\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// Equivalent to `encode(data, false, false)`.\n    function encode(bytes memory data) internal pure returns (string memory result) {\n        result = encode(data, false, false);\n    }\n\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// Equivalent to `encode(data, fileSafe, false)`.\n    function encode(bytes memory data, bool fileSafe)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = encode(data, fileSafe, false);\n    }\n\n    /// @dev Encodes base64 encoded `data`.\n    ///\n    /// Supports:\n    /// - RFC 4648 (both standard and file-safe mode).\n    /// - RFC 3501 (63: ',').\n    ///\n    /// Does not support:\n    /// - Line breaks.\n    ///\n    /// Note: For performance reasons,\n    /// this function will NOT revert on invalid `data` inputs.\n    /// Outputs for invalid inputs will simply be undefined behaviour.\n    /// It is the user's responsibility to ensure that the `data`\n    /// is a valid base64 encoded string.\n    function decode(string memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let dataLength := mload(data)\n\n            if dataLength {\n                let decodedLength := mul(shr(2, dataLength), 3)\n\n                for {} 1 {} {\n                    // If padded.\n                    if iszero(and(dataLength, 3)) {\n                        let t := xor(mload(add(data, dataLength)), 0x3d3d)\n                        // forgefmt: disable-next-item\n                        decodedLength := sub(\n                            decodedLength,\n                            add(iszero(byte(30, t)), iszero(byte(31, t)))\n                        )\n                        break\n                    }\n                    // If non-padded.\n                    decodedLength := add(decodedLength, sub(and(dataLength, 3), 1))\n                    break\n                }\n                result := mload(0x40)\n\n                // Write the length of the bytes.\n                mstore(result, decodedLength)\n\n                // Skip the first slot, which stores the length.\n                let ptr := add(result, 0x20)\n                let end := add(ptr, decodedLength)\n\n                // Load the table into the scratch space.\n                // Constants are optimized for smaller bytecode with zero gas overhead.\n                // `m` also doubles as the mask of the upper 6 bits.\n                let m := 0xfc000000fc00686c7074787c8084888c9094989ca0a4a8acb0b4b8bcc0c4c8cc\n                mstore(0x5b, m)\n                mstore(0x3b, 0x04080c1014181c2024282c3034383c4044484c5054585c6064)\n                mstore(0x1a, 0xf8fcf800fcd0d4d8dce0e4e8ecf0f4)\n\n                for {} 1 {} {\n                    // Read 4 bytes.\n                    data := add(data, 4)\n                    let input := mload(data)\n\n                    // Write 3 bytes.\n                    // forgefmt: disable-next-item\n                    mstore(ptr, or(\n                        and(m, mload(byte(28, input))),\n                        shr(6, or(\n                            and(m, mload(byte(29, input))),\n                            shr(6, or(\n                                and(m, mload(byte(30, input))),\n                                shr(6, mload(byte(31, input)))\n                            ))\n                        ))\n                    ))\n\n                    ptr := add(ptr, 3)\n\n                    if iszero(lt(ptr, end)) { break }\n                }\n\n                // Allocate the memory for the string.\n                // Add 31 and mask with `not(31)` to round the\n                // free memory pointer up the next multiple of 32.\n                mstore(0x40, and(add(end, 31), not(31)))\n                // Zeroize the slot after the bytes.\n                mstore(end, 0)\n                // Restore the zero slot.\n                mstore(0x60, 0)\n            }\n        }\n    }\n}\n"

    },

    "src/core/AuthGuard.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\nimport \"./Registry.sol\";\n\ncontract AuthGuard {\n    Registry internal registry;\n\n    constructor(address _registry) {\n        initializeAuthGuard(_registry);\n    }\n\n    function initializeAuthGuard(address _registry) public {\n        if (registry == Registry(address(0))) {\n            registry = Registry(_registry);\n        }\n    }\n\n    function isAuthorized(\n        address _user,\n        address _operator,\n        bytes4 _role\n    ) public view returns (bool) {\n        return registry.isAuthorized(_user, _operator, _role);\n    }\n\n    function isAuthorizedById(\n        uint64 _id,\n        bytes4 _role,\n        address _operator\n    ) public view returns (bool) {\n        return registry.isAuthorizedById(_id, _operator, _role);\n    }\n\n    function contractPermissions(address _contract) public view returns (bool) {\n        return registry.contractPermissions(_contract);\n    }\n\n    function getIdOwner(uint64 _id) public view returns (address) {\n        return registry.getIdOwner(_id);\n    }\n\n    function getStorageContract(uint64 _id) public view returns (address) {\n        return registry.getStorageContract(_id);\n    }\n\n    function getPlugin(uint64 _id) public view returns (address) {\n        return registry.getPlugin(_id);\n    }\n\n    function connectPluginContract(uint64 _id) internal {\n        return registry.connectPluginContract(_id);\n    }\n\n    function migratePluginContract(\n        uint64 _id,\n        address _newPluginContract\n    ) external returns (bool) {\n        return registry.migratePluginContract(_id, _newPluginContract);\n    }\n\n    function registerStorageContract(\n        address _owner,\n        uint8 _salt\n    ) internal returns (uint64) {\n        return registry.registerStorageContract(_owner, _salt);\n    }\n\n    function migrateStorageContract(\n        uint64 _id,\n        address _newStorageContract\n    ) internal returns (bool) {\n        return registry.migrateStorageContract(_id, _newStorageContract);\n    }\n\n    modifier onlyAdmin() {\n        require(registry.isAdmin(msg.sender), \"UNAUTHORIZED\");\n        _;\n    }\n\n    modifier onlyOperatorByUser(address _user) {\n        require(\n            registry.isAdmin(msg.sender) ||\n                registry.isOperator(_user, msg.sender),\n            \"UNAUTHORIZED\"\n        );\n        _;\n    }\n\n    modifier onlyAuthorizedByUser(address _user, bytes4 _role) {\n        require(\n            registry.isAuthorized(_user, msg.sender, _role),\n            \"UNAUTHORIZED\"\n        );\n        _;\n    }\n\n    modifier onlyAuthorizedById(uint64 _id, bytes4 _role) {\n        require(\n            registry.isAuthorizedById(_id, msg.sender, _role),\n            \"UNAUTHORIZED\"\n        );\n        _;\n    }\n\n    modifier onlyWhitelistedContract() {\n        require(\n            registry.isAdmin(msg.sender) ||\n                registry.contractPermissions(msg.sender),\n            \"UNAUTHORIZED\"\n        );\n        _;\n    }\n}\n"

    },

    "src/core/Registry.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\n// ████████████████████████████████████████████████████████████████████████████████\n// ████████████████████████████████████████████████████████████████████████████████\n// ████████████████████████████████████████████████████████████████████████████████\n// ████████████████████████████████████████████████████████████████████████████████\n// ████████████████████████████████████████████████████████████████████████████████\n// ████████████████████████████████████████████████████████████████████████████████\n// ████████████████████████████████▓▀██████████████████████████████████████████████\n// ██████████████████████████████████  ╙███████████████████████████████████████████\n// ███████████████████████████████████    ╙████████████████████████████████████████\n// ████████████████████████████████████      ╙▀████████████████████████████████████\n// ████████████████████████████████████▌        ╙▀█████████████████████████████████\n// ████████████████████████████████████▌           ╙███████████████████████████████\n// ████████████████████████████████████▌            ███████████████████████████████\n// ████████████████████████████████████▌         ▄█████████████████████████████████\n// ████████████████████████████████████       ▄████████████████████████████████████\n// ███████████████████████████████████▀   ,▄███████████████████████████████████████\n// ██████████████████████████████████▀ ,▄██████████████████████████████████████████\n// █████████████████████████████████▄▓█████████████████████████████████████████████\n// ████████████████████████████████████████████████████████████████████████████████\n// ████████████████████████████████████████████████████████████████████████████████\n// ████████████████████████████████████████████████████████████████████████████████\n// ████████████████████████████████████████████████████████████████████████████████\n// ████████████████████████████████████████████████████████████████████████████████\n// ████████████████████████████████████████████████████████████████████████████████\n\ncontract Registry {\n    bytes4 public constant REGISTER_STORAGE_ROLE =\n        bytes4(keccak256(\"REGISTER_STORAGE_ROLE\"));\n    bytes4 public constant REGISTER_PLUGIN_ROLE =\n        bytes4(keccak256(\"REGISTER_PLUGIN_ROLE\"));\n\n    mapping(address => bool) public adminPermissions; // only admins\n    mapping(address => bool) public contractPermissions; // trusted router contracts\n    mapping(address => mapping(address => bool)) public operatorPermissions; // operate on behalf of a certain user\n    mapping(address => mapping(address => mapping(bytes4 => bool)))\n        public rolePermissions;\n\n    uint64 immutable chainAndNetworkId;\n\n    mapping(uint64 => address) public storageContracts;\n    mapping(uint64 => address) public pluginContracts;\n    mapping(address => uint64) public ownerNonces;\n    mapping(uint64 => address) public idOwners;\n\n    event AdminPermissionChanged(address indexed admin, bool isAuthorized);\n    event ContractPermissionChanged(\n        address indexed contractAddress,\n        bool isAuthorized\n    );\n    event OperatorPermissionChanged(\n        address indexed user,\n        address indexed operator,\n        bool isAuthorized\n    );\n    event UserRoleChanged(\n        address indexed user,\n        address indexed operator,\n        bytes4 indexed role,\n        bool isAuthorized\n    );\n    event IdRegistered(\n        uint64 indexed id,\n        address indexed owner,\n        address indexed storageContract\n    );\n    event PluginConnected(uint64 indexed id, address indexed pluginContract);\n    event StorageContractMigrated(\n        uint64 indexed id,\n        address indexed oldStorageContract,\n        address indexed newStorageContract\n    );\n    event PluginContractMigrated(\n        uint64 indexed id,\n        address indexed oldPluginContract,\n        address indexed newPluginContract\n    );\n\n    constructor(address[] memory _initialAdmins) {\n        chainAndNetworkId = uint64(\n            uint16(bytes2(keccak256(abi.encodePacked(block.chainid))))\n        );\n        for (uint64 i = 0; i < _initialAdmins.length; ++i) {\n            adminPermissions[_initialAdmins[i]] = true;\n            emit AdminPermissionChanged(_initialAdmins[i], true);\n        }\n    }\n\n    /**\n     * @notice Set admini permissions\n     * @param _admin The address of the administrator\n     * @param _isAuthorized A boolean to indicate if the administrator is authorized\n     */\n    function setAdmin(address _admin, bool _isAuthorized) public onlyAdmins {\n        adminPermissions[_admin] = _isAuthorized;\n        emit AdminPermissionChanged(_admin, _isAuthorized);\n    }\n\n    /**\n     * @notice Set contract permissions\n     * @param _contract The address of the contract\n     * @param _isAuthorized A boolean to indicate if the contract is authorized\n     */\n    function setContractPermission(\n        address _contract,\n        bool _isAuthorized\n    ) public onlyAdmins {\n        contractPermissions[_contract] = _isAuthorized;\n        emit ContractPermissionChanged(_contract, _isAuthorized);\n    }\n\n    /**\n     * @notice Set operator permissions\n     * @param _operator The address of the operator\n     * @param _isAuthorized A boolean to indicate if the operator is authorized\n     */\n    function setOperatorPermission(\n        address _operator,\n        bool _isAuthorized\n    ) public {\n        operatorPermissions[msg.sender][_operator] = _isAuthorized;\n        emit OperatorPermissionChanged(msg.sender, _operator, _isAuthorized);\n    }\n\n    /**\n     * @notice Set user role permissions\n     * @param _operator The address of the user\n     * @param _role The role associated with the user\n     * @param _isAuthorized A boolean to indicate if the user role is authorized\n     */\n    function setUserRolePermission(\n        address _operator,\n        bytes4 _role,\n        bool _isAuthorized\n    ) public {\n        rolePermissions[msg.sender][_operator][_role] = _isAuthorized;\n        emit UserRoleChanged(msg.sender, _operator, _role, _isAuthorized);\n    }\n\n    /**\n     * @notice Set user role permissions for an operator in batch\n     * @param _user The address of the user for whom the roles are being set\n     * @param _operator The address of the operator being granted the roles\n     * @param _roles The array of roles associated with the user and operator\n     * @param _isAuthorized A boolean to indicate if the user roles are authorized\n     */\n    function setBatchUserRolePermissions(\n        address _user,\n        address _operator,\n        bytes4[] memory _roles,\n        bool _isAuthorized\n    ) public {\n        for (uint256 i = 0; i < _roles.length; ++i) {\n            rolePermissions[_user][_operator][_roles[i]] = _isAuthorized;\n            emit UserRoleChanged(_user, _operator, _roles[i], _isAuthorized);\n        }\n    }\n\n    /**\n     * @notice Check if a user is an admin\n     * @param _user The address of the user\n     * @return A boolean indicating if the user is an admin\n     */\n    function isAdmin(address _user) public view returns (bool) {\n        return adminPermissions[_user];\n    }\n\n    /**\n     * @notice Check if an address is an operator for a user\n     * @param _user The address of the user\n     * @param _operator The address of the operator\n     * @return A boolean indicating if the address is an operator for the user\n     */\n    function isOperator(\n        address _user,\n        address _operator\n    ) public view returns (bool) {\n        return operatorPermissions[_user][_operator];\n    }\n\n    /**\n     * @notice Check if an operator is authorized for a specific role\n     * @param _user The address of the user\n     * @param _operator The address of the operator\n     * @param _role The role to check for authorization\n     * @return A boolean indicating if the operator is authorized for the specified role\n     */\n    function isAuthorized(\n        address _user,\n        address _operator,\n        bytes4 _role\n    ) public view returns (bool) {\n        if (adminPermissions[_operator] || _user == _operator) {\n            return true;\n        }\n        if (operatorPermissions[_user][_operator]) {\n            return true;\n        }\n        if (rolePermissions[_user][_operator][_role]) {\n            return true;\n        }\n        if (contractPermissions[_operator]) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * @notice Check if an operator is authorized for a specific role by ID\n     * @param _id The ID to check for authorization\n     * @param _operator The address of the operator\n     * @param _role The role to check for authorization\n     * @return A boolean indicating if the operator is authorized for the specified role by ID\n     */\n    function isAuthorizedById(\n        uint64 _id,\n        address _operator,\n        bytes4 _role\n    ) public view returns (bool) {\n        address _user = idOwners[_id];\n        return isAuthorized(_user, _operator, _role);\n    }\n\n    /**\n     * @notice Check if an operator is authorized for an array of specific roles\n     * @param _user The address of the user\n     * @param _operator The address of the operator\n     * @param _roles The array of roles to check for authorization\n     * @return A boolean indicating if the operator is authorized for all specified roles\n     */\n    function isAuthorizedForRoles(\n        address _user,\n        address _operator,\n        bytes4[] memory _roles\n    ) public view returns (bool) {\n        if (adminPermissions[_operator] || _user == _operator) {\n            return true;\n        }\n        if (operatorPermissions[_user][_operator]) {\n            return true;\n        }\n        if (contractPermissions[_operator]) {\n            return true;\n        }\n        for (uint256 i = 0; i < _roles.length; ++i) {\n            if (!rolePermissions[_user][_operator][_roles[i]]) {\n                return false;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @notice Get the owner of an ID\n     * @param _id The ID to get the owner of\n     * @return The address of the owner\n     */\n    function getIdOwner(uint64 _id) external view returns (address) {\n        return idOwners[_id];\n    }\n\n    /**\n     * @notice Get the storage contract for an ID\n     * @param _id The ID to get the storage contract of\n     * @return The address of the storage contract\n     */\n    function getStorageContract(uint64 _id) external view returns (address) {\n        return storageContracts[_id];\n    }\n\n    /**\n     * @notice Get the plugin for an ID\n     * @param _id The ID to get the plugin of\n     * @return The address of the plugin\n     */\n    function getPlugin(uint64 _id) external view returns (address) {\n        return pluginContracts[_id];\n    }\n\n    /**\n     * @notice Register a storage contract\n     * @param _owner The address of the storage contract owner\n     * @param _salt The salt for generating the ID\n     * @return The ID of the registered storage contract\n     */\n    function registerStorageContract(\n        address _owner,\n        uint8 _salt\n    )\n        external\n        onlyAuthorizedByUser(_owner, REGISTER_STORAGE_ROLE)\n        returns (uint64)\n    {\n        uint64 id = calculateIdWithSalt(_owner, _salt);\n        require(storageContracts[id] == address(0), \"ID_ALREADY_REGISTERED\");\n        ownerNonces[_owner] += 1;\n        storageContracts[id] = msg.sender;\n        idOwners[id] = _owner;\n        emit IdRegistered(id, _owner, msg.sender);\n        return id;\n    }\n\n    /**\n     * @notice Connect a plugin contract to an ID\n     * @param _id The ID to connect the plugin contract to\n     */\n    function connectPluginContract(\n        uint64 _id\n    ) external onlyAuthorizedByUser(idOwners[_id], REGISTER_PLUGIN_ROLE) {\n        require(storageContracts[_id] != address(0), \"ID_NOT_REGISTERED\");\n        require(\n            pluginContracts[_id] == address(0),\n            \"PLUGIN_ALREADY_REGISTERED\"\n        );\n        pluginContracts[_id] = msg.sender;\n        emit PluginConnected(_id, msg.sender);\n    }\n\n    /**\n     * @notice Migrate a storage contract to a new address\n     * @param _id The ID of the storage contract to migrate\n     * @param _newStorageContract The address of the new storage contract\n     * @return A boolean indicating if the migration was successful\n     */\n    function migrateStorageContract(\n        uint64 _id,\n        address _newStorageContract\n    ) external onlyStorageContracts(_id) returns (bool) {\n        address oldStorageContract = storageContracts[_id];\n        require(oldStorageContract != address(0), \"ID_NOT_REGISTERED\");\n        storageContracts[_id] = _newStorageContract;\n\n        emit StorageContractMigrated(\n            _id,\n            oldStorageContract,\n            _newStorageContract\n        );\n\n        return true;\n    }\n\n    /**\n     * @notice Migrate a plugin contract to a new address\n     * @param _id The ID of the plugin contract to migrate\n     * @param _newPluginContract The address of the new plugin contract\n     * @return A boolean indicating if the migration was successful\n     */\n    function migratePluginContract(\n        uint64 _id,\n        address _newPluginContract\n    ) external onlyPluginContracts(_id) returns (bool) {\n        address oldPluginContract = pluginContracts[_id];\n        require(oldPluginContract != address(0), \"ID_NOT_CONNECTED_TO_PLUGIN\");\n        pluginContracts[_id] = _newPluginContract;\n\n        emit PluginContractMigrated(_id, oldPluginContract, _newPluginContract);\n\n        return true;\n    }\n\n    /**\n     * @notice Calculate the ID with the provided owner and salt\n     * @param _owner The address of the owner\n     * @param _salt The salt for generating the ID\n     * @return The calculated ID\n     */\n    function calculateIdWithSalt(\n        address _owner,\n        uint8 _salt\n    ) public view returns (uint64) {\n        return\n            (uint64(\n                bytes8(\n                    keccak256(\n                        abi.encodePacked(_owner, ownerNonces[_owner], _salt)\n                    )\n                )\n            ) << 16) | chainAndNetworkId;\n    }\n\n    /**\n     * @notice Calculate the ID with the provided owner, nonce, and salt\n     * @param _owner The address of the owner\n     * @param _nonce The nonce for generating the ID\n     * @param _salt The salt for generating the ID\n     * @return The calculated ID\n     */\n    function calculateIdWithSaltAndNonce(\n        address _owner,\n        uint64 _nonce,\n        uint8 _salt\n    ) public view returns (uint64) {\n        return\n            (uint64(\n                bytes8(keccak256(abi.encodePacked(_owner, _nonce, _salt)))\n            ) << 16) | chainAndNetworkId;\n    }\n\n    modifier onlyAdmins() {\n        require(adminPermissions[msg.sender], \"NOT_AN_ADMIN\");\n        _;\n    }\n\n    modifier onlyOperators(address _user) {\n        require(\n            adminPermissions[msg.sender] ||\n                operatorPermissions[_user][msg.sender],\n            \"NOT_AN_OPERATOR\"\n        );\n        _;\n    }\n\n    modifier onlyStorageContracts(uint64 _id) {\n        require(\n            isAdmin(msg.sender) || storageContracts[_id] == msg.sender,\n            \"NOT_A_STORAGE_CONTRACT\"\n        );\n        _;\n    }\n\n    modifier onlyPluginContracts(uint64 _id) {\n        require(\n            isAdmin(msg.sender) || pluginContracts[_id] == msg.sender,\n            \"NOT_A_PLUGIN_CONTRACT\"\n        );\n        _;\n    }\n\n    modifier onlyAuthorizedByUser(address _user, bytes4 _role) {\n        require(isAuthorized(_user, msg.sender, _role), \"UNAUTHORIZED\");\n        _;\n    }\n}\n"

    },

    "src/storage/VideoStorage.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\n// ████████████████████████████████████████████████████████████████████████████████\n// ████████████████████████████████████████████████████████████████████████████████\n// ████████████████████████████████████████████████████████████████████████████████\n// ████████████████████████████████████████████████████████████████████████████████\n// ████████████████████████████████████████████████████████████████████████████████\n// ████████████████████████████████████████████████████████████████████████████████\n// ████████████████████████████████▓▀██████████████████████████████████████████████\n// ██████████████████████████████████  ╙███████████████████████████████████████████\n// ███████████████████████████████████    ╙████████████████████████████████████████\n// ████████████████████████████████████      ╙▀████████████████████████████████████\n// ████████████████████████████████████▌        ╙▀█████████████████████████████████\n// ████████████████████████████████████▌           ╙███████████████████████████████\n// ████████████████████████████████████▌            ███████████████████████████████\n// ████████████████████████████████████▌         ▄█████████████████████████████████\n// ████████████████████████████████████       ▄████████████████████████████████████\n// ███████████████████████████████████▀   ,▄███████████████████████████████████████\n// ██████████████████████████████████▀ ,▄██████████████████████████████████████████\n// █████████████████████████████████▄▓█████████████████████████████████████████████\n// ████████████████████████████████████████████████████████████████████████████████\n// ████████████████████████████████████████████████████████████████████████████████\n// ████████████████████████████████████████████████████████████████████████████████\n// ████████████████████████████████████████████████████████████████████████████████\n// ████████████████████████████████████████████████████████████████████████████████\n// ████████████████████████████████████████████████████████████████████████████████\n\nimport {AuthGuard} from \"../core/AuthGuard.sol\";\nimport {Base64} from \"solady/utils/Base64.sol\";\n\ncontract VideoStorage is AuthGuard {\n    bytes4 public constant VIDEO_CREATE_ROLE =\n        bytes4(keccak256(\"VIDEO_CREATE_ROLE\"));\n    bytes4 public constant VIDEO_UPDATE_ROLE =\n        bytes4(keccak256(\"VIDEO_UPDATE_ROLE\"));\n\n    uint8 constant TAGS_LIMIT = 7;\n\n    constructor(address _registry) AuthGuard(_registry) {}\n\n    event VideoCreated(VideoCreatedEventParams videoCreatedEventParams);\n    event TitleUpdated(uint64 indexed id, string newTitle);\n    event ThumbnailUpdated(uint64 indexed id, string newThumbnailURL);\n    event VideoUpdated(uint64 indexed id, string newVideoURL);\n    event DescriptionUpdated(uint64 indexed id, string newDescription);\n    event PackedDataUpdated(uint64 indexed id, bytes32 newPackedData);\n    event SymbolUpdated(uint64 indexed id, string newSymbol);\n    event FrozenStatusUpdated(uint64 indexed id, bool newFrozenStatus);\n    event NSFWStatusUpdated(uint64 indexed id, bool newFrozenStatus);\n    event LicenseTypeUpdated(uint64 indexed id, uint8 newLicenseType);\n    event TagsUpdated(uint64 indexed id, string[] newTags);\n\n    mapping(uint64 => VideoMetadata) public videos;\n\n    struct VideoMetadata {\n        // title is limited to 96 characters\n        bytes32 title1; // first data slot\n        bytes32 title2; // second data slot\n        bytes32 title3; // third data slot\n        // arweave id efficiently packed\n        bytes32 arweaveThumbnail;\n        // arweave id efficiently packed\n        bytes32 arweaveVideo;\n        // packed data combining symbol, created time, flags, and category\n        bytes32 packedData; // Combines symbol, created, flags, and category\n        // dynamic value at the end for efficiency\n        string description;\n    }\n\n    struct CreateParams {\n        address owner;\n        string title; // can only be 96 characters\n        string description;\n        string thumbnailURL; // just the arweave ID nothing else (no https://arweave.net/)\n        string videoURL; // just the arweave ID nothing else (no https://arweave.net/)\n        string[] tags;\n        string symbol; // 6 characters or less\n        bool frozen;\n        bool nsfw;\n        uint8 licenseType; // license type\n        uint8 salt;\n    }\n\n    struct VideoCreatedEventParams {\n        uint64 id;\n        string title;\n        string description;\n        string thumbnailURL;\n        string videoURL;\n        string[] tags;\n        string symbol;\n        bool frozen;\n        bool nsfw;\n        uint8 licenseType;\n        uint64 created;\n    }\n\n    function create(\n        CreateParams memory params\n    )\n        public\n        onlyAuthorizedByUser(params.owner, VIDEO_CREATE_ROLE)\n        returns (uint64)\n    {\n        uint64 id = registerStorageContract(params.owner, params.salt);\n        require(getCreated(id) == 0, \"VIDEO_ALREADY_EXISTS\");\n        (\n            bytes32 title1,\n            bytes32 title2,\n            bytes32 title3\n        ) = calculateTitleBytes32(bytes(params.title));\n\n        bytes32 packedData = calculatePackedData(\n            PackedDataParams({\n                symbol: params.symbol,\n                created: uint64(block.timestamp),\n                hidden: false,\n                frozen: params.frozen,\n                licenseType: params.licenseType,\n                nsfw: params.nsfw,\n                tagHashes: calculateTagHashes(params.tags)\n            })\n        );\n\n        videos[id] = VideoMetadata(\n            title1,\n            title2,\n            title3,\n            arweaveIdToBytes32(params.thumbnailURL),\n            arweaveIdToBytes32(params.videoURL),\n            packedData,\n            params.description\n        );\n\n        emit VideoCreated(\n            VideoCreatedEventParams(\n                id,\n                params.title,\n                params.description,\n                params.thumbnailURL,\n                params.videoURL,\n                params.tags,\n                params.symbol,\n                params.frozen,\n                params.nsfw,\n                params.licenseType,\n                uint64(block.timestamp)\n            )\n        );\n\n        return id;\n    }\n\n    modifier validUpdate(uint64 _id) {\n        require(getCreated(_id) != 0, \"VIDEO_NOT_CREATED\");\n        require(!isFrozen(_id), \"VIDEO_DATA_FROZEN\");\n        _;\n    }\n\n    function updateTitle(\n        uint64 _id,\n        string memory _newTitle\n    ) public validUpdate(_id) onlyAuthorizedById(_id, VIDEO_UPDATE_ROLE) {\n        (\n            bytes32 title1,\n            bytes32 title2,\n            bytes32 title3\n        ) = calculateTitleBytes32(bytes(_newTitle));\n        require(\n            title1 != 0x0 || title2 != 0x0 || title3 != 0x0,\n            \"INVALID_TITLE\"\n        );\n        videos[_id].title1 = title1;\n        videos[_id].title2 = title2;\n        videos[_id].title3 = title3;\n\n        // Emit TitleUpdated event\n        emit TitleUpdated(_id, _newTitle);\n    }\n\n    function updateThumbnail(\n        uint64 _id,\n        string memory _newThumbnailURL\n    ) public validUpdate(_id) onlyAuthorizedById(_id, VIDEO_UPDATE_ROLE) {\n        bytes memory input = Base64.decode(_newThumbnailURL);\n        bytes32 _thumbnail;\n        assembly {\n            _thumbnail := mload(add(input, 32))\n        }\n        require(_thumbnail != 0x0, \"INVALID_THUMBNAIL\");\n        videos[_id].arweaveThumbnail = _thumbnail;\n\n        // Emit ThumbnailUpdated event\n        emit ThumbnailUpdated(_id, _newThumbnailURL);\n    }\n\n    function updateVideo(\n        uint64 _id,\n        string memory _newVideoURL\n    ) public validUpdate(_id) onlyAuthorizedById(_id, VIDEO_UPDATE_ROLE) {\n        bytes memory input = Base64.decode(_newVideoURL);\n        bytes32 _video;\n        assembly {\n            _video := mload(add(input, 32))\n        }\n        require(_video != 0x0, \"INVALID_VIDEO\");\n        videos[_id].arweaveVideo = _video;\n\n        // Emit VideoUpdated event\n        emit VideoUpdated(_id, _newVideoURL);\n    }\n\n    function updateDescription(\n        uint64 _id,\n        string memory _newDescription\n    ) public validUpdate(_id) onlyAuthorizedById(_id, VIDEO_UPDATE_ROLE) {\n        require(bytes(_newDescription).length > 0, \"INVALID_DESCRIPTION\");\n        videos[_id].description = _newDescription;\n\n        // Emit DescriptionUpdated event\n        emit DescriptionUpdated(_id, _newDescription);\n    }\n\n    function updatePackedData(\n        uint64 _id,\n        bytes16 _newPackedData\n    ) public validUpdate(_id) onlyAuthorizedById(_id, VIDEO_UPDATE_ROLE) {\n        require(_newPackedData != 0x0, \"INVALID_COMBINED_FIELD\");\n        videos[_id].packedData = _newPackedData;\n\n        // Emit PackedDataUpdated event\n        emit PackedDataUpdated(_id, _newPackedData);\n    }\n\n    function updateSymbol(\n        uint64 _id,\n        string memory _newSymbol\n    ) public validUpdate(_id) onlyAuthorizedById(_id, VIDEO_UPDATE_ROLE) {\n        bytes32 newPackedData = calculatePackedData(\n            PackedDataParams({\n                symbol: _newSymbol,\n                created: getCreated(_id),\n                hidden: isHidden(_id),\n                frozen: isFrozen(_id),\n                licenseType: getLicenseType(_id),\n                nsfw: isNSFW(_id),\n                tagHashes: getTags(_id)\n            })\n        );\n\n        videos[_id].packedData = newPackedData;\n\n        // Emit SymbolUpdated event\n        emit SymbolUpdated(_id, _newSymbol);\n    }\n\n    function updateFrozenStatus(\n        uint64 _id,\n        bool _newFrozenStatus\n    ) public validUpdate(_id) onlyAuthorizedById(_id, VIDEO_UPDATE_ROLE) {\n        bytes32 newPackedData = calculatePackedData(\n            PackedDataParams({\n                symbol: getSymbol(_id),\n                created: getCreated(_id),\n                hidden: isHidden(_id),\n                frozen: _newFrozenStatus,\n                licenseType: getLicenseType(_id),\n                nsfw: isNSFW(_id),\n                tagHashes: getTags(_id)\n            })\n        );\n\n        videos[_id].packedData = newPackedData;\n\n        // Emit FrozenStatusUpdated event\n        emit FrozenStatusUpdated(_id, _newFrozenStatus);\n    }\n\n    function updateLicenseType(\n        uint64 _id,\n        uint8 _newLicenseType\n    ) public validUpdate(_id) onlyAuthorizedById(_id, VIDEO_UPDATE_ROLE) {\n        bytes32 newPackedData = calculatePackedData(\n            PackedDataParams({\n                symbol: getSymbol(_id),\n                created: getCreated(_id),\n                hidden: isHidden(_id),\n                frozen: isFrozen(_id),\n                licenseType: _newLicenseType,\n                nsfw: isNSFW(_id),\n                tagHashes: getTags(_id)\n            })\n        );\n\n        videos[_id].packedData = newPackedData;\n\n        // Emit LicenseTypeUpdated event\n        emit LicenseTypeUpdated(_id, _newLicenseType);\n    }\n\n    function updateNSFWStatus(\n        uint64 _id,\n        bool _newNSFWStatus\n    ) public validUpdate(_id) onlyAuthorizedById(_id, VIDEO_UPDATE_ROLE) {\n        bytes32 newPackedData = calculatePackedData(\n            PackedDataParams({\n                symbol: getSymbol(_id),\n                created: getCreated(_id),\n                hidden: isHidden(_id),\n                frozen: isFrozen(_id),\n                licenseType: getLicenseType(_id),\n                nsfw: _newNSFWStatus,\n                tagHashes: getTags(_id)\n            })\n        );\n\n        videos[_id].packedData = newPackedData;\n\n        // Emit NSFWStatusUpdated event\n        emit NSFWStatusUpdated(_id, _newNSFWStatus);\n    }\n\n    function updateTags(\n        uint64 _id,\n        string[] memory _newTags\n    ) public validUpdate(_id) onlyAuthorizedById(_id, VIDEO_UPDATE_ROLE) {\n        bytes32 newPackedData = calculatePackedData(\n            PackedDataParams({\n                symbol: getSymbol(_id),\n                created: getCreated(_id),\n                hidden: isHidden(_id),\n                frozen: isFrozen(_id),\n                licenseType: getLicenseType(_id),\n                nsfw: isNSFW(_id),\n                tagHashes: calculateTagHashes(_newTags)\n            })\n        );\n\n        videos[_id].packedData = newPackedData;\n\n        // Emit CategoriesUpdated event\n        emit TagsUpdated(_id, _newTags);\n    }\n\n    function getTitle(uint64 _id) public view returns (string memory) {\n        bytes memory titleBytes = new bytes(96);\n        uint64 actualLength;\n\n        for (uint64 i = 0; i < 32; i++) {\n            titleBytes[i] = videos[_id].title1[i];\n            titleBytes[32 + i] = videos[_id].title2[i];\n            titleBytes[64 + i] = videos[_id].title3[i];\n        }\n\n        for (uint64 j = 0; j < titleBytes.length; j++) {\n            if (titleBytes[j] == 0x00) {\n                actualLength = j;\n                break;\n            }\n        }\n\n        bytes memory trimmedTitleBytes = new bytes(actualLength);\n        for (uint64 k = 0; k < actualLength; k++) {\n            trimmedTitleBytes[k] = titleBytes[k];\n        }\n        return string(trimmedTitleBytes);\n    }\n\n    function getThumbnail(uint64 _id) public view returns (string memory) {\n        bytes32 input = videos[_id].arweaveThumbnail;\n        bytes memory output = new bytes(32);\n        assembly {\n            mstore(add(output, 32), input)\n        }\n        return Base64.encode(output, true, true);\n    }\n\n    function getVideo(uint64 _id) public view returns (string memory) {\n        bytes32 input = videos[_id].arweaveVideo;\n        bytes memory output = new bytes(32);\n        assembly {\n            mstore(add(output, 32), input)\n        }\n        return Base64.encode(output, true, true);\n    }\n\n    function getDescription(uint64 _id) public view returns (string memory) {\n        return videos[_id].description;\n    }\n\n    function getSymbol(uint64 _id) public view returns (string memory) {\n        bytes32 packedData = videos[_id].packedData;\n        uint48 symbol = uint48(uint256(packedData) >> 208);\n        bytes6 symbolBytes = bytes6(symbol);\n\n        // Count the number of non-null characters\n        uint8 nonNullChars = 0;\n        for (uint8 i = 0; i < 6; i++) {\n            if (symbolBytes[i] != 0) {\n                nonNullChars++;\n            } else {\n                break;\n            }\n        }\n\n        // Create a new array with the appropriate size and copy the non-null characters\n        bytes memory trimmedSymbol = new bytes(nonNullChars);\n        for (uint8 i = 0; i < nonNullChars; i++) {\n            trimmedSymbol[i] = symbolBytes[i];\n        }\n\n        return string(trimmedSymbol);\n    }\n\n    function getCreated(uint64 _id) public view returns (uint64) {\n        bytes32 packedData = videos[_id].packedData;\n        return uint64(uint256(packedData) >> 144);\n    }\n\n    function isHidden(uint64 _id) public view returns (bool) {\n        bytes32 packedData = videos[_id].packedData;\n        return (uint256(packedData) >> 96) & 1 == 1;\n    }\n\n    function isFrozen(uint64 _id) public view returns (bool) {\n        bytes32 packedData = videos[_id].packedData;\n        return (uint256(packedData) >> 97) & 1 == 1;\n    }\n\n    function getLicenseType(uint64 _id) public view returns (uint8) {\n        bytes32 packedData = videos[_id].packedData;\n        return uint8((uint256(packedData) >> 98) & 0xFF);\n    }\n\n    function isNSFW(uint64 _id) public view returns (bool) {\n        bytes32 packedData = videos[_id].packedData;\n        return (uint256(packedData) >> 106) & 1 == 1;\n    }\n\n    function getTags(uint64 _id) public view returns (uint16[] memory) {\n        bytes32 packedData = videos[_id].packedData;\n        uint112 packedTags = uint112(uint256(packedData) & 0xFFFFFFFFFFFF);\n        uint8 tagCount = 0;\n\n        // Count the number of non-zero tags\n        for (uint8 i = 0; i < TAGS_LIMIT; i++) {\n            uint16 tagHash = uint16(packedTags >> (i * 16));\n            if (tagHash != 0) {\n                tagCount++;\n            }\n        }\n\n        // Create a new array with the appropriate size and fill it with the non-zero tags\n        uint16[] memory tagHashes = new uint16[](tagCount);\n        uint8 index = 0;\n        for (uint8 i = 0; i < TAGS_LIMIT; i++) {\n            uint16 tagHash = uint16(packedTags >> (i * 16));\n            if (tagHash != 0) {\n                tagHashes[index] = tagHash;\n                index++;\n            }\n        }\n\n        return tagHashes;\n    }\n\n    function calculateTitleBytes32(\n        bytes memory titleBytes\n    ) public pure returns (bytes32 title1, bytes32 title2, bytes32 title3) {\n        require(titleBytes.length <= 96, \"TITLE_TOO_LONG\");\n\n        // bytes memory titleBytes = bytes(title);\n        uint32 i = 0;\n\n        for (; i < 32 && i < titleBytes.length; i++) {\n            title1 |= bytes32(\n                uint(uint8(titleBytes[i])) * (2 ** (8 * (31 - i)))\n            );\n        }\n        for (; i < 64 && i < titleBytes.length; i++) {\n            title2 |= bytes32(\n                uint(uint8(titleBytes[i])) * (2 ** (8 * (63 - i)))\n            );\n        }\n        for (; i < 96 && i < titleBytes.length; i++) {\n            title3 |= bytes32(\n                uint(uint8(titleBytes[i])) * (2 ** (8 * (95 - i)))\n            );\n        }\n    }\n\n    // music     gaming\n    // VVV         V\n    // 1000000000100000000000000000\n\n    // UP TO 7\n    // 16bits(hash(\"asfaa\"))\n    // [0000000000000000] =>\n    // [0000000000000000][0000000000000000][0000000000000000][0000000000000000][0000000000000000][0000000000000000][0000000000000000]\n\n    struct PackedDataParams {\n        string symbol;\n        uint64 created;\n        bool hidden;\n        bool frozen;\n        uint8 licenseType;\n        bool nsfw;\n        uint16[] tagHashes;\n    }\n\n    function calculatePackedData(\n        PackedDataParams memory params\n    ) public pure returns (bytes32) {\n        uint48 symbol = uint48(bytes6(bytes(params.symbol)));\n        uint64 created = params.created;\n        uint8 hidden = params.hidden ? 1 : 0;\n        uint8 frozen = params.frozen ? 1 : 0;\n        uint8 licenseType = params.licenseType;\n        uint8 nsfw = params.nsfw ? 1 : 0;\n        uint112 tags = 0;\n\n        for (uint8 i = 0; i < params.tagHashes.length && i < TAGS_LIMIT; i++) {\n            tags |= uint112(params.tagHashes[i]) << (i * 16);\n        }\n        return\n            (bytes32(uint(symbol)) << 208) |\n            (bytes32(uint(created)) << 144) |\n            (bytes32(uint(hidden)) << 96) |\n            (bytes32(uint(frozen)) << 97) |\n            (bytes32(uint(licenseType)) << 98) |\n            (bytes32(uint(nsfw)) << 106) |\n            (bytes32(uint(tags)));\n    }\n\n    function calculateTagHashes(\n        string[] memory _tags\n    ) public pure returns (uint16[] memory) {\n        uint16[] memory tagHashes = new uint16[](_tags.length);\n\n        for (uint8 i = 0; i < _tags.length && i < TAGS_LIMIT; i++) {\n            tagHashes[i] = uint16(\n                bytes2(keccak256(abi.encodePacked(_tags[i])))\n            );\n        }\n\n        return tagHashes;\n    }\n\n    function arweaveIdToBytes32(\n        string memory id\n    ) public pure returns (bytes32) {\n        bytes memory input = Base64.decode(id);\n        bytes32 output;\n        assembly {\n            output := mload(add(input, 32))\n        }\n        return output;\n    }\n}\n"

    }

  },

  "settings": {

    "remappings": [

      "ERC721A-Upgradeable/=lib/ERC721A-Upgradeable/contracts/",

      "ERC721A/=lib/ERC721A/contracts/",

      "clones-with-immutable-args/=lib/clones-with-immutable-args/src/",

      "ds-test/=lib/forge-std/lib/ds-test/src/",

      "forge-std/=lib/forge-std/src/",

      "openzeppelin-contracts/=lib/openzeppelin-contracts/",

      "solady/=lib/solady/src/",

      "solmate/=lib/solmate/src/"

    ],

    "optimizer": {

      "enabled": true,

      "runs": 200

    },

    "metadata": {

      "bytecodeHash": "ipfs"

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "evmVersion": "london",

    "libraries": {}

  }

}}