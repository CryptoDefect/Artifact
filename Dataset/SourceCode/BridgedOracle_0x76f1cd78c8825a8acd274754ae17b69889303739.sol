{{

  "language": "Solidity",

  "settings": {

    "evmVersion": "istanbul",

    "libraries": {},

    "metadata": {

      "bytecodeHash": "ipfs",

      "useLiteralContent": true

    },

    "optimizer": {

      "enabled": true,

      "runs": 200

    },

    "remappings": [],

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    }

  },

  "sources": {

    "contracts/BridgedOracle.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./PriceOracle.sol\";\nimport \"./ChainlinkOracle/ChainlinkOracle.sol\";\n\ncontract BridgedOracle is PriceOracle {\n    address public admin;\n    ChainlinkOracle public chainlink;\n    PriceOracle public uniswap;\n\n    mapping(address => bool) chainlinkAssets;\n    mapping(address => bool) chainlinkETHs;\n\n    constructor(address _chainlink, address _uniswap) public {\n        admin = msg.sender;\n        chainlink = ChainlinkOracle(_chainlink);\n        uniswap = PriceOracle(_uniswap);\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"only admin may call\");\n        _;\n    }\n\n    function getUnderlyingPriceView(address cToken)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        if (chainlinkAssets[cToken]) {\n            if (chainlinkETHs[cToken]) {\n                return chainlink.getUnderlyingPriceETH();\n            } else {\n                return chainlink.getUnderlyingPriceView(cToken);\n            }\n        } else {\n            return uniswap.getUnderlyingPriceView(cToken);\n        }\n    }\n\n    function getUnderlyingPrice(address cToken)\n        public\n        override\n        returns (uint256)\n    {\n        if (chainlinkAssets[cToken]) {\n            if (chainlinkETHs[cToken]) {\n                return chainlink.getUnderlyingPriceETH();\n            } else {\n                return chainlink.getUnderlyingPrice(cToken);\n            }\n        } else {\n            return uniswap.getUnderlyingPrice(cToken);\n        }\n    }\n\n    function registerChainlinkAsset(\n        address token,\n        string calldata symbol,\n        address feed,\n        uint256 decimal,\n        bool base,\n        bool isETH\n    ) public onlyAdmin {\n        require(!chainlinkAssets[token], \"Already registered\");\n        chainlinkAssets[token] = true;\n        chainlinkETHs[token] = isETH;\n        chainlink.setFeed(symbol, feed, decimal, base);\n    }\n\n    function deregisterChainlinkAsset(address token) public onlyAdmin {\n        require(chainlinkAssets[token], \"Already deregistered\");\n        chainlinkAssets[token] = false;\n    }\n\n    function getChainlinkAsset(address token) public view returns (bool) {\n        return chainlinkAssets[token];\n    }\n\n    function releaseChainlink(address newAdmin) public onlyAdmin {\n        chainlink.setAdmin(newAdmin);\n    }\n\n    function updateChainlink(address newChainlink) public onlyAdmin {\n        chainlink = ChainlinkOracle(newChainlink);\n        chainlink.setAdmin(address(this));\n    }\n\n    function updateUniswap(address newUniswap) public onlyAdmin {\n        uniswap = PriceOracle(newUniswap);\n    }\n\n    function compareStrings(string memory a, string memory b)\n        internal\n        pure\n        returns (bool)\n    {\n        return (keccak256(abi.encodePacked((a))) ==\n            keccak256(abi.encodePacked((b))));\n    }\n\n    /** Admin Functions */\n\n    function transferOwnership(address _admin) public onlyAdmin {\n        require(_admin != address(0), \"invalid address\");\n        admin = _admin;\n    }\n\n}\n"

    },

    "contracts/ChainlinkOracle/AggregatorV2V3Interface.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\n/**\n * @title The V2 & V3 Aggregator Interface\n * @notice Solidity V0.5 does not allow interfaces to inherit from other\n * interfaces so this contract is a combination of v0.5 AggregatorInterface.sol\n * and v0.5 AggregatorV3Interface.sol.\n */\ninterface AggregatorV2V3Interface {\n  //\n  // V2 Interface:\n  //\n  function latestAnswer() external view returns (int256);\n  function latestTimestamp() external view returns (uint256);\n  function latestRound() external view returns (uint256);\n  function getAnswer(uint256 roundId) external view returns (int256);\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp);\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n\n  //\n  // V3 Interface:\n  //\n  function decimals() external view returns (uint8);\n  function description() external view returns (string memory);\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n"

    },

    "contracts/ChainlinkOracle/ChainlinkOracle.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"../PriceOracle.sol\";\nimport \"../SafeMath.sol\";\nimport \"./AggregatorV2V3Interface.sol\";\n\ninterface IToken {\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint256);\n}\n\ninterface ICToken {\n    function symbol() external view returns (string memory);\n\n    function underlying() external view returns (address);\n}\n\ncontract ChainlinkOracle is PriceOracle {\n    using SafeMath for uint256;\n    address public admin;\n\n    mapping(address => uint256) internal prices;\n    mapping(bytes32 => AggregatorV2V3Interface) internal feeds;\n    mapping(bytes32 => uint256) internal decimals;\n    mapping(bytes32 => bool) internal bases;\n    event PricePosted(\n        address asset,\n        uint256 previousPriceMantissa,\n        uint256 requestedPriceMantissa,\n        uint256 newPriceMantissa\n    );\n    event NewAdmin(address oldAdmin, address newAdmin);\n    event FeedSet(address feed, string symbol);\n\n    constructor() public {\n        admin = msg.sender;\n    }\n\n    function getUnderlyingPriceETH() public view returns (uint) {\n        return getChainlinkPrice(getFeed(\"ETH\"));\n    }\n\n    function getUnderlyingPriceView(address cToken)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return getPrice(cToken);\n    }\n\n    function getUnderlyingPrice(address cToken)\n        public\n        override\n        returns (uint256)\n    {\n        return getUnderlyingPriceView(cToken);\n    }\n\n    function getPrice(address cToken) public view returns (uint256 price) {\n        address token = ICToken(cToken).underlying();\n        string memory symbol = IToken(token).symbol();\n\n        if (prices[token] != 0) {\n            price = prices[token];\n        } else {\n            price = getChainlinkPrice(getFeed(symbol));\n        }\n\n        if (!getBase(symbol)) {\n            AggregatorV2V3Interface baseFeed = getFeed(\"ETH\");\n            price = getChainlinkPrice(baseFeed).mul(price).div(10**18);\n        }\n\n        uint256 tokenDecimals = 18;\n        if (decimals[keccak256(abi.encodePacked(symbol))] > 0) {\n            tokenDecimals = uint256(IToken(token).decimals());\n        }\n\n        uint256 decimalDelta = uint256(36)\n            .sub(tokenDecimals)\n            .sub(getDecimal(symbol));\n        // Ensure that we don't multiply the result by 0\n        if (decimalDelta > 0) {\n            return price.mul(10**decimalDelta);\n        } else {\n            return price;\n        }\n    }\n\n    function getChainlinkPrice(AggregatorV2V3Interface feed)\n        internal\n        view\n        returns (uint256)\n    {\n        // Chainlink USD-denominated feeds store answers at 8 decimals\n        uint256 decimalDelta = uint256(18).sub(feed.decimals());\n        // Ensure that we don't multiply the result by 0\n        if (decimalDelta > 0) {\n            return uint256(feed.latestAnswer()).mul(10**decimalDelta);\n        } else {\n            return uint256(feed.latestAnswer());\n        }\n    }\n\n    function setUnderlyingPrice(address cToken, uint256 underlyingPriceMantissa)\n        external\n        onlyAdmin\n    {\n        address asset = ICToken(cToken).underlying();\n        emit PricePosted(\n            asset,\n            prices[asset],\n            underlyingPriceMantissa,\n            underlyingPriceMantissa\n        );\n        prices[asset] = underlyingPriceMantissa;\n    }\n\n    function setDirectPrice(address asset, uint256 price) external onlyAdmin {\n        emit PricePosted(asset, prices[asset], price, price);\n        prices[asset] = price;\n    }\n\n    function setFeed(\n        string calldata symbol,\n        address feed,\n        uint256 decimal,\n        bool base\n    ) external onlyAdmin {\n        require(\n            feed != address(0) && feed != address(this),\n            \"invalid feed address\"\n        );\n        emit FeedSet(feed, symbol);\n        feeds[keccak256(abi.encodePacked(symbol))] = AggregatorV2V3Interface(\n            feed\n        );\n        decimals[keccak256(abi.encodePacked(symbol))] = decimal;\n        bases[keccak256(abi.encodePacked(symbol))] = base;\n    }\n\n    function getFeed(string memory symbol)\n        public\n        view\n        returns (AggregatorV2V3Interface)\n    {\n        return feeds[keccak256(abi.encodePacked(symbol))];\n    }\n\n    function getBase(string memory symbol) public view returns (bool) {\n        return bases[keccak256(abi.encodePacked(symbol))];\n    }\n\n    function getDecimal(string memory symbol) public view returns (uint256) {\n        return decimals[keccak256(abi.encodePacked(symbol))];\n    }\n\n    function assetPrices(address asset) external view returns (uint256) {\n        return prices[asset];\n    }\n\n    function compareStrings(string memory a, string memory b)\n        internal\n        pure\n        returns (bool)\n    {\n        return (keccak256(abi.encodePacked((a))) ==\n            keccak256(abi.encodePacked((b))));\n    }\n\n    function setAdmin(address newAdmin) external onlyAdmin {\n        address oldAdmin = admin;\n        admin = newAdmin;\n\n        emit NewAdmin(oldAdmin, newAdmin);\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"only admin may call\");\n        _;\n    }\n}\n"

    },

    "contracts/PriceOracle.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nabstract contract PriceOracle {\n    /// @notice Indicator that this is a PriceOracle contract (for inspection)\n    bool public constant isPriceOracle = true;\n\n    /**\n      * @notice Get the underlying price of a cToken asset\n      * @param cToken The cToken to get the underlying price of\n      * @return The underlying asset price mantissa (scaled by 1e18).\n      *  Zero means the price is unavailable.\n      */\n    function getUnderlyingPrice(address cToken) external virtual returns (uint);\n\n    function getUnderlyingPriceView(address cToken) public view virtual returns (uint);\n}\n"

    },

    "contracts/SafeMath.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\n// Subject to the MIT license.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction underflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"

    }

  }

}}