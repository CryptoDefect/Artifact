{{

  "language": "Solidity",

  "sources": {

    "contracts/access/AdminAgent.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\nimport { Context } from \"../lib/utils/Context.sol\";\n\ncontract AdminAgent is Context {\n\n  mapping(address => bool) private _adminAgents;\n\n  constructor(address[] memory adminAgents_) {\n    for (uint i = 0; i < adminAgents_.length; i++) {\n      require(adminAgents_[i] != address(0), \"Invalid address\");\n      _adminAgents[adminAgents_[i]] = true;\n    }\n  }\n\n  modifier onlyAdminAgents() {\n    require(_adminAgents[_msgSender()], \"Unauthorized\");\n    _;\n  }\n}"

    },

    "contracts/access/AdminGovernanceAgent.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\nimport { Context } from \"../lib/utils/Context.sol\";\n\ncontract AdminGovernanceAgent is Context {\n\n  mapping(address => bool) private _adminGovAgents;\n\n  constructor(address[] memory adminGovAgents_) {\n    for (uint i = 0; i < adminGovAgents_.length; i++) {\n      require(adminGovAgents_[i] != address(0), \"Invalid address\");\n      _adminGovAgents[adminGovAgents_[i]] = true;\n    }\n  }\n\n  modifier onlyAdminGovAgents() {\n    require(_adminGovAgents[_msgSender()], \"Unauthorized\");\n    _;\n  }\n}"

    },

    "contracts/access/BackendAgent.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\nimport { Context } from \"../lib/utils/Context.sol\";\n\ncontract BackendAgent is Context {\n\n  mapping(address => bool) private _backendAdminAgents;\n  mapping(address => bool) private _backendAgents;\n\n  event SetBackendAgent(address agent);\n  event RevokeBackendAgent(address agent);\n\n  modifier onlyBackendAdminAgents() {\n    require(_backendAdminAgents[_msgSender()], \"Unauthorized\");\n    _;\n  }\n\n  modifier onlyBackendAgents() {\n    require(_backendAgents[_msgSender()], \"Unauthorized\");\n    _;\n  }\n\n  function _setBackendAgents(address[] memory backendAgents) internal {\n    for (uint i = 0; i < backendAgents.length; i++) {\n      require(backendAgents[i] != address(0), \"Invalid address\");\n      _backendAgents[backendAgents[i]] = true;\n    }\n  }\n\n  function _setBackendAdminAgents(address[] memory backendAdminAgents) internal {\n    for (uint i = 0; i < backendAdminAgents.length; i++) {\n      require(backendAdminAgents[i] != address(0), \"Invalid address\");\n      _backendAdminAgents[backendAdminAgents[i]] = true;\n    }\n  }\n\n  function setBackendAgent(address _agent) external onlyBackendAdminAgents {\n    require(_agent != address(0), \"Invalid address\");\n    _backendAgents[_agent] = true;\n    emit SetBackendAgent(_agent);\n  }\n\n  function revokeBackendAgent(address _agent) external onlyBackendAdminAgents {\n    _backendAgents[_agent] = false;\n    emit RevokeBackendAgent(_agent);\n  }\n}"

    },

    "contracts/exchange/VETHP2P.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.18;\n\nimport { VETHRevenueCycleTreasury } from \"./VETHRevenueCycleTreasury.sol\";\nimport { ERC20 } from \"../lib/token/ERC20/ERC20.sol\";\nimport { VYToken } from \"../token/VYToken.sol\";\nimport { BackendAgent } from \"../access/BackendAgent.sol\";\nimport { RegistrarClient } from \"../RegistrarClient.sol\";\nimport { Router } from \"../Router.sol\";\n\ncontract VETHP2P is BackendAgent, RegistrarClient {\n\n  uint256 private constant MULTIPLIER = 10**18;\n\n  struct TradeOfferCalcInfo {\n    uint256 amountOut;\n    uint256 takerReceives;\n    uint256 takerFee;\n    uint256 makerReceives;\n    uint256 makerFee;\n  }\n\n  uint256 public constant EXPIRES_IN = 30 days;\n  uint256 public constant MINIMUM_AUTOCLOSE_IN_ETH = 500000000000000; // 0.0005 ETH\n  uint256 public constant ETH_FEE = 20000000000000000;\n  uint256 public constant VY_FEE = 20000000000000000;\n\n  Router private _ethComptroller;\n  VETHRevenueCycleTreasury private _vethRevenueCycleTreasury;\n  uint256 private _nonce = 1;\n\n  enum TradingPairs {\n    VY_ETH,\n    ETH_VY\n  }\n\n  struct Offer {\n    uint256 id;\n    TradingPairs tradingPair;\n    uint256 quantity;\n    uint256 price;\n    uint256 expiresAt;\n    bool isOpen;\n  }\n\n  struct TradingPair {\n    address makerAssetAddress;\n    address takerAssetAddress;\n    address makerTreasuryAddress;\n    address takerTreasuryAddress;\n    uint256 makerFeeRate;\n    uint256 takerFeeRate;\n  }\n\n  mapping(address => mapping(uint256 => Offer)) private _offers;\n  mapping(TradingPairs => TradingPair) private _tradingPairs;\n\n  event CreateOffer(uint256 id, address seller, TradingPairs tradingPair, uint256 quantity, uint256 price, uint256 expiresAt, uint256 timestamp);\n  event TradeOffer(uint256 id, address buyer, uint256 sellerQuantity, uint256 buyerQuantity, uint256 unfilledQuantity, uint256 timestamp);\n  event CloseOffer(uint256 id, uint256 timestamp);\n\n  constructor(\n    address registrarAddress,\n    address ethComptrollerAddress_,\n    address[] memory backendAdminAgents,\n    address[] memory backendAgents\n  ) RegistrarClient(registrarAddress) {\n    require(ethComptrollerAddress_ != address(0), \"Invalid address\");\n\n    _ethComptroller = Router(payable(ethComptrollerAddress_));\n    _setBackendAdminAgents(backendAdminAgents);\n    _setBackendAgents(backendAgents);\n  }\n\n  modifier onlyValidCreateOffer(TradingPairs tradingPair, uint256 quantity, uint256 price) {\n    require(_pairExist(tradingPair), \"Invalid pair\");\n    require(quantity > 0, \"Invalid quantity\");\n    require(price > 0, \"Invalid price\");\n\n    if (tradingPair == TradingPairs.ETH_VY) {\n      require(msg.value == quantity, \"Invalid ETH amount sent\");\n    } else {\n      require(msg.value == 0, \"Invalid ETH amount sent\");\n    }\n    _;\n  }\n\n  modifier onlyValidTradeOffer(uint256 id, address seller, uint256 quantity) {\n    require(_isOfferActive(id, seller), \"Invalid offer\");\n    require(quantity > 0, \"Invalid quantity\");\n    _;\n  }\n\n  modifier onlyOpenOffer(uint256 id, address seller) {\n    require(_offers[seller][id].isOpen, \"Offer must be open in order to close\");\n    _;\n  }\n\n  function getNonce() external view returns (uint256) {\n    return _nonce;\n  }\n\n  function getOffer(uint256 id, address seller) external view returns (Offer memory) {\n    return _offers[seller][id];\n  }\n\n  function createOffer(TradingPairs tradingPair, uint256 quantity, uint256 price)\n    external\n    payable\n    onlyValidCreateOffer(tradingPair, quantity, price)\n  {\n    _createOffer(tradingPair, quantity, price);\n  }\n\n  function createOffer(TradingPairs tradingPair, uint256 quantity, uint256 price, uint8 v, bytes32 r, bytes32 s)\n    external\n    payable\n    onlyValidCreateOffer(tradingPair, quantity, price)\n  {\n    // Verify maker asset must be VY\n    require(_tradingPairs[tradingPair].makerAssetAddress == _tradingPairs[TradingPairs.VY_ETH].makerAssetAddress, \"Must be [VY_ETH]\");\n    VYToken makerAsset = VYToken(_tradingPairs[tradingPair].makerAssetAddress);\n    // Call approval\n    makerAsset.permit(_msgSender(), address(this), quantity, v, r, s);\n    _createOffer(tradingPair, quantity, price);\n  }\n\n  function _createOffer(TradingPairs tradingPair, uint256 quantity, uint256 price) private {\n    uint256 yieldRate = _vethRevenueCycleTreasury.getYieldRate();\n    if (tradingPair == TradingPairs.ETH_VY) {\n      require(price <= yieldRate, \"Price must be <= yieldRate\");\n    } else if (tradingPair == TradingPairs.VY_ETH) {\n      require((MULTIPLIER * MULTIPLIER / price) <= yieldRate, \"Price reciprocal must be <= yieldRate\");\n    } else {\n      revert(\"Unsupported pair\");\n    }\n\n    // Create offer\n    uint256 expiresAt = block.timestamp + EXPIRES_IN;\n    uint256 id = _nonce++;\n    _offers[_msgSender()][id] = Offer(id, tradingPair, quantity, price, expiresAt, true);\n\n    // Transfer VY to the contract\n    if (tradingPair == TradingPairs.VY_ETH) {\n      ERC20 token = _getSpendingTokenAndCheck(_tradingPairs[tradingPair].makerAssetAddress, quantity);\n      token.transferFrom(_msgSender(), address(this), quantity);\n    }\n\n    emit CreateOffer(id, _msgSender(), tradingPair, quantity, price, expiresAt, block.timestamp);\n  }\n\n  function tradeOffer(uint256 id, address seller, uint256 quantity)\n    external\n    payable\n    onlyValidTradeOffer(id, seller, quantity)\n    returns (TradeOfferCalcInfo memory)\n  {\n    _validateTradeOfferETHAmount(id, seller, quantity);\n\n    return _tradeOffer(id, seller, quantity);\n  }\n\n  function tradeOffer(uint256 id, address seller, uint256 quantity, uint8 v, bytes32 r, bytes32 s)\n    external\n    payable\n    onlyValidTradeOffer(id, seller, quantity)\n    returns (TradeOfferCalcInfo memory)\n  {\n    _validateTradeOfferETHAmount(id, seller, quantity);\n\n    // Verify taker asset must be VY\n    TradingPair memory tradingPair = _tradingPairs[_offers[seller][id].tradingPair];\n    require(tradingPair.takerAssetAddress == _tradingPairs[TradingPairs.ETH_VY].takerAssetAddress, \"Must be [ETH_VY]\");\n\n    VYToken takerAsset = VYToken(tradingPair.takerAssetAddress);\n    // Call approval\n    takerAsset.permit(_msgSender(), address(this), quantity, v, r, s);\n\n    return _tradeOffer(id, seller, quantity);\n  }\n\n  function estimateTradeOffer(uint256 id, address seller, uint256 quantity) external view onlyValidTradeOffer(id, seller, quantity) returns (TradeOfferCalcInfo memory) {\n    TradingPair memory tradingPair = _tradingPairs[_offers[seller][id].tradingPair];\n    uint256 maxInput = _offers[seller][id].quantity * _offers[seller][id].price / MULTIPLIER;\n    require(quantity <= maxInput, \"Not enough to sell\");\n\n    return _calcTradeOffer(tradingPair, quantity, _offers[seller][id].price);\n  }\n\n  function _tradeOffer(uint256 id, address seller, uint256 quantity) private returns (TradeOfferCalcInfo memory) {\n    TradingPair memory tradingPair = _tradingPairs[_offers[seller][id].tradingPair];\n    uint256 maxInput = _offers[seller][id].quantity * _offers[seller][id].price / MULTIPLIER;\n    require(quantity <= maxInput, \"Not enough to sell\");\n\n    /// @dev returns maker quantity fulfilled by this trade\n    TradeOfferCalcInfo memory calc = _calcTradeOffer(tradingPair, quantity, _offers[seller][id].price);\n\n    // Update offer quantity\n    require(_offers[seller][id].quantity >= calc.amountOut, \"Bad calculations\");\n    _offers[seller][id].quantity -= calc.amountOut;\n\n    // VY_ETH trade\n    if (tradingPair.takerAssetAddress == address(0)) {\n      ERC20 makerAsset = ERC20(tradingPair.makerAssetAddress);\n\n      // Transfer taker ETH\n      _transfer(seller, calc.makerReceives);\n      _ethComptroller.route{ value: calc.makerFee }();\n\n      // Transfer maker VY\n      makerAsset.transfer(_msgSender(), calc.takerReceives);\n      makerAsset.transfer(tradingPair.makerTreasuryAddress, calc.takerFee);\n    } else { // ETH_VY trade\n      ERC20 takerAsset = _getSpendingTokenAndCheck(tradingPair.takerAssetAddress, quantity);\n\n      /**\n       * Transfer taker VY\n       *\n       * @dev the code below transfers makerReceives from taker to contract, then from contract to maker\n       * instead of transferring makerReceives directly from taker to maker, is to avoid user transfer fee\n       * being applied to (See ticket-296 for more info)\n       */\n      takerAsset.transferFrom(_msgSender(), address(this), calc.makerReceives);\n      takerAsset.transfer(seller, calc.makerReceives);\n      takerAsset.transferFrom(_msgSender(), tradingPair.takerTreasuryAddress, calc.makerFee);\n\n      // Transfer maker ETH\n      _transfer(_msgSender(), calc.takerReceives);\n      _ethComptroller.route{ value: calc.takerFee }();\n    }\n\n    // ETH_VY market - selling amount in ETH < MINIMUM_AUTOCLOSE_IN_ETH\n    bool makerCloseout = (tradingPair.makerAssetAddress == address(0) && _offers[seller][id].quantity < MINIMUM_AUTOCLOSE_IN_ETH);\n    // VY_ETH market - converted selling amount in VY to ETH < MINIMUM_AUTOCLOSE_IN_ETH\n    bool takerCloseout = (tradingPair.takerAssetAddress == address(0) && _offers[seller][id].quantity * _offers[seller][id].price / MULTIPLIER < MINIMUM_AUTOCLOSE_IN_ETH);\n\n    if (makerCloseout || takerCloseout) {\n      _closeOffer(id, seller); // Auto-close when selling amount in ETH < MINIMUM_AUTOCLOSE_IN_ETH\n    }\n\n    emit TradeOffer(id, _msgSender(), calc.amountOut, quantity, _offers[seller][id].quantity, block.timestamp);\n\n    return calc;\n  }\n\n  function closeOffer(uint256 id) external onlyOpenOffer(id, _msgSender()) {\n    _closeOffer(id, _msgSender());\n  }\n\n  function closeOffer(address seller, uint256 id) external onlyOpenOffer(id, seller) onlyBackendAgents {\n    _closeOffer(id, seller);\n  }\n\n  function _pairExist(TradingPairs tradingPair) private view returns (bool) {\n    return _tradingPairs[tradingPair].makerAssetAddress != address(0) || _tradingPairs[tradingPair].takerAssetAddress != address(0);\n  }\n\n  function _isOfferActive(uint256 id, address seller) private view returns (bool) {\n    return _offers[seller][id].isOpen && _offers[seller][id].expiresAt > block.timestamp;\n  }\n\n  function _getSpendingTokenAndCheck(address assetAddress, uint256 quantity) private view returns (ERC20) {\n    ERC20 token = ERC20(assetAddress);\n    require(token.allowance(_msgSender(), address(this)) >= quantity, \"Insufficient allowance\");\n    require(token.balanceOf(_msgSender()) >= quantity, \"Insufficient balance\");\n    return token;\n  }\n\n  function _calcTradeOffer(TradingPair memory tradingPair, uint256 quantity, uint256 price) private pure returns (TradeOfferCalcInfo memory) {\n    // Offer is 1,000 VY at 10.0 ETH each (10,000 ETH in total)\n    // Taker want to swap 100 ETH for 10 VY\n    // buyQuantity should be 100 ETH * (10^18 / 10^19) = 10 VY\n    uint256 buyQuantity = quantity * MULTIPLIER / price;\n\n    TradeOfferCalcInfo memory calc;\n    calc.amountOut = buyQuantity;\n    calc.makerFee = quantity * tradingPair.makerFeeRate / MULTIPLIER;\n    calc.takerFee = buyQuantity * tradingPair.takerFeeRate / MULTIPLIER;\n    calc.makerReceives = quantity - calc.makerFee;\n    calc.takerReceives = buyQuantity - calc.takerFee;\n\n    return calc;\n  }\n\n  function _closeOffer(uint256 id, address seller) private {\n    uint256 remainingQuantity = _offers[seller][id].quantity;\n    _offers[seller][id].isOpen = false;\n    if (remainingQuantity > 0) {\n      _offers[seller][id].quantity = 0;\n\n      address makerAssetAddress = _tradingPairs[_offers[seller][id].tradingPair].makerAssetAddress;\n      if (makerAssetAddress == address(0)) {\n        _transfer(seller, remainingQuantity);\n      } else {\n        ERC20 token = ERC20(makerAssetAddress);\n        token.transfer(seller, remainingQuantity);\n      }\n    }\n    emit CloseOffer(id, block.timestamp);\n  }\n\n  function updateAddresses() external override onlyRegistrar {\n    _vethRevenueCycleTreasury = VETHRevenueCycleTreasury(_registrar.getVETHRevenueCycleTreasury());\n    _initTradingPairs();\n  }\n\n  function _initTradingPairs() internal {\n    address vethRevenueCycleTreasury = _registrar.getVETHRevenueCycleTreasury();\n    address vyToken = _registrar.getVYToken();\n    _tradingPairs[TradingPairs.VY_ETH] = TradingPair(vyToken, address(0), vethRevenueCycleTreasury, address(_ethComptroller), VY_FEE, ETH_FEE);\n    _tradingPairs[TradingPairs.ETH_VY] = TradingPair(address(0), vyToken, address(_ethComptroller), vethRevenueCycleTreasury, ETH_FEE, VY_FEE);\n  }\n\n  function _transfer(address recipient, uint256 amount) private {\n    (bool sent,) = recipient.call{value: amount}(\"\");\n    require(sent, \"Failed to send Ether\");\n  }\n\n  function _validateTradeOfferETHAmount(uint256 id, address seller, uint256 quantity) private {\n    if (_offers[seller][id].tradingPair == TradingPairs.VY_ETH) {\n      require(msg.value == quantity, \"Invalid ETH amount sent\");\n    } else {\n      require(msg.value == 0, \"Invalid ETH amount sent\");\n    }\n  }\n}"

    },

    "contracts/exchange/VETHRevenueCycleTreasury.sol": {

      "content": "// SPDX-License-Identifier: MIT\n//\n// VETHRevenueCycleTreasury [VY_ETH]\n//\n\npragma solidity 0.8.18;\n\nimport { BackendAgent } from \"../access/BackendAgent.sol\";\nimport { VYToken } from \"../token/VYToken.sol\";\nimport { RegistrarClient } from \"../RegistrarClient.sol\";\nimport { RegistrarMigrator } from \"../RegistrarMigrator.sol\";\nimport { AdminGovernanceAgent } from \"../access/AdminGovernanceAgent.sol\";\nimport { Governable } from \"../governance/Governable.sol\";\nimport { VETHYieldRateTreasury } from \"../treasury/VETHYieldRateTreasury.sol\";\nimport { VYRevenueCycleCirculationTracker } from \"./VYRevenueCycleCirculationTracker.sol\";\nimport { Registrar } from \"../Registrar.sol\";\nimport { Router } from \"../Router.sol\";\n\ncontract VETHRevenueCycleTreasury is BackendAgent, RegistrarClient, RegistrarMigrator, AdminGovernanceAgent, Governable, VYRevenueCycleCirculationTracker {\n\n  uint256 private constant MULTIPLIER = 10**18;\n\n  uint256 public constant ETH_FEE = 20000000000000000;\n  uint256 public constant VY_FEE = 20000000000000000;\n  uint256 public constant CREATE_PRICE_FACTOR = 2000000000000000000; // 2 multiplier\n  uint256 public constant YIELD_RATE_FACTOR = 1030000000000000000; // 1.03 multiplier\n\n  VYToken internal _vyToken;\n  VETHYieldRateTreasury private _vethYRT;\n  Router private _ethComptroller;\n  address private _migration;\n  uint256 private _nonce = 0;\n  uint256 private _vyAllocatedInOffer = 0;\n  uint256 internal _initialYieldRate = 0;\n\n  struct Offer {\n    uint256 id;\n    uint256 quantity;\n    uint256 price;\n    bool isOpen;\n  }\n\n  mapping(uint256 => Offer) private _offers;\n\n  event CreateOffer(uint256 id, uint256 quantity, uint256 price, uint256 timestamp);\n  event TradeOffer(uint256 id, address buyer, uint256 sellerQuantity, uint256 buyerQuantity, uint256 unfilledQuantity, uint256 timestamp);\n  event CloseOffer(uint256 id, uint256 timestamp);\n\n  constructor(\n    address registrarAddress,\n    address ethComptrollerAddress_,\n    address[] memory adminAgents,\n    address[] memory backendAdminAgents,\n    address[] memory backendAgents,\n    address[] memory adminGovAgents,\n    uint256 initialYieldRate_,\n    uint256 initialCirculation\n  ) RegistrarClient(registrarAddress)\n    RegistrarMigrator(registrarAddress, uint(Registrar.Contract.VETHRevenueCycleTreasury), adminAgents)\n    AdminGovernanceAgent(adminGovAgents)\n    VYRevenueCycleCirculationTracker(initialCirculation) {\n    require(ethComptrollerAddress_ != address(0), \"Invalid address\");\n\n    _ethComptroller = Router(payable(ethComptrollerAddress_));\n    _setBackendAdminAgents(backendAdminAgents);\n    _setBackendAgents(backendAgents);\n    _initialYieldRate = initialYieldRate_;\n  }\n\n  function getNonce() external view returns (uint256) {\n    return _nonce;\n  }\n\n  function getVYAllocatedInOffer() external view returns (uint256) {\n    return _vyAllocatedInOffer;\n  }\n\n  function getOffer(uint256 id) external view returns (Offer memory) {\n    return _offers[id];\n  }\n\n  function getMigration() external view returns (address) {\n    return _migration;\n  }\n\n  function getInitialYieldRate() external view returns (uint256) {\n    return _initialYieldRate;\n  }\n\n  function getYieldRate() external view returns (uint256) {\n    return _getYieldRate();\n  }\n\n  function getVETHCirculation() public view returns (uint256) {\n    return _getRevenueCycleCirculation();\n  }\n\n  function setMigration(address destination) external onlyGovernance {\n    _migration = destination;\n  }\n\n  function transferMigration(uint256 amount) external onlyAdminGovAgents {\n    require(_migration != address(0), \"Migration not set\");\n    require(_vyToken.balanceOf(address(this)) >= amount, \"Insufficient balance\");\n    _vyToken.transfer(_migration, amount);\n  }\n\n  function createOffer(uint256 quantity) external onlyBackendAgents {\n    require(quantity > 0, \"Invalid quantity\");\n\n    uint256 yieldRate = _getYieldRate();\n    require(yieldRate > 0, \"Yield rate must be greater than zero\");\n    uint256 price = CREATE_PRICE_FACTOR * MULTIPLIER / yieldRate;\n\n    Offer memory offer = _offers[_nonce];\n    if (offer.isOpen) {\n      _closeOffer(_nonce);\n    }\n\n    uint256 _vyBalance = _vyToken.balanceOf(address(this));\n    uint256 _desiredTotalVY = _vyAllocatedInOffer + quantity;\n\n    uint256 id = ++_nonce;\n    _offers[id] = Offer(id, quantity, price, true);\n    _vyAllocatedInOffer += quantity;\n\n    if (_desiredTotalVY > _vyBalance) {\n      uint256 amountToMint = _desiredTotalVY - _vyBalance;\n      _vyToken.mint(amountToMint);\n    }\n\n    emit CreateOffer(id, quantity, price, block.timestamp);\n  }\n\n  function tradeOffer(uint256 id) external payable {\n    require(msg.value > 0, \"Invalid quantity\");\n    require(_isOfferActive(id), \"Invalid offer\");\n\n    uint256 price = _offers[id].price;\n    uint256 maxInput = _offers[id].quantity * price / MULTIPLIER;\n    require(msg.value <= maxInput, \"Not enough to sell\");\n\n    /// @dev returns maker quantity fulfilled by this trade\n    uint256 buyQuantity = msg.value * MULTIPLIER / price;\n    require(_vyToken.balanceOf(address(this)) >= buyQuantity, \"Not enough to sell\");\n\n    // Add yield rate > 0 check to avoid error dividing by 0 yield rate from the following cases:\n    // 1. VETHYieldRateTreasury contract swap making treasuryValue 0\n    // 2. Stake supply = 0 and initial yield rate = 0\n    uint256 yieldRate = _getYieldRate();\n    if (yieldRate > 0) {\n      uint256 limitYieldRate = YIELD_RATE_FACTOR * MULTIPLIER / yieldRate;\n      // Ensure offer price is still above yield rate to enforce rising yield rate rule\n      require(price >= limitYieldRate, \"Price must be >= limitYieldRate\");\n    }\n\n    // Update offer quantity and total VY allocated\n    require(_offers[id].quantity >= buyQuantity, \"Bad calculations\");\n    _offers[id].quantity -= buyQuantity;\n    _vyAllocatedInOffer -= buyQuantity;\n\n    uint256 makerFee = msg.value * VY_FEE / MULTIPLIER;\n    uint256 takerFee = buyQuantity * ETH_FEE / MULTIPLIER;\n\n    uint256 makerReceives = msg.value - makerFee;\n    uint256 takerReceives = buyQuantity - takerFee;\n\n    _transfer(address(_vethYRT), makerReceives);\n    _ethComptroller.route{ value: makerFee }();\n    _vyToken.transfer(_msgSender(), takerReceives);\n\n    emit TradeOffer(id, _msgSender(), buyQuantity, msg.value, _offers[id].quantity, block.timestamp);\n  }\n\n  function closeOffer(uint256 id) external onlyBackendAgents {\n    require(_isOfferActive(id), \"Invalid offer\");\n    _closeOffer(id);\n  }\n\n  function updateAddresses() external override onlyRegistrar {\n    _vyToken = VYToken(_registrar.getVYToken());\n    _vethYRT = VETHYieldRateTreasury(payable(_registrar.getVETHYieldRateTreasury()));\n    _updateGovernable(_registrar);\n    _updateVYCirculationHelper(_registrar);\n  }\n\n  function _isOfferActive(uint256 id) private view returns (bool) {\n    return _offers[id].isOpen;\n  }\n\n  function _getYieldRate() private view returns (uint256) {\n    uint256 circulation = getVETHCirculation();\n    uint256 treasuryValue = _vethYRT.getYieldRateTreasuryValue();\n\n    if (treasuryValue == 0) {\n      return 0;\n    }\n\n    if (circulation > 0) {\n      return MULTIPLIER * circulation / treasuryValue;\n    } else {\n      return _initialYieldRate;\n    }\n  }\n\n  function _transfer(address recipient, uint256 amount) private {\n    (bool sent,) = recipient.call{value: amount}(\"\");\n    require(sent, \"Failed to send Ether\");\n  }\n\n  function _closeOffer(uint256 id) private {\n    _vyAllocatedInOffer -= _offers[id].quantity;\n    _offers[id].isOpen = false;\n    _offers[id].quantity = 0;\n    emit CloseOffer(id, block.timestamp);\n  }\n}"

    },

    "contracts/exchange/VYRevenueCycleCirculationTracker.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.18;\n\nimport { Registrar } from \"../Registrar.sol\";\nimport { Context } from \"../lib/utils/Context.sol\";\n\ncontract VYRevenueCycleCirculationTracker is Context {\n\n  uint256 private _revenueCycleCirculation;\n  address private _vyTokenAddress;\n\n  constructor(uint256 initialCirculation) {\n    _revenueCycleCirculation = initialCirculation;\n  }\n\n  modifier onlyVYToken() {\n    require(_msgSender() == _vyTokenAddress, \"Caller must be VYToken\");\n    _;\n  }\n\n  function increaseRevenueCycleCirculation(uint256 amount) external onlyVYToken {\n    _revenueCycleCirculation += amount;\n  }\n\n  function decreaseRevenueCycleCirculation(uint256 amount) external onlyVYToken {\n    if (amount > _revenueCycleCirculation) {\n        _revenueCycleCirculation = 0;\n    } else {\n        _revenueCycleCirculation -= amount;\n    }\n  }\n\n  function _updateVYCirculationHelper(Registrar registrar) internal {\n    _vyTokenAddress = registrar.getVYToken();\n  }\n\n  function _getRevenueCycleCirculation() internal view returns (uint256) {\n    return _revenueCycleCirculation;\n  }\n}\n"

    },

    "contracts/governance/Governable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\nimport { Context } from \"../lib/utils/Context.sol\";\nimport { Registrar } from \"../Registrar.sol\";\n\ncontract Governable is Context {\n\n  address internal _governanceAddress;\n\n  constructor() {}\n\n  modifier onlyGovernance() {\n    require(_governanceAddress == _msgSender(), \"Unauthorized\");\n    _;\n  }\n\n  function _updateGovernable(Registrar registrar) internal {\n    _governanceAddress = registrar.getVETHGovernance();\n  }\n\n  function getGovernanceAddress() external view returns (address) {\n    return _governanceAddress;\n  }\n}"

    },

    "contracts/governance/VETHGovernance.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.18;\n\nimport { AdminGovernanceAgent } from \"../access/AdminGovernanceAgent.sol\";\nimport { VETHYieldRateTreasury } from \"../treasury/VETHYieldRateTreasury.sol\";\nimport { VYToken } from \"../token/VYToken.sol\";\nimport { VETHRevenueCycleTreasury } from \"../exchange/VETHRevenueCycleTreasury.sol\";\nimport { VETHReverseStakingTreasury } from \"../VETHReverseStakingTreasury.sol\";\nimport { RegistrarClient } from \"../RegistrarClient.sol\";\n\ncontract VETHGovernance is AdminGovernanceAgent, RegistrarClient {\n\n  enum VoteOptions {\n    YES,\n    NO\n  }\n\n  enum ProposalType {\n    Migration,\n    Registrar,\n    ReverseStakingTermUpdate\n  }\n\n  struct MigrationProposal {\n    address yieldRateTreasuryDestination;\n    address revenueCycleTreasuryDestination;\n    address reverseStakingTreasuryDestination;\n  }\n\n  struct RegistrarProposal {\n    address registrar; // Registrar to add\n  }\n\n  struct ReverseStakingTermUpdateProposal {\n    uint256 dailyBurnRate;\n    uint256 minimumReverseStakeETH;\n    uint256 processingFeePercentage;\n    uint256 restakeMinimumPayout;\n  }\n\n  struct Proposal {\n    ProposalType proposalType;\n    uint256 endsAt;\n    bool approved;\n    MigrationProposal migration;\n    RegistrarProposal registrar;\n    ReverseStakingTermUpdateProposal reverseStakingTermUpdate;\n  }\n\n  event StartMigrationProposal(\n    uint256 proposalId,\n    address yieldRateTreasuryDestination,\n    address revenueCycleTreasuryDestination,\n    address reverseStakingTreasuryDestination,\n    uint256 endsAt\n  );\n  event StartRegistrarProposal(uint256 proposalId, address registrar, uint256 endsAt);\n  event StartReverseStakingTermUpdateProposal(\n    uint256 proposalId,\n    uint256 dailyBurnRate,\n    uint256 minimumReverseStakeETH,\n    uint256 processingFeePercentage,\n    uint256 restakeMinimumPayout,\n    uint256 endsAt\n  );\n\n  VYToken private _vyToken;\n  VETHYieldRateTreasury private _vethYRT;\n  VETHRevenueCycleTreasury private _vethRevenueCycleTreasury;\n  VETHReverseStakingTreasury internal _vethReverseStakingTreasury;\n  mapping(uint256 => mapping(address => uint256)) private _deposits;\n  mapping(uint256 => mapping(VoteOptions => uint256)) private _voteCount;\n  mapping(uint256 => Proposal) private _proposals;\n  uint256 public votingPeriod;  // In seconds\n  uint256 private _proposalNonce = 0;\n\n  event Vote(address account, VoteOptions voteOption, uint256 quantity);\n\n  constructor(\n    address registrarAddress,\n    uint256 votingPeriod_,\n    address[] memory adminGovAgents\n  ) AdminGovernanceAgent(adminGovAgents) RegistrarClient(registrarAddress) {\n    votingPeriod = votingPeriod_;\n  }\n\n  modifier hasMigrationAddresses() {\n    require(address(_vethYRT) != address(0), \"ETH Treasury address not set\");\n    require(address(_vethRevenueCycleTreasury) != address(0), \"VETHRevenueCycleTreasury address not set\");\n    require(address(_vethReverseStakingTreasury) != address(0), \"VETHReverseStakingTreasury address not set\");\n    _;\n  }\n\n  modifier hasProposal() {\n    require(_proposals[_proposalNonce].endsAt > 0, \"No proposal\");\n    _;\n  }\n\n  modifier hasProposalById(uint256 proposalId) {\n    require(_proposals[proposalId].endsAt > 0, \"No proposal\");\n    _;\n  }\n\n  function getCurrentProposal() external view returns (Proposal memory) {\n    return _proposals[_proposalNonce];\n  }\n\n  function getProposalById(uint256 proposalId) external view returns (Proposal memory) {\n    return _proposals[proposalId];\n  }\n\n  function getCurrentProposalId() external view returns (uint256) {\n    return _proposalNonce;\n  }\n\n  function getCurrentYesVotes() external view returns (uint256) {\n    return _voteCount[_proposalNonce][VoteOptions.YES];\n  }\n\n  function getCurrentNoVotes() external view returns (uint256) {\n    return _voteCount[_proposalNonce][VoteOptions.NO];\n  }\n\n  function getYesVotesById(uint256 proposalId) external view returns (uint256) {\n    return _voteCount[proposalId][VoteOptions.YES];\n  }\n\n  function getNoVotesById(uint256 proposalId) external view returns (uint256) {\n    return _voteCount[proposalId][VoteOptions.NO];\n  }\n\n  function getCurrentDepositedVY(address voter) external view returns (uint256) {\n    return _deposits[_proposalNonce][voter];\n  }\n\n  function getDepositedVYById(uint256 proposalId, address voter) external view returns (uint256) {\n    return _deposits[proposalId][voter];\n  }\n\n  function hasCurrentProposalEnded() public view hasProposal returns (bool) {\n    return block.timestamp > _proposals[_proposalNonce].endsAt;\n  }\n\n  function hasProposalEndedById(uint256 proposalId) external view hasProposalById(proposalId) returns (bool) {\n    return block.timestamp > _proposals[proposalId].endsAt;\n  }\n\n  function voteYes(uint256 quantity) external {\n    _vote(VoteOptions.YES, quantity);\n  }\n\n  function voteNo(uint256 quantity) external {\n    _vote(VoteOptions.NO, quantity);\n  }\n\n  function _vote(VoteOptions voteOption, uint256 quantity) private hasProposal {\n    require(block.timestamp < _proposals[_proposalNonce].endsAt, \"Proposal already ended\");\n    require(_deposits[_proposalNonce][_msgSender()] == 0, \"Already voted\");\n    require(_vyToken.allowance(_msgSender(), address(this)) >= quantity, \"Insufficient VY allowance\");\n    require(_vyToken.balanceOf(_msgSender()) >= quantity, \"Insufficient VY balance\");\n\n    _deposits[_proposalNonce][_msgSender()] += quantity;\n    _voteCount[_proposalNonce][voteOption] += quantity;\n    _vyToken.transferFrom(_msgSender(), address(this), quantity);\n\n    emit Vote(_msgSender(), voteOption, quantity);\n  }\n\n  function startMigrationProposal(\n    address yieldRateTreasuryDestination,\n    address revenueCycleTreasuryDestination,\n    address reverseStakingTreasuryDestination\n  ) external onlyAdminGovAgents {\n    // Prevent funds locked up in zero address\n    require(\n      yieldRateTreasuryDestination != address(0) &&\n        revenueCycleTreasuryDestination != address(0) &&\n        reverseStakingTreasuryDestination != address(0),\n      \"Invalid address\"\n    );\n\n    _startMigrationProposal(yieldRateTreasuryDestination, revenueCycleTreasuryDestination, reverseStakingTreasuryDestination);\n  }\n\n  function executeMigrationProposal() external hasMigrationAddresses hasProposal onlyAdminGovAgents {\n    _checkValidMigrationProposal(\n      _proposals[_proposalNonce].migration.yieldRateTreasuryDestination != address(0),\n      _proposals[_proposalNonce].migration.revenueCycleTreasuryDestination != address(0),\n      _proposals[_proposalNonce].migration.reverseStakingTreasuryDestination != address(0)\n    );\n\n    _executeMigrationProposal();\n  }\n\n  function startRegistrarProposal(address registrar) external onlyAdminGovAgents {\n    // Prevent funds locked up in zero address\n    require(registrar != address(0), \"Invalid address\");\n\n    // Should only allow starting new proposal after current one is expired\n    // Note: starting first proposal where _proposalNonce is 0 should not require expiration condition\n    require(block.timestamp > _proposals[_proposalNonce].endsAt || _proposalNonce == 0, \"Proposal still ongoing\");\n\n    uint256 endsAt = block.timestamp + votingPeriod;\n\n    _proposals[++_proposalNonce] = Proposal(\n      ProposalType.Registrar,\n      endsAt,\n      false,\n      MigrationProposal(address(0), address(0), address(0)),\n      RegistrarProposal(registrar),\n      ReverseStakingTermUpdateProposal(0, 0, 0, 0)\n    );\n\n    // Emit event\n    emit StartRegistrarProposal(\n      _proposalNonce,\n      registrar,\n      endsAt\n    );\n  }\n\n  function executeRegistrarProposal() external hasProposal onlyAdminGovAgents {\n    require(address(_vyToken) != address(0), \"VYToken address not set\");\n    require(hasCurrentProposalEnded(), \"Proposal still ongoing\");\n    require(_proposals[_proposalNonce].proposalType == ProposalType.Registrar, \"Invalid proposal\");\n    require(_voteCount[_proposalNonce][VoteOptions.YES] >= _voteCount[_proposalNonce][VoteOptions.NO], \"Proposal not passed\");\n\n    _proposals[_proposalNonce].approved = true;\n\n    // Register new Registrar with VYToken\n    _vyToken.setRegistrar(_registrar.getEcosystemId(), _proposalNonce);\n  }\n\n  function startReverseStakingTermUpdateProposal(\n    uint256 dailyBurnRate,\n    uint256 minimumReverseStakeETH,\n    uint256 processingFeePercentage,\n    uint256 restakeMinimumPayout\n  ) external onlyAdminGovAgents {\n    // Should only allow starting new proposal after current one is expired\n    // Note: starting first proposal where _proposalNonce is 0 should not require expiration condition\n    require(block.timestamp > _proposals[_proposalNonce].endsAt || _proposalNonce == 0, \"Proposal still ongoing\");\n\n    uint256 endsAt = block.timestamp + votingPeriod;\n\n    _proposals[++_proposalNonce] = Proposal(\n      ProposalType.ReverseStakingTermUpdate,\n      endsAt,\n      false,\n      MigrationProposal(address(0), address(0), address(0)),\n      RegistrarProposal(address(0)),\n      ReverseStakingTermUpdateProposal(\n        dailyBurnRate,\n        minimumReverseStakeETH,\n        processingFeePercentage,\n        restakeMinimumPayout\n      )\n    );\n\n    // Emit event\n    emit StartReverseStakingTermUpdateProposal(\n      _proposalNonce,\n      dailyBurnRate,\n      minimumReverseStakeETH,\n      processingFeePercentage,\n      restakeMinimumPayout,\n      endsAt\n    );\n  }\n\n  function executeReverseStakingTermUpdateProposal() external hasProposal onlyAdminGovAgents {\n    require(address(_vethReverseStakingTreasury) != address(0), \"VETHReverseStakingTreasury address not set\");\n    require(hasCurrentProposalEnded(), \"Proposal still ongoing\");\n    require(_proposals[_proposalNonce].proposalType == ProposalType.ReverseStakingTermUpdate, \"Invalid proposal\");\n    require(_voteCount[_proposalNonce][VoteOptions.YES] >= _voteCount[_proposalNonce][VoteOptions.NO], \"Proposal not passed\");\n\n    _proposals[_proposalNonce].approved = true;\n\n    ReverseStakingTermUpdateProposal memory proposal = _proposals[_proposalNonce].reverseStakingTermUpdate;\n    _vethReverseStakingTreasury.createNewReverseStakeTerm(\n      proposal.dailyBurnRate,\n      proposal.minimumReverseStakeETH,\n      proposal.processingFeePercentage,\n      proposal.restakeMinimumPayout\n    );\n  }\n\n  function startYieldRateTreasuryMigration(address yieldRateTreasuryDestination) external onlyAdminGovAgents {\n    // Prevent funds locked up in zero address\n    require(yieldRateTreasuryDestination != address(0), \"Invalid address\");\n    _startMigrationProposal(yieldRateTreasuryDestination, address(0), address(0));\n  }\n\n  function executeYieldRateTreasuryMigration() external hasProposal onlyAdminGovAgents {\n    require(address(_vethYRT) != address(0), \"ETH Treasury address not set\");\n    _checkValidMigrationProposal(\n      _proposals[_proposalNonce].migration.yieldRateTreasuryDestination != address(0),\n      _proposals[_proposalNonce].migration.revenueCycleTreasuryDestination == address(0),\n      _proposals[_proposalNonce].migration.reverseStakingTreasuryDestination == address(0)\n    );\n\n    _executeMigrationProposal();\n  }\n\n  function startRevenueCycleTreasuryMigration(address revenueCycleTreasuryDestination) external onlyAdminGovAgents {\n    // Prevent funds locked up in zero address\n    require(revenueCycleTreasuryDestination != address(0), \"Invalid address\");\n    _startMigrationProposal(address(0), revenueCycleTreasuryDestination, address(0));\n  }\n\n  function executeRevenueCycleTreasuryMigration() external hasProposal onlyAdminGovAgents {\n    require(address(_vethRevenueCycleTreasury) != address(0), \"VETHRevenueCycleTreasury address not set\");\n    _checkValidMigrationProposal(\n      _proposals[_proposalNonce].migration.yieldRateTreasuryDestination == address(0),\n      _proposals[_proposalNonce].migration.revenueCycleTreasuryDestination != address(0),\n      _proposals[_proposalNonce].migration.reverseStakingTreasuryDestination == address(0)\n    );\n\n    _executeMigrationProposal();\n  }\n\n  function startReverseStakingTreasuryMigration(address reverseStakingTreasuryDestination) external onlyAdminGovAgents {\n    // Prevent funds locked up in zero address\n    require(reverseStakingTreasuryDestination != address(0), \"Invalid address\");\n    _startMigrationProposal(address(0), address(0), reverseStakingTreasuryDestination);\n  }\n\n  function executeReverseStakingTreasuryMigration() external hasProposal onlyAdminGovAgents {\n    require(address(_vethReverseStakingTreasury) != address(0), \"VETHReverseStakingTreasury address not set\");\n    _checkValidMigrationProposal(\n      _proposals[_proposalNonce].migration.yieldRateTreasuryDestination == address(0),\n      _proposals[_proposalNonce].migration.revenueCycleTreasuryDestination == address(0),\n      _proposals[_proposalNonce].migration.reverseStakingTreasuryDestination != address(0)\n    );\n\n    _executeMigrationProposal();\n  }\n\n  function _executeMigrationProposal() private {\n    require(hasCurrentProposalEnded(), \"Proposal still ongoing\");\n    require(_voteCount[_proposalNonce][VoteOptions.YES] >= _voteCount[_proposalNonce][VoteOptions.NO], \"Proposal not passed\");\n\n    _proposals[_proposalNonce].approved = true;\n\n    // execute VETHYieldRateTreasury migration\n    address yieldRateTreasuryDestination = _proposals[_proposalNonce].migration.yieldRateTreasuryDestination;\n    if (yieldRateTreasuryDestination != address(0)) {\n      _vethYRT.setMigration(yieldRateTreasuryDestination);\n    }\n\n    // execute VETHRevenueCycleTreasury migration\n    address revenueCycleTreasuryDestination = _proposals[_proposalNonce].migration.revenueCycleTreasuryDestination;\n    if (revenueCycleTreasuryDestination != address(0)) {\n      _vethRevenueCycleTreasury.setMigration(revenueCycleTreasuryDestination);\n    }\n\n    // execute VETHReverseStakingTreasury migration\n    address reverseStakingTreasuryDestination = _proposals[_proposalNonce].migration.reverseStakingTreasuryDestination;\n    if (reverseStakingTreasuryDestination != address(0)) {\n      _vethReverseStakingTreasury.setMigration(reverseStakingTreasuryDestination);\n    }\n  }\n\n  function _startMigrationProposal(\n    address yieldRateTreasuryDestination,\n    address revenueCycleTreasuryDestination,\n    address reverseStakingTreasuryDestination\n  ) private {\n    // Should only allow starting new proposal after current one is expired\n    // Note: starting first proposal where _proposalNonce is 0 should not require expiration condition\n    require(block.timestamp > _proposals[_proposalNonce].endsAt || _proposalNonce == 0, \"Proposal still ongoing\");\n\n    uint256 endsAt = block.timestamp + votingPeriod;\n\n    // Create new proposal and increment nounce\n    _proposals[++_proposalNonce] = Proposal(\n      ProposalType.Migration,\n      endsAt,\n      false,\n      MigrationProposal(yieldRateTreasuryDestination, revenueCycleTreasuryDestination, reverseStakingTreasuryDestination),\n      RegistrarProposal(address(0)),\n      ReverseStakingTermUpdateProposal(0, 0, 0, 0)\n    );\n\n    // Emit event\n    emit StartMigrationProposal(\n      _proposalNonce,\n      yieldRateTreasuryDestination,\n      revenueCycleTreasuryDestination,\n      reverseStakingTreasuryDestination,\n      endsAt\n    );\n  }\n\n  // Withdraw from current proposal\n  function withdrawDepositedVY() external {\n    _withdraw(_proposalNonce);\n  }\n\n  // Withdraw by proposal id\n  function withdrawDepositedVYById(uint256 proposalId) external {\n    _withdraw(proposalId);\n  }\n\n  // Withdraw from all proposals\n  function withdrawAllDepositedVY() external hasProposal {\n    // Check if current proposal is still ongoing - to continue current proposal has to end first\n    require(hasCurrentProposalEnded(), \"Proposal still ongoing\");\n\n    // When _withdraw is called this variable will be false\n    bool nothingToWithdraw = true;\n\n    // Loop to withdraw proposals that have deposits\n    for (uint proposalId = 1; proposalId <= _proposalNonce; proposalId++) {\n      if (_deposits[proposalId][_msgSender()] > 0) { // Check if there is anything to withdraw\n        nothingToWithdraw = false;\n        _withdraw(proposalId);\n      }\n    }\n\n    // If nothing to withdraw then warn the user\n    require(!nothingToWithdraw, \"Nothing to withdraw\");\n  }\n\n  function _withdraw(uint256 proposalId) private hasProposalById(proposalId) {\n    require(block.timestamp > _proposals[proposalId].endsAt, \"Proposal still ongoing\");\n    require(_deposits[proposalId][_msgSender()] > 0, \"Nothing to withdraw\");\n    uint256 quantity = _deposits[proposalId][_msgSender()];\n    _deposits[proposalId][_msgSender()] = 0;\n    _vyToken.transfer(_msgSender(), quantity);\n  }\n\n  function updateAddresses() external override onlyRegistrar {\n    _vyToken = VYToken(_registrar.getVYToken());\n    _vethYRT = VETHYieldRateTreasury(payable(_registrar.getVETHYieldRateTreasury()));\n    _vethRevenueCycleTreasury = VETHRevenueCycleTreasury(_registrar.getVETHRevenueCycleTreasury());\n    _vethReverseStakingTreasury = VETHReverseStakingTreasury(payable(_registrar.getVETHReverseStakingTreasury()));\n  }\n\n  function _checkValidMigrationProposal(bool validYRT, bool validRCT, bool validRST) private view {\n    require(_proposals[_proposalNonce].proposalType == ProposalType.Migration, \"Invalid proposal\");\n    require(validYRT, \"Invalid migration proposal\");\n    require(validRCT, \"Invalid migration proposal\");\n    require(validRST, \"Invalid migration proposal\");\n  }\n}"

    },

    "contracts/lib/access/AccessControl.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(account),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"

    },

    "contracts/lib/access/IAccessControl.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"

    },

    "contracts/lib/openzeppelin-upgradeable/access/OwnableUpgradeable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"

    },

    "contracts/lib/openzeppelin-upgradeable/interfaces/draft-IERC1822Upgradeable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822ProxiableUpgradeable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"

    },

    "contracts/lib/openzeppelin-upgradeable/proxy/beacon/IBeaconUpgradeable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeaconUpgradeable {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"

    },

    "contracts/lib/openzeppelin-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeaconUpgradeable.sol\";\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/StorageSlotUpgradeable.sol\";\nimport \"../utils/Initializable.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967UpgradeUpgradeable is Initializable {\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\n        require(AddressUpgradeable.isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return AddressUpgradeable.verifyCallResult(success, returndata, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"

    },

    "contracts/lib/openzeppelin-upgradeable/proxy/utils/Initializable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"

    },

    "contracts/lib/openzeppelin-upgradeable/proxy/utils/UUPSUpgradeable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../ERC1967/ERC1967UpgradeUpgradeable.sol\";\nimport \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");\n        _;\n    }\n\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate that the this implementation remains valid after an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"

    },

    "contracts/lib/openzeppelin-upgradeable/utils/AddressUpgradeable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"

    },

    "contracts/lib/openzeppelin-upgradeable/utils/ContextUpgradeable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"

    },

    "contracts/lib/openzeppelin-upgradeable/utils/StorageSlotUpgradeable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlotUpgradeable {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"

    },

    "contracts/lib/token/ERC20/ERC20.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"

    },

    "contracts/lib/token/ERC20/extensions/IERC20Metadata.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"

    },

    "contracts/lib/token/ERC20/IERC20.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"

    },

    "contracts/lib/utils/Context.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"

    },

    "contracts/lib/utils/introspection/ERC165.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"

    },

    "contracts/lib/utils/introspection/IERC165.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"

    },

    "contracts/lib/utils/math/Math.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"

    },

    "contracts/lib/utils/math/SignedMath.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"

    },

    "contracts/lib/utils/Strings.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"

    },

    "contracts/Registrar.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.18;\n\nimport { AdminAgent } from \"./access/AdminAgent.sol\";\nimport { IRegistrarClient } from \"./RegistrarClient.sol\";\nimport { VYToken } from \"./token/VYToken.sol\";\n\ncontract Registrar is AdminAgent {\n\n  bytes32 private constant ECOSYSTEM_ID = keccak256(bytes(\"VY_ETH\"));\n\n  address[] private _contracts;\n  address[] private _prevContracts;\n  bool private _finalized;\n\n  event SetContracts(address[] addresses);\n  event SetContractByIndex(uint8 index, address contractAddressTo);\n  event Finalize(address registrarAddress);\n\n  enum Contract {\n    VYToken,\n    VETHYieldRateTreasury,\n    VETHP2P,\n    VETHRevenueCycleTreasury,\n    VETHGovernance,\n    VETHReverseStakingTreasury\n  }\n\n  /**\n   * @dev Constructor that setup the owner of this contract.\n   */\n  constructor(address[] memory adminAgents) AdminAgent(adminAgents) {\n    _prevContracts = new address[](_numbersOfContracts());\n  }\n\n  modifier onlyUnfinalized() {\n    require(_finalized == false, \"Registrar already finalized\");\n    _;\n  }\n\n  modifier onlyValidContractIndex(uint256 index) {\n    require(index < _numbersOfContracts(), \"Invalid index\");\n    _;\n  }\n\n  function getEcosystemId() external pure virtual returns (bytes32) {\n    return ECOSYSTEM_ID;\n  }\n\n  function getContracts() external view returns (address[] memory) {\n    return _contracts;\n  }\n\n  function getContractByIndex(\n    uint256 index\n  ) external view onlyValidContractIndex(index) returns (address) {\n    return _contracts[index];\n  }\n\n  function getPrevContractByIndex(\n    uint256 index\n  ) external view onlyValidContractIndex(index) returns (address) {\n    return _prevContracts[index];\n  }\n\n  function setContracts(address[] calldata _addresses) external onlyAdminAgents onlyUnfinalized {\n    require(_validContractsLength(_addresses.length), \"Invalid number of addresses\");\n\n    // Loop through and update _prevContracts entries only if those addresses are new.\n    // For example, assume _prevContracts[0] = 0xABC and contracts[i] = 0xF00\n    // If _addresses[i] = 0xF00 and we didn't perform the check below, then we would overwrite the old\n    // 0xABC with 0xF00, thereby losing whatever actual previous contract address that was.\n    for (uint i = 0; i < _contracts.length; i++) {\n      if (_addresses[i] != _contracts[i]) {\n        _prevContracts[i] = _contracts[i];\n      }\n    }\n\n    _contracts = _addresses;\n\n    emit SetContracts(_addresses);\n  }\n\n  function setContractByIndex(uint8 _index, address _address) external onlyAdminAgents onlyUnfinalized {\n    if (_address != _contracts[_index]) {\n      _prevContracts[_index] = _contracts[_index];\n    }\n\n    _contracts[_index] = _address;\n\n    emit SetContractByIndex(_index, _address);\n  }\n\n  function updateAllClients() external onlyAdminAgents onlyUnfinalized {\n    VYToken(this.getVYToken()).setMinter();\n    IRegistrarClient(this.getVETHP2P()).updateAddresses();\n    IRegistrarClient(this.getVETHRevenueCycleTreasury()).updateAddresses();\n    IRegistrarClient(this.getVETHReverseStakingTreasury()).updateAddresses();\n    IRegistrarClient(this.getVETHYieldRateTreasury()).updateAddresses();\n    IRegistrarClient(this.getVETHGovernance()).updateAddresses();\n  }\n\n  function getVYToken() external view returns (address) {\n    return _contracts[uint(Contract.VYToken)];\n  }\n\n  function getVETHYieldRateTreasury() external view returns (address) {\n    return _contracts[uint(Contract.VETHYieldRateTreasury)];\n  }\n\n  function getVETHP2P() external view returns (address) {\n    return _contracts[uint(Contract.VETHP2P)];\n  }\n\n  function getVETHRevenueCycleTreasury() external view returns (address) {\n    return _contracts[uint(Contract.VETHRevenueCycleTreasury)];\n  }\n\n  function getVETHGovernance() external view returns (address) {\n    return _contracts[uint(Contract.VETHGovernance)];\n  }\n\n  function getVETHReverseStakingTreasury() external view returns (address) {\n    return _contracts[uint(Contract.VETHReverseStakingTreasury)];\n  }\n\n  function finalize() external onlyAdminAgents onlyUnfinalized {\n    _finalized = true;\n    emit Finalize(address(this));\n  }\n\n  function isFinalized() external view returns (bool) {\n    return _finalized;\n  }\n\n  function _numbersOfContracts() private pure returns (uint256) {\n    return uint(Contract.VETHReverseStakingTreasury) + 1;\n  }\n\n  function _validContractsLength(uint256 contractsLength) private pure returns (bool) {\n    return contractsLength == _numbersOfContracts();\n  }\n}"

    },

    "contracts/RegistrarClient.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\nimport { Context } from \"./lib/utils/Context.sol\";\nimport { Registrar } from \"./Registrar.sol\";\n\ninterface IRegistrarClient {\n  function updateAddresses() external;\n}\n\nabstract contract RegistrarClient is Context, IRegistrarClient {\n\n  Registrar internal _registrar;\n\n  constructor(address registrarAddress) {\n    require(registrarAddress != address(0), \"Invalid address\");\n    _registrar = Registrar(registrarAddress);\n  }\n\n  modifier onlyRegistrar() {\n    require(_msgSender() == address(_registrar), \"Unauthorized, registrar only\");\n    _;\n  }\n\n  function getRegistrar() external view returns(address) {\n    return address(_registrar);\n  }\n\n  // All subclasses must implement this function\n  function updateAddresses() external override virtual;\n}"

    },

    "contracts/RegistrarMigrator.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.18;\n\nimport { Registrar } from \"./Registrar.sol\";\nimport { AdminAgent } from \"./access/AdminAgent.sol\";\nimport { VYToken } from \"./token/VYToken.sol\";\n\nabstract contract RegistrarMigrator is AdminAgent {\n\n  Registrar private _registrar;\n  uint256 private _contractIndex;\n\n  constructor(\n    address registrarAddress,\n    uint256 contractIndex,\n    address[] memory adminAgents\n  ) AdminAgent(adminAgents) {\n    require(registrarAddress != address(0), \"Invalid address\");\n\n    _registrar = Registrar(registrarAddress);\n    _contractIndex = contractIndex;\n  }\n\n  modifier onlyUnfinalized() {\n    require(_registrar.isFinalized() == false, \"Registrar already finalized\");\n    _;\n  }\n\n  function registrarMigrateTokens() external onlyAdminAgents onlyUnfinalized {\n    VYToken vyToken = VYToken(_registrar.getVYToken());\n    vyToken.registrarMigrateTokens(_registrar.getEcosystemId(), _contractIndex);\n  }\n}"

    },

    "contracts/Router.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.18;\n\nimport { OwnableUpgradeable } from \"./lib/openzeppelin-upgradeable/access/OwnableUpgradeable.sol\";\nimport { Initializable } from \"./lib/openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport { UUPSUpgradeable } from \"./lib/openzeppelin-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\ncontract Router is Initializable, OwnableUpgradeable, UUPSUpgradeable {\n\n  address private _primaryStakeholder;\n\n  event Route(address indexed receiver, uint256 amount);\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  function initialize(address primaryStakeholder_) public initializer {\n    __Ownable_init();\n    __UUPSUpgradeable_init();\n    _primaryStakeholder = primaryStakeholder_;\n  }\n\n  function route() external payable {\n    _routePrimaryStakeholder(msg.value);\n  }\n\n  function _routePrimaryStakeholder(uint256 amount) private {\n    (bool sent,) = _primaryStakeholder.call{value: amount}(\"\");\n    require(sent, \"Failed to send Ether\");\n\n    emit Route(_primaryStakeholder, amount);\n  }\n\n  function _authorizeUpgrade(address newImplementation)\n    internal\n    onlyOwner\n    override\n  {}\n\n  receive() external payable {}\n}"

    },

    "contracts/token/VYToken.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.18;\n\nimport { AccessControl } from \"../lib/access/AccessControl.sol\";\nimport { ERC20 } from \"../lib/token/ERC20/ERC20.sol\";\nimport { AdminAgent } from \"../access/AdminAgent.sol\";\nimport { BackendAgent } from \"../access/BackendAgent.sol\";\nimport { VYRevenueCycleCirculationTracker } from \"../exchange/VYRevenueCycleCirculationTracker.sol\";\nimport { Registrar } from \"../Registrar.sol\";\nimport { VETHGovernance } from \"../governance/VETHGovernance.sol\";\n\ncontract VYToken is ERC20, AdminAgent, BackendAgent, AccessControl {\n\n  uint256 private constant MULTIPLIER = 10**18;\n\n  // EIP712 Precomputed hashes:\n  // keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")\n  bytes32 private constant EIP712DOMAINTYPE_HASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n  // keccak256(\"VYToken\")\n  bytes32 private constant NAME_HASH = 0xc8992ef634b020d3849cb749bb94cf703a7071d02872a417a811fadacc5fdcbb;\n\n  // keccak256(\"1\")\n  bytes32 private constant VERSION_HASH = 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\n\n  // keccak256(\"VYPermit(address owner,address spender,uint256 amount,uint256 nonce)\");\n  bytes32 private constant TXTYPE_HASH = 0x085abc97e2d328b3816b8248b9e8aa0e35bb8f414343c830d2d375b0d9b3c98f;\n\n  // solhint-disable-next-line var-name-mixedcase\n  bytes32 public DOMAIN_SEPARATOR;\n  mapping(address => uint) public nonces;\n\n  bytes32 public constant MAIN_ECOSYSTEM_ID = keccak256(bytes(\"VY_ETH\"));\n  bytes32 private constant OWNER_ROLE = keccak256(\"OWNER_ROLE\");\n  bytes32 private constant WHITELISTER_ROLE = keccak256(\"WHITELISTER_ROLE\");\n\n  uint256 public constant MAX_SUPPLY = 7000000000000000000000000000; // 7 billion hard cap\n\n  mapping(address => bool) private _agents;\n  mapping(address => bool) private _minters;\n  mapping(bytes32 => address) private _registrars; // Ecosystems\n  uint256 private _vyCirculation = 0;\n  uint256 private _transferFee = 0; // user transfer fee in %\n\n  event AgentWhitelisted(address recipient);\n  event AgentWhitelistRevoked(address recipient);\n  event SetRegistrar(address registrar, bytes32 ecosystemId);\n\n  /**\n   * @dev Constructor that setup all the role admins.\n   */\n  constructor(\n    string memory name,\n    string memory symbol,\n    address registrarAddress,\n    address[] memory adminAgents,\n    address[] memory backendAdminAgents,\n    address[] memory backendAgents,\n    uint256 transferFee_,\n    uint256 initialCirculation\n  ) ERC20(name, symbol) AdminAgent(adminAgents) {\n    // make OWNER_ROLE the admin role for each role (only people with the role of an admin role can manage that role)\n    _setRoleAdmin(WHITELISTER_ROLE, OWNER_ROLE);\n    _setRoleAdmin(OWNER_ROLE, OWNER_ROLE);\n    // setup deployer to be part of OWNER_ROLE which allow deployer to manage all roles\n    _setupRole(OWNER_ROLE, _msgSender());\n\n    // Setup backend\n    _setBackendAdminAgents(backendAdminAgents);\n    _setBackendAgents(backendAgents);\n\n    // Setup registrar\n    _setRegistrar(registrarAddress);\n\n    // Setup EIP712\n    DOMAIN_SEPARATOR = keccak256(\n      abi.encode(\n        EIP712DOMAINTYPE_HASH,\n        NAME_HASH,\n        VERSION_HASH,\n        block.chainid,\n        address(this)\n      )\n    );\n\n    _transferFee = transferFee_;\n    _vyCirculation = initialCirculation;\n  }\n\n  function getVYCirculation() external view returns (uint256) {\n    return _vyCirculation;\n  }\n\n  function getRegistrarById(bytes32 id) external view returns(address) {\n    return _registrars[id];\n  }\n\n  function isMinter(address _address) external view returns (bool) {\n    return _minters[_address];\n  }\n\n  function transfer(address recipient, uint256 amount) public override returns (bool) {\n    // Check if fee is not zero then it's user to user transfer - send fee to vethRevenueCycleTreasury\n    uint256 fee = _calculateTransferFee(_msgSender(), recipient, amount);\n\n    if (fee != 0) {\n      address mainRevenueCycleTreasury = _getMainEcosystemRegistrar().getVETHRevenueCycleTreasury();\n      _updateCirculationAndSupply(_msgSender(), mainRevenueCycleTreasury, fee);\n\n      super.transfer(recipient, amount - fee); // transfers amount - fee to recipient\n      return super.transfer(mainRevenueCycleTreasury, fee); // transfers fee to vethRevenueCycleTreasury\n    }\n\n    _updateCirculationAndSupply(_msgSender(), recipient, amount);\n    return super.transfer(recipient, amount);\n  }\n\n  function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n    // Check if fee is not zero then it's user to user transfer - send fee to vethRevenueCycleTreasury\n    uint256 fee = _calculateTransferFee(sender, recipient, amount);\n\n    if (fee != 0) {\n      address mainRevenueCycleTreasury = _getMainEcosystemRegistrar().getVETHRevenueCycleTreasury();\n      _updateCirculationAndSupply(sender, mainRevenueCycleTreasury, fee);\n\n      super.transferFrom(sender, recipient, amount - fee); // transfers amount - fee to recipient\n      return super.transferFrom(sender, mainRevenueCycleTreasury, fee); // transfers fee to vethRevenueCycleTreasury\n    }\n\n    _updateCirculationAndSupply(sender, recipient, amount);\n    return super.transferFrom(sender, recipient, amount);\n  }\n\n  function getTransferFee() external view returns (uint256) {\n    return _transferFee;\n  }\n\n  function setTransferFee(uint256 fee) external onlyAdminAgents {\n    _transferFee = fee;\n  }\n\n  /*\n   * Register a new ecosystem Registrar with us\n   *\n   * @dev can only be called by VETHGovernance\n   */\n  function setRegistrar(bytes32 originEcosystemId, uint proposalNonce) external {\n    address registrarAddress = _registrars[originEcosystemId];\n    require(registrarAddress != address(0), \"Invalid originEcosystemId\");\n\n    // Only VETHGovernance of applicable Registrar may call this function\n    Registrar registrar = Registrar(registrarAddress);\n    VETHGovernance governance = VETHGovernance(registrar.getVETHGovernance());\n    require(_msgSender() == address(governance), \"Caller must be VETHGovernance\");\n\n    VETHGovernance.Proposal memory proposal = governance.getProposalById(proposalNonce);\n\n    // Must be valid proposal\n    require(proposal.approved == true && proposal.proposalType == VETHGovernance.ProposalType.Registrar, \"Invalid proposal\");\n\n    _setRegistrar(proposal.registrar.registrar);\n    _setMinter(Registrar(proposal.registrar.registrar));\n  }\n\n  /**\n   * @dev 1) Must be called by the outgoing contract (contract to be swapped out) as\n   * the _msgSender must initiate the transfer.\n   * 2) Since the registrar now saves the previous contract, registrarMigrateTokens\n   * can be called post-swap\n   * 3) Registrar must be not finalized\n   */\n  function registrarMigrateTokens(bytes32 registrarId, uint256 contractIndex) external {\n    // The reason we need this function is to transfer tokens due to a registrar contract\n    // swap without modifying the circulation and supply.\n\n    // Require valid registrar id\n    address registrarAddress = _registrars[registrarId];\n    require(registrarAddress != address(0), \"Invalid registar id\");\n\n    // Require that this registrar is not finalized\n    Registrar registrar = Registrar(registrarAddress);\n    _requireRegistrarIsUnfinalized(registrar);\n\n    address prevContract = registrar.getPrevContractByIndex(contractIndex);\n    address newContract = registrar.getContractByIndex(contractIndex);\n\n    // Require that _msgSender is prevContract\n    require(_msgSender() == prevContract, \"Caller must be prevContract\");\n\n    // Require newContract should not be the zero address\n    require(newContract != address(0), \"newContract is the zero address\");\n\n    super.transfer(newContract, balanceOf(prevContract));\n  }\n\n  function _setRegistrar(address registrar) private {\n    require(registrar != address(0), \"Invalid address\");\n    bytes32 ecosystemId = Registrar(registrar).getEcosystemId();\n    _registrars[ecosystemId] = registrar;\n\n    emit SetRegistrar(registrar, ecosystemId);\n  }\n\n  /**\n   * @dev Only whitelisted minters may call this function\n   */\n  function mint(uint256 amount) public returns (bool) {\n    require(_minters[_msgSender()], \"Caller is not an allowed minter\");\n    require(totalSupply() + amount <= MAX_SUPPLY, \"Exceeds max supply\");\n\n    super._mint(_msgSender(), amount);\n\n    return true;\n  }\n\n  /**\n   * @dev Can only be called by Registrar, in the case of registrar contract swap update.\n   * Registrar must not be finalized.\n   */\n  function setMinter() external {\n    Registrar registrar = Registrar(_msgSender());\n    require(_registrars[registrar.getEcosystemId()] == _msgSender(), \"Invalid registar\");\n    _requireRegistrarIsUnfinalized(registrar);\n\n    _setMinter(registrar);\n  }\n\n  function _setMinter(Registrar registrar) private {\n    // Unset previous revenueCycleTreasury\n    address prevRevenueCycleTreasury = registrar.getPrevContractByIndex(uint(Registrar.Contract.VETHRevenueCycleTreasury));\n    _minters[prevRevenueCycleTreasury] = false;\n\n    // Set current revenueCycleTreasury\n    address revenueCycleTreasury = registrar.getVETHRevenueCycleTreasury();\n    _minters[revenueCycleTreasury] = true;\n  }\n\n  /**\n   * @dev Airdrop tokens to holders in case VYToken is migrated.\n   * Can only be done if main ecosystem's registrar is not finalized.\n   */\n  function airdropTokens(address[] calldata _addresses, uint[] calldata _amounts) external onlyBackendAgents {\n    require(_addresses.length == _amounts.length, \"Argument array length mismatch\");\n    _requireRegistrarIsUnfinalized(_getMainEcosystemRegistrar()); // Check main ecosystem\n\n    for (uint i = 0; i < _addresses.length; i++) {\n      super._mint(_addresses[i], _amounts[i]);\n    }\n  }\n\n  function grantOwnerRole(address _address) external onlyRole(OWNER_ROLE) {\n    grantRole(OWNER_ROLE, _address);\n  }\n\n  function grantWhitelisterRole(address _address) external onlyRole(OWNER_ROLE) {\n    grantRole(WHITELISTER_ROLE, _address);\n  }\n\n  function revokeOwnerRole(address _address) external onlyRole(OWNER_ROLE) {\n    revokeRole(OWNER_ROLE, _address);\n  }\n\n  function revokeWhitelisterRole(address _address) external onlyRole(OWNER_ROLE) {\n    revokeRole(WHITELISTER_ROLE, _address);\n  }\n\n  function isWhitelistedAgent(address _address) external view returns (bool) {\n    return _agents[_address];\n  }\n\n  function whitelistAgent(address _address) external onlyRole(WHITELISTER_ROLE) {\n    require(_agents[_address] == false, \"Already whitelisted\");\n    _agents[_address] = true;\n    emit AgentWhitelisted(_address);\n  }\n\n  function revokeWhitelistedAgent(address _address) external onlyRole(WHITELISTER_ROLE) {\n    require(_agents[_address] == true, \"Not whitelisted\");\n    delete _agents[_address];\n    emit AgentWhitelistRevoked(_address);\n  }\n\n  function permit(address owner, address spender, uint256 amount, uint8 v, bytes32 r, bytes32 s) external {\n    // EIP712 scheme: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md\n    bytes32 txInputHash = keccak256(abi.encode(TXTYPE_HASH, owner, spender, amount, nonces[owner]));\n    bytes32 totalHash = keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, txInputHash));\n\n    address recoveredAddress = ecrecover(totalHash, v, r, s);\n    require(recoveredAddress != address(0) && recoveredAddress == owner, \"VYToken: INVALID_SIGNATURE\");\n\n    nonces[owner] = nonces[owner] + 1;\n    _approve(owner, spender, amount);\n  }\n\n  function _getMainEcosystemRegistrar() private view returns (Registrar) {\n    address registrarAddress = _registrars[MAIN_ECOSYSTEM_ID];\n\n    return Registrar(registrarAddress);\n  }\n\n  function _updateCirculationAndSupply(address from, address to, uint256 amount) private {\n    if (_minters[to]) {\n      _decreaseCirculationAndSupply(amount, to);\n    } else if (_minters[from]) {\n      _increaseCirculationAndSupply(amount, from);\n    }\n  }\n\n  function _increaseCirculationAndSupply(uint256 amount, address minter) internal {\n    _vyCirculation += amount;\n\n    VYRevenueCycleCirculationTracker(minter).increaseRevenueCycleCirculation(amount);\n  }\n\n  function _decreaseCirculationAndSupply(uint256 amount, address minter) internal {\n    if (amount > _vyCirculation) {\n      _vyCirculation = 0;\n    } else {\n      _vyCirculation -= amount;\n    }\n\n    VYRevenueCycleCirculationTracker(minter).decreaseRevenueCycleCirculation(amount);\n  }\n\n  function _calculateTransferFee(address from, address to, uint256 amount) private view returns (uint256) {\n    // Check for user to user transfer\n    if (!_agents[from] && !_agents[to]) {\n      uint256 transferFee = amount * _transferFee / MULTIPLIER;\n      return transferFee;\n    }\n\n    return 0;\n  }\n\n  function _requireRegistrarIsUnfinalized(Registrar registrar) private view {\n    require(!registrar.isFinalized(), \"Registrar already finalized\");\n  }\n}"

    },

    "contracts/treasury/VETHYieldRateTreasury.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.18;\n\nimport { AdminGovernanceAgent } from \"../access/AdminGovernanceAgent.sol\";\nimport { Governable } from \"../governance/Governable.sol\";\nimport { VETHReverseStakingTreasury } from \"../VETHReverseStakingTreasury.sol\";\nimport { RegistrarClient } from \"../RegistrarClient.sol\";\n\ncontract VETHYieldRateTreasury is AdminGovernanceAgent, Governable, RegistrarClient {\n\n  address private _migration;\n  VETHReverseStakingTreasury private _vethReverseStakingTreasury;\n\n  event ReverseStakingTransfer(address recipient, uint256 amount);\n\n  constructor(\n    address registrarAddress,\n    address[] memory adminGovAgents\n  ) AdminGovernanceAgent(adminGovAgents)\n    RegistrarClient(registrarAddress) {\n  }\n\n  modifier onlyReverseStakingTreasury() {\n    require(address(_vethReverseStakingTreasury) == _msgSender(), \"Unauthorized\");\n    _;\n  }\n\n  function getYieldRateTreasuryValue() external view returns (uint256) {\n    return address(this).balance + _vethReverseStakingTreasury.getTotalClaimedYield();\n  }\n\n  function getMigration() external view returns (address) {\n    return _migration;\n  }\n\n  function setMigration(address destination) external onlyGovernance {\n    _migration = destination;\n  }\n\n  function transferMigration(uint256 amount) external onlyAdminGovAgents {\n    require(_migration != address(0), \"Migration not set\");\n    _transfer(_migration, amount, \"\");\n  }\n\n  function reverseStakingTransfer(address recipient, uint256 amount) external onlyReverseStakingTreasury {\n    _transfer(recipient, amount, \"\");\n    emit ReverseStakingTransfer(recipient, amount);\n  }\n\n  function reverseStakingRoute(address recipient, uint256 amount, bytes memory selector) external onlyReverseStakingTreasury {\n    _transfer(recipient, amount, selector);\n    emit ReverseStakingTransfer(recipient, amount);\n  }\n\n  function updateAddresses() external override onlyRegistrar {\n    _vethReverseStakingTreasury = VETHReverseStakingTreasury(payable(_registrar.getVETHReverseStakingTreasury()));\n    _updateGovernable(_registrar);\n  }\n\n  function _transfer(address recipient, uint256 amount, bytes memory payload) private {\n    require(address(this).balance >= amount, \"Insufficient balance\");\n    (bool sent,) = recipient.call{value: amount}(payload);\n    require(sent, \"Failed to send Ether\");\n  }\n\n  receive() external payable {}\n}"

    },

    "contracts/VETHReverseStakingTreasury.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.18;\n\nimport { BackendAgent } from \"./access/BackendAgent.sol\";\nimport { VYToken } from \"./token/VYToken.sol\";\nimport { VETHP2P } from \"./exchange/VETHP2P.sol\";\nimport { VETHRevenueCycleTreasury } from \"./exchange/VETHRevenueCycleTreasury.sol\";\nimport { VETHYieldRateTreasury } from \"./treasury/VETHYieldRateTreasury.sol\";\nimport { RegistrarClient } from \"./RegistrarClient.sol\";\nimport { AdminGovernanceAgent } from \"./access/AdminGovernanceAgent.sol\";\nimport { Governable } from \"./governance/Governable.sol\";\nimport { RegistrarMigrator } from \"./RegistrarMigrator.sol\";\nimport { Registrar } from \"./Registrar.sol\";\nimport { Router } from \"./Router.sol\";\n\ncontract VETHReverseStakingTreasury is BackendAgent, RegistrarClient, RegistrarMigrator, AdminGovernanceAgent, Governable {\n\n  uint256 private constant MINIMUM_REVERSE_STAKE_AUTOCLOSE = 100000000; // 0.1 gwei\n  uint256 private constant MULTIPLIER = 10**18;\n  uint256 private constant DAY_IN_SECONDS = 86400;\n  bytes private constant ROUTE_SELECTOR = abi.encode(bytes4(keccak256(\"route()\")));\n  uint256 private constant BURNACCRUEDVY_CACHE_DURATION = 6 hours;\n\n  // We use this to get around stack too deep errors.\n  struct TradeOfferVars {\n    uint256 maxInput;\n    uint256 ethFee;\n    uint256 vyFee;\n    uint256 vyOut;\n  }\n\n  struct CalcOfferRepayment {\n    uint256 effectiveETHPaidOff;\n    uint256 excessETH;\n    uint256 excessStakedVY;\n    uint256 vyToBurn;\n    bool isPaidOff;\n  }\n\n  struct RestakeVars {\n    uint256 newReverseStakeVY;\n    uint256 newReverseStakeClaimedYieldETH;\n    uint256 newReverseStakeId;\n    uint256 startAt;\n    uint256 vyToBurn;\n    uint256 processingFeeETH;\n    uint256 yieldPayout;\n    uint256[] reverseStakeIds;\n    uint256 vyYieldRate;\n  }\n\n  struct MigrateReverseStakeVars {\n    address borrowerAddress;\n    uint256 stakedVY;\n    uint256 originalClaimedYieldETH;\n    uint256 currentClaimedYieldETH;\n    uint256 yieldRate;\n    uint256 startAt;\n    uint256 lastPaidAt;\n    uint256 previousReverseStakeId;\n    uint256 termId;\n  }\n\n  uint256 public constant ETH_FEE = 20000000000000000;\n  uint256 public constant VY_FEE = 20000000000000000;\n  /// @dev 1.020409; Buffer to account for fee\n  uint256 public constant OFFER_PRICE_YR_RATIO = 1020409000000000000;\n  /// @dev 0.98; 2% left over to account for burn rate over lifespan of offer\n  uint256 public constant OFFER_NET_STAKE_RATIO = 980000000000000000;\n  uint256 public constant EXPIRES_IN = 30 days;\n  uint256 public constant MINIMUM_OFFER_AUTOCLOSE_IN_ETH = 500000000000000; // 0.0005 ETH\n  uint256 public constant MAX_RESTAKE_REVERSE_STAKES = 20;\n\n  VETHP2P private _vethP2P;\n  VETHRevenueCycleTreasury private _vethRevenueCycleTreasury;\n  VYToken private _vyToken;\n  VETHYieldRateTreasury private _vethYRT;\n  Router private _ethComptroller;\n  address private _migration;\n  uint256 private _reverseStakeTermsNonce = 0;\n  uint256 private _reverseStakesNonce = 0;\n  uint256 private _totalClaimedYieldETH = 0;\n  uint256 private _maxReverseStakes = 20;\n  uint256 private _burnAccruedVYYieldRate;\n  uint256 private _burnAccruedVYTimestamp;\n\n  // This contains the mutable reverse stake terms\n  struct ReverseStakeTerm {\n    uint256 dailyBurnRate;\n    uint256 minimumReverseStakeETH;\n    uint256 processingFeePercentage;\n    uint256 restakeMinimumPayout;\n  }\n\n  // This contains reverseStake info per user\n  struct ReverseStake {\n    uint256 termId;\n    uint256 stakedVY;\n    uint256 originalClaimedYieldETH;  // No longer used; kept for record-keeping\n    uint256 currentClaimedYieldETH;\n    uint256 yieldRate;                // No longer used; kept for record-keeping\n    uint256 startAt;\n    uint256 lastPaidAt;\n  }\n\n  struct Offer {\n    uint256 unfilledQuantity;\n    uint256 price;\n    uint256 maxClaimedYieldETH;  // ClaimedYield at the time offer is created\n    uint256 maxQuantity;         // Max quantity at the time offer is created\n    uint256 expiresAt;\n    bool isOpen;\n  }\n\n  mapping(uint256 => ReverseStakeTerm) private _reverseStakeTerms;\n  mapping(address => mapping(uint256 => ReverseStake)) private _reverseStakes;\n  mapping(address => uint256) private _openReverseStakes;\n  mapping(address => mapping(uint256 => Offer)) private _offers;\n\n  event CreateReverseStakeTerm(\n    uint256 termId,\n    uint256 dailyBurnRate,\n    uint256 minimumReverseStakeETH,\n    uint256 processingFeePercentage,\n    uint256 restakeMinimumPayout);\n  event CreateReverseStake(\n    address borrower,\n    uint256 reverseStakeId,\n    uint256 termId,\n    uint256 stakedVY,\n    uint256 originalClaimedYieldETH,\n    uint256 currentClaimedYieldETH,\n    uint256 yieldRate,\n    uint256 startAt);\n\n  event ReturnETHToUnstake(\n    address borrower,\n    uint256 reverseStakeId,\n    uint256 ethAmount,\n    uint256 currentClaimedYieldETH,\n    uint256 stakedVY,\n    uint256 stakedVYReturned,\n    uint256 burnRatePaid,\n    uint256 paidAt\n  );\n  event MigrateReverseStake(\n    address borrower,\n    uint256 reverseStakeId,\n    uint256 termId,\n    uint256 stakedVY,\n    uint256 originalClaimedYieldETH,\n    uint256 currentClaimedYieldETH,\n    uint256 yieldRate,\n    uint256 startAt,\n    uint256 previousReverseStakeId\n  );\n  event CloseReverseStake(address borrower, uint256 reverseStakeId, uint256 stakeTransferred);\n  event CreateOffer(address borrower, uint256 reverseStakeId, uint256 quantity, uint256 price, uint256 expiresAt, uint256 timestamp);\n  event TradeOffer(\n    address borrower,\n    uint256 reverseStakeId,\n    address buyer,\n    uint256 sellerQuantity,\n    uint256 buyerQuantity,\n    uint256 unfilledQuantity,\n    uint256 excessETH,\n    uint256 timestamp\n  );\n  event CloseOffer(address borrower, uint256 reverseStakeId, uint256 timestamp);\n  event Restake(\n    address borrower,\n    uint256 reverseStakeId,\n    uint256 stakedVY,\n    uint256 originalClaimedYieldETH,\n    uint256 currentClaimedYieldETH,\n    uint256 yieldRate,\n    uint256 startAt,\n    uint256 yieldPayout,\n    uint256[] previousReverseStakeIds,\n    uint256 burnRatePaid,\n    uint256 newTermId\n  );\n  event BurnAccruedVY(\n    address borrower,\n    uint256 reverseStakeId,\n    uint256 stakedVY,\n    uint256 burnRatePaid,\n    uint256 yieldRate\n  );\n\n  constructor(\n    address registrarAddress,\n    address ethComptrollerAddress_,\n    address[] memory adminGovAgents,\n    address[] memory backendAdminAgents,\n    address[] memory backendAgents,\n    address[] memory adminAgents\n  ) RegistrarClient(registrarAddress)\n    RegistrarMigrator(registrarAddress, uint(Registrar.Contract.VETHReverseStakingTreasury), adminAgents)\n    AdminGovernanceAgent(adminGovAgents) {\n    require(ethComptrollerAddress_ != address(0), \"Invalid address\");\n\n    _ethComptroller = Router(payable(ethComptrollerAddress_));\n    _setBackendAdminAgents(backendAdminAgents);\n    _setBackendAgents(backendAgents);\n  }\n\n  modifier onlyActiveReverseStake(address borrower, uint256 reverseStakeId) {\n    _checkValidReverseStake(_reverseStakes[borrower][reverseStakeId].startAt > 0);\n    _checkActiveReverseStake(isReverseStakeActive(borrower, reverseStakeId));\n    _;\n  }\n\n  modifier onlyActiveOffer(address borrower, uint256 reverseStakeId) {\n    require(_offers[borrower][reverseStakeId].isOpen && _offers[borrower][reverseStakeId].expiresAt > block.timestamp, \"Invalid offer\");\n    _;\n  }\n\n  modifier onlyOpenOffer(uint256 id, address borrower) {\n    require(_offers[borrower][id].isOpen, \"Offer must be open in order to close\");\n    _;\n  }\n\n  function setupInitialReverseStakeTerm(\n    uint256 dailyBurnRate,\n    uint256 minimumReverseStakeETH,\n    uint256 processingFeePercentage,\n    uint256 restakeMinimumPayout\n  ) external onlyBackendAdminAgents {\n    require(_reverseStakeTermsNonce == 0, \"Reverse stake terms already set up\");\n    _createNewReverseStakeTerm(\n      dailyBurnRate,\n      minimumReverseStakeETH,\n      processingFeePercentage,\n      restakeMinimumPayout\n    );\n  }\n\n  function createNewReverseStakeTerm(\n    uint256 dailyBurnRate,\n    uint256 minimumReverseStakeETH,\n    uint256 processingFeePercentage,\n    uint256 restakeMinimumPayout\n  ) external onlyGovernance {\n    _createNewReverseStakeTerm(\n      dailyBurnRate,\n      minimumReverseStakeETH,\n      processingFeePercentage,\n      restakeMinimumPayout\n    );\n  }\n\n  /**\n   * @dev Returns total claimed yield in ETH\n   */\n  function getTotalClaimedYield() external view returns (uint256) {\n    return _totalClaimedYieldETH;\n  }\n\n  function getReverseStake(address borrower, uint256 reverseStakeId) external view returns (ReverseStake memory) {\n    return _reverseStakes[borrower][reverseStakeId];\n  }\n\n  function isReverseStakeActive(address borrower, uint256 reverseStakeId) public view returns (bool) {\n    return _reverseStakes[borrower][reverseStakeId].currentClaimedYieldETH > 0;\n  }\n\n  function isOfferActive(address borrower, uint256 reverseStakeId) external view returns (bool) {\n    return _offers[borrower][reverseStakeId].isOpen && _offers[borrower][reverseStakeId].expiresAt > block.timestamp;\n  }\n\n  function getReverseStakeTerm(uint256 termId) external view returns (ReverseStakeTerm memory) {\n    return _reverseStakeTerms[termId];\n  }\n\n  function getCurrentReverseStakeTerm() external view returns (ReverseStakeTerm memory) {\n    return _reverseStakeTerms[_reverseStakeTermsNonce];\n  }\n\n  function getCurrentReverseStakeTermId() external view returns (uint256) {\n    return _reverseStakeTermsNonce;\n  }\n\n  function ethToBurn(address borrower, uint256 reverseStakeId) external view returns (uint256) {\n    return _ethToBurn(borrower, reverseStakeId);\n  }\n\n  function vyToBurn(address borrower, uint256 reverseStakeId) external view returns (uint256) {\n    return _vyToBurn(borrower, reverseStakeId);\n  }\n\n  function getStakedVYForReverseStakeETH(uint256 ethAmount) external view returns (uint256) {\n    return _getStakedVYForReverseStakeETH(ethAmount);\n  }\n\n  function getMaxReverseStakes() external view returns (uint256) {\n    return _maxReverseStakes;\n  }\n\n  function getReverseStakesNonce() external view returns (uint256) {\n    return _reverseStakesNonce;\n  }\n\n  function getBurnAccruedVYYieldRate() external view returns (uint256) {\n    return _burnAccruedVYYieldRate;\n  }\n\n  function getBurnAccruedVYTimestamp() external view returns (uint256) {\n    return _burnAccruedVYTimestamp;\n  }\n\n  function setMaxReverseStakes(uint256 maxReverseStakes_) external onlyBackendAdminAgents {\n    _maxReverseStakes = maxReverseStakes_;\n  }\n\n  function getMigration() external view returns (address) {\n    return _migration;\n  }\n\n  function setMigration(address destination) external onlyGovernance {\n    _migration = destination;\n  }\n\n  function transferMigration(uint256 amount) external onlyAdminGovAgents {\n    require(_migration != address(0), \"Migration not set\");\n    _checkSufficientBalance(_vyToken.balanceOf(address(this)) >= amount);\n    _transferVY(_migration, amount);\n  }\n\n  function createReverseStake(uint256 termId, uint256 ethAmount, uint256 vyAmount) external {\n    require(_vyToken.allowance(_msgSender(), address(this)) >= vyAmount, \"Insufficient allowance\");\n    require(_vyToken.balanceOf(_msgSender()) >= vyAmount, \"Insufficient balance\");\n    uint256 minStake = _createReverseStakePrerequisite(termId, ethAmount, vyAmount);\n\n    _createReverseStake(ethAmount, minStake);\n  }\n\n  function createReverseStake(uint256 termId, uint256 ethAmount, uint256 vyAmount, uint8 v, bytes32 r, bytes32 s) external {\n    uint256 minStake = _createReverseStakePrerequisite(termId, ethAmount, vyAmount);\n\n    // Call approval\n    _vyToken.permit(_msgSender(), address(this), vyAmount, v, r, s);\n    _createReverseStake(ethAmount, minStake);\n  }\n\n  function _createReverseStake(uint256 ethAmount, uint256 stakedVY) private {\n    ReverseStakeTerm memory reverseStakeTerm = _reverseStakeTerms[_reverseStakeTermsNonce];\n    require(ethAmount >= reverseStakeTerm.minimumReverseStakeETH, \"Minimum reverse stake ETH not met\");\n\n    uint256 circulation = _vethRevenueCycleTreasury.getVETHCirculation();\n    require(_vyToken.balanceOf(address(this)) + stakedVY <= circulation, \"Total staked VY cannot exceed circulation\");\n\n    uint256 reverseStakeId = ++_reverseStakesNonce;\n    uint256 ethComptrollerReceives = ethAmount * reverseStakeTerm.processingFeePercentage / MULTIPLIER;\n    uint256 borrowerReceives = ethAmount - ethComptrollerReceives;\n    uint256 startAt = block.timestamp;\n    uint256 vyYieldRate = _vethRevenueCycleTreasury.getYieldRate();\n\n    _reverseStakes[_msgSender()][reverseStakeId] = ReverseStake(_reverseStakeTermsNonce, stakedVY, ethAmount, ethAmount, vyYieldRate, startAt, 0);\n    _openReverseStakes[_msgSender()]++;\n\n    _totalClaimedYieldETH += ethAmount;\n    _vyToken.transferFrom(_msgSender(), address(this), stakedVY);\n    _vethYRT.reverseStakingTransfer(_msgSender(), borrowerReceives);\n    _vethYRT.reverseStakingRoute(address(_ethComptroller), ethComptrollerReceives, ROUTE_SELECTOR);\n\n    emit CreateReverseStake(_msgSender(), reverseStakeId, _reverseStakeTermsNonce, stakedVY, ethAmount, ethAmount, vyYieldRate, startAt);\n  }\n\n  function returnETHToUnstake(uint256 reverseStakeId) external payable onlyActiveReverseStake(_msgSender(), reverseStakeId) {\n    require(msg.value > 0, \"Zero ETH amount sent\");\n    _checkActiveOffer(_offers[_msgSender()][reverseStakeId].isOpen);\n\n    ReverseStake storage reverseStake = _reverseStakes[_msgSender()][reverseStakeId];\n    uint256 vyToBurn_ = _vyToBurn(_msgSender(), reverseStakeId);\n    require(reverseStake.stakedVY >= vyToBurn_, \"Not enough staked VY to burn\");\n    reverseStake.stakedVY -= vyToBurn_;\n\n    uint256 excessETH = 0;\n    uint256 stakedVYReturned = 0;\n    uint256 ethAmount = msg.value;\n\n    if (ethAmount > reverseStake.currentClaimedYieldETH) {\n      excessETH = ethAmount - reverseStake.currentClaimedYieldETH;\n      ethAmount = reverseStake.currentClaimedYieldETH;\n    }\n\n    if (reverseStake.currentClaimedYieldETH == ethAmount) {\n      stakedVYReturned = reverseStake.stakedVY;\n      _decrementOpenReverseStakesAndCloseOffer(_msgSender(), reverseStakeId, 0);\n    } else {\n      stakedVYReturned = reverseStake.stakedVY * ethAmount / reverseStake.currentClaimedYieldETH;\n    }\n\n    reverseStake.currentClaimedYieldETH -= ethAmount;\n    reverseStake.stakedVY -= stakedVYReturned;\n    reverseStake.lastPaidAt = block.timestamp;\n\n    _totalClaimedYieldETH -= ethAmount;\n    _transferToRevenueCycleTreasury(vyToBurn_);\n    _transferVY(_msgSender(), stakedVYReturned);\n\n    _transfer(address(_vethYRT), ethAmount);\n\n    if (excessETH > 0) {\n      _transfer(_msgSender(), excessETH);\n    }\n\n    emit ReturnETHToUnstake(\n      _msgSender(),\n      reverseStakeId,\n      ethAmount,\n      reverseStake.currentClaimedYieldETH,\n      reverseStake.stakedVY,\n      stakedVYReturned,\n      vyToBurn_,\n      reverseStake.lastPaidAt\n    );\n  }\n\n  function restake(uint256[] memory reverseStakeIds) external {\n    address borrower = _msgSender();\n    require(reverseStakeIds.length > 0 && reverseStakeIds.length <= MAX_RESTAKE_REVERSE_STAKES, \"Invalid number of reverseStakes\");\n\n    uint256 totalCurrentClaimedYieldETH;\n    RestakeVars memory reverseStakeData = RestakeVars(0, 0, 0, 0, 0, 0, 0, new uint256[](reverseStakeIds.length), 0);\n\n    // Sum all VYs to burn and principals + close reverseStakes\n    for (uint i = 0; i < reverseStakeIds.length; i++) {\n      uint256 reverseStakeId = reverseStakeIds[i];\n      reverseStakeData.reverseStakeIds[i] = reverseStakeId;\n\n      // Requirements\n      _checkValidReverseStake(_reverseStakes[borrower][reverseStakeId].startAt > 0);\n      _checkActiveReverseStake(isReverseStakeActive(borrower, reverseStakeId));\n      _checkActiveOffer(_offers[borrower][reverseStakeId].isOpen);\n\n      ReverseStake storage reverseStake = _reverseStakes[borrower][reverseStakeId];\n\n      // Sum VY to burn\n      uint256 vyToBurn_ = _vyToBurn(borrower, reverseStakeId); // Calculate VY to burn\n      reverseStakeData.vyToBurn += vyToBurn_;\n\n      // Sum principal after VY to burn\n      require(reverseStake.stakedVY >= vyToBurn_, \"Not enough staked VY to burn\");\n      uint256 newReverseStakeVY = reverseStake.stakedVY - vyToBurn_;\n      reverseStakeData.newReverseStakeVY += newReverseStakeVY;\n\n      // Close reverseStake\n      totalCurrentClaimedYieldETH += reverseStake.currentClaimedYieldETH;\n      reverseStake.stakedVY = 0;\n      reverseStake.currentClaimedYieldETH = 0;\n      if (_openReverseStakes[borrower] > 0) {\n        _openReverseStakes[borrower]--;\n      }\n    }\n\n    // Create new reverseStake\n    reverseStakeData.vyYieldRate = _vethRevenueCycleTreasury.getYieldRate();\n    reverseStakeData.newReverseStakeClaimedYieldETH = reverseStakeData.newReverseStakeVY * MULTIPLIER / reverseStakeData.vyYieldRate; // Calculate new reverseStake principal\n    reverseStakeData.newReverseStakeId = ++_reverseStakesNonce;\n    reverseStakeData.startAt = block.timestamp;\n    _reverseStakes[borrower][reverseStakeData.newReverseStakeId] = ReverseStake(\n      _reverseStakeTermsNonce,                            // termId\n      reverseStakeData.newReverseStakeVY,                 // stakedVY\n      reverseStakeData.newReverseStakeClaimedYieldETH,    // originalClaimedYieldETH\n      reverseStakeData.newReverseStakeClaimedYieldETH,    // currentClaimedYieldETH\n      reverseStakeData.vyYieldRate,                       // yieldRate\n      reverseStakeData.startAt,                           // startAt\n      0);                                                 // lastPaidAt\n    _openReverseStakes[borrower]++;\n\n    // Update totalClaimedYield\n    require(reverseStakeData.newReverseStakeClaimedYieldETH >= totalCurrentClaimedYieldETH, \"Restaked reverseStakes must increase in value\");\n    reverseStakeData.yieldPayout = reverseStakeData.newReverseStakeClaimedYieldETH - totalCurrentClaimedYieldETH;\n    _totalClaimedYieldETH += reverseStakeData.yieldPayout;\n\n    // Processing fee\n    reverseStakeData.processingFeeETH = reverseStakeData.yieldPayout * _reverseStakeTerms[_reverseStakeTermsNonce].processingFeePercentage / MULTIPLIER;\n\n    // Yield payout\n    require(reverseStakeData.yieldPayout >= _reverseStakeTerms[_reverseStakeTermsNonce].restakeMinimumPayout, \"Minimum yield payout not met\");\n    reverseStakeData.yieldPayout -= reverseStakeData.processingFeeETH;\n\n    // Transfers\n    _vethYRT.reverseStakingTransfer(borrower, reverseStakeData.yieldPayout);\n    _vethYRT.reverseStakingRoute(address(_ethComptroller), reverseStakeData.processingFeeETH, ROUTE_SELECTOR);\n    _transferToRevenueCycleTreasury(reverseStakeData.vyToBurn);\n\n    emit Restake(\n      borrower,                                           // borrower\n      reverseStakeData.newReverseStakeId,                 // reverseStakeId\n      reverseStakeData.newReverseStakeVY,                 // stakedVY\n      reverseStakeData.newReverseStakeClaimedYieldETH,    // originalClaimedYieldETH\n      reverseStakeData.newReverseStakeClaimedYieldETH,    // currentClaimedYieldETH\n      reverseStakeData.vyYieldRate,                       // yieldRate\n      reverseStakeData.startAt,                           // startAt\n      reverseStakeData.yieldPayout,                       // yieldPayout\n      reverseStakeData.reverseStakeIds,                   // previousReverseStakeIds\n      reverseStakeData.vyToBurn,                          // burnRatePaid\n      _reverseStakeTermsNonce                             // newTermId\n    );\n  }\n\n  function burnAccruedVY(address[] memory borrowers, uint256[] memory reverseStakeIds) external onlyBackendAgents {\n    require(borrowers.length == reverseStakeIds.length, \"Argument array length mismatch\");\n\n    if (block.timestamp > _burnAccruedVYTimestamp + BURNACCRUEDVY_CACHE_DURATION) {\n      // Update cache\n      _burnAccruedVYYieldRate = _vethRevenueCycleTreasury.getYieldRate();\n      _burnAccruedVYTimestamp = block.timestamp;\n    }\n\n    uint256 totalVYToBurn;\n    for (uint i = 0; i < reverseStakeIds.length; i++) {\n      uint256 reverseStakeId = reverseStakeIds[i];\n      address borrower = borrowers[i];\n      ReverseStake storage reverseStake = _reverseStakes[borrower][reverseStakeId];\n\n      // Requirements\n      _checkValidReverseStake(reverseStake.startAt > 0);\n      if (!isReverseStakeActive(borrower, reverseStakeId)) {\n        continue;\n      }\n\n      // Calculate burn using cached yield rate\n      uint256 vyToBurn_ = _vyToBurn(borrower, reverseStakeId, _burnAccruedVYYieldRate);\n      if (vyToBurn_ == 0) {\n        continue;\n      }\n\n      uint256 burnRatePaid = vyToBurn_;\n      if (reverseStake.stakedVY <= vyToBurn_) {\n        burnRatePaid = reverseStake.stakedVY;\n\n        // Before closing make sure reverse stake is still open\n        require(reverseStake.stakedVY > 0 && reverseStake.currentClaimedYieldETH > 0, \"ReverseStake is already closed\");\n\n        // Update total claimed yield as part of closing\n        _totalClaimedYieldETH -= reverseStake.currentClaimedYieldETH;\n\n        // Update reverseStake and offer (if any) upon closing\n        _decrementOpenReverseStakesAndCloseOffer(borrower, reverseStakeId, reverseStake.stakedVY);\n        reverseStake.stakedVY = 0;\n        reverseStake.currentClaimedYieldETH = 0;\n      } else {\n        reverseStake.stakedVY -= vyToBurn_;\n        reverseStake.lastPaidAt = block.timestamp;\n      }\n\n      totalVYToBurn += burnRatePaid;\n      emit BurnAccruedVY(borrower, reverseStakeId, reverseStake.stakedVY, burnRatePaid, _burnAccruedVYYieldRate);\n    }\n\n    // Transfer totalVYToBurn outside of loop instead of transferring vyToBurn each time within the for loop.\n    // This is to avoid a yield rate change affecting subsequent vyToBurn calculations within the for loop.\n    _transferToRevenueCycleTreasury(totalVYToBurn);\n  }\n\n  function createOffer(uint256 reverseStakeId, uint256 quantity, uint256 price) external onlyActiveReverseStake(_msgSender(), reverseStakeId) {\n    _checkValidQuantity(quantity);\n    require(!_offers[_msgSender()][reverseStakeId].isOpen, \"Limit one offer per reverseStake\");\n\n    ReverseStake memory reverseStake = _reverseStakes[_msgSender()][reverseStakeId];\n\n    // OFFER_NET_STAKE_RATIO\n    uint256 vyToBurn_ = _vyToBurn(_msgSender(), reverseStakeId);\n    require(reverseStake.stakedVY >= vyToBurn_, \"Not enough staked VY\");\n    uint256 maximumQuantity = (reverseStake.stakedVY - vyToBurn_) * OFFER_NET_STAKE_RATIO / MULTIPLIER;\n    require(quantity <= maximumQuantity, \"Quantity exceeds limit\");\n\n    // We're creating a [VY_ETH] offer:\n    // min price = (current claimed yield / (remaining staked VY after burned VY * 0.98)) * 1.020409\n    uint256 minPrice = reverseStake.currentClaimedYieldETH * OFFER_PRICE_YR_RATIO / maximumQuantity;\n    _checkMinPrice(price >= minPrice);\n\n    // As yieldRate gets lower, actual \"price\" gets higher due to inversion\n    // adjustedYieldRate = yield rate / 1.020409\n    uint256 adjustedYieldRate = _vethRevenueCycleTreasury.getYieldRate() * MULTIPLIER / OFFER_PRICE_YR_RATIO;\n    require((MULTIPLIER * MULTIPLIER / price) <= adjustedYieldRate, \"Price too low\");\n\n    // Set offer expiration\n    uint256 expiresAt = block.timestamp + EXPIRES_IN;\n\n    // Create offer\n    _offers[_msgSender()][reverseStakeId] = Offer(quantity, price, reverseStake.currentClaimedYieldETH, maximumQuantity, expiresAt, true);\n\n    emit CreateOffer(_msgSender(), reverseStakeId, quantity, price, expiresAt, block.timestamp);\n  }\n\n  /**\n   * @dev This is for other members to trade on the offer the borrower created\n   */\n  function tradeOffer(address borrower, uint256 reverseStakeId) external payable onlyActiveOffer(borrower, reverseStakeId) {\n    _checkValidQuantity(msg.value);\n\n    Offer storage offer = _offers[borrower][reverseStakeId];\n    ReverseStake storage reverseStake = _reverseStakes[borrower][reverseStakeId];\n\n    TradeOfferVars memory info;\n    info.maxInput = offer.unfilledQuantity * offer.price / MULTIPLIER;\n    _checkEnoughAmountToSell(msg.value <= info.maxInput);\n\n    info.ethFee = msg.value * ETH_FEE / MULTIPLIER;\n    info.vyFee = msg.value * VY_FEE / offer.price;\n\n    info.vyOut = msg.value * MULTIPLIER / offer.price;\n\n    // Calculate and update reverseStake\n    CalcOfferRepayment memory calc = _payReverseStakeVY(\n      borrower,\n      reverseStakeId,\n      info.vyOut,\n      offer.maxClaimedYieldETH,\n      offer.maxQuantity,\n      msg.value - info.ethFee\n    );\n\n    // Update offer\n    if (!calc.isPaidOff) {\n      if (info.vyOut > offer.unfilledQuantity) {\n        info.vyOut = offer.unfilledQuantity;\n      }\n      offer.unfilledQuantity -= info.vyOut;\n\n      // If remaining quantity is low enough, close it out\n      // VY_ETH market - converted selling amount in VY to ETH < MINIMUM_OFFER_AUTOCLOSE_IN_ETH\n      bool takerCloseout = (offer.unfilledQuantity * offer.price / MULTIPLIER) < MINIMUM_OFFER_AUTOCLOSE_IN_ETH;\n\n      // console.log(\"unfilledQuantity: %s, takerCloseout: %s, amount: %s\", offer.unfilledQuantity, takerCloseout, offer.unfilledQuantity * offer.price / MULTIPLIER);\n\n      if (takerCloseout) {\n        // Auto-close when selling amount in ETH < MINIMUM_OFFER_AUTOCLOSE_IN_ETH\n        // No need to return VY from offer, since it was reserving\n        // the VY directly from borrower's stakedVY pool.\n        _closeOffer(borrower, reverseStakeId);\n      }\n    }\n\n    _totalClaimedYieldETH -= calc.effectiveETHPaidOff;\n\n    // Send out VY fee + VY to burn.\n    // Note that we have 2% VY buffer in the staked VY, as\n    // the offer can only be created with 98% of staked VY max.\n    _transferToRevenueCycleTreasury(info.vyFee + calc.vyToBurn);\n\n    // Send out VY to buyer\n    _transferVY(_msgSender(), info.vyOut - info.vyFee);\n\n    // Send out ETH fee\n    _ethComptroller.route{ value: info.ethFee }();\n\n    // Send out to VETHYieldRateTreasury\n    _transfer(address(_vethYRT), msg.value - calc.excessETH - info.ethFee);\n    if (calc.excessETH > 0) {\n      // Send excess to borrower\n      _transfer(borrower, calc.excessETH);\n    }\n\n    if (calc.excessStakedVY > 0) {\n      // Return excess VY to borrower (if any) once reverseStake is repaid in full\n      _transferVY(borrower, calc.excessStakedVY);\n    }\n\n    emit TradeOffer(borrower, reverseStakeId, _msgSender(), info.vyOut, msg.value, offer.unfilledQuantity, calc.excessETH, reverseStake.lastPaidAt);\n    emit ReturnETHToUnstake(\n      borrower,\n      reverseStakeId,\n      calc.effectiveETHPaidOff,\n      reverseStake.currentClaimedYieldETH,\n      reverseStake.stakedVY,\n      0,\n      calc.vyToBurn,\n      reverseStake.lastPaidAt\n    );\n  }\n\n  /**\n   * @dev This is for the borrower to sell their staked VY to other users\n   */\n  function tradeStakedVY(uint256 reverseStakeId, uint256 offerId, address seller, uint256 amountVY) external onlyActiveReverseStake(_msgSender(), reverseStakeId) {\n    _tradeStakedVYPrerequisite(reverseStakeId, amountVY);\n\n    ReverseStake storage reverseStake = _reverseStakes[_msgSender()][reverseStakeId];\n    // We are trading on a member's [ETH_VY] offer, so their price will be VY/ETH.\n    VETHP2P.Offer memory offer = _vethP2P.getOffer(offerId, seller);\n    require(offer.isOpen == true && offer.quantity > 0, \"Offer is closed or has zero quantity\");\n\n    uint256 vyToBurn_ = _vyToBurn(_msgSender(), reverseStakeId);\n\n    // min price formula = (current claimed yield / remaining staked VY after burned VY) * 1.020409\n    // In this case it's actually max price due to inversion.\n    uint256 maxPrice = reverseStake.currentClaimedYieldETH * OFFER_PRICE_YR_RATIO / (reverseStake.stakedVY - vyToBurn_);\n    maxPrice = MULTIPLIER * MULTIPLIER / maxPrice;\n    _checkMinPrice(offer.price <= maxPrice);\n\n    _vyToken.approve(address(_vethP2P), amountVY);\n\n    // Calculate (estimate) and update state first\n    VETHP2P.TradeOfferCalcInfo memory calc = _vethP2P.estimateTradeOffer(offerId, seller, amountVY);\n    CalcOfferRepayment memory reverseStakeCalcs = _payReverseStakeVY(\n      _msgSender(),\n      reverseStakeId,\n      amountVY,\n      reverseStake.currentClaimedYieldETH,\n      reverseStake.stakedVY - vyToBurn_,\n      calc.amountOut - calc.takerFee\n    );\n\n    // This needs to be updated last (but before transfers)\n    // as this affects the yield rate.\n    _totalClaimedYieldETH -= reverseStakeCalcs.effectiveETHPaidOff;\n\n    // Execute actual swap\n    VETHP2P.TradeOfferCalcInfo memory realCalc = _vethP2P.tradeOffer(offerId, seller, amountVY);\n    require(calc.amountOut == realCalc.amountOut, \"amountOut does not match\");\n\n    // Send out funds post-swap\n    _transferToRevenueCycleTreasury(reverseStakeCalcs.vyToBurn);\n\n    _transfer(address(_vethYRT), realCalc.amountOut - reverseStakeCalcs.excessETH - realCalc.takerFee);\n    if (reverseStakeCalcs.excessETH > 0) {\n      // Send excess to borrower\n      _transfer(_msgSender(), reverseStakeCalcs.excessETH);\n    }\n\n    if (reverseStakeCalcs.excessStakedVY > 0) {\n      // Return excess VY to borrower (if any) once reverseStake is repaid in full\n      _transferVY(_msgSender(), reverseStakeCalcs.excessStakedVY);\n    }\n\n    emit ReturnETHToUnstake(\n      _msgSender(),\n      reverseStakeId,\n      reverseStakeCalcs.effectiveETHPaidOff,\n      reverseStake.currentClaimedYieldETH,\n      reverseStake.stakedVY,\n      0,\n      reverseStakeCalcs.vyToBurn,\n      reverseStake.lastPaidAt\n    );\n  }\n\n  function closeOffer(uint256 reverseStakeId) external onlyOpenOffer(reverseStakeId, _msgSender()) {\n    _closeOffer(_msgSender(), reverseStakeId);\n  }\n\n  function closeOffer(address borrower, uint256 reverseStakeId) external onlyOpenOffer(reverseStakeId, borrower) onlyBackendAgents {\n    _closeOffer(borrower, reverseStakeId);\n  }\n\n  function getOffer(address borrower, uint256 reverseStakeId) external view returns (Offer memory) {\n    return _offers[borrower][reverseStakeId];\n  }\n\n  function updateAddresses() external override onlyRegistrar {\n    _vethP2P = VETHP2P(_registrar.getVETHP2P());\n    _vethRevenueCycleTreasury = VETHRevenueCycleTreasury(_registrar.getVETHRevenueCycleTreasury());\n    _vyToken = VYToken(_registrar.getVYToken());\n    _vethYRT = VETHYieldRateTreasury(payable(_registrar.getVETHYieldRateTreasury()));\n    _updateGovernable(_registrar);\n  }\n\n  function _migrateReverseStake(\n    address borrowerAddress,\n    uint256 stakedVY,\n    uint256 originalClaimedYieldETH,\n    uint256 currentClaimedYieldETH,\n    uint256 yieldRate,\n    uint256 startAt,\n    uint256 lastPaidAt,\n    uint256 previousReverseStakeId,\n    uint256 termId\n  ) private {\n    require(startAt > 0, \"Previous reverseStake invalid\");\n\n    uint256 reverseStakeId = ++_reverseStakesNonce;\n    _reverseStakes[borrowerAddress][reverseStakeId] = ReverseStake(termId, stakedVY, originalClaimedYieldETH, currentClaimedYieldETH, yieldRate, startAt, lastPaidAt);\n    _openReverseStakes[borrowerAddress]++;\n    _totalClaimedYieldETH += currentClaimedYieldETH;\n\n    emit MigrateReverseStake(borrowerAddress, reverseStakeId, termId, stakedVY, originalClaimedYieldETH, currentClaimedYieldETH, yieldRate, startAt, previousReverseStakeId);\n  }\n\n  function migrateReverseStakes(\n    MigrateReverseStakeVars[] calldata reverseStakeDataArray\n  ) external onlyBackendAgents onlyUnfinalized {\n    for (uint i = 0; i < reverseStakeDataArray.length; i++) {\n      _migrateReverseStake(\n        reverseStakeDataArray[i].borrowerAddress,\n        reverseStakeDataArray[i].stakedVY,\n        reverseStakeDataArray[i].originalClaimedYieldETH,\n        reverseStakeDataArray[i].currentClaimedYieldETH,\n        reverseStakeDataArray[i].yieldRate,\n        reverseStakeDataArray[i].startAt,\n        reverseStakeDataArray[i].lastPaidAt,\n        reverseStakeDataArray[i].previousReverseStakeId,\n        reverseStakeDataArray[i].termId\n      );\n    }\n  }\n\n  function _createNewReverseStakeTerm(\n    uint256 dailyBurnRate,\n    uint256 minimumReverseStakeETH,\n    uint256 processingFeePercentage,\n    uint256 restakeMinimumPayout\n  ) private {\n    _reverseStakeTerms[++_reverseStakeTermsNonce] = ReverseStakeTerm(\n      dailyBurnRate,\n      minimumReverseStakeETH,\n      processingFeePercentage,\n      restakeMinimumPayout\n    );\n\n    emit CreateReverseStakeTerm(\n      _reverseStakeTermsNonce,\n      dailyBurnRate,\n      minimumReverseStakeETH,\n      processingFeePercentage,\n      restakeMinimumPayout\n    );\n  }\n\n  function _getStakedVYForReverseStakeETH(uint256 ethAmount) private view returns (uint256) {\n    uint256 vyYieldRate = _vethRevenueCycleTreasury.getYieldRate();\n    return vyYieldRate * ethAmount / MULTIPLIER;\n  }\n\n  // rounding down basis, meaning for 11.6 days borrower will burn VY for 11 days\n  // we have to account for the case where borrower might pay at 11.6 days and another payment at 20.4 days\n  // because 20.4-11.6 = 8.8 days we cannot calculate directly otherwise 11+8 = 19 days of burn rate instead of 20\n  // therefore we have to look at the number of days in total minus the number of days borrower has paid\n  function _daysElapsed(uint256 startAt, uint256 lastPaidAt) private view returns (uint256) {\n    uint256 currentTime = block.timestamp;\n    if (lastPaidAt > 0) {\n      uint256 daysTotal = (currentTime - startAt) / DAY_IN_SECONDS;\n      uint256 daysPaid = (lastPaidAt - startAt) / DAY_IN_SECONDS;\n      return daysTotal - daysPaid;\n    } else {\n      return (currentTime - startAt) / DAY_IN_SECONDS;\n    }\n  }\n\n  function _ethToBurn(address borrower, uint256 reverseStakeId) private view returns (uint256) {\n    ReverseStake memory reverseStake = _reverseStakes[borrower][reverseStakeId];\n    ReverseStakeTerm memory reverseStakeTerm = _reverseStakeTerms[reverseStake.termId];\n    uint256 daysElapsed = _daysElapsed(reverseStake.startAt, reverseStake.lastPaidAt);\n\n    return reverseStake.currentClaimedYieldETH * reverseStakeTerm.dailyBurnRate * daysElapsed / MULTIPLIER;\n  }\n\n  function _vyToBurn(address borrower, uint256 reverseStakeId) private view returns (uint256) {\n    uint256 ethToBurn_ = _ethToBurn(borrower, reverseStakeId);\n    uint256 vyYieldRate = _vethRevenueCycleTreasury.getYieldRate();\n\n    return ethToBurn_ * vyYieldRate / MULTIPLIER;\n  }\n\n  function _vyToBurn(address borrower, uint256 reverseStakeId, uint256 vyYieldRate) private view returns (uint256) {\n    uint256 ethToBurn_ = _ethToBurn(borrower, reverseStakeId);\n    return ethToBurn_ * vyYieldRate / MULTIPLIER;\n  }\n\n  /**\n   * @dev Pay off reverseStake by selling staked VY\n   */\n  function _payReverseStakeVY(address borrower, uint256 reverseStakeId, uint256 vyToTrade, uint256 maxClaimedYieldETH, uint256 maxVY, uint256 amountETH) private returns (CalcOfferRepayment memory) {\n    ReverseStake storage reverseStake = _reverseStakes[borrower][reverseStakeId];\n\n    CalcOfferRepayment memory calc;\n\n    // uint256 percentagePaidOff = vyToTrade * MULTIPLIER / maxVY;\n    // calc.effectiveETHPaidOff = percentagePaidOff * maxClaimedYieldETH / MULTIPLIER;\n    calc.effectiveETHPaidOff = vyToTrade * maxClaimedYieldETH / maxVY;\n    if (amountETH > calc.effectiveETHPaidOff) {\n      calc.excessETH = amountETH - calc.effectiveETHPaidOff;\n    }\n    calc.vyToBurn = _vyToBurn(borrower, reverseStakeId);\n\n    // console.log(\"vyToTrade: %s\\npercentagePaidOff: %s\\neffectiveETHPaidOff: %s\", vyToTrade, percentagePaidOff, calc.effectiveETHPaidOff);\n    // console.log(\"excessETH: %s\\nvyToBurn: %s\\nstake: %s\", calc.excessETH, calc.vyToBurn, reverseStake.stakedVY);\n    // console.log(\"amountETH: %s\", amountETH);\n\n    // Update reverseStake\n    require(reverseStake.stakedVY >= vyToTrade + calc.vyToBurn, \"Not enough staked VY\");\n    reverseStake.stakedVY -= vyToTrade + calc.vyToBurn;\n\n    // Handle possible precision issues\n    if (calc.effectiveETHPaidOff > reverseStake.currentClaimedYieldETH) {\n      calc.effectiveETHPaidOff = reverseStake.currentClaimedYieldETH;\n    }\n    if (reverseStake.currentClaimedYieldETH > calc.effectiveETHPaidOff &&\n      (reverseStake.currentClaimedYieldETH - calc.effectiveETHPaidOff <= MINIMUM_REVERSE_STAKE_AUTOCLOSE)) {\n      calc.effectiveETHPaidOff = reverseStake.currentClaimedYieldETH;\n    }\n\n    // ReverseStake paid off?\n    if (calc.effectiveETHPaidOff == reverseStake.currentClaimedYieldETH) {\n      calc.isPaidOff = true;\n      _decrementOpenReverseStakesAndCloseOffer(borrower, reverseStakeId, 0);\n\n      // If there is any remaining staked VY, record that\n      // so we can later return it to borrower.\n      if (reverseStake.stakedVY > 0) {\n        calc.excessStakedVY = reverseStake.stakedVY;\n        reverseStake.stakedVY = 0;\n      }\n    }\n\n    // Update rest of reverseStake\n    reverseStake.currentClaimedYieldETH -= calc.effectiveETHPaidOff;\n    reverseStake.lastPaidAt = block.timestamp;\n\n    // console.log(\"currentClaimedYieldETH: %s, excessStakedVY: %s\", reverseStake.currentClaimedYieldETH, calc.excessStakedVY);\n    // console.log(\"stakedVY: %s\", reverseStake.stakedVY);\n\n    return calc;\n  }\n\n  function _createReverseStakePrerequisite(uint256 termId, uint256 ethAmount, uint256 vyAmount) private view returns (uint256) {\n    require(termId == _reverseStakeTermsNonce, \"Invalid reverse stake term specified\");\n    require(_openReverseStakes[_msgSender()] < _maxReverseStakes, \"Maximum reverse stakes reached\");\n    uint256 minStake = _getStakedVYForReverseStakeETH(ethAmount);\n    require(vyAmount >= minStake, \"vyAmount too low based on yield rate\");\n\n    return minStake;\n  }\n\n  function _tradeStakedVYPrerequisite(uint256 reverseStakeId, uint256 amountVY) private view {\n    _checkValidQuantity(amountVY);\n    Offer memory offer = _offers[_msgSender()][reverseStakeId];\n    _checkActiveOffer(offer.isOpen);\n    ReverseStake memory reverseStake = _reverseStakes[_msgSender()][reverseStakeId];\n    uint256 vyToBurn_ = _vyToBurn(_msgSender(), reverseStakeId);\n    require(reverseStake.stakedVY >= vyToBurn_, \"Not enough staked VY\");\n    uint256 remainingStake = reverseStake.stakedVY - vyToBurn_;\n    _checkEnoughAmountToSell(amountVY <= remainingStake);\n  }\n\n  function _transferToRevenueCycleTreasury(uint256 amount) private {\n    _transferVY(address(_vethRevenueCycleTreasury), amount);\n  }\n\n  function _decrementOpenReverseStakesAndCloseOffer(address borrower, uint256 reverseStakeId, uint256 stakeTransferred) internal {\n    if (_openReverseStakes[borrower] > 0) {\n      _openReverseStakes[borrower]--;\n    }\n    if (_offers[borrower][reverseStakeId].isOpen) {\n      _closeOffer(borrower, reverseStakeId);\n    }\n    emit CloseReverseStake(borrower, reverseStakeId, stakeTransferred);\n  }\n\n  function _closeOffer(address borrower, uint256 reverseStakeId) internal {\n    delete _offers[borrower][reverseStakeId];\n    emit CloseOffer(borrower, reverseStakeId, block.timestamp);\n  }\n\n  function _transferVY(address recipient, uint256 amount) private {\n    if (amount > 0) {\n      _vyToken.transfer(recipient, amount);\n    }\n  }\n\n  function _checkActiveOffer(bool isOpen) private pure {\n    require(!isOpen, \"Active offer found\");\n  }\n\n  function _checkMinPrice(bool minPriceMet) private pure {\n    require(minPriceMet, \"Minimum price not met\");\n  }\n\n  function _checkValidQuantity(uint256 amount) private pure {\n    require(amount > 0, \"Invalid quantity\");\n  }\n\n  function _checkEnoughAmountToSell(bool isEnough) private pure {\n    require(isEnough, \"Not enough to sell\");\n  }\n\n  function _checkSufficientBalance(bool isufficient) private pure {\n    require(isufficient, \"Insufficient balance\");\n  }\n\n  function _checkValidReverseStake(bool isValid) private pure {\n    require(isValid, \"Invalid reverseStake\");\n  }\n\n  function _checkActiveReverseStake(bool isActive) private pure {\n    require(isActive, \"ReverseStake is not active\");\n  }\n\n  function _transfer(address recipient, uint256 amount) private {\n    (bool sent,) = recipient.call{value: amount}(\"\");\n    require(sent, \"Failed to send Ether\");\n  }\n\n  receive() external payable {}\n}\n"

    }

  },

  "settings": {

    "optimizer": {

      "enabled": true,

      "runs": 1000

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    }

  }

}}