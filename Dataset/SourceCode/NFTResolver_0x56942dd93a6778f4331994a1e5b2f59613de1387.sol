{{

  "language": "Solidity",

  "sources": {

    "NFTResolver.sol": {

      "content": "/// @author raffy.eth\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.18;\r\n\r\nimport {Ownable} from \"@openzeppelin/contracts@4.8.2/access/Ownable.sol\";\r\nimport {IERC165} from \"@openzeppelin/contracts@4.8.2/utils/introspection/IERC165.sol\";\r\nimport {ENS} from \"@ensdomains/ens-contracts/contracts/registry/ENS.sol\";\r\nimport {INameResolver} from \"@ensdomains/ens-contracts/contracts/resolvers/profiles/INameResolver.sol\";\r\nimport {IExtendedResolver} from \"@ensdomains/ens-contracts/contracts/resolvers/profiles/IExtendedResolver.sol\";\r\n\r\ninterface ERC721Stub {\r\n\tfunction name() external view returns (string memory);\r\n\tfunction tokenURI(uint256 token) external view returns (string memory);\r\n\tfunction ownerOf(uint256 token) external view returns (address);\r\n}\r\n\r\naddress constant CRYPTO_PUNKS  = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;\r\ninterface CryptoPunksStub {\r\n\tfunction punkIndexToAddress(uint256 token) external view returns (address);\r\n\tfunction punkImageSvg(uint16 index) external view returns (string memory svg);\r\n}\r\n\r\naddress constant ENS_REGISTRY = 0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e;\r\nbytes32 constant ENS_REVERSE_NODE = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\r\ninterface ReverseRegistrarStub {\r\n\t function setName(string memory name) external returns (bytes32);\r\n}\r\n\r\nuint256 constant HYPHEN = 0x2D;\r\n\t\r\ncontract NFTResolver is Ownable, IExtendedResolver {\r\n\r\n\tevent NFTRegistered(address indexed nft, string label);\r\n\r\n\terror NotAllowed();\r\n\terror NotContract();\r\n\terror BadPayment();\r\n\terror BadLabel();\r\n\r\n\tfunction supportsInterface(bytes4 x) external pure returns (bool) {\r\n\t\treturn x == type(IERC165).interfaceId\t\t\t// 0x01ffc9a7 \r\n\t\t\t|| x == type(IExtendedResolver).interfaceId; // 0x9061b923\r\n\t}\r\n\r\n\tmapping (bytes32 => address) _addrs;\r\n\tuint256 public publicPrice = 0.05 ether;\r\n\tbool public adminRegistrationLocked;\r\n\r\n\tfunction withdraw() external {\r\n\t\tpayable(owner()).transfer(address(this).balance);\r\n\t}\r\n\r\n\tfunction setPrimary(string calldata name) onlyOwner external {\r\n\t\tReverseRegistrarStub(ENS(ENS_REGISTRY).owner(ENS_REVERSE_NODE)).setName(name);\r\n\t}\r\n\r\n\tfunction setPublicPrice(uint256 price) onlyOwner external {\r\n\t\tpublicPrice = price;\r\n\t}\r\n\tfunction lockAdminRegistration() onlyOwner external {\r\n\t\tadminRegistrationLocked = true;\r\n\t}\r\n\r\n\tfunction publicRegister(address nft, string calldata label) external payable {\r\n\t\tif (publicPrice == 0) revert NotAllowed();\r\n\t\tif (msg.value < publicPrice) revert BadPayment();\r\n\t\tif (contractFor(label) != address(0)) revert BadLabel(); // cannot overwrite\r\n\t\t_register(nft, label);\r\n\t}\r\n\tfunction adminRegister(address[] calldata nfts, string[] calldata labels) onlyOwner external {\r\n\t\tif (adminRegistrationLocked) revert NotAllowed();\r\n\t\tfor (uint256 i; i < nfts.length; i++) {\r\n\t\t\t_register(nfts[i], labels[i]);\r\n\t\t}\r\n\t}\r\n\tfunction _register(address nft, string memory label) private {\r\n\t\tif (nft != address(0)) {\r\n\t\t\tif (nft.code.length == 0) revert NotContract();\r\n\t\t\tif (_digitQ(uint8(bytes(label)[0]))) revert BadLabel(); // leading digit\r\n\t\t\tuint256 last = uint8(bytes(label)[bytes(label).length-1]);\r\n\t\t\tif (_digitQ(last) || last == HYPHEN) revert BadLabel(); // trailing digit\r\n\t\t}\r\n\t\t_addrs[_labelhash(label)] = nft;\r\n\t\temit NFTRegistered(nft, label);\r\n\t}\r\n\r\n\t// convenience getters\r\n\tfunction contractFor(string memory label) public view returns (address) {\r\n\t\treturn _addrs[_labelhash(label)];\r\n\t}\r\n\tfunction holderFor(string memory label, uint256 token) external view returns (address target, address owner, string memory primary) {\r\n\t\t(target, owner) = holderOf(contractFor(label), token);\r\n\t\tprimary = primaryOf(owner);\r\n\t}\r\n\r\n\t// primitive getters\r\n\tfunction primaryOf(address owner) public view returns (string memory ret) {\r\n\t\tstring memory temp = new string(40);\r\n\t\tuint256 ptr;\r\n\t\tassembly {\r\n\t\t\tptr := add(temp, 32)\r\n\t\t}\r\n\t\t_writeHex(ptr, uint160(owner), 40);\r\n\t\tbytes32 node = keccak256(abi.encodePacked(ENS_REVERSE_NODE, keccak256(bytes(temp))));\r\n\t\taddress resolver = ENS(ENS_REGISTRY).resolver(node);\r\n\t\tif (resolver != address(0)) {\r\n\t\t\ttry INameResolver(resolver).name(node) returns (string memory name) {\r\n\t\t\t\tret = name;\r\n\t\t\t} catch {\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfunction avatarOf(address nft, uint256 token) public view returns (string memory avatar) {\r\n\t\t(address target, ) = holderOf(nft, token);\r\n\t\tif (target == CRYPTO_PUNKS) {\r\n\t\t\treturn CryptoPunksStub(0x16F5A35647D6F03D5D3da7b35409D65ba03aF3B2).punkImageSvg(uint16(token));\r\n\t\t}\r\n\t\tavatar = new string(125); // 18 + 40 + 3 + 64\r\n\t\tuint256 ptr;\r\n\t\tassembly {\r\n\t\t\tptr := add(avatar, 32)\r\n\t\t\tmstore(ptr,          0x6569703135353A312F6572633732313A30780000000000000000000000000000) // \"eip155:1/erc1155:0x\"\r\n\t\t\tmstore(add(ptr, 58), 0x2F30780000000000000000000000000000000000000000000000000000000000) // \"/0x\"\r\n\t\t}\r\n\t\t_writeHex(ptr + 18, uint160(target), 40);\r\n\t\t_writeHex(ptr + 61, token, 64);\r\n\t}\r\n\tfunction holderOf(address nft, uint256 token) public view returns (address target, address owner) {\r\n\t\tif (nft == CRYPTO_PUNKS) {\r\n\t\t\ttry CryptoPunksStub(nft).punkIndexToAddress(token) returns (address ret) {\r\n\t\t\t\towner = ret;\r\n\t\t\t} catch {\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\ttry ERC721Stub(nft).ownerOf(token) returns (address ret) {\r\n\t\t\t\towner = ret;\r\n\t\t\t} catch {\r\n\t\t\t}\r\n\t\t}\r\n\t\ttarget = nft;\r\n\t\twhile (owner.code.length > 0) { // wrapped?\r\n\t\t\ttry ERC721Stub(owner).ownerOf(token) returns (address ret) {\r\n\t\t\t\ttarget = owner;\r\n\t\t\t\towner = ret;\r\n\t\t\t} catch {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// accepts:\r\n\t//   <name>.*\r\n\t//   <digit>.<name>.*\r\n\t//   <name>-?<digit>.*\r\n\tuint256 constant TY_LABEL = 0;\r\n\tuint256 constant TY_TOKEN = 1;\r\n\tfunction parseEncodedName(bytes memory encoded) public pure returns (uint256 ty, bytes32 labelhash, uint256 token) {\r\n\t\tunchecked {\r\n\t\t\tuint256 head;\r\n\t\t\tuint256 ptr;\r\n\t\t\tassembly {\r\n\t\t\t\tptr := add(encoded, 32)\r\n\t\t\t\thead := mload(ptr)\r\n\t\t\t}\r\n\t\t\tuint256 len = head >> 248;\r\n\t\t\tif (_digitQ(uint8(head >> 240))) { // leading digit\r\n\t\t\t\ttoken = _readInteger(++ptr, len);\r\n\t\t\t\tptr += len;\r\n\t\t\t\tty = TY_TOKEN;\r\n\t\t\t}\r\n\t\t\tassembly {\r\n\t\t\t\thead := mload(ptr)\r\n\t\t\t\tptr := add(ptr, 1)\r\n\t\t\t}\r\n\t\t\tlen = head >> 248;\r\n\t\t\tif (ty == TY_LABEL) {\r\n\t\t\t\tuint256 end = ptr + len; // work backwards\r\n\t\t\t\tuint256 cut = end;\r\n\t\t\t\tuint256 off;\r\n\t\t\t\tdo {\r\n\t\t\t\t\toff = cut - 32;\r\n\t\t\t\t\tassembly {\r\n\t\t\t\t\t\thead := mload(off)\r\n\t\t\t\t\t}\r\n\t\t\t\t\twhile (_digitQ(uint8(head))) {\r\n\t\t\t\t\t\thead >>= 8;\r\n\t\t\t\t\t\t--cut;\r\n\t\t\t\t\t}\r\n\t\t\t\t} while (off == cut);\r\n\t\t\t\tif (cut < end) { // has digits\r\n\t\t\t\t\tty = TY_TOKEN;\r\n\t\t\t\t\ttoken = _readInteger(cut, end - cut);\r\n\t\t\t\t\tif (uint8(head) == HYPHEN) --cut;\r\n\t\t\t\t\tlen = cut - ptr; // truncate\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tassembly {\r\n\t\t\t\tlabelhash := keccak256(ptr, len)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// IExtendedResolver\r\n\tfunction resolve(bytes calldata name, bytes calldata data) external view returns (bytes memory res) {\r\n\t\tunchecked {\r\n\t\t\t(uint256 ty, bytes32 labelhash, uint256 token) = parseEncodedName(name);\r\n\t\t\taddress addr = _addrs[labelhash];\r\n\t\t\tbytes4 method = bytes4(data[0:4]);\r\n\t\t\tif (method == 0x3b3b57de) { // addr(bytes32) => address\r\n                bytes32 node = abi.decode(data[4:], (bytes32));\r\n\t\t\t\tif (ty == TY_TOKEN) {\r\n\t\t\t\t\t(, addr) = holderOf(addr, token);\r\n\t\t\t\t} else if (ENS(ENS_REGISTRY).resolver(node) == address(this)) {\r\n                    addr = address(this);\r\n                }\r\n\t\t\t\tres = abi.encode(addr);\r\n\t\t\t} else if (method == 0xf1cb7e06) { // addr(bytes32,coinType) => bytes\r\n\t\t\t\t(bytes32 node, uint256 coinType) = abi.decode(data[4:], (bytes32, uint256));\r\n\t\t\t\tif (coinType == 60) {\r\n\t\t\t\t\tif (ty == TY_TOKEN) {\r\n\t\t\t\t\t\t(, addr) = holderOf(addr, token);\r\n\t\t\t\t\t} else if (ENS(ENS_REGISTRY).resolver(node) == address(this)) {\r\n                        addr = address(this);\r\n                    }\r\n\t\t\t\t\tres = abi.encode(abi.encodePacked(addr));\r\n\t\t\t\t} else {\r\n\t\t\t\t\tres = abi.encode('');\r\n\t\t\t\t}\r\n\t\t\t} else if (method == 0xbc1c58d1) { // contenthash(bytes32) => bytes \r\n\t\t\t\treturn abi.encode('');\r\n\t\t\t} else if (method == 0x59d1d43c) { // text(bytes32,string) => string\r\n\t\t\t\t(, string memory key) = abi.decode(data[4:], (bytes32, string));\r\n\t\t\t\tbytes32 keyhash = keccak256(bytes(key));\r\n\t\t\t\tif (keyhash == 0xb68b5f5089998f2978a1dcc681e8ef27962b90d5c26c4c0b9c1945814ffa5ef0) { // url\r\n\t\t\t\t\tif (ty == TY_TOKEN) {\r\n\t\t\t\t\t\ttry ERC721Stub(addr).tokenURI(token) returns (string memory url) {\r\n\t\t\t\t\t\t\treturn abi.encode(url);\r\n\t\t\t\t\t\t} catch {\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} \r\n\t\t\t\t} else if (keyhash == 0x1596dc38e2ac5a6ddc5e019af4adcc1e017a04f510d57e69d6879d5d2996bb8e) { // description\r\n\t\t\t\t\ttry ERC721Stub(addr).name() returns (string memory ret) {\r\n\t\t\t\t\t\treturn abi.encode(ret);\r\n\t\t\t\t\t} catch {\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (keyhash == 0xd1f86c93d831119ad98fe983e643a7431e4ac992e3ead6e3007f4dd1adf66343) { // avatar\r\n\t\t\t\t\tif (ty == TY_TOKEN) {\r\n\t\t\t\t\t\treturn abi.encode(avatarOf(addr, token));\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (keyhash == 0x32418106fd89af94305d9787acb608a501b749f5f1783cfca7b3f864595254ca) { // name\r\n\t\t\t\t\tif (ty == TY_TOKEN) {\r\n\t\t\t\t\t\t(, addr) = holderOf(addr, token);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn abi.encode(primaryOf(addr));\r\n\t\t\t\t}\r\n\t\t\t\treturn abi.encode(\"\");\r\n\t\t\t}\r\n\t\t}\r\n\t} \r\n\r\n\t// utils\r\n\tfunction _labelhash(string memory label) private pure returns (bytes32) {\r\n\t\treturn keccak256(bytes(label));\r\n\t}\r\n\tfunction _digitQ(uint256 ch) private pure returns (bool) {\r\n\t\treturn ch >= 0x30 && ch <= 0x39;\r\n\t}\r\n\tfunction _readInteger(uint256 ptr, uint256 len) private pure returns (uint256 acc) {\r\n\t\tunchecked {\r\n\t\t\tuint256 end = ptr + len;\r\n\t\t\twhile (true) {\r\n\t\t\t\tuint256 temp;\r\n\t\t\t\tassembly {\r\n\t\t\t\t\ttemp := mload(ptr)\r\n\t\t\t\t}\r\n\t\t\t\tuint256 shift = 256;\r\n\t\t\t\twhile (shift > 0) {\r\n\t\t\t\t\tshift -= 8;\r\n\t\t\t\t\tuint256 ch = uint8(temp >> shift);\r\n\t\t\t\t\tif (!_digitQ(ch)) return type(uint256).max; // error\r\n\t\t\t\t\tacc = acc * 10 + (ch - 0x30);\r\n\t\t\t\t\tif (++ptr == end) return acc;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfunction _writeHex(uint256 ptr, uint256 value, uint256 len) private pure {\r\n\t\tunchecked {\r\n\t\t\tuint256 end = ptr + len;\r\n\t\t\twhile (end > ptr) {\r\n\t\t\t\tassembly {\r\n\t\t\t\t\tend := sub(end, 1)\r\n\t\t\t\t\tmstore8(end, byte(and(value, 0xF), 0x3031323334353637383961626364656600000000000000000000000000000000))\r\n\t\t\t\t\tvalue := shr(4, value)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n}"

    },

    "@ensdomains/ens-contracts/contracts/resolvers/profiles/IExtendedResolver.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IExtendedResolver {\n    function resolve(\n        bytes memory name,\n        bytes memory data\n    ) external view returns (bytes memory);\n}\n"

    },

    "@ensdomains/ens-contracts/contracts/resolvers/profiles/INameResolver.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface INameResolver {\n    event NameChanged(bytes32 indexed node, string name);\n\n    /**\n     * Returns the name associated with an ENS node, for reverse records.\n     * Defined in EIP181.\n     * @param node The ENS node to query.\n     * @return The associated name.\n     */\n    function name(bytes32 node) external view returns (string memory);\n}\n"

    },

    "@ensdomains/ens-contracts/contracts/registry/ENS.sol": {

      "content": "pragma solidity >=0.8.4;\n\ninterface ENS {\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n\n    // Logged when an operator is added or removed.\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        bytes32 label,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        bytes32 label,\n        address owner\n    ) external returns (bytes32);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setOwner(bytes32 node, address owner) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function owner(bytes32 node) external view returns (address);\n\n    function resolver(bytes32 node) external view returns (address);\n\n    function ttl(bytes32 node) external view returns (uint64);\n\n    function recordExists(bytes32 node) external view returns (bool);\n\n    function isApprovedForAll(\n        address owner,\n        address operator\n    ) external view returns (bool);\n}\n"

    },

    "@openzeppelin/contracts@4.8.2/utils/introspection/IERC165.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"

    },

    "@openzeppelin/contracts@4.8.2/access/Ownable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"

    },

    "@openzeppelin/contracts@4.8.2/utils/Context.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"

    }

  },

  "settings": {

    "optimizer": {

      "enabled": true,

      "runs": 420

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    }

  }

}}