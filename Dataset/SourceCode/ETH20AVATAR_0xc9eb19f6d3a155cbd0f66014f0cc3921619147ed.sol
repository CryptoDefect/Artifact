/**

 *Submitted for verification at Etherscan.io on 2023-08-16

*/



// SPDX-License-Identifier: MIT



pragma solidity 0.8.19;



/**

 * @dev Provides information about the current execution context, including the

 * sender of the transaction and its data. While these are generally available

 * via msg.sender and msg.data, they should not be accessed in such a direct

 * manner, since when dealing with meta-transactions the account sending and

 * paying for execution may not be the actual sender (as far as an application

 * is concerned).

 *

 * This contract is only required for intermediate, library-like contracts.

 */

abstract contract Context {

    function _msgSender() internal view virtual returns (address) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes calldata) {

        return msg.data;

    }

}



/**

 * @dev Contract module which provides a basic access control mechanism, where

 * there is an account (an owner) that can be granted exclusive access to

 * specific functions.

 *

 * By default, the owner account will be the one that deploys the contract. This

 * can later be changed with {transferOwnership}.

 *

 * This module is used through inheritance. It will make available the modifier

 * `onlyOwner`, which can be applied to your functions to restrict their use to

 * the owner.

 */

abstract contract Ownable is Context {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev Initializes the contract setting the deployer as the initial owner.

     */

    constructor() {

        _transferOwnership(_msgSender());

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        _checkOwner();

        _;

    }



    /**

     * @dev Returns the address of the current owner.

     */

    function owner() public view virtual returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if the sender is not the owner.

     */

    function _checkOwner() internal view virtual {

        require(owner() == _msgSender(), "Ownable: caller is not the owner");

    }



    /**

     * @dev Leaves the contract without owner. It will not be possible to call

     * `onlyOwner` functions. Can only be called by the current owner.

     *

     * NOTE: Renouncing ownership will leave the contract without an owner,

     * thereby disabling any functionality that is only available to the owner.

     */

    function renounceOwnership() public virtual onlyOwner {

        _transferOwnership(address(0));

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Can only be called by the current owner.

     */

    function transferOwnership(address newOwner) public virtual onlyOwner {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Internal function without access restriction.

     */

    function _transferOwnership(address newOwner) internal virtual {

        address oldOwner = _owner;

        _owner = newOwner;

        emit OwnershipTransferred(oldOwner, newOwner);

    }

}



/**

 * @dev Standard math utilities missing in the Solidity language.

 */

library Math {

    enum Rounding {

        Down, // Toward negative infinity

        Up, // Toward infinity

        Zero // Toward zero

    }



    /**

     * @dev Returns the largest of two numbers.

     */

    function max(uint256 a, uint256 b) internal pure returns (uint256) {

        return a > b ? a : b;

    }



    /**

     * @dev Returns the smallest of two numbers.

     */

    function min(uint256 a, uint256 b) internal pure returns (uint256) {

        return a < b ? a : b;

    }



    /**

     * @dev Returns the average of two numbers. The result is rounded towards

     * zero.

     */

    function average(uint256 a, uint256 b) internal pure returns (uint256) {

        // (a + b) / 2 can overflow.

        return (a & b) + (a ^ b) / 2;

    }



    /**

     * @dev Returns the ceiling of the division of two numbers.

     *

     * This differs from standard division with `/` in that it rounds up instead

     * of rounding down.

     */

    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {

        // (a + b - 1) / b can overflow on addition, so we distribute.

        return a == 0 ? 0 : (a - 1) / b + 1;

    }



    /**

     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0

     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)

     * with further edits by Uniswap Labs also under MIT license.

     */

    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {

        unchecked {

            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use

            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256

            // variables such that product = prod1 * 2^256 + prod0.

            uint256 prod0; // Least significant 256 bits of the product

            uint256 prod1; // Most significant 256 bits of the product

            assembly {

                let mm := mulmod(x, y, not(0))

                prod0 := mul(x, y)

                prod1 := sub(sub(mm, prod0), lt(mm, prod0))

            }



            // Handle non-overflow cases, 256 by 256 division.

            if (prod1 == 0) {

                // Solidity will revert if denominator == 0, unlike the div opcode on its own.

                // The surrounding unchecked block does not change this fact.

                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.

                return prod0 / denominator;

            }



            // Make sure the result is less than 2^256. Also prevents denominator == 0.

            require(denominator > prod1, "Math: mulDiv overflow");



            ///////////////////////////////////////////////

            // 512 by 256 division.

            ///////////////////////////////////////////////



            // Make division exact by subtracting the remainder from [prod1 prod0].

            uint256 remainder;

            assembly {

                // Compute remainder using mulmod.

                remainder := mulmod(x, y, denominator)



                // Subtract 256 bit number from 512 bit number.

                prod1 := sub(prod1, gt(remainder, prod0))

                prod0 := sub(prod0, remainder)

            }



            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.

            // See https://cs.stackexchange.com/q/138556/92363.



            // Does not overflow because the denominator cannot be zero at this stage in the function.

            uint256 twos = denominator & (~denominator + 1);

            assembly {

                // Divide denominator by twos.

                denominator := div(denominator, twos)



                // Divide [prod1 prod0] by twos.

                prod0 := div(prod0, twos)



                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.

                twos := add(div(sub(0, twos), twos), 1)

            }



            // Shift in bits from prod1 into prod0.

            prod0 |= prod1 * twos;



            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such

            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for

            // four bits. That is, denominator * inv = 1 mod 2^4.

            uint256 inverse = (3 * denominator) ^ 2;



            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works

            // in modular arithmetic, doubling the correct bits in each step.

            inverse *= 2 - denominator * inverse; // inverse mod 2^8

            inverse *= 2 - denominator * inverse; // inverse mod 2^16

            inverse *= 2 - denominator * inverse; // inverse mod 2^32

            inverse *= 2 - denominator * inverse; // inverse mod 2^64

            inverse *= 2 - denominator * inverse; // inverse mod 2^128

            inverse *= 2 - denominator * inverse; // inverse mod 2^256



            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.

            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is

            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1

            // is no longer required.

            result = prod0 * inverse;

            return result;

        }

    }



    /**

     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.

     */

    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {

        uint256 result = mulDiv(x, y, denominator);

        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {

            result += 1;

        }

        return result;

    }



    /**

     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.

     *

     * Inspired by Henry S. Warren, Jr.'s "Hacker's Delight" (Chapter 11).

     */

    function sqrt(uint256 a) internal pure returns (uint256) {

        if (a == 0) {

            return 0;

        }



        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.

        //

        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have

        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.

        //

        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`

        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`

        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`

        //

        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.

        uint256 result = 1 << (log2(a) >> 1);



        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,

        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at

        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision

        // into the expected uint128 result.

        unchecked {

            result = (result + a / result) >> 1;

            result = (result + a / result) >> 1;

            result = (result + a / result) >> 1;

            result = (result + a / result) >> 1;

            result = (result + a / result) >> 1;

            result = (result + a / result) >> 1;

            result = (result + a / result) >> 1;

            return min(result, a / result);

        }

    }



    /**

     * @notice Calculates sqrt(a), following the selected rounding direction.

     */

    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {

        unchecked {

            uint256 result = sqrt(a);

            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);

        }

    }



    /**

     * @dev Return the log in base 2, rounded down, of a positive value.

     * Returns 0 if given 0.

     */

    function log2(uint256 value) internal pure returns (uint256) {

        uint256 result = 0;

        unchecked {

            if (value >> 128 > 0) {

                value >>= 128;

                result += 128;

            }

            if (value >> 64 > 0) {

                value >>= 64;

                result += 64;

            }

            if (value >> 32 > 0) {

                value >>= 32;

                result += 32;

            }

            if (value >> 16 > 0) {

                value >>= 16;

                result += 16;

            }

            if (value >> 8 > 0) {

                value >>= 8;

                result += 8;

            }

            if (value >> 4 > 0) {

                value >>= 4;

                result += 4;

            }

            if (value >> 2 > 0) {

                value >>= 2;

                result += 2;

            }

            if (value >> 1 > 0) {

                result += 1;

            }

        }

        return result;

    }



    /**

     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.

     * Returns 0 if given 0.

     */

    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {

        unchecked {

            uint256 result = log2(value);

            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);

        }

    }



    /**

     * @dev Return the log in base 10, rounded down, of a positive value.

     * Returns 0 if given 0.

     */

    function log10(uint256 value) internal pure returns (uint256) {

        uint256 result = 0;

        unchecked {

            if (value >= 10 ** 64) {

                value /= 10 ** 64;

                result += 64;

            }

            if (value >= 10 ** 32) {

                value /= 10 ** 32;

                result += 32;

            }

            if (value >= 10 ** 16) {

                value /= 10 ** 16;

                result += 16;

            }

            if (value >= 10 ** 8) {

                value /= 10 ** 8;

                result += 8;

            }

            if (value >= 10 ** 4) {

                value /= 10 ** 4;

                result += 4;

            }

            if (value >= 10 ** 2) {

                value /= 10 ** 2;

                result += 2;

            }

            if (value >= 10 ** 1) {

                result += 1;

            }

        }

        return result;

    }



    /**

     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.

     * Returns 0 if given 0.

     */

    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {

        unchecked {

            uint256 result = log10(value);

            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);

        }

    }



    /**

     * @dev Return the log in base 256, rounded down, of a positive value.

     * Returns 0 if given 0.

     *

     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.

     */

    function log256(uint256 value) internal pure returns (uint256) {

        uint256 result = 0;

        unchecked {

            if (value >> 128 > 0) {

                value >>= 128;

                result += 16;

            }

            if (value >> 64 > 0) {

                value >>= 64;

                result += 8;

            }

            if (value >> 32 > 0) {

                value >>= 32;

                result += 4;

            }

            if (value >> 16 > 0) {

                value >>= 16;

                result += 2;

            }

            if (value >> 8 > 0) {

                result += 1;

            }

        }

        return result;

    }



    /**

     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.

     * Returns 0 if given 0.

     */

    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {

        unchecked {

            uint256 result = log256(value);

            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);

        }

    }

}



/**

 * @dev Standard signed math utilities missing in the Solidity language.

 */

library SignedMath {

    /**

     * @dev Returns the largest of two signed numbers.

     */

    function max(int256 a, int256 b) internal pure returns (int256) {

        return a > b ? a : b;

    }



    /**

     * @dev Returns the smallest of two signed numbers.

     */

    function min(int256 a, int256 b) internal pure returns (int256) {

        return a < b ? a : b;

    }



    /**

     * @dev Returns the average of two signed numbers without overflow.

     * The result is rounded towards zero.

     */

    function average(int256 a, int256 b) internal pure returns (int256) {

        // Formula from the book "Hacker's Delight"

        int256 x = (a & b) + ((a ^ b) >> 1);

        return x + (int256(uint256(x) >> 255) & (a ^ b));

    }



    /**

     * @dev Returns the absolute unsigned value of a signed value.

     */

    function abs(int256 n) internal pure returns (uint256) {

        unchecked {

            // must be unchecked in order to support `n = type(int256).min`

            return uint256(n >= 0 ? n : -n);

        }

    }

}



/**

 * @dev String operations.

 */

library Strings {

    bytes16 private constant _SYMBOLS = "0123456789abcdef";

    uint8 private constant _ADDRESS_LENGTH = 20;



    /**

     * @dev Converts a `uint256` to its ASCII `string` decimal representation.

     */

    function toString(uint256 value) internal pure returns (string memory) {

        unchecked {

            uint256 length = Math.log10(value) + 1;

            string memory buffer = new string(length);

            uint256 ptr;

            /// @solidity memory-safe-assembly

            assembly {

                ptr := add(buffer, add(32, length))

            }

            while (true) {

                ptr--;

                /// @solidity memory-safe-assembly

                assembly {

                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))

                }

                value /= 10;

                if (value == 0) break;

            }

            return buffer;

        }

    }



    /**

     * @dev Converts a `int256` to its ASCII `string` decimal representation.

     */

    function toString(int256 value) internal pure returns (string memory) {

        return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMath.abs(value))));

    }



    /**

     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.

     */

    function toHexString(uint256 value) internal pure returns (string memory) {

        unchecked {

            return toHexString(value, Math.log256(value) + 1);

        }

    }



    /**

     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.

     */

    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {

        bytes memory buffer = new bytes(2 * length + 2);

        buffer[0] = "0";

        buffer[1] = "x";

        for (uint256 i = 2 * length + 1; i > 1; --i) {

            buffer[i] = _SYMBOLS[value & 0xf];

            value >>= 4;

        }

        require(value == 0, "Strings: hex length insufficient");

        return string(buffer);

    }



    /**

     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.

     */

    function toHexString(address addr) internal pure returns (string memory) {

        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);

    }



    /**

     * @dev Returns true if the two strings are equal.

     */

    function equal(string memory a, string memory b) internal pure returns (bool) {

        return keccak256(bytes(a)) == keccak256(bytes(b));

    }

}



/**

 * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.

 *

 * These functions can be used to verify that a message was signed by the holder

 * of the private keys of a given address.

 */

library ECDSA {

    enum RecoverError {

        NoError,

        InvalidSignature,

        InvalidSignatureLength,

        InvalidSignatureS,

        InvalidSignatureV // Deprecated in v4.8

    }



    function _throwError(RecoverError error) private pure {

        if (error == RecoverError.NoError) {

            return; // no error: do nothing

        } else if (error == RecoverError.InvalidSignature) {

            revert("ECDSA: invalid signature");

        } else if (error == RecoverError.InvalidSignatureLength) {

            revert("ECDSA: invalid signature length");

        } else if (error == RecoverError.InvalidSignatureS) {

            revert("ECDSA: invalid signature 's' value");

        }

    }



    /**

     * @dev Returns the address that signed a hashed message (`hash`) with

     * `signature` or error string. This address can then be used for verification purposes.

     *

     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:

     * this function rejects them by requiring the `s` value to be in the lower

     * half order, and the `v` value to be either 27 or 28.

     *

     * IMPORTANT: `hash` _must_ be the result of a hash operation for the

     * verification to be secure: it is possible to craft signatures that

     * recover to arbitrary addresses for non-hashed data. A safe way to ensure

     * this is by receiving a hash of the original message (which may otherwise

     * be too long), and then calling {toEthSignedMessageHash} on it.

     *

     * Documentation for signature generation:

     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]

     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]

     *

     * _Available since v4.3._

     */

    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {

        if (signature.length == 65) {

            bytes32 r;

            bytes32 s;

            uint8 v;

            // ecrecover takes the signature parameters, and the only way to get them

            // currently is to use assembly.

            /// @solidity memory-safe-assembly

            assembly {

                r := mload(add(signature, 0x20))

                s := mload(add(signature, 0x40))

                v := byte(0, mload(add(signature, 0x60)))

            }

            return tryRecover(hash, v, r, s);

        } else {

            return (address(0), RecoverError.InvalidSignatureLength);

        }

    }



    /**

     * @dev Returns the address that signed a hashed message (`hash`) with

     * `signature`. This address can then be used for verification purposes.

     *

     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:

     * this function rejects them by requiring the `s` value to be in the lower

     * half order, and the `v` value to be either 27 or 28.

     *

     * IMPORTANT: `hash` _must_ be the result of a hash operation for the

     * verification to be secure: it is possible to craft signatures that

     * recover to arbitrary addresses for non-hashed data. A safe way to ensure

     * this is by receiving a hash of the original message (which may otherwise

     * be too long), and then calling {toEthSignedMessageHash} on it.

     */

    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {

        (address recovered, RecoverError error) = tryRecover(hash, signature);

        _throwError(error);

        return recovered;

    }



    /**

     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.

     *

     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]

     *

     * _Available since v4.3._

     */

    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {

        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);

        uint8 v = uint8((uint256(vs) >> 255) + 27);

        return tryRecover(hash, v, r, s);

    }



    /**

     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.

     *

     * _Available since v4.2._

     */

    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {

        (address recovered, RecoverError error) = tryRecover(hash, r, vs);

        _throwError(error);

        return recovered;

    }



    /**

     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,

     * `r` and `s` signature fields separately.

     *

     * _Available since v4.3._

     */

    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {

        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature

        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines

        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most

        // signatures from current libraries generate a unique signature with an s-value in the lower half order.

        //

        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value

        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or

        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept

        // these malleable signatures as well.

        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {

            return (address(0), RecoverError.InvalidSignatureS);

        }



        // If the signature is valid (and not malleable), return the signer address

        address signer = ecrecover(hash, v, r, s);

        if (signer == address(0)) {

            return (address(0), RecoverError.InvalidSignature);

        }



        return (signer, RecoverError.NoError);

    }



    /**

     * @dev Overload of {ECDSA-recover} that receives the `v`,

     * `r` and `s` signature fields separately.

     */

    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {

        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);

        _throwError(error);

        return recovered;

    }



    /**

     * @dev Returns an Ethereum Signed Message, created from a `hash`. This

     * produces hash corresponding to the one signed with the

     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]

     * JSON-RPC method as part of EIP-191.

     *

     * See {recover}.

     */

    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {

        // 32 is the length in bytes of hash,

        // enforced by the type signature above

        /// @solidity memory-safe-assembly

        assembly {

            mstore(0x00, "\x19Ethereum Signed Message:\n32")

            mstore(0x1c, hash)

            message := keccak256(0x00, 0x3c)

        }

    }



    /**

     * @dev Returns an Ethereum Signed Message, created from `s`. This

     * produces hash corresponding to the one signed with the

     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]

     * JSON-RPC method as part of EIP-191.

     *

     * See {recover}.

     */

    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {

        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n", Strings.toString(s.length), s));

    }



    /**

     * @dev Returns an Ethereum Signed Typed Data, created from a

     * `domainSeparator` and a `structHash`. This produces hash corresponding

     * to the one signed with the

     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]

     * JSON-RPC method as part of EIP-712.

     *

     * See {recover}.

     */

    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {

        /// @solidity memory-safe-assembly

        assembly {

            let ptr := mload(0x40)

            mstore(ptr, "\x19\x01")

            mstore(add(ptr, 0x02), domainSeparator)

            mstore(add(ptr, 0x22), structHash)

            data := keccak256(ptr, 0x42)

        }

    }



    /**

     * @dev Returns an Ethereum Signed Data with intended validator, created from a

     * `validator` and `data` according to the version 0 of EIP-191.

     *

     * See {recover}.

     */

    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {

        return keccak256(abi.encodePacked("\x19\x00", validator, data));

    }

}



/// The ERC721 standard allows for self-approvals.

/// For performance, this implementation WILL NOT revert for such actions.

/// Please add any checks with overrides if desired.

abstract contract ERC721 {

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                         CONSTANTS                          */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev An account can hold up to 4294967295 tokens.

    uint256 internal constant _MAX_ACCOUNT_BALANCE = 0xffffffff;



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                       CUSTOM ERRORS                        */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Only the token owner or an approved account can manage the token.

    error NotOwnerNorApproved();



    /// @dev The token does not exist.

    error TokenDoesNotExist();



    /// @dev The token already exists.

    error TokenAlreadyExists();



    /// @dev Cannot query the balance for the zero address.

    error BalanceQueryForZeroAddress();



    /// @dev Cannot mint or transfer to the zero address.

    error TransferToZeroAddress();



    /// @dev The token must be owned by `from`.

    error TransferFromIncorrectOwner();



    /// @dev The recipient's balance has overflowed.

    error AccountBalanceOverflow();



    /// @dev Cannot safely transfer to a contract that does not implement

    /// the ERC721Receiver interface.

    error TransferToNonERC721ReceiverImplementer();



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                           EVENTS                           */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Emitted when token `id` is transferred from `from` to `to`.

    event Transfer(address indexed from, address indexed to, uint256 indexed id);



    /// @dev Emitted when `owner` enables `account` to manage the `id` token.

    event Approval(address indexed owner, address indexed account, uint256 indexed id);



    /// @dev Emitted when `owner` enables or disables `operator` to manage all of their tokens.

    event ApprovalForAll(address indexed owner, address indexed operator, bool isApproved);



    /// @dev `keccak256(bytes("Transfer(address,address,uint256)"))`.

    uint256 private constant _TRANSFER_EVENT_SIGNATURE =

        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;



    /// @dev `keccak256(bytes("Approval(address,address,uint256)"))`.

    uint256 private constant _APPROVAL_EVENT_SIGNATURE =

        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;



    /// @dev `keccak256(bytes("ApprovalForAll(address,address,bool)"))`.

    uint256 private constant _APPROVAL_FOR_ALL_EVENT_SIGNATURE =

        0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31;



    // =============================================================

    //                          CONSTRUCTOR

    // =============================================================



    constructor(string memory name_, string memory symbol_) {

        _name = name_;

        _symbol = symbol_;

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                          STORAGE                           */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev The ownership data slot of `id` is given by:

    /// ```

    ///     mstore(0x00, id)

    ///     mstore(0x1c, _ERC721_MASTER_SLOT_SEED)

    ///     let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))

    /// ```

    /// Bits Layout:

    // - [0..159]   `addr`

    // - [160..223] `extraData`

    ///

    /// The approved address slot is given by: `add(1, ownershipSlot)`.

    ///

    /// See: https://notes.ethereum.org/%40vbuterin/verkle_tree_eip

    ///

    /// The balance slot of `owner` is given by:

    /// ```

    ///     mstore(0x1c, _ERC721_MASTER_SLOT_SEED)

    ///     mstore(0x00, owner)

    ///     let balanceSlot := keccak256(0x0c, 0x1c)

    /// ```

    /// Bits Layout:

    /// - [0..31]   `balance`

    /// - [32..225] `aux`

    ///

    /// The `operator` approval slot of `owner` is given by:

    /// ```

    ///     mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, operator))

    ///     mstore(0x00, owner)

    ///     let operatorApprovalSlot := keccak256(0x0c, 0x30)

    /// ```

    uint256 private constant _ERC721_MASTER_SLOT_SEED = 0x7d8825530a5a2e7a << 192;



    /// @dev Pre-shifted and pre-masked constant.

    uint256 private constant _ERC721_MASTER_SLOT_SEED_MASKED = 0x0a5a2e7a00000000;



    // Token name

    string private _name;



    // Token symbol

    string private _symbol;



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                      ERC721 METADATA                       */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Returns the token collection name.

    function name() public view virtual returns (string memory) {

        return _name;

    }



    /// @dev Returns the token collection symbol.

    function symbol() public view virtual returns (string memory) {

        return _symbol;

    }



    /// @dev Returns the Uniform Resource Identifier (URI) for token `id`.

    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {

        if (!_exists(tokenId)) revert TokenDoesNotExist();



        string memory baseURI = _baseURI();

        return

            bytes(baseURI).length > 0

                ? string(abi.encodePacked(baseURI, "/", _toHexString(address(this)), "/", _toString(tokenId)))

                : "";

    }



    /**

     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each

     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty

     * by default, it can be overridden in child contracts.

     */

    function _baseURI() internal view virtual returns (string memory) {

        return "";

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                           ERC721                           */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Returns the owner of token `id`.

    ///

    /// Requirements:

    /// - Token `id` must exist.

    function ownerOf(uint256 id) public view virtual returns (address result) {

        result = _ownerOf(id);

        /// @solidity memory-safe-assembly

        assembly {

            if iszero(result) {

                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.

                revert(0x1c, 0x04)

            }

        }

    }



    /// @dev Returns the number of tokens owned by `owner`.

    ///

    /// Requirements:

    /// - `owner` must not be the zero address.

    function balanceOf(address owner) public view virtual returns (uint256 result) {

        /// @solidity memory-safe-assembly

        assembly {

            // Revert if the `owner` is the zero address.

            if iszero(owner) {

                mstore(0x00, 0x8f4eb604) // `BalanceQueryForZeroAddress()`.

                revert(0x1c, 0x04)

            }

            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)

            mstore(0x00, owner)

            result := and(sload(keccak256(0x0c, 0x1c)), _MAX_ACCOUNT_BALANCE)

        }

    }



    /// @dev Returns the account approved to managed token `id`.

    ///

    /// Requirements:

    /// - Token `id` must exist.

    function getApproved(uint256 id) public view virtual returns (address result) {

        /// @solidity memory-safe-assembly

        assembly {

            mstore(0x00, id)

            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)

            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))

            if iszero(shr(96, shl(96, sload(ownershipSlot)))) {

                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.

                revert(0x1c, 0x04)

            }

            result := sload(add(1, ownershipSlot))

        }

    }



    /// @dev Sets `account` as the approved account to manage token `id`.

    ///

    /// Requirements:

    /// - Token `id` must exist.

    /// - The caller must be the owner of the token,

    ///   or an approved operator for the token owner.

    ///

    /// Emits a {Approval} event.

    function approve(address account, uint256 id) public payable virtual {

        _approve(msg.sender, account, id);

    }



    /// @dev Returns whether `operator` is approved to manage the tokens of `owner`.

    function isApprovedForAll(address owner, address operator) public view virtual returns (bool result) {

        /// @solidity memory-safe-assembly

        assembly {

            mstore(0x1c, operator)

            mstore(0x08, _ERC721_MASTER_SLOT_SEED_MASKED)

            mstore(0x00, owner)

            result := sload(keccak256(0x0c, 0x30))

        }

    }



    /// @dev Sets whether `operator` is approved to manage the tokens of the caller.

    ///

    /// Emits a {ApprovalForAll} event.

    function setApprovalForAll(address operator, bool isApproved) public virtual {

        /// @solidity memory-safe-assembly

        assembly {

            // Convert to 0 or 1.

            isApproved := iszero(iszero(isApproved))

            // Update the `isApproved` for (`msg.sender`, `operator`).

            mstore(0x1c, operator)

            mstore(0x08, _ERC721_MASTER_SLOT_SEED_MASKED)

            mstore(0x00, caller())

            sstore(keccak256(0x0c, 0x30), isApproved)

            // Emit the {ApprovalForAll} event.

            mstore(0x00, isApproved)

            log3(0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, caller(), shr(96, shl(96, operator)))

        }

    }



    /// @dev Transfers token `id` from `from` to `to`.

    ///

    /// Requirements:

    ///

    /// - Token `id` must exist.

    /// - `from` must be the owner of the token.

    /// - `to` cannot be the zero address.

    /// - The caller must be the owner of the token, or be approved to manage the token.

    ///

    /// Emits a {Transfer} event.

    function transferFrom(address from, address to, uint256 id) public payable virtual {

        _beforeTokenTransfer(from, to, id);

        /// @solidity memory-safe-assembly

        assembly {

            // Clear the upper 96 bits.

            let bitmaskAddress := shr(96, not(0))

            from := and(bitmaskAddress, from)

            to := and(bitmaskAddress, to)

            // Load the ownership data.

            mstore(0x00, id)

            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, caller()))

            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))

            let ownershipPacked := sload(ownershipSlot)

            let owner := and(bitmaskAddress, ownershipPacked)

            // Revert if `from` is not the owner, or does not exist.

            if iszero(mul(owner, eq(owner, from))) {

                if iszero(owner) {

                    mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.

                    revert(0x1c, 0x04)

                }

                mstore(0x00, 0xa1148100) // `TransferFromIncorrectOwner()`.

                revert(0x1c, 0x04)

            }

            // Revert if `to` is the zero address.

            if iszero(to) {

                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.

                revert(0x1c, 0x04)

            }

            // Load, check, and update the token approval.

            {

                mstore(0x00, from)

                let approvedAddress := sload(add(1, ownershipSlot))

                // Revert if the caller is not the owner, nor approved.

                if iszero(or(eq(caller(), from), eq(caller(), approvedAddress))) {

                    if iszero(sload(keccak256(0x0c, 0x30))) {

                        mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.

                        revert(0x1c, 0x04)

                    }

                }

                // Delete the approved address if any.

                if approvedAddress {

                    sstore(add(1, ownershipSlot), 0)

                }

            }

            // Update with the new owner.

            sstore(ownershipSlot, xor(ownershipPacked, xor(from, to)))

            // Decrement the balance of `from`.

            {

                let fromBalanceSlot := keccak256(0x0c, 0x1c)

                sstore(fromBalanceSlot, sub(sload(fromBalanceSlot), 1))

            }

            // Increment the balance of `to`.

            {

                mstore(0x00, to)

                let toBalanceSlot := keccak256(0x0c, 0x1c)

                let toBalanceSlotPacked := add(sload(toBalanceSlot), 1)

                if iszero(and(toBalanceSlotPacked, _MAX_ACCOUNT_BALANCE)) {

                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.

                    revert(0x1c, 0x04)

                }

                sstore(toBalanceSlot, toBalanceSlotPacked)

            }

            // Emit the {Transfer} event.

            log4(0x00, 0x00, _TRANSFER_EVENT_SIGNATURE, from, to, id)

        }

        _afterTokenTransfer(from, to, id);

    }



    /// @dev Equivalent to `safeTransferFrom(from, to, id, "")`.

    function safeTransferFrom(address from, address to, uint256 id) public payable virtual {

        transferFrom(from, to, id);

        if (_hasCode(to)) _checkOnERC721Received(from, to, id, "");

    }



    /// @dev Transfers token `id` from `from` to `to`.

    ///

    /// Requirements:

    ///

    /// - Token `id` must exist.

    /// - `from` must be the owner of the token.

    /// - `to` cannot be the zero address.

    /// - The caller must be the owner of the token, or be approved to manage the token.

    /// - If `to` refers to a smart contract, it must implement

    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.

    ///

    /// Emits a {Transfer} event.

    function safeTransferFrom(address from, address to, uint256 id, bytes calldata data) public payable virtual {

        transferFrom(from, to, id);

        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);

    }



    /// @dev Returns true if this contract implements the interface defined by `interfaceId`.

    /// See: https://eips.ethereum.org/EIPS/eip-165

    /// This function call must use less than 30000 gas.

    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {

        /// @solidity memory-safe-assembly

        assembly {

            let s := shr(224, interfaceId)

            // ERC165: 0x01ffc9a7, ERC721: 0x80ac58cd, ERC721Metadata: 0x5b5e139f.

            result := or(or(eq(s, 0x01ffc9a7), eq(s, 0x80ac58cd)), eq(s, 0x5b5e139f))

        }

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                  INTERNAL QUERY FUNCTIONS                  */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Returns if token `id` exists.

    function _exists(uint256 id) internal view virtual returns (bool result) {

        /// @solidity memory-safe-assembly

        assembly {

            mstore(0x00, id)

            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)

            result := shl(96, sload(add(id, add(id, keccak256(0x00, 0x20)))))

        }

    }



    /// @dev Returns the owner of token `id`.

    /// Returns the zero address instead of reverting if the token does not exist.

    function _ownerOf(uint256 id) internal view virtual returns (address result) {

        /// @solidity memory-safe-assembly

        assembly {

            mstore(0x00, id)

            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)

            result := shr(96, shl(96, sload(add(id, add(id, keccak256(0x00, 0x20))))))

        }

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*            INTERNAL DATA HITCHHIKING FUNCTIONS             */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Returns the auxiliary data for `owner`.

    /// Minting, transferring, burning the tokens of `owner` will not change the auxiliary data.

    /// Auxiliary data can be set for any address, even if it does not have any tokens.

    function _getAux(address owner) internal view virtual returns (uint224 result) {

        /// @solidity memory-safe-assembly

        assembly {

            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)

            mstore(0x00, owner)

            result := shr(32, sload(keccak256(0x0c, 0x1c)))

        }

    }



    /// @dev Set the auxiliary data for `owner` to `value`.

    /// Minting, transferring, burning the tokens of `owner` will not change the auxiliary data.

    /// Auxiliary data can be set for any address, even if it does not have any tokens.

    function _setAux(address owner, uint224 value) internal virtual {

        /// @solidity memory-safe-assembly

        assembly {

            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)

            mstore(0x00, owner)

            let balanceSlot := keccak256(0x0c, 0x1c)

            let packed := sload(balanceSlot)

            sstore(balanceSlot, xor(packed, shl(32, xor(value, shr(32, packed)))))

        }

    }



    /// @dev Returns the extra data for token `id`.

    /// Minting, transferring, burning a token will not change the extra data.

    /// The extra data can be set on a non existent token.

    function _getExtraData(uint256 id) internal view virtual returns (uint96 result) {

        /// @solidity memory-safe-assembly

        assembly {

            mstore(0x00, id)

            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)

            result := shr(160, sload(add(id, add(id, keccak256(0x00, 0x20)))))

        }

    }



    /// @dev Sets the extra data for token `id` to `value`.

    /// Minting, transferring, burning a token will not change the extra data.

    /// The extra data can be set on a non existent token.

    function _setExtraData(uint256 id, uint96 value) internal virtual {

        /// @solidity memory-safe-assembly

        assembly {

            mstore(0x00, id)

            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)

            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))

            let packed := sload(ownershipSlot)

            sstore(ownershipSlot, xor(packed, shl(160, xor(value, shr(160, packed)))))

        }

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                  INTERNAL MINT FUNCTIONS                   */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Mints token `id` to `to`.

    ///

    /// Requirements:

    ///

    /// - Token `id` must not exist.

    /// - `to` cannot be the zero address.

    ///

    /// Emits a {Transfer} event.

    function _mint(address to, uint256 id) internal virtual {

        _beforeTokenTransfer(address(0), to, id);

        /// @solidity memory-safe-assembly

        assembly {

            // Clear the upper 96 bits.

            to := shr(96, shl(96, to))

            // Revert if `to` is the zero address.

            if iszero(to) {

                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.

                revert(0x1c, 0x04)

            }

            // Load the ownership data.

            mstore(0x00, id)

            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)

            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))

            let ownershipPacked := sload(ownershipSlot)

            // Revert if the token already exists.

            if shl(96, ownershipPacked) {

                mstore(0x00, 0xc991cbb1) // `TokenAlreadyExists()`.

                revert(0x1c, 0x04)

            }

            // Update with the owner.

            sstore(ownershipSlot, or(ownershipPacked, to))

            // Increment the balance of the owner.

            {

                mstore(0x00, to)

                let balanceSlot := keccak256(0x0c, 0x1c)

                let balanceSlotPacked := add(sload(balanceSlot), 1)

                if iszero(and(balanceSlotPacked, _MAX_ACCOUNT_BALANCE)) {

                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.

                    revert(0x1c, 0x04)

                }

                sstore(balanceSlot, balanceSlotPacked)

            }

            // Emit the {Transfer} event.

            log4(0x00, 0x00, _TRANSFER_EVENT_SIGNATURE, 0, to, id)

        }

        _afterTokenTransfer(address(0), to, id);

    }



    /// @dev Equivalent to `_safeMint(to, id, "")`.

    function _safeMint(address to, uint256 id) internal virtual {

        _safeMint(to, id, "");

    }



    /// @dev Mints token `id` to `to`.

    ///

    /// Requirements:

    ///

    /// - Token `id` must not exist.

    /// - `to` cannot be the zero address.

    /// - If `to` refers to a smart contract, it must implement

    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.

    ///

    /// Emits a {Transfer} event.

    function _safeMint(address to, uint256 id, bytes memory data) internal virtual {

        _mint(to, id);

        if (_hasCode(to)) _checkOnERC721Received(address(0), to, id, data);

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                  INTERNAL BURN FUNCTIONS                   */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Equivalent to `_burn(address(0), id)`.

    function _burn(uint256 id) internal virtual {

        _burn(address(0), id);

    }



    /// @dev Destroys token `id`, using `by`.

    ///

    /// Requirements:

    ///

    /// - Token `id` must exist.

    /// - If `by` is not the zero address,

    ///   it must be the owner of the token, or be approved to manage the token.

    ///

    /// Emits a {Transfer} event.

    function _burn(address by, uint256 id) internal virtual {

        address owner = ownerOf(id);

        _beforeTokenTransfer(owner, address(0), id);

        /// @solidity memory-safe-assembly

        assembly {

            // Clear the upper 96 bits.

            by := shr(96, shl(96, by))

            // Load the ownership data.

            mstore(0x00, id)

            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, by))

            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))

            let ownershipPacked := sload(ownershipSlot)

            // Reload the owner in case it is changed in `_beforeTokenTransfer`.

            owner := shr(96, shl(96, ownershipPacked))

            // Revert if the token does not exist.

            if iszero(owner) {

                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.

                revert(0x1c, 0x04)

            }

            // Load and check the token approval.

            {

                mstore(0x00, owner)

                let approvedAddress := sload(add(1, ownershipSlot))

                // If `by` is not the zero address, do the authorization check.

                // Revert if the `by` is not the owner, nor approved.

                if iszero(or(iszero(by), or(eq(by, owner), eq(by, approvedAddress)))) {

                    if iszero(sload(keccak256(0x0c, 0x30))) {

                        mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.

                        revert(0x1c, 0x04)

                    }

                }

                // Delete the approved address if any.

                if approvedAddress {

                    sstore(add(1, ownershipSlot), 0)

                }

            }

            // Clear the owner.

            sstore(ownershipSlot, xor(ownershipPacked, owner))

            // Decrement the balance of `owner`.

            {

                let balanceSlot := keccak256(0x0c, 0x1c)

                sstore(balanceSlot, sub(sload(balanceSlot), 1))

            }

            // Emit the {Transfer} event.

            log4(0x00, 0x00, _TRANSFER_EVENT_SIGNATURE, owner, 0, id)

        }

        _afterTokenTransfer(owner, address(0), id);

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                INTERNAL APPROVAL FUNCTIONS                 */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Returns whether `account` is the owner of token `id`, or is approved to managed it.

    ///

    /// Requirements:

    /// - Token `id` must exist.

    function _isApprovedOrOwner(address account, uint256 id) internal view virtual returns (bool result) {

        /// @solidity memory-safe-assembly

        assembly {

            result := 1

            // Clear the upper 96 bits.

            account := shr(96, shl(96, account))

            // Load the ownership data.

            mstore(0x00, id)

            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, account))

            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))

            let owner := shr(96, shl(96, sload(ownershipSlot)))

            // Revert if the token does not exist.

            if iszero(owner) {

                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.

                revert(0x1c, 0x04)

            }

            // Check if `account` is the `owner`.

            if iszero(eq(account, owner)) {

                mstore(0x00, owner)

                // Check if `account` is approved to

                if iszero(sload(keccak256(0x0c, 0x30))) {

                    result := eq(account, sload(add(1, ownershipSlot)))

                }

            }

        }

    }



    /// @dev Returns the account approved to manage token `id`.

    /// Returns the zero address instead of reverting if the token does not exist.

    function _getApproved(uint256 id) internal view virtual returns (address result) {

        /// @solidity memory-safe-assembly

        assembly {

            mstore(0x00, id)

            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)

            result := sload(add(1, add(id, add(id, keccak256(0x00, 0x20)))))

        }

    }



    /// @dev Equivalent to `_approve(address(0), account, id)`.

    function _approve(address account, uint256 id) internal virtual {

        _approve(address(0), account, id);

    }



    /// @dev Sets `account` as the approved account to manage token `id`, using `by`.

    ///

    /// Requirements:

    /// - Token `id` must exist.

    /// - If `by` is not the zero address, `by` must be the owner

    ///   or an approved operator for the token owner.

    ///

    /// Emits a {Transfer} event.

    function _approve(address by, address account, uint256 id) internal virtual {

        assembly {

            // Clear the upper 96 bits.

            let bitmaskAddress := shr(96, not(0))

            account := and(bitmaskAddress, account)

            by := and(bitmaskAddress, by)

            // Load the owner of the token.

            mstore(0x00, id)

            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, by))

            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))

            let owner := and(bitmaskAddress, sload(ownershipSlot))

            // Revert if the token does not exist.

            if iszero(owner) {

                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.

                revert(0x1c, 0x04)

            }

            // If `by` is not the zero address, do the authorization check.

            // Revert if `by` is not the owner, nor approved.

            if iszero(or(iszero(by), eq(by, owner))) {

                mstore(0x00, owner)

                if iszero(sload(keccak256(0x0c, 0x30))) {

                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.

                    revert(0x1c, 0x04)

                }

            }

            // Sets `account` as the approved account to manage `id`.

            sstore(add(1, ownershipSlot), account)

            // Emit the {Approval} event.

            log4(0x00, 0x00, _APPROVAL_EVENT_SIGNATURE, owner, account, id)

        }

    }



    /// @dev Approve or remove the `operator` as an operator for `by`,

    /// without authorization checks.

    ///

    /// Emits a {ApprovalForAll} event.

    function _setApprovalForAll(address by, address operator, bool isApproved) internal virtual {

        /// @solidity memory-safe-assembly

        assembly {

            // Clear the upper 96 bits.

            by := shr(96, shl(96, by))

            operator := shr(96, shl(96, operator))

            // Convert to 0 or 1.

            isApproved := iszero(iszero(isApproved))

            // Update the `isApproved` for (`by`, `operator`).

            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, operator))

            mstore(0x00, by)

            sstore(keccak256(0x0c, 0x30), isApproved)

            // Emit the {ApprovalForAll} event.

            mstore(0x00, isApproved)

            log3(0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, by, operator)

        }

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                INTERNAL TRANSFER FUNCTIONS                 */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Equivalent to `_transfer(address(0), from, to, id)`.

    function _transfer(address from, address to, uint256 id) internal virtual {

        _transfer(address(0), from, to, id);

    }



    /// @dev Transfers token `id` from `from` to `to`.

    ///

    /// Requirements:

    ///

    /// - Token `id` must exist.

    /// - `from` must be the owner of the token.

    /// - `to` cannot be the zero address.

    /// - If `by` is not the zero address,

    ///   it must be the owner of the token, or be approved to manage the token.

    ///

    /// Emits a {Transfer} event.

    function _transfer(address by, address from, address to, uint256 id) internal virtual {

        _beforeTokenTransfer(from, to, id);

        /// @solidity memory-safe-assembly

        assembly {

            // Clear the upper 96 bits.

            let bitmaskAddress := shr(96, not(0))

            from := and(bitmaskAddress, from)

            to := and(bitmaskAddress, to)

            by := and(bitmaskAddress, by)

            // Load the ownership data.

            mstore(0x00, id)

            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, by))

            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))

            let ownershipPacked := sload(ownershipSlot)

            let owner := and(bitmaskAddress, ownershipPacked)

            // Revert if `from` is not the owner, or does not exist.

            if iszero(mul(owner, eq(owner, from))) {

                if iszero(owner) {

                    mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.

                    revert(0x1c, 0x04)

                }

                mstore(0x00, 0xa1148100) // `TransferFromIncorrectOwner()`.

                revert(0x1c, 0x04)

            }

            // Revert if `to` is the zero address.

            if iszero(to) {

                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.

                revert(0x1c, 0x04)

            }

            // Load, check, and update the token approval.

            {

                mstore(0x00, from)

                let approvedAddress := sload(add(1, ownershipSlot))

                // If `by` is not the zero address, do the authorization check.

                // Revert if the `by` is not the owner, nor approved.

                if iszero(or(iszero(by), or(eq(by, from), eq(by, approvedAddress)))) {

                    if iszero(sload(keccak256(0x0c, 0x30))) {

                        mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.

                        revert(0x1c, 0x04)

                    }

                }

                // Delete the approved address if any.

                if approvedAddress {

                    sstore(add(1, ownershipSlot), 0)

                }

            }

            // Update with the new owner.

            sstore(ownershipSlot, xor(ownershipPacked, xor(from, to)))

            // Decrement the balance of `from`.

            {

                let fromBalanceSlot := keccak256(0x0c, 0x1c)

                sstore(fromBalanceSlot, sub(sload(fromBalanceSlot), 1))

            }

            // Increment the balance of `to`.

            {

                mstore(0x00, to)

                let toBalanceSlot := keccak256(0x0c, 0x1c)

                let toBalanceSlotPacked := add(sload(toBalanceSlot), 1)

                if iszero(and(toBalanceSlotPacked, _MAX_ACCOUNT_BALANCE)) {

                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.

                    revert(0x1c, 0x04)

                }

                sstore(toBalanceSlot, toBalanceSlotPacked)

            }

            // Emit the {Transfer} event.

            log4(0x00, 0x00, _TRANSFER_EVENT_SIGNATURE, from, to, id)

        }

        _afterTokenTransfer(from, to, id);

    }



    /// @dev Equivalent to `_safeTransfer(from, to, id, "")`.

    function _safeTransfer(address from, address to, uint256 id) internal virtual {

        _safeTransfer(from, to, id, "");

    }



    /// @dev Transfers token `id` from `from` to `to`.

    ///

    /// Requirements:

    ///

    /// - Token `id` must exist.

    /// - `from` must be the owner of the token.

    /// - `to` cannot be the zero address.

    /// - The caller must be the owner of the token, or be approved to manage the token.

    /// - If `to` refers to a smart contract, it must implement

    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.

    ///

    /// Emits a {Transfer} event.

    function _safeTransfer(address from, address to, uint256 id, bytes memory data) internal virtual {

        _transfer(address(0), from, to, id);

        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);

    }



    /// @dev Equivalent to `_safeTransfer(by, from, to, id, "")`.

    function _safeTransfer(address by, address from, address to, uint256 id) internal virtual {

        _safeTransfer(by, from, to, id, "");

    }



    /// @dev Transfers token `id` from `from` to `to`.

    ///

    /// Requirements:

    ///

    /// - Token `id` must exist.

    /// - `from` must be the owner of the token.

    /// - `to` cannot be the zero address.

    /// - If `by` is not the zero address,

    ///   it must be the owner of the token, or be approved to manage the token.

    /// - If `to` refers to a smart contract, it must implement

    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.

    ///

    /// Emits a {Transfer} event.

    function _safeTransfer(address by, address from, address to, uint256 id, bytes memory data) internal virtual {

        _transfer(by, from, to, id);

        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                    HOOKS FOR OVERRIDING                    */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Hook that is called before any token transfers, including minting and burning.

    function _beforeTokenTransfer(address from, address to, uint256 id) internal virtual {}



    /// @dev Hook that is called after any token transfers, including minting and burning.

    function _afterTokenTransfer(address from, address to, uint256 id) internal virtual {}



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                      PRIVATE HELPERS                       */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Returns if `a` has bytecode of non-zero length.

    function _hasCode(address a) private view returns (bool result) {

        /// @solidity memory-safe-assembly

        assembly {

            result := extcodesize(a) // Can handle dirty upper bits.

        }

    }



    /// @dev Perform a call to invoke {IERC721Receiver-onERC721Received} on `to`.

    /// Reverts if the target does not support the function correctly.

    function _checkOnERC721Received(address from, address to, uint256 id, bytes memory data) private {

        /// @solidity memory-safe-assembly

        assembly {

            // Prepare the calldata.

            let m := mload(0x40)

            let onERC721ReceivedSelector := 0x150b7a02

            mstore(m, onERC721ReceivedSelector)

            mstore(add(m, 0x20), caller()) // The `operator`, which is always `msg.sender`.

            mstore(add(m, 0x40), shr(96, shl(96, from)))

            mstore(add(m, 0x60), id)

            mstore(add(m, 0x80), 0x80)

            let n := mload(data)

            mstore(add(m, 0xa0), n)

            if n {

                pop(staticcall(gas(), 4, add(data, 0x20), n, add(m, 0xc0), n))

            }

            // Revert if the call reverts.

            if iszero(call(gas(), to, 0, add(m, 0x1c), add(n, 0xa4), m, 0x20)) {

                if returndatasize() {

                    // Bubble up the revert if the call reverts.

                    returndatacopy(0x00, 0x00, returndatasize())

                    revert(0x00, returndatasize())

                }

                mstore(m, 0)

            }

            // Load the returndata and compare it.

            if iszero(eq(mload(m), shl(224, onERC721ReceivedSelector))) {

                mstore(0x00, 0xd1a57ed6) // `TransferToNonERC721ReceiverImplementer()`.

                revert(0x1c, 0x04)

            }

        }

    }



    /**

     * @dev Converts a uint256 to its ASCII string decimal representation.

     */

    function _toString(uint256 value) internal pure virtual returns (string memory str) {

        assembly {

            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but

            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.

            // We will need 1 word for the trailing zeros padding, 1 word for the length,

            // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.

            let m := add(mload(0x40), 0xa0)

            // Update the free memory pointer to allocate.

            mstore(0x40, m)

            // Assign the `str` to the end.

            str := sub(m, 0x20)

            // Zeroize the slot after the string.

            mstore(str, 0)



            // Cache the end of the memory to calculate the length later.

            let end := str



            // We write the string from rightmost digit to leftmost digit.

            // The following is essentially a do-while loop that also handles the zero case.

            // prettier-ignore

            for { let temp := value } 1 {} {

                str := sub(str, 1)

                // Write the character to the pointer.

                // The ASCII index of the '0' character is 48.

                mstore8(str, add(48, mod(temp, 10)))

                // Keep dividing `temp` until zero.

                temp := div(temp, 10)

                // prettier-ignore

                if iszero(temp) { break }

            }



            let length := sub(end, str)

            // Move the pointer 32 bytes leftwards to make room for the length.

            str := sub(str, 0x20)

            // Store the length.

            mstore(str, length)

        }

    }



    /// @dev Returns the hexadecimal representation of `value`.

    /// The output is prefixed with "0x" and encoded using 2 hexadecimal digits per byte.

    function _toHexString(address value) internal pure returns (string memory str) {

        str = _toHexStringNoPrefix(value);

        /// @solidity memory-safe-assembly

        assembly {

            let strLength := add(mload(str), 2) // Compute the length.

            mstore(str, 0x3078) // Write the "0x" prefix.

            str := sub(str, 2) // Move the pointer.

            mstore(str, strLength) // Write the length.

        }

    }



    /// @dev Returns the hexadecimal representation of `value`.

    /// The output is encoded using 2 hexadecimal digits per byte.

    function _toHexStringNoPrefix(address value) internal pure returns (string memory str) {

        /// @solidity memory-safe-assembly

        assembly {

            str := mload(0x40)



            // Allocate the memory.

            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,

            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.

            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.

            mstore(0x40, add(str, 0x80))



            // Store "0123456789abcdef" in scratch space.

            mstore(0x0f, 0x30313233343536373839616263646566)



            str := add(str, 2)

            mstore(str, 40)



            let o := add(str, 0x20)

            mstore(add(o, 40), 0)



            value := shl(96, value)



            // We write the string from rightmost digit to leftmost digit.

            // The following is essentially a do-while loop that also handles the zero case.

            for {

                let i := 0

            } 1 {



            } {

                let p := add(o, add(i, i))

                let temp := byte(i, value)

                mstore8(add(p, 1), mload(and(temp, 15)))

                mstore8(p, mload(shr(4, temp)))

                i := add(i, 1)

                if eq(i, 20) {

                    break

                }

            }

        }

    }

}



/**

 * @dev Interface of ERC721ABurnable.

 */

interface IERC721Burnable {

    /**

     * @dev Burns `tokenId`. See {ERC721A-_burn}.

     *

     * Requirements:

     *

     * - The caller must own `tokenId` or be an approved operator.

     */

    function burn(uint256 tokenId) external;

}



/**

 * @title ERC721Burnable.

 *

 * @dev ERC721 token that can be irreversibly burned (destroyed).

 */

abstract contract ERC721Burnable is ERC721, IERC721Burnable {

    /**

     * @dev Burns `tokenId`. See {ERC721-_burn}.

     *

     * Requirements:

     *

     * - The caller must own `tokenId` or be an approved operator.

     */

    function burn(uint256 tokenId) public virtual override {

        _burn(tokenId);

    }

}



/// @notice Based on the reference implementation of the EIP-4494

/// @notice See https://github.com/dievardump/erc721-with-permits and https://eips.ethereum.org/EIPS/eip-4494

/// @author Simon Fremaux (@dievardump) & William SchwabSchwab (@wschwab)

interface IERC4494 {

    function DOMAIN_SEPARATOR() external view returns (bytes32);



    /// @notice Allows to retrieve current nonce for token

    /// @param tokenId token id

    /// @return current token nonce

    function nonces(uint256 tokenId) external view returns (uint256);



    /// @notice function to be called by anyone to approve `spender` using a Permit signature

    /// @dev Anyone can call this to approve `spender`, even a third-party

    /// @param spender the actor to approve

    /// @param tokenId the token id

    /// @param deadline the deadline for the permit to be used

    /// @param signature permit

    function permit(address spender, uint256 tokenId, uint256 deadline, bytes memory signature) external;

}



/// @notice Contract for EIP-712 typed structured data hashing and signing.

/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/EIP712.sol)

/// @author Modified from Solbase (https://github.com/Sol-DAO/solbase/blob/main/src/utils/EIP712.sol)

/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/EIP712.sol)

/// Note, this implementation:

/// - Uses `address(this)` for the `verifyingContract` field.

/// - Does NOT use the optional EIP-712 salt.

/// - Does NOT use any EIP-712 extensions.

/// This is for simplicity and to save gas.

/// If you need to customize, please fork / modify accordingly.

abstract contract EIP712 {

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                  CONSTANTS AND IMMUTABLES                  */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev `keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)")`.

    bytes32 internal constant _DOMAIN_TYPEHASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;



    address private immutable _cachedThis;

    uint256 private immutable _cachedChainId;

    bytes32 private immutable _cachedNameHash;

    bytes32 private immutable _cachedVersionHash;

    bytes32 private immutable _cachedDomainSeparator;



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                        CONSTRUCTOR                         */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Cache the hashes for cheaper runtime gas costs.

    /// In the case of upgradeable contracts (i.e. proxies),

    /// or if the chain id changes due to a hard fork,

    /// the domain separator will be seamlessly calculated on-the-fly.

    constructor() {

        _cachedThis = address(this);

        _cachedChainId = block.chainid;



        (string memory name, string memory version) = _domainNameAndVersion();

        bytes32 nameHash = keccak256(bytes(name));

        bytes32 versionHash = keccak256(bytes(version));

        _cachedNameHash = nameHash;

        _cachedVersionHash = versionHash;



        bytes32 separator;

        /// @solidity memory-safe-assembly

        assembly {

            let m := mload(0x40) // Load the free memory pointer.

            mstore(m, _DOMAIN_TYPEHASH)

            mstore(add(m, 0x20), nameHash)

            mstore(add(m, 0x40), versionHash)

            mstore(add(m, 0x60), chainid())

            mstore(add(m, 0x80), address())

            separator := keccak256(m, 0xa0)

        }

        _cachedDomainSeparator = separator;

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                   FUNCTIONS TO OVERRIDE                    */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Please override this function to return the domain name and version.

    /// ```

    ///     function _domainNameAndVersion()

    ///         internal

    ///         pure

    ///         virtual

    ///         returns (string memory name, string memory version)

    ///     {

    ///         name = "Solady";

    ///         version = "1";

    ///     }

    /// ```

    function _domainNameAndVersion() internal pure virtual returns (string memory name, string memory version);



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                     HASHING OPERATIONS                     */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Returns the EIP-712 domain separator.

    function _domainSeparator() internal view virtual returns (bytes32 separator) {

        separator = _cachedDomainSeparator;

        if (_cachedDomainSeparatorInvalidated()) {

            separator = _buildDomainSeparator();

        }

    }



    /// @dev Returns the hash of the fully encoded EIP-712 message for this domain,

    /// given `structHash`, as defined in

    /// https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct.

    ///

    /// The hash can be used together with {ECDSA-recover} to obtain the signer of a message:

    /// ```

    ///     bytes32 digest = _hashTypedData(keccak256(abi.encode(

    ///         keccak256("Mail(address to,string contents)"),

    ///         mailTo,

    ///         keccak256(bytes(mailContents))

    ///     )));

    ///     address signer = ECDSA.recover(digest, signature);

    /// ```

    function _hashTypedData(bytes32 structHash) internal view virtual returns (bytes32 digest) {

        bytes32 separator = _cachedDomainSeparator;

        if (_cachedDomainSeparatorInvalidated()) {

            separator = _buildDomainSeparator();

        }

        /// @solidity memory-safe-assembly

        assembly {

            // Compute the digest.

            mstore(0x00, 0x1901000000000000) // Store "\x19\x01".

            mstore(0x1a, separator) // Store the domain separator.

            mstore(0x3a, structHash) // Store the struct hash.

            digest := keccak256(0x18, 0x42)

            // Restore the part of the free memory slot that was overwritten.

            mstore(0x3a, 0)

        }

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                    EIP-5267 OPERATIONS                     */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev See: https://eips.ethereum.org/EIPS/eip-5267

    function eip712Domain()

        public

        view

        virtual

        returns (

            bytes1 fields,

            string memory name,

            string memory version,

            uint256 chainId,

            address verifyingContract,

            bytes32 salt,

            uint256[] memory extensions

        )

    {

        fields = hex"0f"; // `0b01111`.

        (name, version) = _domainNameAndVersion();

        chainId = block.chainid;

        verifyingContract = address(this);

        salt = salt; // `bytes32(0)`.

        extensions = extensions; // `new uint256[](0)`.

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                      PRIVATE HELPERS                       */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Returns the EIP-712 domain separator.

    function _buildDomainSeparator() private view returns (bytes32 separator) {

        bytes32 nameHash = _cachedNameHash;

        bytes32 versionHash = _cachedVersionHash;

        /// @solidity memory-safe-assembly

        assembly {

            let m := mload(0x40) // Load the free memory pointer.

            mstore(m, _DOMAIN_TYPEHASH)

            mstore(add(m, 0x20), nameHash)

            mstore(add(m, 0x40), versionHash)

            mstore(add(m, 0x60), chainid())

            mstore(add(m, 0x80), address())

            separator := keccak256(m, 0xa0)

        }

    }



    /// @dev Returns if the cached domain separator has been invalidated.

    function _cachedDomainSeparatorInvalidated() private view returns (bool result) {

        uint256 cachedChainId = _cachedChainId;

        address cachedThis = _cachedThis;

        /// @solidity memory-safe-assembly

        assembly {

            result := iszero(and(eq(chainid(), cachedChainId), eq(address(), cachedThis)))

        }

    }

}



/// @dev OpenZeppelin's ERC721Upgradeable extended with EIP-4494-compliant permits

/// @notice Based on the reference implementation of the EIP-4494

/// @notice See https://github.com/dievardump/erc721-with-permits and https://eips.ethereum.org/EIPS/eip-4494

abstract contract ERC721Permit is IERC4494, EIP712, ERC721 {

    /// @dev value is equal to keccak256("Permit(address spender,uint256 tokenId,uint256 nonce,uint256 deadline)")

    bytes32 public constant PERMIT_TYPEHASH = 0x49ecf333e5b8c95c40fdafc95c1ad136e8914a8fb55e9dc8bb01eaa83a2df9ad;



    mapping(uint256 => uint256) internal _nonces;



    /// @notice Builds the DOMAIN_SEPARATOR (eip712) at time of use

    /// @dev This is not set as a constant, to ensure that the chainId will change in the event of a chain fork

    /// @return the DOMAIN_SEPARATOR of eip712

    function DOMAIN_SEPARATOR() public view override returns (bytes32) {

        return _domainSeparator();

    }



    /// @notice Allows to retrieve current nonce for token

    /// @param tokenId token id

    /// @return current token nonce

    function nonces(uint256 tokenId) public view override returns (uint256) {

        require(_exists(tokenId), "!EXIST");

        return _nonces[tokenId];

    }



    /// @notice function to be called by anyone to approve `spender` using a Permit signature

    /// @dev Anyone can call this to approve `spender`, even a third-party

    /// @param spender_ the actor to approve

    /// @param tokenId_ the token id

    /// @param deadline_ the deadline for the permit to be used

    /// @param signature_ permit

    function permit(address spender_, uint256 tokenId_, uint256 deadline_, bytes memory signature_) external override {

        require(deadline_ >= block.timestamp, "EXPRIED");



        bytes32 digest = _buildDigest(spender_, tokenId_, _nonces[tokenId_], deadline_);



        (address recoveredAddress, ) = ECDSA.tryRecover(digest, signature_);

        require((recoveredAddress != address(0) && _isApprovedOrOwner(recoveredAddress, tokenId_)), "!PERMIT");



        _approve(spender_, tokenId_);

    }



    /// @notice Builds the permit digest to sign

    /// @param spender_ the token spender

    /// @param tokenId_ the tokenId

    /// @param nonce_ the nonce to make a permit for

    /// @param deadline_ the deadline before when the permit can be used

    /// @return the digest (following eip712) to sign

    function _buildDigest(

        address spender_,

        uint256 tokenId_,

        uint256 nonce_,

        uint256 deadline_

    ) private view returns (bytes32) {

        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, spender_, tokenId_, nonce_, deadline_));

        return _hashTypedData(structHash);

    }



    /// @dev helper to easily increment a nonce for a given tokenId

    /// @param tokenId the tokenId to increment the nonce for

    function _incrementNonce(uint256 tokenId) internal {

        assembly {

            mstore(0x00, tokenId)

            mstore(0x20, _nonces.slot)

            let key := keccak256(0x00, 0x40)

            sstore(key, add(sload(key), 1))

        }

    }



    function _transfer(address from_, address to_, uint256 tokenId_) internal virtual override {

        // increment the nonce to be sure it can't be reused

        _incrementNonce(tokenId_);



        // do normal transfer

        super._transfer(from_, to_, tokenId_);

    }

}



/**

 * @dev Interface of IERC721URIStorage.

 */

interface IERC721URIStorage {

    event NewBaseTokenURI(string baseTokenURI);



    function baseURI() external view returns (string memory);

}



/**

 * @dev ERC721 token with storage based token URI management.

 */

abstract contract ERC721URIStorage is IERC721URIStorage, ERC721 {

    string internal _baseUri;



    function baseURI() external view override returns (string memory) {

        return _baseURI();

    }



    function _baseURI() internal view virtual override returns (string memory) {

        return _baseUri;

    }



    function _setBaseURI(string memory baseUri_) internal virtual {

        _baseUri = baseUri_;

        emit NewBaseTokenURI(baseUri_);

    }

}



interface IPresale {

    function setMinted(address account_) external;

}



abstract contract ReentrancyGuard {

    error ReentrancyGuard__Locked();

    uint256 private locked = 1;



    modifier nonReentrant() virtual {

        if (locked > 1) revert ReentrancyGuard__Locked();



        locked = 2;



        _;



        locked = 1;

    }

}



library SafeTransferLib {

    /*//////////////////////////////////////////////////////////////

                             ETH OPERATIONS

    //////////////////////////////////////////////////////////////*/



    function safeTransferETH(address to, uint256 amount) internal {

        bool success;



        /// @solidity memory-safe-assembly

        assembly {

            // Transfer the ETH and store if it succeeded or not.

            success := call(gas(), to, amount, 0, 0, 0, 0)

        }



        require(success, "ETH_TRANSFER_FAILED");

    }



    /*//////////////////////////////////////////////////////////////

                            ERC20 OPERATIONS

    //////////////////////////////////////////////////////////////*/



    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {

        bool success;



        /// @solidity memory-safe-assembly

        assembly {

            // Get a pointer to some free memory.

            let freeMemoryPointer := mload(0x40)



            // Write the abi-encoded calldata into memory, beginning with the function selector.

            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)

            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the "from" argument.

            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the "to" argument.

            mstore(add(freeMemoryPointer, 68), amount) // Append the "amount" argument. Masking not required as it's a full 32 byte type.



            success := and(

                // Set success to whether the call reverted, if not we check it either

                // returned exactly 1 (can't just be non-zero data), or had no return data.

                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),

                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.

                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.

                // Counterintuitively, this call must be positioned second to the or() call in the

                // surrounding and() call or else returndatasize() will be zero during the computation.

                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)

            )

        }



        require(success, "TRANSFER_FROM_FAILED");

    }



    function safeTransfer(address token, address to, uint256 amount) internal {

        bool success;



        /// @solidity memory-safe-assembly

        assembly {

            // Get a pointer to some free memory.

            let freeMemoryPointer := mload(0x40)



            // Write the abi-encoded calldata into memory, beginning with the function selector.

            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)

            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the "to" argument.

            mstore(add(freeMemoryPointer, 36), amount) // Append the "amount" argument. Masking not required as it's a full 32 byte type.



            success := and(

                // Set success to whether the call reverted, if not we check it either

                // returned exactly 1 (can't just be non-zero data), or had no return data.

                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),

                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.

                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.

                // Counterintuitively, this call must be positioned second to the or() call in the

                // surrounding and() call or else returndatasize() will be zero during the computation.

                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)

            )

        }



        require(success, "TRANSFER_FAILED");

    }



    function safeApprove(address token, address to, uint256 amount) internal {

        bool success;



        /// @solidity memory-safe-assembly

        assembly {

            // Get a pointer to some free memory.

            let freeMemoryPointer := mload(0x40)



            // Write the abi-encoded calldata into memory, beginning with the function selector.

            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)

            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the "to" argument.

            mstore(add(freeMemoryPointer, 36), amount) // Append the "amount" argument. Masking not required as it's a full 32 byte type.



            success := and(

                // Set success to whether the call reverted, if not we check it either

                // returned exactly 1 (can't just be non-zero data), or had no return data.

                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),

                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.

                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.

                // Counterintuitively, this call must be positioned second to the or() call in the

                // surrounding and() call or else returndatasize() will be zero during the computation.

                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)

            )

        }



        require(success, "APPROVE_FAILED");

    }

}



contract ETH20AVATAR is ERC721, ERC721Burnable, ERC721Permit, ERC721URIStorage, Ownable, ReentrancyGuard {

    uint256 public constant MAX_SUPLLY = 10000;

    uint256 private _idCounter;

    address presaleContract;



    /**

     * @dev Initializes the MyBoi NFT.

     * @param name_ The name of the token.

     * @param symbol_ The symbol of the token.

     * @param baseUri_ The base URI for token metadata.

     */

    constructor(

        address presaleContract_,

        string memory name_,

        string memory symbol_,

        string memory baseUri_

    ) ERC721(name_, symbol_) {

        _setBaseURI(baseUri_);

        _idCounter = 1;

        presaleContract = presaleContract_;

    }



    /**

     * @dev Checks if a given token ID exists.

     * @param tokenId_ The ID of the token to check.

     * @return A boolean indicating whether the token exists.

     */

    function exists(uint256 tokenId_) external view returns (bool) {

        return _exists(tokenId_);

    }



    /**

     * @dev Returns the total number of tokens minted.

     * @return The total number of tokens minted.

     */

    function totalMinted() external view returns (uint256) {

        return _idCounter - 1;

    }



    /**

     * @dev Sets the base token URI for token metadata.

     * @param baseTokenURI_ The new base token URI.

     */

    function setBaseTokenURI(string calldata baseTokenURI_) external onlyOwner {

        _setBaseURI(baseTokenURI_);

    }



    function mint() external nonReentrant {

        address sender = _msgSender();

        IPresale(presaleContract).setMinted(sender);

        _safeMint(sender, _idCounter);

        _idCounter++;

    }



    // The following functions are overrides required by Solidity.



    /**

     * @dev Transfers the ownership of a token from one address to another.

     * @param from_ The current owner of the token.

     * @param to_ The new owner of the token.

     * @param tokenId_ The ID of the token to transfer.

     */

    function _transfer(address from_, address to_, uint256 tokenId_) internal override(ERC721, ERC721Permit) {

        super._transfer(from_, to_, tokenId_);

    }



    /**

     * @dev Returns the base URI for token metadata.

     * @return The base URI for token metadata.

     */

    function _baseURI() internal view virtual override(ERC721, ERC721URIStorage) returns (string memory) {

        return _baseUri;

    }



    /**

     * @dev Returns the name and version of the ERC712.

     * @return The name and version of the contract.

     */

    function _domainNameAndVersion() internal pure override returns (string memory, string memory) {

        return ("ETH20 AVATAR", "1");

    }

}