{{

  "language": "Solidity",

  "sources": {

    "contracts/StoryProtocol.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\n// See https://github.com/storyprotocol/protocol-contracts/blob/main/StoryProtocol-AlphaTestingAgreement-17942166.3.pdf\npragma solidity ^0.8.19;\n\nimport { Multicall } from \"@openzeppelin/contracts/utils/Multicall.sol\";\n\nimport { IIPOrgController } from \"contracts/interfaces/ip-org/IIPOrgController.sol\";\nimport { IIPOrg } from \"contracts/interfaces/ip-org/IIPOrg.sol\";\n\nimport { Errors } from \"contracts/lib/Errors.sol\";\nimport { LibRelationship } from \"contracts/lib/modules/LibRelationship.sol\";\nimport { Licensing } from \"contracts/lib/modules/Licensing.sol\";\nimport { ModuleRegistry } from \"contracts/modules/ModuleRegistry.sol\";\nimport { Registration } from \"contracts/lib/modules/Registration.sol\";\nimport { RELATIONSHIP_MODULE, LICENSING_MODULE, REGISTRATION_MODULE } from \"contracts/lib/modules/Module.sol\";\n\n/// @title Story Protocol Gateway Contract\n/// @notice The Story Protocol contract acts as a global gateway for calling\n///         protocol-standardized IP actions (based on their enrolled modules).\n///         Most functions can be solely executed through this contract, as it will\n///         be actively maintained and upgraded to support all standardized modules.\n///         In the future, for more customized logic, IP Orgs may choose to create\n///         their own frontend contracts (gateways) for IP interaction.\ncontract StoryProtocol is Multicall {\n    /// @notice The IP Org Controller administers creation of new IP Orgs.\n    IIPOrgController public immutable IP_ORG_CONTROLLER;\n\n    /// @notice The module registry is used to authorize calls to modules.\n    ModuleRegistry public immutable MODULE_REGISTRY;\n\n    /// @notice Initializes a new Story Protocol gateway contract.\n    /// @param ipOrgController_ IP Org Controller contract, used for IP Org creation.\n    /// @param moduleRegistry_ Protocol-wide module registry used for module bookkeeping.\n    constructor(IIPOrgController ipOrgController_, ModuleRegistry moduleRegistry_) {\n        if (address(ipOrgController_) == address(0) || address(moduleRegistry_) == address(0)) {\n            revert Errors.ZeroAddress();\n        }\n        IP_ORG_CONTROLLER = ipOrgController_;\n        MODULE_REGISTRY = moduleRegistry_;\n    }\n\n    ////////////////////////////////////////////////////////////////////////////\n    //                                 IPOrg                                  //\n    ////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Sets the metadata for an IP Org.\n    /// @param ipOrg_ The address of the IP Org being configured.\n    /// @param baseURI_ The base token metadata URI for the IP Org.\n    /// @param contractURI_ The contract URI associated with the IP Org.\n    function setMetadata(address ipOrg_, string calldata baseURI_, string calldata contractURI_) public {\n        bytes memory encodedParams = abi.encode(Registration.SET_IP_ORG_METADATA, abi.encode(baseURI_, contractURI_));\n        MODULE_REGISTRY.configure(IIPOrg(ipOrg_), msg.sender, REGISTRATION_MODULE, encodedParams);\n    }\n\n    /// @notice Adds additional IP asset types for an IP Org.\n    /// @param ipOrg_ The address of the IP Org being configured.\n    /// @param ipAssetTypes_ The IP asset type descriptors to add for the IPOrg.\n    function addIPAssetTypes(address ipOrg_, string[] calldata ipAssetTypes_) public {\n        bytes memory encodedParams = abi.encode(Registration.SET_IP_ORG_ASSET_TYPES, abi.encode(ipAssetTypes_));\n        MODULE_REGISTRY.configure(IIPOrg(ipOrg_), msg.sender, REGISTRATION_MODULE, encodedParams);\n    }\n\n    /// @notice Registers a new IP Org\n    /// @param owner_ The address of the IP Org to be registered.\n    /// @param name_ A name to associate with the IP Org.\n    /// @param symbol_ A symbol to associate with the IP Org.\n    function registerIpOrg(\n        address owner_,\n        string calldata name_,\n        string calldata symbol_,\n        string[] calldata ipAssetTypes_\n    ) external returns (address ipOrg_) {\n        return IP_ORG_CONTROLLER.registerIpOrg(owner_, name_, symbol_, ipAssetTypes_);\n    }\n\n    /// @notice Registers an IP Asset.\n    /// @param ipOrg_ The governing IP Org under which the IP asset is registered.\n    /// @param params_ The registration params, including owner, name, hash.\n    /// @param licenseId_ Optional: The license id to associate with the IP asset, 0 if none.\n    /// @param preHooksData_ Hooks to embed with the registration pre-call.\n    /// @param postHooksData_ Hooks to embed with the registration post-call.\n    /// @return The global IP asset and local IP Org asset id.\n    function registerIPAsset(\n        address ipOrg_,\n        Registration.RegisterIPAssetParams calldata params_,\n        uint256 licenseId_,\n        bytes[] calldata preHooksData_,\n        bytes[] calldata postHooksData_\n    ) public returns (uint256, uint256) {\n        bytes memory encodedParams = abi.encode(Registration.REGISTER_IP_ASSET, abi.encode(params_));\n        bytes memory result = MODULE_REGISTRY.execute(\n            IIPOrg(ipOrg_),\n            msg.sender,\n            REGISTRATION_MODULE,\n            encodedParams,\n            preHooksData_,\n            postHooksData_\n        );\n        // An empty result indicates that an async hook call is pending execution.\n        if (result.length == 0) {\n            return (0, 0);\n        }\n        (uint256 globalId, uint256 localId) = abi.decode(result, (uint256, uint256));\n        if (licenseId_ != 0) {\n            _linkLnftToIpa(ipOrg_, licenseId_, globalId, msg.sender);\n        }\n        return (globalId, localId);\n    }\n\n    /// @notice Transfers an IP asset to another owner.\n    /// @param ipOrg_ The IP Org which the IP asset is associated with.\n    /// @param from_ The address of the current owner of the IP asset.\n    /// @param to_ The address of the new owner of the IP asset.\n    /// @param ipAssetId_ The global id of the IP asset being transferred.\n    function transferIPAsset(\n        address ipOrg_,\n        address from_,\n        address to_,\n        uint256 ipAssetId_,\n        bytes[] calldata preHooksData_,\n        bytes[] calldata postHooksData_\n    ) public {\n        bytes memory encodedParams = abi.encode(Registration.TRANSFER_IP_ASSET, abi.encode(from_, to_, ipAssetId_));\n        MODULE_REGISTRY.execute(\n            IIPOrg(ipOrg_),\n            msg.sender,\n            REGISTRATION_MODULE,\n            encodedParams,\n            preHooksData_,\n            postHooksData_\n        );\n    }\n\n    ////////////////////////////////////////////////////////////////////////////\n    //                            Relationships                               //\n    ////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Adds a new custom relationship type for an IP Org.\n    /// @param params_ Relationship configs including sources, destinations, and relationship type.\n    function addRelationshipType(LibRelationship.AddRelationshipTypeParams calldata params_) external {\n        MODULE_REGISTRY.configure(\n            IIPOrg(params_.ipOrg),\n            msg.sender,\n            RELATIONSHIP_MODULE,\n            abi.encode(LibRelationship.ADD_REL_TYPE_CONFIG, abi.encode(params_))\n        );\n    }\n\n    /// @notice Removes a relationship type for an IP Org.\n    /// @param ipOrg_ The IP Org under which the relationship type is defined.\n    /// @param relType_ The relationship type being removed from the IP Org.\n    function removeRelationshipType(address ipOrg_, string calldata relType_) external {\n        MODULE_REGISTRY.configure(\n            IIPOrg(ipOrg_),\n            msg.sender,\n            RELATIONSHIP_MODULE,\n            abi.encode(LibRelationship.REMOVE_REL_TYPE_CONFIG, abi.encode(relType_))\n        );\n    }\n\n    /// @notice Creates a new relationship for an IP Org.\n    /// @param ipOrg_ The address of the IP Org creating the relationship.\n    /// @param params_ Params for relationship creation, including type, source, and destination.\n    /// @param preHooksData_ Data to be processed by any enrolled pre-hook actions.\n    /// @param postHooksData_ Data to be processed by any enrolled post-hook actions.\n    function createRelationship(\n        address ipOrg_,\n        LibRelationship.CreateRelationshipParams calldata params_,\n        bytes[] calldata preHooksData_,\n        bytes[] calldata postHooksData_\n    ) external returns (uint256 relId) {\n        bytes memory result = MODULE_REGISTRY.execute(\n            IIPOrg(ipOrg_),\n            msg.sender,\n            RELATIONSHIP_MODULE,\n            abi.encode(params_),\n            preHooksData_,\n            postHooksData_\n        );\n        return abi.decode(result, (uint256));\n    }\n\n    ////////////////////////////////////////////////////////////////////////////\n    //                            Licensing                                   //\n    ////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Configures a licensing framework for an IP Org, including licensing terms.\n    /// @param ipOrg_ The address of the IP Org configuring the licensing.\n    /// @param config_ Licensing configuration, including framework and licensor.\n    function configureIpOrgLicensing(address ipOrg_, Licensing.LicensingConfig calldata config_) external {\n        MODULE_REGISTRY.configure(\n            IIPOrg(ipOrg_),\n            msg.sender,\n            LICENSING_MODULE,\n            abi.encode(Licensing.LICENSING_FRAMEWORK_CONFIG, abi.encode(config_))\n        );\n    }\n\n    /// Creates a tradeable License NFT in the License Registry.\n    /// @param ipOrg_ The address of the IP Org creating the license.\n    /// @param params_ Params around licensing creation, including IP asset id and terms.\n    /// @param preHooksData_ Data to be processed by any enrolled pre-hook actions.\n    /// @param postHooksData_ Data to be processed by any enrolled post-hook actions.\n    /// @return The id of the created license.\n    function createLicense(\n        address ipOrg_,\n        Licensing.LicenseCreation calldata params_,\n        bytes[] calldata preHooksData_,\n        bytes[] calldata postHooksData_\n    ) external returns (uint256) {\n        bytes memory params = abi.encode(params_);\n        bytes memory result = MODULE_REGISTRY.execute(\n            IIPOrg(ipOrg_),\n            msg.sender,\n            LICENSING_MODULE,\n            abi.encode(Licensing.CREATE_LICENSE, params),\n            preHooksData_,\n            postHooksData_\n        );\n        return abi.decode(result, (uint256));\n    }\n\n    /// Activates a license that is pending approval\n    /// @param ipOrg_ Address of the IP Org under which the license is contained.\n    /// @param licenseId_ The identifier of the license.\n    function activateLicense(address ipOrg_, uint256 licenseId_) external {\n        MODULE_REGISTRY.execute(\n            IIPOrg(ipOrg_),\n            msg.sender,\n            LICENSING_MODULE,\n            abi.encode(Licensing.ACTIVATE_LICENSE, abi.encode(licenseId_)),\n            new bytes[](0),\n            new bytes[](0)\n        );\n    }\n\n    /// Associates a license with an IPA\n    /// @param ipOrg_ the ipOrg address\n    /// @param licenseId_ the license id\n    /// @param ipaId_ the ipa id\n    function linkLnftToIpa(address ipOrg_, uint256 licenseId_, uint256 ipaId_) public {\n        _linkLnftToIpa(ipOrg_, licenseId_, ipaId_, msg.sender);\n    }\n\n    function _linkLnftToIpa(address ipOrg_, uint256 licenseId_, uint256 ipaId_, address caller_) private {\n        MODULE_REGISTRY.execute(\n            IIPOrg(ipOrg_),\n            caller_,\n            LICENSING_MODULE,\n            abi.encode(Licensing.LINK_LNFT_TO_IPA, abi.encode(licenseId_, ipaId_)),\n            new bytes[](0),\n            new bytes[](0)\n        );\n    }\n}\n"

    },

    "node_modules/@openzeppelin/contracts/utils/Multicall.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Multicall.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Address.sol\";\n\n/**\n * @dev Provides a function to batch together multiple calls in a single external call.\n *\n * _Available since v4.1._\n */\nabstract contract Multicall {\n    /**\n     * @dev Receives and executes a batch of function calls on this contract.\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            results[i] = Address.functionDelegateCall(address(this), data[i]);\n        }\n        return results;\n    }\n}\n"

    },

    "contracts/interfaces/ip-org/IIPOrgController.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/// @notice IP Org Controller Interface\ninterface IIPOrgController {\n    /// @notice Emits when a new IP Org is registered.\n    /// @param owner The address of the IP Org owner.\n    /// @param ipAssetOrg The address of the new IP Org contract.\n    /// @param name Descriptive name for the new IP Org contract.\n    /// @param symbol A describe symbol for the new IP Org contract.\n    /// @param ipAssetTypes String descriptors of the IP asset types available.\n    event IPOrgRegistered(address owner, address ipAssetOrg, string name, string symbol, string[] ipAssetTypes);\n\n    /// @notice Emits when an IP Org is transferred to a new owner.\n    /// @param ipOrg The address of the IP Org.\n    /// @param prevOwner The address of the previous owner of the IP Org.\n    /// @param newOwner The address of the new owner of the IP Org.\n    event IPOrgTransferred(address ipOrg, address prevOwner, address newOwner);\n\n    /// @notice Emits when an ownership transfer is initialized for a new owner.\n    /// @param ipOrg The address of the IP Org.\n    /// @param pendingOwner The pending owner to set for the IP Org.\n    event IPOrgPendingOwnerSet(address ipOrg, address pendingOwner);\n\n    /// @notice Registers a new IP Org.\n    /// @param owner_ The address of the IP Org owner.\n    /// @param name_ Metadata name to attach to the IP Org.\n    /// @param symbol_ Metadata symbol to attach to the IP Org.\n    /// @param ipAssetTypes_ String descriptors of the IP asset types available.\n    function registerIpOrg(\n        address owner_,\n        string calldata name_,\n        string calldata symbol_,\n        string[] calldata ipAssetTypes_\n    ) external returns (address);\n\n    /// @notice Checks whether an IP Org exists.\n    function isIpOrg(address ipOrg_) external view returns (bool);\n}\n"

    },

    "contracts/interfaces/ip-org/IIPOrg.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/// @notice IP Org Interface\ninterface IIPOrg {\n    /// @notice Returns the current owner of the IP asset within the IP Org.\n    /// @return The address of the owner of the IP asset.\n    function ownerOf(uint256 id) external view returns (address);\n\n    /// @notice Transfers ownership of the IP asset wrapper within an IP Org.\n    /// @param from The previous owner of the wrapped IP asset.\n    /// @param to The new owner of the wrapped IP asset.\n    /// @param id The identifier of the IP Org asset.\n    function transferFrom(address from, address to, uint256 id) external;\n\n    /// @notice Burns an IP asset wrapper within the IP Org.\n    /// @dev This function is only callable by the IP Org registration module.\n    /// @param id The local identifier of the IP asset within the IP Org.\n    function burn(uint256 id) external;\n\n    /// @notice Mints an IP Asset wrapper for the IP Org.\n    /// @dev This function is only callable by the IP Org registration module.\n    /// @param owner Address of the current owner of the local IP Org asset.\n    /// @param assetType The IP Org asset type.\n    /// @return id The local identifier of the minted IP Org wrapped asset.\n    function mint(address owner, uint8 assetType) external returns (uint256 id);\n\n    /// @notice Gets the current owner of the IP Org.\n    /// @return The address of the IP Org owner.\n    function owner() external view returns (address);\n\n    /// @notice Returns contract-level metadata for the IP Org.\n    /// @return The contract-wide URI associated with the IP Org.\n    function contractURI() external view returns (string memory);\n\n    /// @notice Returns the IP Org asset type for a given IP Org asset.\n    /// @return The id associated with the IP Org asset type.\n    function ipOrgAssetType(uint256 id_) external view returns (uint8);\n\n    /// @notice Gets the global IP asset id associated with this IP Org asset.\n    /// @param id_ The local id of the IP Org wrapped IP asset.\n    /// @return The global identifier of the IP asset.\n    function ipAssetId(uint256 id_) external returns (uint256);\n}\n"

    },

    "contracts/lib/Errors.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\n// See https://github.com/storyprotocol/protocol-contracts/blob/main/StoryProtocol-AlphaTestingAgreement-17942166.3.pdf\npragma solidity ^0.8.19;\n\n/// @title Errors Library\n/// @notice Library for all Story Protocol contract errors.\nlibrary Errors {\n    ////////////////////////////////////////////////////////////////////////////\n    //                                  Globals                               //\n    ////////////////////////////////////////////////////////////////////////////\n\n    /// @notice The provided array may not be empty.\n    error EmptyArray();\n\n    /// @notice The arrays may not have a mismatch in length.\n    error LengthMismatch();\n\n    /// @notice The provided role does not exist for the given account.\n    error MissingRole(bytes32 role, address account);\n\n    /// @notice The caller is not authorized to perform the call.\n    error Unauthorized();\n\n    /// @notice The provided interface is not supported.\n    error UnsupportedInterface(string name);\n\n    /// @notice The zero address may not be used as input.\n    error ZeroAddress();\n\n    /// @notice The amount specified may not be zero.\n    error ZeroAmount();\n\n    ////////////////////////////////////////////////////////////////////////////\n    //                            BaseModule                                  //\n    ////////////////////////////////////////////////////////////////////////////\n\n    error BaseModule_HooksParamsLengthMismatch(uint8 hookType);\n    error BaseModule_ZeroIpaRegistry();\n    error BaseModule_ZeroLicenseRegistry();\n    error BaseModule_OnlyModuleRegistry();\n\n    /// @notice The caller is not authorized to perform this operation.\n    error BaseModule_Unauthorized();\n\n    ////////////////////////////////////////////////////////////////////////////\n    //                            HookRegistry                                //\n    ////////////////////////////////////////////////////////////////////////////\n\n    /// @notice The hook is already registered.\n    error HookRegistry_RegisteringDuplicatedHook();\n\n    /// @notice This error is thrown when trying to register a hook with the address 0.\n    error HookRegistry_RegisteringZeroAddressHook();\n\n    /// @notice This error is thrown when the caller is not IP Org owner.\n    error HookRegistry_CallerNotIPOrgOwner();\n\n    /// @notice This error is thrown when trying to register more than the maximum allowed number of hooks.\n    error HookRegistry_MaxHooksExceeded();\n\n    /// @notice Hooks configuration array length does not match that of the hooks array.\n    error HookRegistry_HooksConfigLengthMismatch();\n\n    /// @notice This error is thrown when the provided index is out of bounds of the hooks array.\n    error HookRegistry_IndexOutOfBounds(uint256 hooksIndex);\n\n    /// @notice The module may not be the zero address.\n    error HookRegistry_ZeroModuleRegistry();\n\n    /// @notice The provided hook has not been whitelisted.\n    error HookRegistry_RegisteringNonWhitelistedHook(address hookAddress);\n\n    ////////////////////////////////////////////////////////////////////////////\n    //                      BaseRelationshipProcessor                         //\n    ////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Call may only be processed by the relationship module.\n    error BaseRelationshipProcessor_OnlyRelationshipModule();\n\n    ////////////////////////////////////////////////////////////////////////////\n    //                           ModuleRegistry                               //\n    ////////////////////////////////////////////////////////////////////////////\n\n    /// @notice The selected module has yet to been registered.\n    error ModuleRegistry_ModuleNotYetRegistered();\n\n    /// @notice The module depenedency has not yet been registered for the gatway.\n    error ModuleRegistry_DependencyNotYetRegistered();\n\n    /// @notice The module depenedency was already registered for the gateway.\n    error ModuleRegistry_DependencyAlreadyRegistered();\n\n    /// @notice The caller is not the org owner.\n    error ModuleRegistry_CallerNotOrgOwner();\n\n    /// @notice Hook has yet to be registered.\n    error ModuleRegistry_HookNotRegistered(string hookKey);\n\n    /// @notice The selected module was already registered.\n    error ModuleRegistry_ModuleAlreadyRegistered();\n\n    /// @notice The key of the targeted module does not match the provided key.\n    error ModuleRegistry_ModuleKeyMismatch();\n\n    /// @notice The caller is not authorized to call the module dependency.\n    error ModuleRegistry_Unauthorized();\n\n    /// @notice The gateway is not valid for registration.\n    error ModuleRegistry_InvalidGateway();\n\n    ////////////////////////////////////////////////////////////////////////////\n    //                                 CollectModule                          //\n    ////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Collect module caller is unauthorized.\n    error CollectModule_CallerUnauthorized();\n\n    /// @notice Collect NFT has already been initialized.\n    error CollectModule_CollectNotYetInitialized();\n\n    /// @notice Collect action is not authorized for the collect module.\n    error CollectModule_CollectUnauthorized();\n\n    /// @notice Collect module IP asset is already initialized.\n    error CollectModule_IPAssetAlreadyInitialized();\n\n    /// @notice Collect module IP asset does not exist.\n    error CollectModule_IPAssetNonExistent();\n\n    /// @notice Collect module provided IP asset registry does not exist.\n    error CollectModule_IPOrgNonExistent();\n\n    ////////////////////////////////////////////////////////////////////////////\n    //                           CollectPaymentModule                         //\n    ////////////////////////////////////////////////////////////////////////////\n\n    /// @notice The configured collect module payment amount is invalid.\n    error CollectPaymentModule_AmountInvalid();\n\n    /// @notice The ERC-20 transfer failed when processing the payment collect.\n    error CollectPaymentModule_ERC20TransferFailed();\n\n    /// @notice The collect ERC-20 transfer was not properly ABI-encoded.\n    error CollectPaymentModule_ERC20TransferInvalidABIEncoding();\n\n    /// @notice The collect ERC-20 transfer returned a non-successful value.\n    error CollectPaymentModule_ERC20TransferInvalidReturnValue();\n\n    /// @notice Invalid settings were configured for the collect payment module.\n    error CollectPaymentModule_InvalidSettings();\n\n    /// @notice Native tokens are not allowed for the configured payment module.\n    error CollectPaymentModule_NativeTokenNotAllowed();\n\n    /// @notice Native tokens failed to transfer for the payment collect.\n    error CollectPaymentModule_NativeTransferFailed();\n\n    /// @notice Invalid parameters were passed in to the payment collect.\n    error CollectPaymentModule_PaymentParamsInvalid();\n\n    /// @notice Insufficient funds were provided for the payment collect.\n    error CollectPaymentModule_PaymentInsufficient();\n\n    /// @notice The token provided for the payment collect is invalid.\n    error CollectPaymentModule_TokenInvalid();\n\n    ////////////////////////////////////////////////////////////////////////////\n    //                                  CollectNFT                            //\n    ////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Collect NFT has already been initialized.\n    error CollectNFT_AlreadyInitialized();\n\n    /// @notice Caller of the Collect NFT is not authorized.\n    error CollectNFT_CallerUnauthorized();\n\n    /// @notice Collector address is not valid.\n    error CollectNFT_CollectorInvalid();\n\n    /// @notice IP asset bound to the Collect NFT does not exist.\n    error CollectNFT_IPAssetNonExistent();\n\n    ////////////////////////////////////////////////////////////////////////////\n    //                                   ERC721                               //\n    ////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Originating address does not own the NFT.\n    error ERC721_OwnerInvalid();\n\n    /// @notice Receiving address cannot be the zero address.\n    error ERC721_ReceiverInvalid();\n\n    /// @notice Receiving contract does not implement the ERC-721 wallet interface.\n    error ERC721_SafeTransferUnsupported();\n\n    /// @notice Sender is not NFT owner, approved address, or owner operator.\n    error ERC721_SenderUnauthorized();\n\n    /// @notice Token has already been minted.\n    error ERC721_TokenAlreadyMinted();\n\n    /// @notice NFT does not exist.\n    error ERC721_TokenNonExistent();\n\n    ////////////////////////////////////////////////////////////////////////////\n    //                                 IPAccountImpl                          //\n    ////////////////////////////////////////////////////////////////////////////\n\n    /// @notice IP account caller is not the owner.\n    error IPAccountImpl_CallerNotOwner();\n\n    ////////////////////////////////////////////////////////////////////////////\n    //                               IPAccountRegistry                        //\n    ////////////////////////////////////////////////////////////////////////////\n\n    /// @notice IP account implementation does not exist.\n    error IPAccountRegistry_NonExistentIpAccountImpl();\n\n    /// @notice IP account initialization failed.\n    error IPAccountRegistry_InitializationFailed();\n\n    ////////////////////////////////////////////////////////////////////////////\n    //                         UintArrayMask                               //\n    ////////////////////////////////////////////////////////////////////////////\n\n    error UintArrayMask_EmptyArray();\n\n    ////////////////////////////////////////////////////////////////////////////\n    //                               IPOrg                                    //\n    ////////////////////////////////////////////////////////////////////////////\n\n    /// @notice IP identifier is over bounds.\n    error IPOrg_IdOverBounds();\n\n    /// @notice Licensing is not configured.\n    error IPOrg_LicensingNotConfigured();\n\n    /// @notice IP Org wrapper id does not exist.\n    error IPOrg_IdDoesNotExist();\n\n    ////////////////////////////////////////////////////////////////////////////\n    //                             IPOrgController                            //\n    ////////////////////////////////////////////////////////////////////////////\n\n    /// @notice The caller is not the owner of the IP Org Controller.\n    error IPOrgController_InvalidOwner();\n\n    /// @notice IP Org does not exist.\n    error IPOrgController_IPOrgNonExistent();\n\n    /// @notice The caller is not the authorized IP Org owner.\n    error IPOrgController_InvalidIPOrgOwner();\n\n    /// @notice The new owner for an IP Org may not be the zero address.\n    error IPOrgController_InvalidNewIPOrgOwner();\n\n    /// @notice The owner transfer has not yet been initialized.\n    error IPOrgController_OwnerTransferUninitialized();\n\n    ////////////////////////////////////////////////////////////////////////////\n    //                                LibDuration                             //\n    ////////////////////////////////////////////////////////////////////////////\n\n    /// @notice The caller is not the designated renwer.\n    error LibDuration_CallerNotRenewer();\n\n    /// @notice The start time is not valid.\n    error LibDuration_InvalidStartTime();\n\n    /// @notice The proposed license is not renewable.\n    error LibDuration_NotRenewable();\n\n    /// @notice A zero TTL may not be used for configuration.\n    error LibDuration_ZeroTTL();\n\n    ////////////////////////////////////////////////////////////////////////////\n    //                       LicensingFrameworkRepo                           //\n    ////////////////////////////////////////////////////////////////////////////\n    error LicensingFrameworkRepo_FrameworkAlreadyAdded();\n    error LicensingFrameworkRepo_DuplicateParamType();\n    error LicensingFrameworkRepo_TooManyParams();\n\n    ////////////////////////////////////////////////////////////////////////////\n    //                        LicensingModule                                 //\n    ////////////////////////////////////////////////////////////////////////////\n\n    /// @notice The franchise does not exist.\n    error LicensingModule_CallerNotIpOrgOwner();\n    error LicensingModule_InvalidConfigType();\n    error LicensingModule_InvalidTermCommercialStatus();\n    error LicensingModule_IpOrgFrameworkAlreadySet();\n    error LicensingModule_DuplicateTermId();\n    error LicensingModule_CommercialLicenseNotAllowed();\n    error LicensingModule_NonCommercialTermsRequired();\n    error LicensingModule_IpOrgNotConfigured();\n    error LicensingModule_IpOrgAlreadyConfigured();\n    error LicensingModule_ipOrgTermNotFound();\n    error LicensingModule_ShareAlikeDisabled();\n    error LicensingModule_InvalidAction();\n    error LicensingModule_CallerNotLicensor();\n    error LicensingModule_ParentLicenseNotActive();\n    error LicensingModule_DerivativeNotAllowed();\n    error LicensingModule_InvalidIpa();\n    error LicensingModule_CallerNotLicenseOwner();\n    error LicensingModule_CantFindParentLicenseOrRelatedIpa();\n    error LicensingModule_InvalidLicenseeType();\n    error LicensingModule_InvalidLicensorType();\n    error LicensingModule_InvalidLicensorConfig();\n    error LicensingModule_InvalidParamValue();\n    error LicensingModule_InvalidParamsLength();\n    error LicensingModule_DuplicateParam();\n    error LicensingModule_ReciprocalCannotSetParams();\n    error LicensingModule_ParamSetByIpOrg();\n    error LicensingModule_InvalidInputValue();\n    error LicensingModule_IpOrgFrameworkNotSet();\n\n    ////////////////////////////////////////////////////////////////////////////\n    //                            LicenseRegistry                             //\n    ////////////////////////////////////////////////////////////////////////////\n\n    error LicenseRegistry_UnknownLicenseId();\n    error LicenseRegistry_CallerNotLicensingModule();\n    error LicenseRegistry_CallerNotRevoker();\n    error LicenseRegistry_CallerNotLicensingModuleOrLicensee();\n    error LicenseRegistry_CallerNotLicensor();\n    error LicenseRegistry_LicenseNotPendingApproval();\n    error LicenseRegistry_InvalidLicenseStatus();\n    error LicenseRegistry_ParentLicenseNotActive();\n    error LicenseRegistry_IPANotActive();\n    error LicenseRegistry_LicenseNotActive();\n    error LicenseRegistry_LicenseAlreadyLinkedToIpa();\n\n    ////////////////////////////////////////////////////////////////////////////\n    //                            RegistrationModule                          //\n    ////////////////////////////////////////////////////////////////////////////\n\n    /// @notice The caller is not authorized to perform registration.\n    error RegistrationModule_CallerNotAuthorized();\n\n    /// @notice The configured caller is invalid.\n    error RegistrationModule_InvalidCaller();\n\n    /// @notice The IP asset does not exist.\n    error RegistrationModule_IPAssetNonExistent();\n\n    /// @notice The registration module for the IP Org was not yet configured.\n    error RegistrationModule_IPOrgNotConfigured();\n\n    /// @notice The registration configuration action is not valid.\n    error RegistrationModule_InvalidConfigOperation();\n\n    /// @notice The registration execution action is not valid.\n    error RegistrationModule_InvalidExecutionOperation();\n\n    /// @notice IP asset type is not in the list of supported types for\n    /// the IP Org.\n    error RegistrationModule_InvalidIPAssetType();\n\n    /// @notice IPAsset types provided are more than the maximum allowed.\n    error RegistrationModule_TooManyAssetTypes();\n\n    ////////////////////////////////////////////////////////////////////////////\n    //                            RelationshipModule                          //\n    ////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Unable to relate to another franchise.\n    error RelationshipModule_CannotRelateToOtherIPOrg();\n\n    /// @notice The intent has already been registered.\n    error RelationshipModule_IntentAlreadyRegistered();\n\n    /// @notice The selected TTL is not valid.\n    error RelationshipModule_InvalidTTL();\n\n    /// @notice The selected end timestamp is not valid.\n    error RelationshipModule_InvalidEndTimestamp();\n\n    /// @notice Relationship does not exist.\n    error RelationshipModule_NonExistingRelationship();\n\n    /// @notice The relationship source IP type is not supported.\n    error RelationshipModule_UnsupportedRelationshipSrc();\n\n    /// @notice The relationship destination IP type is not supported.\n    error RelationshipModule_UnsupportedRelationshipDst();\n\n    /// @notice Trying an unsupported config action\n    error RelationshipModule_InvalidConfigOperation();\n\n    /// @notice Unauthorized caller\n    error RelationshipModule_CallerNotIpOrgOwner();\n\n    /// @notice Value not on Relatable enum\n    error RelationshipModule_InvalidRelatable();\n\n    /// @notice Getting an invalid relationship type\n    error RelationshipModule_RelTypeNotSet(string relType);\n\n    /// @notice Relating invalid src addresss\n    error RelationshipModule_InvalidSrcAddress();\n\n    /// @notice Relating invalid dst addresss\n    error RelationshipModule_InvalidDstAddress();\n\n    /// @notice Relating unsupported src ipOrg asset type\n    error RelationshipModule_InvalidSrcId();\n\n    /// @notice Relating unsupported dst ipOrg asset type\n    error RelationshipModule_InvalidDstId();\n\n    /// @notice For IPORG_ENTRY - IPORG_ENTRY relationships,\n    /// ipOrg address must be set\n    error RelationshipModule_IpOrgRelatableCannotBeProtocolLevel();\n\n    /// @notice Index is not found for the asset types of that IP Org.\n    error RelationshipModule_UnsupportedIpOrgIndexType();\n\n    ////////////////////////////////////////////////////////////////////////////\n    //                                RoyaltyNFT                              //\n    ////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Mismatch between parity of accounts and their respective allocations.\n    error RoyaltyNFT_AccountsAndAllocationsMismatch(uint256 accountsLength, uint256 allocationsLength);\n\n    /// @notice Invalid summation for royalty NFT allocations.\n    error RoyaltyNFT_InvalidAllocationsSum(uint32 allocationsSum);\n\n    ////////////////////////////////////////////////////////////////////////////\n    //                                  Hook                                  //\n    ////////////////////////////////////////////////////////////////////////////\n\n    /// @notice The hook request was not found.\n    error Hook_RequestedNotFound();\n\n    /// @notice The sync operation is not supported in Async hooks.\n    error Hook_UnsupportedSyncOperation();\n\n    /// @notice The async operation is not supported in Sync hooks.\n    error Hook_UnsupportedAsyncOperation();\n\n    /// @notice The callback function can only called by designated callback caller.\n    error Hook_OnlyCallbackCallerCanCallback(address current, address expected);\n\n    /// @notice Invalid async request ID.\n    error Hook_InvalidAsyncRequestId(bytes32 invalidRequestId);\n\n    /// @notice The address is not the owner of the token.\n    error TokenGatedHook_NotTokenOwner(address tokenAddress, address ownerAddress);\n\n    error Hook_AsyncHookError(bytes32 requestId, string reason);\n\n    /// @notice Invalid Hook configuration.\n    error Hook_InvalidHookConfig(string reason);\n\n    ////////////////////////////////////////////////////////////////////////////\n    //                       LicensorApprovalHook                             //\n    ////////////////////////////////////////////////////////////////////////////\n\n    error LicensorApprovalHook_ApprovalAlreadyRequested();\n    error LicensorApprovalHook_InvalidLicensor();\n    error LicensorApprovalHook_InvalidLicenseId();\n    error LicensorApprovalHook_NoApprovalRequested();\n    error LicensorApprovalHook_InvalidResponseStatus();\n}\n"

    },

    "contracts/lib/modules/LibRelationship.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\n// See https://github.com/storyprotocol/protocol-contracts/blob/main/StoryProtocol-AlphaTestingAgreement-17942166.3.pdf\npragma solidity ^0.8.19;\n\n/// @title Relationship Module Library\nlibrary LibRelationship {\n    /// @notice defines the elements that can be related in a relationship type\n    enum Relatables {\n        /// Unset value\n        Undefined,\n        /// The relationship type can be used to relate IPAs\n        Ipa,\n        /// The relationship type can be used to relate IPOrg token ids\n        IpOrgEntry,\n        /// The relationship type can be used to relate License token ids\n        License,\n        /// The relationship type can be used to relate Addresses\n        Address,\n        /// The relationship type can be used to relate External NFTs (e.g. ERC721)\n        ExternalNft\n    }\n\n    /// @notice defines the elements that can be related in a relationship type\n    struct RelatedElements {\n        /// Source type\n        Relatables src;\n        /// Destination type\n        Relatables dst;\n    }\n\n    /// @notice defines 2 related elements under a certain type\n    struct Relationship {\n        /// Relationship type name id\n        string relType;\n        /// Source address\n        address srcAddress;\n        /// Destination address\n        address dstAddress;\n        /// Source id (or zero if not applicable)\n        uint256 srcId;\n        /// Destination id (or zero if not applicable)\n        uint256 dstId;\n    }\n\n    /// @notice defines the parameters for adding a relationship type\n    struct AddRelationshipTypeParams {\n        /// Relationship type name id\n        string relType;\n        /// IP Org address or zero address for protocol level rel types\n        address ipOrg;\n        /// Source and destination types\n        RelatedElements allowedElements;\n        /// Source ipOrgs types allowed or empty array if not applicable\n        uint8[] allowedSrcs;\n        /// Destination ipOrgs types allowed or empty array if not applicable\n        uint8[] allowedDsts;\n    }\n\n    /// @notice defines the parameters to define a relationship type\n    struct RelationshipType {\n        /// Allowed source address\n        address src;\n        /// Allowd source subtypes (bitmask verion of allowedSrcs)\n        uint256 srcSubtypesMask;\n        /// Allowed destination address\n        address dst;\n        /// Allowed destination subtypes (bitmask verion of allowedDsts)\n        uint256 dstSubtypesMask;\n    }\n\n    /// @notice defines the parameters for creating a relationship\n    struct CreateRelationshipParams {\n        /// Relationship type name id\n        string relType;\n        /// Source address\n        address srcAddress;\n        /// Source id or zero if not applicable\n        uint256 srcId;\n        /// Destination address\n        address dstAddress;\n        /// Destination id or zero if not applicable\n        uint256 dstId;\n    }\n\n    /// Constant for protocol level relationship types\n    address public constant PROTOCOL_LEVEL_RELATIONSHIP = address(0);\n    /// Any address goes\n    address public constant NO_ADDRESS_RESTRICTIONS = 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF;\n\n    /// Action to configure a relationship type in Relationship Module\n    bytes32 public constant ADD_REL_TYPE_CONFIG = keccak256(\"ADD_REL_TYPE\");\n    /// Action to remove a relationship type in Relationship Module\n    bytes32 public constant REMOVE_REL_TYPE_CONFIG = keccak256(\"REMOVE_REL_TYPE\");\n}\n"

    },

    "contracts/lib/modules/Licensing.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\n// See https://github.com/storyprotocol/protocol-contracts/blob/main/StoryProtocol-AlphaTestingAgreement-17942166.3.pdf\npragma solidity ^0.8.19;\n\nimport { BitMask } from \"contracts/lib/BitMask.sol\";\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { ShortStrings, ShortString } from \"@openzeppelin/contracts/utils/ShortStrings.sol\";\n\n/// @title Licensing Module Library\nlibrary Licensing {\n    using ShortStrings for *;\n    /// @notice Enum for the status of a license.\n    enum LicenseStatus {\n        /// No status has been set.\n        Unset,\n        /// The license is active. It can be linked with IPAs.\n        Active,\n        /// The license is pending licensor approval. It can't be linked with IPAs until approved\n        /// by the licensor using the LicensingModule (activateLicense)\n        PendingLicensorApproval,\n        /// The license has been revoked. It can't be linked with IPAs or sublicensed.\n        /// Sub-licenses will be considered non active.\n        Revoked\n    }\n\n    /// @notice Defines the types to encode/decode the parameters of a licensing framework.\n    enum ParameterType {\n        /// Boolean value\n        Bool,\n        /// Number value (18 decimals)\n        Number,\n        /// Address value\n        Address,\n        /// String value\n        String,\n        /// Array of ShortString values\n        ShortStringArray,\n        // uint256 bitmask representing indexes in choices array. ParamDefinition will have the available choices array.\n        MultipleChoice\n    }\n\n    /// @notice Defines the configuration of the licensor for an IP org.\n    enum LicensorConfig {\n        /// Null value.\n        Unset,\n        /// Licensor is the IP org owner, for all licenses.\n        IpOrgOwnerAlways,\n        /// Licensor will be:\n        /// - If parentLicense is provided, the licensee of the parent license.\n        /// - If parentLicense is not provided, the Owner of the linked IPA.\n        /// - If no parentLicense and no linked IPA, the IP org owner.\n        Source\n    }\n\n    /// @notice Data struct representing a license agreement minted according to an IP Org Licensing Framework\n    struct LicenseData {\n        /// License status.\n        LicenseStatus status;\n        /// If true, other licenses can set this one as parent license, false will prevent it.\n        bool derivativesAllowed;\n        /// If true, sublicenses can be created by anyone, and the terms of this license will be\n        /// applied to the sublicenses. If false, sublicenses can only be created by the licensor.\n        bool isReciprocal;\n        /// If true, sublicenses will be minted with LicenseStatus.PendingLicensorApproval.\n        bool derivativeNeedsApproval;\n        /// Address with permission to revoke the license.\n        address revoker;\n        /// address granting the license\n        address licensor;\n        /// address of the ip org that produced the terms\n        address ipOrg;\n        /// The id of the license framework used to mint this license\n        ShortString frameworkId;\n        /// If the licensee is linked to an IPA, this is the IPA id. 0 otherwise\n        uint256 ipaId;\n        /// The id of the parent license, if any. 0 otherwise\n        uint256 parentLicenseId;\n    }\n\n    /// @notice Parameters to mint a license\n    struct LicenseCreation {\n        /// Array of (tag, value) pairs for the parameters, corresponding to the tags in the\n        /// licensing framework.\n        ParamValue[] params;\n        /// Parent license id, if any. 0 otherwise.\n        uint256 parentLicenseId;\n        /// Linked IPA id, if any. 0 otherwise.\n        uint256 ipaId;\n    }\n\n    /// @notice Corresponds to a parameter (licensing term) of a licensing framework.\n    struct ParamDefinition {\n        /// The parameter id, used to identify the parameter in the license agreement text.\n        ShortString tag;\n        /// The type of the parameter, used to encode/decode the value\n        ParameterType paramType;\n        /// Encoded according to paramType, might be empty.\n        bytes defaultValue;\n        /// If MultipleChoice, String[] of the available choices. Empty bytes otherwise.\n        bytes availableChoices;\n    }\n\n    /// @notice Corresponds to a value for parameter (licensing term) of a licensing framework.\n    struct ParamValue {\n        /// The parameter id, used to identify the parameter in the license agreement text.\n        ShortString tag;\n        /// Encoded according to paramType, might be empty.\n        bytes value;\n    }\n\n    /// @notice Parameters to set a licensing framework in LicensingFrameworkRepo\n    struct SetFramework {\n        /// The id of the licensing framework.\n        string id;\n        /// The URL to the license agreement text.\n        string textUrl;\n        /// Array of parameter definitions, corresponding to the parameters in\n        /// the license agreement text.\n        ParamDefinition[] paramDefs;\n    }\n\n    /// @notice Parameters to set a licensing framework in an IP org\n    struct LicensingConfig {\n        /// The id of the licensing framework.\n        string frameworkId;\n        /// Array of (tag, value) pairs for the parameters, corresponding to the tags in the\n        /// licensing framework.\n        ParamValue[] params;\n        /// Enum with the rules to determine the licensor for this IP org's licenses\n        LicensorConfig licensor;\n    }\n\n    /// @notice Maximum number of parameters allowed in a licensing framework.\n    uint256 public constant MAX_PARAM_TAGS = 255;\n\n    /// Input for IpOrg legal terms configuration in LicensingModule (for now, the only option)\n    bytes32 public constant LICENSING_FRAMEWORK_CONFIG = keccak256(\"LICENSING_FRAMEWORK_CONFIG\");\n    /// Create license action in LicensingModule\n    bytes32 public constant CREATE_LICENSE = keccak256(\"CREATE_LICENSE\");\n    /// Activate license action in LicensingModule\n    bytes32 public constant ACTIVATE_LICENSE = keccak256(\"ACTIVATE_LICENSE\");\n    /// Revoke license action in LicensingModule\n    bytes32 public constant LINK_LNFT_TO_IPA = keccak256(\"LINK_LNFT_TO_IPA\");\n\n    /// @notice Returns the string representation of a license status.\n    function statusToString(LicenseStatus status_) internal pure returns (string memory) {\n        if (status_ == LicenseStatus.Unset) {\n            return \"Unset\";\n        } else if (status_ == LicenseStatus.Active) {\n            return \"Active\";\n        } else if (status_ == LicenseStatus.PendingLicensorApproval) {\n            return \"Pending Licensor Approval\";\n        } else if (status_ == LicenseStatus.Revoked) {\n            return \"Revoked\";\n        }\n        return \"Unknown\";\n    }\n\n    /// @notice decodes value from a MultipleChoice parameter into the corresponding ShortString[]\n    /// with the choices\n    /// @param value the encoded value\n    /// @param availableChoices the encoded available choices for the parameter, defined in parameter\n    /// definition\n    function decodeMultipleChoice(\n        bytes memory value,\n        bytes memory availableChoices\n    ) internal pure returns (ShortString[] memory) {\n        uint256 mask = abi.decode(value, (uint256));\n        uint8[] memory indexes = BitMask.getSetIndexes(mask);\n        ShortString[] memory choices = abi.decode(availableChoices, (ShortString[]));\n        ShortString[] memory result = new ShortString[](indexes.length);\n        for (uint256 i = 0; i < indexes.length; i++) {\n            result[i] = choices[indexes[i]];\n        }\n        return result;\n    }\n\n    /// @notice Sets the indexes for the chosen options in a MultipleChoice parameter,\n    /// and encodes it into bytes\n    /// @param choiceIndexes_ the indexes of the chosen options\n    /// @return value the encoded value\n    function encodeMultipleChoice(uint8[] memory choiceIndexes_) internal pure returns (bytes memory value) {\n        uint256 mask = BitMask.convertToMask(choiceIndexes_);\n        return abi.encode(mask);\n    }\n\n    /// @notice Validates the value for a parameter, according to its type, meaning it will\n    /// decode the value and try to revert if it's not valid.\n    /// @dev WARNING: Some validations are not possible to do on chain (like string validation),\n    /// so they should be done off chain. Also, Boolean decoded as a Number will be valid.\n    /// @param paramDef_ the parameter definition\n    /// @param value_ the encoded value\n    function validateParamValue(ParamDefinition memory paramDef_, bytes memory value_) internal pure returns (bool) {\n        // An empty value signals the parameter is untagged, to trigger default values in the\n        // license agreement text, but that's valid\n        if (keccak256(value_) == keccak256(\"\")) {\n            return true;\n        }\n        if (paramDef_.paramType == Licensing.ParameterType.Bool) {\n            abi.decode(value_, (bool));\n            return true;\n        } else if (paramDef_.paramType == Licensing.ParameterType.Number && abi.decode(value_, (uint256)) == 0) {\n            return false;\n        } else if (\n            paramDef_.paramType == Licensing.ParameterType.Address &&\n            // Not supporting address(0) as a valid value\n            abi.decode(value_, (address)) == address(0)\n        ) {\n            return false;\n        } else if (\n            paramDef_.paramType == Licensing.ParameterType.String &&\n            (keccak256(abi.encodePacked(abi.decode(value_, (string)))) == keccak256(abi.encode(\" \")) ||\n                keccak256(abi.encodePacked(abi.decode(value_, (string)))) == keccak256(abi.encode(\"\")))\n        ) {\n            return false;\n        } else if (\n            paramDef_.paramType == Licensing.ParameterType.ShortStringArray &&\n            abi.decode(value_, (ShortString[])).length == 0\n        ) {\n            return false;\n        } else if (\n            paramDef_.paramType == Licensing.ParameterType.MultipleChoice &&\n            abi.decode(paramDef_.availableChoices, (ShortString[])).length == 0\n        ) {\n            return false;\n        }\n        return true;\n    }\n\n    /// @notice converts a ShortString[] to a string representation of a JSON array. Used for LicenseRegistry\n    /// metadata rendering.\n    /// @param ss the ShortString[]\n    /// @return the string representation of a JSON array\n    function shortStringArrayToJsonArray(ShortString[] memory ss) internal pure returns (string memory) {\n        string memory result = \"[\";\n        uint256 len = ss.length;\n        for (uint256 i = 0; i < len; i++) {\n            ShortString s = ss[i];\n            result = string(abi.encodePacked(result, \"\\\"\", s.toString(), \"\\\"\")); // solhint-disable-line\n            if (i != len - 1) {\n                result = string(abi.encodePacked(result, \",\"));\n            }\n        }\n        return string(abi.encodePacked(result, \"]\"));\n    }\n\n    /// @notice decodes value from a parameter into a string representation that can be used\n    /// in LicenseRegistry metadata rendering.\n    /// @param paramDef_ the parameter definition\n    /// @param value_ the encoded value\n    /// @return the string representation of the value\n    function getDecodedParamString(\n        Licensing.ParamDefinition memory paramDef_,\n        bytes memory value_\n    ) internal pure returns (string memory) {\n        if (paramDef_.paramType == Licensing.ParameterType.Bool) {\n            return abi.decode(value_, (bool)) ? \"true\" : \"false\";\n        } else if (paramDef_.paramType == Licensing.ParameterType.Number) {\n            return Strings.toString(abi.decode(value_, (uint256)));\n        } else if (paramDef_.paramType == Licensing.ParameterType.String) {\n            return abi.decode(value_, (string));\n        } else if (paramDef_.paramType == Licensing.ParameterType.Address) {\n            address addr = abi.decode(value_, (address));\n            return Strings.toHexString(uint160(addr), 20);\n        } else if (paramDef_.paramType == Licensing.ParameterType.ShortStringArray) {\n            ShortString[] memory choices = abi.decode(value_, (ShortString[]));\n            return shortStringArrayToJsonArray(choices);\n        } else if (paramDef_.paramType == Licensing.ParameterType.MultipleChoice) {\n            ShortString[] memory choices = decodeMultipleChoice(value_, paramDef_.availableChoices);\n            return shortStringArrayToJsonArray(choices);\n        }\n        return \"\";\n    }\n}\n"

    },

    "contracts/modules/ModuleRegistry.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\n// See https://github.com/storyprotocol/protocol-contracts/blob/main/StoryProtocol-AlphaTestingAgreement-17942166.3.pdf\npragma solidity ^0.8.19;\n\nimport { IModuleRegistry } from \"contracts/interfaces/modules/IModuleRegistry.sol\";\nimport { AccessControlled } from \"contracts/access-control/AccessControlled.sol\";\nimport { AccessControl } from \"contracts/lib/AccessControl.sol\";\nimport { IModule } from \"contracts/interfaces/modules/base/IModule.sol\";\nimport { IGateway } from \"contracts/interfaces/modules/IGateway.sol\";\nimport { Errors } from \"contracts/lib/Errors.sol\";\nimport { IIPOrg } from \"contracts/interfaces/ip-org/IIPOrg.sol\";\nimport { Multicall } from \"@openzeppelin/contracts/utils/Multicall.sol\";\nimport { IHook } from \"contracts/interfaces/hooks/base/IHook.sol\";\nimport { ModuleKey, ModuleDependencies, toModuleKey } from \"contracts/lib/modules/Module.sol\";\n\n/// @title ModuleRegistry\n/// @notice The module registry serves as the global repository for all modules\n///         registered under Story Protocol, and acts as the central authorization\n///         mechanism for configuring which frontends may call which modules.\ncontract ModuleRegistry is IModuleRegistry, AccessControlled, Multicall {\n    /// @notice Identifying protocol-wide modules (opposed to those bound to specific IP Orgs).\n    address public constant PROTOCOL_LEVEL = address(0);\n\n    /// @dev Maps protocol hook string keys to their respective hooks.\n    mapping(string => IHook) internal _protocolHooks;\n\n    /// @dev Maps hook contracts to their respective hook key names.\n    mapping(IHook => string) internal _hookKeys;\n\n    /// @notice Maps module keys to their respective modules.\n    mapping(ModuleKey => address) internal _modules;\n\n    /// @notice Tracks whether a gateway can call a specific module function.\n    mapping(ModuleKey => mapping(IGateway => mapping(bytes4 => bool))) internal _isAuthorized;\n\n    constructor(address accessControl_) AccessControlled(accessControl_) {}\n\n    /// @notice Gets the protocol-wide module associated with a module key.\n    /// @param key_ The unique module key used to identify the module.\n    function protocolModule(string calldata key_) public view returns (address) {\n        return _modules[toModuleKey(key_)];\n    }\n\n    /// @notice Gets the protocol-wide module associated with a module key.\n    /// @param key_ The unique module key used to identify the module.\n    function protocolModule(ModuleKey key_) public view returns (address) {\n        return _modules[key_];\n    }\n\n    /// @notice Checks whether a gateway is authorized to call a module function.\n    /// @param key_ The type of the module being checked.\n    /// @param gateway_ The gateway which has the module function as a dependency.\n    /// @param fn_ The module function whose access is being checked for.\n    function isAuthorized(ModuleKey key_, IGateway gateway_, bytes4 fn_) public view returns (bool) {\n        if (_modules[key_] == address(0)) {\n            revert Errors.ModuleRegistry_ModuleNotYetRegistered();\n        }\n        return _isAuthorized[key_][gateway_][fn_];\n    }\n\n    /// @notice Registers a new gateway to the protocol with its declared dependencies.\n    /// @dev This is only callable by entities with the MODULE_REGISTRAR_ROLE role.\n    /// @param gateway_ The gateway being registered into the protocol.\n    function registerProtocolGateway(IGateway gateway_) external onlyRole(AccessControl.MODULE_REGISTRAR_ROLE) {\n        ModuleDependencies memory dependencies = gateway_.updateDependencies();\n        uint256 numModules = dependencies.keys.length;\n        if (numModules != dependencies.fns.length) {\n            revert Errors.ModuleRegistry_InvalidGateway();\n        }\n\n        for (uint256 i = 0; i < numModules; ++i) {\n            ModuleKey moduleKey = dependencies.keys[i];\n            bytes4[] memory fns = dependencies.fns[i];\n\n            if (_modules[moduleKey] == address(0)) {\n                revert Errors.ModuleRegistry_ModuleNotYetRegistered();\n            }\n\n            // Authorize all module function dependencies for the gateway.\n            for (uint256 j = 0; j < fns.length; j++) {\n                if (_isAuthorized[moduleKey][gateway_][fns[j]]) {\n                    revert Errors.ModuleRegistry_DependencyAlreadyRegistered();\n                }\n                _isAuthorized[moduleKey][gateway_][fns[j]] = true;\n                emit ModuleAuthorizationGranted(moduleKey, fns[j], address(gateway_), true);\n            }\n        }\n    }\n\n    /// @notice Removes a gatway as an authorized caller of the protocol.\n    /// @dev This is only callable by entities with the MODULE_REGISTRAR_ROLE role.\n    /// @param gateway_ The gateway being removed from the protocol.\n    function removeProtocolGateway(IGateway gateway_) external onlyRole(AccessControl.MODULE_REGISTRAR_ROLE) {\n        ModuleDependencies memory dependencies = gateway_.getDependencies();\n        uint256 numModules = dependencies.keys.length;\n        if (numModules != dependencies.fns.length) {\n            revert Errors.ModuleRegistry_InvalidGateway();\n        }\n\n        for (uint256 i = 0; i < numModules; ++i) {\n            ModuleKey moduleKey = dependencies.keys[i];\n            bytes4[] memory fns = dependencies.fns[i];\n\n            // Revoke authorizations made previously.\n            // TODO: Change logic to track dependencies through the registry itself.\n            for (uint256 j = 0; j < fns.length; j++) {\n                if (!_isAuthorized[moduleKey][gateway_][fns[j]]) {\n                    revert Errors.ModuleRegistry_DependencyNotYetRegistered();\n                }\n                _isAuthorized[moduleKey][gateway_][fns[j]] = false;\n                emit ModuleAuthorizationGranted(moduleKey, fns[j], address(gateway_), false);\n            }\n        }\n    }\n\n    /// @notice Adds a new module to the protocol.\n    /// @dev This is only callable by entities with the MODULE_REGISTRAR_ROLE role.\n    /// @param key_ The identifier for the type of module being enrolled.\n    /// @param module_ The module that will be registered into the protocol.\n    function registerProtocolModule(\n        ModuleKey key_,\n        IModule module_\n    ) external onlyRole(AccessControl.MODULE_REGISTRAR_ROLE) {\n        if (address(module_) == address(0)) {\n            revert Errors.ZeroAddress();\n        }\n\n        if (_modules[key_] != address(0)) {\n            revert Errors.ModuleRegistry_ModuleAlreadyRegistered();\n        }\n\n        if (module_.moduleKey() != key_) {\n            revert Errors.ModuleRegistry_ModuleKeyMismatch();\n        }\n\n        _modules[key_] = address(module_);\n\n        emit ModuleAdded(PROTOCOL_LEVEL, string(abi.encodePacked(key_)), address(module_));\n    }\n\n    /// @notice Registers a new protocol hook.\n    /// @param hookKey The unique identifier for the hook.\n    /// @param hookAddress The address of the hook contract.\n    /// @dev This function can only be called by an account with the MODULE_REGISTRAR_ROLE.\n    function registerProtocolHook(\n        string calldata hookKey,\n        IHook hookAddress\n    ) external onlyRole(AccessControl.MODULE_REGISTRAR_ROLE) {\n        if (address(hookAddress) == address(0)) {\n            revert Errors.ZeroAddress();\n        }\n        _protocolHooks[hookKey] = hookAddress;\n        _hookKeys[hookAddress] = hookKey;\n        emit HookAdded(PROTOCOL_LEVEL, hookKey, address(hookAddress));\n    }\n\n    /// @notice Removes a protocol hook.\n    /// @param hookKey The unique identifier for the hook.\n    /// @dev This function can only be called by an account with the MODULE_REGISTRAR_ROLE.\n    /// If the hook is not registered, it reverts with an error.\n    function removeProtocolHook(string calldata hookKey) external onlyRole(AccessControl.MODULE_REGISTRAR_ROLE) {\n        if (address(_protocolHooks[hookKey]) == address(0)) {\n            revert Errors.ModuleRegistry_HookNotRegistered(hookKey);\n        }\n        IHook hookAddress = _protocolHooks[hookKey];\n        delete _protocolHooks[hookKey];\n        delete _hookKeys[hookAddress];\n        emit HookRemoved(PROTOCOL_LEVEL, hookKey, address(hookAddress));\n    }\n\n    /// Removes the current module configured for a module key.\n    /// This is only callable by MODULE_REGISTRAR_ROLE holders.\n    /// @param key_ The identifier for the type of module being removed.\n    function removeProtocolModule(ModuleKey key_) external onlyRole(AccessControl.MODULE_REGISTRAR_ROLE) {\n        if (_modules[key_] == address(0)) {\n            revert Errors.ModuleRegistry_ModuleNotYetRegistered();\n        }\n\n        address removedModule = _modules[key_];\n        delete _modules[key_];\n\n        emit ModuleRemoved(key_, removedModule);\n    }\n\n    /// @notice Returns the protocol hook associated with a given hook key.\n    /// @param hookKey The unique identifier for the hook.\n    /// @return The protocol hook associated with the given hook key.\n    function hookForKey(string calldata hookKey) external view returns (IHook) {\n        return _protocolHooks[hookKey];\n    }\n\n    /// @notice Checks if a hook is registered in the protocol.\n    /// @param hook_ The hook to check.\n    /// @return True if the hook is registered, false otherwise.\n    function isRegisteredHook(IHook hook_) external view returns (bool) {\n        return address(_protocolHooks[_hookKeys[hook_]]) == address(hook_);\n    }\n\n    /// Execution entrypoint, callable by any address on its own behalf.\n    /// @param ipOrg_ address of the IPOrg, or address(0) for protocol-level stuff\n    /// @param moduleKey_ short module descriptor\n    /// @param moduleParams_ encoded params for module action\n    /// @param preHookParams_ encoded params for pre action hooks\n    /// @param postHookParams_ encoded params for post action hooks\n    /// @return encoded result of the module execution\n    function execute(\n        IIPOrg ipOrg_,\n        string calldata moduleKey_,\n        bytes memory moduleParams_,\n        bytes[] memory preHookParams_,\n        bytes[] memory postHookParams_\n    ) external returns (bytes memory) {\n        return _execute(ipOrg_, msg.sender, moduleKey_, moduleParams_, preHookParams_, postHookParams_);\n    }\n\n    /// Execution entrypoint, callable by any MODULE_EXECUTOR_ROLE holder on behalf of any address.\n    /// @param ipOrg_ address of the IPOrg, or address(0) for protocol-level stuff\n    /// @param caller_ address requesting the execution\n    /// @param moduleKey_ short module descriptor\n    /// @param moduleParams_ encoded params for module action\n    /// @param preHookParams_ encoded params for pre action hooks\n    /// @param postHookParams_ encoded params for post action hooks\n    /// @return encoded result of the module execution\n    function execute(\n        IIPOrg ipOrg_,\n        address caller_,\n        string calldata moduleKey_,\n        bytes calldata moduleParams_,\n        bytes[] calldata preHookParams_,\n        bytes[] calldata postHookParams_\n    ) external onlyRole(AccessControl.MODULE_EXECUTOR_ROLE) returns (bytes memory) {\n        return _execute(ipOrg_, caller_, moduleKey_, moduleParams_, preHookParams_, postHookParams_);\n    }\n\n    /// Configuration entrypoint, callable by any address on its own behalf.\n    /// @param ipOrg_ address of the IPOrg, or address(0) for protocol-level stuff\n    /// @param moduleKey_ short module descriptor\n    /// @param params_ encoded params for module configuration\n    function configure(IIPOrg ipOrg_, string calldata moduleKey_, bytes calldata params_) external {\n        _configure(ipOrg_, msg.sender, moduleKey_, params_);\n    }\n\n    /// Configuration entrypoint, callable by any MODULE_EXECUTOR_ROLE holder on behalf of any address.\n    /// @param ipOrg_ address of the IPOrg, or address(0) for protocol-level stuff\n    /// @param caller_ address requesting the execution\n    /// @param moduleKey_ short module descriptor\n    /// @param params_ encoded params for module configuration\n    function configure(\n        IIPOrg ipOrg_,\n        address caller_,\n        string calldata moduleKey_,\n        bytes calldata params_\n    ) external onlyRole(AccessControl.MODULE_EXECUTOR_ROLE) returns (bytes memory) {\n        return _configure(ipOrg_, caller_, moduleKey_, params_);\n    }\n\n    /// @dev Executes an action for a specific module.\n    /// @param ipOrg_ The IP Org under which the execution is performed.\n    /// @param caller_ The address of the original calling entity.\n    /// @param moduleKey_ The identifier of the module being executed.\n    /// @param moduleParams_ Encoded data to be passed to the module.\n    /// @param preHookParams_ Set of data to be used for any registered pre-hooks.\n    /// @param postHookParams_ Set of data to be used for any registered post-hooks.\n    function _execute(\n        IIPOrg ipOrg_,\n        address caller_,\n        string calldata moduleKey_,\n        bytes memory moduleParams_,\n        bytes[] memory preHookParams_,\n        bytes[] memory postHookParams_\n    ) private returns (bytes memory result) {\n        IModule module = IModule(_modules[toModuleKey(moduleKey_)]);\n        if (address(module) == address(0)) {\n            revert Errors.ModuleRegistry_ModuleNotYetRegistered();\n        }\n        result = module.execute(ipOrg_, caller_, moduleParams_, preHookParams_, postHookParams_);\n        emit ModuleExecuted(address(ipOrg_), moduleKey_, caller_, moduleParams_, preHookParams_, postHookParams_);\n        return result;\n    }\n\n    /// @dev Configures a specific module for an IP Org.\n    /// @param ipOrg_ The IP Org making the relevant configurations.\n    /// @param caller_ The address of the calling entity performing the configuration.\n    /// @param moduleKey_ The identifier for the module being configured.\n    /// @param params_ Module-specific data used for the configuration.\n    function _configure(\n        IIPOrg ipOrg_,\n        address caller_,\n        string calldata moduleKey_,\n        bytes calldata params_\n    ) private returns (bytes memory result) {\n        IModule module = IModule(_modules[toModuleKey(moduleKey_)]);\n        if (address(module) == address(0)) {\n            revert Errors.ModuleRegistry_ModuleNotYetRegistered();\n        }\n        result = module.configure(ipOrg_, caller_, params_);\n        emit ModuleConfigured(address(ipOrg_), moduleKey_, caller_, params_);\n        return result;\n    }\n}\n"

    },

    "contracts/lib/modules/Registration.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\n// See https://github.com/storyprotocol/protocol-contracts/blob/main/StoryProtocol-AlphaTestingAgreement-17942166.3.pdf\npragma solidity ^0.8.19;\n\n/// @title Relationship Module Library\nlibrary Registration {\n    /// @notice IPOrg configuration settings.\n    struct IPOrgConfig {\n        string baseURI;\n        string contractURI;\n        string[] assetTypes;\n    }\n\n    /// @notice Struct used for IP asset registration.\n    struct RegisterIPAssetParams {\n        address owner;\n        uint8 ipOrgAssetType;\n        string name;\n        bytes32 hash;\n        string mediaUrl;\n    }\n\n    // TODO(leeren): Change in favor of granular function-selector based auth.\n\n    // Constants used for determining module configuration logic.\n    bytes32 public constant SET_IP_ORG_METADATA = keccak256(\"SET_IP_ORG_METADATA\");\n    bytes32 public constant SET_IP_ORG_ASSET_TYPES = keccak256(\"SET_IP_ORG_ASSET_TYPES\");\n\n    // Constants used for determining module execution logic.\n    bytes32 public constant REGISTER_IP_ASSET = keccak256(\"REGISTER_IP_ASSET\");\n    bytes32 public constant TRANSFER_IP_ASSET = keccak256(\"TRANSFER_IP_ASSET\");\n}\n"

    },

    "contracts/lib/modules/Module.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\n// See https://github.com/storyprotocol/protocol-contracts/blob/main/StoryProtocol-AlphaTestingAgreement-17942166.3.pdf\npragma solidity ^0.8.19;\n\n// This file contains module structures and constants used throughout Story Protocol.\n\n// A module key is identified by its keccak-256 encoded string identifier.\ntype ModuleKey is bytes32;\n\nusing { moduleKeyEquals as == } for ModuleKey global;\nusing { moduleKeyNotEquals as != } for ModuleKey global;\n\n// A gateway's module dependencies are composed of a list of module keys\n// and a list of function selectors dependend on for each of these modules.\nstruct ModuleDependencies {\n    ModuleKey[] keys;\n    bytes4[][] fns;\n}\n\n// Helper function for comparing equality between two keys.\nfunction moduleKeyEquals(ModuleKey k1, ModuleKey k2) pure returns (bool) {\n    return ModuleKey.unwrap(k1) == ModuleKey.unwrap(k2);\n}\n\n// Helper function for comparing inequality between two keys.\nfunction moduleKeyNotEquals(ModuleKey k1, ModuleKey k2) pure returns (bool) {\n    return ModuleKey.unwrap(k1) != ModuleKey.unwrap(k2);\n}\n\n// Transforms a string to its designated module key.\nfunction toModuleKey(string calldata moduleKey_) pure returns (ModuleKey) {\n    return ModuleKey.wrap(keccak256(abi.encodePacked(moduleKey_)));\n}\n\n// String values for core protocol modules.\nstring constant RELATIONSHIP_MODULE = \"RELATIONSHIP_MODULE\";\nstring constant LICENSING_MODULE = \"LICENSING_MODULE\";\nstring constant REGISTRATION_MODULE = \"REGISTRATION_MODULE\";\n\n// Module key values for core protocol modules.\nModuleKey constant RELATIONSHIP_MODULE_KEY = ModuleKey.wrap(keccak256(abi.encodePacked(RELATIONSHIP_MODULE)));\nModuleKey constant LICENSING_MODULE_KEY = ModuleKey.wrap(keccak256(abi.encodePacked(LICENSING_MODULE)));\nModuleKey constant REGISTRATION_MODULE_KEY = ModuleKey.wrap(keccak256(abi.encodePacked(REGISTRATION_MODULE)));\n"

    },

    "node_modules/@openzeppelin/contracts/utils/Address.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"

    },

    "contracts/lib/BitMask.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/**\n * @notice Based on OpenZeppelin's BitMap, this library is used to encode a set of indexes in a compact way.\n * Instead of using a storage type like OZ, where they use a mapping(uint256 => uint256) for large numbers of values,\n * this library limts it to a 256 values in a single uint256.\n */\nlibrary BitMask {\n    /// Returns whether the bit at `index` is set.\n    function isSet(uint256 mask_, uint8 index_) internal pure returns (bool) {\n        uint256 indexMask = 1 << (index_ & 0xff);\n        return mask_ & indexMask != 0;\n    }\n\n    /// Sets the bit at `index` to the boolean `value`.\n    function setTo(uint256 mask_, uint256 index_, bool value_) internal pure returns (uint256) {\n        if (value_) {\n            return set(mask_, index_);\n        } else {\n            return unset(mask_, index_);\n        }\n    }\n\n    /// Sets the bit at `index`.\n    function set(uint256 mask_, uint256 index_) internal pure returns (uint256) {\n        uint256 indexMask = 1 << (index_ & 0xff);\n        return mask_ |= indexMask;\n    }\n\n    /// Unsets the bit at `index`.\n    function unset(uint256 mask_, uint256 index_) internal pure returns (uint256) {\n        uint256 indexMask = 1 << (index_ & 0xff);\n        return mask_ &= ~indexMask;\n    }\n\n    /// Gets the uint8 from the bitmask as an array\n    function getSetIndexes(uint256 mask_) internal pure returns (uint8[] memory) {\n        // Count the number of set bits to allocate the array size\n        uint256 count;\n        for (uint8 i = 0; i < 255; ++i) {\n            if (isSet(mask_, i)) {\n                ++count;\n            }\n        }\n        uint8[] memory setBitIndexes = new uint8[](count);\n        // Fill the array with indices of set bits\n        uint256 index = 0;\n        for (uint8 i = 0; i < 255; ++i) {\n            if (isSet(mask_, i)) {\n                setBitIndexes[index] = i;\n                ++index;\n            }\n        }\n        return setBitIndexes;\n    }\n\n    /// Converts an array of uint8 to a bit mask\n    function convertToMask(uint8[] memory indexes_) internal pure returns (uint256) {\n        uint256 mask = 0;\n        for (uint256 i = 0; i < indexes_.length; ) {\n            mask |= 1 << (uint256(indexes_[i]) & 0xff);\n            unchecked {\n                i++;\n            }\n        }\n        return mask;\n    }\n}\n"

    },

    "node_modules/@openzeppelin/contracts/utils/Strings.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"

    },

    "node_modules/@openzeppelin/contracts/utils/ShortStrings.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/ShortStrings.sol)\n\npragma solidity ^0.8.8;\n\nimport \"./StorageSlot.sol\";\n\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\n// | length  | 0x                                                              BB |\ntype ShortString is bytes32;\n\n/**\n * @dev This library provides functions to convert short memory strings\n * into a `ShortString` type that can be used as an immutable variable.\n *\n * Strings of arbitrary length can be optimized using this library if\n * they are short enough (up to 31 bytes) by packing them with their\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\n * fallback mechanism can be used for every other case.\n *\n * Usage example:\n *\n * ```solidity\n * contract Named {\n *     using ShortStrings for *;\n *\n *     ShortString private immutable _name;\n *     string private _nameFallback;\n *\n *     constructor(string memory contractName) {\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\n *     }\n *\n *     function name() external view returns (string memory) {\n *         return _name.toStringWithFallback(_nameFallback);\n *     }\n * }\n * ```\n */\nlibrary ShortStrings {\n    // Used as an identifier for strings longer than 31 bytes.\n    bytes32 private constant _FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\n\n    error StringTooLong(string str);\n    error InvalidShortString();\n\n    /**\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\n     *\n     * This will trigger a `StringTooLong` error is the input string is too long.\n     */\n    function toShortString(string memory str) internal pure returns (ShortString) {\n        bytes memory bstr = bytes(str);\n        if (bstr.length > 31) {\n            revert StringTooLong(str);\n        }\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n    }\n\n    /**\n     * @dev Decode a `ShortString` back to a \"normal\" string.\n     */\n    function toString(ShortString sstr) internal pure returns (string memory) {\n        uint256 len = byteLength(sstr);\n        // using `new string(len)` would work locally but is not memory safe.\n        string memory str = new string(32);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(str, len)\n            mstore(add(str, 0x20), sstr)\n        }\n        return str;\n    }\n\n    /**\n     * @dev Return the length of a `ShortString`.\n     */\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n        if (result > 31) {\n            revert InvalidShortString();\n        }\n        return result;\n    }\n\n    /**\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\n     */\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n        if (bytes(value).length < 32) {\n            return toShortString(value);\n        } else {\n            StorageSlot.getStringSlot(store).value = value;\n            return ShortString.wrap(_FALLBACK_SENTINEL);\n        }\n    }\n\n    /**\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     */\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n        if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {\n            return toString(value);\n        } else {\n            return store;\n        }\n    }\n\n    /**\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     *\n     * WARNING: This will return the \"byte length\" of the string. This may not reflect the actual length in terms of\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\n     */\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n        if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {\n            return byteLength(value);\n        } else {\n            return bytes(store).length;\n        }\n    }\n}\n"

    },

    "contracts/interfaces/modules/IModuleRegistry.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport { ModuleKey } from \"contracts/lib/modules/Module.sol\";\nimport { IGateway } from \"contracts/interfaces/modules/IGateway.sol\";\nimport { IModule } from \"contracts/interfaces/modules/base/IModule.sol\";\n\n/// @title IModuleRegistry\n/// @notice Module Registry Interface\ninterface IModuleRegistry {\n    /// @notice Emits when a gateway was successfully registered by the protocol\n    ///         for a specific dependency (module type + module function).\n    /// @param key The identifier of the dependent module type.\n    /// @param fn The function identifier of the dependent module type.\n    /// @param gateway The gateway address granted permission to use the dependency.\n    /// @param grant Whether the gateway was authorized to use the dependency.\n    event ModuleAuthorizationGranted(ModuleKey indexed key, bytes4 fn, address indexed gateway, bool grant);\n\n    /// @notice Emits when a brand new module is enrolled to the protocol.\n    /// @param ipOrg The IP Org to which the module belongs.\n    /// @param moduleKey The string identifier of the module type that was added.\n    /// @param module The address of the module.\n    event ModuleAdded(address indexed ipOrg, string moduleKey, address indexed module);\n\n    /// @notice Emits when the protocol module for a module type is removed.\n    /// @param key The identifier of the module type that was added.\n    /// @param module The address of the removed module\n    event ModuleRemoved(ModuleKey indexed key, address indexed module);\n\n    /// @notice Emits when a module is executed for an IP Org.\n    event ModuleExecuted(\n        address indexed ipOrg,\n        string moduleKey,\n        address indexed caller,\n        bytes selfParams,\n        bytes[] preHookParams,\n        bytes[] postHookParams\n    );\n\n    /// @notice Emits when a module is configured for an IP Org.\n    event ModuleConfigured(address indexed ipOrg, string moduleKey, address indexed caller, bytes params);\n\n    /// @notice Emits when a new hook is added for a specific IP Org.\n    event HookAdded(address indexed ipOrg, string hookKey, address indexed hook);\n\n    /// @notice Emits when a hook is removed for an IP Org.\n    event HookRemoved(address indexed ipOrg, string hookKey, address indexed hook);\n\n    /// @notice Registers a new module of a provided type to Story Protocol.\n    /// @param key_ The bytes32 type of the module being registered.\n    /// @param module_ The actual module being registered.\n    function registerProtocolModule(ModuleKey key_, IModule module_) external;\n\n    /// @notice Fetches the protocol module by its string identifier.\n    /// @param key_ The string module type.\n    /// @return The module associated with the module key.\n    function protocolModule(string calldata key_) external view returns (address);\n\n    /// @notice Fetches the protocol module bound to a module type.\n    /// @param key_ The bytes32 module type.\n    /// @return The module associated with the module key.\n    function protocolModule(ModuleKey key_) external view returns (address);\n\n    /// @notice Checks whether a gateway has permission to call a module function.\n    /// @param key_ The module type.\n    /// @param gateway_ The gateway which has the module as a dependency.\n    /// @param fn_ The module function whose access is being checked for.\n    function isAuthorized(ModuleKey key_, IGateway gateway_, bytes4 fn_) external view returns (bool);\n}\n"

    },

    "contracts/access-control/AccessControlled.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\n// See https://github.com/storyprotocol/protocol-contracts/blob/main/StoryProtocol-AlphaTestingAgreement-17942166.3.pdf\npragma solidity ^0.8.19;\n\n// solhint-disable-next-line max-line-length\nimport { ERC165CheckerUpgradeable } from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165CheckerUpgradeable.sol\";\nimport { IAccessControl } from \"@openzeppelin/contracts/access/IAccessControl.sol\";\n\nimport { AccessControl } from \"contracts/lib/AccessControl.sol\";\nimport { IAccessControlled } from \"contracts/interfaces/access-control/IAccessControlled.sol\";\nimport { Errors } from \"contracts/lib/Errors.sol\";\n\n/// @title Access Controlled Contract\n/// @notice This contract is to be inherited by any protocol components that require granular\n///         roles for execution, as defined by the Access Control Singleton contract. Later on,\n///         this contract will be deprecated in favor of authorization through te module registry.\nabstract contract AccessControlled is IAccessControlled {\n    using ERC165CheckerUpgradeable for address;\n\n    /// @notice Pointer to the global Access Control Singleton for protocol auth.\n    IAccessControl private _accessControl;\n\n    /// @notice Checks if msg.sender has role `role`, reverts otherwise.\n    /// @param role_ The role being checked for, set by the Access Control Singleton.\n    modifier onlyRole(bytes32 role_) {\n        if (!_hasRole(role_, msg.sender)) {\n            revert Errors.MissingRole(role_, msg.sender);\n        }\n        _;\n    }\n\n    /// @notice Instantiates a new Access Controlled contract.\n    /// @param accessControl_ The global Access Control Singleton contract address.\n    constructor(address accessControl_) {\n        if (!accessControl_.supportsInterface(type(IAccessControl).interfaceId))\n            revert Errors.UnsupportedInterface(\"IAccessControl\");\n        _accessControl = IAccessControl(accessControl_);\n        emit AccessControlUpdated(accessControl_);\n    }\n\n    /// @notice Sets the Access Control Singleton used for authorization.\n    /// @param accessControl_ The address of the new Access Control Singleton.\n    function setAccessControl(address accessControl_) public onlyRole(AccessControl.PROTOCOL_ADMIN_ROLE) {\n        if (!accessControl_.supportsInterface(type(IAccessControl).interfaceId))\n            revert Errors.UnsupportedInterface(\"IAccessControl\");\n        _accessControl = IAccessControl(accessControl_);\n        emit AccessControlUpdated(accessControl_);\n    }\n\n    /// @dev Checks if an account `account_` has role `role_` assigned.\n    /// @param role_ The role being checked for as defined by the Access Control Singlton.\n    /// @param account_ The address whose role permissions are being checked for.\n    /// @return return True if the account has the role, False otherwise.\n    function _hasRole(bytes32 role_, address account_) internal view returns (bool) {\n        return _accessControl.hasRole(role_, account_);\n    }\n}\n"

    },

    "contracts/lib/AccessControl.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\n// See https://github.com/storyprotocol/protocol-contracts/blob/main/StoryProtocol-AlphaTestingAgreement-17942166.3.pdf\npragma solidity ^0.8.19;\n\n/// @title Access Control Library\n/// @notice Library for access control helpers and protocol role definitions.\n///         These roles are used by the AccessControlSingleton, accessed by AccessControlled contracts.\nlibrary AccessControl {\n    // Default admin role as per OZ AccessControl system. All other roles stem from this.\n    bytes32 public constant PROTOCOL_ADMIN_ROLE = bytes32(0);\n\n    // Role that can upgrade UUPS contracts or Beacon Proxies\n    bytes32 public constant UPGRADER_ROLE = keccak256(\"UPGRADER_ROLE\");\n\n    // Role for managing protocol-wide and IP Org localized relationships.\n    bytes32 public constant RELATIONSHIP_MANAGER_ROLE = keccak256(\"RELATIONSHIP_MANAGER_ROLE\");\n\n    // Role that can perform admin tasks on the Licensing Module contracts (setNonCommercialLicenseURI)\n    bytes32 public constant LICENSING_MANAGER_ROLE = keccak256(\"LICENSING_MANAGER_ROLE\");\n\n    // Role that can add new modules to the Module Registry\n    bytes32 public constant MODULE_REGISTRAR_ROLE = keccak256(\"MODULE_REGISTRAR_ROLE\");\n\n    // Role that can execute modules\n    bytes32 public constant MODULE_EXECUTOR_ROLE = keccak256(\"MODULE_EXECUTOR_ROLE\");\n\n    // Role that can execute Hooks\n    bytes32 public constant HOOK_CALLER_ROLE = keccak256(\"HOOK_CALLER_ROLE\");\n\n}\n"

    },

    "contracts/interfaces/modules/base/IModule.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport { IIPOrg } from \"contracts/interfaces/ip-org/IIPOrg.sol\";\nimport { ModuleKey } from \"contracts/lib/modules/Module.sol\";\n\n/// @title Story Protocol Module Interface.\n/// @notice This interface must be implemented by all protocol modules in Story Protocol,\n///         providing the base functionality needed for authorization and execution\n///         logic centered around IP assets.\ninterface IModule {\n    /// The execution of the module is pending, and will need to be executed again.\n    event RequestPending(address indexed sender);\n    /// Module execution completed successfully.\n    event RequestCompleted(address indexed sender);\n    /// Module execution failed.\n    event RequestFailed(address indexed sender, string reason);\n\n    /// @notice Gets the protocol-wide key associated with the module.\n    /// @return The bytes32 identifier of the module.\n    function moduleKey() external pure returns (ModuleKey);\n\n    /// @notice Main execution entrypoint.\n    /// @dev This function verifies encoded module params, executes any pre-action hooks,\n    ///      performs the main module logic, and then executes any post-action hooks.\n    ///      Modules must decide themselves how parameters are encoded and decoded.\n    /// @param ipOrg_ Address of the IP Org or the zero address (for protocol-wide modules).\n    /// @param caller_ Address of the caller.\n    /// @param moduleParams_ Encoded params to be decoded for module execution.\n    /// @param preHookParams_ Encoded params used for pre-hook execution logic.\n    /// @param postHookParams_ Encoded params used for post-hook execution logic.\n    /// @return result of the module action\n    function execute(\n        IIPOrg ipOrg_,\n        address caller_,\n        bytes calldata moduleParams_,\n        bytes[] calldata preHookParams_,\n        bytes[] calldata postHookParams_\n    ) external returns (bytes memory result);\n\n    /// @notice Module configuration entrypoint.\n    /// @dev Note that it is up to the module on how the parameters should be\n    ///      encoded, unpacked, and used for configuration.\n    /// @param ipOrg_ Address of the IP Org or the zero address (for protocol-wide modules).\n    /// @param caller_ Address of configuration caller.\n    /// @param params_ ABI-encoded parameters used for module configuration.\n    /// @return result Result of the module configuration expressed as a bytes array.\n    function configure(IIPOrg ipOrg_, address caller_, bytes calldata params_) external returns (bytes memory result);\n}\n"

    },

    "contracts/interfaces/modules/IGateway.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport { ModuleDependencies } from \"contracts/lib/modules/Module.sol\";\n\n/// @title Module Gateway Interface\n/// @notice Interface for a Story Protocol module gateway, which is a contract\n///         that may be granted access by the module registry to call module\n///         functions declared by the gateway's module dependency set.\ninterface IGateway {\n    /// @notice Synchronizes all downstream dependencies via the module registry.\n    /// @dev This function may only be called by the module registry.\n    /// @return dependencies The freshly updated dependencies needed by the gateway.\n    function updateDependencies() external returns (ModuleDependencies memory dependencies);\n\n    /// @notice Fetches all module dependencies required by the gateway contract.\n    /// @return dependencies The dependencies that the gateway requires from the protocol.\n    function getDependencies() external view returns (ModuleDependencies memory dependencies);\n}\n"

    },

    "contracts/interfaces/hooks/base/IHook.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/// @notice Enum for representing various states of an async hook.\nenum HookResult {\n    Pending, // Indicates the hook is ongoing execution.\n    Completed // Indicates the hook has successfully completed.\n}\n\n/// @title Hook Interface.\n/// @notice This interface defines methods for synchronous and asynchronous hooks.\n/// @dev Hooks are used to execute custom logic in response to certain events or conditions.\ninterface IHook {\n    /// @notice Executes a synchronous hook.\n    /// @param hookContext_ The context of an executing hook. It is an encoded version of Hook.ExecutionContext\n    /// @return result The result of the hook execution.\n    /// @return hookData The data returned by the hook.\n    function executeSync(bytes calldata hookContext_) external returns (HookResult result, bytes memory hookData);\n\n    /// @notice Executes an asynchronous hook.\n    /// @param hookContext_ The context of an executing hook. It is an encoded version of Hook.ExecutionContext\n    /// @param callbackHandler_ The address of the callback handler.\n    /// @return result The result of the hook execution.\n    /// @return hookData The data returned by the hook.\n    /// @return requestId The id of the request.\n    function executeAsync(\n        bytes calldata hookContext_,\n        address callbackHandler_\n    ) external returns (HookResult result, bytes memory hookData, bytes32 requestId);\n\n    /// @notice Validates the configuration for the hook.\n    /// @dev This should be overridden by hook implementations to provide custom validation logic.\n    /// @param hookConfig_ The configuration data for the hook.\n    function validateConfig(bytes calldata hookConfig_) external view;\n}\n"

    },

    "node_modules/@openzeppelin/contracts/utils/math/Math.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"

    },

    "node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"

    },

    "node_modules/@openzeppelin/contracts/utils/StorageSlot.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"

    },

    "node_modules/@openzeppelin/contracts-upgradeable/utils/introspection/ERC165CheckerUpgradeable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165CheckerUpgradeable {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface.\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            supportsERC165InterfaceUnchecked(account, type(IERC165Upgradeable).interfaceId) &&\n            !supportsERC165InterfaceUnchecked(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * _Available since v3.4._\n     */\n    function getSupportedInterfaces(\n        address account,\n        bytes4[] memory interfaceIds\n    ) internal view returns (bool[] memory) {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     *\n     * Some precompiled contracts will falsely indicate support for a given interface, so caution\n     * should be exercised when using this function.\n     *\n     * Interface identification is specified in ERC-165.\n     */\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\n        // prepare call\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165Upgradeable.supportsInterface.selector, interfaceId);\n\n        // perform static call\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly {\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0x00)\n        }\n\n        return success && returnSize >= 0x20 && returnValue > 0;\n    }\n}\n"

    },

    "node_modules/@openzeppelin/contracts/access/IAccessControl.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"

    },

    "contracts/interfaces/access-control/IAccessControlled.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/// @title Access Controlled Interface\n/// @notice This interface must be implemented by all protocol components that require\n///         to be authorized via the global Access Control Singleton contract. This\n///         initially includes all modules and hooks contracts, but will later be\n///         sunset in favor of central authorization via the module registry.\ninterface IAccessControlled {\n    /// @notice Emits when the global Access Control Singleton contract is updated.\n    /// @param accessControl Address of the protocol-wide Access Control singleton contract.\n    event AccessControlUpdated(address indexed accessControl);\n\n    /// @notice Sets the Access Control Singleton instance.\n    /// @param accessControl_ address of the new instance of the Access Control Singleton.\n    function setAccessControl(address accessControl_) external;\n}\n"

    },

    "node_modules/@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"

    }

  },

  "settings": {

    "remappings": [

      "@ethereum-waffle/=node_modules/@ethereum-waffle/",

      "@openzeppelin/=node_modules/@openzeppelin/",

      "base64-sol/=node_modules/base64-sol/",

      "ds-test/=lib/forge-std/lib/ds-test/src/",

      "eth-gas-reporter/=node_modules/eth-gas-reporter/",

      "forge-std/=lib/forge-std/src/",

      "hardhat-deploy/=node_modules/hardhat-deploy/",

      "hardhat/=node_modules/hardhat/",

      "solmate/=node_modules/solmate/"

    ],

    "optimizer": {

      "enabled": true,

      "runs": 20000

    },

    "metadata": {

      "useLiteralContent": false,

      "bytecodeHash": "ipfs",

      "appendCBOR": true

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "evmVersion": "paris",

    "libraries": {}

  }

}}