{{

  "language": "Solidity",

  "sources": {

    "contracts/CoinDao.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\ninterface _ISwapPair {\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n}\n\ninterface _IERC20{\n    function name() external view returns(string memory);\n    function symbol() external view returns(string memory);\n    function decimals() external view returns(uint256);\n    function totalSupply() external view returns(uint256);\n\n    function balanceOf(address account) external view returns(uint256);\n    function allowance(address deployer, address spender) external view returns(uint256);\n\n    function approve(address _spender, uint256 _value) external returns(bool);\n    function transfer(address _to, uint256 _value) external returns(bool);\n    function transferFrom(address _from, address _to, uint256 _value) external returns(bool);\n\n    event Approval(address indexed deployer, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\nlibrary SafeMath {\n    // ==================================================\n    // *\n    // ==================================================\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n    // ==================================================\n    // /\n    // ==================================================\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        return c;\n    }\n\n    // ==================================================\n    // %\n    // ==================================================\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    // ==================================================\n    // -\n    // ==================================================\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n        return c;\n    }\n\n    // ==================================================\n    // +\n    // ==================================================\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    // ==================================================\n    // Inspired by OraclizeAPI's implementation - MIT licence\n    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n    // ==================================================\n    function toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n}\n\ncontract CoinDao is _IERC20{\n\n    using SafeMath for uint256;\n\n    /// param ///\n\n    address public onlyOwner;\n    address private teamWallet = address(0xf25F2458f00ac54b91a539EA2d476C6245B51A27);\n    address private airdropWallet = address(0);\n\n    _IERC20 private swapTokenObject;\n    uint256 private swapTokenDecimal;\n\n    address public pricePair;                         // get price\n    mapping (address => bool) public pairOf;          // address => true\n\n    bytes32 public merkleRoot;\n    uint256 public maxSellNumber;\n    uint256 public updateInterval = 10;\n    uint256 public lastUpdateTime;\n    uint256 public lastUpdatePrice;                      // Now token price (Price / 1000000000 = $U)\n\n    bool public freeTransfer = false;\n    mapping (address => uint256) public costOf;          // address => cost\n    \n    uint256 public claimBase = 12500;\n    uint256 public claimPremium = 10;                    // airdrop cost premium\n    mapping (address => uint) public claimedOf;          // address => cost\n\n    enum buyOrSell{buy, sell}\n\n    /// contract ///\n\n    string private _name = \"CoinDao\";\n    string private _symbol = \"CO\";\n\n    uint256 private _decimals = 18;\n    uint256 private _totalSupply = 210000000 * (10 ** _decimals);\n\n    mapping (address => uint256) private _balances;\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    constructor() {\n        onlyOwner = msg.sender;\n\n        uint256 ratioValue = _totalSupply.div(100);\n        _balances[onlyOwner] = ratioValue.mul(10);\n        _balances[teamWallet] = ratioValue.mul(10);\n        _balances[airdropWallet] = ratioValue.mul(80);\n        emit Transfer(airdropWallet, onlyOwner, _balances[onlyOwner]);\n        emit Transfer(airdropWallet, teamWallet, _balances[teamWallet]);\n\n        setMaxSellNumber(ratioValue.mul(5));\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view virtual override returns (uint256) {\n        return _decimals;\n    }\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address _owner) public view virtual override returns (uint256) {\n        return _balances[_owner];\n    }\n\n    function allowance(address _owner, address _spender) public view virtual override returns (uint256) {\n        return _allowances[_owner][_spender];\n    }\n\n    function approve(address _spender, uint256 _value) public virtual override returns(bool){\n        _approve(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function transfer(address _to, uint256 _value) public virtual override returns(bool){\n        return transferFrom(msg.sender, _to, _value);\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public virtual override returns(bool){\n        require(_from != address(0), \"ERC20: transfer from the zero address\");\n        require(_to != address(0), \"ERC20: transfer to the zero address\");\n\n        if(_from != msg.sender && pairOf[_from] == false){\n            require(maxSellNumber == 0 || maxSellNumber >= _value, \"Exceeds the maximum sellable quantity for a single transaction\");\n        }\n\n        // check allowance\n        if(_from != msg.sender){\n            uint256 currentAllowance = _allowances[_from][msg.sender];\n            require(currentAllowance >= _value, \"ERC20: transfer amount exceeds allowance\");\n            _approve(_from, msg.sender, currentAllowance.sub(_value));\n        }\n\n        // sell or transfer\n        if(pairOf[_from] == false && freeTransfer == false){\n            uint256 canSellPrice = costOf[_from];\n            if(canSellPrice > lastUpdatePrice){\n                uint256 lossRatio = canSellPrice.sub(lastUpdatePrice).mul(100).div(canSellPrice);\n                if(lossRatio == 0){\n                    lossRatio = 1;\n                }\n                revert(string.concat(\"Position Losses(-\", lossRatio.toString(), \"%), Can't sell or transfer\"));\n            }\n        }\n\n        _transfer(_from, _to, _value, 0);\n        updateTokenPrice();\n        return true;\n    }\n\n    function _approve(address _owner, address _spender, uint256 _value) private {\n        require(_owner != address(0), \"ERC20: approve from the zero address\");\n        require(_spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[_owner][_spender] = _value;\n        emit Approval(_owner, _spender, _value);\n    }\n\n    function _transfer(address _from, address _to, uint256 _value, uint256 _cost) private {\n        require(_value > 0 && _balances[_from] >= _value);\n\n        // Update Balance/Cost\n        updateBalanceAndCost(_from, _value, _cost, buyOrSell.sell);\n        updateBalanceAndCost(_to, _value, _cost, buyOrSell.buy);\n\n        emit Transfer(_from, _to, _value);\n    }\n\n    /// Func ///\n\n    /**\n     * @notice Update balance/cost, and make transfer\n     * @param _address   Change of address\n     * @param _changeQty Change of qty\n     * @param _cost      Buy/sell costs\n     * @param _action    Change direction (buy or sell)\n     */\n    function updateBalanceAndCost(address _address, uint256 _changeQty, uint256 _cost, buyOrSell _action) private {\n        if(_cost == 0){\n            _cost = lastUpdatePrice;\n        }\n        uint256 changeAmount = _changeQty.mul(_cost);\n\n        uint256 originQty = _balances[_address];\n        uint256 originAmount = originQty.mul(costOf[_address]);\n\n        uint256 finallyQty;\n        uint256 finallyCost;\n        if(_action == buyOrSell.buy){\n            // + (originAmount ＋ changeAmount) ／ finallyQty\n            finallyQty = originQty.add(_changeQty);\n            finallyCost = originAmount.add(changeAmount).div(finallyQty);\n        }else{\n            // - (originAmount - changeAmount) ／ finallyQty\n            finallyQty = originQty.sub(_changeQty);\n            if(originAmount <= changeAmount){\n                finallyCost = 0;\n            }else{\n                finallyCost = originAmount.sub(changeAmount).div(finallyQty);\n            }\n        }\n        \n        costOf[_address] = finallyCost;\n        _balances[_address] = finallyQty;\n    }\n\n    /**\n     * @notice Update Token Price\n     */\n    function updateTokenPrice() private {\n        uint256 _timestamp = block.timestamp;\n        if(_timestamp.sub(lastUpdateTime) < updateInterval || pricePair == address(0)){\n            return;\n        }\n\n        uint256 selfBalance = _balances[pricePair];\n        uint256 otherBalance = swapTokenObject.balanceOf(pricePair);\n\n        // same decimal\n        if (_decimals < swapTokenDecimal){\n            selfBalance = selfBalance.mul(10 ** swapTokenDecimal.sub(_decimals));\n        }else if(_decimals > swapTokenDecimal){\n            otherBalance = otherBalance.mul(10 ** _decimals.sub(swapTokenDecimal));\n        }\n\n        lastUpdateTime = _timestamp;\n        lastUpdatePrice = otherBalance.mul(10 ** 9).div(selfBalance);\n    }\n\n    /// Manager ///\n\n    modifier _manager(){\n        require(onlyOwner == msg.sender, \"Permission denied\");\n        _;\n    }\n\n    function setOwner(address newOwner) _manager public {\n        onlyOwner = newOwner;\n    }\n\n    function setFreeTransfer(bool _bool) _manager public { \n        freeTransfer = _bool;\n    }\n\n    function setMaxSellNumber(uint256 _value) _manager public {\n        maxSellNumber = _value;\n    }\n\n    function setUpdateInterval(uint256 _interval) _manager public { \n        updateInterval = _interval;\n    }\n\n    function setPricePair(address _address) _manager public {\n        if(_address != address(0)){\n            _ISwapPair pair = _ISwapPair(_address);\n            address token0 = pair.token0();\n            address token1 = pair.token1();\n            address selfAddress = address(this);\n            require(token0 == selfAddress || token1 == selfAddress, \"Swap pair error\");\n\n            swapTokenObject = _IERC20(token0 != selfAddress ? token0 : token1);\n            swapTokenDecimal = swapTokenObject.decimals();\n            setPairOf(_address, true);\n        }\n        pricePair = _address;\n    }\n\n    function setPairOf(address _address, bool _bool) _manager public {\n        pairOf[_address] = _bool;\n    }\n\n    function setMerkleRoot(bytes32 _merkleRoot) _manager public {\n        merkleRoot = _merkleRoot;\n    }\n\n    function setClaimBase(uint256 _number) _manager public {\n        claimBase = _number;\n    }\n\n    function setClaimPremium(uint256 _ratio) _manager public {\n        claimPremium = _ratio;\n    }\n\n    /// Airdrop ///\n\n    function getPosition(address _address) public view returns (uint256, uint256){\n        return (costOf[_address], _balances[_address]);\n    }\n\n    function getClaim(address _address) public view returns (uint256, uint256){\n        return (_balances[airdropWallet].div(claimBase), claimedOf[_address]);\n    }\n\n    function claim(bytes32[] calldata proof) public {\n        (uint256 claimValue, uint256 claimedValue) = getClaim(msg.sender);\n        require(claimValue > 0, \"Suspension of claim\");\n        require(claimedValue == 0, \"Already claimed\");\n        claimedOf[msg.sender] = claimValue;\n\n        // check merkle\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n        require(MerkleProof.verify(proof, merkleRoot, leaf), \"Address not in WhiteList\");\n        \n        // check premium\n        uint256 premiumCost = 0;\n        if(lastUpdatePrice > 0 && claimPremium > 0){\n            premiumCost = lastUpdatePrice.div(100).mul(100 + claimPremium);\n        }\n        _transfer(airdropWallet, msg.sender, claimValue, premiumCost);\n    }\n\n    function donate(uint256 _value) public {\n        _transfer(msg.sender, airdropWallet, _value, 0);\n    }\n\n}\n\n"

    },

    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     *\n     * _Available since v4.7._\n     */\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     *\n     * _Available since v4.7._\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be proved to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and the sibling nodes in `proof`,\n     * consuming from one or the other at each step according to the instructions given by\n     * `proofFlags`.\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"

    }

  },

  "settings": {

    "optimizer": {

      "enabled": false,

      "runs": 200

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "libraries": {}

  }

}}