{{

  "language": "Solidity",

  "sources": {

    "src/policies/BoostedLiquidity/BLVaultManagerLusd.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// Import system dependencies\nimport {MINTRv1} from \"src/modules/MINTR/MINTR.v1.sol\";\nimport {ROLESv1, RolesConsumer} from \"src/modules/ROLES/OlympusRoles.sol\";\nimport {TRSRYv1} from \"src/modules/TRSRY/TRSRY.v1.sol\";\nimport {BLREGv1} from \"src/modules/BLREG/BLREG.v1.sol\";\nimport \"src/Kernel.sol\";\n\n// Import external dependencies\nimport {AggregatorV3Interface} from \"interfaces/AggregatorV2V3Interface.sol\";\nimport {IAuraRewardPool, IAuraMiningLib, ISTASHToken} from \"policies/BoostedLiquidity/interfaces/IAura.sol\";\nimport {JoinPoolRequest, ExitPoolRequest, IVault, IBasePool, IBalancerHelper} from \"policies/BoostedLiquidity/interfaces/IBalancer.sol\";\n\n// Import vault dependencies\nimport {RewardsData} from \"policies/BoostedLiquidity/interfaces/IBLVault.sol\";\nimport {IBLVaultManager} from \"policies/BoostedLiquidity/interfaces/IBLVaultManager.sol\";\nimport {BLVaultLusd} from \"policies/BoostedLiquidity/BLVaultLusd.sol\";\n\n// Import types\nimport {OlympusERC20Token} from \"src/external/OlympusERC20.sol\";\n\n// Import libraries\nimport {ClonesWithImmutableArgs} from \"clones/ClonesWithImmutableArgs.sol\";\n\ncontract BLVaultManagerLusd is Policy, IBLVaultManager, RolesConsumer {\n    using ClonesWithImmutableArgs for address;\n\n    // ========= ERRORS ========= //\n\n    error BLManagerLusd_AlreadyActive();\n    error BLManagerLusd_AlreadyInactive();\n    error BLManagerLusd_Inactive();\n    error BLManagerLusd_InvalidVault();\n    error BLManagerLusd_LimitViolation();\n    error BLManagerLusd_InvalidLpAmount();\n    error BLManagerLusd_InvalidLimit();\n    error BLManagerLusd_InvalidFee();\n    error BLManagerLusd_BadPriceFeed();\n    error BLManagerLusd_VaultAlreadyExists();\n    error BLManagerLusd_NoUserVault();\n\n    // ========= EVENTS ========= //\n\n    event VaultDeployed(address vault, address owner, uint64 fee);\n\n    // ========= STATE VARIABLES ========= //\n\n    // Modules\n    MINTRv1 public MINTR;\n    TRSRYv1 public TRSRY;\n    BLREGv1 public BLREG;\n\n    // Tokens\n    address public ohm;\n    address public pairToken; // LUSD for this implementation\n    address public aura;\n    address public bal;\n\n    // Exchange Info\n    string public exchangeName;\n    BalancerData public balancerData;\n\n    // Aura Info\n    AuraData public auraData;\n    IAuraMiningLib public auraMiningLib;\n\n    // Oracle Info\n    OracleFeed public ohmEthPriceFeed;\n    OracleFeed public ethUsdPriceFeed;\n    OracleFeed public lusdUsdPriceFeed;\n\n    // Vault Info\n    BLVaultLusd public implementation;\n    mapping(BLVaultLusd => address) public vaultOwners;\n    mapping(address => BLVaultLusd) public userVaults;\n\n    // Vaults State\n    uint256 public totalLp;\n    uint256 public deployedOhm;\n    uint256 public circulatingOhmBurned;\n\n    // System Configuration\n    uint256 public ohmLimit;\n    uint64 public currentFee;\n    uint48 public minWithdrawalDelay;\n    bool public isLusdBLVaultActive;\n\n    // Constants\n    uint32 public constant MAX_FEE = 10_000; // 100%\n    uint8 private constant _ohmIndex = 1;\n    uint8 private constant _lusdIndex = 0;\n\n    //============================================================================================//\n    //                                      POLICY SETUP                                          //\n    //============================================================================================//\n\n    constructor(\n        Kernel kernel_,\n        TokenData memory tokenData_,\n        BalancerData memory balancerData_,\n        AuraData memory auraData_,\n        address auraMiningLib_,\n        OracleFeed memory ohmEthPriceFeed_,\n        OracleFeed memory ethUsdPriceFeed_,\n        OracleFeed memory lusdUsdPriceFeed_,\n        address implementation_,\n        uint256 ohmLimit_,\n        uint64 fee_,\n        uint48 minWithdrawalDelay_\n    ) Policy(kernel_) {\n        // Set exchange name\n        {\n            exchangeName = \"Balancer\";\n        }\n\n        // Set tokens\n        {\n            ohm = tokenData_.ohm;\n            pairToken = tokenData_.pairToken;\n            aura = tokenData_.aura;\n            bal = tokenData_.bal;\n        }\n\n        // Set exchange info\n        {\n            balancerData = balancerData_;\n        }\n\n        // Set Aura Pool\n        {\n            auraData = auraData_;\n            auraMiningLib = IAuraMiningLib(auraMiningLib_);\n        }\n\n        // Set oracle info\n        {\n            ohmEthPriceFeed = ohmEthPriceFeed_;\n            ethUsdPriceFeed = ethUsdPriceFeed_;\n            lusdUsdPriceFeed = lusdUsdPriceFeed_;\n        }\n\n        // Set vault implementation\n        {\n            implementation = BLVaultLusd(implementation_);\n        }\n\n        // Configure system\n        {\n            ohmLimit = ohmLimit_;\n            currentFee = fee_;\n            minWithdrawalDelay = minWithdrawalDelay_;\n        }\n    }\n\n    /// @inheritdoc Policy\n    function configureDependencies() external override returns (Keycode[] memory dependencies) {\n        dependencies = new Keycode[](4);\n        dependencies[0] = toKeycode(\"MINTR\");\n        dependencies[1] = toKeycode(\"TRSRY\");\n        dependencies[2] = toKeycode(\"BLREG\");\n        dependencies[3] = toKeycode(\"ROLES\");\n\n        MINTR = MINTRv1(getModuleAddress(dependencies[0]));\n        TRSRY = TRSRYv1(getModuleAddress(dependencies[1]));\n        BLREG = BLREGv1(getModuleAddress(dependencies[2]));\n        ROLES = ROLESv1(getModuleAddress(dependencies[3]));\n    }\n\n    /// @inheritdoc Policy\n    function requestPermissions()\n        external\n        view\n        override\n        returns (Permissions[] memory permissions)\n    {\n        Keycode mintrKeycode = MINTR.KEYCODE();\n        Keycode blregKeycode = BLREG.KEYCODE();\n\n        permissions = new Permissions[](5);\n        permissions[0] = Permissions(mintrKeycode, MINTR.mintOhm.selector);\n        permissions[1] = Permissions(mintrKeycode, MINTR.burnOhm.selector);\n        permissions[2] = Permissions(mintrKeycode, MINTR.increaseMintApproval.selector);\n        permissions[3] = Permissions(blregKeycode, BLREG.addVault.selector);\n        permissions[4] = Permissions(blregKeycode, BLREG.removeVault.selector);\n    }\n\n    //============================================================================================//\n    //                                           MODIFIERS                                        //\n    //============================================================================================//\n\n    modifier onlyWhileActive() {\n        if (!isLusdBLVaultActive) revert BLManagerLusd_Inactive();\n        _;\n    }\n\n    modifier onlyVault() {\n        if (vaultOwners[BLVaultLusd(msg.sender)] == address(0)) revert BLManagerLusd_InvalidVault();\n        _;\n    }\n\n    //============================================================================================//\n    //                                        VAULT DEPLOYMENT                                    //\n    //============================================================================================//\n\n    /// @inheritdoc IBLVaultManager\n    function deployVault() external override onlyWhileActive returns (address vault) {\n        if (address(userVaults[msg.sender]) != address(0))\n            revert BLManagerLusd_VaultAlreadyExists();\n\n        // Create clone of vault implementation\n        bytes memory data = abi.encodePacked(\n            msg.sender, // Owner\n            this, // Vault Manager\n            address(TRSRY), // Treasury\n            address(MINTR), // Minter\n            ohm, // OHM\n            pairToken, // Pair Token (LUSD)\n            aura, // Aura\n            bal, // Balancer\n            balancerData.vault, // Balancer Vault\n            balancerData.liquidityPool, // Balancer Pool\n            auraData.pid, // Aura PID\n            auraData.auraBooster, // Aura Booster\n            auraData.auraRewardPool, // Aura Reward Pool\n            currentFee\n        );\n        BLVaultLusd clone = BLVaultLusd(address(implementation).clone(data));\n\n        // Initialize clone of vault implementation (for reentrancy state)\n        clone.initializeClone();\n\n        // Set vault owner\n        vaultOwners[clone] = msg.sender;\n        userVaults[msg.sender] = clone;\n\n        // Emit event\n        emit VaultDeployed(address(clone), msg.sender, currentFee);\n\n        // Return vault address\n        return address(clone);\n    }\n\n    //============================================================================================//\n    //                                         OHM MANAGEMENT                                     //\n    //============================================================================================//\n\n    /// @inheritdoc IBLVaultManager\n    function mintOhmToVault(uint256 amount_) external override onlyWhileActive onlyVault {\n        // Check that minting will not exceed limit\n        if (deployedOhm + amount_ > ohmLimit + circulatingOhmBurned)\n            revert BLManagerLusd_LimitViolation();\n\n        deployedOhm += amount_;\n\n        // Mint OHM\n        MINTR.increaseMintApproval(address(this), amount_);\n        MINTR.mintOhm(msg.sender, amount_);\n    }\n\n    /// @inheritdoc IBLVaultManager\n    function burnOhmFromVault(uint256 amount_) external override onlyWhileActive onlyVault {\n        // Account for how much OHM has been deployed by the Vault system or burned from circulating supply.\n        // If we are burning more OHM than has been deployed by the system we are removing previously\n        // circulating OHM which should be tracked separately.\n        if (amount_ > deployedOhm) {\n            circulatingOhmBurned += amount_ - deployedOhm;\n            deployedOhm = 0;\n        } else {\n            deployedOhm -= amount_;\n        }\n\n        // Burn OHM\n        MINTR.burnOhm(msg.sender, amount_);\n    }\n\n    //============================================================================================//\n    //                                     VAULT STATE MANAGEMENT                                 //\n    //============================================================================================//\n\n    /// @inheritdoc IBLVaultManager\n    function increaseTotalLp(uint256 amount_) external override onlyWhileActive onlyVault {\n        totalLp += amount_;\n    }\n\n    /// @inheritdoc IBLVaultManager\n    function decreaseTotalLp(uint256 amount_) external override onlyWhileActive onlyVault {\n        if (amount_ > totalLp) amount_ = totalLp;\n        totalLp -= amount_;\n    }\n\n    //============================================================================================//\n    //                                         VIEW FUNCTIONS                                     //\n    //============================================================================================//\n\n    /// @inheritdoc IBLVaultManager\n    function canWithdraw(address user_) external view override returns (bool) {\n        if (address(userVaults[user_]) == address(0)) return false;\n        return userVaults[user_].canWithdraw();\n    }\n\n    /// @inheritdoc IBLVaultManager\n    function getLpBalance(address user_) external view override returns (uint256) {\n        if (address(userVaults[user_]) == address(0)) return 0;\n        return userVaults[user_].getLpBalance();\n    }\n\n    /// @inheritdoc IBLVaultManager\n    function getUserPairShare(address user_) external view override returns (uint256) {\n        if (address(userVaults[user_]) == address(0)) return 0;\n        return userVaults[user_].getUserPairShare();\n    }\n\n    /// @inheritdoc IBLVaultManager\n    function getOutstandingRewards(\n        address user_\n    ) external view override returns (RewardsData[] memory) {\n        // Get user's vault address\n        BLVaultLusd vault = userVaults[user_];\n        if (address(vault) == address(0)) return new RewardsData[](0);\n\n        RewardsData[] memory rewards = vault.getOutstandingRewards();\n        return rewards;\n    }\n\n    /// @inheritdoc IBLVaultManager\n    function getMaxDeposit() external view override returns (uint256) {\n        uint256 maxOhmAmount = ohmLimit + circulatingOhmBurned - deployedOhm;\n\n        // Convert max OHM mintable amount to pair token amount\n        uint256 ohmTknPrice = getOhmTknPrice();\n        uint256 maxTknAmount = (maxOhmAmount * 1e18) / ohmTknPrice;\n\n        return maxTknAmount;\n    }\n\n    /// @inheritdoc IBLVaultManager\n    /// @dev    This is an external function but should only be used in a callstatic from an external\n    ///         source like the frontend.\n    function getExpectedLpAmount(uint256 amount_) external override returns (uint256 bptAmount) {\n        IBasePool pool = IBasePool(balancerData.liquidityPool);\n        IBalancerHelper balancerHelper = IBalancerHelper(balancerData.balancerHelper);\n\n        // Calculate OHM amount to mint\n        uint256 ohmTknOraclePrice = getOhmTknPrice();\n        uint256 ohmTknPoolPrice = getOhmTknPoolPrice();\n\n        // If the expected oracle price mint amount is less than the expected pool price mint amount, use the oracle price\n        // otherwise use the pool price\n        uint256 ohmTknPrice = ohmTknOraclePrice < ohmTknPoolPrice\n            ? ohmTknOraclePrice\n            : ohmTknPoolPrice;\n        uint256 ohmMintAmount = (amount_ * ohmTknPrice) / 1e18;\n\n        // Build join pool request\n        address[] memory assets = new address[](2);\n        assets[_ohmIndex] = ohm;\n        assets[_lusdIndex] = pairToken;\n\n        uint256[] memory maxAmountsIn = new uint256[](2);\n        maxAmountsIn[_ohmIndex] = ohmMintAmount;\n        maxAmountsIn[_lusdIndex] = amount_;\n\n        JoinPoolRequest memory joinPoolRequest = JoinPoolRequest({\n            assets: assets,\n            maxAmountsIn: maxAmountsIn,\n            userData: abi.encode(1, maxAmountsIn, 0),\n            fromInternalBalance: false\n        });\n\n        // Join pool query\n        (bptAmount, ) = balancerHelper.queryJoin(\n            pool.getPoolId(),\n            address(this),\n            address(this),\n            joinPoolRequest\n        );\n    }\n\n    /// @inheritdoc IBLVaultManager\n    /// @dev    This is an external function but should only be used in a callstatic from an external\n    ///         source like the frontend.\n    function getExpectedTokensOutProtocol(\n        uint256 lpAmount_\n    ) external override returns (uint256[] memory expectedTokenAmounts) {\n        IBasePool pool = IBasePool(balancerData.liquidityPool);\n        IBalancerHelper balancerHelper = IBalancerHelper(balancerData.balancerHelper);\n\n        // Build exit pool request\n        address[] memory assets = new address[](2);\n        assets[_ohmIndex] = ohm;\n        assets[_lusdIndex] = pairToken;\n\n        uint256[] memory minAmountsOut = new uint256[](2);\n        minAmountsOut[_ohmIndex] = 0;\n        minAmountsOut[_lusdIndex] = 0;\n\n        ExitPoolRequest memory exitPoolRequest = ExitPoolRequest({\n            assets: assets,\n            minAmountsOut: minAmountsOut,\n            userData: abi.encode(1, lpAmount_),\n            toInternalBalance: false\n        });\n\n        (, expectedTokenAmounts) = balancerHelper.queryExit(\n            pool.getPoolId(),\n            address(this),\n            address(this),\n            exitPoolRequest\n        );\n    }\n\n    /// @inheritdoc IBLVaultManager\n    /// @dev    This is an external function but should only be used in a callstatic from an external\n    ///         source like the frontend.\n    function getExpectedPairTokenOutUser(\n        uint256 lpAmount_\n    ) external override returns (uint256 expectedTknAmount) {\n        IBasePool pool = IBasePool(balancerData.liquidityPool);\n        IBalancerHelper balancerHelper = IBalancerHelper(balancerData.balancerHelper);\n\n        // Build exit pool request\n        address[] memory assets = new address[](2);\n        assets[_ohmIndex] = ohm;\n        assets[_lusdIndex] = pairToken;\n\n        uint256[] memory minAmountsOut = new uint256[](2);\n        minAmountsOut[_ohmIndex] = 0;\n        minAmountsOut[_lusdIndex] = 0;\n\n        ExitPoolRequest memory exitPoolRequest = ExitPoolRequest({\n            assets: assets,\n            minAmountsOut: minAmountsOut,\n            userData: abi.encode(1, lpAmount_),\n            toInternalBalance: false\n        });\n\n        (, uint256[] memory expectedTokenAmounts) = balancerHelper.queryExit(\n            pool.getPoolId(),\n            address(this),\n            address(this),\n            exitPoolRequest\n        );\n\n        // Check against oracle price\n        uint256 tknOhmPrice = getTknOhmPrice();\n        uint256 expectedTknAmountOut = (expectedTokenAmounts[_ohmIndex] * tknOhmPrice) / 1e9;\n\n        expectedTknAmount = expectedTokenAmounts[_lusdIndex] > expectedTknAmountOut\n            ? expectedTknAmountOut\n            : expectedTokenAmounts[_lusdIndex];\n    }\n\n    /// @inheritdoc IBLVaultManager\n    function getRewardTokens() external view override returns (address[] memory) {\n        IAuraRewardPool auraPool = IAuraRewardPool(auraData.auraRewardPool);\n\n        uint256 numExtraRewards = auraPool.extraRewardsLength();\n        address[] memory rewardTokens = new address[](numExtraRewards + 2);\n        rewardTokens[0] = aura;\n        rewardTokens[1] = auraPool.rewardToken();\n        for (uint256 i; i < numExtraRewards; ) {\n            IAuraRewardPool extraRewardPool = IAuraRewardPool(auraPool.extraRewards(i));\n            rewardTokens[i + 2] = ISTASHToken(extraRewardPool.rewardToken()).baseToken();\n\n            unchecked {\n                ++i;\n            }\n        }\n        return rewardTokens;\n    }\n\n    /// @inheritdoc IBLVaultManager\n    function getRewardRate(\n        address rewardToken_\n    ) external view override returns (uint256 rewardRate) {\n        IAuraRewardPool auraPool = IAuraRewardPool(auraData.auraRewardPool);\n\n        if (rewardToken_ == bal) {\n            // If reward token is Bal, return rewardRate from Aura Pool\n            rewardRate = auraPool.rewardRate();\n        } else if (rewardToken_ == aura) {\n            // If reward token is Aura, calculate rewardRate from AuraMiningLib\n            uint256 balRewardRate = auraPool.rewardRate();\n            rewardRate = auraMiningLib.convertCrvToCvx(balRewardRate);\n        } else {\n            uint256 numExtraRewards = auraPool.extraRewardsLength();\n            for (uint256 i; i < numExtraRewards; ) {\n                IAuraRewardPool extraRewardPool = IAuraRewardPool(auraPool.extraRewards(i));\n                if (rewardToken_ == ISTASHToken(extraRewardPool.rewardToken()).baseToken()) {\n                    rewardRate = extraRewardPool.rewardRate();\n                    break;\n                }\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n    }\n\n    /// @inheritdoc IBLVaultManager\n    function getPoolOhmShare() public view override returns (uint256) {\n        // Cast addresses\n        IVault vault = IVault(balancerData.vault);\n        IBasePool pool = IBasePool(balancerData.liquidityPool);\n\n        // Get pool total supply\n        uint256 poolTotalSupply = pool.totalSupply();\n\n        // Get token balances in pool\n        (, uint256[] memory balances_, ) = vault.getPoolTokens(pool.getPoolId());\n\n        // Balancer pool tokens are sorted alphabetically by token address. In the case of this\n        // deployment, OHM is the second token in the pool. Therefore, the OHM balance is at index 1.\n        if (poolTotalSupply == 0) return 0;\n        else return (balances_[_ohmIndex] * totalLp) / poolTotalSupply;\n    }\n\n    /// @inheritdoc IBLVaultManager\n    function getOhmSupplyChangeData()\n        external\n        view\n        override\n        returns (uint256 poolOhmShare, uint256 mintedOhm, uint256 netBurnedOhm)\n    {\n        // Using the pool's OHM share, the amount of OHM deployed by this system, and the amount of\n        // OHM burned by this system we can calculate a whole host of useful data points. The most\n        // important is to calculate what amount of OHM should not be considered part of circulating\n        // supply which would be poolOhmShare. The rest of the data can be used to calculate whether\n        // the system has net emitted or net removed OHM from the circulating supply. Net emitted is\n        // the amount of OHM that was minted to the pool but is no longer in the pool beyond what has\n        // been burned in the past (deployedOhm - poolOhmShare - circulatingOhmBurned). Net removed\n        // is the amount of OHM that is in the pool but wasn’t minted there plus what has been burned\n        // in the past (poolOhmShare + circulatingOhmBurned - deployedOhm). Here we just return\n        // the data components to calculate these data points.\n\n        poolOhmShare = getPoolOhmShare();\n        mintedOhm = deployedOhm;\n        netBurnedOhm = circulatingOhmBurned;\n    }\n\n    /// @inheritdoc IBLVaultManager\n    function getOhmTknPrice() public view override returns (uint256) {\n        // Get ETH per OHM (18 Decimals)\n        uint256 ethPerOhm = _validatePrice(ohmEthPriceFeed.feed, ohmEthPriceFeed.updateThreshold);\n\n        // Get USD per ETH (8 decimals)\n        uint256 usdPerEth = _validatePrice(ethUsdPriceFeed.feed, ethUsdPriceFeed.updateThreshold);\n\n        // Get USD per LUSD (8 decimals)\n        uint256 usdPerLusd = _validatePrice(\n            lusdUsdPriceFeed.feed,\n            lusdUsdPriceFeed.updateThreshold\n        );\n\n        // Calculate OHM per LUSD (9 decimals)\n        return (usdPerLusd * 1e27) / (ethPerOhm * usdPerEth);\n    }\n\n    /// @inheritdoc IBLVaultManager\n    function getTknOhmPrice() public view override returns (uint256) {\n        // Get ETH per OHM (18 Decimals)\n        uint256 ethPerOhm = _validatePrice(ohmEthPriceFeed.feed, ohmEthPriceFeed.updateThreshold);\n\n        // Get USD per ETH (8 decimals)\n        uint256 usdPerEth = _validatePrice(ethUsdPriceFeed.feed, ethUsdPriceFeed.updateThreshold);\n\n        // Get USD per LUSD (8 decimals)\n        uint256 usdPerLusd = _validatePrice(\n            lusdUsdPriceFeed.feed,\n            lusdUsdPriceFeed.updateThreshold\n        );\n\n        // Calculate LUSD per OHM (18 decimals)\n        return (ethPerOhm * usdPerEth) / (usdPerLusd);\n    }\n\n    /// @inheritdoc IBLVaultManager\n    function getOhmTknPoolPrice() public view override returns (uint256) {\n        IBasePool pool = IBasePool(balancerData.liquidityPool);\n        IVault vault = IVault(balancerData.vault);\n\n        // Get token balances\n        (, uint256[] memory balances, ) = vault.getPoolTokens(pool.getPoolId());\n\n        // Get OHM per LUSD (9 decimals)\n        if (balances[_lusdIndex] == 0) return 0;\n        else return (balances[_ohmIndex] * 1e18) / balances[_lusdIndex];\n    }\n\n    //============================================================================================//\n    //                                        ADMIN FUNCTIONS                                     //\n    //============================================================================================//\n\n    /// @inheritdoc IBLVaultManager\n    function emergencyBurnOhm(uint256 amount_) external override onlyRole(\"liquidityvault_admin\") {\n        OlympusERC20Token(ohm).increaseAllowance(address(MINTR), amount_);\n        MINTR.burnOhm(address(this), amount_);\n    }\n\n    /// @inheritdoc IBLVaultManager\n    function setLimit(uint256 newLimit_) external override onlyRole(\"liquidityvault_admin\") {\n        if (newLimit_ + circulatingOhmBurned < deployedOhm) revert BLManagerLusd_InvalidLimit();\n        ohmLimit = newLimit_;\n    }\n\n    /// @inheritdoc IBLVaultManager\n    function setFee(uint64 newFee_) external override onlyRole(\"liquidityvault_admin\") {\n        if (newFee_ > MAX_FEE) revert BLManagerLusd_InvalidFee();\n        currentFee = newFee_;\n    }\n\n    /// @inheritdoc IBLVaultManager\n    function setWithdrawalDelay(\n        uint48 newDelay_\n    ) external override onlyRole(\"liquidityvault_admin\") {\n        minWithdrawalDelay = newDelay_;\n    }\n\n    function changeUpdateThresholds(\n        uint48 ohmEthUpdateThreshold_,\n        uint48 ethUsdUpdateThreshold_,\n        uint48 lusdUsdUpdateThreshold_\n    ) external onlyRole(\"liquidityvault_admin\") {\n        ohmEthPriceFeed.updateThreshold = ohmEthUpdateThreshold_;\n        ethUsdPriceFeed.updateThreshold = ethUsdUpdateThreshold_;\n        lusdUsdPriceFeed.updateThreshold = lusdUsdUpdateThreshold_;\n    }\n\n    /// @inheritdoc IBLVaultManager\n    function activate() external override onlyRole(\"liquidityvault_admin\") {\n        if (isLusdBLVaultActive) revert BLManagerLusd_AlreadyActive();\n\n        isLusdBLVaultActive = true;\n        BLREG.addVault(address(this));\n    }\n\n    /// @inheritdoc IBLVaultManager\n    function deactivate() external override onlyRole(\"emergency_admin\") {\n        if (!isLusdBLVaultActive) revert BLManagerLusd_AlreadyInactive();\n\n        isLusdBLVaultActive = false;\n        BLREG.removeVault(address(this));\n    }\n\n    //============================================================================================//\n    //                                      INTERNAL FUNCTIONS                                    //\n    //============================================================================================//\n\n    function _validatePrice(\n        AggregatorV3Interface priceFeed_,\n        uint48 updateThreshold_\n    ) internal view returns (uint256) {\n        // Get price data\n        (uint80 roundId, int256 priceInt, , uint256 updatedAt, uint80 answeredInRound) = priceFeed_\n            .latestRoundData();\n\n        // Validate chainlink price feed data\n        // 1. Price should be greater than 0\n        // 2. Updated at timestamp should be within the update threshold\n        // 3. Answered in round ID should be the same as round ID\n        if (\n            priceInt <= 0 ||\n            updatedAt < block.timestamp - updateThreshold_ ||\n            answeredInRound != roundId\n        ) revert BLManagerLusd_BadPriceFeed();\n\n        return uint256(priceInt);\n    }\n}\n"

    },

    "src/modules/MINTR/MINTR.v1.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {OlympusERC20Token as OHM} from \"src/external/OlympusERC20.sol\";\nimport \"src/Kernel.sol\";\n\n/// @notice Wrapper for minting and burning functions of OHM token.\nabstract contract MINTRv1 is Module {\n    // =========  EVENTS ========= //\n\n    event IncreaseMintApproval(address indexed policy_, uint256 newAmount_);\n    event DecreaseMintApproval(address indexed policy_, uint256 newAmount_);\n    event Mint(address indexed policy_, address indexed to_, uint256 amount_);\n    event Burn(address indexed policy_, address indexed from_, uint256 amount_);\n\n    // ========= ERRORS ========= //\n\n    error MINTR_NotApproved();\n    error MINTR_ZeroAmount();\n    error MINTR_NotActive();\n\n    // =========  STATE ========= //\n\n    OHM public ohm;\n\n    /// @notice Status of the minter. If false, minting and burning OHM is disabled.\n    bool public active;\n\n    /// @notice Mapping of who is approved for minting.\n    /// @dev    minter -> amount. Infinite approval is max(uint256).\n    mapping(address => uint256) public mintApproval;\n\n    // =========  FUNCTIONS ========= //\n\n    modifier onlyWhileActive() {\n        if (!active) revert MINTR_NotActive();\n        _;\n    }\n\n    /// @notice Mint OHM to an address.\n    function mintOhm(address to_, uint256 amount_) external virtual;\n\n    /// @notice Burn OHM from an address. Must have approval.\n    function burnOhm(address from_, uint256 amount_) external virtual;\n\n    /// @notice Increase approval for specific withdrawer addresses\n    /// @dev    Policies must explicity request how much they want approved before withdrawing.\n    function increaseMintApproval(address policy_, uint256 amount_) external virtual;\n\n    /// @notice Decrease approval for specific withdrawer addresses\n    function decreaseMintApproval(address policy_, uint256 amount_) external virtual;\n\n    /// @notice Emergency shutdown of minting and burning.\n    function deactivate() external virtual;\n\n    /// @notice Re-activate minting and burning after shutdown.\n    function activate() external virtual;\n}\n"

    },

    "src/modules/ROLES/OlympusRoles.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {ROLESv1} from \"src/modules/ROLES/ROLES.v1.sol\";\nimport \"src/Kernel.sol\";\n\n/// @notice Abstract contract to have the `onlyRole` modifier\n/// @dev    Inheriting this automatically makes ROLES module a dependency\nabstract contract RolesConsumer {\n    ROLESv1 public ROLES;\n\n    modifier onlyRole(bytes32 role_) {\n        ROLES.requireRole(role_, msg.sender);\n        _;\n    }\n}\n\n/// @notice Module that holds multisig roles needed by various policies.\ncontract OlympusRoles is ROLESv1 {\n    //============================================================================================//\n    //                                        MODULE SETUP                                        //\n    //============================================================================================//\n\n    constructor(Kernel kernel_) Module(kernel_) {}\n\n    /// @inheritdoc Module\n    function KEYCODE() public pure override returns (Keycode) {\n        return toKeycode(\"ROLES\");\n    }\n\n    /// @inheritdoc Module\n    function VERSION() external pure override returns (uint8 major, uint8 minor) {\n        major = 1;\n        minor = 0;\n    }\n\n    //============================================================================================//\n    //                                       CORE FUNCTIONS                                       //\n    //============================================================================================//\n\n    /// @inheritdoc ROLESv1\n    function saveRole(bytes32 role_, address addr_) external override permissioned {\n        if (hasRole[addr_][role_]) revert ROLES_AddressAlreadyHasRole(addr_, role_);\n\n        ensureValidRole(role_);\n\n        // Grant role to the address\n        hasRole[addr_][role_] = true;\n\n        emit RoleGranted(role_, addr_);\n    }\n\n    /// @inheritdoc ROLESv1\n    function removeRole(bytes32 role_, address addr_) external override permissioned {\n        if (!hasRole[addr_][role_]) revert ROLES_AddressDoesNotHaveRole(addr_, role_);\n\n        hasRole[addr_][role_] = false;\n\n        emit RoleRevoked(role_, addr_);\n    }\n\n    //============================================================================================//\n    //                                       VIEW FUNCTIONS                                       //\n    //============================================================================================//\n\n    /// @inheritdoc ROLESv1\n    function requireRole(bytes32 role_, address caller_) external view override {\n        if (!hasRole[caller_][role_]) revert ROLES_RequireRole(role_);\n    }\n\n    /// @inheritdoc ROLESv1\n    function ensureValidRole(bytes32 role_) public pure override {\n        for (uint256 i = 0; i < 32; ) {\n            bytes1 char = role_[i];\n            if ((char < 0x61 || char > 0x7A) && char != 0x5f && char != 0x00) {\n                revert ROLES_InvalidRole(role_); // a-z only\n            }\n            unchecked {\n                i++;\n            }\n        }\n    }\n}\n"

    },

    "src/modules/TRSRY/TRSRY.v1.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport \"src/Kernel.sol\";\n\n/// @notice Treasury holds all other assets under the control of the protocol.\nabstract contract TRSRYv1 is Module {\n    // =========  EVENTS ========= //\n\n    event IncreaseWithdrawApproval(\n        address indexed withdrawer_,\n        ERC20 indexed token_,\n        uint256 newAmount_\n    );\n    event DecreaseWithdrawApproval(\n        address indexed withdrawer_,\n        ERC20 indexed token_,\n        uint256 newAmount_\n    );\n    event Withdrawal(\n        address indexed policy_,\n        address indexed withdrawer_,\n        ERC20 indexed token_,\n        uint256 amount_\n    );\n    event IncreaseDebtorApproval(address indexed debtor_, ERC20 indexed token_, uint256 newAmount_);\n    event DecreaseDebtorApproval(address indexed debtor_, ERC20 indexed token_, uint256 newAmount_);\n    event DebtIncurred(ERC20 indexed token_, address indexed policy_, uint256 amount_);\n    event DebtRepaid(ERC20 indexed token_, address indexed policy_, uint256 amount_);\n    event DebtSet(ERC20 indexed token_, address indexed policy_, uint256 amount_);\n\n    // =========  ERRORS ========= //\n\n    error TRSRY_NoDebtOutstanding();\n    error TRSRY_NotActive();\n\n    // =========  STATE ========= //\n\n    /// @notice Status of the treasury. If false, no withdrawals or debt can be incurred.\n    bool public active;\n\n    /// @notice Mapping of who is approved for withdrawal.\n    /// @dev    withdrawer -> token -> amount. Infinite approval is max(uint256).\n    mapping(address => mapping(ERC20 => uint256)) public withdrawApproval;\n\n    /// @notice Mapping of who is approved to incur debt.\n    /// @dev    debtor -> token -> amount. Infinite approval is max(uint256).\n    mapping(address => mapping(ERC20 => uint256)) public debtApproval;\n\n    /// @notice Total debt for token across all withdrawals.\n    mapping(ERC20 => uint256) public totalDebt;\n\n    /// @notice Debt for particular token and debtor address\n    mapping(ERC20 => mapping(address => uint256)) public reserveDebt;\n\n    // =========  FUNCTIONS ========= //\n\n    modifier onlyWhileActive() {\n        if (!active) revert TRSRY_NotActive();\n        _;\n    }\n\n    /// @notice Increase approval for specific withdrawer addresses\n    function increaseWithdrawApproval(\n        address withdrawer_,\n        ERC20 token_,\n        uint256 amount_\n    ) external virtual;\n\n    /// @notice Decrease approval for specific withdrawer addresses\n    function decreaseWithdrawApproval(\n        address withdrawer_,\n        ERC20 token_,\n        uint256 amount_\n    ) external virtual;\n\n    /// @notice Allow withdrawal of reserve funds from pre-approved addresses.\n    function withdrawReserves(address to_, ERC20 token_, uint256 amount_) external virtual;\n\n    /// @notice Increase approval for someone to accrue debt in order to withdraw reserves.\n    /// @dev    Debt will generally be taken by contracts to allocate treasury funds in yield sources.\n    function increaseDebtorApproval(\n        address debtor_,\n        ERC20 token_,\n        uint256 amount_\n    ) external virtual;\n\n    /// @notice Decrease approval for someone to withdraw reserves as debt.\n    function decreaseDebtorApproval(\n        address debtor_,\n        ERC20 token_,\n        uint256 amount_\n    ) external virtual;\n\n    /// @notice Pre-approved policies can get a loan to perform operations with treasury assets.\n    function incurDebt(ERC20 token_, uint256 amount_) external virtual;\n\n    /// @notice Repay a debtor debt.\n    /// @dev    Only confirmed to safely handle standard and non-standard ERC20s.\n    /// @dev    Can have unforeseen consequences with ERC777. Be careful with ERC777 as reserve.\n    function repayDebt(address debtor_, ERC20 token_, uint256 amount_) external virtual;\n\n    /// @notice An escape hatch for setting debt in special cases, like swapping reserves to another token.\n    function setDebt(address debtor_, ERC20 token_, uint256 amount_) external virtual;\n\n    /// @notice Get total balance of assets inside the treasury + any debt taken out against those assets.\n    function getReserveBalance(ERC20 token_) external view virtual returns (uint256);\n\n    /// @notice Emergency shutdown of withdrawals.\n    function deactivate() external virtual;\n\n    /// @notice Re-activate withdrawals after shutdown.\n    function activate() external virtual;\n}\n"

    },

    "src/modules/BLREG/BLREG.v1.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport \"src/Kernel.sol\";\n\n/// @title  Olympus Boosted Liquidity Vault Registry\n/// @notice Olympus Boosted Liquidity Vault Registry (Module) Contract\n/// @dev    The Olympus Boosted Liquidity Vault Registry Module tracks the boosted liquidity vaults\n///         that are approved to be used by the Olympus protocol. This allows for a single-soure\n///         of truth for reporting purposes around total OHM deployed and net emissions.\nabstract contract BLREGv1 is Module {\n    // ========= EVENTS ========= //\n\n    event VaultAdded(address indexed vault);\n    event VaultRemoved(address indexed vault);\n\n    // ========= STATE ========= //\n\n    /// @notice Count of active vaults\n    /// @dev    This is a useless variable in contracts but useful for any frontends or\n    ///         off-chain requests where the array is not easily accessible.\n    uint256 public activeVaultCount;\n\n    /// @notice Tracks all active vaults\n    address[] public activeVaults;\n\n    // ========= FUNCTIONS ========= //\n\n    /// @notice         Adds an vault to the registry\n    /// @param vault_   The address of the vault to add\n    function addVault(address vault_) external virtual;\n\n    /// @notice         Removes an vault from the registry\n    /// @param vault_   The address of the vault to remove\n    function removeVault(address vault_) external virtual;\n}\n"

    },

    "src/Kernel.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n//     ███████    █████       █████ █████ ██████   ██████ ███████████  █████  █████  █████████\n//   ███░░░░░███ ░░███       ░░███ ░░███ ░░██████ ██████ ░░███░░░░░███░░███  ░░███  ███░░░░░███\n//  ███     ░░███ ░███        ░░███ ███   ░███░█████░███  ░███    ░███ ░███   ░███ ░███    ░░░\n// ░███      ░███ ░███         ░░█████    ░███░░███ ░███  ░██████████  ░███   ░███ ░░█████████\n// ░███      ░███ ░███          ░░███     ░███ ░░░  ░███  ░███░░░░░░   ░███   ░███  ░░░░░░░░███\n// ░░███     ███  ░███      █    ░███     ░███      ░███  ░███         ░███   ░███  ███    ░███\n//  ░░░███████░   ███████████    █████    █████     █████ █████        ░░████████  ░░█████████\n//    ░░░░░░░    ░░░░░░░░░░░    ░░░░░    ░░░░░     ░░░░░ ░░░░░          ░░░░░░░░    ░░░░░░░░░\n\n//============================================================================================//\n//                                        GLOBAL TYPES                                        //\n//============================================================================================//\n\n/// @notice Actions to trigger state changes in the kernel. Passed by the executor\nenum Actions {\n    InstallModule,\n    UpgradeModule,\n    ActivatePolicy,\n    DeactivatePolicy,\n    ChangeExecutor,\n    MigrateKernel\n}\n\n/// @notice Used by executor to select an action and a target contract for a kernel action\nstruct Instruction {\n    Actions action;\n    address target;\n}\n\n/// @notice Used to define which module functions a policy needs access to\nstruct Permissions {\n    Keycode keycode;\n    bytes4 funcSelector;\n}\n\ntype Keycode is bytes5;\n\n//============================================================================================//\n//                                       UTIL FUNCTIONS                                       //\n//============================================================================================//\n\nerror TargetNotAContract(address target_);\nerror InvalidKeycode(Keycode keycode_);\n\n// solhint-disable-next-line func-visibility\nfunction toKeycode(bytes5 keycode_) pure returns (Keycode) {\n    return Keycode.wrap(keycode_);\n}\n\n// solhint-disable-next-line func-visibility\nfunction fromKeycode(Keycode keycode_) pure returns (bytes5) {\n    return Keycode.unwrap(keycode_);\n}\n\n// solhint-disable-next-line func-visibility\nfunction ensureContract(address target_) view {\n    if (target_.code.length == 0) revert TargetNotAContract(target_);\n}\n\n// solhint-disable-next-line func-visibility\nfunction ensureValidKeycode(Keycode keycode_) pure {\n    bytes5 unwrapped = Keycode.unwrap(keycode_);\n    for (uint256 i = 0; i < 5; ) {\n        bytes1 char = unwrapped[i];\n        if (char < 0x41 || char > 0x5A) revert InvalidKeycode(keycode_); // A-Z only\n        unchecked {\n            i++;\n        }\n    }\n}\n\n//============================================================================================//\n//                                        COMPONENTS                                          //\n//============================================================================================//\n\n/// @notice Generic adapter interface for kernel access in modules and policies.\nabstract contract KernelAdapter {\n    error KernelAdapter_OnlyKernel(address caller_);\n\n    Kernel public kernel;\n\n    constructor(Kernel kernel_) {\n        kernel = kernel_;\n    }\n\n    /// @notice Modifier to restrict functions to be called only by kernel.\n    modifier onlyKernel() {\n        if (msg.sender != address(kernel)) revert KernelAdapter_OnlyKernel(msg.sender);\n        _;\n    }\n\n    /// @notice Function used by kernel when migrating to a new kernel.\n    function changeKernel(Kernel newKernel_) external onlyKernel {\n        kernel = newKernel_;\n    }\n}\n\n/// @notice Base level extension of the kernel. Modules act as independent state components to be\n///         interacted with and mutated through policies.\n/// @dev    Modules are installed and uninstalled via the executor.\nabstract contract Module is KernelAdapter {\n    error Module_PolicyNotPermitted(address policy_);\n\n    constructor(Kernel kernel_) KernelAdapter(kernel_) {}\n\n    /// @notice Modifier to restrict which policies have access to module functions.\n    modifier permissioned() {\n        if (!kernel.modulePermissions(KEYCODE(), Policy(msg.sender), msg.sig))\n            revert Module_PolicyNotPermitted(msg.sender);\n        _;\n    }\n\n    /// @notice 5 byte identifier for a module.\n    function KEYCODE() public pure virtual returns (Keycode) {}\n\n    /// @notice Returns which semantic version of a module is being implemented.\n    /// @return major - Major version upgrade indicates breaking change to the interface.\n    /// @return minor - Minor version change retains backward-compatible interface.\n    function VERSION() external pure virtual returns (uint8 major, uint8 minor) {}\n\n    /// @notice Initialization function for the module\n    /// @dev    This function is called when the module is installed or upgraded by the kernel.\n    /// @dev    MUST BE GATED BY onlyKernel. Used to encompass any initialization or upgrade logic.\n    function INIT() external virtual onlyKernel {}\n}\n\n/// @notice Policies are application logic and external interface for the kernel and installed modules.\n/// @dev    Policies are activated and deactivated in the kernel by the executor.\n/// @dev    Module dependencies and function permissions must be defined in appropriate functions.\nabstract contract Policy is KernelAdapter {\n    error Policy_ModuleDoesNotExist(Keycode keycode_);\n\n    constructor(Kernel kernel_) KernelAdapter(kernel_) {}\n\n    /// @notice Easily accessible indicator for if a policy is activated or not.\n    function isActive() external view returns (bool) {\n        return kernel.isPolicyActive(this);\n    }\n\n    /// @notice Function to grab module address from a given keycode.\n    function getModuleAddress(Keycode keycode_) internal view returns (address) {\n        address moduleForKeycode = address(kernel.getModuleForKeycode(keycode_));\n        if (moduleForKeycode == address(0)) revert Policy_ModuleDoesNotExist(keycode_);\n        return moduleForKeycode;\n    }\n\n    /// @notice Define module dependencies for this policy.\n    /// @return dependencies - Keycode array of module dependencies.\n    function configureDependencies() external virtual returns (Keycode[] memory dependencies) {}\n\n    /// @notice Function called by kernel to set module function permissions.\n    /// @return requests - Array of keycodes and function selectors for requested permissions.\n    function requestPermissions() external view virtual returns (Permissions[] memory requests) {}\n}\n\n/// @notice Main contract that acts as a central component registry for the protocol.\n/// @dev    The kernel manages modules and policies. The kernel is mutated via predefined Actions,\n/// @dev    which are input from any address assigned as the executor. The executor can be changed as needed.\ncontract Kernel {\n    // =========  EVENTS ========= //\n\n    event PermissionsUpdated(\n        Keycode indexed keycode_,\n        Policy indexed policy_,\n        bytes4 funcSelector_,\n        bool granted_\n    );\n    event ActionExecuted(Actions indexed action_, address indexed target_);\n\n    // =========  ERRORS ========= //\n\n    error Kernel_OnlyExecutor(address caller_);\n    error Kernel_ModuleAlreadyInstalled(Keycode module_);\n    error Kernel_InvalidModuleUpgrade(Keycode module_);\n    error Kernel_PolicyAlreadyActivated(address policy_);\n    error Kernel_PolicyNotActivated(address policy_);\n\n    // =========  PRIVILEGED ADDRESSES ========= //\n\n    /// @notice Address that is able to initiate Actions in the kernel. Can be assigned to a multisig or governance contract.\n    address public executor;\n\n    // =========  MODULE MANAGEMENT ========= //\n\n    /// @notice Array of all modules currently installed.\n    Keycode[] public allKeycodes;\n\n    /// @notice Mapping of module address to keycode.\n    mapping(Keycode => Module) public getModuleForKeycode;\n\n    /// @notice Mapping of keycode to module address.\n    mapping(Module => Keycode) public getKeycodeForModule;\n\n    /// @notice Mapping of a keycode to all of its policy dependents. Used to efficiently reconfigure policy dependencies.\n    mapping(Keycode => Policy[]) public moduleDependents;\n\n    /// @notice Helper for module dependent arrays. Prevents the need to loop through array.\n    mapping(Keycode => mapping(Policy => uint256)) public getDependentIndex;\n\n    /// @notice Module <> Policy Permissions.\n    /// @dev    Keycode -> Policy -> Function Selector -> bool for permission\n    mapping(Keycode => mapping(Policy => mapping(bytes4 => bool))) public modulePermissions;\n\n    // =========  POLICY MANAGEMENT ========= //\n\n    /// @notice List of all active policies\n    Policy[] public activePolicies;\n\n    /// @notice Helper to get active policy quickly. Prevents need to loop through array.\n    mapping(Policy => uint256) public getPolicyIndex;\n\n    //============================================================================================//\n    //                                       CORE FUNCTIONS                                       //\n    //============================================================================================//\n\n    constructor() {\n        executor = msg.sender;\n    }\n\n    /// @notice Modifier to check if caller is the executor.\n    modifier onlyExecutor() {\n        if (msg.sender != executor) revert Kernel_OnlyExecutor(msg.sender);\n        _;\n    }\n\n    function isPolicyActive(Policy policy_) public view returns (bool) {\n        return activePolicies.length > 0 && activePolicies[getPolicyIndex[policy_]] == policy_;\n    }\n\n    /// @notice Main kernel function. Initiates state changes to kernel depending on Action passed in.\n    function executeAction(Actions action_, address target_) external onlyExecutor {\n        if (action_ == Actions.InstallModule) {\n            ensureContract(target_);\n            ensureValidKeycode(Module(target_).KEYCODE());\n            _installModule(Module(target_));\n        } else if (action_ == Actions.UpgradeModule) {\n            ensureContract(target_);\n            ensureValidKeycode(Module(target_).KEYCODE());\n            _upgradeModule(Module(target_));\n        } else if (action_ == Actions.ActivatePolicy) {\n            ensureContract(target_);\n            _activatePolicy(Policy(target_));\n        } else if (action_ == Actions.DeactivatePolicy) {\n            ensureContract(target_);\n            _deactivatePolicy(Policy(target_));\n        } else if (action_ == Actions.ChangeExecutor) {\n            executor = target_;\n        } else if (action_ == Actions.MigrateKernel) {\n            ensureContract(target_);\n            _migrateKernel(Kernel(target_));\n        }\n\n        emit ActionExecuted(action_, target_);\n    }\n\n    function _installModule(Module newModule_) internal {\n        Keycode keycode = newModule_.KEYCODE();\n\n        if (address(getModuleForKeycode[keycode]) != address(0))\n            revert Kernel_ModuleAlreadyInstalled(keycode);\n\n        getModuleForKeycode[keycode] = newModule_;\n        getKeycodeForModule[newModule_] = keycode;\n        allKeycodes.push(keycode);\n\n        newModule_.INIT();\n    }\n\n    function _upgradeModule(Module newModule_) internal {\n        Keycode keycode = newModule_.KEYCODE();\n        Module oldModule = getModuleForKeycode[keycode];\n\n        if (address(oldModule) == address(0) || oldModule == newModule_)\n            revert Kernel_InvalidModuleUpgrade(keycode);\n\n        getKeycodeForModule[oldModule] = Keycode.wrap(bytes5(0));\n        getKeycodeForModule[newModule_] = keycode;\n        getModuleForKeycode[keycode] = newModule_;\n\n        newModule_.INIT();\n\n        _reconfigurePolicies(keycode);\n    }\n\n    function _activatePolicy(Policy policy_) internal {\n        if (isPolicyActive(policy_)) revert Kernel_PolicyAlreadyActivated(address(policy_));\n\n        // Add policy to list of active policies\n        activePolicies.push(policy_);\n        getPolicyIndex[policy_] = activePolicies.length - 1;\n\n        // Record module dependencies\n        Keycode[] memory dependencies = policy_.configureDependencies();\n        uint256 depLength = dependencies.length;\n\n        for (uint256 i; i < depLength; ) {\n            Keycode keycode = dependencies[i];\n\n            moduleDependents[keycode].push(policy_);\n            getDependentIndex[keycode][policy_] = moduleDependents[keycode].length - 1;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Grant permissions for policy to access restricted module functions\n        Permissions[] memory requests = policy_.requestPermissions();\n        _setPolicyPermissions(policy_, requests, true);\n    }\n\n    function _deactivatePolicy(Policy policy_) internal {\n        if (!isPolicyActive(policy_)) revert Kernel_PolicyNotActivated(address(policy_));\n\n        // Revoke permissions\n        Permissions[] memory requests = policy_.requestPermissions();\n        _setPolicyPermissions(policy_, requests, false);\n\n        // Remove policy from all policy data structures\n        uint256 idx = getPolicyIndex[policy_];\n        Policy lastPolicy = activePolicies[activePolicies.length - 1];\n\n        activePolicies[idx] = lastPolicy;\n        activePolicies.pop();\n        getPolicyIndex[lastPolicy] = idx;\n        delete getPolicyIndex[policy_];\n\n        // Remove policy from module dependents\n        _pruneFromDependents(policy_);\n    }\n\n    /// @notice All functionality will move to the new kernel. WARNING: ACTION WILL BRICK THIS KERNEL.\n    /// @dev    New kernel must add in all of the modules and policies via executeAction.\n    /// @dev    NOTE: Data does not get cleared from this kernel.\n    function _migrateKernel(Kernel newKernel_) internal {\n        uint256 keycodeLen = allKeycodes.length;\n        for (uint256 i; i < keycodeLen; ) {\n            Module module = Module(getModuleForKeycode[allKeycodes[i]]);\n            module.changeKernel(newKernel_);\n            unchecked {\n                ++i;\n            }\n        }\n\n        uint256 policiesLen = activePolicies.length;\n        for (uint256 j; j < policiesLen; ) {\n            Policy policy = activePolicies[j];\n\n            // Deactivate before changing kernel\n            policy.changeKernel(newKernel_);\n            unchecked {\n                ++j;\n            }\n        }\n    }\n\n    function _reconfigurePolicies(Keycode keycode_) internal {\n        Policy[] memory dependents = moduleDependents[keycode_];\n        uint256 depLength = dependents.length;\n\n        for (uint256 i; i < depLength; ) {\n            dependents[i].configureDependencies();\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _setPolicyPermissions(\n        Policy policy_,\n        Permissions[] memory requests_,\n        bool grant_\n    ) internal {\n        uint256 reqLength = requests_.length;\n        for (uint256 i = 0; i < reqLength; ) {\n            Permissions memory request = requests_[i];\n            modulePermissions[request.keycode][policy_][request.funcSelector] = grant_;\n\n            emit PermissionsUpdated(request.keycode, policy_, request.funcSelector, grant_);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _pruneFromDependents(Policy policy_) internal {\n        Keycode[] memory dependencies = policy_.configureDependencies();\n        uint256 depcLength = dependencies.length;\n\n        for (uint256 i; i < depcLength; ) {\n            Keycode keycode = dependencies[i];\n            Policy[] storage dependents = moduleDependents[keycode];\n\n            uint256 origIndex = getDependentIndex[keycode][policy_];\n            Policy lastPolicy = dependents[dependents.length - 1];\n\n            // Swap with last and pop\n            dependents[origIndex] = lastPolicy;\n            dependents.pop();\n\n            // Record new index and delete deactivated policy index\n            getDependentIndex[keycode][lastPolicy] = origIndex;\n            delete getDependentIndex[keycode][policy_];\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}\n"

    },

    "src/interfaces/AggregatorV2V3Interface.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorInterface {\n    function latestAnswer() external view returns (int256);\n\n    function latestTimestamp() external view returns (uint256);\n\n    function latestRound() external view returns (uint256);\n\n    function getAnswer(uint256 roundId) external view returns (int256);\n\n    function getTimestamp(uint256 roundId) external view returns (uint256);\n\n    event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n\n    event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n\ninterface AggregatorV3Interface {\n    function decimals() external view returns (uint8);\n\n    function description() external view returns (string memory);\n\n    function version() external view returns (uint256);\n\n    // getRoundData and latestRoundData should both raise \"No data present\"\n    // if they do not have data to report, instead of returning unset values\n    // which could be misinterpreted as actual reported values.\n    function getRoundData(\n        uint80 _roundId\n    )\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\n"

    },

    "src/policies/BoostedLiquidity/interfaces/IAura.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.8.0;\n\n// Define Booster Interface\ninterface IAuraBooster {\n    function deposit(uint256 pid_, uint256 amount_, bool stake_) external returns (bool);\n}\n\n// Define Base Reward Pool interface\ninterface IAuraRewardPool {\n    function balanceOf(address account_) external view returns (uint256);\n\n    function earned(address account_) external view returns (uint256);\n\n    function rewardRate() external view returns (uint256);\n\n    function rewardToken() external view returns (address);\n\n    function extraRewardsLength() external view returns (uint256);\n\n    function extraRewards(uint256 index) external view returns (address);\n\n    function deposit(uint256 assets_, address receiver_) external;\n\n    function getReward(address account_, bool claimExtras_) external;\n\n    function withdrawAndUnwrap(uint256 amount_, bool claim_) external returns (bool);\n}\n\n// Define Aura Mining Lib interface\ninterface IAuraMiningLib {\n    function convertCrvToCvx(uint256 amount_) external view returns (uint256);\n}\n\n// Define Aura STASH Token Interface\ninterface ISTASHToken {\n    function baseToken() external view returns (address);\n}\n"

    },

    "src/policies/BoostedLiquidity/interfaces/IBalancer.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.8.0;\n\n// Import types\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\n// Define Data Structures\nstruct JoinPoolRequest {\n    address[] assets;\n    uint256[] maxAmountsIn;\n    bytes userData;\n    bool fromInternalBalance;\n}\n\nstruct ExitPoolRequest {\n    address[] assets;\n    uint256[] minAmountsOut;\n    bytes userData;\n    bool toInternalBalance;\n}\n\n// Define Vault Interface\ninterface IVault {\n    function joinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        JoinPoolRequest memory request\n    ) external payable;\n\n    function exitPool(\n        bytes32 poolId,\n        address sender,\n        address payable recipient,\n        ExitPoolRequest memory request\n    ) external;\n\n    function getPoolTokens(\n        bytes32 poolId\n    ) external view returns (address[] memory, uint256[] memory, uint256);\n}\n\n// Define Balancer Base Pool Interface\ninterface IBasePool {\n    function getPoolId() external view returns (bytes32);\n\n    function balanceOf(address user_) external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function approve(address spender_, uint256 amount_) external returns (bool);\n}\n\n// Define Balancer Pool Factory Interface\ninterface IFactory {\n    function create(\n        string memory name,\n        string memory symbol,\n        ERC20[] memory tokens,\n        uint256[] memory weights,\n        uint256 swapFeePercentage,\n        address owner\n    ) external returns (address);\n}\n\ninterface IBalancerHelper {\n    function queryJoin(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        JoinPoolRequest memory request\n    ) external returns (uint256 bptOut, uint256[] memory amountsIn);\n\n    function queryExit(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        ExitPoolRequest memory request\n    ) external returns (uint256 bptIn, uint256[] memory amountsOut);\n}\n"

    },

    "src/policies/BoostedLiquidity/interfaces/IBLVault.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nstruct RewardsData {\n    address rewardToken;\n    uint256 outstandingRewards;\n}\n\ninterface IBLVault {\n    //============================================================================================//\n    //                                      LIQUIDITY FUNCTIONS                                   //\n    //============================================================================================//\n\n    /// @notice                         Mints OHM against a pair token deposit and uses the OHM and pair tokens to add liquidity to a Balancer pool\n    /// @dev                            Can only be called by the owner of the vault\n    /// @param amount_                  The amount of pair tokens to deposit\n    /// @param minLpAmount_             The minimum acceptable amount of LP tokens to receive back\n    /// @return lpAmountOut             The amount of LP tokens received by the transaction\n    function deposit(uint256 amount_, uint256 minLpAmount_) external returns (uint256 lpAmountOut);\n\n    /// @notice                         Withdraws LP tokens from Aura and Balancer, burns the OHM side, and returns the pair token side to the user\n    /// @dev                            Can only be called by the owner of the vault\n    /// @param lpAmount_                The amount of LP tokens to withdraw from Balancer\n    /// @param minTokenAmountsBalancer_ The minimum acceptable amounts of OHM (first entry), and pair tokens (second entry) to receive back from Balancer\n    /// @param minTokenAmountUser_      The minimum acceptable amount of pair tokens to receive back from the vault\n    /// @param claim_                   Whether to claim outstanding rewards from Aura\n    /// @return uint256                 The amount of OHM received\n    /// @return uint256                 The amount of pair tokens received\n    function withdraw(\n        uint256 lpAmount_,\n        uint256[] calldata minTokenAmountsBalancer_,\n        uint256 minTokenAmountUser_,\n        bool claim_\n    ) external returns (uint256, uint256);\n\n    /// @notice                         Withdraws LP tokens from Aura and Balancer, returns the pair tokens to the user\n    /// @dev                            Can only be called by the owner of the vault. Can only be called when the vault is paused\n    /// @param lpAmount_                The amount of LP tokens to withdraw from Balancer\n    /// @param minTokenAmounts_         The minimum acceptable amounts of OHM (first entry), and pair tokens (second entry) to receive back from Balancer\n    /// @return uint256                 The amount of OHM received\n    /// @return uint256                 The amount of pair tokens received\n    function emergencyWithdraw(\n        uint256 lpAmount_,\n        uint256[] calldata minTokenAmounts_\n    ) external returns (uint256, uint256);\n\n    //============================================================================================//\n    //                                       REWARDS FUNCTIONS                                    //\n    //============================================================================================//\n\n    /// @notice                         Claims outstanding rewards from Aura\n    /// @dev                            Can only be called by the owner of the vault\n    function claimRewards() external;\n\n    //============================================================================================//\n    //                                        VIEW FUNCTIONS                                      //\n    //============================================================================================//\n\n    /// @notice                         Gets whether enough time has passed since the last deposit for the user to be ale to withdraw\n    /// @return bool                    Whether enough time has passed since the last deposit for the user to be ale to withdraw\n    function canWithdraw() external view returns (bool);\n\n    /// @notice                         Gets the LP balance of the contract based on its deposits to Aura\n    /// @return uint256                 LP balance deposited into Aura\n    function getLpBalance() external view returns (uint256);\n\n    /// @notice                         Gets the contract's claim on pair tokens based on its LP balance deposited into Aura\n    /// @return uint256                 Claim on pair tokens\n    function getUserPairShare() external view returns (uint256);\n\n    /// @notice                         Returns the vault's unclaimed rewards in Aura\n    /// @return RewardsData[]           The vault's unclaimed rewards in Aura\n    function getOutstandingRewards() external view returns (RewardsData[] memory);\n}\n"

    },

    "src/policies/BoostedLiquidity/interfaces/IBLVaultManager.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n// Import system dependencies\nimport {MINTRv1} from \"src/modules/MINTR/MINTR.v1.sol\";\nimport {ROLESv1} from \"src/modules/ROLES/ROLES.v1.sol\";\nimport {TRSRYv1} from \"src/modules/TRSRY/TRSRY.v1.sol\";\n\n// Import external dependencies\nimport {AggregatorV3Interface} from \"interfaces/AggregatorV2V3Interface.sol\";\nimport {IAuraMiningLib} from \"policies/BoostedLiquidity/interfaces/IAura.sol\";\n\n// Import vault dependencies\nimport {IBLVault, RewardsData} from \"policies/BoostedLiquidity/interfaces/IBLVault.sol\";\n\ninterface IBLVaultManager {\n    // ========= DATA STRUCTURES ========= //\n\n    struct TokenData {\n        address ohm;\n        address pairToken;\n        address aura;\n        address bal;\n    }\n\n    struct BalancerData {\n        address vault;\n        address liquidityPool;\n        address balancerHelper;\n    }\n\n    struct AuraData {\n        uint256 pid;\n        address auraBooster;\n        address auraRewardPool;\n    }\n\n    struct OracleFeed {\n        AggregatorV3Interface feed;\n        uint48 updateThreshold;\n    }\n\n    //============================================================================================//\n    //                                        STATE VARIABLES                                     //\n    //============================================================================================//\n\n    /// @notice                         The minimum length of time between a deposit and a withdrawal\n    function minWithdrawalDelay() external returns (uint48);\n\n    //============================================================================================//\n    //                                        VAULT DEPLOYMENT                                    //\n    //============================================================================================//\n\n    /// @notice                         Deploys a personal single sided vault for the user\n    /// @dev                            The vault is deployed with the user as the owner\n    /// @return vault                   The address of the deployed vault\n    function deployVault() external returns (address);\n\n    //============================================================================================//\n    //                                         OHM MANAGEMENT                                     //\n    //============================================================================================//\n\n    /// @notice                         Mints OHM to the caller\n    /// @dev                            Can only be called by an approved vault\n    /// @param amount_                  The amount of OHM to mint\n    function mintOhmToVault(uint256 amount_) external;\n\n    /// @notice                         Burns OHM from the caller\n    /// @dev                            Can only be called by an approved vault. The caller must have an OHM approval for the MINTR.\n    /// @param amount_                  The amount of OHM to burn\n    function burnOhmFromVault(uint256 amount_) external;\n\n    //============================================================================================//\n    //                                     VAULT STATE MANAGEMENT                                 //\n    //============================================================================================//\n\n    /// @notice                         Increases the tracked value for totalLP\n    /// @dev                            Can only be called by an approved vault\n    /// @param amount_                  The amount of LP tokens to add to the total\n    function increaseTotalLp(uint256 amount_) external;\n\n    /// @notice                         Decreases the tracked value for totalLP\n    /// @dev                            Can only be called by an approved vault\n    /// @param amount_                  The amount of LP tokens to remove from the total\n    function decreaseTotalLp(uint256 amount_) external;\n\n    //============================================================================================//\n    //                                         VIEW FUNCTIONS                                     //\n    //============================================================================================//\n\n    /// @notice                         Returns whether enough time has passed since the last deposit for the user to be ale to withdraw\n    /// @param user_                    The user to check the vault of\n    /// @return bool                    Whether enough time has passed since the last deposit for the user to be ale to withdraw\n    function canWithdraw(address user_) external view returns (bool);\n\n    /// @notice                         Returns the user's vault's LP balance\n    /// @param user_                    The user to check the vault of\n    /// @return uint256                 The user's vault's LP balance\n    function getLpBalance(address user_) external view returns (uint256);\n\n    /// @notice                         Returns the user's vault's claim on the pair token\n    /// @param user_                    The user to check the vault of\n    /// @return uint256                 The user's vault's claim on the pair token\n    function getUserPairShare(address user_) external view returns (uint256);\n\n    /// @notice                         Returns the user's vault's unclaimed rewards in Aura\n    /// @param user_                    The user to check the vault of\n    /// @return RewardsData[]           The user's vault's unclaimed rewards in Aura\n    function getOutstandingRewards(address user_) external view returns (RewardsData[] memory);\n\n    /// @notice                         Calculates the max pair token deposit based on the limit and current amount of OHM minted\n    /// @return uint256                 The max pair token deposit\n    function getMaxDeposit() external view returns (uint256);\n\n    /// @notice                         Calculates the amount of LP tokens that will be generated for a given amount of pair tokens\n    /// @param amount_                  The amount of pair tokens to calculate the LP tokens for\n    /// @return uint256                 The amount of LP tokens that will be generated\n    function getExpectedLpAmount(uint256 amount_) external returns (uint256);\n\n    /// @notice                         Calculates the amount of OHM and pair tokens that should be received by the vault for withdrawing a given amount of LP tokens\n    /// @param lpAmount_                The amount of LP tokens to calculate the OHM and pair tokens for\n    /// @return expectedTokenAmounts    The amount of OHM and pair tokens that should be received\n    function getExpectedTokensOutProtocol(\n        uint256 lpAmount_\n    ) external returns (uint256[] memory expectedTokenAmounts);\n\n    /// @notice                         Calculates the amount of pair tokens that should be received by the user for withdrawing a given amount of LP tokens after the treasury takes any arbs\n    /// @param lpAmount_                The amount of LP tokens to calculate the pair tokens for\n    /// @return expectedTknAmount       The amount of pair tokens that should be received\n    function getExpectedPairTokenOutUser(\n        uint256 lpAmount_\n    ) external returns (uint256 expectedTknAmount);\n\n    /// @notice                         Gets all the reward tokens from the Aura pool\n    /// @return address[]               The addresses of the reward tokens\n    function getRewardTokens() external view returns (address[] memory);\n\n    /// @notice                         Gets the reward rate (tokens per second) of the passed reward token\n    /// @return uint256                 The reward rate (tokens per second)\n    function getRewardRate(address rewardToken_) external view returns (uint256);\n\n    /// @notice                         Returns the amount of OHM in the pool that is owned by this vault system.\n    /// @return uint256                 The amount of OHM in the pool that is owned by this vault system.\n    function getPoolOhmShare() external view returns (uint256);\n\n    /// @notice                         Gets the net OHM emitted or removed by the system since inception\n    /// @return uint256                 Vault system's current claim on OHM from the Balancer pool\n    /// @return uint256                 Current amount of OHM minted by the system into the Balancer pool\n    /// @return uint256                 OHM that wasn't minted, but was previously circulating that has been burned by the system\n    function getOhmSupplyChangeData() external view returns (uint256, uint256, uint256);\n\n    /// @notice                         Gets the number of OHM per 1 pair token using oracle prices\n    /// @return uint256                 OHM per 1 pair token (9 decimals)\n    function getOhmTknPrice() external view returns (uint256);\n\n    /// @notice                         Gets the number of pair tokens per 1 OHM using oracle prices\n    /// @return uint256                 Pair tokens per 1 OHM (18 decimals)\n    function getTknOhmPrice() external view returns (uint256);\n\n    /// @notice                         Gets the number of OHM per 1 pair token using pool prices\n    /// @return uint256                 OHM per 1 pair token (9 decimals)\n    function getOhmTknPoolPrice() external view returns (uint256);\n\n    //============================================================================================//\n    //                                        ADMIN FUNCTIONS                                     //\n    //============================================================================================//\n\n    /// @notice                         Emergency burns OHM that has been sent to the manager in the event a user had to emergency withdraw\n    /// @dev                            Can only be called by the admin\n    /// @param amount_                  The amount of OHM to burn\n    function emergencyBurnOhm(uint256 amount_) external;\n\n    /// @notice                         Updates the limit on minting OHM\n    /// @dev                            Can only be called by the admin. Cannot be set lower than the current outstanding minted OHM.\n    /// @param newLimit_                The new OHM limit (9 decimals)\n    function setLimit(uint256 newLimit_) external;\n\n    /// @notice                         Updates the fee on reward tokens\n    /// @dev                            Can only be called by the admin. Cannot be set beyond 10_000 (100%). Only is used by vaults deployed after the update.\n    /// @param newFee_                  The new fee (in basis points)\n    function setFee(uint64 newFee_) external;\n\n    /// @notice                         Updates the minimum holding period before a user can withdraw\n    /// @dev                            Can only be called by the admin\n    /// @param newDelay_                The new minimum holding period (in seconds)\n    function setWithdrawalDelay(uint48 newDelay_) external;\n\n    /// @notice                         Activates the vault manager and all approved vaults\n    /// @dev                            Can only be called by the admin\n    function activate() external;\n\n    /// @notice                         Deactivates the vault manager and all approved vaults\n    /// @dev                            Can only be called by the admin\n    function deactivate() external;\n}\n"

    },

    "src/policies/BoostedLiquidity/BLVaultLusd.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\n// Import system dependencies\nimport {IBLVault, RewardsData} from \"policies/BoostedLiquidity/interfaces/IBLVault.sol\";\nimport {IBLVaultManager} from \"policies/BoostedLiquidity/interfaces/IBLVaultManager.sol\";\nimport {BLVaultManagerLusd} from \"policies/BoostedLiquidity/BLVaultManagerLusd.sol\";\n\n// Import external dependencies\nimport {JoinPoolRequest, ExitPoolRequest, IVault, IBasePool} from \"policies/BoostedLiquidity/interfaces/IBalancer.sol\";\nimport {IAuraBooster, IAuraRewardPool, IAuraMiningLib, ISTASHToken} from \"policies/BoostedLiquidity/interfaces/IAura.sol\";\n\n// Import types\nimport {OlympusERC20Token} from \"src/external/OlympusERC20.sol\";\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\n// Import libraries\nimport {Clone} from \"clones/Clone.sol\";\nimport {TransferHelper} from \"libraries/TransferHelper.sol\";\nimport {FullMath} from \"libraries/FullMath.sol\";\n\ncontract BLVaultLusd is IBLVault, Clone {\n    using TransferHelper for ERC20;\n    using FullMath for uint256;\n\n    // ========= ERRORS ========= //\n\n    error BLVaultLusd_AlreadyInitialized();\n    error BLVaultLusd_OnlyOwner();\n    error BLVaultLusd_Active();\n    error BLVaultLusd_Inactive();\n    error BLVaultLusd_Reentrancy();\n    error BLVaultLusd_AuraDepositFailed();\n    error BLVaultLusd_AuraWithdrawalFailed();\n    error BLVaultLusd_WithdrawFailedPriceImbalance();\n    error BLVaultLusd_WithdrawalDelay();\n\n    // ========= EVENTS ========= //\n\n    event Deposit(uint256 ohmAmount, uint256 lusdAmount);\n    event Withdraw(uint256 ohmAmount, uint256 lusdAmount);\n    event RewardsClaimed(address indexed rewardsToken, uint256 amount);\n\n    // ========= STATE VARIABLES ========= //\n\n    /// @notice The last timestamp a deposit was made. Used for enforcing minimum deposit lengths.\n    uint256 public lastDeposit;\n\n    uint256 private constant _OHM_DECIMALS = 1e9;\n    uint256 private constant _LUSD_DECIMALS = 1e18;\n\n    uint256 private _reentrancyStatus;\n\n    uint8 private constant _ohmIndex = 1;\n    uint8 private constant _lusdIndex = 0;\n\n    // ========= CONSTRUCTOR ========= //\n\n    constructor() {}\n\n    // ========= INITIALIZER ========= //\n\n    function initializeClone() external {\n        if (_reentrancyStatus != 0) revert BLVaultLusd_AlreadyInitialized();\n        _reentrancyStatus = 1;\n    }\n\n    // ========= IMMUTABLE CLONE ARGS ========= //\n\n    function owner() public pure returns (address) {\n        return _getArgAddress(0);\n    }\n\n    function manager() public pure returns (BLVaultManagerLusd) {\n        return BLVaultManagerLusd(_getArgAddress(20));\n    }\n\n    function TRSRY() public pure returns (address) {\n        return _getArgAddress(40);\n    }\n\n    function MINTR() public pure returns (address) {\n        return _getArgAddress(60);\n    }\n\n    function ohm() public pure returns (OlympusERC20Token) {\n        return OlympusERC20Token(_getArgAddress(80));\n    }\n\n    function lusd() public pure returns (ERC20) {\n        return ERC20(_getArgAddress(100));\n    }\n\n    function aura() public pure returns (ERC20) {\n        return ERC20(_getArgAddress(120));\n    }\n\n    function bal() public pure returns (ERC20) {\n        return ERC20(_getArgAddress(140));\n    }\n\n    function vault() public pure returns (IVault) {\n        return IVault(_getArgAddress(160));\n    }\n\n    function liquidityPool() public pure returns (IBasePool) {\n        return IBasePool(_getArgAddress(180));\n    }\n\n    function pid() public pure returns (uint256) {\n        return _getArgUint256(200);\n    }\n\n    function auraBooster() public pure returns (IAuraBooster) {\n        return IAuraBooster(_getArgAddress(232));\n    }\n\n    function auraRewardPool() public pure returns (IAuraRewardPool) {\n        return IAuraRewardPool(_getArgAddress(252));\n    }\n\n    function fee() public pure returns (uint64) {\n        return _getArgUint64(272);\n    }\n\n    // ========= MODIFIERS ========= //\n\n    modifier onlyOwner() {\n        if (msg.sender != owner()) revert BLVaultLusd_OnlyOwner();\n        _;\n    }\n\n    modifier onlyWhileActive() {\n        if (!manager().isLusdBLVaultActive()) revert BLVaultLusd_Inactive();\n        _;\n    }\n\n    modifier onlyWhileInactive() {\n        if (manager().isLusdBLVaultActive()) revert BLVaultLusd_Active();\n        _;\n    }\n\n    modifier nonReentrant() {\n        if (_reentrancyStatus != 1) revert BLVaultLusd_Reentrancy();\n\n        _reentrancyStatus = 2;\n\n        _;\n\n        _reentrancyStatus = 1;\n    }\n\n    //============================================================================================//\n    //                                      LIQUIDITY FUNCTIONS                                   //\n    //============================================================================================//\n\n    /// @inheritdoc IBLVault\n    function deposit(\n        uint256 amount_,\n        uint256 minLpAmount_\n    ) external override onlyWhileActive onlyOwner nonReentrant returns (uint256 lpAmountOut) {\n        // Cache variables into memory\n        IBLVaultManager manager = manager();\n        OlympusERC20Token ohm = ohm();\n        ERC20 lusd = lusd();\n        IBasePool liquidityPool = liquidityPool();\n        IAuraBooster auraBooster = auraBooster();\n\n        uint256 ohmMintAmount;\n\n        // Set last deposit timestamp\n        lastDeposit = block.timestamp;\n\n        // Block scope to avoid stack too deep\n        // Calculate OHM amount to mint\n        {\n            // getOhmTknPrice returns the amount of OHM per 1 LUSD\n            uint256 ohmLusdOraclePrice = manager.getOhmTknPrice();\n            uint256 ohmLusdPoolPrice = manager.getOhmTknPoolPrice();\n\n            // If the expected oracle price mint amount is less than the expected pool price mint amount, use the oracle price\n            // otherwise use the pool price\n            uint256 ohmLusdPrice = ohmLusdOraclePrice < ohmLusdPoolPrice\n                ? ohmLusdOraclePrice\n                : ohmLusdPoolPrice;\n            ohmMintAmount = (amount_ * ohmLusdPrice) / _LUSD_DECIMALS;\n        }\n\n        // Block scope to avoid stack too deep\n        // Get tokens and deposit to Balancer and Aura\n        {\n            // Cache OHM-LUSD BPT before\n            uint256 bptBefore = liquidityPool.balanceOf(address(this));\n\n            // Transfer in LUSD\n            lusd.safeTransferFrom(msg.sender, address(this), amount_);\n\n            // Mint OHM\n            manager.mintOhmToVault(ohmMintAmount);\n\n            // Join Balancer pool\n            _joinBalancerPool(ohmMintAmount, amount_, minLpAmount_);\n\n            // OHM-PAIR BPT after\n            lpAmountOut = liquidityPool.balanceOf(address(this)) - bptBefore;\n            manager.increaseTotalLp(lpAmountOut);\n\n            // Stake into Aura\n            liquidityPool.approve(address(auraBooster), lpAmountOut);\n            bool depositSuccess = auraBooster.deposit(pid(), lpAmountOut, true);\n            if (!depositSuccess) revert BLVaultLusd_AuraDepositFailed();\n        }\n\n        // Return unused tokens\n        uint256 unusedOhm = ohm.balanceOf(address(this));\n        uint256 unusedLusd = lusd.balanceOf(address(this));\n\n        if (unusedOhm > 0) {\n            ohm.increaseAllowance(MINTR(), unusedOhm);\n            manager.burnOhmFromVault(unusedOhm);\n        }\n\n        if (unusedLusd > 0) {\n            lusd.safeTransfer(msg.sender, unusedLusd);\n        }\n\n        // Emit event\n        emit Deposit(ohmMintAmount - unusedOhm, amount_ - unusedLusd);\n\n        return lpAmountOut;\n    }\n\n    /// @inheritdoc IBLVault\n    function withdraw(\n        uint256 lpAmount_,\n        uint256[] calldata minTokenAmountsBalancer_,\n        uint256 minTokenAmountUser_,\n        bool claim_\n    ) external override onlyOwner nonReentrant returns (uint256, uint256) {\n        // Cache variables into memory\n        OlympusERC20Token ohm = ohm();\n        ERC20 lusd = lusd();\n        IBLVaultManager manager = manager();\n\n        // Check if enough time has passed since the latest deposit\n        if (block.timestamp - lastDeposit < manager.minWithdrawalDelay())\n            revert BLVaultLusd_WithdrawalDelay();\n\n        // Cache OHM and LUSD balances before\n        uint256 ohmBefore = ohm.balanceOf(address(this));\n        uint256 lusdBefore = lusd.balanceOf(address(this));\n\n        // Decrease total LP\n        manager.decreaseTotalLp(lpAmount_);\n\n        // Unstake from Aura\n        bool withdrawalSuccess = auraRewardPool().withdrawAndUnwrap(lpAmount_, claim_);\n        if (!withdrawalSuccess) revert BLVaultLusd_AuraWithdrawalFailed();\n\n        // Exit Balancer pool\n        _exitBalancerPool(lpAmount_, minTokenAmountsBalancer_);\n\n        // Calculate OHM and LUSD amounts received\n        uint256 ohmAmountOut = ohm.balanceOf(address(this)) - ohmBefore;\n        uint256 lusdAmountOut = lusd.balanceOf(address(this)) - lusdBefore;\n\n        // Calculate oracle expected LUSD received amount\n        // getTknOhmPrice returns the amount of LUSD per 1 OHM based on the oracle price\n        uint256 lusdOhmPrice = manager.getTknOhmPrice();\n        uint256 expectedLusdAmountOut = (ohmAmountOut * lusdOhmPrice) / _OHM_DECIMALS;\n\n        // Take any arbs relative to the oracle price for the Treasury and return the rest to the owner\n        uint256 lusdToReturn = lusdAmountOut > expectedLusdAmountOut\n            ? expectedLusdAmountOut\n            : lusdAmountOut;\n\n        if (lusdToReturn < minTokenAmountUser_) revert BLVaultLusd_WithdrawFailedPriceImbalance();\n        if (lusdAmountOut > lusdToReturn) lusd.safeTransfer(TRSRY(), lusdAmountOut - lusdToReturn);\n\n        // Burn OHM\n        ohm.increaseAllowance(MINTR(), ohmAmountOut);\n        manager.burnOhmFromVault(ohmAmountOut);\n\n        // Return LUSD to owner\n        lusd.safeTransfer(msg.sender, lusdToReturn);\n\n        // Return rewards to owner\n        if (claim_) _sendRewards();\n\n        // Emit event\n        emit Withdraw(ohmAmountOut, lusdToReturn);\n\n        return (ohmAmountOut, lusdToReturn);\n    }\n\n    /// @inheritdoc IBLVault\n    function emergencyWithdraw(\n        uint256 lpAmount_,\n        uint256[] calldata minTokenAmounts_\n    ) external override onlyWhileInactive onlyOwner nonReentrant returns (uint256, uint256) {\n        // Cache variables into memory\n        OlympusERC20Token ohm = ohm();\n        ERC20 lusd = lusd();\n\n        // Cache OHM and LUSD balances before\n        uint256 ohmBefore = ohm.balanceOf(address(this));\n        uint256 lusdBefore = lusd.balanceOf(address(this));\n\n        // Unstake from Aura\n        auraRewardPool().withdrawAndUnwrap(lpAmount_, false);\n\n        // Exit Balancer pool\n        _exitBalancerPool(lpAmount_, minTokenAmounts_);\n\n        // Calculate OHM and LUSD amounts received\n        uint256 ohmAmountOut = ohm.balanceOf(address(this)) - ohmBefore;\n        uint256 lusdAmountOut = lusd.balanceOf(address(this)) - lusdBefore;\n\n        // Transfer LUSD to owner\n        lusd.safeTransfer(msg.sender, lusdAmountOut);\n\n        // Transfer OHM to manager\n        ohm.transfer(address(manager()), ohmAmountOut);\n\n        return (ohmAmountOut, lusdAmountOut);\n    }\n\n    //============================================================================================//\n    //                                       REWARDS FUNCTIONS                                    //\n    //============================================================================================//\n\n    /// @inheritdoc IBLVault\n    function claimRewards() external override onlyWhileActive onlyOwner nonReentrant {\n        // Claim rewards from Aura\n        auraRewardPool().getReward(address(this), true);\n\n        // Send rewards to owner\n        _sendRewards();\n    }\n\n    //============================================================================================//\n    //                                        VIEW FUNCTIONS                                      //\n    //============================================================================================//\n\n    /// @inheritdoc IBLVault\n    function canWithdraw() external view override returns (bool) {\n        return block.timestamp - lastDeposit >= manager().minWithdrawalDelay();\n    }\n\n    /// @inheritdoc IBLVault\n    function getLpBalance() public view override returns (uint256) {\n        return auraRewardPool().balanceOf(address(this));\n    }\n\n    /// @inheritdoc IBLVault\n    function getUserPairShare() public view override returns (uint256) {\n        // If total supply is 0 return 0\n        if (liquidityPool().totalSupply() == 0) return 0;\n\n        // Get user's LP balance\n        uint256 userLpBalance = getLpBalance();\n\n        // Get pool balances\n        (, uint256[] memory balances, ) = vault().getPoolTokens(liquidityPool().getPoolId());\n\n        // Get user's share of the LUSD\n        uint256 userLusdShare = (userLpBalance * balances[_lusdIndex]) /\n            liquidityPool().totalSupply();\n\n        // Check pool against oracle price\n        // getTknOhmPrice returns the amount of LUSD per 1 OHM based on the oracle price\n        uint256 lusdOhmPrice = manager().getTknOhmPrice();\n        uint256 expectedLusdShare = (userLpBalance * balances[_ohmIndex] * lusdOhmPrice) /\n            (liquidityPool().totalSupply() * _OHM_DECIMALS);\n\n        return userLusdShare > expectedLusdShare ? expectedLusdShare : userLusdShare;\n    }\n\n    /// @inheritdoc IBLVault\n    function getOutstandingRewards() public view override returns (RewardsData[] memory) {\n        uint256 numExtraRewards = auraRewardPool().extraRewardsLength();\n        RewardsData[] memory rewards = new RewardsData[](numExtraRewards + 2);\n\n        // Get Bal reward\n        uint256 balRewards = auraRewardPool().earned(address(this));\n        rewards[0] = RewardsData({rewardToken: address(bal()), outstandingRewards: balRewards});\n\n        // Get Aura rewards\n        uint256 auraRewards = manager().auraMiningLib().convertCrvToCvx(balRewards);\n        rewards[1] = RewardsData({rewardToken: address(aura()), outstandingRewards: auraRewards});\n\n        // Get extra rewards\n        for (uint256 i; i < numExtraRewards; ) {\n            IAuraRewardPool extraRewardPool = IAuraRewardPool(auraRewardPool().extraRewards(i));\n\n            address extraRewardToken = ISTASHToken(extraRewardPool.rewardToken()).baseToken();\n            uint256 extraRewardAmount = extraRewardPool.earned(address(this));\n\n            rewards[i + 2] = RewardsData({\n                rewardToken: extraRewardToken,\n                outstandingRewards: extraRewardAmount\n            });\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return rewards;\n    }\n\n    //============================================================================================//\n    //                                      INTERNAL FUNCTIONS                                    //\n    //============================================================================================//\n\n    function _joinBalancerPool(\n        uint256 ohmAmount_,\n        uint256 lusdAmount_,\n        uint256 minLpAmount_\n    ) internal {\n        // Cache variables to memory\n        OlympusERC20Token ohm = ohm();\n        ERC20 lusd = lusd();\n        IVault vault = vault();\n\n        // Build join pool request\n        address[] memory assets = new address[](2);\n        assets[_ohmIndex] = address(ohm);\n        assets[_lusdIndex] = address(lusd);\n\n        uint256[] memory maxAmountsIn = new uint256[](2);\n        maxAmountsIn[_ohmIndex] = ohmAmount_;\n        maxAmountsIn[_lusdIndex] = lusdAmount_;\n\n        JoinPoolRequest memory joinPoolRequest = JoinPoolRequest({\n            assets: assets,\n            maxAmountsIn: maxAmountsIn,\n            userData: abi.encode(1, maxAmountsIn, minLpAmount_),\n            fromInternalBalance: false\n        });\n\n        // Join pool\n        ohm.increaseAllowance(address(vault), ohmAmount_);\n        lusd.approve(address(vault), lusdAmount_);\n        vault.joinPool(liquidityPool().getPoolId(), address(this), address(this), joinPoolRequest);\n    }\n\n    function _exitBalancerPool(uint256 lpAmount_, uint256[] calldata minTokenAmounts_) internal {\n        // Cache variables to memory\n        OlympusERC20Token ohm = ohm();\n        ERC20 lusd = lusd();\n        IBasePool liquidityPool = liquidityPool();\n        IVault vault = vault();\n\n        // Build exit pool request\n        address[] memory assets = new address[](2);\n        assets[_ohmIndex] = address(ohm);\n        assets[_lusdIndex] = address(lusd);\n\n        ExitPoolRequest memory exitPoolRequest = ExitPoolRequest({\n            assets: assets,\n            minAmountsOut: minTokenAmounts_,\n            userData: abi.encode(1, lpAmount_),\n            toInternalBalance: false\n        });\n\n        // Exit Balancer pool\n        liquidityPool.approve(address(vault), lpAmount_);\n        vault.exitPool(\n            liquidityPool.getPoolId(),\n            address(this),\n            payable(address(this)),\n            exitPoolRequest\n        );\n    }\n\n    function _sendRewards() internal {\n        // Send Bal rewards to owner\n        {\n            uint256 balRewards = bal().balanceOf(address(this));\n            uint256 balFee = (balRewards * fee()) / 10_000;\n            if (balRewards - balFee > 0) {\n                bal().safeTransfer(owner(), balRewards - balFee);\n                emit RewardsClaimed(address(bal()), balRewards - balFee);\n            }\n            if (balFee > 0) bal().safeTransfer(TRSRY(), balFee);\n        }\n\n        // Send Aura rewards to owner\n        {\n            uint256 auraRewards = aura().balanceOf(address(this));\n            uint256 auraFee = (auraRewards * fee()) / 10_000;\n            if (auraRewards - auraFee > 0) {\n                aura().safeTransfer(owner(), auraRewards - auraFee);\n                emit RewardsClaimed(address(aura()), auraRewards - auraFee);\n            }\n            if (auraFee > 0) aura().safeTransfer(TRSRY(), auraFee);\n        }\n\n        // Send extra rewards to owner\n        {\n            uint256 numExtraRewards = auraRewardPool().extraRewardsLength();\n            for (uint256 i; i < numExtraRewards; ) {\n                IAuraRewardPool extraRewardPool = IAuraRewardPool(auraRewardPool().extraRewards(i));\n                ERC20 extraRewardToken = ERC20(\n                    ISTASHToken(extraRewardPool.rewardToken()).baseToken()\n                );\n\n                uint256 extraRewardAmount = extraRewardToken.balanceOf(address(this));\n                uint256 extraRewardFee = (extraRewardAmount * fee()) / 10_000;\n                if (extraRewardAmount - extraRewardFee > 0) {\n                    extraRewardToken.safeTransfer(owner(), extraRewardAmount - extraRewardFee);\n                    emit RewardsClaimed(\n                        address(extraRewardToken),\n                        extraRewardAmount - extraRewardFee\n                    );\n                }\n                if (extraRewardFee > 0) extraRewardToken.safeTransfer(TRSRY(), extraRewardFee);\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n    }\n}\n"

    },

    "src/external/OlympusERC20.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.7.5;\n\n/// @notice Olympus OHM token\n/// @dev This contract is the legacy v2 OHM token. Included in the repo for completeness,\n///      since it is not being changed and is imported in some contracts.\n\ninterface IOlympusAuthority {\n    // =========  EVENTS ========= //\n\n    event GovernorPushed(address indexed from, address indexed to, bool _effectiveImmediately);\n    event GuardianPushed(address indexed from, address indexed to, bool _effectiveImmediately);\n    event PolicyPushed(address indexed from, address indexed to, bool _effectiveImmediately);\n    event VaultPushed(address indexed from, address indexed to, bool _effectiveImmediately);\n\n    event GovernorPulled(address indexed from, address indexed to);\n    event GuardianPulled(address indexed from, address indexed to);\n    event PolicyPulled(address indexed from, address indexed to);\n    event VaultPulled(address indexed from, address indexed to);\n\n    // =========  VIEW ========= //\n\n    function governor() external view returns (address);\n\n    function guardian() external view returns (address);\n\n    function policy() external view returns (address);\n\n    function vault() external view returns (address);\n}\n\n// File: types/OlympusAccessControlled.sol\n\nabstract contract OlympusAccessControlled {\n    // =========  EVENTS ========= //\n\n    event AuthorityUpdated(IOlympusAuthority indexed authority);\n\n    string internal UNAUTHORIZED = \"UNAUTHORIZED\"; // save gas\n\n    // =========  STATE VARIABLES ========= //\n\n    IOlympusAuthority public authority;\n\n    // =========  Constructor ========= //\n\n    constructor(IOlympusAuthority _authority) {\n        authority = _authority;\n        emit AuthorityUpdated(_authority);\n    }\n\n    // =========  MODIFIERS ========= //\n\n    modifier onlyGovernor() {\n        require(msg.sender == authority.governor(), UNAUTHORIZED);\n        _;\n    }\n\n    modifier onlyGuardian() {\n        require(msg.sender == authority.guardian(), UNAUTHORIZED);\n        _;\n    }\n\n    modifier onlyPermitted() {\n        require(msg.sender == authority.policy(), UNAUTHORIZED);\n        _;\n    }\n\n    modifier onlyVault() {\n        require(msg.sender == authority.vault(), UNAUTHORIZED);\n        _;\n    }\n\n    // =========  GOV ONLY ========= //\n\n    function setAuthority(IOlympusAuthority _newAuthority) external onlyGovernor {\n        authority = _newAuthority;\n        emit AuthorityUpdated(_newAuthority);\n    }\n}\n\n// File: cryptography/ECDSA.sol\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes memory signature\n    ) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(\n        bytes32 domainSeparator,\n        bytes32 structHash\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n\n// File: cryptography/EIP712.sol\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        uint256 chainID;\n        assembly {\n            chainID := chainid()\n        }\n\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = chainID;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        uint256 chainID;\n        assembly {\n            chainID := chainid()\n        }\n\n        if (chainID == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        uint256 chainID;\n        assembly {\n            chainID := chainid()\n        }\n\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, chainID, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n\n// File: interfaces/IERC20Permit.sol\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as th xe allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n\n// File: interfaces/IERC20.sol\n\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: interfaces/IOHM.sol\n\ninterface IOHM is IERC20 {\n    function mint(address account_, uint256 amount_) external;\n\n    function burn(uint256 amount) external;\n\n    function burnFrom(address account_, uint256 amount_) external;\n}\n\n// File: libraries/SafeMath.sol\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        assert(a == b * c + (a % b)); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    // Only used in the  BondingCalculator.sol\n    function sqrrt(uint256 a) internal pure returns (uint256 c) {\n        if (a > 3) {\n            c = a;\n            uint256 b = add(div(a, 2), 1);\n            while (b < c) {\n                c = b;\n                b = div(add(div(a, b), b), 2);\n            }\n        } else if (a != 0) {\n            c = 1;\n        }\n    }\n}\n\n// File: libraries/Counters.sol\n\nlibrary Counters {\n    using SafeMath for uint256;\n\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        // The {SafeMath} overflow check can be skipped here, see the comment at the top\n        counter._value += 1;\n    }\n\n    function decrement(Counter storage counter) internal {\n        counter._value = counter._value.sub(1);\n    }\n}\n\n// File: types/ERC20.sol\n\nabstract contract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    // TODO comment actual hash value.\n    bytes32 private constant ERC20TOKEN_ERC1820_INTERFACE_ID = keccak256(\"ERC20Token\");\n\n    mapping(address => uint256) internal _balances;\n\n    mapping(address => mapping(address => uint256)) internal _allowances;\n\n    uint256 internal _totalSupply;\n\n    string internal _name;\n\n    string internal _symbol;\n\n    uint8 internal immutable _decimals;\n\n    constructor(string memory name_, string memory symbol_, uint8 decimals_) {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = decimals_;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(\n        address owner,\n        address spender\n    ) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(\n            sender,\n            msg.sender,\n            _allowances[sender][msg.sender].sub(amount, \"ERC20: transfer amount exceeds allowance\")\n        );\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(\n        address spender,\n        uint256 subtractedValue\n    ) public virtual returns (bool) {\n        _approve(\n            msg.sender,\n            spender,\n            _allowances[msg.sender][spender].sub(\n                subtractedValue,\n                \"ERC20: decreased allowance below zero\"\n            )\n        );\n        return true;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _beforeTokenTransfer(address from_, address to_, uint256 amount_) internal virtual {}\n}\n\n// File: types/ERC20Permit.sol\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private immutable _PERMIT_TYPEHASH =\n        keccak256(\n            \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n        );\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(\n            abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline)\n        );\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n\n// File: OlympusERC20.sol\n\ncontract OlympusERC20Token is ERC20Permit, IOHM, OlympusAccessControlled {\n    using SafeMath for uint256;\n\n    constructor(\n        address _authority\n    )\n        ERC20(\"Olympus\", \"OHM\", 9)\n        ERC20Permit(\"Olympus\")\n        OlympusAccessControlled(IOlympusAuthority(_authority))\n    {}\n\n    function mint(address account_, uint256 amount_) external override onlyVault {\n        _mint(account_, amount_);\n    }\n\n    function burn(uint256 amount) external override {\n        _burn(msg.sender, amount);\n    }\n\n    function burnFrom(address account_, uint256 amount_) external override {\n        _burnFrom(account_, amount_);\n    }\n\n    function _burnFrom(address account_, uint256 amount_) internal {\n        uint256 decreasedAllowance_ = allowance(account_, msg.sender).sub(\n            amount_,\n            \"ERC20: burn amount exceeds allowance\"\n        );\n\n        _approve(account_, msg.sender, decreasedAllowance_);\n        _burn(account_, amount_);\n    }\n}\n"

    },

    "lib/clones-with-immutable-args/src/ClonesWithImmutableArgs.sol": {

      "content": "// SPDX-License-Identifier: BSD\n\npragma solidity ^0.8.4;\n\n/// @title ClonesWithImmutableArgs\n/// @author wighawag, zefram.eth\n/// @notice Enables creating clone contracts with immutable args\nlibrary ClonesWithImmutableArgs {\n    error CreateFail();\n\n    /// @notice Creates a clone proxy of the implementation contract, with immutable args\n    /// @dev data cannot exceed 65535 bytes, since 2 bytes are used to store the data length\n    /// @param implementation The implementation contract to clone\n    /// @param data Encoded immutable args\n    /// @return instance The address of the created clone\n    function clone(address implementation, bytes memory data)\n        internal\n        returns (address instance)\n    {\n        // unrealistic for memory ptr or data length to exceed 256 bits\n        unchecked {\n            uint256 extraLength = data.length + 2; // +2 bytes for telling how much data there is appended to the call\n            uint256 creationSize = 0x43 + extraLength;\n            uint256 runSize = creationSize - 11;\n            uint256 dataPtr;\n            uint256 ptr;\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                ptr := mload(0x40)\n\n                // -------------------------------------------------------------------------------------------------------------\n                // CREATION (11 bytes)\n                // -------------------------------------------------------------------------------------------------------------\n\n                // 3d          | RETURNDATASIZE        | 0                       | –\n                // 61 runtime  | PUSH2 runtime (r)     | r 0                     | –\n                mstore(\n                    ptr,\n                    0x3d61000000000000000000000000000000000000000000000000000000000000\n                )\n                mstore(add(ptr, 0x02), shl(240, runSize)) // size of the contract running bytecode (16 bits)\n\n                // creation size = 0b\n                // 80          | DUP1                  | r r 0                   | –\n                // 60 creation | PUSH1 creation (c)    | c r r 0                 | –\n                // 3d          | RETURNDATASIZE        | 0 c r r 0               | –\n                // 39          | CODECOPY              | r 0                     | [0-2d]: runtime code\n                // 81          | DUP2                  | 0 c  0                  | [0-2d]: runtime code\n                // f3          | RETURN                | 0                       | [0-2d]: runtime code\n                mstore(\n                    add(ptr, 0x04),\n                    0x80600b3d3981f300000000000000000000000000000000000000000000000000\n                )\n\n                // -------------------------------------------------------------------------------------------------------------\n                // RUNTIME\n                // -------------------------------------------------------------------------------------------------------------\n\n                // 36          | CALLDATASIZE          | cds                     | –\n                // 3d          | RETURNDATASIZE        | 0 cds                   | –\n                // 3d          | RETURNDATASIZE        | 0 0 cds                 | –\n                // 37          | CALLDATACOPY          | –                       | [0, cds] = calldata\n                // 61          | PUSH2 extra           | extra                   | [0, cds] = calldata\n                mstore(\n                    add(ptr, 0x0b),\n                    0x363d3d3761000000000000000000000000000000000000000000000000000000\n                )\n                mstore(add(ptr, 0x10), shl(240, extraLength))\n\n                // 60 0x38     | PUSH1 0x38            | 0x38 extra              | [0, cds] = calldata // 0x38 (56) is runtime size - data\n                // 36          | CALLDATASIZE          | cds 0x38 extra          | [0, cds] = calldata\n                // 39          | CODECOPY              | _                       | [0, cds] = calldata\n                // 3d          | RETURNDATASIZE        | 0                       | [0, cds] = calldata\n                // 3d          | RETURNDATASIZE        | 0 0                     | [0, cds] = calldata\n                // 3d          | RETURNDATASIZE        | 0 0 0                   | [0, cds] = calldata\n                // 36          | CALLDATASIZE          | cds 0 0 0               | [0, cds] = calldata\n                // 61 extra    | PUSH2 extra           | extra cds 0 0 0         | [0, cds] = calldata\n                mstore(\n                    add(ptr, 0x12),\n                    0x603836393d3d3d36610000000000000000000000000000000000000000000000\n                )\n                mstore(add(ptr, 0x1b), shl(240, extraLength))\n\n                // 01          | ADD                   | cds+extra 0 0 0         | [0, cds] = calldata\n                // 3d          | RETURNDATASIZE        | 0 cds 0 0 0             | [0, cds] = calldata\n                // 73 addr     | PUSH20 0x123…         | addr 0 cds 0 0 0        | [0, cds] = calldata\n                mstore(\n                    add(ptr, 0x1d),\n                    0x013d730000000000000000000000000000000000000000000000000000000000\n                )\n                mstore(add(ptr, 0x20), shl(0x60, implementation))\n\n                // 5a          | GAS                   | gas addr 0 cds 0 0 0    | [0, cds] = calldata\n                // f4          | DELEGATECALL          | success 0               | [0, cds] = calldata\n                // 3d          | RETURNDATASIZE        | rds success 0           | [0, cds] = calldata\n                // 82          | DUP3                  | 0 rds success 0         | [0, cds] = calldata\n                // 80          | DUP1                  | 0 0 rds success 0       | [0, cds] = calldata\n                // 3e          | RETURNDATACOPY        | success 0               | [0, rds] = return data (there might be some irrelevant leftovers in memory [rds, cds] when rds < cds)\n                // 90          | SWAP1                 | 0 success               | [0, rds] = return data\n                // 3d          | RETURNDATASIZE        | rds 0 success           | [0, rds] = return data\n                // 91          | SWAP2                 | success 0 rds           | [0, rds] = return data\n                // 60 0x36     | PUSH1 0x36            | 0x36 sucess 0 rds       | [0, rds] = return data\n                // 57          | JUMPI                 | 0 rds                   | [0, rds] = return data\n                // fd          | REVERT                | –                       | [0, rds] = return data\n                // 5b          | JUMPDEST              | 0 rds                   | [0, rds] = return data\n                // f3          | RETURN                | –                       | [0, rds] = return data\n\n                mstore(\n                    add(ptr, 0x34),\n                    0x5af43d82803e903d91603657fd5bf30000000000000000000000000000000000\n                )\n            }\n\n            // -------------------------------------------------------------------------------------------------------------\n            // APPENDED DATA (Accessible from extcodecopy)\n            // (but also send as appended data to the delegatecall)\n            // -------------------------------------------------------------------------------------------------------------\n\n            extraLength -= 2;\n            uint256 counter = extraLength;\n            uint256 copyPtr = ptr + 0x43;\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                dataPtr := add(data, 32)\n            }\n            for (; counter >= 32; counter -= 32) {\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    mstore(copyPtr, mload(dataPtr))\n                }\n\n                copyPtr += 32;\n                dataPtr += 32;\n            }\n            uint256 mask = ~(256**(32 - counter) - 1);\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                mstore(copyPtr, and(mload(dataPtr), mask))\n            }\n            copyPtr += counter;\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                mstore(copyPtr, shl(240, extraLength))\n            }\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                instance := create(0, ptr, creationSize)\n            }\n            if (instance == address(0)) {\n                revert CreateFail();\n            }\n        }\n    }\n}\n"

    },

    "src/modules/ROLES/ROLES.v1.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.15;\n\nimport \"src/Kernel.sol\";\n\nabstract contract ROLESv1 is Module {\n    // =========  EVENTS ========= //\n\n    event RoleGranted(bytes32 indexed role_, address indexed addr_);\n    event RoleRevoked(bytes32 indexed role_, address indexed addr_);\n\n    // =========  ERRORS ========= //\n\n    error ROLES_InvalidRole(bytes32 role_);\n    error ROLES_RequireRole(bytes32 role_);\n    error ROLES_AddressAlreadyHasRole(address addr_, bytes32 role_);\n    error ROLES_AddressDoesNotHaveRole(address addr_, bytes32 role_);\n    error ROLES_RoleDoesNotExist(bytes32 role_);\n\n    // =========  STATE ========= //\n\n    /// @notice Mapping for if an address has a policy-defined role.\n    mapping(address => mapping(bytes32 => bool)) public hasRole;\n\n    // =========  FUNCTIONS ========= //\n\n    /// @notice Function to grant policy-defined roles to some address. Can only be called by admin.\n    function saveRole(bytes32 role_, address addr_) external virtual;\n\n    /// @notice Function to revoke policy-defined roles from some address. Can only be called by admin.\n    function removeRole(bytes32 role_, address addr_) external virtual;\n\n    /// @notice \"Modifier\" to restrict policy function access to certain addresses with a role.\n    /// @dev    Roles are defined in the policy and granted by the ROLES admin.\n    function requireRole(bytes32 role_, address caller_) external virtual;\n\n    /// @notice Function that checks if role is valid (all lower case)\n    function ensureValidRole(bytes32 role_) external pure virtual;\n}\n"

    },

    "lib/solmate/src/tokens/ERC20.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"

    },

    "lib/clones-with-immutable-args/src/Clone.sol": {

      "content": "// SPDX-License-Identifier: BSD\npragma solidity ^0.8.4;\n\n/// @title Clone\n/// @author zefram.eth\n/// @notice Provides helper functions for reading immutable args from calldata\ncontract Clone {\n    /// @notice Reads an immutable arg with type address\n    /// @param argOffset The offset of the arg in the packed data\n    /// @return arg The arg value\n    function _getArgAddress(uint256 argOffset)\n        internal\n        pure\n        returns (address arg)\n    {\n        uint256 offset = _getImmutableArgsOffset();\n        assembly {\n            arg := shr(0x60, calldataload(add(offset, argOffset)))\n        }\n    }\n\n    /// @notice Reads an immutable arg with type uint256\n    /// @param argOffset The offset of the arg in the packed data\n    /// @return arg The arg value\n    function _getArgUint256(uint256 argOffset)\n        internal\n        pure\n        returns (uint256 arg)\n    {\n        uint256 offset = _getImmutableArgsOffset();\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            arg := calldataload(add(offset, argOffset))\n        }\n    }\n\n    /// @notice Reads an immutable arg with type uint64\n    /// @param argOffset The offset of the arg in the packed data\n    /// @return arg The arg value\n    function _getArgUint64(uint256 argOffset)\n        internal\n        pure\n        returns (uint64 arg)\n    {\n        uint256 offset = _getImmutableArgsOffset();\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            arg := shr(0xc0, calldataload(add(offset, argOffset)))\n        }\n    }\n\n    /// @notice Reads an immutable arg with type uint8\n    /// @param argOffset The offset of the arg in the packed data\n    /// @return arg The arg value\n    function _getArgUint8(uint256 argOffset) internal pure returns (uint8 arg) {\n        uint256 offset = _getImmutableArgsOffset();\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            arg := shr(0xf8, calldataload(add(offset, argOffset)))\n        }\n    }\n\n    /// @return offset The offset of the packed immutable args in calldata\n    function _getImmutableArgsOffset() internal pure returns (uint256 offset) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            offset := sub(\n                calldatasize(),\n                add(shr(240, calldataload(sub(calldatasize(), 2))), 2)\n            )\n        }\n    }\n}\n"

    },

    "src/libraries/TransferHelper.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\n\n/// @notice Safe ERC20 and ETH transfer library that safely handles missing return values.\n/// @author Modified from Uniswap & old Solmate (https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/libraries/TransferHelper.sol)\nlibrary TransferHelper {\n    function safeTransferFrom(ERC20 token, address from, address to, uint256 amount) internal {\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(ERC20.transferFrom.selector, from, to, amount)\n        );\n\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(ERC20 token, address to, uint256 amount) internal {\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(ERC20.transfer.selector, to, amount)\n        );\n\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(ERC20 token, address to, uint256 amount) internal {\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(ERC20.approve.selector, to, amount)\n        );\n\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"APPROVE_FAILED\");\n    }\n}\n"

    },

    "src/libraries/FullMath.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = a * b\n            // Compute the product mod 2**256 and mod 2**256 - 1\n            // then use the Chinese Remainder Theorem to reconstruct\n            // the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2**256 + prod0\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(a, b, not(0))\n                prod0 := mul(a, b)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division\n            if (prod1 == 0) {\n                require(denominator > 0);\n                assembly {\n                    result := div(prod0, denominator)\n                }\n                return result;\n            }\n\n            // Make sure the result is less than 2**256.\n            // Also prevents denominator == 0\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0]\n            // Compute remainder using mulmod\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(a, b, denominator)\n            }\n            // Subtract 256 bit number from 512 bit number\n            assembly {\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator\n            // Compute largest power of two divisor of denominator.\n            // Always >= 1.\n            uint256 twos = (type(uint256).max - denominator + 1) & denominator;\n            // Divide denominator by power of two\n            assembly {\n                denominator := div(denominator, twos)\n            }\n\n            // Divide [prod1 prod0] by the factors of two\n            assembly {\n                prod0 := div(prod0, twos)\n            }\n            // Shift in bits from prod1 into prod0. For this we need\n            // to flip `twos` such that it is 2**256 / twos.\n            // If twos is zero, then it becomes one\n            assembly {\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2**256\n            // Now that denominator is an odd number, it has an inverse\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n            // Compute the inverse by starting with a seed that is correct\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\n            uint256 inv = (3 * denominator) ^ 2;\n            // Now use Newton-Raphson iteration to improve the precision.\n            // Thanks to Hensel's lifting lemma, this also works in modular\n            // arithmetic, doubling the correct bits in each step.\n            inv *= 2 - denominator * inv; // inverse mod 2**8\n            inv *= 2 - denominator * inv; // inverse mod 2**16\n            inv *= 2 - denominator * inv; // inverse mod 2**32\n            inv *= 2 - denominator * inv; // inverse mod 2**64\n            inv *= 2 - denominator * inv; // inverse mod 2**128\n            inv *= 2 - denominator * inv; // inverse mod 2**256\n\n            // Because the division is now exact we can divide by multiplying\n            // with the modular inverse of denominator. This will give us the\n            // correct result modulo 2**256. Since the precoditions guarantee\n            // that the outcome is less than 2**256, this is the final result.\n            // We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inv;\n            return result;\n        }\n    }\n\n    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivUp(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        result = mulDiv(a, b, denominator);\n        unchecked {\n            if (mulmod(a, b, denominator) > 0) {\n                require(result < type(uint256).max);\n                result++;\n            }\n        }\n    }\n}\n"

    }

  },

  "settings": {

    "remappings": [

      "balancer-v2/=lib/balancer-v2/",

      "bonds/=lib/bonds/src/",

      "clones-with-immutable-args/=lib/clones-with-immutable-args/src/",

      "clones/=lib/clones-with-immutable-args/src/",

      "ds-test/=lib/ds-test/src/",

      "forge-std/=lib/forge-std/src/",

      "interfaces/=src/interfaces/",

      "libraries/=src/libraries/",

      "modules/=src/modules/",

      "policies/=src/policies/",

      "solmate/=lib/solmate/src/",

      "test/=src/test/"

    ],

    "optimizer": {

      "enabled": true,

      "runs": 10

    },

    "metadata": {

      "bytecodeHash": "ipfs"

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "evmVersion": "london",

    "libraries": {}

  }

}}