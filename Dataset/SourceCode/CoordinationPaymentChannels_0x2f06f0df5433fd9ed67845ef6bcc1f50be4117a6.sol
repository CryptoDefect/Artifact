// SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "./CanReclaimTokens.sol";

interface IWETH {
    function withdraw(uint wad) external;
}

contract CoordinationPaymentChannels is CanReclaimTokens {
    using SafeERC20 for IERC20;

    IERC20 constant WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    bytes constant public INSTANT_WITHDRAWAL_COMMITMENT_DATA = bytes("INSTANT");

    // This keypair is responsible for signing stake commitments
    address public coordinator;
    // This keypair is responsible for signing user claim commitments
    address public claimGenerator;

    /* coordinator <-> keeper payment channels
     * The Coordinator and Keepers transact off-chain using these payment channels in a series of auctions
     * hosted by the Coordinator. The values stored in these variables reflect the latest on-chain state for a
     * payment channel, but the actual state of the payment channels is likely to be more recent than what is on
     * chain. The Coordinator and keeepers will pass signed commitments back and forth dictating what the current state
     * of the payment channel is.
     * A payment channel is keyed by a Keeper's stake address.
     * Note a keeper may have multiple payment channels / stake addresses.
     */
    // The amount of WETH a keeper's stake address has staked. This determines their maximum spending power.
    mapping (address => uint256) public stakedAmount;
    // This nonce is used to give an ordering to the off-chain stake commitments and to prevent replays on-chain.
    mapping (address => uint256) public stakeNonce;
    // The total amount of WETH a keeper has currently spent. Cannot be greater than stakedAmount.
    mapping (address => uint256) public stakeSpent;
    // Used to prevent channel reuse edge cases if a stake address closes their channel and opens another.
    mapping (address => uint256) public channelNonce;
    // Used to track the expiration of withdrawal timelocks.
    mapping (bytes32 => uint256) public withdrawalTimelockTimestamp;

    /* claim generator -> user payment channels
     * The Claim Generator will generate claims using the Keeper bids from the Coordinator auctions. Claim amounts are
     * calculated as a percentage of the bid amounts determined by the DAO. Given that bids are signed by Keepers and
     * the Claim Generator, and they are available publicly, claim amount correcntess is easily verifiable off-chain.
     *
     * userClaimedAmount tracks how much a user has claimed to date. A user's outstanding claim amount is given by
     * subtracting userClaimedAmount from their most recent claim commitment generated by the Claim Generator.
     */
    mapping (address => uint256) public userClaimedAmount;


    /* Total amount of claimable WETH. Accrues when commitments are submitted to `initiateTimelockedWithdrawal`,
     * `executeInstantWithdrawal`, and `settleSpentStake` and when `addClaimable` is called.
     */
    uint256 public totalClaimableAmount;

    event Staked(address indexed _stakeAddress, uint256 _channelNonce, uint256 _amount);
    event Claimed(address indexed _claimAddress, uint256 _amount);
    event CoordinatorChanged(address indexed _oldCoordinator, address indexed _newCoordinator);
    event ClaimGeneratorChanged(address indexed _oldClaimGenerator, address indexed _newClaimGenerator);
    event StakeWithdrawn(address indexed _stakeAddress, uint256 _channelNonce, uint256 _amount);
    event TimelockedWithdrawalInitiated(
        address indexed _stakeAddress, 
        uint256 _stakeSpent, 
        uint256 _stakeNonce, 
        uint256 _channelNonce, 
        uint256 _withdrawalTimelock);
    event AddedClaimable(uint256 _amount);
    event Settled(uint256 _refundedAmount, uint256 _accruedAmount);

    /* Represents a payment channel state. The Coordinator and Keepers will sign commitments to agree upon the current
     * Note, the `data` field is used off-chain to hold the hash of the previous commitment to ensure that the 
     * Coordinator and Keeper state for the payment channel is always consistent. The only time any assertions are made
     * on its value is `executeInstantWithdrawal` when it should equal `INSTANT_WITHDRAWAL_COMMITMENT_DATA`.
     */
    struct StakeCommitment {
        address stakeAddress;
        uint256 stakeSpent;
        uint256 stakeNonce;
        uint256 channelNonce;
        bytes data;
        bytes stakeAddressSignature;
        bytes coordinatorSignature;
    }

    /// @notice Retreives the payment channel state for the provided stake address.
    function getStakerState(
        address _stakeAddress
    ) public view returns (
        uint256 _stakedAmount, 
        uint256 _stakeNonce, 
        uint256 _stakeSpent, 
        uint256 _channelNonce, 
        uint256 _withdrawalTimelock
    ) {
        return (
            stakedAmount[_stakeAddress], 
            stakeNonce[_stakeAddress], 
            stakeSpent[_stakeAddress], 
            channelNonce[_stakeAddress], 
            getCurrentWithdrawalTimelock(_stakeAddress));
    }

    /** @notice Calculate the commitment hash used for signatures for a particular stake payment channel state.
      * @dev The Coordinator and Keepers transact off-chain by passing signed commitments back and forth. Signed stake 
      *      commitments are submitted on-chain only to perform settlements and withdrawals.
      */
    function stakeCommitmentHash(
        address _stakeAddress, 
        uint256 _stakeSpent, 
        uint256 _stakeNonce, 
        uint256 _channelNonce, 
        bytes memory _data
    ) public pure returns (bytes32) {
        return keccak256(abi.encode(_stakeAddress, _stakeSpent, _stakeNonce, _channelNonce, _data));
    }

    function stakeCommitmentHash(
        StakeCommitment memory _commitment
    ) internal pure returns (bytes32) {
        return stakeCommitmentHash(
            _commitment.stakeAddress, 
            _commitment.stakeSpent, 
            _commitment.stakeNonce, 
            _commitment.channelNonce, 
            _commitment.data);
    }

    /** @notice Calculate the commitment hash used for signatures for a particular claim payment channel state.
      *         Signed claim commitments are generated by the claim generator and used by users to perform claims.
      */
    function claimCommitmentHash(
        address _claimAddress, 
        uint256 _earningsToDate
    ) public pure returns (bytes32) {
        return keccak256(abi.encode(_claimAddress, _earningsToDate));
    }

    /** @notice Calculate the key to the entry in the withdrawalTimelockTimestamp map for a particular stake
      *         payment channel state.
      */
    function withdrawalTimelockKey(
        address _stakeAddress, 
        uint256 _stakeSpent, 
        uint256 _stakeNonce, 
        uint256 _channelNonce
    ) public pure returns (bytes32) {
        return keccak256(abi.encode(_stakeAddress, _stakeSpent, _stakeNonce, _channelNonce));
    }

    /** @notice Get the withdrawal timelock expiration for a payment channel. A return value of 0 indicates no timelock.
      * @dev The withdrawal timelock allows the Coordinator to withdrawals with newer commitments.
      */
    function getCurrentWithdrawalTimelock(
        address _stakeAddress
    ) public view returns (uint256) {
        return withdrawalTimelockTimestamp[
            withdrawalTimelockKey(
                _stakeAddress, 
                stakeSpent[_stakeAddress], 
                stakeNonce[_stakeAddress], 
                channelNonce[_stakeAddress])];
    }

    constructor(address _coordinator, address _claimGenerator) {
        coordinator = _coordinator;
        claimGenerator = _claimGenerator;
        blacklistRecoverableToken(address(WETH));
        emit CoordinatorChanged(address(0), _coordinator);
        emit ClaimGeneratorChanged(address(0), _claimGenerator);
    }

    fallback() external payable {}

    receive() external payable {}

    /** @notice Update the Coordinator address. This keypair is responsible for signing stake commitments.
      * @dev To migrate Coordinator addresses, any commitments signed by the old Coordinator must be resigned by the
      *      new Coordinator address.
      */ 
    function updateCoordinatorAddress(
        address _newCoordinator
    ) external onlyOperator {
        emit CoordinatorChanged(coordinator, _newCoordinator);
        coordinator = _newCoordinator;
    }

    /** @notice Update the claimGenerator address. This keypair is responsible to for signing user claim commitments.
      * @dev To migrate claimGenerator addresses, any commitments signed by the old Claim address must be resigned by
      *      the new claimGenerator address.
      */
    function updateClaimGeneratorAddress(
        address _newClaimGenerator
    ) external onlyOperator {
        emit ClaimGeneratorChanged(claimGenerator, _newClaimGenerator);
        claimGenerator = _newClaimGenerator;
    }

    /** @notice Add WETH to the payment channel of msg.sender. Cannot be done while in a timelocked withdrawal.
      * @dev Withdrawal of stake will require a signature from the Coordinator.
      */
    function stake(
        uint256 _amount
    ) public {
        require(getCurrentWithdrawalTimelock(msg.sender) == 0, "cannot stake while in withdrawal");
        WETH.safeTransferFrom(msg.sender, address(this), _amount);
        stakedAmount[msg.sender] += _amount;
        emit Staked(msg.sender, channelNonce[msg.sender], stakedAmount[msg.sender]);
    }

    /** @notice Used to add claimable WETH to the contract.
      * @dev Since claimable WETH otherwise only accrues on withdrawal or settlement of WETH, this can be used create a
      *      buffer of immediately claimable WETH so users do not need to wait for a Keeper to withdraw or for someone
      *      to call the `settleSpentStake` function. This can also be used to amend deficits from overgenerous claims.
      */
    function addClaimable(
        uint256 _amount
    ) public {
        WETH.safeTransferFrom(msg.sender, address(this), _amount);
        totalClaimableAmount += _amount;
        emit AddedClaimable(_amount);
    }

    /** @dev The stakeSpent for a payment channel will increase when a stake address makes payments and decrease
      *      when the Coordinator issues refunds. This function changes the totalClaimableAmount of WETH on the contract
      *      accordingly.
      */
    function adjustTotalClaimableAmountByStakeSpentChange(
        uint256 _oldStakeSpent, 
        uint256 _newStakeSpent
    ) internal {
        if (_newStakeSpent < _oldStakeSpent) {
            // If a stake address's new stakeSpent is less than their previously stored stakeSpent, then a refund was 
            // issued to the stakeAddress. We "refund" this WETH to the stakeAddress by subtracting 
            // the difference from totalClaimableAmount.
            uint256 refundAmount = _oldStakeSpent - _newStakeSpent;
            require(totalClaimableAmount >= refundAmount, "not enough claimable WETH to refund");
            totalClaimableAmount -= refundAmount;
        } else {
            // Otherwise we accrue any unsettled spent stake to totalClaimableAmount.
            totalClaimableAmount += _newStakeSpent - _oldStakeSpent;
        }
    }

    /** @notice Used to settle spent stake for a payment channel to accrue claimable WETH. 
      * @dev Note anyone can call this function since it requires a signature from both keepers and the coordinator.
      *      It will primarily be used by the coordinator but a user who would like to claim WETH immediately when there
      *      is no claimable WETH may also call this to accrue claimable WETH.
      * @param _commitments is a list of StakeCommitments. There should be one entry for each payment channel being
      *        settled and it should be the latest commitment for that channel. We only care about the most recent
      *        state for a payment channel, so evenif there are multiple commitments for a payment channel that have not
      *        been submitted on-chain, only the latest needs to be submitted. The resulting contract state will be the
      *        same regardless.
      */
    function settleSpentStake(
        StakeCommitment[] memory _commitments
    ) external {
        uint256 claimableWETHToAccrue = 0;
        uint256 claimableWETHToRefund = 0;
        for (uint i=0; i< _commitments.length; i++) {
            StakeCommitment memory commitment = _commitments[i];
            // Initiating withdrawal settles the spent stake in the payment channel. Thus we disable settling spent
            // stake using this function for a payment channel in withdrawal. Proper settlement of the payment channel
            // should be handled by the withdrawal process.
            require(getCurrentWithdrawalTimelock(commitment.stakeAddress) == 0, "cannot settle while in withdrawal");
            require(commitment.stakeSpent <= stakedAmount[commitment.stakeAddress], "cannot spend more than is staked");
            require(commitment.stakeNonce > stakeNonce[commitment.stakeAddress], "stake nonce is too old");
            require(commitment.channelNonce == channelNonce[commitment.stakeAddress], "incorrect channel nonce");

            address recoveredStakeAddress = ECDSA.recover(
                ECDSA.toEthSignedMessageHash(stakeCommitmentHash(commitment)), 
                commitment.stakeAddressSignature);
            require(recoveredStakeAddress == commitment.stakeAddress, "recovered address is not the stake address");
            address recoveredCoordinatorAddress =  ECDSA.recover(
                ECDSA.toEthSignedMessageHash(stakeCommitmentHash(commitment)), 
                commitment.coordinatorSignature);
            require(recoveredCoordinatorAddress == coordinator, "recovered address is not the coordinator");

            if (commitment.stakeSpent < stakeSpent[commitment.stakeAddress]) {
                // If a stake address's new stakeSpent is less than their previously stored stakeSpent, then a refund was 
                // issued to the stakeAddress. We "refund" this WETH to the stakeAddress by subtracting 
                // the difference from totalClaimableAmount.
                claimableWETHToRefund += stakeSpent[commitment.stakeAddress] - commitment.stakeSpent;
            } else {
                // Otherwise we accrue any unsettled spent stake to totalClaimableAmount
                claimableWETHToAccrue += commitment.stakeSpent - stakeSpent[commitment.stakeAddress];
            }
            stakeNonce[commitment.stakeAddress] = commitment.stakeNonce;
            stakeSpent[commitment.stakeAddress] = commitment.stakeSpent;
        }
        adjustTotalClaimableAmountByStakeSpentChange(claimableWETHToRefund, claimableWETHToAccrue);
        emit Settled(claimableWETHToRefund, claimableWETHToAccrue);
    }

    /** @notice Initiate or challenge withdrawal, which can be completed after a 7 day timelock expires.
      * @dev Used by the stake addresses to withdraw from and close the payment channel. Also used by the Coordinator to
      *      challenge a withdrawal. The most recent commitment for the payment channel that has been signed by both the
      *      stake address and the Coordinator should be used for the withdrawal. In order to prevent Keepers from
      *      immediately exiting with an old commitment, potentially taking WETH they do not own, there is a 7 day
      *      timelock on being able to complete the withdrawal. If the Coordinator has a more recent commitment, they
      *      will submit it to this function resetting the timelock.
      */
    function initiateTimelockedWithdrawal(
        StakeCommitment memory _commitment
    ) external {
        // This is to prevent people who are not the payment channel owner from initiating the withdrawal process.
        if (getCurrentWithdrawalTimelock(_commitment.stakeAddress) == 0) {
            require(msg.sender == _commitment.stakeAddress, "only stakeAddress can start the withdrawal process");
        }
        require(_commitment.stakeSpent <= stakedAmount[_commitment.stakeAddress], "cannot spend more than is staked");
        // The stakeNonce may have been seen in settleSpentStake so we must allow >= to here.
        // Note this means a malicious or compromised Coordinator has the ability to indefinitely reset the timelock.
        // This is fine since we can just change the Coordinator address.
        require(_commitment.stakeNonce >= stakeNonce[_commitment.stakeAddress], "stake nonce is too old");
        require(_commitment.channelNonce == channelNonce[_commitment.stakeAddress], "incorrect channel nonce");
        require(msg.sender == _commitment.stakeAddress || msg.sender == coordinator, 
            "only callable by stakeAdddress or coordinator");
        
        address recoveredStakeAddress = ECDSA.recover(
            ECDSA.toEthSignedMessageHash(stakeCommitmentHash(_commitment)), 
            _commitment.stakeAddressSignature);
        require(recoveredStakeAddress == _commitment.stakeAddress, "recovered address is not the stake address");
        address recoveredCoordinatorAddress =  ECDSA.recover(
            ECDSA.toEthSignedMessageHash(stakeCommitmentHash(_commitment)), 
            _commitment.coordinatorSignature);
        require(recoveredCoordinatorAddress == coordinator, "recovered address is not the coordinator");

        adjustTotalClaimableAmountByStakeSpentChange(stakeSpent[_commitment.stakeAddress], _commitment.stakeSpent);
        stakeNonce[_commitment.stakeAddress] = _commitment.stakeNonce;
        stakeSpent[_commitment.stakeAddress] = _commitment.stakeSpent;

        // Initiate the timelock
        withdrawalTimelockTimestamp[
            withdrawalTimelockKey(
                _commitment.stakeAddress, 
                _commitment.stakeSpent, 
                _commitment.stakeNonce, 
                _commitment.channelNonce
            )] = block.timestamp + 7 days;

        emit TimelockedWithdrawalInitiated(
            _commitment.stakeAddress, 
            _commitment.stakeSpent, 
            _commitment.stakeNonce, 
            _commitment.channelNonce, 
            block.timestamp + 7 days);
    }

    /** @notice Withdraw remaining stake from the payment channel after the withdrawal timelock has concluded.
      * @dev Closing the payment channel zeros out all payment channel state for the stake address aside from the
      *      channelNonce which is incremented. This is to prevent any channel reuse edge cases. A stake address that
      *      has closed their payment channel and withdrawn is able to create a new payment channel by staking WETH. 
      */
    function executeTimelockedWithdrawal(
        address _stakeAddress
    ) public {
        uint256 _channelNonce = channelNonce[_stakeAddress];
        require(getCurrentWithdrawalTimelock(_stakeAddress) > 0, "must initiate timelocked withdrawal first");
        require(block.timestamp > getCurrentWithdrawalTimelock(_stakeAddress), "still in withdrawal timelock");
        
        uint256 withdrawalAmount = stakedAmount[_stakeAddress] - stakeSpent[_stakeAddress];
        stakeNonce[_stakeAddress] = 0;
        stakeSpent[_stakeAddress] = 0;
        stakedAmount[_stakeAddress] = 0;
        channelNonce[_stakeAddress] += 1;

        WETH.safeTransfer(_stakeAddress, withdrawalAmount);

        emit StakeWithdrawn(_stakeAddress, _channelNonce, withdrawalAmount);
    }

    /** @notice Instantly withdraw remaining stake in payment channel.
      * @dev To perform an instant withdrawal a Keeper will ask the coordinator for an instant withdrawal signature. 
      *      This `data` field in the commitment used to produce the signature should be populated with 
      *      `INSTANT_WITHDRAWAL_COMMITMENT_DATA`. We don't want a compromised Coordinator to instantly settle the 
      *      channel with an old commitment, so we also require a stakeAddress instant withdrawal signature.
      *      Closing the payment channel zeros out all payment channel state for the stake address aside from the
      *      channelNonce which is incremented. This is to prevent any channel reuse edge cases. A stake address that
      *      has closed their payment channel and withdrawn is able to create a new payment channel by staking WETH.
      */
    function executeInstantWithdrawal(
        StakeCommitment memory _commitment
    ) external {
        require(msg.sender == _commitment.stakeAddress, "only stakeAddress can perform instant withdrawal");
        require(_commitment.stakeSpent <= stakedAmount[_commitment.stakeAddress], "cannot spend more than is staked");
        // The stakeNonce may have been seen in settleSpentStake so we must allow >= to here.
        // Note this means a malicious or compromised Coordinator has the ability to indefinitely reset the timelock.
        // This is fine since we can just change the Coordinator address.
        require(_commitment.stakeNonce >= stakeNonce[_commitment.stakeAddress], "stake nonce is too old");
        require(_commitment.channelNonce == channelNonce[_commitment.stakeAddress], "incorrect channel nonce");
        require(keccak256(_commitment.data) == keccak256(INSTANT_WITHDRAWAL_COMMITMENT_DATA), "incorrect data payload");

        address recoveredStakeAddress =  ECDSA.recover(
            ECDSA.toEthSignedMessageHash(stakeCommitmentHash(_commitment)),
            _commitment.stakeAddressSignature);
        require(recoveredStakeAddress == _commitment.stakeAddress, "recovered address is not the stake address");
        address recoveredCoordinatorAddress =  ECDSA.recover(
            ECDSA.toEthSignedMessageHash(stakeCommitmentHash(_commitment)),
            _commitment.coordinatorSignature);
        require(recoveredCoordinatorAddress == coordinator, "recovered address is not the coordinator");

        adjustTotalClaimableAmountByStakeSpentChange(stakeSpent[_commitment.stakeAddress], _commitment.stakeSpent);
        uint256 withdrawalAmount = stakedAmount[_commitment.stakeAddress] - _commitment.stakeSpent;
        stakeNonce[_commitment.stakeAddress] = 0;
        stakeSpent[_commitment.stakeAddress] = 0;
        stakedAmount[_commitment.stakeAddress] = 0;
        channelNonce[_commitment.stakeAddress] += 1;

        WETH.safeTransfer(_commitment.stakeAddress, withdrawalAmount);

        emit StakeWithdrawn(_commitment.stakeAddress, _commitment.channelNonce, withdrawalAmount);
    }


    /** @notice Claim accumulated earnings. Claim amounts are determined off-chain and signed by the claimGenerator
      *         address. Claim amounts are calculated as a pre-determined percentage of a Keeper's bid, and Keeper bids
      *         are signed by both Keepers and the Coordinator, so claim amount correctness is easily verifiable
      *         off-chain by consumers even if it is not verified on-chain.
      * @dev Note that it is not feasible to verify claim amount correctness on-chain as the total claim amount for
      *      a user can be the sum of claims generated from any number of bid commitments. Claimers only rely on the
      *      claim generator to calculate the claim as a percentage of Keeper bids correctly and this is easily
      *      verifiable by consumers off-chain given the signed bid commitments are public.
      *      A user has claimable WETH if the Claim Generator has generated a commitment for them where `earningsToDate`
      *      is greater than `userClaimedAmount[_claimAddress]`.
      */
    function claim(
        address _claimAddress,
        uint256 _earningsToDate,
        bytes memory _claimGeneratorSignature
    ) external {
        processClaim(
            _claimAddress,
            _earningsToDate,
            _claimGeneratorSignature,
            false
        );
    }

    /** @notice Claim accumulated earnings, and unwrap to ETH. Claim amounts are determined off-chain and signed by the claimGenerator
      *         address. Claim amounts are calculated as a pre-determined percentage of a Keeper's bid, and Keeper bids
      *         are signed by both Keepers and the Coordinator, so claim amount correctness is easily verifiable
      *         off-chain by consumers even if it is not verified on-chain.
      * @dev Note that it is not feasible to verify claim amount correctness on-chain as the total claim amount for
      *      a user can be the sum of claims generated from any number of bid commitments. Claimers only rely on the
      *      claim generator to calculate the claim as a percentage of Keeper bids correctly and this is easily
      *      verifiable by consumers off-chain given the signed bid commitments are public.
      *      A user has claimable WETH if the Claim Generator has generated a commitment for them where `earningsToDate`
      *      is greater than `userClaimedAmount[_claimAddress]`.
      */
    function claimAndUnwrap(
        address _claimAddress,
        uint256 _earningsToDate,
        bytes memory _claimGeneratorSignature
    ) external {
        processClaim(
            _claimAddress,
            _earningsToDate,
            _claimGeneratorSignature,
            true
        );
    }

    /** @notice Claim accumulated earnings. Claim amounts are determined off-chain and signed by the claimGenerator
      *         address. Claim amounts are calculated as a pre-determined percentage of a Keeper's bid, and Keeper bids
      *         are signed by both Keepers and the Coordinator, so claim amount correctness is easily verifiable
      *         off-chain by consumers even if it is not verified on-chain.
      * @dev Note that it is not feasible to verify claim amount correctness on-chain as the total claim amount for
      *      a user can be the sum of claims generated from any number of bid commitments. Claimers only rely on the
      *      claim generator to calculate the claim as a percentage of Keeper bids correctly and this is easily
      *      verifiable by consumers off-chain given the signed bid commitments are public.
      *      A user has claimable WETH if the Claim Generator has generated a commitment for them where `earningsToDate`
      *      is greater than `userClaimedAmount[_claimAddress]`.
      */
    function processClaim(
        address _claimAddress,
        uint256 _earningsToDate,
        bytes memory _claimGeneratorSignature,
        bool unwrap
    ) internal {
        require(_earningsToDate > userClaimedAmount[_claimAddress], "nothing to claim");

        // Validate the signature
        address recoveredClaimGeneratorAddress = ECDSA.recover(
            ECDSA.toEthSignedMessageHash(claimCommitmentHash(_claimAddress, _earningsToDate)),
            _claimGeneratorSignature);
        require(recoveredClaimGeneratorAddress == claimGenerator, "recoveredClaimGeneratorAddress is not the account manager");

        // Calculate the claimAmount
        uint256 claimAmount = _earningsToDate - userClaimedAmount[_claimAddress];
        require(claimAmount <= totalClaimableAmount, "claim amount exceeds balance on contract");
        userClaimedAmount[_claimAddress] = _earningsToDate;
        totalClaimableAmount -= claimAmount;

        // Transfer the earnings to _claimAddress
        if (unwrap) {
            IWETH(address(WETH)).withdraw(claimAmount);
            (bool sent, bytes memory data) = _claimAddress.call{value: claimAmount}("");
            require(sent, "Failed to send Ether");
        } else {
            WETH.safeTransfer(_claimAddress, claimAmount);
        }

        emit Claimed(_claimAddress, claimAmount);
    }
}