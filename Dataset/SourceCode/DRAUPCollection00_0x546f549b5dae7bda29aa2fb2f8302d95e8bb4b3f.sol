// SPDX-License-Identifier: MIT
//
// This software is developed by DRAUP, Inc. "DRAUP" is a trademark of DRAUP, Inc.
// in the United States and other countries. Nothing herein grants you any rights in
// or to DRAUP, Inc.'s trade names or trademarks, all of which are expressly
// reserved to DRAUP, Inc.
//
//
//
//                            DRAUP COLLECTION 00
//
//                          DRAUP X NICOLAS SASSOON
//
//                              SEEN ON SCREEN
//
//
//                                                           .,,
//                                                           ;░░▒▒
//                                                           ;░φφ░╚╠
//                                                       .░φ░░░░Γ╙╙
//                                                       '░░░░
//                                                           ░░░░
//                                                           ¡░░░░
//                                                           ¡░░░░
//                                                           ¡░░░¡░
//                                                           :░░▒░!-
//                                                           ¡░¡░▒░│-
//                                                       .│''░▒░┐'░
//                                                       ;''¡░╠▒░.'░
//                                                   .,,;'''¡░╠╠░░. ┌
//                                               .░░░░░░┐..¡¡░╠╠▒░┐ '.
//                                               .░│¡░░░░░░░¡░░░▒╠▒░░. '~
//                                               ;│.¡░░░░░░░░░░░░▒╠╠░░' .
//                                           ;░┌¡░░░░░░░░░░░░▒╠╠╠░░'.░⌐
//                                             ;░.¡░░φ▒▒▒▒▒░░░░▒▒╠╬▒░░\░░
//                                           ;░┐¡░φ╠╠╬╬╠╠▒▒▒▒▒╠╠╬╠▒░░░░
//                                       .░░.░φ▒╠╬╬╬╣╣╣╬╬╠╠╠╠╬╬▒░░░░
//                                       .░░│░░▒╠╠╠╠╬╬╬▓██▓▓╬╬╬╬▒░░░░
//                                       ░░░░φ▒╩╚╩╚╚Γ└''└│╙╙╚╩╩╩╚╙Γ"
//                                   .\¡░φ▒░░░░░░░       ''''''
//                                   ¡¡░▒░░░│││¡└
//                                   .¡░░░░░│'''¡'
//                               .░░░░░░░░┐''│¡~
//                       .,░φ░░░░░░░░░░░░░│..'!░
//                   .░░░░░░░░░░░░░░░░░░░░░░┐. !-
//                   ;░░φ▒▒▒▒░░░░░░░░░░░░░░░░░░░┐.'-
//               .░░φ▒▒▒▒░░░░░░▒▒▒▒╠╠╠▒▒▒▒▒▒▒φ░░░¡░.
//               .░░▒╠╠▒░░░░░░░░▒╠╠╩╩╩╩╩╩╬╬╣╣╣▓╣╬▒▒φ░░;
//               .¡░▒╠╠▒░░░░░░░░░░Γ░└'''''''""╙╙╩╬╬╬╬╣╣╬▒φ░»,
//               :░φ╠╬▒▒░░░░░░░░░░             '''!╙╚╩╠╠╠╠╠╠╠▒φφφ░,
//               :░▒╬╬▒▒░░░░░░░░'                   '!░░░╠╠╠╠╠╠╠▒▒▒░░░.
//               :░╠╬╬▒▒░░░░░░░'                     .░░░▒▒╠╠╠╠▒▒▒▒▒▒░░░.
//               '░╚╬╬▒▒░░░░░░                     .≥░░░▒▒▒▒▒▒▒▒▒▒▒▒▒░░░┐-
//               !░╠╬▒▒░░░░░                  ,;φ░░░░▒▒▒▒▒▒▒▒▒▒▒╠╠▒▒▒░░░┌.
//               ^░╠╬╠▒▒░░░               ,φ░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒╠╠╠▒▒▒░░░│¡
//               !╚╬╬▒▒░▒░            »░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒╠╠╠╠╠▒▒▒░░░░░
//               '░╠╬▒▒▒▒░         ,φ░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒╠╠╠╠╠╠╠╠╠▒▒░░░░░
//                   '╚╠▒▒▒▒░       ;░░░▒▒▒╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠▒▒░░░░░
//                   ░╠▒▒▒▒▒░  .,φφ▒▒▒╠╠╠╬╬╬╬╬╬╬╬╬╬╬╬╠╠╠╬╬╬╬╬╬╬╬╬╬╠╠▒▒░░░░
//                   ]╠▒▒▒▒▒▒▒╠╠╠╠╠╠╠╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╠▒▒░░░'
//                   ]╠▒▒▒▒▒▒▒╠╠╠╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╠▒▒▒░'
//                   !╠╠▒▒▒▒▒▒╠╠╠╠╬╬╬╬╬╬╬╬╬╬╬╬╬╬╣▓▓▓▓▓▓▓▓▓▓▓▓╬╬╬╬╬╬╠╠╩░'
//                   '╙╬╬▒▒▒▒▒╠╠╠╠╠╠╬╬╬╬╬╬╬╬╬╬╬╬╣▓▓▓▓▓▓▓▓▓▓▓▓▓▓╬╬╬╬╩Γ"
//                   '!╚╣╬╬╠╠╠╠╠╠╠╬╬╬╬╬╬╬╬╬╬╬╬╬╬╣▓▓▓▓▓▓▓▓▓▓▓▓╬╬╩╙░'
//                       '░╚╣▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╣▓▓▓▓▀╩╩╙╙░└''
//                       '!╙╩╣▓▓╣╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╩╙░"''
//                           '!╙╚╬▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╩╙Γ"'
//
//
//
pragma solidity ~0.8.18;
import {Ownable} from "openzeppelin-contracts/contracts/access/Ownable.sol";
import {IERC2981, IERC165} from "openzeppelin-contracts/contracts/interfaces/IERC2981.sol";
import {ECDSA} from "openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol";
import {IERC20} from "openzeppelin-contracts/contracts/token/ERC20/IERC20.sol";
import {ERC721A} from "erc721a/contracts/ERC721A.sol";
import {IRenderer} from "./IRenderer.sol";
import {PaddedString} from "draup-utils/src/PaddedString.sol";
import {DefaultOperatorFilterer} from "operator-filter-registry/src/DefaultOperatorFilterer.sol";
import "forge-std/console2.sol";

// define constants for the item types
uint constant COAT_ITEM_TYPE = 0;
uint constant DRESS_ITEM_TYPE = 1;
uint constant PANTS_ITEM_TYPE = 2;
uint constant TOP_ITEM_TYPE = 3;
uint constant HAT_ITEM_TYPE = 4;

// define constants for checking mint transaction validity
uint8 constant SUCCESS_MINT_ALLOWED = 0;
uint8 constant ERR_ALLOWLIST_SIGNATURE_INVALID = 1;
uint8 constant ERR_INSUFFICIENT_FUNDS = 2;
uint8 constant ERR_INSUFFICIENT_ITEM_SUPPLY = 3;
uint8 constant ERR_CANNOT_MINT_ITEM_TYPE = 4;
uint8 constant ERR_MAX_MINTS_REACHED = 5;

// define constants for mint process
uint constant MINT_NOT_STARTED = 0;
uint constant MINT_IN_PROGRESS = 1;
uint constant MINT_FINISHED = 2;

contract DRAUPCollection00 is ERC721A, Ownable, DefaultOperatorFilterer {
    using ECDSA for bytes32;
    // ERC4906 events
    event MetadataUpdate(uint256 _tokenId);
    event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);

    // minting
    uint[5] private _maxSupplies;
    uint[5] private _currentSupplies;
    uint[5] private _mintPrices;
    uint immutable public _maxMintsPerCustomer;
    mapping (address => uint) private _mintCounts;
    uint public mintingStatus;

    // management
    address public signer;
    address public revenueWallet;

    // tokens
    IRenderer public renderer;
    string public baseTokenURI;
    mapping(uint => uint) private _tokenItemTypes;
    mapping(uint => bytes32) private _tokenSeeds;

    constructor(uint[5] memory setSupply, uint[5] memory setMintPrices, string memory initialBaseURI, address initialSigner, uint maxMints) ERC721A("DRAUP COLLECTION 00", "DRAUP:00") {
        _maxSupplies = setSupply;
        _mintPrices = setMintPrices;
        baseTokenURI = initialBaseURI;
        signer = initialSigner;
        _maxMintsPerCustomer = maxMints;
    }

    error CannotTransferToNull();

    // supported interfaces IERC2981 and IERC4906
        function supportsInterface(bytes4 _interfaceId)
        public
        view
        override
        returns (bool)
    {
        return
            _interfaceId == type(IERC2981).interfaceId ||
            _interfaceId == bytes4(0x49064906) ||
            super.supportsInterface(_interfaceId);
    }


    // Token Info

    function getMaxSupply() public view returns (uint) {
        return _maxSupplies[0] + _maxSupplies[1] + _maxSupplies[2] + _maxSupplies[3] + _maxSupplies[4];
    }

    function itemSupplyInfo() public view returns (uint[5] memory itemSupplies, uint[5] memory itemMaxSupplies, uint[5] memory itemMintPrices) {
        for (uint i = 0; i < 5; i++) {
            itemSupplies[i] = _currentSupplies[i];
            itemMaxSupplies[i] = _maxSupplies[i];
            itemMintPrices[i] = _mintPrices[i];
        }
    }

    function tokenInfo(uint tokenId) public view returns (uint itemType, bytes32 seed) {
        itemType = _tokenItemTypes[tokenId];
        seed = _tokenSeeds[tokenId];
    }

    function tokenInfos(uint start, uint end) public view returns (uint[] memory itemTypes, bytes32[] memory seeds) {
        if (end == 0) {
            end = _nextTokenId();
        }
        require(start < end, "start must be less than end");
        itemTypes = new uint[](end-start);
        seeds = new bytes32[](end-start);
        for (uint i = start; i < end; i++) {
            itemTypes[i-start] = _tokenItemTypes[i];
            seeds[i-start] = _tokenSeeds[i];
        }
    }

    // Returns an array of token IDs and an array of tokens item types owned by `owner`.
    // from ERC721AQueryable with additional info about item type
    function tokensOfOwner(address owner) public view returns (uint256[] memory tokenIds, uint[] memory tokenItemTypes, string[] memory tokenURIs) {
        unchecked {
            uint256 tokenIdsIdx;
            address currOwnershipAddr;
            uint256 tokenIdsLength = balanceOf(owner);
            uint256[] memory foundTokenIds = new uint256[](tokenIdsLength);
            uint256[] memory foundTokenTypes = new uint256[](tokenIdsLength);
            string[] memory foundTokenURIs = new string[](tokenIdsLength);
            TokenOwnership memory ownership;
            for (uint256 i = _startTokenId(); tokenIdsIdx != tokenIdsLength; ++i) {
                ownership = _ownershipAt(i);
                if (ownership.burned) {
                    continue;
                }
                if (ownership.addr != address(0)) {
                    currOwnershipAddr = ownership.addr;
                }
                if (currOwnershipAddr == owner) {
                    foundTokenIds[tokenIdsIdx++] = i;
                    foundTokenTypes[tokenIdsIdx-1] = _tokenItemTypes[i];
                    foundTokenURIs[tokenIdsIdx-1] = tokenURI(i);
                }
            }
            tokenIds = foundTokenIds;
            tokenItemTypes = foundTokenTypes;
            tokenURIs = foundTokenURIs;
        }
    }

    // upgradeable token renderer from https://github.com/holic/web3-scaffold/
    function tokenURI(uint256 tokenId)
        public
        view
        override
        returns (string memory)
    {
        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();
        if (address(renderer) != address(0)) {
            return renderer.tokenURI(tokenId);
        }
        return
            string(
                abi.encodePacked(
                    baseTokenURI,
                    PaddedString.digitsToString(tokenId, 3),
                    "/item_",
                    PaddedString.digitsToString(tokenId, 3),
                    "_metadata_",
                    PaddedString.digitsToString(_tokenItemTypes[tokenId], 1),
                    ".json"
                )
            );
    }

    // Allow List

    function isValidSignature(address addr, bytes calldata signature) public view returns (bool isValid) {
        bytes32 digest = keccak256(
            abi.encodePacked(
                "\x19Ethereum Signed Message:\n32",
                keccak256(abi.encode(addr))
            )
        );
        isValid = signer == digest.recover(signature);
    }


    // Minting

    error MintingNotActive();
    error MintValidationFailure(uint errorCode);

    function mintingIsActive() public view returns (bool) {
        return mintingStatus == MINT_IN_PROGRESS;
    }

    modifier onlyDuringMinting() {
        if (!mintingIsActive()) {
            revert MintingNotActive();
        }
        _;
    }

    function validateMintOrder(uint itemType, address minter) public view returns (uint) {
        if (itemType == 0 || itemType > 4) {
            return ERR_CANNOT_MINT_ITEM_TYPE;
        }
        if (_maxSupplies[itemType] - _currentSupplies[itemType] < 1) {
            return ERR_INSUFFICIENT_ITEM_SUPPLY;
        }
        if (_mintCounts[minter] >= _maxMintsPerCustomer) {
            return ERR_MAX_MINTS_REACHED;
        }
        return SUCCESS_MINT_ALLOWED;
    }

    // hero pieces minted by DRAUP using short form generative techniques
    function mintCoats(address to, bytes32[] calldata seeds) public onlyOwner {
        if (to == address(0)) {
            revert CannotTransferToNull();
        }
        uint startTokenId = _nextTokenId();
        uint itemType = COAT_ITEM_TYPE;
        if (seeds.length > (_maxSupplies[itemType] - _currentSupplies[itemType])) {
            revert MintValidationFailure(ERR_INSUFFICIENT_ITEM_SUPPLY);
        }
        _currentSupplies[itemType] += seeds.length;
        for (uint i=0; i<seeds.length; i++) {
            _mint(to, 1);
            // item type is 0
            _tokenSeeds[startTokenId+i] = seeds[i];
        }
    }

    // main collection pieces minted by public using long form generative techniques
    function mintItem(uint itemType, bytes calldata signature) public payable onlyDuringMinting {
        // validate mint order
        uint mintOrderStatus = validateMintOrder(itemType, msg.sender);
        if (mintOrderStatus != SUCCESS_MINT_ALLOWED) {
            revert MintValidationFailure(mintOrderStatus);
        }
        if (!isValidSignature(msg.sender, signature)) {
            revert MintValidationFailure(ERR_ALLOWLIST_SIGNATURE_INVALID);
        }
        if (msg.value < _mintPrices[itemType]) {
            revert MintValidationFailure(ERR_INSUFFICIENT_FUNDS);
        }
        _mintCounts[msg.sender] += 1;
        _mintItemOfType(msg.sender, itemType);
    }

    // admin minting for team and artist pieces
    function adminMintItem(address to, uint itemType) public onlyOwner {
        // validate mint order
        uint mintOrderStatus = validateMintOrder(itemType, msg.sender);
        if (mintOrderStatus != SUCCESS_MINT_ALLOWED) {
            revert MintValidationFailure(mintOrderStatus);
        }
        _mintItemOfType(to, itemType);
    }

    function _mintItemOfType(address recipient, uint itemType) private {
        // mint token
        uint upcomingTokenId = _nextTokenId();
        // note: using block.prevrandao but Forge currently does not support EVM's past London
        bytes32 seed = keccak256(abi.encodePacked(upcomingTokenId, block.difficulty, blockhash(block.number - 1), msg.sender));
        _currentSupplies[itemType] += 1;
        _tokenItemTypes[upcomingTokenId] = itemType;
        _tokenSeeds[upcomingTokenId] = seed;
        _mint(recipient, 1);
    }

    // Royalty info provided via EIP-2981
    // https://eips.ethereum.org/EIPS/eip-2981
    function royaltyInfo(uint256, uint256 salePrice)
        external
        view
        returns (address, uint256)
    {
        return (address(this), (salePrice * 750) / 10000);
    }

    // Transfers, secondary trading, and on-chain royalty enforcement integration

    function setApprovalForAll(address operator, bool approved) public override onlyAllowedOperatorApproval(operator) {
        super.setApprovalForAll(operator, approved);
    }

    function approve(address operator, uint tokenId) public override payable onlyAllowedOperatorApproval(operator) {
        super.approve(operator, tokenId);
    }

    function transferFrom(address from, address to, uint tokenId) public override payable onlyAllowedOperator(from) {
        super.transferFrom(from, to, tokenId);
    }

    function safeTransferFrom(address from, address to, uint tokenId) public override payable onlyAllowedOperator(from) {
        super.safeTransferFrom(from, to, tokenId);
    }

    function safeTransferFrom(address from, address to, uint tokenId, bytes memory data)
        public
        override
        payable
        onlyAllowedOperator(from)
    {
        super.safeTransferFrom(from, to, tokenId, data);
    }


    // Admin actions

    error AdminActionFailure();

    function setSigner(address _signer) public onlyOwner {
        signer = _signer;
    }

    function setRevenueWallet(address _revenueWallet) public onlyOwner {
        revenueWallet = _revenueWallet;
    }

    function startMinting() public onlyOwner {
        if (mintingStatus == MINT_FINISHED) {
            revert AdminActionFailure();
        }
        mintingStatus = MINT_IN_PROGRESS;
    }

    function pauseMinting() public onlyOwner {
        if (mintingStatus == MINT_FINISHED) {
            revert AdminActionFailure();
        }
        mintingStatus = MINT_NOT_STARTED;
    }

    function finishMinting() public onlyOwner {
        mintingStatus = MINT_FINISHED;
    }

    function setRenderer(IRenderer _renderer) external onlyOwner {
        renderer = _renderer;
    }

    function setBaseURI(string memory newBaseURI) public onlyOwner {
        baseTokenURI = newBaseURI;
    }

    function publishMetadataUpdated(uint tokenId) public onlyOwner {
        emit MetadataUpdate(tokenId);
    }

    function publishBatchMetadataUpdated(uint fromTokenId, uint toTokenId) public onlyOwner {
        emit BatchMetadataUpdate(fromTokenId, toTokenId);
    }

    // Financial Operations

    error ZeroAmountFailure();

    receive() external payable {}

    function processCurrentBalance() external {
        if (address(this).balance == 0) {
            revert ZeroAmountFailure();
        }
        if (revenueWallet == address(0)) {
            revert CannotTransferToNull();
        }
        (bool sent, ) = revenueWallet.call{value: address(this).balance}("");
        if (!sent) {
            revert AdminActionFailure();
        }
    }

    function withdrawAllERC20(IERC20 token) external {
        token.transfer(revenueWallet, token.balanceOf(address(this)));
    }

}