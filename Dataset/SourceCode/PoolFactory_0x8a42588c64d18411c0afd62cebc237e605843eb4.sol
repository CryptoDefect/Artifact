{{

  "language": "Solidity",

  "sources": {

    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"

    },

    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"

    },

    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"

    },

    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/Address.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"

    },

    "contracts/interfaces/IConfiguration.sol": {

      "content": "/*\nIConfiguration\n\nhttps://github.com/gysr-io/core\n\nSPDX-License-Identifier: MIT\n*/\n\npragma solidity 0.8.18;\n\n/**\n * @title Configuration interface\n *\n * @notice this defines the protocol configuration interface\n */\ninterface IConfiguration {\n    // events\n    event ParameterUpdated(bytes32 indexed key, address value);\n    event ParameterUpdated(bytes32 indexed key, uint256 value);\n    event ParameterUpdated(bytes32 indexed key, address value0, uint96 value1);\n    event ParameterOverridden(\n        address indexed caller,\n        bytes32 indexed key,\n        address value\n    );\n    event ParameterOverridden(\n        address indexed caller,\n        bytes32 indexed key,\n        uint256 value\n    );\n    event ParameterOverridden(\n        address indexed caller,\n        bytes32 indexed key,\n        address value0,\n        uint96 value1\n    );\n\n    /**\n     * @notice set or update uint256 parameter\n     * @param key keccak256 hash of parameter key\n     * @param value uint256 parameter value\n     */\n    function setUint256(bytes32 key, uint256 value) external;\n\n    /**\n     * @notice set or update address parameter\n     * @param key keccak256 hash of parameter key\n     * @param value address parameter value\n     */\n    function setAddress(bytes32 key, address value) external;\n\n    /**\n     * @notice set or update packed address + uint96 pair\n     * @param key keccak256 hash of parameter key\n     * @param value0 address parameter value\n     * @param value1 uint96 parameter value\n     */\n    function setAddressUint96(\n        bytes32 key,\n        address value0,\n        uint96 value1\n    ) external;\n\n    /**\n     * @notice get uint256 parameter\n     * @param key keccak256 hash of parameter key\n     * @return uint256 parameter value\n     */\n    function getUint256(bytes32 key) external view returns (uint256);\n\n    /**\n     * @notice get address parameter\n     * @param key keccak256 hash of parameter key\n     * @return uint256 parameter value\n     */\n    function getAddress(bytes32 key) external view returns (address);\n\n    /**\n     * @notice get packed address + uint96 pair\n     * @param key keccak256 hash of parameter key\n     * @return address parameter value\n     * @return uint96 parameter value\n     */\n    function getAddressUint96(\n        bytes32 key\n    ) external view returns (address, uint96);\n\n    /**\n     * @notice override uint256 parameter for specific caller\n     * @param caller address of caller\n     * @param key keccak256 hash of parameter key\n     * @param value uint256 parameter value\n     */\n    function overrideUint256(\n        address caller,\n        bytes32 key,\n        uint256 value\n    ) external;\n\n    /**\n     * @notice override address parameter for specific caller\n     * @param caller address of caller\n     * @param key keccak256 hash of parameter key\n     * @param value address parameter value\n     */\n    function overrideAddress(\n        address caller,\n        bytes32 key,\n        address value\n    ) external;\n\n    /**\n     * @notice override address parameter for specific caller\n     * @param caller address of caller\n     * @param key keccak256 hash of parameter key\n     * @param value0 address parameter value\n     * @param value1 uint96 parameter value\n     */\n    function overrideAddressUint96(\n        address caller,\n        bytes32 key,\n        address value0,\n        uint96 value1\n    ) external;\n}\n"

    },

    "contracts/interfaces/IEvents.sol": {

      "content": "/*\nIEvents\n\nhttps://github.com/gysr-io/core\n\nSPDX-License-Identifier: MIT\n */\n\npragma solidity 0.8.18;\n\n/**\n * @title GYSR event system\n *\n * @notice common interface to define GYSR event system\n */\ninterface IEvents {\n    // staking\n    event Staked(\n        bytes32 indexed account,\n        address indexed user,\n        address indexed token,\n        uint256 amount,\n        uint256 shares\n    );\n    event Unstaked(\n        bytes32 indexed account,\n        address indexed user,\n        address indexed token,\n        uint256 amount,\n        uint256 shares\n    );\n    event Claimed(\n        bytes32 indexed account,\n        address indexed user,\n        address indexed token,\n        uint256 amount,\n        uint256 shares\n    );\n    event Updated(bytes32 indexed account, address indexed user);\n\n    // rewards\n    event RewardsDistributed(\n        address indexed user,\n        address indexed token,\n        uint256 amount,\n        uint256 shares\n    );\n    event RewardsFunded(\n        address indexed token,\n        uint256 amount,\n        uint256 shares,\n        uint256 timestamp\n    );\n    event RewardsExpired(\n        address indexed token,\n        uint256 amount,\n        uint256 shares,\n        uint256 timestamp\n    );\n    event RewardsWithdrawn(\n        address indexed token,\n        uint256 amount,\n        uint256 shares,\n        uint256 timestamp\n    );\n    event RewardsUpdated(bytes32 indexed account);\n\n    // gysr\n    event GysrSpent(address indexed user, uint256 amount);\n    event GysrVested(address indexed user, uint256 amount);\n    event GysrWithdrawn(uint256 amount);\n    event Fee(address indexed receiver, address indexed token, uint256 amount);\n}\n"

    },

    "contracts/interfaces/IModuleFactory.sol": {

      "content": "/*\nIModuleFactory\n\nhttps://github.com/gysr-io/core\n\nSPDX-License-Identifier: MIT\n*/\n\npragma solidity 0.8.18;\n\n/**\n * @title Module factory interface\n *\n * @notice this defines the common module factory interface used by the\n * main factory to create the staking and reward modules for a new Pool.\n */\ninterface IModuleFactory {\n    // events\n    event ModuleCreated(address indexed user, address module);\n\n    /**\n     * @notice create a new Pool module\n     * @param config address for configuration contract\n     * @param data binary encoded construction parameters\n     * @return address of newly created module\n     */\n    function createModule(address config, bytes calldata data)\n        external\n        returns (address);\n}\n"

    },

    "contracts/interfaces/IOwnerController.sol": {

      "content": "/*\nIOwnerController\n\nhttps://github.com/gysr-io/core\n\nSPDX-License-Identifier: MIT\n*/\n\npragma solidity 0.8.18;\n\n/**\n * @title Owner controller interface\n *\n * @notice this defines the interface for any contracts that use the\n * owner controller access pattern\n */\ninterface IOwnerController {\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() external view returns (address);\n\n    /**\n     * @dev Returns the address of the current controller.\n     */\n    function controller() external view returns (address);\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`). This can\n     * include renouncing ownership by transferring to the zero address.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) external;\n\n    /**\n     * @dev Transfers control of the contract to a new account (`newController`).\n     * Can only be called by the owner.\n     */\n    function transferControl(address newController) external;\n}\n"

    },

    "contracts/interfaces/IPool.sol": {

      "content": "/*\nIPool\n\nhttps://github.com/gysr-io/core\n\nSPDX-License-Identifier: MIT\n*/\n\npragma solidity 0.8.18;\n\n/**\n * @title Pool interface\n *\n * @notice this defines the core Pool contract interface\n */\ninterface IPool {\n    /**\n     * @return staking tokens for Pool\n     */\n    function stakingTokens() external view returns (address[] memory);\n\n    /**\n     * @return reward tokens for Pool\n     */\n    function rewardTokens() external view returns (address[] memory);\n\n    /**\n     * @return staking balances for user\n     */\n    function stakingBalances(\n        address user\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @return total staking balances for Pool\n     */\n    function stakingTotals() external view returns (uint256[] memory);\n\n    /**\n     * @return reward balances for Pool\n     */\n    function rewardBalances() external view returns (uint256[] memory);\n\n    /**\n     * @return GYSR usage ratio for Pool\n     */\n    function usage() external view returns (uint256);\n\n    /**\n     * @return address of staking module\n     */\n    function stakingModule() external view returns (address);\n\n    /**\n     * @return address of reward module\n     */\n    function rewardModule() external view returns (address);\n\n    /**\n     * @notice stake asset and begin earning rewards\n     * @param amount number of tokens to stake\n     * @param stakingdata data passed to staking module\n     * @param rewarddata data passed to reward module\n     */\n    function stake(\n        uint256 amount,\n        bytes calldata stakingdata,\n        bytes calldata rewarddata\n    ) external;\n\n    /**\n     * @notice unstake asset and claim rewards\n     * @param amount number of tokens to unstake\n     * @param stakingdata data passed to staking module\n     * @param rewarddata data passed to reward module\n     */\n    function unstake(\n        uint256 amount,\n        bytes calldata stakingdata,\n        bytes calldata rewarddata\n    ) external;\n\n    /**\n     * @notice claim rewards without unstaking\n     * @param amount number of tokens to claim against\n     * @param stakingdata data passed to staking module\n     * @param rewarddata data passed to reward module\n     */\n    function claim(\n        uint256 amount,\n        bytes calldata stakingdata,\n        bytes calldata rewarddata\n    ) external;\n\n    /**\n     * @notice method called ad hoc to update user accounting\n     * @param stakingdata data passed to staking module\n     * @param rewarddata data passed to reward module\n     */\n    function update(\n        bytes calldata stakingdata,\n        bytes calldata rewarddata\n    ) external;\n\n    /**\n     * @notice method called ad hoc to clean up and perform additional accounting\n     * @param stakingdata data passed to staking module\n     * @param rewarddata data passed to reward module\n     */\n    function clean(\n        bytes calldata stakingdata,\n        bytes calldata rewarddata\n    ) external;\n\n    /**\n     * @return gysr balance available for withdrawal\n     */\n    function gysrBalance() external view returns (uint256);\n\n    /**\n     * @notice withdraw GYSR tokens applied during unstaking\n     * @param amount number of GYSR to withdraw\n     */\n    function withdraw(uint256 amount) external;\n\n    /**\n     * @notice transfer control of the staking module to another account\n     * @param newController address of new controller\n     */\n    function transferControlStakingModule(address newController) external;\n\n    /**\n     * @notice transfer control of the reward module to another account\n     * @param newController address of new controller\n     */\n    function transferControlRewardModule(address newController) external;\n\n    /**\n     * @notice execute multiple operations in a single call\n     * @param data array of encoded function data\n     */\n    function multicall(\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n}\n"

    },

    "contracts/interfaces/IPoolFactory.sol": {

      "content": "/*\nIPoolFactory\n\nhttps://github.com/gysr-io/core\n\nSPDX-License-Identifier: MIT\n*/\n\npragma solidity 0.8.18;\n\n/**\n * @title Pool factory interface\n *\n * @notice this defines the Pool factory interface, primarily intended for\n * the Pool contract to interact with\n */\ninterface IPoolFactory {\n    /**\n     * @notice create a new Pool\n     * @param staking address of factory that will be used to create staking module\n     * @param reward address of factory that will be used to create reward module\n     * @param stakingdata construction data for staking module factory\n     * @param rewarddata construction data for reward module factory\n     * @return address of newly created Pool\n     */\n    function create(\n        address staking,\n        address reward,\n        bytes calldata stakingdata,\n        bytes calldata rewarddata\n    ) external returns (address);\n\n    /**\n     * @return true if address is a pool created by the factory\n     */\n    function map(address) external view returns (bool);\n\n    /**\n     * @return address of the nth pool created by the factory\n     */\n    function list(uint256) external view returns (address);\n}\n"

    },

    "contracts/interfaces/IRewardModule.sol": {

      "content": "/*\nIRewardModule\n\nhttps://github.com/gysr-io/core\n\nSPDX-License-Identifier: MIT\n*/\n\npragma solidity 0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./IEvents.sol\";\nimport \"./IOwnerController.sol\";\n\n/**\n * @title Reward module interface\n *\n * @notice this contract defines the common interface that any reward module\n * must implement to be compatible with the modular Pool architecture.\n */\ninterface IRewardModule is IOwnerController, IEvents {\n    /**\n     * @return array of reward tokens\n     */\n    function tokens() external view returns (address[] memory);\n\n    /**\n     * @return array of reward token balances\n     */\n    function balances() external view returns (uint256[] memory);\n\n    /**\n     * @return GYSR usage ratio for reward module\n     */\n    function usage() external view returns (uint256);\n\n    /**\n     * @return address of module factory\n     */\n    function factory() external view returns (address);\n\n    /**\n     * @notice perform any necessary accounting for new stake\n     * @param account bytes32 id of staking account\n     * @param sender address of sender\n     * @param shares number of new shares minted\n     * @param data addtional data\n     * @return amount of gysr spent\n     * @return amount of gysr vested\n     */\n    function stake(\n        bytes32 account,\n        address sender,\n        uint256 shares,\n        bytes calldata data\n    ) external returns (uint256, uint256);\n\n    /**\n     * @notice reward user and perform any necessary accounting for unstake\n     * @param account bytes32 id of staking account\n     * @param sender address of sender\n     * @param receiver address of reward receiver\n     * @param shares number of shares burned\n     * @param data additional data\n     * @return amount of gysr spent\n     * @return amount of gysr vested\n     */\n    function unstake(\n        bytes32 account,\n        address sender,\n        address receiver,\n        uint256 shares,\n        bytes calldata data\n    ) external returns (uint256, uint256);\n\n    /**\n     * @notice reward user and perform and necessary accounting for existing stake\n     * @param account bytes32 id of staking account\n     * @param sender address of sender\n     * @param receiver address of reward receiver\n     * @param shares number of shares being claimed against\n     * @param data additional data\n     * @return amount of gysr spent\n     * @return amount of gysr vested\n     */\n    function claim(\n        bytes32 account,\n        address sender,\n        address receiver,\n        uint256 shares,\n        bytes calldata data\n    ) external returns (uint256, uint256);\n\n    /**\n     * @notice method called by anyone to update accounting\n     * @dev will only be called ad hoc and should not contain essential logic\n     * @param account bytes32 id of staking account for update\n     * @param sender address of sender\n     * @param data additional data\n     */\n    function update(\n        bytes32 account,\n        address sender,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @notice method called by owner to clean up and perform additional accounting\n     * @dev will only be called ad hoc and should not contain any essential logic\n     * @param data additional data\n     */\n    function clean(bytes calldata data) external;\n}\n"

    },

    "contracts/interfaces/IStakingModule.sol": {

      "content": "/*\nIStakingModule\n\nhttps://github.com/gysr-io/core\n\nSPDX-License-Identifier: MIT\n*/\n\npragma solidity 0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./IEvents.sol\";\nimport \"./IOwnerController.sol\";\n\n/**\n * @title Staking module interface\n *\n * @notice this contract defines the common interface that any staking module\n * must implement to be compatible with the modular Pool architecture.\n */\ninterface IStakingModule is IOwnerController, IEvents {\n    /**\n     * @return array of staking tokens\n     */\n    function tokens() external view returns (address[] memory);\n\n    /**\n     * @notice get balance of user\n     * @param user address of user\n     * @return balances of each staking token\n     */\n    function balances(address user) external view returns (uint256[] memory);\n\n    /**\n     * @return address of module factory\n     */\n    function factory() external view returns (address);\n\n    /**\n     * @notice get total staked amount\n     * @return totals for each staking token\n     */\n    function totals() external view returns (uint256[] memory);\n\n    /**\n     * @notice stake an amount of tokens for user\n     * @param sender address of sender\n     * @param amount number of tokens to stake\n     * @param data additional data\n     * @return bytes32 id of staking account\n     * @return number of shares minted for stake\n     */\n    function stake(\n        address sender,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bytes32, uint256);\n\n    /**\n     * @notice unstake an amount of tokens for user\n     * @param sender address of sender\n     * @param amount number of tokens to unstake\n     * @param data additional data\n     * @return bytes32 id of staking account\n     * @return address of reward receiver\n     * @return number of shares burned for unstake\n     */\n    function unstake(\n        address sender,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bytes32, address, uint256);\n\n    /**\n     * @notice quote the share value for an amount of tokens without unstaking\n     * @param sender address of sender\n     * @param amount number of tokens to claim with\n     * @param data additional data\n     * @return bytes32 id of staking account\n     * @return address of reward receiver\n     * @return number of shares that the claim amount is worth\n     */\n    function claim(\n        address sender,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bytes32, address, uint256);\n\n    /**\n     * @notice method called by anyone to update accounting\n     * @dev will only be called ad hoc and should not contain essential logic\n     * @param sender address of user for update\n     * @param data additional data\n     * @return bytes32 id of staking account\n     */\n    function update(\n        address sender,\n        bytes calldata data\n    ) external returns (bytes32);\n\n    /**\n     * @notice method called by owner to clean up and perform additional accounting\n     * @dev will only be called ad hoc and should not contain any essential logic\n     * @param data additional data\n     */\n    function clean(bytes calldata data) external;\n}\n"

    },

    "contracts/OwnerController.sol": {

      "content": "/*\nOwnerController\n\nhttps://github.com/gysr-io/core\n\nSPDX-License-Identifier: MIT\n*/\n\npragma solidity 0.8.18;\n\nimport \"./interfaces/IOwnerController.sol\";\n\n/**\n * @title Owner controller\n *\n * @notice this base contract implements an owner-controller access model.\n *\n * @dev the contract is an adapted version of the OpenZeppelin Ownable contract.\n * It allows the owner to designate an additional account as the controller to\n * perform restricted operations.\n *\n * Other changes include supporting role verification with a require method\n * in addition to the modifier option, and removing some unneeded functionality.\n *\n * Original contract here:\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\n */\ncontract OwnerController is IOwnerController {\n    address private _owner;\n    address private _controller;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    event ControlTransferred(\n        address indexed previousController,\n        address indexed newController\n    );\n\n    constructor() {\n        _owner = msg.sender;\n        _controller = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n        emit ControlTransferred(address(0), _owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view override returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Returns the address of the current controller.\n     */\n    function controller() public view override returns (address) {\n        return _controller;\n    }\n\n    /**\n     * @dev Modifier that throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"oc1\");\n        _;\n    }\n\n    /**\n     * @dev Modifier that throws if called by any account other than the controller.\n     */\n    modifier onlyController() {\n        require(_controller == msg.sender, \"oc2\");\n        _;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    function requireOwner() internal view {\n        require(_owner == msg.sender, \"oc1\");\n    }\n\n    /**\n     * @dev Throws if called by any account other than the controller.\n     */\n    function requireController() internal view {\n        require(_controller == msg.sender, \"oc2\");\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override {\n        requireOwner();\n        require(newOwner != address(0), \"oc3\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n\n    /**\n     * @dev Transfers control of the contract to a new account (`newController`).\n     * Can only be called by the owner.\n     */\n    function transferControl(address newController) public virtual override {\n        requireOwner();\n        require(newController != address(0), \"oc4\");\n        emit ControlTransferred(_controller, newController);\n        _controller = newController;\n    }\n}\n"

    },

    "contracts/Pool.sol": {

      "content": "/*\nPool\n\nhttps://github.com/gysr-io/core\n\nSPDX-License-Identifier: MIT\n*/\n\npragma solidity 0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"./interfaces/IPool.sol\";\nimport \"./interfaces/IConfiguration.sol\";\nimport \"./interfaces/IStakingModule.sol\";\nimport \"./interfaces/IRewardModule.sol\";\nimport \"./interfaces/IEvents.sol\";\nimport \"./OwnerController.sol\";\n\n/**\n * @title Pool\n *\n * @notice this implements the GYSR core Pool contract. It supports generalized\n * incentive mechanisms through a modular architecture, where\n * staking and reward logic is contained in child contracts.\n */\ncontract Pool is IPool, IEvents, ReentrancyGuard, OwnerController {\n    using SafeERC20 for IERC20;\n\n    // modules\n    IStakingModule private immutable _staking;\n    IRewardModule private immutable _reward;\n\n    // gysr fields\n    IERC20 private immutable _gysr;\n    IConfiguration private immutable _config;\n    uint256 private _gysrVested;\n\n    /**\n     * @param staking_ the staking module address\n     * @param reward_ the reward module address\n     * @param gysr_ address for GYSR token\n     * @param config_ address for configuration contract\n     */\n    constructor(\n        address staking_,\n        address reward_,\n        address gysr_,\n        address config_\n    ) {\n        _staking = IStakingModule(staking_);\n        _reward = IRewardModule(reward_);\n        _gysr = IERC20(gysr_);\n        _config = IConfiguration(config_);\n    }\n\n    // -- IPool --------------------------------------------------------------\n\n    /**\n     * @inheritdoc IPool\n     */\n    function stakingTokens() external view override returns (address[] memory) {\n        return _staking.tokens();\n    }\n\n    /**\n     * @inheritdoc IPool\n     */\n    function rewardTokens() external view override returns (address[] memory) {\n        return _reward.tokens();\n    }\n\n    /**\n     * @inheritdoc IPool\n     */\n    function stakingBalances(\n        address user\n    ) external view override returns (uint256[] memory) {\n        return _staking.balances(user);\n    }\n\n    /**\n     * @inheritdoc IPool\n     */\n    function stakingTotals() external view override returns (uint256[] memory) {\n        return _staking.totals();\n    }\n\n    /**\n     * @inheritdoc IPool\n     */\n    function rewardBalances()\n        external\n        view\n        override\n        returns (uint256[] memory)\n    {\n        return _reward.balances();\n    }\n\n    /**\n     * @inheritdoc IPool\n     */\n    function usage() external view override returns (uint256) {\n        return _reward.usage();\n    }\n\n    /**\n     * @inheritdoc IPool\n     */\n    function stakingModule() external view override returns (address) {\n        return address(_staking);\n    }\n\n    /**\n     * @inheritdoc IPool\n     */\n    function rewardModule() external view override returns (address) {\n        return address(_reward);\n    }\n\n    /**\n     * @inheritdoc IPool\n     */\n    function stake(\n        uint256 amount,\n        bytes calldata stakingdata,\n        bytes calldata rewarddata\n    ) external override nonReentrant {\n        (bytes32 account, uint256 shares) = _staking.stake(\n            msg.sender,\n            amount,\n            stakingdata\n        );\n        (uint256 spent, uint256 vested) = _reward.stake(\n            account,\n            msg.sender,\n            shares,\n            rewarddata\n        );\n        _processGysr(spent, vested);\n    }\n\n    /**\n     * @inheritdoc IPool\n     */\n    function unstake(\n        uint256 amount,\n        bytes calldata stakingdata,\n        bytes calldata rewarddata\n    ) external override nonReentrant {\n        (bytes32 account, address receiver, uint256 shares) = _staking.unstake(\n            msg.sender,\n            amount,\n            stakingdata\n        );\n        (uint256 spent, uint256 vested) = _reward.unstake(\n            account,\n            msg.sender,\n            receiver,\n            shares,\n            rewarddata\n        );\n        _processGysr(spent, vested);\n    }\n\n    /**\n     * @inheritdoc IPool\n     */\n    function claim(\n        uint256 amount,\n        bytes calldata stakingdata,\n        bytes calldata rewarddata\n    ) external override nonReentrant {\n        (bytes32 account, address receiver, uint256 shares) = _staking.claim(\n            msg.sender,\n            amount,\n            stakingdata\n        );\n        (uint256 spent, uint256 vested) = _reward.claim(\n            account,\n            msg.sender,\n            receiver,\n            shares,\n            rewarddata\n        );\n        _processGysr(spent, vested);\n    }\n\n    /**\n     * @inheritdoc IPool\n     */\n    function update(\n        bytes calldata stakingdata,\n        bytes calldata rewarddata\n    ) external override nonReentrant {\n        bytes32 account = _staking.update(msg.sender, stakingdata);\n        _reward.update(account, msg.sender, rewarddata);\n    }\n\n    /**\n     * @inheritdoc IPool\n     */\n    function clean(\n        bytes calldata stakingdata,\n        bytes calldata rewarddata\n    ) external override nonReentrant {\n        requireController();\n        _staking.clean(stakingdata);\n        _reward.clean(rewarddata);\n    }\n\n    /**\n     * @inheritdoc IPool\n     */\n    function gysrBalance() external view override returns (uint256) {\n        return _gysrVested;\n    }\n\n    /**\n     * @inheritdoc IPool\n     */\n    function withdraw(uint256 amount) external override {\n        requireController();\n        require(amount > 0, \"p1\");\n        require(amount <= _gysrVested, \"p2\");\n\n        // do transfer\n        _gysr.safeTransfer(msg.sender, amount);\n\n        _gysrVested = _gysrVested - amount;\n\n        emit GysrWithdrawn(amount);\n    }\n\n    /**\n     * @inheritdoc IPool\n     */\n    function transferControlStakingModule(\n        address newController\n    ) external override {\n        requireOwner();\n        _staking.transferControl(newController);\n    }\n\n    /**\n     * @inheritdoc IPool\n     */\n    function transferControlRewardModule(\n        address newController\n    ) external override {\n        requireOwner();\n        _reward.transferControl(newController);\n    }\n\n    /**\n     * @inheritdoc IPool\n     */\n    function multicall(\n        bytes[] calldata data\n    ) external override returns (bytes[] memory results) {\n        // h/t https://github.com/Uniswap/v3-periphery/blob/main/contracts/base/Multicall.sol\n        results = new bytes[](data.length);\n        for (uint256 i; i < data.length; ++i) {\n            (bool success, bytes memory result) = address(this).delegatecall(\n                data[i]\n            );\n            if (!success) {\n                // h/t https://ethereum.stackexchange.com/a/83577\n                if (result.length < 68) revert();\n                assembly {\n                    result := add(result, 0x04)\n                }\n                revert(abi.decode(result, (string)));\n            }\n            results[i] = result;\n        }\n    }\n\n    // -- Pool internal -----------------------------------------------------\n\n    /**\n     * @dev private method to process GYSR spending and vesting\n     * @param spent number of tokens spent by user\n     * @param vested number of tokens vested\n     */\n    function _processGysr(uint256 spent, uint256 vested) private {\n        // spending\n        if (spent > 0) {\n            _gysr.safeTransferFrom(msg.sender, address(this), spent);\n        }\n\n        // vesting\n        if (vested > 0) {\n            (address receiver, uint256 rate) = _config.getAddressUint96(\n                keccak256(\"gysr.core.pool.spend.fee\")\n            );\n\n            // fallback to zero fee on bad configuration\n            uint256 fee;\n            if (rate > 0 && rate <= 1e18 && receiver != address(0)) {\n                fee = (vested * rate) / 1e18;\n                _gysr.safeTransfer(receiver, fee);\n                emit Fee(receiver, address(_gysr), fee);\n            }\n            _gysrVested = _gysrVested + vested - fee;\n        }\n    }\n}\n"

    },

    "contracts/PoolFactory.sol": {

      "content": "/*\nPoolFactory\n\nhttps://github.com/gysr-io/core\n\nSPDX-License-Identifier: MIT\n*/\n\npragma solidity 0.8.18;\n\nimport \"./interfaces/IPoolFactory.sol\";\nimport \"./interfaces/IModuleFactory.sol\";\nimport \"./interfaces/IStakingModule.sol\";\nimport \"./interfaces/IRewardModule.sol\";\nimport \"./OwnerController.sol\";\nimport \"./Pool.sol\";\n\n/**\n * @title Pool factory\n *\n * @notice this implements the Pool factory contract which allows any user to\n * easily configure and deploy their own Pool\n *\n * @dev it relies on a system of sub-factories which are responsible for the\n * creation of underlying staking and reward modules. This primary factory\n * calls each module factory and assembles the overall Pool contract.\n *\n * this contract also manages the module factory whitelist.\n */\ncontract PoolFactory is IPoolFactory, OwnerController {\n    // events\n    event PoolCreated(address indexed user, address pool);\n    event WhitelistUpdated(\n        address indexed factory,\n        uint256 previous,\n        uint256 updated\n    );\n\n    // types\n    enum ModuleFactoryType {\n        Unknown,\n        Staking,\n        Reward\n    }\n\n    // fields\n    mapping(address => bool) public override map;\n    address[] public override list;\n    address private immutable _gysr;\n    address private immutable _config;\n    mapping(address => ModuleFactoryType) public whitelist;\n\n    /**\n     * @param gysr_ address of GYSR token\n     * @param config_ address of configuration contract\n     */\n    constructor(address gysr_, address config_) {\n        _gysr = gysr_;\n        _config = config_;\n    }\n\n    /**\n     * @inheritdoc IPoolFactory\n     */\n    function create(\n        address staking,\n        address reward,\n        bytes calldata stakingdata,\n        bytes calldata rewarddata\n    ) external override returns (address) {\n        // validate\n        require(whitelist[staking] == ModuleFactoryType.Staking, \"f1\");\n        require(whitelist[reward] == ModuleFactoryType.Reward, \"f2\");\n\n        // create modules\n        address stakingModule = IModuleFactory(staking).createModule(\n            _config,\n            stakingdata\n        );\n        address rewardModule = IModuleFactory(reward).createModule(\n            _config,\n            rewarddata\n        );\n\n        // create pool\n        Pool pool = new Pool(stakingModule, rewardModule, _gysr, _config);\n\n        // set access\n        IStakingModule(stakingModule).transferOwnership(address(pool));\n        IRewardModule(rewardModule).transferOwnership(address(pool));\n        pool.transferControl(msg.sender);\n        pool.transferControlStakingModule(msg.sender);\n        pool.transferControlRewardModule(msg.sender);\n        pool.transferOwnership(msg.sender);\n\n        // bookkeeping\n        map[address(pool)] = true;\n        list.push(address(pool));\n\n        // output\n        emit PoolCreated(msg.sender, address(pool));\n        return address(pool);\n    }\n\n    /**\n     * @notice set the whitelist status of a module factory\n     * @param factory_ address of module factory\n     * @param type_ updated whitelist status for module\n     */\n    function setWhitelist(address factory_, uint256 type_) external {\n        requireController();\n        require(type_ <= uint256(ModuleFactoryType.Reward), \"f4\");\n        require(factory_ != address(0), \"f5\");\n        emit WhitelistUpdated(factory_, uint256(whitelist[factory_]), type_);\n        whitelist[factory_] = ModuleFactoryType(type_);\n    }\n\n    /**\n     * @return total number of Pools created by the factory\n     */\n    function count() public view returns (uint256) {\n        return list.length;\n    }\n}\n"

    }

  },

  "settings": {

    "optimizer": {

      "enabled": true,

      "runs": 10000

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "libraries": {}

  }

}}