{"ARC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IARC20Factory {\n    function parameters() external view returns (string memory name, string memory symbol, uint8 decimals);\n}\ncontract ARC20 {\n    string public name;\n    string public symbol;\n    uint8 public immutable decimals;\n    address public immutable factory;\n    uint256  public totalSupply;\n    mapping (address =\u003e uint256) public balanceOf;\n    mapping (address =\u003e mapping(address =\u003e uint256)) public allowance;\n    mapping (address =\u003e uint256) public nonces;\n\n    bytes32 public DOMAIN_SEPARATOR;\n    bytes32 public constant PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    constructor() {\n        (name, symbol, decimals) = IARC20Factory(msg.sender).parameters();\n\n        factory = msg.sender;\n\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), keccak256(bytes(\u00271\u0027)), chainId, address(this)));\n    }\n\n    function mint(address to, uint256 amount) external {\n        require(msg.sender == factory, \"unauthorized\");\n        _mint(to, amount);\n    }\n\n    function burn(uint256 amount) external {\n        require(msg.sender == factory, \"unauthorized\");\n        _burn(msg.sender, amount);\n    }\n\n    function approve(address spender, uint256 amount) external returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) external returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 amount) external returns (bool) {\n        uint256 allowed = allowance[from][msg.sender];\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n        return true;\n    }\n\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external {\n        require(deadline \u003e= block.timestamp, \u0027EXPIRED\u0027);\n        unchecked {\n            bytes32 digest = keccak256(\n                abi.encodePacked(\n                    \u0027\\x19\\x01\u0027,\n                    DOMAIN_SEPARATOR,\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n                )\n            );\n            address recoveredAddress = ecrecover(digest, v, r, s);\n            require(recoveredAddress != address(0) \u0026\u0026 recoveredAddress == owner, \u0027INVALID_SIGNATURE\u0027);\n            allowance[recoveredAddress][spender] = value;\n        }\n        emit Approval(owner, spender, value);\n    }\n\n    function _mint(address to, uint256 amount) internal {\n        totalSupply += amount;\n\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal {\n        balanceOf[from] -= amount;\n\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}"},"factory.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./ARC20.sol\";\n\n\ncontract ARC20Factory  {\n\n    bytes32 private constant DOMAIN_NAME = keccak256(\"ARC20Bridge\");\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n    bytes32 public constant MINT_TYPEHASH = keccak256(abi.encodePacked(\"Mint(address token,address to,uint256 amount,string utxoid)\"));\n    bytes32 public DOMAIN_SEPARATOR;\n\n    struct Parameters {\n        string name;\n        string symbol;\n        uint8 decimals;\n    }\n\n    bool private entered;\n    Parameters public parameters;\n    address public owner;\n    uint256 public fee;\n    address[] public signers;\n    mapping (address =\u003e bool) public authorized;\n    mapping (address =\u003e uint256) public indexes;\n    mapping (bytes32 =\u003e bool) public used;\n\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\n\n    event FeeChanged(uint256 indexed oldFee, uint256 indexed newFee);\n\n    event ARC20Created(address indexed sender, address indexed dog20);\n\n    event Minted(address indexed token, address indexed to, uint256 indexed amount, string utxoid);\n\n    event Burned(address indexed token, address indexed from, uint256 indexed amount, uint256 fee, string receiver);\n\n    event SignerAdded(address indexed sender, address indexed account);\n\n    event SignerRemoved(address indexed sender, address indexed account);\n\n    modifier nonReentrant() {\n        require(!entered, \"REENTRANT\");\n        entered = true;\n        _;\n        entered = false;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n        _;\n    }\n\n    constructor(address[] memory _signers) {\n        for (uint256 i = 0; i \u003c _signers.length; i++) {\n            address _addr = _signers[i];\n            signers.push(_addr);\n            authorized[_addr] = true;\n            indexes[_addr] = i;\n        }\n\n        owner = msg.sender;\n        emit OwnerChanged(address(0), msg.sender);\n\n        fee = 0.01 ether;\n\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(abi.encode(DOMAIN_TYPEHASH, DOMAIN_NAME, keccak256(bytes(\u00271\u0027)), chainId, address(this)));\n    }\n\n    function createARC20(string memory name, string memory symbol, uint8 decimals) external onlyOwner returns (address newARC20Address) {\n        parameters = Parameters({name: name, symbol: symbol, decimals: decimals});\n        newARC20Address = address(new ARC20{salt: keccak256(abi.encode(name, symbol, decimals))}());\n        delete parameters;\n        emit ARC20Created(msg.sender, newARC20Address);\n    }\n\n    function mint(address token, address to, uint256 amount, string memory utxoid, uint8[] memory v, bytes32[] memory r, bytes32[] memory s) external nonReentrant {\n        require(v.length == signers.length, \"invalid signatures\");\n\n        bytes32 digest = buildMintSeparator(token, to, amount, utxoid);\n        require(!used[digest], \"reuse\");\n        used[digest] = true;\n\n        address[] memory signatures = new address[](v.length);\n        for (uint256 i = 0; i \u003c v.length; i++) {\n            address signer = ecrecover(digest, v[i], r[i], s[i]);\n            require(authorized[signer], \"invalid signer\");\n            for (uint256 j = 0; j \u003c i; j++) {\n                require(signatures[j] != signer, \"duplicated\");\n            }\n            signatures[i] = signer;\n        }\n\n        ARC20(token).mint(to, amount);\n\n        emit Minted(token, to, amount, utxoid);\n    }\n\n    function burn(address token, uint256 amount, string memory receiver) external payable nonReentrant {\n        require(msg.value \u003e= fee, \"invalid ether\");\n\n        ARC20(token).transferFrom(msg.sender, address(this), amount);\n        ARC20(token).burn(amount);\n\n        emit Burned(token, msg.sender, amount, fee, receiver);\n    }\n\n    function withdraw(address to) external onlyOwner {\n        uint256 balance = address(this).balance;\n        payable(to).transfer(balance);\n    }\n\n    function setOwner(address _owner) external onlyOwner {\n        emit OwnerChanged(owner, _owner);\n        owner = _owner;\n    }\n\n    function setFee(uint256 _fee) external onlyOwner {\n        emit FeeChanged(fee, _fee);\n        fee = _fee;\n    }\n\n    function addSigner(address account) external onlyOwner {\n        require(!authorized[account], \"already exists\");\n\n        indexes[account] = signers.length;\n        authorized[account] = true;\n        signers.push(account);\n\n        emit SignerAdded(msg.sender, account);\n    }\n\n    function removeSigner(address account) external onlyOwner {\n        require(authorized[account], \"non-existent\");\n        require(indexes[account] \u003c signers.length, \"index out of range\");\n\n        uint256 index = indexes[account];\n        uint256 lastIndex = signers.length - 1;\n\n        if (index != lastIndex) {\n            address lastAddr = signers[lastIndex];\n            signers[index] = lastAddr;\n            indexes[lastAddr] = index;\n        }\n\n        delete authorized[account];\n        delete indexes[account];\n        signers.pop();\n\n        emit SignerRemoved(msg.sender, account);\n    }\n\n    function buildMintSeparator(address token, address to, uint256 amount, string memory utxoid) view public returns (bytes32) {\n        return keccak256(abi.encodePacked(\n            \u0027\\x19\\x01\u0027,\n            DOMAIN_SEPARATOR,\n            keccak256(abi.encode(MINT_TYPEHASH, token, to, amount, keccak256(bytes(utxoid))))\n        ));\n    }\n}"}}