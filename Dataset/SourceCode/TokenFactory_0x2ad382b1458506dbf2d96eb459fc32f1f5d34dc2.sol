{{

  "language": "Solidity",

  "sources": {

    "src/contracts/TokenFactory.sol": {

      "content": "// SPDX-License-Identifier: BUSL-1.1\n// omnisea-contracts v0.1\n\npragma solidity ^0.8.7;\n\nimport \"../interfaces/IOmniERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IOmniApp.sol\";\nimport \"../interfaces/IOmnichainRouter.sol\";\nimport { MintParams, Asset } from \"../structs/erc721/ERC721Structs.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/**\n * @title TokenFactory\n * @author Omnisea\n * @custom:version 1.0\n * @notice TokenFactory is ERC721 minting service.\n *         Contract is responsible for validating and executing the function that creates (mints) a NFT.\n *         Enables delegation of cross-chain minting via Omnichain Router which abstracts underlying cross-chain messaging.\n *         messaging protocols such as LayerZero and Axelar Network.\n *         It is designed to avoid burn & mint mechanism to keep NFT's non-fungibility, on-chain history, and references to contracts.\n *         It supports cross-chain actions instead of ERC721 \"transfer\", and allows simultaneous actions from many chains,\n *         without requiring the NFT presence on the same chain as the user performing the action (e.g. mint).\n */\ncontract TokenFactory is IOmniApp, Ownable, ReentrancyGuard {\n\n    event OmReceived(string srcChain, address srcOA);\n    event Minted(address collAddr, address rec);\n    event Paid(address rec);\n    event Locked(address rec, uint256 amount, address asset);\n    event Refunded(address rec);\n    event NewRefund(address collAddr, address spender);\n\n    error InvalidPrice(address collAddr, address spender, uint256 paid);\n    error InvalidCreator(address collAddr, address cre);\n    error InvalidAsset(string collAsset, string paidAsset);\n\n    uint256 private constant ACTION_MINT = 1;\n    uint256 private constant ACTION_WITHDRAW = 2;\n\n    IOmnichainRouter public omnichainRouter;\n    mapping(address => mapping(string => mapping(address => uint256))) public refunds;\n    mapping(address => mapping(string => uint256)) public mints;\n    string public chainName;\n    mapping(string => address) public remoteChainToOA;\n    mapping(string => Asset) public assets;\n    uint256 private _fee;\n    address private _feeManager;\n    address private _redirectionsBudgetManager;\n\n    /**\n     * @notice Sets the contract owner, feeManager address, router, and indicates source chain name for mappings.\n     *\n     * @param _router A contract that handles cross-chain messaging used to extend ERC721 with omnichain capabilities.\n     */\n    constructor(IOmnichainRouter _router) {\n        chainName = \"Ethereum\";\n        _feeManager = address(0x61104fBe07ecc735D8d84422c7f045f8d29DBf15);\n        _redirectionsBudgetManager = address(0x61104fBe07ecc735D8d84422c7f045f8d29DBf15);\n        omnichainRouter = _router;\n    }\n\n    function setRouter(IOmnichainRouter _router) external onlyOwner {\n        omnichainRouter = _router;\n    }\n\n    function setFee(uint256 fee) external onlyOwner {\n        require(fee <= 5);\n        _fee = fee;\n    }\n\n    function setFeeManager(address _newManager) external onlyOwner {\n        _feeManager = _newManager;\n    }\n\n    function setRedirectionsBudgetManager(address _newManager) external onlyOwner {\n        _redirectionsBudgetManager = _newManager;\n    }\n\n    function setChainName(string memory _chainName) external onlyOwner {\n        chainName = _chainName;\n    }\n\n    /**\n     * @notice Sets the remote Omnichain Applications (\"OA\") addresses to meet omReceive() validation.\n     *\n     * @param remoteChainName Name of the remote chain.\n     * @param remoteOA Address of the remote OA.\n     */\n    function setOA(string memory remoteChainName, address remoteOA) external onlyOwner {\n        remoteChainToOA[remoteChainName] = remoteOA;\n    }\n\n    /**\n     * @notice Checks the presence of the selected remote User Application (\"OA\").\n     *\n     * @param remoteChainName Name of the remote chain.\n     * @param remoteOA Address of the remote OA.\n     */\n    function isOA(string memory remoteChainName, address remoteOA) public view returns (bool) {\n        return remoteChainToOA[remoteChainName] == remoteOA;\n    }\n\n    /**\n     * @notice Adds ERC20 (asset) support as the minting payment currency.\n     *\n     * @param asset Address of the supported ERC20.\n     * @param assetName Name of the asset used for the mapping purpose.\n     * @param decimals Token decimals.\n     */\n    function addAsset(address asset, string memory assetName, uint256 decimals) external onlyOwner {\n        require(asset != address(0));\n        assets[assetName] = Asset(IERC20(asset), decimals);\n    }\n\n    /**\n     * @notice Handles the ERC721 minting logic.\n     *         Validates data and checks if minting is allowed.\n     *         If price for mint is set, it initiates payment processing.\n     *         Delegates task to the Omnichain Router based on the varying chainName and dstChainName.\n     *\n     * @param params See MintParams struct in ERC721Structs.sol.\n     */\n    function mintToken(MintParams calldata params) public payable nonReentrant {\n        require(bytes(params.dstChainName).length > 0 && params.coll != address(0));\n        if (keccak256(bytes(params.dstChainName)) == keccak256(bytes(chainName))) {\n            IOmniERC721 omniNft = IOmniERC721(params.coll);\n            uint256 price = omniNft.mintPrice();\n            if (price > 0) {\n                processMintPayment(price, msg.sender, omniNft.creator(), false, assets[omniNft.assetName()]);\n            }\n            omniNft.mint(msg.sender);\n            emit Minted(params.coll, msg.sender);\n            return;\n        }\n        if (params.mintPrice > 0) {\n            processMintPayment(params.mintPrice, msg.sender, address(this), true, assets[params.assetName]);\n        }\n        bytes memory payload = _getMintPayload(params.coll, params.mintPrice, params.creator, params.assetName);\n        _omniAction(payload, params.dstChainName, params.gas, params.redirectFee);\n    }\n\n    /**\n     * @notice Handles the incoming tasks from other chains received from Omnichain Router.\n     *         Validates User Application.\n     *         actionType == 1: mint.\n     *         actionType != 1: withdraw (See payout / refund).\n\n     * @notice Prevents throwing supply exceeded error when mint transactions from at least 2 chains are racing.\n     *         srcChain isn't aware of supply exceeding risk when initiating a transaction because it doesn't know about\n     *         pending cross-chain transactions from other chains. If a price for mint is specified and funds were locked\n     *         on the srcChain, the minting user will be eligible for a refund (unlocking and return of the funds).\n     *         This way, it syncs the minting logic state between each chain.\n     *\n     * @param _payload Encoded MintParams data.\n     * @param srcOA Address of the remote OA.\n     * @param srcChain Name of the remote OA chain.\n     */\n    function omReceive(bytes calldata _payload, address srcOA, string memory srcChain) external override {\n        emit OmReceived(srcChain, srcOA);\n        require(isOA(srcChain, srcOA));\n        (uint256 actionType, address coll, bool minted, uint256 paid, address rec, address cre, string memory assetName) = abi.decode(_payload, (uint256, address, bool, uint256, address, address, string));\n\n        if (actionType == ACTION_WITHDRAW) {\n            withdraw(rec, cre, paid, assetName, minted);\n            return;\n        }\n        IOmniERC721 collection = IOmniERC721(coll);\n        uint256 price = collection.mintPrice();\n        uint256 supply = collection.totalSupply();\n\n        if (cre != collection.creator()) revert InvalidCreator(coll, cre);\n\n        if (price > 0) {\n            if (paid != price) revert InvalidPrice(coll, rec, paid);\n            if (keccak256(bytes(assetName)) != keccak256(bytes(collection.assetName()))) revert InvalidAsset(collection.assetName(), assetName);\n\n            if (supply > 0 && collection.tokenIds() >= supply) {\n                refunds[coll][srcChain][rec] += price;\n                emit NewRefund(coll, rec);\n                return;\n            }\n        }\n\n        collection.mint(rec);\n        mints[coll][srcChain]++;\n        emit Minted(coll, rec);\n    }\n\n    /**\n     * @notice Refund if mint failed due to supply exceeded on cross-chain mint (funds locked on dstChain).\n     *\n     * @param collectionAddress The address of the ERC721 collection.\n     * @param dstChainName Name of the remote chain.\n     * @param redirectFee Fee required to cover transaction fee on the redirectChain, if involved. OmnichainRouter-specific.\n     *        Involved during cross-chain multi-protocol routing. For example, Optimism (LayerZero) to Moonbeam (Axelar).\n     */\n    function refund(address collectionAddress, string memory dstChainName, uint256 gas, uint256 redirectFee) external payable nonReentrant {\n        IOmniERC721 collection = IOmniERC721(collectionAddress);\n        uint256 amount = refunds[collectionAddress][dstChainName][msg.sender];\n        require(collection.mintPrice() > 0 && amount > 0);\n        refunds[collectionAddress][dstChainName][msg.sender] = 0;\n        _omniAction(_getWithdrawPayload(collectionAddress, false, amount, collection.assetName()), dstChainName, gas, redirectFee);\n    }\n\n    /**\n     * @notice Payout creator earnings (funds from minting locked on dstChain).\n     *\n     * @param collectionAddress The address of the ERC721 collection.\n     * @param dstChainName Name of the remote chain.\n     * @param redirectFee Fee required to cover transaction fee on the redirectChain, if involved. OmnichainRouter-specific.\n     *        Involved during cross-chain multi-protocol routing. For example, Optimism (LayerZero) to Moonbeam (Axelar).\n     */\n    function getEarned(address collectionAddress, string memory dstChainName, uint256 gas, uint256 redirectFee) external payable nonReentrant {\n        IOmniERC721 collection = IOmniERC721(collectionAddress);\n        uint256 price = collection.mintPrice();\n        uint256 amount = mints[collectionAddress][dstChainName] * price;\n        require(price > 0 && amount > 0 && msg.sender == collection.creator());\n        mints[collectionAddress][dstChainName] = 0;\n        _omniAction(_getWithdrawPayload(collectionAddress, true, amount, collection.assetName()), dstChainName, gas, redirectFee);\n    }\n\n    function withdrawOARedirectFees() external onlyOwner {\n        omnichainRouter.withdrawOARedirectFees(_redirectionsBudgetManager);\n    }\n\n    /**\n     * @notice Delegates cross-chain task to the Omnichain Router.\n     *\n     * @param payload Data required for the task execution on the dstChain.\n     * @param dstChainName Name of the remote chain.\n     * @param gas Gas limit set for the function execution on the dstChain.\n     * @param redirectFee Fee required to cover transaction fee on the redirectChain, if involved. OmnichainRouter-specific.\n     *        Involved during cross-chain multi-protocol routing. For example, Optimism (LayerZero) to Moonbeam (Axelar).\n     */\n    function _omniAction(bytes memory payload, string memory dstChainName, uint256 gas, uint256 redirectFee) private {\n        omnichainRouter.send{value : msg.value}(dstChainName, remoteChainToOA[dstChainName], payload, gas, msg.sender, redirectFee);\n    }\n\n    /**\n     * @notice If same chain, pays creator immediately. If different chains, locks funds for future payout/refund action.\n     *\n     * @param price Price for a single ERC721 mint.\n     * @param spender The spender address.\n     * @param receiver The collection creator address.\n     * @param isLock Cross-chain minting requires locking funds for the future withdraw action.\n     * @param asset Asset used for minting.\n     */\n    function processMintPayment(uint256 price, address spender, address receiver, bool isLock, Asset memory asset) internal {\n        IERC20 token = asset.token;\n        uint256 inWei = (price * 10**asset.decimals);\n        require(token.allowance(spender, address(this)) >= inWei);\n\n        if (isLock) {\n            token.transferFrom(spender, receiver, inWei);\n            emit Locked(receiver, inWei, address(token));\n            return;\n        }\n        token.transferFrom(spender, receiver, inWei * (100 - _fee) / 100);\n        token.transferFrom(spender, _feeManager, inWei * _fee / 100);\n        emit Paid(receiver);\n    }\n\n    /**\n     * @notice Withdraws funds locked during cross-chain mint. Payout creator if minted, refund spender if failed.\n     *\n     * @param refundee The refundee address.\n     * @param creator The creator address.\n     * @param price The price for single ERC721 mint.\n     * @param assetName ERC20 minting price currency name.\n     * @param isPayout If true pay creator, if false refund spender.\n     */\n    function withdraw(address refundee, address creator, uint256 price, string memory assetName, bool isPayout) private nonReentrant {\n        Asset memory asset = assets[assetName];\n        IERC20 token = asset.token;\n        uint256 inWei = (price * 10**asset.decimals);\n\n        if (inWei == 0) {\n            return;\n        }\n\n        if (isPayout) {\n            token.transfer(creator, inWei * (100 - _fee) / 100);\n            token.transfer(_feeManager, inWei * _fee / 100);\n            emit Paid(creator);\n            return;\n        }\n        token.transfer(refundee, inWei);\n        emit Refunded(refundee);\n    }\n\n    /**\n     * @notice Encodes data for cross-chain minting execution.\n     *\n     * @param collectionAddress The collection address.\n     * @param price The price for single ERC721 mint.\n     * @param creator The creator address.\n     * @param assetName ERC20 minting price currency name.\n     */\n    function _getMintPayload(address collectionAddress, uint256 price, address creator, string memory assetName) private view returns (bytes memory) {\n        return abi.encode(ACTION_MINT, collectionAddress, true, price, msg.sender, creator, assetName);\n    }\n\n    /**\n     * @notice Encodes data for cross-chain withdraw (payout/refund) execution.\n     *\n     * @param collectionAddress The collection address.\n     * @param isPayout If true payout creator, if false refund spender.\n     * @param amount The ERC20 amount to withdraw.\n     */\n    function _getWithdrawPayload(address collectionAddress, bool isPayout, uint256 amount, string memory assetName) private view returns (bytes memory) {\n        return abi.encode(ACTION_WITHDRAW, collectionAddress, isPayout, amount, msg.sender, msg.sender, assetName);\n    }\n\n    receive() external payable {}\n}\n"

    },

    "src/interfaces/IOmniERC721.sol": {

      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity ^0.8.7;\r\n\r\ninterface IOmniERC721 {\r\n    function mint(address owner) external;\r\n    function totalSupply() external view returns (uint256);\r\n    function mintPrice() external view returns (uint256);\r\n    function tokenIds() external view returns (uint256);\r\n    function creator() external view returns (address);\r\n    function createdAt() external view returns (uint256);\r\n    function dropFrom() external view returns (uint256);\r\n    function assetName() external view returns (string memory);\r\n}"

    },

    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"

    },

    "src/interfaces/IOmniApp.sol": {

      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity ^0.8.7;\r\n\r\ninterface IOmniApp {\r\n    /**\r\n     * @notice Handles the incoming tasks from other chains received from Omnichain Router.\r\n     *\r\n     * @param _payload Encoded MintParams data.\r\n     * @param srcOA Address of the remote OA.\r\n     * @param srcChain Name of the remote OA chain.\r\n     */\r\n    function omReceive(bytes calldata _payload, address srcOA, string memory srcChain) external;\r\n}"

    },

    "src/interfaces/IOmnichainRouter.sol": {

      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity ^0.8.7;\r\n\r\ninterface IOmnichainRouter {\r\n    /**\r\n     * @notice Delegates the cross-chain task to the Omnichain Router.\r\n     *\r\n     * @param dstChainName Name of the remote chain.\r\n     * @param dstUA Address of the remote User Application (\"UA\").\r\n     * @param fnData Encoded payload with a data for a target function execution.\r\n     * @param gas Cross-chain task (tx) execution gas limit\r\n     * @param user Address of the user initiating the cross-chain task (for gas refund)\r\n     * @param redirectFee Fee required to cover transaction fee on the redirectChain, if involved. OmnichainRouter-specific.\r\n     *        Involved during cross-chain multi-protocol routing. For example, Optimism (LayerZero) to Moonbeam (Axelar).\r\n     */\r\n    function send(string memory dstChainName, address dstUA, bytes memory fnData, uint gas, address user, uint256 redirectFee) external payable;\r\n\r\n    /**\r\n     * @notice Router on source chain receives redirect fee on payable send() function call. This fee is accounted to srcUARedirectBudget.\r\n     *         here, msg.sender is that srcUA. srcUA contract should implement this function and point the address below which manages redirection budget.\r\n     *\r\n     * @param redirectionBudgetManager Address pointed by the srcUA (msg.sender) executing this function.\r\n     *        Responsible for funding srcUA redirection budget.\r\n     */\r\n    function withdrawOARedirectFees(address redirectionBudgetManager) external;\r\n}"

    },

    "src/structs/erc721/ERC721Structs.sol": {

      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity ^0.8.7;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n/**\r\n     * @notice Parameters for ERC721 collection creation.\r\n     *\r\n     * @param dstChainName Name of the destination chain.\r\n     * @param name Name of the collection.\r\n     * @param uri URI to collection's metadata.\r\n     * @param fileURI URI of the file linked with the collection.\r\n     * @param price Price for a single ERC721 mint.\r\n     * @param assetName Mapping name of the ERC20 being a currency for the minting price.\r\n     * @param from Minting start date.\r\n     * @param to Minting end date.\r\n     * @param tokensURI CID of the NFTs metadata directory.\r\n     * @param totalSupply Collection's total supply. Unlimited if 0.\r\n     * @param gas Cross-chain task (tx) execution gas limit\r\n     * @param redirectFee Fee required to cover transaction fee on the redirectChain, if involved. OmnichainRouter-specific.\r\n     *        Involved during cross-chain multi-protocol routing. For example, Optimism (LayerZero) to Moonbeam (Axelar).\r\n     */\r\nstruct CreateParams {\r\n    string dstChainName;\r\n    string name;\r\n    string uri;\r\n    uint256 price;\r\n    string assetName;\r\n    uint256 from;\r\n    uint256 to;\r\n    string tokensURI;\r\n    uint256 totalSupply;\r\n    uint gas;\r\n    uint256 redirectFee;\r\n}\r\n\r\n/**\r\n     * @notice Parameters for ERC721 mint.\r\n     *\r\n     * @param dstChainName Name of the destination (NFT's) chain.\r\n     * @param coll Address of the collection.\r\n     * @param mintPrice Price for the ERC721 mint. Used during cross-chain mint for locking purpose. Validated on the dstChain.\r\n     * @param assetName Mapping name of the ERC20 being a currency for the minting price.\r\n     * @param creator Address of the creator.\r\n     * @param gas Cross-chain task (tx) execution gas limit\r\n     * @param redirectFee Fee required to cover transaction fee on the redirectChain, if involved. OmnichainRouter-specific.\r\n     *        Involved during cross-chain multi-protocol routing. For example, Optimism (LayerZero) to Moonbeam (Axelar).\r\n     */\r\nstruct MintParams {\r\n    string dstChainName;\r\n    address coll;\r\n    uint256 mintPrice;\r\n    string assetName;\r\n    address creator;\r\n    uint256 gas;\r\n    uint256 redirectFee;\r\n}\r\n\r\n/**\r\n  * @notice Asset supported for omnichain minting.\r\n  *\r\n  * @param dstChainName Name of the destination (NFT's) chain.\r\n  * @param coll Address of the collection.\r\n*/\r\nstruct Asset {\r\n    IERC20 token;\r\n    uint256 decimals;\r\n}\r\n"

    },

    "@openzeppelin/contracts/access/Ownable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"

    },

    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/Context.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"

    }

  },

  "settings": {

    "optimizer": {

      "enabled": true,

      "runs": 1

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "libraries": {}

  }

}}