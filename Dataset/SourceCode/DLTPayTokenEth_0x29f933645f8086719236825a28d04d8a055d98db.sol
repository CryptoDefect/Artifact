{{

  "language": "Solidity",

  "sources": {

    "/contracts/DLTPayToken-Ethereum.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@arbitrum/token-bridge-contracts/contracts/tokenbridge/ethereum/gateway/L1CustomGateway.sol\";\nimport \"@arbitrum/token-bridge-contracts/contracts/tokenbridge/ethereum/gateway/L1GatewayRouter.sol\";\n\n// ---------------------------------------------------------------- //\n// Support for arbitrum\ninterface IL1CustomGateway {\n    function registerTokenToL2(\n        address _l2Address,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost,\n        address _creditBackAddress\n    ) external payable returns (uint256);\n}\n\ninterface IGatewayRouter2 {\n    function setGateway(\n        address _gateway,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost,\n        address _creditBackAddress\n    ) external payable returns (uint256);\n}\n\n// ---------------------------------------------------------------- //\n\ncontract DLTPayTokenEth is ERC20, ERC20Burnable, Pausable, AccessControl {\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n    bytes32 public constant BRIDGE_ROLE = keccak256(\"BRIDGE_ROLE\");\n    bytes32 public constant SENDER_ROLE = keccak256(\"SENDER_ROLE\");\n\n    // ---------------------------------------------------------------- //\n    // Support for arbitrum\n    address public gateway;\n    address public router;\n    bool private shouldRegisterGateway;\n\n    // ---------------------------------------------------------------- //\n    // Support for anyswap/multichain.org\n    // according to https://docs.multichain.org/developer-guide/how-to-develop-under-anyswap-erc20-standards\n    // and https://github.com/anyswap/chaindata/blob/main/AnyswapV6ERC20.sol\n    address public immutable underlying;\n\n    event LogSwapin(\n        bytes32 indexed txhash,\n        address indexed account,\n        uint amount\n    );\n    event LogSwapout(\n        address indexed account,\n        address indexed bindaddr,\n        uint amount\n    );\n\n    function mint(\n        address to,\n        uint256 amount\n    ) external onlyRole(BRIDGE_ROLE) returns (bool) {\n        _mint(to, amount);\n        return true;\n    }\n\n    function burn(\n        address from,\n        uint256 amount\n    ) external onlyRole(BRIDGE_ROLE) returns (bool) {\n        _burn(from, amount);\n        return true;\n    }\n\n    // For backwards compatibility\n    function Swapin(\n        bytes32 txhash,\n        address account,\n        uint256 amount\n    ) external onlyRole(BRIDGE_ROLE) returns (bool) {\n        _mint(account, amount);\n        emit LogSwapin(txhash, account, amount);\n        return true;\n    }\n\n    // For backwards compatibility\n    function Swapout(uint256 amount, address bindaddr) external returns (bool) {\n        require(bindaddr != address(0), \"AnyswapV6ERC20: address(0)\");\n        _burn(msg.sender, amount);\n        emit LogSwapout(msg.sender, bindaddr, amount);\n        return true;\n    }\n\n    // ---------------------------------------------------------------- //\n    // Support for arbitrum\n    /// @dev we only set shouldRegisterGateway to true when in `registerTokenOnL2`\n    function isArbitrumEnabled() external view returns (uint8) {\n        require(shouldRegisterGateway, \"NOT_EXPECTED_CALL\");\n        return uint8(0xb1);\n    }\n\n    function registerTokenOnL2(\n        address l2CustomTokenAddress,\n        uint256 maxSubmissionCostForCustomGateway,\n        uint256 maxSubmissionCostForRouter,\n        uint256 maxGasForCustomGateway,\n        uint256 maxGasForRouter,\n        uint256 gasPriceBid,\n        uint256 valueForGateway,\n        uint256 valueForRouter,\n        address creditBackAddress\n    ) public payable onlyRole(DEFAULT_ADMIN_ROLE) {\n        // we temporarily set `shouldRegisterGateway` to true for the callback in registerTokenToL2 to succeed\n        bool prev = shouldRegisterGateway;\n        shouldRegisterGateway = true;\n\n        IL1CustomGateway(gateway).registerTokenToL2{value: valueForGateway}(\n            l2CustomTokenAddress,\n            maxGasForCustomGateway,\n            gasPriceBid,\n            maxSubmissionCostForCustomGateway,\n            creditBackAddress\n        );\n\n        IGatewayRouter2(router).setGateway{value: valueForRouter}(\n            gateway,\n            maxGasForRouter,\n            gasPriceBid,\n            maxSubmissionCostForRouter,\n            creditBackAddress\n        );\n\n        shouldRegisterGateway = prev;\n    }\n\n    function bridgeMint(\n        address account,\n        uint256 amount\n    ) public onlyRole(BRIDGE_ROLE) {\n        _mint(account, amount);\n    }\n\n    function bridgeBurn(\n        address account,\n        uint256 amount\n    ) public onlyRole(BRIDGE_ROLE) {\n        _burn(account, amount);\n    }\n\n    // ---------------------------------------------------------------- //\n\n    constructor(\n        address arb_router,\n        address arb_gateway\n    ) ERC20(\"DLTPAY\", \"DLTP\") {\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(PAUSER_ROLE, msg.sender);\n        _grantRole(SENDER_ROLE, msg.sender);\n        underlying = address(0);\n        router = arb_router;\n        gateway = arb_gateway;\n        _pause();\n    }\n\n    function unpause() external onlyRole(PAUSER_ROLE) {\n        _unpause();\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override whenNotPaused {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n\n    function setArb(\n        address arb_router,\n        address arb_gateway\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        router = arb_router;\n        gateway = arb_gateway;\n    }\n\n    function senderTransfer(\n        address to,\n        uint256 amount\n    ) external onlyRole(SENDER_ROLE) whenPaused {\n        _unpause();\n        _transfer(msg.sender, to, amount);\n        _pause();\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/math/SafeMath.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/math/Math.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"

    },

    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/Strings.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/Create2.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Create2.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(\n        uint256 amount,\n        bytes32 salt,\n        bytes memory bytecode\n    ) internal returns (address addr) {\n        require(address(this).balance >= amount, \"Create2: insufficient balance\");\n        require(bytecode.length != 0, \"Create2: bytecode length is zero\");\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), \"Create2: Failed on deploy\");\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(\n        bytes32 salt,\n        bytes32 bytecodeHash,\n        address deployer\n    ) internal pure returns (address addr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40) // Get free memory pointer\n\n            // |                   | ↓ ptr ...  ↓ ptr + 0x0B (start) ...  ↓ ptr + 0x20 ...  ↓ ptr + 0x40 ...   |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\n            // | 0xFF              |            FF                                                             |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\n            // | keccak(start, 85) |            ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑ |\n\n            mstore(add(ptr, 0x40), bytecodeHash)\n            mstore(add(ptr, 0x20), salt)\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\n            mstore8(start, 0xff)\n            addr := keccak256(start, 85)\n        }\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/Context.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/Address.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"

    },

    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"

    },

    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"

    },

    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"

    },

    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n}\n"

    },

    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"

    },

    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"

    },

    "@openzeppelin/contracts/security/Pausable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"

    },

    "@openzeppelin/contracts/interfaces/IERC165.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165.sol\";\n"

    },

    "@openzeppelin/contracts/access/IAccessControl.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"

    },

    "@openzeppelin/contracts/access/AccessControl.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(account),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"

    },

    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"

    },

    "@arbitrum/token-bridge-contracts/contracts/tokenbridge/libraries/gateway/TokenGateway.sol": {

      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity >=0.6.11;\n\nimport \"./ITokenGateway.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nabstract contract TokenGateway is ITokenGateway {\n    using Address for address;\n\n    address public counterpartGateway;\n    address public router;\n\n    // This modifier is overriden in gateways to validate the message sender\n    // For L1 to L2 messages need to be validated against the aliased counterpartGateway\n    // For L2 to L1 messages need to be validated against the bridge and L2ToL1Sender\n    // prettier-ignore\n    modifier onlyCounterpartGateway() virtual;\n\n    function _initialize(address _counterpartGateway, address _router) internal virtual {\n        // This initializes internal variables of the abstract contract it can be chained together with other functions.\n        // It is virtual so subclasses can override or wrap around this logic.\n        // An example where this is useful is different subclasses that validate the router address differently\n        require(_counterpartGateway != address(0), \"INVALID_COUNTERPART\");\n        require(counterpartGateway == address(0), \"ALREADY_INIT\");\n        counterpartGateway = _counterpartGateway;\n        router = _router;\n    }\n\n    function isRouter(address _target) internal view returns (bool isTargetRouter) {\n        return _target == router;\n    }\n\n    /**\n     * @notice Calculate the address used when bridging an ERC20 token\n     * @dev the L1 and L2 address oracles may not always be in sync.\n     * For example, a custom token may have been registered but not deploy or the contract self destructed.\n     * @param l1ERC20 address of L1 token\n     * @return L2 address of a bridged ERC20 token\n     */\n    function calculateL2TokenAddress(address l1ERC20)\n        public\n        view\n        virtual\n        override\n        returns (address);\n}\n"

    },

    "@arbitrum/token-bridge-contracts/contracts/tokenbridge/libraries/gateway/ITokenGateway.sol": {

      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.6.9 <0.9.0;\n\ninterface ITokenGateway {\n    /// @notice event deprecated in favor of DepositInitiated and WithdrawalInitiated\n    // event OutboundTransferInitiated(\n    //     address token,\n    //     address indexed _from,\n    //     address indexed _to,\n    //     uint256 indexed _transferId,\n    //     uint256 _amount,\n    //     bytes _data\n    // );\n\n    /// @notice event deprecated in favor of DepositFinalized and WithdrawalFinalized\n    // event InboundTransferFinalized(\n    //     address token,\n    //     address indexed _from,\n    //     address indexed _to,\n    //     uint256 indexed _transferId,\n    //     uint256 _amount,\n    //     bytes _data\n    // );\n\n    function outboundTransfer(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) external payable returns (bytes memory);\n\n    function finalizeInboundTransfer(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable;\n\n    /**\n     * @notice Calculate the address used when bridging an ERC20 token\n     * @dev the L1 and L2 address oracles may not always be in sync.\n     * For example, a custom token may have been registered but not deploy or the contract self destructed.\n     * @param l1ERC20 address of L1 token\n     * @return L2 address of a bridged ERC20 token\n     */\n    function calculateL2TokenAddress(address l1ERC20) external view returns (address);\n\n    function getOutboundCalldata(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _data\n    ) external view returns (bytes memory);\n}\n"

    },

    "@arbitrum/token-bridge-contracts/contracts/tokenbridge/libraries/gateway/IGatewayRouter.sol": {

      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity >=0.6.11;\n\nimport \"../ProxyUtil.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"./TokenGateway.sol\";\nimport \"./GatewayMessageHandler.sol\";\n\n/**\n * @title Common interface for L1 and L2 Gateway Routers\n */\ninterface IGatewayRouter is ITokenGateway {\n    function defaultGateway() external view returns (address gateway);\n\n    event TransferRouted(\n        address indexed token,\n        address indexed _userFrom,\n        address indexed _userTo,\n        address gateway\n    );\n\n    event GatewaySet(address indexed l1Token, address indexed gateway);\n    event DefaultGatewayUpdated(address newDefaultGateway);\n\n    function getGateway(address _token) external view returns (address gateway);\n}\n"

    },

    "@arbitrum/token-bridge-contracts/contracts/tokenbridge/libraries/gateway/ICustomGateway.sol": {

      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.6.9 <0.9.0;\n\n// import \"./ITokenGateway.sol\";\n\ninterface ICustomGateway {\n    function l1ToL2Token(address _l1Token) external view returns (address _l2Token);\n\n    event TokenSet(address indexed l1Address, address indexed l2Address);\n}\n"

    },

    "@arbitrum/token-bridge-contracts/contracts/tokenbridge/libraries/gateway/GatewayRouter.sol": {

      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity >=0.6.11;\n\nimport \"../ProxyUtil.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"./TokenGateway.sol\";\nimport \"./GatewayMessageHandler.sol\";\nimport \"./IGatewayRouter.sol\";\n\n/**\n * @title Common interface for L1 and L2 Gateway Routers\n */\nabstract contract GatewayRouter is TokenGateway, IGatewayRouter {\n    using Address for address;\n\n    address internal constant ZERO_ADDR = address(0);\n    address internal constant DISABLED = address(1);\n\n    mapping(address => address) public l1TokenToGateway;\n    address public override defaultGateway;\n\n    function postUpgradeInit() external view {\n        // it is assumed the L2 Arbitrum Gateway contract is behind a Proxy controlled by a proxy admin\n        // this function can only be called by the proxy admin contract\n        address proxyAdmin = ProxyUtil.getProxyAdmin();\n        require(msg.sender == proxyAdmin, \"NOT_FROM_ADMIN\");\n        // this has no other logic since the current upgrade doesn't require this logic\n    }\n\n    function _initialize(\n        address _counterpartGateway,\n        address _router,\n        address _defaultGateway\n    ) internal {\n        // if you are a router, you can't have a router\n        require(_router == address(0), \"BAD_ROUTER\");\n        TokenGateway._initialize(_counterpartGateway, _router);\n        // default gateway can have 0 address\n        defaultGateway = _defaultGateway;\n    }\n\n    function finalizeInboundTransfer(\n        address, /* _token */\n        address, /* _from */\n        address, /* _to */\n        uint256, /* _amount */\n        bytes calldata /* _data */\n    ) external payable virtual override {\n        revert(\"ONLY_OUTBOUND_ROUTER\");\n    }\n\n    function outboundTransfer(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) public payable virtual override returns (bytes memory) {\n        // this function is kept instead of delegating to outboundTransferCustomRefund to allow\n        // compatibility with older gateways that did not implement outboundTransferCustomRefund\n        address gateway = getGateway(_token);\n        bytes memory gatewayData = GatewayMessageHandler.encodeFromRouterToGateway(\n            msg.sender,\n            _data\n        );\n\n        emit TransferRouted(_token, msg.sender, _to, gateway);\n        return\n            ITokenGateway(gateway).outboundTransfer{ value: msg.value }(\n                _token,\n                _to,\n                _amount,\n                _maxGas,\n                _gasPriceBid,\n                gatewayData\n            );\n    }\n\n    function getOutboundCalldata(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _data\n    ) public view virtual override returns (bytes memory) {\n        address gateway = getGateway(_token);\n        return TokenGateway(gateway).getOutboundCalldata(_token, _from, _to, _amount, _data);\n    }\n\n    function getGateway(address _token) public view virtual override returns (address gateway) {\n        gateway = l1TokenToGateway[_token];\n\n        if (gateway == ZERO_ADDR) {\n            // if no gateway value set, use default gateway\n            gateway = defaultGateway;\n        }\n\n        if (gateway == DISABLED || !gateway.isContract()) {\n            // not a valid gateway\n            return ZERO_ADDR;\n        }\n\n        return gateway;\n    }\n\n    function calculateL2TokenAddress(address l1ERC20)\n        public\n        view\n        virtual\n        override(TokenGateway, ITokenGateway)\n        returns (address)\n    {\n        address gateway = getGateway(l1ERC20);\n        if (gateway == ZERO_ADDR) {\n            return ZERO_ADDR;\n        }\n        return TokenGateway(gateway).calculateL2TokenAddress(l1ERC20);\n    }\n}\n"

    },

    "@arbitrum/token-bridge-contracts/contracts/tokenbridge/libraries/gateway/GatewayMessageHandler.sol": {

      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity >=0.6.11;\n\n/// @notice this library manages encoding and decoding of gateway communication\nlibrary GatewayMessageHandler {\n    // these are for communication from L1 to L2 gateway\n\n    function encodeToL2GatewayMsg(bytes memory gatewayData, bytes memory callHookData)\n        internal\n        pure\n        returns (bytes memory res)\n    {\n        res = abi.encode(gatewayData, callHookData);\n    }\n\n    function parseFromL1GatewayMsg(bytes calldata _data)\n        internal\n        pure\n        returns (bytes memory gatewayData, bytes memory callHookData)\n    {\n        // abi decode may revert, but the encoding is done by L1 gateway, so we trust it\n        (gatewayData, callHookData) = abi.decode(_data, (bytes, bytes));\n    }\n\n    // these are for communication from L2 to L1 gateway\n\n    function encodeFromL2GatewayMsg(uint256 exitNum, bytes memory callHookData)\n        internal\n        pure\n        returns (bytes memory res)\n    {\n        res = abi.encode(exitNum, callHookData);\n    }\n\n    function parseToL1GatewayMsg(bytes calldata _data)\n        internal\n        pure\n        returns (uint256 exitNum, bytes memory callHookData)\n    {\n        // abi decode may revert, but the encoding is done by L1 gateway, so we trust it\n        (exitNum, callHookData) = abi.decode(_data, (uint256, bytes));\n    }\n\n    // these are for communication from router to gateway\n\n    function encodeFromRouterToGateway(address _from, bytes calldata _data)\n        internal\n        pure\n        returns (bytes memory res)\n    {\n        // abi decode may revert, but the encoding is done by L1 gateway, so we trust it\n        return abi.encode(_from, _data);\n    }\n\n    function parseFromRouterToGateway(bytes calldata _data)\n        internal\n        pure\n        returns (address, bytes memory res)\n    {\n        // abi decode may revert, but the encoding is done by L1 gateway, so we trust it\n        return abi.decode(_data, (address, bytes));\n    }\n}\n"

    },

    "@arbitrum/token-bridge-contracts/contracts/tokenbridge/libraries/Whitelist.sol": {

      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity >=0.6.11;\n\nabstract contract WhitelistConsumer {\n    address public whitelist;\n\n    event WhitelistSourceUpdated(address newSource);\n\n    modifier onlyWhitelisted() {\n        if (whitelist != address(0)) {\n            require(Whitelist(whitelist).isAllowed(msg.sender), \"NOT_WHITELISTED\");\n        }\n        _;\n    }\n\n    function updateWhitelistSource(address newSource) external {\n        require(msg.sender == whitelist, \"NOT_FROM_LIST\");\n        whitelist = newSource;\n        emit WhitelistSourceUpdated(newSource);\n    }\n}\n\ncontract Whitelist {\n    address public owner;\n    mapping(address => bool) public isAllowed;\n\n    event OwnerUpdated(address newOwner);\n    event WhitelistUpgraded(address newWhitelist, address[] targets);\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"ONLY_OWNER\");\n        _;\n    }\n\n    function setOwner(address newOwner) external onlyOwner {\n        owner = newOwner;\n        emit OwnerUpdated(newOwner);\n    }\n\n    function setWhitelist(address[] memory user, bool[] memory val) external onlyOwner {\n        require(user.length == val.length, \"INVALID_INPUT\");\n\n        for (uint256 i = 0; i < user.length; i++) {\n            isAllowed[user[i]] = val[i];\n        }\n    }\n\n    // set new whitelist to address(0) to disable whitelist\n    function triggerConsumers(address newWhitelist, address[] memory targets) external onlyOwner {\n        for (uint256 i = 0; i < targets.length; i++) {\n            WhitelistConsumer(targets[i]).updateWhitelistSource(newWhitelist);\n        }\n        emit WhitelistUpgraded(newWhitelist, targets);\n    }\n}\n"

    },

    "@arbitrum/token-bridge-contracts/contracts/tokenbridge/libraries/ProxyUtil.sol": {

      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity >=0.6.11;\n\nlibrary ProxyUtil {\n    function getProxyAdmin() internal view returns (address admin) {\n        // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/proxy/TransparentUpgradeableProxy.sol#L48\n        // Storage slot with the admin of the proxy contract.\n        // This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n        bytes32 slot = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n        assembly {\n            admin := sload(slot)\n        }\n    }\n}\n"

    },

    "@arbitrum/token-bridge-contracts/contracts/tokenbridge/libraries/ITransferAndCall.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-version\npragma solidity >0.6.0 <0.9.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\ninterface ITransferAndCall is IERC20Upgradeable {\n    function transferAndCall(\n        address to,\n        uint256 value,\n        bytes memory data\n    ) external returns (bool success);\n\n    event Transfer(address indexed from, address indexed to, uint256 value, bytes data);\n}\n\n/**\n * @notice note that implementation of ITransferAndCallReceiver is not expected to return a success bool\n */\ninterface ITransferAndCallReceiver {\n    function onTokenTransfer(\n        address _sender,\n        uint256 _value,\n        bytes memory _data\n    ) external;\n}\n"

    },

    "@arbitrum/token-bridge-contracts/contracts/tokenbridge/libraries/BytesLib.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\n\npragma solidity >=0.6.11;\n\n/* solhint-disable no-inline-assembly */\nlibrary BytesLib {\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= (_start + 20), \"Read out of bounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= (_start + 1), \"Read out of bounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= (_start + 32), \"Read out of bounds\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= (_start + 32), \"Read out of bounds\");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n}\n/* solhint-enable no-inline-assembly */\n"

    },

    "@arbitrum/token-bridge-contracts/contracts/tokenbridge/libraries/AddressAliasHelper.sol": {

      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity >=0.6.11;\n\nlibrary AddressAliasHelper {\n    uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);\n\n    /// @notice Utility function that converts the address in the L1 that submitted a tx to\n    /// the inbox to the msg.sender viewed in the L2\n    /// @param l1Address the address in the L1 that triggered the tx to L2\n    /// @return l2Address L2 address as viewed in msg.sender\n    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\n        l2Address = address(uint160(l1Address) + offset);\n    }\n\n    /// @notice Utility function that converts the msg.sender viewed in the L2 to the\n    /// address in the L1 that submitted a tx to the inbox\n    /// @param l2Address L2 address as viewed in msg.sender\n    /// @return l1Address the address in the L1 that triggered the tx to L2\n    function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {\n        l1Address = address(uint160(l2Address) - offset);\n    }\n}\n"

    },

    "@arbitrum/token-bridge-contracts/contracts/tokenbridge/ethereum/gateway/L1GatewayRouter.sol": {

      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity >=0.6.11;\n\nimport \"../../libraries/Whitelist.sol\";\n\nimport { ArbitrumEnabledToken } from \"../ICustomToken.sol\";\nimport \"../L1ArbitrumMessenger.sol\";\nimport \"../../libraries/gateway/GatewayRouter.sol\";\nimport \"../../arbitrum/gateway/L2GatewayRouter.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"./IL1GatewayRouter.sol\";\nimport \"./IL1ArbitrumGateway.sol\";\n\n/**\n * @title Handles deposits from Erhereum into Arbitrum. Tokens are routered to their appropriate L1 gateway (Router itself also conforms to the Gateway itnerface).\n * @notice Router also serves as an L1-L2 token address oracle.\n */\ncontract L1GatewayRouter is\n    WhitelistConsumer,\n    L1ArbitrumMessenger,\n    GatewayRouter,\n    ERC165,\n    IL1GatewayRouter\n{\n    address public override owner;\n    address public override inbox;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"ONLY_OWNER\");\n        _;\n    }\n\n    function initialize(\n        address _owner,\n        address _defaultGateway,\n        address, // was _whitelist, now unused\n        address _counterpartGateway,\n        address _inbox\n    ) public {\n        GatewayRouter._initialize(_counterpartGateway, address(0), _defaultGateway);\n        owner = _owner;\n        WhitelistConsumer.whitelist = address(0);\n        inbox = _inbox;\n    }\n\n    function setDefaultGateway(\n        address newL1DefaultGateway,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost\n    ) external payable onlyOwner returns (uint256) {\n        defaultGateway = newL1DefaultGateway;\n\n        emit DefaultGatewayUpdated(newL1DefaultGateway);\n\n        address l2NewDefaultGateway;\n\n        if (newL1DefaultGateway != address(0)) {\n            l2NewDefaultGateway = TokenGateway(newL1DefaultGateway).counterpartGateway();\n        }\n\n        bytes memory data = abi.encodeWithSelector(\n            L2GatewayRouter.setDefaultGateway.selector,\n            l2NewDefaultGateway\n        );\n\n        return\n            sendTxToL2(\n                inbox,\n                counterpartGateway,\n                msg.sender,\n                msg.value,\n                0,\n                L2GasParams({\n                    _maxSubmissionCost: _maxSubmissionCost,\n                    _maxGas: _maxGas,\n                    _gasPriceBid: _gasPriceBid\n                }),\n                data\n            );\n    }\n\n    function setOwner(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"INVALID_OWNER\");\n        // set newOwner to address(1) to disable owner and keep `initialize` safe\n        owner = newOwner;\n    }\n\n    function _setGateways(\n        address[] memory _token,\n        address[] memory _gateway,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost,\n        address _creditBackAddress\n    ) internal returns (uint256) {\n        require(_token.length == _gateway.length, \"WRONG_LENGTH\");\n\n        for (uint256 i = 0; i < _token.length; i++) {\n            l1TokenToGateway[_token[i]] = _gateway[i];\n            emit GatewaySet(_token[i], _gateway[i]);\n            // overwrite memory so the L2 router receives the L2 address of each gateway\n            if (_gateway[i] != address(0) && _gateway[i] != DISABLED) {\n                // if we are assigning a gateway to the token, the address oracle of the gateway\n                // must return something other than the 0 address\n                // this check helps avoid misconfiguring gateways\n                require(\n                    TokenGateway(_gateway[i]).calculateL2TokenAddress(_token[i]) != address(0),\n                    \"TOKEN_NOT_HANDLED_BY_GATEWAY\"\n                );\n                _gateway[i] = TokenGateway(_gateway[i]).counterpartGateway();\n            }\n        }\n\n        bytes memory data = abi.encodeWithSelector(\n            L2GatewayRouter.setGateway.selector,\n            _token,\n            _gateway\n        );\n\n        return\n            sendTxToL2(\n                inbox,\n                counterpartGateway,\n                _creditBackAddress,\n                msg.value,\n                0,\n                L2GasParams({\n                    _maxSubmissionCost: _maxSubmissionCost,\n                    _maxGas: _maxGas,\n                    _gasPriceBid: _gasPriceBid\n                }),\n                data\n            );\n    }\n\n    /**\n     * @notice Allows L1 Token contract to trustlessly register its gateway. (other setGateway method allows excess eth recovery from _maxSubmissionCost and is recommended)\n     * @param _gateway l1 gateway address\n     * @param _maxGas max gas for L2 retryable exrecution\n     * @param _gasPriceBid gas price for L2 retryable ticket\n     * @param  _maxSubmissionCost base submission cost  L2 retryable tick3et\n     * @return Retryable ticket ID\n     */\n    function setGateway(\n        address _gateway,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost\n    ) external payable override returns (uint256) {\n        return setGateway(_gateway, _maxGas, _gasPriceBid, _maxSubmissionCost, msg.sender);\n    }\n\n    /**\n     * @notice Allows L1 Token contract to trustlessly register its gateway.\n     * @param _gateway l1 gateway address\n     * @param _maxGas max gas for L2 retryable exrecution\n     * @param _gasPriceBid gas price for L2 retryable ticket\n     * @param  _maxSubmissionCost base submission cost  L2 retryable tick3et\n     * @param _creditBackAddress address for crediting back overpayment of _maxSubmissionCost\n     * @return Retryable ticket ID\n     */\n    function setGateway(\n        address _gateway,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost,\n        address _creditBackAddress\n    ) public payable override returns (uint256) {\n        require(\n            ArbitrumEnabledToken(msg.sender).isArbitrumEnabled() == uint8(0xb1),\n            \"NOT_ARB_ENABLED\"\n        );\n        // require(_gateway.isContract(), \"NOT_TO_CONTRACT\");\n\n        address currGateway = getGateway(msg.sender);\n        if (currGateway != address(0) && currGateway != defaultGateway) {\n            // if gateway is already set to a non-default gateway, don't allow it to set a different gateway\n            require(currGateway == _gateway, \"NO_UPDATE_TO_DIFFERENT_ADDR\");\n        }\n\n        address[] memory _tokenArr = new address[](1);\n        _tokenArr[0] = address(msg.sender);\n\n        address[] memory _gatewayArr = new address[](1);\n        _gatewayArr[0] = _gateway;\n\n        return\n            _setGateways(\n                _tokenArr,\n                _gatewayArr,\n                _maxGas,\n                _gasPriceBid,\n                _maxSubmissionCost,\n                _creditBackAddress\n            );\n    }\n\n    function setGateways(\n        address[] memory _token,\n        address[] memory _gateway,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost\n    ) external payable onlyOwner returns (uint256) {\n        // it is assumed that token and gateway are both contracts\n        // require(_token[i].isContract() && _gateway[i].isContract(), \"NOT_CONTRACT\");\n        return\n            _setGateways(_token, _gateway, _maxGas, _gasPriceBid, _maxSubmissionCost, msg.sender);\n    }\n\n    function outboundTransfer(\n        address _token,\n        address _to,\n        uint256 _amount,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) public payable override(GatewayRouter, ITokenGateway) returns (bytes memory) {\n        return super.outboundTransfer(_token, _to, _amount, _maxGas, _gasPriceBid, _data);\n    }\n\n    /**\n     * @notice Deposit ERC20 token from Ethereum into Arbitrum using the registered or otherwise default gateway\n     * @dev Some legacy gateway might not have the outboundTransferCustomRefund method and will revert, in such case use outboundTransfer instead\n     *      L2 address alias will not be applied to the following types of addresses on L1:\n     *      - an externally-owned account\n     *      - a contract in construction\n     *      - an address where a contract will be created\n     *      - an address where a contract lived, but was destroyed\n     * @param _token L1 address of ERC20\n     * @param _refundTo Account, or its L2 alias if it have code in L1, to be credited with excess gas refund in L2\n     * @param _to Account to be credited with the tokens in the L2 (can be the user's L2 account or a contract), not subject to L2 aliasing\n                  This account, or its L2 alias if it have code in L1, will also be able to cancel the retryable ticket and receive callvalue refund\n     * @param _amount Token Amount\n     * @param _maxGas Max gas deducted from user's L2 balance to cover L2 execution\n     * @param _gasPriceBid Gas price for L2 execution\n     * @param _data encoded data from router and user\n     * @return res abi encoded inbox sequence number\n     */\n    function outboundTransferCustomRefund(\n        address _token,\n        address _refundTo,\n        address _to,\n        uint256 _amount,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) public payable override returns (bytes memory) {\n        address gateway = getGateway(_token);\n        bytes memory gatewayData = GatewayMessageHandler.encodeFromRouterToGateway(\n            msg.sender,\n            _data\n        );\n\n        emit TransferRouted(_token, msg.sender, _to, gateway);\n        // here we use `IL1ArbitrumGateway` since we don't assume all ITokenGateway implements `outboundTransferCustomRefund`\n        return\n            IL1ArbitrumGateway(gateway).outboundTransferCustomRefund{ value: msg.value }(\n                _token,\n                _refundTo,\n                _to,\n                _amount,\n                _maxGas,\n                _gasPriceBid,\n                gatewayData\n            );\n    }\n\n    modifier onlyCounterpartGateway() override {\n        // don't expect messages from L2 router\n        revert(\"ONLY_COUNTERPART_GATEWAY\");\n        _;\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC165, IERC165)\n        returns (bool)\n    {\n        // registering interfaces that is added after arb-bridge-peripherals >1.0.11\n        // using function selector instead of single function interfaces to reduce bloat\n        return\n            interfaceId == this.outboundTransferCustomRefund.selector ||\n            super.supportsInterface(interfaceId);\n    }\n}\n"

    },

    "@arbitrum/token-bridge-contracts/contracts/tokenbridge/ethereum/gateway/L1CustomGateway.sol": {

      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity >=0.6.11;\n\nimport { ArbitrumEnabledToken } from \"../ICustomToken.sol\";\nimport \"./L1ArbitrumExtendedGateway.sol\";\nimport \"../../arbitrum/gateway/L2CustomGateway.sol\";\nimport \"../../libraries/gateway/ICustomGateway.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"../../libraries/Whitelist.sol\";\n\n/**\n * @title Gatway for \"custom\" bridging functionality\n * @notice Handles some (but not all!) custom Gateway needs.\n */\ncontract L1CustomGateway is L1ArbitrumExtendedGateway, ICustomGateway {\n    using Address for address;\n    // stores addresses of L2 tokens to be used\n    mapping(address => address) public override l1ToL2Token;\n    // owner is able to force add custom mappings\n    address public owner;\n\n    // whitelist not used anymore\n    address public whitelist;\n\n    // start of inline reentrancy guard\n    // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.2/contracts/utils/ReentrancyGuard.sol\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n    uint256 private _status;\n\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n        _;\n        _status = _NOT_ENTERED;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"ONLY_OWNER\");\n        _;\n    }\n\n    function outboundTransferCustomRefund(\n        address _l1Token,\n        address _refundTo,\n        address _to,\n        uint256 _amount,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) public payable override nonReentrant returns (bytes memory res) {\n        return\n            super.outboundTransferCustomRefund(\n                _l1Token,\n                _refundTo,\n                _to,\n                _amount,\n                _maxGas,\n                _gasPriceBid,\n                _data\n            );\n    }\n\n    function finalizeInboundTransfer(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) public payable override nonReentrant {\n        // the superclass checks onlyCounterpartGateway\n        super.finalizeInboundTransfer(_token, _from, _to, _amount, _data);\n    }\n\n    function initialize(\n        address _l1Counterpart,\n        address _l1Router,\n        address _inbox,\n        address _owner\n    ) public {\n        L1ArbitrumGateway._initialize(_l1Counterpart, _l1Router, _inbox);\n        owner = _owner;\n        // disable whitelist by default\n        whitelist = address(0);\n        // reentrancy guard\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @notice Calculate the address used when bridging an ERC20 token\n     * @dev the L1 and L2 address oracles may not always be in sync.\n     * For example, a custom token may have been registered but not deploy or the contract self destructed.\n     * @param l1ERC20 address of L1 token\n     * @return L2 address of a bridged ERC20 token\n     */\n    function calculateL2TokenAddress(address l1ERC20) public view override(ITokenGateway, TokenGateway) returns (address) {\n        return l1ToL2Token[l1ERC20];\n    }\n\n    /**\n     * @notice Allows L1 Token contract to trustlessly register its custom L2 counterpart. (other registerTokenToL2 method allows excess eth recovery from _maxSubmissionCost and is recommended)\n     * @param _l2Address counterpart address of L1 token\n     * @param _maxGas max gas for L2 retryable exrecution\n     * @param _gasPriceBid gas price for L2 retryable ticket\n     * @param  _maxSubmissionCost base submission cost  L2 retryable tick3et\n     * @return Retryable ticket ID\n     */\n    function registerTokenToL2(\n        address _l2Address,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost\n    ) external payable returns (uint256) {\n        return registerTokenToL2(_l2Address, _maxGas, _gasPriceBid, _maxSubmissionCost, msg.sender);\n    }\n\n    /**\n     * @notice Allows L1 Token contract to trustlessly register its custom L2 counterpart.\n     * param _l2Address counterpart address of L1 token\n     * param _maxGas max gas for L2 retryable exrecution\n     * param _gasPriceBid gas price for L2 retryable ticket\n     * param  _maxSubmissionCost base submission cost  L2 retryable tick3et\n     * param _creditBackAddress address for crediting back overpayment of _maxSubmissionCost\n     * return Retryable ticket ID\n     */\n    function registerTokenToL2(\n        address _l2Address,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost,\n        address _creditBackAddress\n    ) public payable virtual returns (uint256) {\n        require(\n            ArbitrumEnabledToken(msg.sender).isArbitrumEnabled() == uint8(0xb1),\n            \"NOT_ARB_ENABLED\"\n        );\n\n        address currL2Addr = l1ToL2Token[msg.sender];\n        if (currL2Addr != address(0)) {\n            // if token is already set, don't allow it to set a different L2 address\n            require(currL2Addr == _l2Address, \"NO_UPDATE_TO_DIFFERENT_ADDR\");\n        }\n\n        l1ToL2Token[msg.sender] = _l2Address;\n\n        address[] memory l1Addresses = new address[](1);\n        address[] memory l2Addresses = new address[](1);\n        l1Addresses[0] = msg.sender;\n        l2Addresses[0] = _l2Address;\n\n        emit TokenSet(l1Addresses[0], l2Addresses[0]);\n\n        bytes memory _data = abi.encodeWithSelector(\n            L2CustomGateway.registerTokenFromL1.selector,\n            l1Addresses,\n            l2Addresses\n        );\n\n        return\n            sendTxToL2(\n                inbox,\n                counterpartGateway,\n                _creditBackAddress,\n                msg.value,\n                0,\n                _maxSubmissionCost,\n                _maxGas,\n                _gasPriceBid,\n                _data\n            );\n    }\n\n    function setOwner(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"INVALID_OWNER\");\n        owner = newOwner;\n    }\n\n    /**\n     * @notice Allows owner to force register a custom L1/L2 token pair.\n     * @dev _l1Addresses[i] counterpart is assumed to be _l2Addresses[i]\n     * @param _l1Addresses array of L1 addresses\n     * @param _l2Addresses array of L2 addresses\n     * @param _maxGas max gas for L2 retryable exrecution\n     * @param _gasPriceBid gas price for L2 retryable ticket\n     * @param  _maxSubmissionCost base submission cost  L2 retryable tick3et\n     * @return Retryable ticket ID\n     */\n    function forceRegisterTokenToL2(\n        address[] calldata _l1Addresses,\n        address[] calldata _l2Addresses,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost\n    ) external payable onlyOwner returns (uint256) {\n        require(_l1Addresses.length == _l2Addresses.length, \"INVALID_LENGTHS\");\n\n        for (uint256 i = 0; i < _l1Addresses.length; i++) {\n            // here we assume the owner checked both addresses offchain before force registering\n            // require(address(_l1Addresses[i]).isContract(), \"MUST_BE_CONTRACT\");\n            l1ToL2Token[_l1Addresses[i]] = _l2Addresses[i];\n            emit TokenSet(_l1Addresses[i], _l2Addresses[i]);\n        }\n\n        bytes memory _data = abi.encodeWithSelector(\n            L2CustomGateway.registerTokenFromL1.selector,\n            _l1Addresses,\n            _l2Addresses\n        );\n\n        return\n            sendTxToL2(\n                inbox,\n                counterpartGateway,\n                msg.sender,\n                msg.value,\n                0,\n                _maxSubmissionCost,\n                _maxGas,\n                _gasPriceBid,\n                _data\n            );\n    }\n}\n"

    },

    "@arbitrum/token-bridge-contracts/contracts/tokenbridge/ethereum/gateway/L1ArbitrumGateway.sol": {

      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity >=0.6.11;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n// import \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Create2.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n// import \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"../L1ArbitrumMessenger.sol\";\nimport \"./IL1ArbitrumGateway.sol\";\nimport \"../../libraries/ProxyUtil.sol\";\nimport \"../../libraries/gateway/GatewayMessageHandler.sol\";\nimport \"../../libraries/gateway/TokenGateway.sol\";\nimport \"../../libraries/ITransferAndCall.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\n/**\n * @title Common interface for gatways on L1 messaging to Arbitrum.\n */\nabstract contract L1ArbitrumGateway is\n    L1ArbitrumMessenger,\n    TokenGateway,\n    ERC165,\n    IL1ArbitrumGateway\n{\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    address public override inbox;\n\n    event DepositInitiated(\n        address l1Token,\n        address indexed _from,\n        address indexed _to,\n        uint256 indexed _sequenceNumber,\n        uint256 _amount\n    );\n\n    event WithdrawalFinalized(\n        address l1Token,\n        address indexed _from,\n        address indexed _to,\n        uint256 indexed _exitNum,\n        uint256 _amount\n    );\n\n    modifier onlyCounterpartGateway() override {\n        address _inbox = inbox;\n\n        // a message coming from the counterpart gateway was executed by the bridge\n        address bridge = address(super.getBridge(_inbox));\n        require(msg.sender == bridge, \"NOT_FROM_BRIDGE\");\n\n        // and the outbox reports that the L2 address of the sender is the counterpart gateway\n        address l2ToL1Sender = super.getL2ToL1Sender(_inbox);\n        require(l2ToL1Sender == counterpartGateway, \"ONLY_COUNTERPART_GATEWAY\");\n        _;\n    }\n\n    function postUpgradeInit() external view {\n        // it is assumed the L1 Arbitrum Gateway contract is behind a Proxy controlled by a proxy admin\n        // this function can only be called by the proxy admin contract\n        address proxyAdmin = ProxyUtil.getProxyAdmin();\n        require(msg.sender == proxyAdmin, \"NOT_FROM_ADMIN\");\n        // this has no other logic since the current upgrade doesn't require this logic\n    }\n\n    function _initialize(\n        address _l2Counterpart,\n        address _router,\n        address _inbox\n    ) internal {\n        TokenGateway._initialize(_l2Counterpart, _router);\n        // L1 gateway must have a router\n        require(_router != address(0), \"BAD_ROUTER\");\n        require(_inbox != address(0), \"BAD_INBOX\");\n        inbox = _inbox;\n    }\n\n    /**\n     * @notice Finalizes a withdrawal via Outbox message; callable only by L2Gateway.outboundTransfer\n     * @param _token L1 address of token being withdrawn from\n     * @param _from initiator of withdrawal\n     * @param _to address the L2 withdrawal call set as the destination.\n     * @param _amount Token amount being withdrawn\n     * @param _data encoded exitNum (Sequentially increasing exit counter determined by the L2Gateway) and additinal hook data\n     */\n    function finalizeInboundTransfer(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) public payable virtual override onlyCounterpartGateway {\n        // this function is marked as virtual so superclasses can override it to add modifiers\n        (uint256 exitNum, bytes memory callHookData) = GatewayMessageHandler.parseToL1GatewayMsg(\n            _data\n        );\n\n        if (callHookData.length != 0) {\n            // callHookData should always be 0 since inboundEscrowAndCall is disabled\n            callHookData = bytes(\"\");\n        }\n\n        // we ignore the returned data since the callHook feature is now disabled\n        (_to, ) = getExternalCall(exitNum, _to, callHookData);\n        inboundEscrowTransfer(_token, _to, _amount);\n\n        emit WithdrawalFinalized(_token, _from, _to, exitNum, _amount);\n    }\n\n    function getExternalCall(\n        uint256, /* _exitNum */\n        address _initialDestination,\n        bytes memory _initialData\n    ) public view virtual returns (address target, bytes memory data) {\n        // this method is virtual so the destination of a call can be changed\n        // using tradeable exits in a subclass (L1ArbitrumExtendedGateway)\n        target = _initialDestination;\n        data = _initialData;\n    }\n\n    function inboundEscrowTransfer(\n        address _l1Token,\n        address _dest,\n        uint256 _amount\n    ) internal virtual {\n        // this method is virtual since different subclasses can handle escrow differently\n        IERC20(_l1Token).safeTransfer(_dest, _amount);\n    }\n\n    /**\n     * @dev Only excess gas is refunded to the _refundTo account, l2 call value is always returned to the _to account\n     */\n    function createOutboundTxCustomRefund(\n        address _refundTo,\n        address _from,\n        uint256, /* _tokenAmount */\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost,\n        bytes memory _outboundCalldata\n    ) internal virtual returns (uint256) {\n        // We make this function virtual since outboundTransfer logic is the same for many gateways\n        // but sometimes (ie weth) you construct the outgoing message differently.\n\n        // msg.value is sent, but 0 is set to the L2 call value\n        // the eth sent is used to pay for the tx's gas\n        return\n            sendTxToL2CustomRefund(\n                inbox,\n                counterpartGateway,\n                _refundTo,\n                _from,\n                msg.value, // we forward the L1 call value to the inbox\n                0, // l2 call value 0 by default\n                L2GasParams({\n                    _maxSubmissionCost: _maxSubmissionCost,\n                    _maxGas: _maxGas,\n                    _gasPriceBid: _gasPriceBid\n                }),\n                _outboundCalldata\n            );\n    }\n\n    /**\n     * @notice DEPRECATED - look at createOutboundTxCustomRefund instead\n     */\n    function createOutboundTx(\n        address _from,\n        uint256 _tokenAmount,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost,\n        bytes memory _outboundCalldata\n    ) internal returns (uint256) {\n        return\n            createOutboundTxCustomRefund(\n                _from,\n                _from,\n                _tokenAmount,\n                _maxGas,\n                _gasPriceBid,\n                _maxSubmissionCost,\n                _outboundCalldata\n            );\n    }\n\n    /**\n     * @notice DEPRECATED - look at outboundTransferCustomRefund instead\n     */\n    function outboundTransfer(\n        address _l1Token,\n        address _to,\n        uint256 _amount,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) public payable override returns (bytes memory res) {\n        return\n            outboundTransferCustomRefund(_l1Token, _to, _to, _amount, _maxGas, _gasPriceBid, _data);\n    }\n\n    /**\n     * @notice Deposit ERC20 token from Ethereum into Arbitrum. If L2 side hasn't been deployed yet, includes name/symbol/decimals data for initial L2 deploy. Initiate by GatewayRouter.\n     * @dev L2 address alias will not be applied to the following types of addresses on L1:\n     *      - an externally-owned account\n     *      - a contract in construction\n     *      - an address where a contract will be created\n     *      - an address where a contract lived, but was destroyed\n     * @param _l1Token L1 address of ERC20\n     * @param _refundTo Account, or its L2 alias if it have code in L1, to be credited with excess gas refund in L2\n     * @param _to Account to be credited with the tokens in the L2 (can be the user's L2 account or a contract), not subject to L2 aliasing\n                  This account, or its L2 alias if it have code in L1, will also be able to cancel the retryable ticket and receive callvalue refund\n     * @param _amount Token Amount\n     * @param _maxGas Max gas deducted from user's L2 balance to cover L2 execution\n     * @param _gasPriceBid Gas price for L2 execution\n     * @param _data encoded data from router and user\n     * @return res abi encoded inbox sequence number\n     */\n    //  * @param maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\n    function outboundTransferCustomRefund(\n        address _l1Token,\n        address _refundTo,\n        address _to,\n        uint256 _amount,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) public payable virtual override returns (bytes memory res) {\n        require(isRouter(msg.sender), \"NOT_FROM_ROUTER\");\n        // This function is set as public and virtual so that subclasses can override\n        // it and add custom validation for callers (ie only whitelisted users)\n        address _from;\n        uint256 seqNum;\n        bytes memory extraData;\n        {\n            uint256 _maxSubmissionCost;\n            if (super.isRouter(msg.sender)) {\n                // router encoded\n                (_from, extraData) = GatewayMessageHandler.parseFromRouterToGateway(_data);\n            } else {\n                _from = msg.sender;\n                extraData = _data;\n            }\n            // user encoded\n            (_maxSubmissionCost, extraData) = abi.decode(extraData, (uint256, bytes));\n            // the inboundEscrowAndCall functionality has been disabled, so no data is allowed\n            require(extraData.length == 0, \"EXTRA_DATA_DISABLED\");\n\n            require(_l1Token.isContract(), \"L1_NOT_CONTRACT\");\n            address l2Token = calculateL2TokenAddress(_l1Token);\n            require(l2Token != address(0), \"NO_L2_TOKEN_SET\");\n\n            _amount = outboundEscrowTransfer(_l1Token, _from, _amount);\n\n            // we override the res field to save on the stack\n            res = getOutboundCalldata(_l1Token, _from, _to, _amount, extraData);\n\n            seqNum = createOutboundTxCustomRefund(\n                _refundTo,\n                _from,\n                _amount,\n                _maxGas,\n                _gasPriceBid,\n                _maxSubmissionCost,\n                res\n            );\n        }\n        emit DepositInitiated(_l1Token, _from, _to, seqNum, _amount);\n        return abi.encode(seqNum);\n    }\n\n    function outboundEscrowTransfer(\n        address _l1Token,\n        address _from,\n        uint256 _amount\n    ) internal virtual returns (uint256 amountReceived) {\n        // this method is virtual since different subclasses can handle escrow differently\n        // user funds are escrowed on the gateway using this function\n        uint256 prevBalance = IERC20(_l1Token).balanceOf(address(this));\n        IERC20(_l1Token).safeTransferFrom(_from, address(this), _amount);\n        uint256 postBalance = IERC20(_l1Token).balanceOf(address(this));\n        return SafeMath.sub(postBalance, prevBalance);\n    }\n\n    function getOutboundCalldata(\n        address _l1Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _data\n    ) public view virtual override returns (bytes memory outboundCalldata) {\n        // this function is public so users can query how much calldata will be sent to the L2\n        // before execution\n        // it is virtual since different gateway subclasses can build this calldata differently\n        // ( ie the standard ERC20 gateway queries for a tokens name/symbol/decimals )\n        bytes memory emptyBytes = \"\";\n\n        outboundCalldata = abi.encodeWithSelector(\n            ITokenGateway.finalizeInboundTransfer.selector,\n            _l1Token,\n            _from,\n            _to,\n            _amount,\n            GatewayMessageHandler.encodeToL2GatewayMsg(emptyBytes, _data)\n        );\n\n        return outboundCalldata;\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165, IERC165)\n        returns (bool)\n    {\n        // registering interfaces that is added after arb-bridge-peripherals >1.0.11\n        // using function selector instead of single function interfaces to reduce bloat\n        return\n            interfaceId == this.outboundTransferCustomRefund.selector ||\n            super.supportsInterface(interfaceId);\n    }\n}\n"

    },

    "@arbitrum/token-bridge-contracts/contracts/tokenbridge/ethereum/gateway/L1ArbitrumExtendedGateway.sol": {

      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity >=0.6.11;\n\nimport \"../../libraries/ITransferAndCall.sol\";\n\nimport \"./L1ArbitrumGateway.sol\";\n\ninterface ITradeableExitReceiver {\n    function onExitTransfer(\n        address sender,\n        uint256 exitNum,\n        bytes calldata data\n    ) external returns (bool);\n}\n\nabstract contract L1ArbitrumExtendedGateway is L1ArbitrumGateway {\n    struct ExitData {\n        bool isExit;\n        address _newTo;\n        bytes _newData;\n    }\n\n    mapping(bytes32 => ExitData) public redirectedExits;\n\n    event WithdrawRedirected(\n        address indexed from,\n        address indexed to,\n        uint256 indexed exitNum,\n        bytes newData,\n        bytes data,\n        bool madeExternalCall\n    );\n\n    /**\n     * @notice Allows a user to redirect their right to claim a withdrawal to another address.\n     * @dev This method also allows you to make an arbitrary call after the transfer.\n     * This does not validate if the exit was already triggered. It is assumed the `_exitNum` is\n     * validated off-chain to ensure this was not yet triggered.\n     * @param _exitNum Sequentially increasing exit counter determined by the L2 bridge\n     * @param _initialDestination address the L2 withdrawal call initially set as the destination.\n     * @param _newDestination address the L1 will now call instead of the previously set destination\n     * @param _newData data to be used in inboundEscrowAndCall\n     * @param _data optional data for external call upon transfering the exit\n     */\n    function transferExitAndCall(\n        uint256 _exitNum,\n        address _initialDestination,\n        address _newDestination,\n        bytes calldata _newData,\n        bytes calldata _data\n    ) external {\n        // the initial data doesn't make a difference when transfering you exit\n        // since the L2 bridge gives a unique exit ID to each exit\n        (address expectedSender, ) = getExternalCall(_exitNum, _initialDestination, \"\");\n\n        // if you want to transfer your exit, you must be the current destination\n        require(msg.sender == expectedSender, \"NOT_EXPECTED_SENDER\");\n        // the inboundEscrowAndCall functionality has been disabled, so no data is allowed\n        require(_newData.length == 0, \"NO_DATA_ALLOWED\");\n\n        setRedirectedExit(_exitNum, _initialDestination, _newDestination, _newData);\n\n        if (_data.length > 0) {\n            // require(_newDestination.isContract(), \"TO_NOT_CONTRACT\");\n            bool success = ITradeableExitReceiver(_newDestination).onExitTransfer(\n                expectedSender,\n                _exitNum,\n                _data\n            );\n            require(success, \"TRANSFER_HOOK_FAIL\");\n        }\n\n        emit WithdrawRedirected(\n            expectedSender,\n            _newDestination,\n            _exitNum,\n            _newData,\n            _data,\n            _data.length > 0\n        );\n    }\n\n    /// @notice this does not verify if the external call was already done\n    function getExternalCall(\n        uint256 _exitNum,\n        address _initialDestination,\n        bytes memory _initialData\n    ) public view virtual override returns (address target, bytes memory data) {\n        // this function is virtual so that subclasses can override it with custom logic where necessary\n        bytes32 withdrawData = encodeWithdrawal(_exitNum, _initialDestination);\n        ExitData storage exit = redirectedExits[withdrawData];\n\n        // here we don't authenticate `_initialData`. we could hash it into `withdrawData` but would increase gas costs\n        // this is safe because if the exit isn't overriden, the _initialData coming from L2 is trusted\n        // but if the exit is traded, all we care about is the latest user calldata\n        if (exit.isExit) {\n            return (exit._newTo, exit._newData);\n        } else {\n            return (_initialDestination, _initialData);\n        }\n    }\n\n    function setRedirectedExit(\n        uint256 _exitNum,\n        address _initialDestination,\n        address _newDestination,\n        bytes memory _newData\n    ) internal virtual {\n        bytes32 withdrawData = encodeWithdrawal(_exitNum, _initialDestination);\n        redirectedExits[withdrawData] = ExitData(true, _newDestination, _newData);\n    }\n\n    function encodeWithdrawal(uint256 _exitNum, address _initialDestination)\n        public\n        pure\n        returns (bytes32)\n    {\n        // here we assume the L2 bridge gives a unique exitNum to each exit\n        return keccak256(abi.encode(_exitNum, _initialDestination));\n    }\n}\n"

    },

    "@arbitrum/token-bridge-contracts/contracts/tokenbridge/ethereum/gateway/IL1GatewayRouter.sol": {

      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.6.9 <0.9.0;\n\nimport \"../../libraries/gateway/ITokenGateway.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC165.sol\";\n\n/**\n * @title Handles deposits from Erhereum into Arbitrum. Tokens are routered to their appropriate L1 gateway (Router itself also conforms to the Gateway itnerface).\n * @notice Router also serves as an L1-L2 token address oracle.\n */\ninterface IL1GatewayRouter is ITokenGateway, IERC165 {\n    /**\n     * @notice Deposit ERC20 token from Ethereum into Arbitrum using the registered or otherwise default gateway\n     * @dev Some legacy gateway might not have the outboundTransferCustomRefund method and will revert, in such case use outboundTransfer instead\n     *      L2 address alias will not be applied to the following types of addresses on L1:\n     *      - an externally-owned account\n     *      - a contract in construction\n     *      - an address where a contract will be created\n     *      - an address where a contract lived, but was destroyed\n     * @param _token L1 address of ERC20\n     * @param _refundTo Account, or its L2 alias if it have code in L1, to be credited with excess gas refund in L2\n     * @param _to Account to be credited with the tokens in the L2 (can be the user's L2 account or a contract), not subject to L2 aliasing\n                  This account, or its L2 alias if it have code in L1, will also be able to cancel the retryable ticket and receive callvalue refund\n     * @param _amount Token Amount\n     * @param _maxGas Max gas deducted from user's L2 balance to cover L2 execution\n     * @param _gasPriceBid Gas price for L2 execution\n     * @param _data encoded data from router and user\n     * @return res abi encoded inbox sequence number\n     */\n    function outboundTransferCustomRefund(\n        address _token,\n        address _refundTo,\n        address _to,\n        uint256 _amount,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) external payable returns (bytes memory);\n\n    /**\n     * @notice Allows L1 Token contract to trustlessly register its gateway.\n     * @param _gateway l1 gateway address\n     * @param _maxGas max gas for L2 retryable exrecution\n     * @param _gasPriceBid gas price for L2 retryable ticket\n     * @param  _maxSubmissionCost base submission cost  L2 retryable tick3et\n     * @param _creditBackAddress address for crediting back overpayment of _maxSubmissionCost\n     * @return Retryable ticket ID\n     */\n    function setGateway(\n        address _gateway,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost,\n        address _creditBackAddress\n    ) external payable returns (uint256);\n\n    /**\n     * @notice Allows L1 Token contract to trustlessly register its gateway. (other setGateway method allows excess eth recovery from _maxSubmissionCost and is recommended)\n     * @param _gateway l1 gateway address\n     * @param _maxGas max gas for L2 retryable exrecution\n     * @param _gasPriceBid gas price for L2 retryable ticket\n     * @param  _maxSubmissionCost base submission cost  L2 retryable tick3et\n     * @return Retryable ticket ID\n     */\n    function setGateway(\n        address _gateway,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        uint256 _maxSubmissionCost\n    ) external payable returns (uint256);\n\n    function owner() external view returns (address);\n\n    function inbox() external view returns (address);\n}\n"

    },

    "@arbitrum/token-bridge-contracts/contracts/tokenbridge/ethereum/gateway/IL1ArbitrumGateway.sol": {

      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.6.9 <0.9.0;\n\nimport \"../../libraries/gateway/ITokenGateway.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC165.sol\";\n\n/**\n * @title Common interface for gatways on L1 messaging to Arbitrum.\n */\ninterface IL1ArbitrumGateway is ITokenGateway, IERC165 {\n    function inbox() external view returns (address);\n\n    /**\n     * @notice Deposit ERC20 token from Ethereum into Arbitrum. If L2 side hasn't been deployed yet, includes name/symbol/decimals data for initial L2 deploy. Initiate by GatewayRouter.\n     * @dev L2 address alias will not be applied to the following types of addresses on L1:\n     *      - an externally-owned account\n     *      - a contract in construction\n     *      - an address where a contract will be created\n     *      - an address where a contract lived, but was destroyed\n     * @param _l1Token L1 address of ERC20\n     * @param _refundTo Account, or its L2 alias if it have code in L1, to be credited with excess gas refund in L2\n     * @param _to Account to be credited with the tokens in the L2 (can be the user's L2 account or a contract), not subject to L2 aliasing\n                  This account, or its L2 alias if it have code in L1, will also be able to cancel the retryable ticket and receive callvalue refund\n     * @param _amount Token Amount\n     * @param _maxGas Max gas deducted from user's L2 balance to cover L2 execution\n     * @param _gasPriceBid Gas price for L2 execution\n     * @param _data encoded data from router and user\n     * @return res abi encoded inbox sequence number\n     */\n    //  * @param maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\n    function outboundTransferCustomRefund(\n        address _l1Token,\n        address _refundTo,\n        address _to,\n        uint256 _amount,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes calldata _data\n    ) external payable returns (bytes memory);\n}\n"

    },

    "@arbitrum/token-bridge-contracts/contracts/tokenbridge/ethereum/L1ArbitrumMessenger.sol": {

      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity >=0.6.11;\n\nimport \"@arbitrum/nitro-contracts/src/bridge/IInbox.sol\";\nimport \"@arbitrum/nitro-contracts/src/bridge/IOutbox.sol\";\n\n/// @notice L1 utility contract to assist with L1 <=> L2 interactions\n/// @dev this is an abstract contract instead of library so the functions can be easily overriden when testing\nabstract contract L1ArbitrumMessenger {\n    event TxToL2(address indexed _from, address indexed _to, uint256 indexed _seqNum, bytes _data);\n\n    struct L2GasParams {\n        uint256 _maxSubmissionCost;\n        uint256 _maxGas;\n        uint256 _gasPriceBid;\n    }\n\n    function sendTxToL2CustomRefund(\n        address _inbox,\n        address _to,\n        address _refundTo,\n        address _user,\n        uint256 _l1CallValue,\n        uint256 _l2CallValue,\n        L2GasParams memory _l2GasParams,\n        bytes memory _data\n    ) internal returns (uint256) {\n        // alternative function entry point when struggling with the stack size\n        return\n            sendTxToL2CustomRefund(\n                _inbox,\n                _to,\n                _refundTo,\n                _user,\n                _l1CallValue,\n                _l2CallValue,\n                _l2GasParams._maxSubmissionCost,\n                _l2GasParams._maxGas,\n                _l2GasParams._gasPriceBid,\n                _data\n            );\n    }\n\n    function sendTxToL2(\n        address _inbox,\n        address _to,\n        address _user,\n        uint256 _l1CallValue,\n        uint256 _l2CallValue,\n        L2GasParams memory _l2GasParams,\n        bytes memory _data\n    ) internal returns (uint256) {\n        // alternative function entry point when struggling with the stack size\n        return\n            sendTxToL2(\n                _inbox,\n                _to,\n                _user,\n                _l1CallValue,\n                _l2CallValue,\n                _l2GasParams._maxSubmissionCost,\n                _l2GasParams._maxGas,\n                _l2GasParams._gasPriceBid,\n                _data\n            );\n    }\n\n    function sendTxToL2CustomRefund(\n        address _inbox,\n        address _to,\n        address _refundTo,\n        address _user,\n        uint256 _l1CallValue,\n        uint256 _l2CallValue,\n        uint256 _maxSubmissionCost,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes memory _data\n    ) internal returns (uint256) {\n        uint256 seqNum = IInbox(_inbox).createRetryableTicket{ value: _l1CallValue }(\n            _to,\n            _l2CallValue,\n            _maxSubmissionCost,\n            _refundTo, // only refund excess fee to the custom address\n            _user, // user can cancel the retryable and receive call value refund\n            _maxGas,\n            _gasPriceBid,\n            _data\n        );\n        emit TxToL2(_user, _to, seqNum, _data);\n        return seqNum;\n    }\n\n    function sendTxToL2(\n        address _inbox,\n        address _to,\n        address _user,\n        uint256 _l1CallValue,\n        uint256 _l2CallValue,\n        uint256 _maxSubmissionCost,\n        uint256 _maxGas,\n        uint256 _gasPriceBid,\n        bytes memory _data\n    ) internal returns (uint256) {\n        return\n            sendTxToL2CustomRefund(\n                _inbox,\n                _to,\n                _user,\n                _user,\n                _l1CallValue,\n                _l2CallValue,\n                _maxSubmissionCost,\n                _maxGas,\n                _gasPriceBid,\n                _data\n            );\n    }\n\n    function getBridge(address _inbox) internal view returns (IBridge) {\n        return IInbox(_inbox).bridge();\n    }\n\n    /// @dev the l2ToL1Sender behaves as the tx.origin, the msg.sender should be validated to protect against reentrancies\n    function getL2ToL1Sender(address _inbox) internal view returns (address) {\n        IOutbox outbox = IOutbox(getBridge(_inbox).activeOutbox());\n        address l2ToL1Sender = outbox.l2ToL1Sender();\n\n        require(l2ToL1Sender != address(0), \"NO_SENDER\");\n        return l2ToL1Sender;\n    }\n}\n"

    },

    "@arbitrum/token-bridge-contracts/contracts/tokenbridge/ethereum/ICustomToken.sol": {

      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.6.9 <0.9.0;\n\ninterface ArbitrumEnabledToken {\n    /// @notice should return `0xa4b1` if token is enabled for arbitrum gateways\n    function isArbitrumEnabled() external view returns (uint8);\n}\n\n/**\n * @title Minimum expected interface for L1 custom token (see TestCustomTokenL1.sol for an example implementation)\n */\ninterface ICustomToken is ArbitrumEnabledToken {\n    /**\n     * @notice Should make an external call to EthERC20Bridge.registerCustomL2Token\n     */\n    function registerTokenOnL2(\n        address l2CustomTokenAddress,\n        uint256 maxSubmissionCostForCustomBridge,\n        uint256 maxSubmissionCostForRouter,\n        uint256 maxGasForCustomBridge,\n        uint256 maxGasForRouter,\n        uint256 gasPriceBid,\n        uint256 valueForGateway,\n        uint256 valueForRouter,\n        address creditBackAddress\n    ) external payable;\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    function balanceOf(address account) external view returns (uint256);\n}\n\ninterface L1MintableToken is ICustomToken {\n    function bridgeMint(address account, uint256 amount) external;\n}\n\ninterface L1ReverseToken is L1MintableToken {\n    function bridgeBurn(address account, uint256 amount) external;\n}\n"

    },

    "@arbitrum/token-bridge-contracts/contracts/tokenbridge/arbitrum/gateway/L2GatewayRouter.sol": {

      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity >=0.6.11;\n\nimport \"../../libraries/gateway/GatewayRouter.sol\";\nimport \"../../ethereum/gateway/L1GatewayRouter.sol\";\nimport \"../L2ArbitrumMessenger.sol\";\nimport \"../../libraries/AddressAliasHelper.sol\";\n\n/**\n * @title Handles withdrawals from Ethereum into Arbitrum. Tokens are routered to their appropriate L2 gateway (Router itself also conforms to the Gateway interface).\n * @notice Router also serves as an L2-L1 token address oracle.\n */\ncontract L2GatewayRouter is GatewayRouter, L2ArbitrumMessenger {\n    modifier onlyCounterpartGateway() override {\n        require(\n            msg.sender == AddressAliasHelper.applyL1ToL2Alias(counterpartGateway),\n            \"ONLY_COUNTERPART_GATEWAY\"\n        );\n        _;\n    }\n\n    function initialize(address _counterpartGateway, address _defaultGateway) public {\n        GatewayRouter._initialize(_counterpartGateway, address(0), _defaultGateway);\n    }\n\n    function setGateway(address[] memory _l1Token, address[] memory _gateway)\n        external\n        onlyCounterpartGateway\n    {\n        // counterpart gateway (L1 router) should never allow wrong lengths\n        assert(_l1Token.length == _gateway.length);\n\n        for (uint256 i = 0; i < _l1Token.length; i++) {\n            l1TokenToGateway[_l1Token[i]] = _gateway[i];\n            emit GatewaySet(_l1Token[i], _gateway[i]);\n        }\n    }\n\n    function outboundTransfer(\n        address _l1Token,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) public payable returns (bytes memory) {\n        return outboundTransfer(_l1Token, _to, _amount, 0, 0, _data);\n    }\n\n    function setDefaultGateway(address newL2DefaultGateway) external onlyCounterpartGateway {\n        defaultGateway = newL2DefaultGateway;\n        emit DefaultGatewayUpdated(newL2DefaultGateway);\n    }\n}\n"

    },

    "@arbitrum/token-bridge-contracts/contracts/tokenbridge/arbitrum/gateway/L2CustomGateway.sol": {

      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity >=0.6.11;\n\nimport \"./L2ArbitrumGateway.sol\";\nimport \"../../libraries/gateway/ICustomGateway.sol\";\n\n// import \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract L2CustomGateway is L2ArbitrumGateway, ICustomGateway {\n    // stores addresses of L2 tokens to be used\n    mapping(address => address) public override l1ToL2Token;\n\n    function initialize(address _l1Counterpart, address _router) public {\n        L2ArbitrumGateway._initialize(_l1Counterpart, _router);\n    }\n\n    /**\n     * @notice internal utility function used to handle when no contract is deployed at expected address\n     */\n    function handleNoContract(\n        address _l1Token,\n        address, /* expectedL2Address */\n        address _from,\n        address, /* _to */\n        uint256 _amount,\n        bytes memory /* gatewayData */\n    ) internal override returns (bool shouldHalt) {\n        // it is assumed that the custom token is deployed in the L2 before deposits are made\n        // trigger withdrawal\n        // we don't need the return value from triggerWithdrawal since this is forcing a withdrawal back to the L1\n        // instead of composing with a L2 dapp\n        triggerWithdrawal(_l1Token, address(this), _from, _amount, \"\");\n        return true;\n    }\n\n    /**\n     * @notice Calculate the address used when bridging an ERC20 token\n     * @dev the L1 and L2 address oracles may not always be in sync.\n     * For example, a custom token may have been registered but not deploy or the contract self destructed.\n     * @param l1ERC20 address of L1 token\n     * @return L2 address of a bridged ERC20 token\n     */\n    function calculateL2TokenAddress(address l1ERC20) public view override returns (address) {\n        return l1ToL2Token[l1ERC20];\n    }\n\n    function registerTokenFromL1(address[] calldata l1Address, address[] calldata l2Address)\n        external\n        onlyCounterpartGateway\n    {\n        // we assume both arrays are the same length, safe since its encoded by the L1\n        for (uint256 i = 0; i < l1Address.length; i++) {\n            // here we don't check if l2Address is a contract and instead deal with that behaviour\n            // in `handleNoContract` this way we keep the l1 and l2 address oracles in sync\n            l1ToL2Token[l1Address[i]] = l2Address[i];\n            emit TokenSet(l1Address[i], l2Address[i]);\n        }\n    }\n}\n"

    },

    "@arbitrum/token-bridge-contracts/contracts/tokenbridge/arbitrum/gateway/L2ArbitrumGateway.sol": {

      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity >=0.6.11;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../../libraries/AddressAliasHelper.sol\";\nimport \"../../libraries/BytesLib.sol\";\nimport \"../../libraries/ProxyUtil.sol\";\n\nimport \"../IArbToken.sol\";\n\nimport \"../L2ArbitrumMessenger.sol\";\nimport \"../../libraries/gateway/GatewayMessageHandler.sol\";\nimport \"../../libraries/gateway/TokenGateway.sol\";\n\n/**\n * @title Common interface for gatways on Arbitrum messaging to L1.\n */\nabstract contract L2ArbitrumGateway is L2ArbitrumMessenger, TokenGateway {\n    using Address for address;\n\n    uint256 public exitNum;\n\n    event DepositFinalized(\n        address indexed l1Token,\n        address indexed _from,\n        address indexed _to,\n        uint256 _amount\n    );\n\n    event WithdrawalInitiated(\n        address l1Token,\n        address indexed _from,\n        address indexed _to,\n        uint256 indexed _l2ToL1Id,\n        uint256 _exitNum,\n        uint256 _amount\n    );\n\n    modifier onlyCounterpartGateway() override {\n        require(\n            msg.sender == AddressAliasHelper.applyL1ToL2Alias(counterpartGateway),\n            \"ONLY_COUNTERPART_GATEWAY\"\n        );\n        _;\n    }\n\n    function postUpgradeInit() external view {\n        // it is assumed the L2 Arbitrum Gateway contract is behind a Proxy controlled by a proxy admin\n        // this function can only be called by the proxy admin contract\n        address proxyAdmin = ProxyUtil.getProxyAdmin();\n        require(msg.sender == proxyAdmin, \"NOT_FROM_ADMIN\");\n        // this has no other logic since the current upgrade doesn't require this logic\n    }\n\n    function _initialize(address _l1Counterpart, address _router) internal override {\n        TokenGateway._initialize(_l1Counterpart, _router);\n        // L1 gateway must have a router\n        require(_router != address(0), \"BAD_ROUTER\");\n    }\n\n    function createOutboundTx(\n        address _from,\n        uint256, /* _tokenAmount */\n        bytes memory _outboundCalldata\n    ) internal virtual returns (uint256) {\n        // We make this function virtual since outboundTransfer logic is the same for many gateways\n        // but sometimes (ie weth) you construct the outgoing message differently.\n\n        // exitNum incremented after being included in _outboundCalldata\n        exitNum++;\n        return\n            sendTxToL1(\n                // default to sending no callvalue to the L1\n                0,\n                _from,\n                counterpartGateway,\n                _outboundCalldata\n            );\n    }\n\n    function getOutboundCalldata(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _data\n    ) public view override returns (bytes memory outboundCalldata) {\n        outboundCalldata = abi.encodeWithSelector(\n            ITokenGateway.finalizeInboundTransfer.selector,\n            _token,\n            _from,\n            _to,\n            _amount,\n            GatewayMessageHandler.encodeFromL2GatewayMsg(exitNum, _data)\n        );\n\n        return outboundCalldata;\n    }\n\n    function outboundTransfer(\n        address _l1Token,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) public payable returns (bytes memory) {\n        return outboundTransfer(_l1Token, _to, _amount, 0, 0, _data);\n    }\n\n    /**\n     * @notice Initiates a token withdrawal from Arbitrum to Ethereum\n     * @param _l1Token l1 address of token\n     * @param _to destination address\n     * @param _amount amount of tokens withdrawn\n     * @return res encoded unique identifier for withdrawal\n     */\n    function outboundTransfer(\n        address _l1Token,\n        address _to,\n        uint256 _amount,\n        uint256, /* _maxGas */\n        uint256, /* _gasPriceBid */\n        bytes calldata _data\n    ) public payable override returns (bytes memory res) {\n        // This function is set as public and virtual so that subclasses can override\n        // it and add custom validation for callers (ie only whitelisted users)\n\n        // the function is marked as payable to conform to the inheritance setup\n        // this particular code path shouldn't have a msg.value > 0\n        // TODO: remove this invariant for execution markets\n        require(msg.value == 0, \"NO_VALUE\");\n\n        address _from;\n        bytes memory _extraData;\n        {\n            if (isRouter(msg.sender)) {\n                (_from, _extraData) = GatewayMessageHandler.parseFromRouterToGateway(_data);\n            } else {\n                _from = msg.sender;\n                _extraData = _data;\n            }\n        }\n        // the inboundEscrowAndCall functionality has been disabled, so no data is allowed\n        require(_extraData.length == 0, \"EXTRA_DATA_DISABLED\");\n\n        uint256 id;\n        {\n            address l2Token = calculateL2TokenAddress(_l1Token);\n            require(l2Token.isContract(), \"TOKEN_NOT_DEPLOYED\");\n            require(IArbToken(l2Token).l1Address() == _l1Token, \"NOT_EXPECTED_L1_TOKEN\");\n\n            _amount = outboundEscrowTransfer(l2Token, _from, _amount);\n            id = triggerWithdrawal(_l1Token, _from, _to, _amount, _extraData);\n        }\n        return abi.encode(id);\n    }\n\n    function triggerWithdrawal(\n        address _l1Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory _data\n    ) internal returns (uint256) {\n        // exit number used for tradeable exits\n        uint256 currExitNum = exitNum;\n        // unique id used to identify the L2 to L1 tx\n        uint256 id = createOutboundTx(\n            _from,\n            _amount,\n            getOutboundCalldata(_l1Token, _from, _to, _amount, _data)\n        );\n        emit WithdrawalInitiated(_l1Token, _from, _to, id, currExitNum, _amount);\n        return id;\n    }\n\n    function outboundEscrowTransfer(\n        address _l2Token,\n        address _from,\n        uint256 _amount\n    ) internal virtual returns (uint256 amountBurnt) {\n        // this method is virtual since different subclasses can handle escrow differently\n        // user funds are escrowed on the gateway using this function\n        // burns L2 tokens in order to release escrowed L1 tokens\n        IArbToken(_l2Token).bridgeBurn(_from, _amount);\n        // by default we assume that the amount we send to bridgeBurn is the amount burnt\n        // this might not be the case for every token\n        return _amount;\n    }\n\n    function inboundEscrowTransfer(\n        address _l2Address,\n        address _dest,\n        uint256 _amount\n    ) internal virtual {\n        // this method is virtual since different subclasses can handle escrow differently\n        IArbToken(_l2Address).bridgeMint(_dest, _amount);\n    }\n\n    /**\n     * @notice Mint on L2 upon L1 deposit.\n     * If token not yet deployed and symbol/name/decimal data is included, deploys StandardArbERC20\n     * @dev Callable only by the L1ERC20Gateway.outboundTransfer method. For initial deployments of a token the L1 L1ERC20Gateway\n     * is expected to include the deployData. If not a L1 withdrawal is automatically triggered for the user\n     * @param _token L1 address of ERC20\n     * @param _from account that initiated the deposit in the L1\n     * @param _to account to be credited with the tokens in the L2 (can be the user's L2 account or a contract)\n     * @param _amount token amount to be minted to the user\n     * @param _data encoded symbol/name/decimal data for deploy, in addition to any additional callhook data\n     */\n    function finalizeInboundTransfer(\n        address _token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external payable override onlyCounterpartGateway {\n        (bytes memory gatewayData, bytes memory callHookData) = GatewayMessageHandler\n            .parseFromL1GatewayMsg(_data);\n\n        if (callHookData.length != 0) {\n            // callHookData should always be 0 since inboundEscrowAndCall is disabled\n            callHookData = bytes(\"\");\n        }\n\n        address expectedAddress = calculateL2TokenAddress(_token);\n\n        if (!expectedAddress.isContract()) {\n            bool shouldHalt = handleNoContract(\n                _token,\n                expectedAddress,\n                _from,\n                _to,\n                _amount,\n                gatewayData\n            );\n            if (shouldHalt) return;\n        }\n        // ignores gatewayData if token already deployed\n\n        {\n            // validate if L1 address supplied matches that of the expected L2 address\n            (bool success, bytes memory _l1AddressData) = expectedAddress.staticcall(\n                abi.encodeWithSelector(IArbToken.l1Address.selector)\n            );\n\n            bool shouldWithdraw;\n            if (!success || _l1AddressData.length < 32) {\n                shouldWithdraw = true;\n            } else {\n                // we do this in the else branch since we want to avoid reverts\n                // and `toAddress` reverts if _l1AddressData has a short length\n                // `_l1AddressData` should be 12 bytes of padding then 20 bytes for the address\n                address expectedL1Address = BytesLib.toAddress(_l1AddressData, 12);\n                if (expectedL1Address != _token) {\n                    shouldWithdraw = true;\n                }\n            }\n\n            if (shouldWithdraw) {\n                // we don't need the return value from triggerWithdrawal since this is forcing\n                // a withdrawal back to the L1 instead of composing with a L2 dapp\n                triggerWithdrawal(_token, address(this), _from, _amount, \"\");\n                return;\n            }\n        }\n\n        inboundEscrowTransfer(expectedAddress, _to, _amount);\n        emit DepositFinalized(_token, _from, _to, _amount);\n\n        return;\n    }\n\n    // returns if function should halt after\n    function handleNoContract(\n        address _l1Token,\n        address expectedL2Address,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes memory gatewayData\n    ) internal virtual returns (bool shouldHalt);\n}\n"

    },

    "@arbitrum/token-bridge-contracts/contracts/tokenbridge/arbitrum/L2ArbitrumMessenger.sol": {

      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity >=0.6.11;\n\nimport \"@arbitrum/nitro-contracts/src/precompiles/ArbSys.sol\";\n\n/// @notice L2 utility contract to assist with L1 <=> L2 interactions\n/// @dev this is an abstract contract instead of library so the functions can be easily overriden when testing\nabstract contract L2ArbitrumMessenger {\n    address internal constant ARB_SYS_ADDRESS = address(100);\n\n    event TxToL1(address indexed _from, address indexed _to, uint256 indexed _id, bytes _data);\n\n    function sendTxToL1(\n        uint256 _l1CallValue,\n        address _from,\n        address _to,\n        bytes memory _data\n    ) internal returns (uint256) {\n        uint256 _id = ArbSys(ARB_SYS_ADDRESS).sendTxToL1{ value: _l1CallValue }(_to, _data);\n        emit TxToL1(_from, _to, _id, _data);\n        return _id;\n    }\n}\n"

    },

    "@arbitrum/token-bridge-contracts/contracts/tokenbridge/arbitrum/IArbToken.sol": {

      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2020, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @title Minimum expected interface for L2 token that interacts with the L2 token bridge (this is the interface necessary\n * for a custom token that interacts with the bridge, see TestArbCustomToken.sol for an example implementation).\n */\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.6.9 <0.9.0;\n\ninterface IArbToken {\n    /**\n     * @notice should increase token supply by amount, and should (probably) only be callable by the L1 bridge.\n     */\n    function bridgeMint(address account, uint256 amount) external;\n\n    /**\n     * @notice should decrease token supply by amount, and should (probably) only be callable by the L1 bridge.\n     */\n    function bridgeBurn(address account, uint256 amount) external;\n\n    /**\n     * @return address of layer 1 token\n     */\n    function l1Address() external view returns (address);\n}\n"

    },

    "@arbitrum/nitro-contracts/src/precompiles/ArbSys.sol": {

      "content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/nitro/blob/master/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.4.21 <0.9.0;\n\n/**\n * @title System level functionality\n * @notice For use by contracts to interact with core L2-specific functionality.\n * Precompiled contract that exists in every Arbitrum chain at address(100), 0x0000000000000000000000000000000000000064.\n */\ninterface ArbSys {\n    /**\n     * @notice Get Arbitrum block number (distinct from L1 block number; Arbitrum genesis block has block number 0)\n     * @return block number as int\n     */\n    function arbBlockNumber() external view returns (uint256);\n\n    /**\n     * @notice Get Arbitrum block hash (reverts unless currentBlockNum-256 <= arbBlockNum < currentBlockNum)\n     * @return block hash\n     */\n    function arbBlockHash(uint256 arbBlockNum) external view returns (bytes32);\n\n    /**\n     * @notice Gets the rollup's unique chain identifier\n     * @return Chain identifier as int\n     */\n    function arbChainID() external view returns (uint256);\n\n    /**\n     * @notice Get internal version number identifying an ArbOS build\n     * @return version number as int\n     */\n    function arbOSVersion() external view returns (uint256);\n\n    /**\n     * @notice Returns 0 since Nitro has no concept of storage gas\n     * @return uint 0\n     */\n    function getStorageGasAvailable() external view returns (uint256);\n\n    /**\n     * @notice (deprecated) check if current call is top level (meaning it was triggered by an EoA or a L1 contract)\n     * @dev this call has been deprecated and may be removed in a future release\n     * @return true if current execution frame is not a call by another L2 contract\n     */\n    function isTopLevelCall() external view returns (bool);\n\n    /**\n     * @notice map L1 sender contract address to its L2 alias\n     * @param sender sender address\n     * @param unused argument no longer used\n     * @return aliased sender address\n     */\n    function mapL1SenderContractAddressToL2Alias(address sender, address unused)\n        external\n        pure\n        returns (address);\n\n    /**\n     * @notice check if the caller (of this caller of this) is an aliased L1 contract address\n     * @return true iff the caller's address is an alias for an L1 contract address\n     */\n    function wasMyCallersAddressAliased() external view returns (bool);\n\n    /**\n     * @notice return the address of the caller (of this caller of this), without applying L1 contract address aliasing\n     * @return address of the caller's caller, without applying L1 contract address aliasing\n     */\n    function myCallersAddressWithoutAliasing() external view returns (address);\n\n    /**\n     * @notice Send given amount of Eth to dest from sender.\n     * This is a convenience function, which is equivalent to calling sendTxToL1 with empty data.\n     * @param destination recipient address on L1\n     * @return unique identifier for this L2-to-L1 transaction.\n     */\n    function withdrawEth(address destination) external payable returns (uint256);\n\n    /**\n     * @notice Send a transaction to L1\n     * @dev it is not possible to execute on the L1 any L2-to-L1 transaction which contains data\n     * to a contract address without any code (as enforced by the Bridge contract).\n     * @param destination recipient address on L1\n     * @param data (optional) calldata for L1 contract call\n     * @return a unique identifier for this L2-to-L1 transaction.\n     */\n    function sendTxToL1(address destination, bytes calldata data)\n        external\n        payable\n        returns (uint256);\n\n    /**\n     * @notice Get send Merkle tree state\n     * @return size number of sends in the history\n     * @return root root hash of the send history\n     * @return partials hashes of partial subtrees in the send history tree\n     */\n    function sendMerkleTreeState()\n        external\n        view\n        returns (\n            uint256 size,\n            bytes32 root,\n            bytes32[] memory partials\n        );\n\n    /**\n     * @notice creates a send txn from L2 to L1\n     * @param position = (level << 192) + leaf = (0 << 192) + leaf = leaf\n     */\n    event L2ToL1Tx(\n        address caller,\n        address indexed destination,\n        uint256 indexed hash,\n        uint256 indexed position,\n        uint256 arbBlockNum,\n        uint256 ethBlockNum,\n        uint256 timestamp,\n        uint256 callvalue,\n        bytes data\n    );\n\n    /// @dev DEPRECATED in favour of the new L2ToL1Tx event above after the nitro upgrade\n    event L2ToL1Transaction(\n        address caller,\n        address indexed destination,\n        uint256 indexed uniqueId,\n        uint256 indexed batchNumber,\n        uint256 indexInBatch,\n        uint256 arbBlockNum,\n        uint256 ethBlockNum,\n        uint256 timestamp,\n        uint256 callvalue,\n        bytes data\n    );\n\n    /**\n     * @notice logs a merkle branch for proof synthesis\n     * @param reserved an index meant only to align the 4th index with L2ToL1Transaction's 4th event\n     * @param hash the merkle hash\n     * @param position = (level << 192) + leaf\n     */\n    event SendMerkleUpdate(\n        uint256 indexed reserved,\n        bytes32 indexed hash,\n        uint256 indexed position\n    );\n\n    error InvalidBlockNumber(uint256 requested, uint256 current);\n}\n"

    },

    "@arbitrum/nitro-contracts/src/libraries/IGasRefunder.sol": {

      "content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/nitro/blob/master/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.6.9 <0.9.0;\n\ninterface IGasRefunder {\n    function onGasSpent(\n        address payable spender,\n        uint256 gasUsed,\n        uint256 calldataSize\n    ) external returns (bool success);\n}\n\nabstract contract GasRefundEnabled {\n    /// @dev this refunds the sender for execution costs of the tx\n    /// calldata costs are only refunded if `msg.sender == tx.origin` to guarantee the value refunded relates to charging\n    /// for the `tx.input`. this avoids a possible attack where you generate large calldata from a contract and get over-refunded\n    modifier refundsGas(IGasRefunder gasRefunder) {\n        uint256 startGasLeft = gasleft();\n        _;\n        if (address(gasRefunder) != address(0)) {\n            uint256 calldataSize;\n            assembly {\n                calldataSize := calldatasize()\n            }\n            uint256 calldataWords = (calldataSize + 31) / 32;\n            // account for the CALLDATACOPY cost of the proxy contract, including the memory expansion cost\n            startGasLeft += calldataWords * 6 + (calldataWords**2) / 512;\n            // if triggered in a contract call, the spender may be overrefunded by appending dummy data to the call\n            // so we check if it is a top level call, which would mean the sender paid calldata as part of tx.input\n            // solhint-disable-next-line avoid-tx-origin\n            if (msg.sender != tx.origin) {\n                // We can't be sure if this calldata came from the top level tx,\n                // so to be safe we tell the gas refunder there was no calldata.\n                calldataSize = 0;\n            }\n            gasRefunder.onGasSpent(payable(msg.sender), startGasLeft - gasleft(), calldataSize);\n        }\n    }\n}\n"

    },

    "@arbitrum/nitro-contracts/src/bridge/ISequencerInbox.sol": {

      "content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/nitro/blob/master/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.6.9 <0.9.0;\npragma experimental ABIEncoderV2;\n\nimport \"../libraries/IGasRefunder.sol\";\nimport \"./IDelayedMessageProvider.sol\";\nimport \"./IBridge.sol\";\n\ninterface ISequencerInbox is IDelayedMessageProvider {\n    struct MaxTimeVariation {\n        uint256 delayBlocks;\n        uint256 futureBlocks;\n        uint256 delaySeconds;\n        uint256 futureSeconds;\n    }\n\n    struct TimeBounds {\n        uint64 minTimestamp;\n        uint64 maxTimestamp;\n        uint64 minBlockNumber;\n        uint64 maxBlockNumber;\n    }\n\n    enum BatchDataLocation {\n        TxInput,\n        SeparateBatchEvent,\n        NoData\n    }\n\n    event SequencerBatchDelivered(\n        uint256 indexed batchSequenceNumber,\n        bytes32 indexed beforeAcc,\n        bytes32 indexed afterAcc,\n        bytes32 delayedAcc,\n        uint256 afterDelayedMessagesRead,\n        TimeBounds timeBounds,\n        BatchDataLocation dataLocation\n    );\n\n    event OwnerFunctionCalled(uint256 indexed id);\n\n    /// @dev a separate event that emits batch data when this isn't easily accessible in the tx.input\n    event SequencerBatchData(uint256 indexed batchSequenceNumber, bytes data);\n\n    /// @dev a valid keyset was added\n    event SetValidKeyset(bytes32 indexed keysetHash, bytes keysetBytes);\n\n    /// @dev a keyset was invalidated\n    event InvalidateKeyset(bytes32 indexed keysetHash);\n\n    function totalDelayedMessagesRead() external view returns (uint256);\n\n    function bridge() external view returns (IBridge);\n\n    /// @dev The size of the batch header\n    // solhint-disable-next-line func-name-mixedcase\n    function HEADER_LENGTH() external view returns (uint256);\n\n    /// @dev If the first batch data byte after the header has this bit set,\n    ///      the sequencer inbox has authenticated the data. Currently not used.\n    // solhint-disable-next-line func-name-mixedcase\n    function DATA_AUTHENTICATED_FLAG() external view returns (bytes1);\n\n    function rollup() external view returns (IOwnable);\n\n    function isBatchPoster(address) external view returns (bool);\n\n    struct DasKeySetInfo {\n        bool isValidKeyset;\n        uint64 creationBlock;\n    }\n\n    // https://github.com/ethereum/solidity/issues/11826\n    // function maxTimeVariation() external view returns (MaxTimeVariation calldata);\n    // function dasKeySetInfo(bytes32) external view returns (DasKeySetInfo calldata);\n\n    /// @notice Remove force inclusion delay after a L1 chainId fork\n    function removeDelayAfterFork() external;\n\n    /// @notice Force messages from the delayed inbox to be included in the chain\n    ///         Callable by any address, but message can only be force-included after maxTimeVariation.delayBlocks and\n    ///         maxTimeVariation.delaySeconds has elapsed. As part of normal behaviour the sequencer will include these\n    ///         messages so it's only necessary to call this if the sequencer is down, or not including any delayed messages.\n    /// @param _totalDelayedMessagesRead The total number of messages to read up to\n    /// @param kind The kind of the last message to be included\n    /// @param l1BlockAndTime The l1 block and the l1 timestamp of the last message to be included\n    /// @param baseFeeL1 The l1 gas price of the last message to be included\n    /// @param sender The sender of the last message to be included\n    /// @param messageDataHash The messageDataHash of the last message to be included\n    function forceInclusion(\n        uint256 _totalDelayedMessagesRead,\n        uint8 kind,\n        uint64[2] calldata l1BlockAndTime,\n        uint256 baseFeeL1,\n        address sender,\n        bytes32 messageDataHash\n    ) external;\n\n    function inboxAccs(uint256 index) external view returns (bytes32);\n\n    function batchCount() external view returns (uint256);\n\n    function isValidKeysetHash(bytes32 ksHash) external view returns (bool);\n\n    /// @notice the creation block is intended to still be available after a keyset is deleted\n    function getKeysetCreationBlock(bytes32 ksHash) external view returns (uint256);\n\n    // ---------- BatchPoster functions ----------\n\n    function addSequencerL2BatchFromOrigin(\n        uint256 sequenceNumber,\n        bytes calldata data,\n        uint256 afterDelayedMessagesRead,\n        IGasRefunder gasRefunder\n    ) external;\n\n    function addSequencerL2Batch(\n        uint256 sequenceNumber,\n        bytes calldata data,\n        uint256 afterDelayedMessagesRead,\n        IGasRefunder gasRefunder,\n        uint256 prevMessageCount,\n        uint256 newMessageCount\n    ) external;\n\n    // ---------- onlyRollupOrOwner functions ----------\n\n    /**\n     * @notice Set max delay for sequencer inbox\n     * @param maxTimeVariation_ the maximum time variation parameters\n     */\n    function setMaxTimeVariation(MaxTimeVariation memory maxTimeVariation_) external;\n\n    /**\n     * @notice Updates whether an address is authorized to be a batch poster at the sequencer inbox\n     * @param addr the address\n     * @param isBatchPoster_ if the specified address should be authorized as a batch poster\n     */\n    function setIsBatchPoster(address addr, bool isBatchPoster_) external;\n\n    /**\n     * @notice Makes Data Availability Service keyset valid\n     * @param keysetBytes bytes of the serialized keyset\n     */\n    function setValidKeyset(bytes calldata keysetBytes) external;\n\n    /**\n     * @notice Invalidates a Data Availability Service keyset\n     * @param ksHash hash of the keyset\n     */\n    function invalidateKeysetHash(bytes32 ksHash) external;\n\n    // ---------- initializer ----------\n\n    function initialize(IBridge bridge_, MaxTimeVariation calldata maxTimeVariation_) external;\n}\n"

    },

    "@arbitrum/nitro-contracts/src/bridge/IOwnable.sol": {

      "content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/nitro/blob/master/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.4.21 <0.9.0;\n\ninterface IOwnable {\n    function owner() external view returns (address);\n}\n"

    },

    "@arbitrum/nitro-contracts/src/bridge/IOutbox.sol": {

      "content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/nitro/blob/master/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.6.9 <0.9.0;\n\nimport \"./IBridge.sol\";\n\ninterface IOutbox {\n    event SendRootUpdated(bytes32 indexed outputRoot, bytes32 indexed l2BlockHash);\n    event OutBoxTransactionExecuted(\n        address indexed to,\n        address indexed l2Sender,\n        uint256 indexed zero,\n        uint256 transactionIndex\n    );\n\n    function rollup() external view returns (address); // the rollup contract\n\n    function bridge() external view returns (IBridge); // the bridge contract\n\n    function spent(uint256) external view returns (bytes32); // packed spent bitmap\n\n    function roots(bytes32) external view returns (bytes32); // maps root hashes => L2 block hash\n\n    // solhint-disable-next-line func-name-mixedcase\n    function OUTBOX_VERSION() external view returns (uint128); // the outbox version\n\n    function updateSendRoot(bytes32 sendRoot, bytes32 l2BlockHash) external;\n\n    /// @notice When l2ToL1Sender returns a nonzero address, the message was originated by an L2 account\n    ///         When the return value is zero, that means this is a system message\n    /// @dev the l2ToL1Sender behaves as the tx.origin, the msg.sender should be validated to protect against reentrancies\n    function l2ToL1Sender() external view returns (address);\n\n    /// @return l2Block return L2 block when the L2 tx was initiated or 0 if no L2 to L1 transaction is active\n    function l2ToL1Block() external view returns (uint256);\n\n    /// @return l1Block return L1 block when the L2 tx was initiated or 0 if no L2 to L1 transaction is active\n    function l2ToL1EthBlock() external view returns (uint256);\n\n    /// @return timestamp return L2 timestamp when the L2 tx was initiated or 0 if no L2 to L1 transaction is active\n    function l2ToL1Timestamp() external view returns (uint256);\n\n    /// @return outputId returns the unique output identifier of the L2 to L1 tx or 0 if no L2 to L1 transaction is active\n    function l2ToL1OutputId() external view returns (bytes32);\n\n    /**\n     * @notice Executes a messages in an Outbox entry.\n     * @dev Reverts if dispute period hasn't expired, since the outbox entry\n     *      is only created once the rollup confirms the respective assertion.\n     * @dev it is not possible to execute any L2-to-L1 transaction which contains data\n     *      to a contract address without any code (as enforced by the Bridge contract).\n     * @param proof Merkle proof of message inclusion in send root\n     * @param index Merkle path to message\n     * @param l2Sender sender if original message (i.e., caller of ArbSys.sendTxToL1)\n     * @param to destination address for L1 contract call\n     * @param l2Block l2 block number at which sendTxToL1 call was made\n     * @param l1Block l1 block number at which sendTxToL1 call was made\n     * @param l2Timestamp l2 Timestamp at which sendTxToL1 call was made\n     * @param value wei in L1 message\n     * @param data abi-encoded L1 message data\n     */\n    function executeTransaction(\n        bytes32[] calldata proof,\n        uint256 index,\n        address l2Sender,\n        address to,\n        uint256 l2Block,\n        uint256 l1Block,\n        uint256 l2Timestamp,\n        uint256 value,\n        bytes calldata data\n    ) external;\n\n    /**\n     *  @dev function used to simulate the result of a particular function call from the outbox\n     *       it is useful for things such as gas estimates. This function includes all costs except for\n     *       proof validation (which can be considered offchain as a somewhat of a fixed cost - it's\n     *       not really a fixed cost, but can be treated as so with a fixed overhead for gas estimation).\n     *       We can't include the cost of proof validation since this is intended to be used to simulate txs\n     *       that are included in yet-to-be confirmed merkle roots. The simulation entrypoint could instead pretend\n     *       to confirm a pending merkle root, but that would be less practical for integrating with tooling.\n     *       It is only possible to trigger it when the msg sender is address zero, which should be impossible\n     *       unless under simulation in an eth_call or eth_estimateGas\n     */\n    function executeTransactionSimulation(\n        uint256 index,\n        address l2Sender,\n        address to,\n        uint256 l2Block,\n        uint256 l1Block,\n        uint256 l2Timestamp,\n        uint256 value,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @param index Merkle path to message\n     * @return true if the message has been spent\n     */\n    function isSpent(uint256 index) external view returns (bool);\n\n    function calculateItemHash(\n        address l2Sender,\n        address to,\n        uint256 l2Block,\n        uint256 l1Block,\n        uint256 l2Timestamp,\n        uint256 value,\n        bytes calldata data\n    ) external pure returns (bytes32);\n\n    function calculateMerkleRoot(\n        bytes32[] memory proof,\n        uint256 path,\n        bytes32 item\n    ) external pure returns (bytes32);\n}\n"

    },

    "@arbitrum/nitro-contracts/src/bridge/IInbox.sol": {

      "content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/nitro/blob/master/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.6.9 <0.9.0;\n\nimport \"./IBridge.sol\";\nimport \"./IDelayedMessageProvider.sol\";\nimport \"./ISequencerInbox.sol\";\n\ninterface IInbox is IDelayedMessageProvider {\n    function bridge() external view returns (IBridge);\n\n    function sequencerInbox() external view returns (ISequencerInbox);\n\n    /**\n     * @notice Send a generic L2 message to the chain\n     * @dev This method is an optimization to avoid having to emit the entirety of the messageData in a log. Instead validators are expected to be able to parse the data from the transaction's input\n     *      This method will be disabled upon L1 fork to prevent replay attacks on L2\n     * @param messageData Data of the message being sent\n     */\n    function sendL2MessageFromOrigin(bytes calldata messageData) external returns (uint256);\n\n    /**\n     * @notice Send a generic L2 message to the chain\n     * @dev This method can be used to send any type of message that doesn't require L1 validation\n     *      This method will be disabled upon L1 fork to prevent replay attacks on L2\n     * @param messageData Data of the message being sent\n     */\n    function sendL2Message(bytes calldata messageData) external returns (uint256);\n\n    function sendL1FundedUnsignedTransaction(\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        uint256 nonce,\n        address to,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    function sendL1FundedContractTransaction(\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        address to,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    function sendUnsignedTransaction(\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        uint256 nonce,\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external returns (uint256);\n\n    function sendContractTransaction(\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external returns (uint256);\n\n    /**\n     * @dev This method can only be called upon L1 fork and will not alias the caller\n     *      This method will revert if not called from origin\n     */\n    function sendL1FundedUnsignedTransactionToFork(\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        uint256 nonce,\n        address to,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    /**\n     * @dev This method can only be called upon L1 fork and will not alias the caller\n     *      This method will revert if not called from origin\n     */\n    function sendUnsignedTransactionToFork(\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        uint256 nonce,\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external returns (uint256);\n\n    /**\n     * @notice Send a message to initiate L2 withdrawal\n     * @dev This method can only be called upon L1 fork and will not alias the caller\n     *      This method will revert if not called from origin\n     */\n    function sendWithdrawEthToFork(\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        uint256 nonce,\n        uint256 value,\n        address withdrawTo\n    ) external returns (uint256);\n\n    /**\n     * @notice Get the L1 fee for submitting a retryable\n     * @dev This fee can be paid by funds already in the L2 aliased address or by the current message value\n     * @dev This formula may change in the future, to future proof your code query this method instead of inlining!!\n     * @param dataLength The length of the retryable's calldata, in bytes\n     * @param baseFee The block basefee when the retryable is included in the chain, if 0 current block.basefee will be used\n     */\n    function calculateRetryableSubmissionFee(uint256 dataLength, uint256 baseFee)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @notice Deposit eth from L1 to L2 to address of the sender if sender is an EOA, and to its aliased address if the sender is a contract\n     * @dev This does not trigger the fallback function when receiving in the L2 side.\n     *      Look into retryable tickets if you are interested in this functionality.\n     * @dev This function should not be called inside contract constructors\n     */\n    function depositEth() external payable returns (uint256);\n\n    /**\n     * @notice Put a message in the L2 inbox that can be reexecuted for some fixed amount of time if it reverts\n     * @dev all msg.value will deposited to callValueRefundAddress on L2\n     * @dev Gas limit and maxFeePerGas should not be set to 1 as that is used to trigger the RetryableData error\n     * @param to destination L2 contract address\n     * @param l2CallValue call value for retryable L2 message\n     * @param maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\n     * @param excessFeeRefundAddress gasLimit x maxFeePerGas - execution cost gets credited here on L2 balance\n     * @param callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\n     * @param gasLimit Max gas deducted from user's L2 balance to cover L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\n     * @param maxFeePerGas price bid for L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\n     * @param data ABI encoded data of L2 message\n     * @return unique message number of the retryable transaction\n     */\n    function createRetryableTicket(\n        address to,\n        uint256 l2CallValue,\n        uint256 maxSubmissionCost,\n        address excessFeeRefundAddress,\n        address callValueRefundAddress,\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    /**\n     * @notice Put a message in the L2 inbox that can be reexecuted for some fixed amount of time if it reverts\n     * @dev Same as createRetryableTicket, but does not guarantee that submission will succeed by requiring the needed funds\n     * come from the deposit alone, rather than falling back on the user's L2 balance\n     * @dev Advanced usage only (does not rewrite aliases for excessFeeRefundAddress and callValueRefundAddress).\n     * createRetryableTicket method is the recommended standard.\n     * @dev Gas limit and maxFeePerGas should not be set to 1 as that is used to trigger the RetryableData error\n     * @param to destination L2 contract address\n     * @param l2CallValue call value for retryable L2 message\n     * @param maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\n     * @param excessFeeRefundAddress gasLimit x maxFeePerGas - execution cost gets credited here on L2 balance\n     * @param callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\n     * @param gasLimit Max gas deducted from user's L2 balance to cover L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\n     * @param maxFeePerGas price bid for L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\n     * @param data ABI encoded data of L2 message\n     * @return unique message number of the retryable transaction\n     */\n    function unsafeCreateRetryableTicket(\n        address to,\n        uint256 l2CallValue,\n        uint256 maxSubmissionCost,\n        address excessFeeRefundAddress,\n        address callValueRefundAddress,\n        uint256 gasLimit,\n        uint256 maxFeePerGas,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    // ---------- onlyRollupOrOwner functions ----------\n\n    /// @notice pauses all inbox functionality\n    function pause() external;\n\n    /// @notice unpauses all inbox functionality\n    function unpause() external;\n\n    // ---------- initializer ----------\n\n    /**\n     * @dev function to be called one time during the inbox upgrade process\n     *      this is used to fix the storage slots\n     */\n    function postUpgradeInit(IBridge _bridge) external;\n\n    function initialize(IBridge _bridge, ISequencerInbox _sequencerInbox) external;\n}\n"

    },

    "@arbitrum/nitro-contracts/src/bridge/IDelayedMessageProvider.sol": {

      "content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/nitro/blob/master/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.6.9 <0.9.0;\n\ninterface IDelayedMessageProvider {\n    /// @dev event emitted when a inbox message is added to the Bridge's delayed accumulator\n    event InboxMessageDelivered(uint256 indexed messageNum, bytes data);\n\n    /// @dev event emitted when a inbox message is added to the Bridge's delayed accumulator\n    /// same as InboxMessageDelivered but the batch data is available in tx.input\n    event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum);\n}\n"

    },

    "@arbitrum/nitro-contracts/src/bridge/IBridge.sol": {

      "content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/nitro/blob/master/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.6.9 <0.9.0;\n\nimport \"./IOwnable.sol\";\n\ninterface IBridge {\n    event MessageDelivered(\n        uint256 indexed messageIndex,\n        bytes32 indexed beforeInboxAcc,\n        address inbox,\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash,\n        uint256 baseFeeL1,\n        uint64 timestamp\n    );\n\n    event BridgeCallTriggered(\n        address indexed outbox,\n        address indexed to,\n        uint256 value,\n        bytes data\n    );\n\n    event InboxToggle(address indexed inbox, bool enabled);\n\n    event OutboxToggle(address indexed outbox, bool enabled);\n\n    event SequencerInboxUpdated(address newSequencerInbox);\n\n    function allowedDelayedInboxList(uint256) external returns (address);\n\n    function allowedOutboxList(uint256) external returns (address);\n\n    /// @dev Accumulator for delayed inbox messages; tail represents hash of the current state; each element represents the inclusion of a new message.\n    function delayedInboxAccs(uint256) external view returns (bytes32);\n\n    /// @dev Accumulator for sequencer inbox messages; tail represents hash of the current state; each element represents the inclusion of a new message.\n    function sequencerInboxAccs(uint256) external view returns (bytes32);\n\n    function rollup() external view returns (IOwnable);\n\n    function sequencerInbox() external view returns (address);\n\n    function activeOutbox() external view returns (address);\n\n    function allowedDelayedInboxes(address inbox) external view returns (bool);\n\n    function allowedOutboxes(address outbox) external view returns (bool);\n\n    function sequencerReportedSubMessageCount() external view returns (uint256);\n\n    /**\n     * @dev Enqueue a message in the delayed inbox accumulator.\n     *      These messages are later sequenced in the SequencerInbox, either\n     *      by the sequencer as part of a normal batch, or by force inclusion.\n     */\n    function enqueueDelayedMessage(\n        uint8 kind,\n        address sender,\n        bytes32 messageDataHash\n    ) external payable returns (uint256);\n\n    function executeCall(\n        address to,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bool success, bytes memory returnData);\n\n    function delayedMessageCount() external view returns (uint256);\n\n    function sequencerMessageCount() external view returns (uint256);\n\n    // ---------- onlySequencerInbox functions ----------\n\n    function enqueueSequencerMessage(\n        bytes32 dataHash,\n        uint256 afterDelayedMessagesRead,\n        uint256 prevMessageCount,\n        uint256 newMessageCount\n    )\n        external\n        returns (\n            uint256 seqMessageIndex,\n            bytes32 beforeAcc,\n            bytes32 delayedAcc,\n            bytes32 acc\n        );\n\n    /**\n     * @dev Allows the sequencer inbox to submit a delayed message of the batchPostingReport type\n     *      This is done through a separate function entrypoint instead of allowing the sequencer inbox\n     *      to call `enqueueDelayedMessage` to avoid the gas overhead of an extra SLOAD in either\n     *      every delayed inbox or every sequencer inbox call.\n     */\n    function submitBatchSpendingReport(address batchPoster, bytes32 dataHash)\n        external\n        returns (uint256 msgNum);\n\n    // ---------- onlyRollupOrOwner functions ----------\n\n    function setSequencerInbox(address _sequencerInbox) external;\n\n    function setDelayedInbox(address inbox, bool enabled) external;\n\n    function setOutbox(address inbox, bool enabled) external;\n\n    // ---------- initializer ----------\n\n    function initialize(IOwnable rollup_) external;\n}\n"

    }

  },

  "settings": {

    "remappings": [],

    "optimizer": {

      "enabled": true,

      "runs": 200

    },

    "evmVersion": "shanghai",

    "libraries": {},

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    }

  }

}}