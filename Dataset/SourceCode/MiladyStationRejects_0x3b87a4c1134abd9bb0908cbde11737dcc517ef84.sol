/**

 *Submitted for verification at Etherscan.io on 2023-05-15

*/



// File: solady/utils/LibString.sol





pragma solidity ^0.8.4;



/// @notice Library for converting numbers into strings and other string operations.

/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)

/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)

library LibString {

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                        CUSTOM ERRORS                       */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev The `length` of the output is too small to contain all the hex digits.

    error HexLengthInsufficient();



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                         CONSTANTS                          */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev The constant returned when the `search` is not found in the string.

    uint256 internal constant NOT_FOUND = type(uint256).max;



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                     DECIMAL OPERATIONS                     */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Returns the base 10 decimal representation of `value`.

    function toString(uint256 value) internal pure returns (string memory str) {

        /// @solidity memory-safe-assembly

        assembly {

            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but

            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.

            // We will need 1 word for the trailing zeros padding, 1 word for the length,

            // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.

            let m := add(mload(0x40), 0xa0)

            // Update the free memory pointer to allocate.

            mstore(0x40, m)

            // Assign the `str` to the end.

            str := sub(m, 0x20)

            // Zeroize the slot after the string.

            mstore(str, 0)



            // Cache the end of the memory to calculate the length later.

            let end := str



            // We write the string from rightmost digit to leftmost digit.

            // The following is essentially a do-while loop that also handles the zero case.

            for { let temp := value } 1 {} {

                str := sub(str, 1)

                // Write the character to the pointer.

                // The ASCII index of the '0' character is 48.

                mstore8(str, add(48, mod(temp, 10)))

                // Keep dividing `temp` until zero.

                temp := div(temp, 10)

                if iszero(temp) { break }

            }



            let length := sub(end, str)

            // Move the pointer 32 bytes leftwards to make room for the length.

            str := sub(str, 0x20)

            // Store the length.

            mstore(str, length)

        }

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                   HEXADECIMAL OPERATIONS                   */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Returns the hexadecimal representation of `value`,

    /// left-padded to an input length of `length` bytes.

    /// The output is prefixed with "0x" encoded using 2 hexadecimal digits per byte,

    /// giving a total length of `length * 2 + 2` bytes.

    /// Reverts if `length` is too small for the output to contain all the digits.

    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {

        str = toHexStringNoPrefix(value, length);

        /// @solidity memory-safe-assembly

        assembly {

            let strLength := add(mload(str), 2) // Compute the length.

            mstore(str, 0x3078) // Write the "0x" prefix.

            str := sub(str, 2) // Move the pointer.

            mstore(str, strLength) // Write the length.

        }

    }



    /// @dev Returns the hexadecimal representation of `value`,

    /// left-padded to an input length of `length` bytes.

    /// The output is prefixed with "0x" encoded using 2 hexadecimal digits per byte,

    /// giving a total length of `length * 2` bytes.

    /// Reverts if `length` is too small for the output to contain all the digits.

    function toHexStringNoPrefix(uint256 value, uint256 length)

        internal

        pure

        returns (string memory str)

    {

        /// @solidity memory-safe-assembly

        assembly {

            let start := mload(0x40)

            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes

            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.

            // We add 0x20 to the total and round down to a multiple of 0x20.

            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.

            let m := add(start, and(add(shl(1, length), 0x62), not(0x1f)))

            // Allocate the memory.

            mstore(0x40, m)

            // Assign the `str` to the end.

            str := sub(m, 0x20)

            // Zeroize the slot after the string.

            mstore(str, 0)



            // Cache the end to calculate the length later.

            let end := str

            // Store "0123456789abcdef" in scratch space.

            mstore(0x0f, 0x30313233343536373839616263646566)



            let temp := value

            // We write the string from rightmost digit to leftmost digit.

            // The following is essentially a do-while loop that also handles the zero case.

            for {} 1 {} {

                str := sub(str, 2)

                mstore8(add(str, 1), mload(and(temp, 15)))

                mstore8(str, mload(and(shr(4, temp), 15)))

                temp := shr(8, temp)

                length := sub(length, 1)

                if iszero(length) { break }

            }



            if temp {

                // Store the function selector of `HexLengthInsufficient()`.

                mstore(0x00, 0x2194895a)

                // Revert with (offset, size).

                revert(0x1c, 0x04)

            }



            // Compute the string's length.

            let strLength := sub(end, str)

            // Move the pointer and write the length.

            str := sub(str, 0x20)

            mstore(str, strLength)

        }

    }



    /// @dev Returns the hexadecimal representation of `value`.

    /// The output is prefixed with "0x" and encoded using 2 hexadecimal digits per byte.

    /// As address are 20 bytes long, the output will left-padded to have

    /// a length of `20 * 2 + 2` bytes.

    function toHexString(uint256 value) internal pure returns (string memory str) {

        str = toHexStringNoPrefix(value);

        /// @solidity memory-safe-assembly

        assembly {

            let strLength := add(mload(str), 2) // Compute the length.

            mstore(str, 0x3078) // Write the "0x" prefix.

            str := sub(str, 2) // Move the pointer.

            mstore(str, strLength) // Write the length.

        }

    }



    /// @dev Returns the hexadecimal representation of `value`.

    /// The output is encoded using 2 hexadecimal digits per byte.

    /// As address are 20 bytes long, the output will left-padded to have

    /// a length of `20 * 2` bytes.

    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {

        /// @solidity memory-safe-assembly

        assembly {

            let start := mload(0x40)

            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,

            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.

            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.

            let m := add(start, 0xa0)

            // Allocate the memory.

            mstore(0x40, m)

            // Assign the `str` to the end.

            str := sub(m, 0x20)

            // Zeroize the slot after the string.

            mstore(str, 0)



            // Cache the end to calculate the length later.

            let end := str

            // Store "0123456789abcdef" in scratch space.

            mstore(0x0f, 0x30313233343536373839616263646566)



            // We write the string from rightmost digit to leftmost digit.

            // The following is essentially a do-while loop that also handles the zero case.

            for { let temp := value } 1 {} {

                str := sub(str, 2)

                mstore8(add(str, 1), mload(and(temp, 15)))

                mstore8(str, mload(and(shr(4, temp), 15)))

                temp := shr(8, temp)

                if iszero(temp) { break }

            }



            // Compute the string's length.

            let strLength := sub(end, str)

            // Move the pointer and write the length.

            str := sub(str, 0x20)

            mstore(str, strLength)

        }

    }



    /// @dev Returns the hexadecimal representation of `value`.

    /// The output is prefixed with "0x", encoded using 2 hexadecimal digits per byte,

    /// and the alphabets are capitalized conditionally according to

    /// https://eips.ethereum.org/EIPS/eip-55

    function toHexStringChecksumed(address value) internal pure returns (string memory str) {

        str = toHexString(value);

        /// @solidity memory-safe-assembly

        assembly {

            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`

            let o := add(str, 0x22)

            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `

            let t := shl(240, 136) // `0b10001000 << 240`

            for { let i := 0 } 1 {} {

                mstore(add(i, i), mul(t, byte(i, hashed)))

                i := add(i, 1)

                if eq(i, 20) { break }

            }

            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))

            o := add(o, 0x20)

            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))

        }

    }



    /// @dev Returns the hexadecimal representation of `value`.

    /// The output is prefixed with "0x" and encoded using 2 hexadecimal digits per byte.

    function toHexString(address value) internal pure returns (string memory str) {

        str = toHexStringNoPrefix(value);

        /// @solidity memory-safe-assembly

        assembly {

            let strLength := add(mload(str), 2) // Compute the length.

            mstore(str, 0x3078) // Write the "0x" prefix.

            str := sub(str, 2) // Move the pointer.

            mstore(str, strLength) // Write the length.

        }

    }



    /// @dev Returns the hexadecimal representation of `value`.

    /// The output is encoded using 2 hexadecimal digits per byte.

    function toHexStringNoPrefix(address value) internal pure returns (string memory str) {

        /// @solidity memory-safe-assembly

        assembly {

            str := mload(0x40)



            // Allocate the memory.

            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,

            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.

            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.

            mstore(0x40, add(str, 0x80))



            // Store "0123456789abcdef" in scratch space.

            mstore(0x0f, 0x30313233343536373839616263646566)



            str := add(str, 2)

            mstore(str, 40)



            let o := add(str, 0x20)

            mstore(add(o, 40), 0)



            value := shl(96, value)



            // We write the string from rightmost digit to leftmost digit.

            // The following is essentially a do-while loop that also handles the zero case.

            for { let i := 0 } 1 {} {

                let p := add(o, add(i, i))

                let temp := byte(i, value)

                mstore8(add(p, 1), mload(and(temp, 15)))

                mstore8(p, mload(shr(4, temp)))

                i := add(i, 1)

                if eq(i, 20) { break }

            }

        }

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                   RUNE STRING OPERATIONS                   */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Returns the number of UTF characters in the string.

    function runeCount(string memory s) internal pure returns (uint256 result) {

        /// @solidity memory-safe-assembly

        assembly {

            if mload(s) {

                mstore(0x00, div(not(0), 255))

                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)

                let o := add(s, 0x20)

                let end := add(o, mload(s))

                for { result := 1 } 1 { result := add(result, 1) } {

                    o := add(o, byte(0, mload(shr(250, mload(o)))))

                    if iszero(lt(o, end)) { break }

                }

            }

        }

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                   BYTE STRING OPERATIONS                   */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    // For performance and bytecode compactness, all indices of the following operations

    // are byte (ASCII) offsets, not UTF character offsets.



    /// @dev Returns `subject` all occurrences of `search` replaced with `replacement`.

    function replace(string memory subject, string memory search, string memory replacement)

        internal

        pure

        returns (string memory result)

    {

        /// @solidity memory-safe-assembly

        assembly {

            let subjectLength := mload(subject)

            let searchLength := mload(search)

            let replacementLength := mload(replacement)



            subject := add(subject, 0x20)

            search := add(search, 0x20)

            replacement := add(replacement, 0x20)

            result := add(mload(0x40), 0x20)



            let subjectEnd := add(subject, subjectLength)

            if iszero(gt(searchLength, subjectLength)) {

                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)

                let h := 0

                if iszero(lt(searchLength, 32)) { h := keccak256(search, searchLength) }

                let m := shl(3, sub(32, and(searchLength, 31)))

                let s := mload(search)

                for {} 1 {} {

                    let t := mload(subject)

                    // Whether the first `searchLength % 32` bytes of

                    // `subject` and `search` matches.

                    if iszero(shr(m, xor(t, s))) {

                        if h {

                            if iszero(eq(keccak256(subject, searchLength), h)) {

                                mstore(result, t)

                                result := add(result, 1)

                                subject := add(subject, 1)

                                if iszero(lt(subject, subjectSearchEnd)) { break }

                                continue

                            }

                        }

                        // Copy the `replacement` one word at a time.

                        for { let o := 0 } 1 {} {

                            mstore(add(result, o), mload(add(replacement, o)))

                            o := add(o, 0x20)

                            if iszero(lt(o, replacementLength)) { break }

                        }

                        result := add(result, replacementLength)

                        subject := add(subject, searchLength)

                        if searchLength {

                            if iszero(lt(subject, subjectSearchEnd)) { break }

                            continue

                        }

                    }

                    mstore(result, t)

                    result := add(result, 1)

                    subject := add(subject, 1)

                    if iszero(lt(subject, subjectSearchEnd)) { break }

                }

            }



            let resultRemainder := result

            result := add(mload(0x40), 0x20)

            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))

            // Copy the rest of the string one word at a time.

            for {} lt(subject, subjectEnd) {} {

                mstore(resultRemainder, mload(subject))

                resultRemainder := add(resultRemainder, 0x20)

                subject := add(subject, 0x20)

            }

            result := sub(result, 0x20)

            // Zeroize the slot after the string.

            let last := add(add(result, 0x20), k)

            mstore(last, 0)

            // Allocate memory for the length and the bytes,

            // rounded up to a multiple of 32.

            mstore(0x40, and(add(last, 31), not(31)))

            // Store the length of the result.

            mstore(result, k)

        }

    }



    /// @dev Returns the byte index of the first location of `search` in `subject`,

    /// searching from left to right, starting from `from`.

    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.

    function indexOf(string memory subject, string memory search, uint256 from)

        internal

        pure

        returns (uint256 result)

    {

        /// @solidity memory-safe-assembly

        assembly {

            for { let subjectLength := mload(subject) } 1 {} {

                if iszero(mload(search)) {

                    // `result = min(from, subjectLength)`.

                    result := xor(from, mul(xor(from, subjectLength), lt(subjectLength, from)))

                    break

                }

                let searchLength := mload(search)

                let subjectStart := add(subject, 0x20)



                result := not(0) // Initialize to `NOT_FOUND`.



                subject := add(subjectStart, from)

                let subjectSearchEnd := add(sub(add(subjectStart, subjectLength), searchLength), 1)



                let m := shl(3, sub(32, and(searchLength, 31)))

                let s := mload(add(search, 0x20))



                if iszero(lt(subject, subjectSearchEnd)) { break }



                if iszero(lt(searchLength, 32)) {

                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {

                        if iszero(shr(m, xor(mload(subject), s))) {

                            if eq(keccak256(subject, searchLength), h) {

                                result := sub(subject, subjectStart)

                                break

                            }

                        }

                        subject := add(subject, 1)

                        if iszero(lt(subject, subjectSearchEnd)) { break }

                    }

                    break

                }

                for {} 1 {} {

                    if iszero(shr(m, xor(mload(subject), s))) {

                        result := sub(subject, subjectStart)

                        break

                    }

                    subject := add(subject, 1)

                    if iszero(lt(subject, subjectSearchEnd)) { break }

                }

                break

            }

        }

    }



    /// @dev Returns the byte index of the first location of `search` in `subject`,

    /// searching from left to right.

    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.

    function indexOf(string memory subject, string memory search)

        internal

        pure

        returns (uint256 result)

    {

        result = indexOf(subject, search, 0);

    }



    /// @dev Returns the byte index of the first location of `search` in `subject`,

    /// searching from right to left, starting from `from`.

    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.

    function lastIndexOf(string memory subject, string memory search, uint256 from)

        internal

        pure

        returns (uint256 result)

    {

        /// @solidity memory-safe-assembly

        assembly {

            for {} 1 {} {

                let searchLength := mload(search)

                let fromMax := sub(mload(subject), searchLength)

                if iszero(gt(fromMax, from)) { from := fromMax }

                if iszero(mload(search)) {

                    result := from

                    break

                }

                result := not(0) // Initialize to `NOT_FOUND`.



                let subjectSearchEnd := sub(add(subject, 0x20), 1)



                subject := add(add(subject, 0x20), from)

                if iszero(gt(subject, subjectSearchEnd)) { break }

                // As this function is not too often used,

                // we shall simply use keccak256 for smaller bytecode size.

                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {

                    if eq(keccak256(subject, searchLength), h) {

                        result := sub(subject, add(subjectSearchEnd, 1))

                        break

                    }

                    subject := sub(subject, 1)

                    if iszero(gt(subject, subjectSearchEnd)) { break }

                }

                break

            }

        }

    }



    /// @dev Returns the byte index of the first location of `search` in `subject`,

    /// searching from right to left.

    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.

    function lastIndexOf(string memory subject, string memory search)

        internal

        pure

        returns (uint256 result)

    {

        result = lastIndexOf(subject, search, uint256(int256(-1)));

    }



    /// @dev Returns whether `subject` starts with `search`.

    function startsWith(string memory subject, string memory search)

        internal

        pure

        returns (bool result)

    {

        /// @solidity memory-safe-assembly

        assembly {

            let searchLength := mload(search)

            // Just using keccak256 directly is actually cheaper.

            // forgefmt: disable-next-item

            result := and(

                iszero(gt(searchLength, mload(subject))),

                eq(

                    keccak256(add(subject, 0x20), searchLength),

                    keccak256(add(search, 0x20), searchLength)

                )

            )

        }

    }



    /// @dev Returns whether `subject` ends with `search`.

    function endsWith(string memory subject, string memory search)

        internal

        pure

        returns (bool result)

    {

        /// @solidity memory-safe-assembly

        assembly {

            let searchLength := mload(search)

            let subjectLength := mload(subject)

            // Whether `search` is not longer than `subject`.

            let withinRange := iszero(gt(searchLength, subjectLength))

            // Just using keccak256 directly is actually cheaper.

            // forgefmt: disable-next-item

            result := and(

                withinRange,

                eq(

                    keccak256(

                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.

                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),

                        searchLength

                    ),

                    keccak256(add(search, 0x20), searchLength)

                )

            )

        }

    }



    /// @dev Returns `subject` repeated `times`.

    function repeat(string memory subject, uint256 times)

        internal

        pure

        returns (string memory result)

    {

        /// @solidity memory-safe-assembly

        assembly {

            let subjectLength := mload(subject)

            if iszero(or(iszero(times), iszero(subjectLength))) {

                subject := add(subject, 0x20)

                result := mload(0x40)

                let output := add(result, 0x20)

                for {} 1 {} {

                    // Copy the `subject` one word at a time.

                    for { let o := 0 } 1 {} {

                        mstore(add(output, o), mload(add(subject, o)))

                        o := add(o, 0x20)

                        if iszero(lt(o, subjectLength)) { break }

                    }

                    output := add(output, subjectLength)

                    times := sub(times, 1)

                    if iszero(times) { break }

                }

                // Zeroize the slot after the string.

                mstore(output, 0)

                // Store the length.

                let resultLength := sub(output, add(result, 0x20))

                mstore(result, resultLength)

                // Allocate memory for the length and the bytes,

                // rounded up to a multiple of 32.

                mstore(0x40, add(result, and(add(resultLength, 63), not(31))))

            }

        }

    }



    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).

    /// `start` and `end` are byte offsets.

    function slice(string memory subject, uint256 start, uint256 end)

        internal

        pure

        returns (string memory result)

    {

        /// @solidity memory-safe-assembly

        assembly {

            let subjectLength := mload(subject)

            if iszero(gt(subjectLength, end)) { end := subjectLength }

            if iszero(gt(subjectLength, start)) { start := subjectLength }

            if lt(start, end) {

                result := mload(0x40)

                let resultLength := sub(end, start)

                mstore(result, resultLength)

                subject := add(subject, start)

                let w := not(31)

                // Copy the `subject` one word at a time, backwards.

                for { let o := and(add(resultLength, 31), w) } 1 {} {

                    mstore(add(result, o), mload(add(subject, o)))

                    o := add(o, w) // `sub(o, 0x20)`.

                    if iszero(o) { break }

                }

                // Zeroize the slot after the string.

                mstore(add(add(result, 0x20), resultLength), 0)

                // Allocate memory for the length and the bytes,

                // rounded up to a multiple of 32.

                mstore(0x40, add(result, and(add(resultLength, 63), w)))

            }

        }

    }



    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.

    /// `start` is a byte offset.

    function slice(string memory subject, uint256 start)

        internal

        pure

        returns (string memory result)

    {

        result = slice(subject, start, uint256(int256(-1)));

    }



    /// @dev Returns all the indices of `search` in `subject`.

    /// The indices are byte offsets.

    function indicesOf(string memory subject, string memory search)

        internal

        pure

        returns (uint256[] memory result)

    {

        /// @solidity memory-safe-assembly

        assembly {

            let subjectLength := mload(subject)

            let searchLength := mload(search)



            if iszero(gt(searchLength, subjectLength)) {

                subject := add(subject, 0x20)

                search := add(search, 0x20)

                result := add(mload(0x40), 0x20)



                let subjectStart := subject

                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)

                let h := 0

                if iszero(lt(searchLength, 32)) { h := keccak256(search, searchLength) }

                let m := shl(3, sub(32, and(searchLength, 31)))

                let s := mload(search)

                for {} 1 {} {

                    let t := mload(subject)

                    // Whether the first `searchLength % 32` bytes of

                    // `subject` and `search` matches.

                    if iszero(shr(m, xor(t, s))) {

                        if h {

                            if iszero(eq(keccak256(subject, searchLength), h)) {

                                subject := add(subject, 1)

                                if iszero(lt(subject, subjectSearchEnd)) { break }

                                continue

                            }

                        }

                        // Append to `result`.

                        mstore(result, sub(subject, subjectStart))

                        result := add(result, 0x20)

                        // Advance `subject` by `searchLength`.

                        subject := add(subject, searchLength)

                        if searchLength {

                            if iszero(lt(subject, subjectSearchEnd)) { break }

                            continue

                        }

                    }

                    subject := add(subject, 1)

                    if iszero(lt(subject, subjectSearchEnd)) { break }

                }

                let resultEnd := result

                // Assign `result` to the free memory pointer.

                result := mload(0x40)

                // Store the length of `result`.

                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))

                // Allocate memory for result.

                // We allocate one more word, so this array can be recycled for {split}.

                mstore(0x40, add(resultEnd, 0x20))

            }

        }

    }



    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.

    function split(string memory subject, string memory delimiter)

        internal

        pure

        returns (string[] memory result)

    {

        uint256[] memory indices = indicesOf(subject, delimiter);

        /// @solidity memory-safe-assembly

        assembly {

            let w := not(31)

            let indexPtr := add(indices, 0x20)

            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))

            mstore(add(indicesEnd, w), mload(subject))

            mstore(indices, add(mload(indices), 1))

            let prevIndex := 0

            for {} 1 {} {

                let index := mload(indexPtr)

                mstore(indexPtr, 0x60)

                if iszero(eq(index, prevIndex)) {

                    let element := mload(0x40)

                    let elementLength := sub(index, prevIndex)

                    mstore(element, elementLength)

                    // Copy the `subject` one word at a time, backwards.

                    for { let o := and(add(elementLength, 31), w) } 1 {} {

                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))

                        o := add(o, w) // `sub(o, 0x20)`.

                        if iszero(o) { break }

                    }

                    // Zeroize the slot after the string.

                    mstore(add(add(element, 0x20), elementLength), 0)

                    // Allocate memory for the length and the bytes,

                    // rounded up to a multiple of 32.

                    mstore(0x40, add(element, and(add(elementLength, 63), w)))

                    // Store the `element` into the array.

                    mstore(indexPtr, element)

                }

                prevIndex := add(index, mload(delimiter))

                indexPtr := add(indexPtr, 0x20)

                if iszero(lt(indexPtr, indicesEnd)) { break }

            }

            result := indices

            if iszero(mload(delimiter)) {

                result := add(indices, 0x20)

                mstore(result, sub(mload(indices), 2))

            }

        }

    }



    /// @dev Returns a concatenated string of `a` and `b`.

    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.

    function concat(string memory a, string memory b)

        internal

        pure

        returns (string memory result)

    {

        /// @solidity memory-safe-assembly

        assembly {

            let w := not(31)

            result := mload(0x40)

            let aLength := mload(a)

            // Copy `a` one word at a time, backwards.

            for { let o := and(add(mload(a), 32), w) } 1 {} {

                mstore(add(result, o), mload(add(a, o)))

                o := add(o, w) // `sub(o, 0x20)`.

                if iszero(o) { break }

            }

            let bLength := mload(b)

            let output := add(result, mload(a))

            // Copy `b` one word at a time, backwards.

            for { let o := and(add(bLength, 32), w) } 1 {} {

                mstore(add(output, o), mload(add(b, o)))

                o := add(o, w) // `sub(o, 0x20)`.

                if iszero(o) { break }

            }

            let totalLength := add(aLength, bLength)

            let last := add(add(result, 0x20), totalLength)

            // Zeroize the slot after the string.

            mstore(last, 0)

            // Stores the length.

            mstore(result, totalLength)

            // Allocate memory for the length and the bytes,

            // rounded up to a multiple of 32.

            mstore(0x40, and(add(last, 31), w))

        }

    }



    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.

    function toCase(string memory subject, bool toUpper)

        internal

        pure

        returns (string memory result)

    {

        /// @solidity memory-safe-assembly

        assembly {

            let length := mload(subject)

            if length {

                result := add(mload(0x40), 0x20)

                subject := add(subject, 1)

                let flags := shl(add(70, shl(5, toUpper)), 67108863)

                let w := not(0)

                for { let o := length } 1 {} {

                    o := add(o, w)

                    let b := and(0xff, mload(add(subject, o)))

                    mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))

                    if iszero(o) { break }

                }

                // Restore the result.

                result := mload(0x40)

                // Stores the string length.

                mstore(result, length)

                // Zeroize the slot after the string.

                let last := add(add(result, 0x20), length)

                mstore(last, 0)

                // Allocate memory for the length and the bytes,

                // rounded up to a multiple of 32.

                mstore(0x40, and(add(last, 31), not(31)))

            }

        }

    }



    /// @dev Returns a lowercased copy of the string.

    function lower(string memory subject) internal pure returns (string memory result) {

        result = toCase(subject, false);

    }



    /// @dev Returns an UPPERCASED copy of the string.

    function upper(string memory subject) internal pure returns (string memory result) {

        result = toCase(subject, true);

    }



    /// @dev Escapes the string to be used within HTML tags.

    function escapeHTML(string memory s) internal pure returns (string memory result) {

        /// @solidity memory-safe-assembly

        assembly {

            for {

                let end := add(s, mload(s))

                result := add(mload(0x40), 0x20)

                // Store the bytes of the packed offsets and strides into the scratch space.

                // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.

                mstore(0x1f, 0x900094)

                mstore(0x08, 0xc0000000a6ab)

                // Store "&quot;&amp;&#39;&lt;&gt;" into the scratch space.

                mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))

            } iszero(eq(s, end)) {} {

                s := add(s, 1)

                let c := and(mload(s), 0xff)

                // Not in `["\"","'","&","<",">"]`.

                if iszero(and(shl(c, 1), 0x500000c400000000)) {

                    mstore8(result, c)

                    result := add(result, 1)

                    continue

                }

                let t := shr(248, mload(c))

                mstore(result, mload(and(t, 31)))

                result := add(result, shr(5, t))

            }

            let last := result

            // Zeroize the slot after the string.

            mstore(last, 0)

            // Restore the result to the start of the free memory.

            result := mload(0x40)

            // Store the length of the result.

            mstore(result, sub(last, add(result, 0x20)))

            // Allocate memory for the length and the bytes,

            // rounded up to a multiple of 32.

            mstore(0x40, and(add(last, 31), not(31)))

        }

    }



    /// @dev Escapes the string to be used within double-quotes in a JSON.

    function escapeJSON(string memory s) internal pure returns (string memory result) {

        /// @solidity memory-safe-assembly

        assembly {

            for {

                let end := add(s, mload(s))

                result := add(mload(0x40), 0x20)

                // Store "\\u0000" in scratch space.

                // Store "0123456789abcdef" in scratch space.

                // Also, store `{0x08:"b", 0x09:"t", 0x0a:"n", 0x0c:"f", 0x0d:"r"}`.

                // into the scratch space.

                mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)

                // Bitmask for detecting `["\"","\\"]`.

                let e := or(shl(0x22, 1), shl(0x5c, 1))

            } iszero(eq(s, end)) {} {

                s := add(s, 1)

                let c := and(mload(s), 0xff)

                if iszero(lt(c, 0x20)) {

                    if iszero(and(shl(c, 1), e)) {

                        // Not in `["\"","\\"]`.

                        mstore8(result, c)

                        result := add(result, 1)

                        continue

                    }

                    mstore8(result, 0x5c) // "\\".

                    mstore8(add(result, 1), c)

                    result := add(result, 2)

                    continue

                }

                if iszero(and(shl(c, 1), 0x3700)) {

                    // Not in `["\b","\t","\n","\f","\d"]`.

                    mstore8(0x1d, mload(shr(4, c))) // Hex value.

                    mstore8(0x1e, mload(and(c, 15))) // Hex value.

                    mstore(result, mload(0x19)) // "\\u00XX".

                    result := add(result, 6)

                    continue

                }

                mstore8(result, 0x5c) // "\\".

                mstore8(add(result, 1), mload(add(c, 8)))

                result := add(result, 2)

            }

            let last := result

            // Zeroize the slot after the string.

            mstore(last, 0)

            // Restore the result to the start of the free memory.

            result := mload(0x40)

            // Store the length of the result.

            mstore(result, sub(last, add(result, 0x20)))

            // Allocate memory for the length and the bytes,

            // rounded up to a multiple of 32.

            mstore(0x40, and(add(last, 31), not(31)))

        }

    }



    /// @dev Returns whether `a` equals `b`.

    function eq(string memory a, string memory b) internal pure returns (bool result) {

        assembly {

            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))

        }

    }



    /// @dev Packs a single string with its length into a single word.

    /// Returns `bytes32(0)` if the length is zero or greater than 31.

    function packOne(string memory a) internal pure returns (bytes32 result) {

        /// @solidity memory-safe-assembly

        assembly {

            // We don't need to zero right pad the string,

            // since this is our own custom non-standard packing scheme.

            result :=

                mul(

                    // Load the length and the bytes.

                    mload(add(a, 0x1f)),

                    // `length != 0 && length < 32`. Abuses underflow.

                    // Assumes that the length is valid and within the block gas limit.

                    lt(sub(mload(a), 1), 0x1f)

                )

        }

    }



    /// @dev Unpacks a string packed using {packOne}.

    /// Returns the empty string if `packed` is `bytes32(0)`.

    /// If `packed` is not an output of {packOne}, the output behaviour is undefined.

    function unpackOne(bytes32 packed) internal pure returns (string memory result) {

        /// @solidity memory-safe-assembly

        assembly {

            // Grab the free memory pointer.

            result := mload(0x40)

            // Allocate 2 words (1 for the length, 1 for the bytes).

            mstore(0x40, add(result, 0x40))

            // Zeroize the length slot.

            mstore(result, 0)

            // Store the length and bytes.

            mstore(add(result, 0x1f), packed)

            // Right pad with zeroes.

            mstore(add(add(result, 0x20), mload(result)), 0)

        }

    }



    /// @dev Packs two strings with their lengths into a single word.

    /// Returns `bytes32(0)` if combined length is zero or greater than 30.

    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {

        /// @solidity memory-safe-assembly

        assembly {

            let aLength := mload(a)

            // We don't need to zero right pad the strings,

            // since this is our own custom non-standard packing scheme.

            result :=

                mul(

                    // Load the length and the bytes of `a` and `b`.

                    or(

                        shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),

                        mload(sub(add(b, 0x1e), aLength))

                    ),

                    // `totalLength != 0 && totalLength < 31`. Abuses underflow.

                    // Assumes that the lengths are valid and within the block gas limit.

                    lt(sub(add(aLength, mload(b)), 1), 0x1e)

                )

        }

    }



    /// @dev Unpacks strings packed using {packTwo}.

    /// Returns the empty strings if `packed` is `bytes32(0)`.

    /// If `packed` is not an output of {packTwo}, the output behaviour is undefined.

    function unpackTwo(bytes32 packed)

        internal

        pure

        returns (string memory resultA, string memory resultB)

    {

        /// @solidity memory-safe-assembly

        assembly {

            // Grab the free memory pointer.

            resultA := mload(0x40)

            resultB := add(resultA, 0x40)

            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.

            mstore(0x40, add(resultB, 0x40))

            // Zeroize the length slots.

            mstore(resultA, 0)

            mstore(resultB, 0)

            // Store the lengths and bytes.

            mstore(add(resultA, 0x1f), packed)

            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))

            // Right pad with zeroes.

            mstore(add(add(resultA, 0x20), mload(resultA)), 0)

            mstore(add(add(resultB, 0x20), mload(resultB)), 0)

        }

    }



    /// @dev Directly returns `a` without copying.

    function directReturn(string memory a) internal pure {

        assembly {

            // Assumes that the string does not start from the scratch space.

            let retStart := sub(a, 0x20)

            let retSize := add(mload(a), 0x40)

            // Right pad with zeroes. Just in case the string is produced

            // by a method that doesn't zero right pad.

            mstore(add(retStart, retSize), 0)

            // Store the return offset.

            mstore(retStart, 0x20)

            // End the transaction, returning the string.

            return(retStart, retSize)

        }

    }

}



// File: solady/utils/MerkleProofLib.sol





pragma solidity ^0.8.4;



/// @notice Gas optimized verification of proof of inclusion for a leaf in a Merkle tree.

/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/MerkleProofLib.sol)

/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/MerkleProofLib.sol)

/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/MerkleProof.sol)

library MerkleProofLib {

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*            MERKLE PROOF VERIFICATION OPERATIONS            */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Returns whether `leaf` exists in the Merkle tree with `root`, given `proof`.

    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf)

        internal

        pure

        returns (bool isValid)

    {

        /// @solidity memory-safe-assembly

        assembly {

            if mload(proof) {

                // Initialize `offset` to the offset of `proof` elements in memory.

                let offset := add(proof, 0x20)

                // Left shift by 5 is equivalent to multiplying by 0x20.

                let end := add(offset, shl(5, mload(proof)))

                // Iterate over proof elements to compute root hash.

                for {} 1 {} {

                    // Slot of `leaf` in scratch space.

                    // If the condition is true: 0x20, otherwise: 0x00.

                    let scratch := shl(5, gt(leaf, mload(offset)))

                    // Store elements to hash contiguously in scratch space.

                    // Scratch space is 64 bytes (0x00 - 0x3f) and both elements are 32 bytes.

                    mstore(scratch, leaf)

                    mstore(xor(scratch, 0x20), mload(offset))

                    // Reuse `leaf` to store the hash to reduce stack operations.

                    leaf := keccak256(0x00, 0x40)

                    offset := add(offset, 0x20)

                    if iszero(lt(offset, end)) { break }

                }

            }

            isValid := eq(leaf, root)

        }

    }



    /// @dev Returns whether `leaf` exists in the Merkle tree with `root`, given `proof`.

    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf)

        internal

        pure

        returns (bool isValid)

    {

        /// @solidity memory-safe-assembly

        assembly {

            if proof.length {

                // Left shift by 5 is equivalent to multiplying by 0x20.

                let end := add(proof.offset, shl(5, proof.length))

                // Initialize `offset` to the offset of `proof` in the calldata.

                let offset := proof.offset

                // Iterate over proof elements to compute root hash.

                for {} 1 {} {

                    // Slot of `leaf` in scratch space.

                    // If the condition is true: 0x20, otherwise: 0x00.

                    let scratch := shl(5, gt(leaf, calldataload(offset)))

                    // Store elements to hash contiguously in scratch space.

                    // Scratch space is 64 bytes (0x00 - 0x3f) and both elements are 32 bytes.

                    mstore(scratch, leaf)

                    mstore(xor(scratch, 0x20), calldataload(offset))

                    // Reuse `leaf` to store the hash to reduce stack operations.

                    leaf := keccak256(0x00, 0x40)

                    offset := add(offset, 0x20)

                    if iszero(lt(offset, end)) { break }

                }

            }

            isValid := eq(leaf, root)

        }

    }



    /// @dev Returns whether all `leafs` exist in the Merkle tree with `root`,

    /// given `proof` and `flags`.

    function verifyMultiProof(

        bytes32[] memory proof,

        bytes32 root,

        bytes32[] memory leafs,

        bool[] memory flags

    ) internal pure returns (bool isValid) {

        // Rebuilds the root by consuming and producing values on a queue.

        // The queue starts with the `leafs` array, and goes into a `hashes` array.

        // After the process, the last element on the queue is verified

        // to be equal to the `root`.

        //

        // The `flags` array denotes whether the sibling

        // should be popped from the queue (`flag == true`), or

        // should be popped from the `proof` (`flag == false`).

        /// @solidity memory-safe-assembly

        assembly {

            // Cache the lengths of the arrays.

            let leafsLength := mload(leafs)

            let proofLength := mload(proof)

            let flagsLength := mload(flags)



            // Advance the pointers of the arrays to point to the data.

            leafs := add(0x20, leafs)

            proof := add(0x20, proof)

            flags := add(0x20, flags)



            // If the number of flags is correct.

            for {} eq(add(leafsLength, proofLength), add(flagsLength, 1)) {} {

                // For the case where `proof.length + leafs.length == 1`.

                if iszero(flagsLength) {

                    // `isValid = (proof.length == 1 ? proof[0] : leafs[0]) == root`.

                    isValid := eq(mload(xor(leafs, mul(xor(proof, leafs), proofLength))), root)

                    break

                }



                // We can use the free memory space for the queue.

                // We don't need to allocate, since the queue is temporary.

                let hashesFront := mload(0x40)

                // Copy the leafs into the hashes.

                // Sometimes, a little memory expansion costs less than branching.

                // Should cost less, even with a high free memory offset of 0x7d00.

                // Left shift by 5 is equivalent to multiplying by 0x20.

                leafsLength := shl(5, leafsLength)

                for { let i := 0 } iszero(eq(i, leafsLength)) { i := add(i, 0x20) } {

                    mstore(add(hashesFront, i), mload(add(leafs, i)))

                }

                // Compute the back of the hashes.

                let hashesBack := add(hashesFront, leafsLength)

                // This is the end of the memory for the queue.

                // We recycle `flagsLength` to save on stack variables

                // (this trick may not always save gas).

                flagsLength := add(hashesBack, shl(5, flagsLength))



                for {} 1 {} {

                    // Pop from `hashes`.

                    let a := mload(hashesFront)

                    // Pop from `hashes`.

                    let b := mload(add(hashesFront, 0x20))

                    hashesFront := add(hashesFront, 0x40)



                    // If the flag is false, load the next proof,

                    // else, pops from the queue.

                    if iszero(mload(flags)) {

                        // Loads the next proof.

                        b := mload(proof)

                        proof := add(proof, 0x20)

                        // Unpop from `hashes`.

                        hashesFront := sub(hashesFront, 0x20)

                    }



                    // Advance to the next flag.

                    flags := add(flags, 0x20)



                    // Slot of `a` in scratch space.

                    // If the condition is true: 0x20, otherwise: 0x00.

                    let scratch := shl(5, gt(a, b))

                    // Hash the scratch space and push the result onto the queue.

                    mstore(scratch, a)

                    mstore(xor(scratch, 0x20), b)

                    mstore(hashesBack, keccak256(0x00, 0x40))

                    hashesBack := add(hashesBack, 0x20)

                    if iszero(lt(hashesBack, flagsLength)) { break }

                }

                // Checks if the last value in the queue is same as the root.

                isValid := eq(mload(sub(hashesBack, 0x20)), root)

                break

            }

        }

    }



    /// @dev Returns whether all `leafs` exist in the Merkle tree with `root`,

    /// given `proof` and `flags`.

    function verifyMultiProofCalldata(

        bytes32[] calldata proof,

        bytes32 root,

        bytes32[] calldata leafs,

        bool[] calldata flags

    ) internal pure returns (bool isValid) {

        // Rebuilds the root by consuming and producing values on a queue.

        // The queue starts with the `leafs` array, and goes into a `hashes` array.

        // After the process, the last element on the queue is verified

        // to be equal to the `root`.

        //

        // The `flags` array denotes whether the sibling

        // should be popped from the queue (`flag == true`), or

        // should be popped from the `proof` (`flag == false`).

        /// @solidity memory-safe-assembly

        assembly {

            // If the number of flags is correct.

            for {} eq(add(leafs.length, proof.length), add(flags.length, 1)) {} {

                // For the case where `proof.length + leafs.length == 1`.

                if iszero(flags.length) {

                    // `isValid = (proof.length == 1 ? proof[0] : leafs[0]) == root`.

                    // forgefmt: disable-next-item

                    isValid := eq(

                        calldataload(

                            xor(leafs.offset, mul(xor(proof.offset, leafs.offset), proof.length))

                        ),

                        root

                    )

                    break

                }



                // We can use the free memory space for the queue.

                // We don't need to allocate, since the queue is temporary.

                let hashesFront := mload(0x40)

                // Copy the leafs into the hashes.

                // Sometimes, a little memory expansion costs less than branching.

                // Should cost less, even with a high free memory offset of 0x7d00.

                // Left shift by 5 is equivalent to multiplying by 0x20.

                calldatacopy(hashesFront, leafs.offset, shl(5, leafs.length))

                // Compute the back of the hashes.

                let hashesBack := add(hashesFront, shl(5, leafs.length))

                // This is the end of the memory for the queue.

                // We recycle `flags.length` to save on stack variables

                // (this trick may not always save gas).

                flags.length := add(hashesBack, shl(5, flags.length))



                // We don't need to make a copy of `proof.offset` or `flags.offset`,

                // as they are pass-by-value (this trick may not always save gas).



                for {} 1 {} {

                    // Pop from `hashes`.

                    let a := mload(hashesFront)

                    // Pop from `hashes`.

                    let b := mload(add(hashesFront, 0x20))

                    hashesFront := add(hashesFront, 0x40)



                    // If the flag is false, load the next proof,

                    // else, pops from the queue.

                    if iszero(calldataload(flags.offset)) {

                        // Loads the next proof.

                        b := calldataload(proof.offset)

                        proof.offset := add(proof.offset, 0x20)

                        // Unpop from `hashes`.

                        hashesFront := sub(hashesFront, 0x20)

                    }



                    // Advance to the next flag offset.

                    flags.offset := add(flags.offset, 0x20)



                    // Slot of `a` in scratch space.

                    // If the condition is true: 0x20, otherwise: 0x00.

                    let scratch := shl(5, gt(a, b))

                    // Hash the scratch space and push the result onto the queue.

                    mstore(scratch, a)

                    mstore(xor(scratch, 0x20), b)

                    mstore(hashesBack, keccak256(0x00, 0x40))

                    hashesBack := add(hashesBack, 0x20)

                    if iszero(lt(hashesBack, flags.length)) { break }

                }

                // Checks if the last value in the queue is same as the root.

                isValid := eq(mload(sub(hashesBack, 0x20)), root)

                break

            }

        }

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                   EMPTY CALLDATA HELPERS                   */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Returns an empty calldata bytes32 array.

    function emptyProof() internal pure returns (bytes32[] calldata proof) {

        /// @solidity memory-safe-assembly

        assembly {

            proof.length := 0

        }

    }



    /// @dev Returns an empty calldata bytes32 array.

    function emptyLeafs() internal pure returns (bytes32[] calldata leafs) {

        /// @solidity memory-safe-assembly

        assembly {

            leafs.length := 0

        }

    }



    /// @dev Returns an empty calldata bool array.

    function emptyFlags() internal pure returns (bool[] calldata flags) {

        /// @solidity memory-safe-assembly

        assembly {

            flags.length := 0

        }

    }

}

// File: solady/auth/Ownable.sol





pragma solidity ^0.8.4;



/// @notice Simple single owner authorization mixin.

/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)

/// @dev While the ownable portion follows [EIP-173](https://eips.ethereum.org/EIPS/eip-173)

/// for compatibility, the nomenclature for the 2-step ownership handover

/// may be unique to this codebase.

abstract contract Ownable {

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                       CUSTOM ERRORS                        */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev The caller is not authorized to call the function.

    error Unauthorized();



    /// @dev The `newOwner` cannot be the zero address.

    error NewOwnerIsZeroAddress();



    /// @dev The `pendingOwner` does not have a valid handover request.

    error NoHandoverRequest();



    /// @dev `bytes4(keccak256(bytes("Unauthorized()")))`.

    uint256 private constant _UNAUTHORIZED_ERROR_SELECTOR = 0x82b42900;



    /// @dev `bytes4(keccak256(bytes("NewOwnerIsZeroAddress()")))`.

    uint256 private constant _NEW_OWNER_IS_ZERO_ADDRESS_ERROR_SELECTOR = 0x7448fbae;



    /// @dev `bytes4(keccak256(bytes("NoHandoverRequest()")))`.

    uint256 private constant _NO_HANDOVER_REQUEST_ERROR_SELECTOR = 0x6f5e8818;



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                           EVENTS                           */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.

    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be

    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),

    /// despite it not being as lightweight as a single argument event.

    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);



    /// @dev An ownership handover to `pendingOwner` has been requested.

    event OwnershipHandoverRequested(address indexed pendingOwner);



    /// @dev The ownership handover to `pendingOwner` has been canceled.

    event OwnershipHandoverCanceled(address indexed pendingOwner);



    /// @dev `keccak256(bytes("OwnershipTransferred(address,address)"))`.

    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =

        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;



    /// @dev `keccak256(bytes("OwnershipHandoverRequested(address)"))`.

    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =

        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;



    /// @dev `keccak256(bytes("OwnershipHandoverCanceled(address)"))`.

    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =

        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                          STORAGE                           */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev The owner slot is given by: `not(_OWNER_SLOT_NOT)`.

    /// It is intentionally choosen to be a high value

    /// to avoid collision with lower slots.

    /// The choice of manual storage layout is to enable compatibility

    /// with both regular and upgradeable contracts.

    uint256 private constant _OWNER_SLOT_NOT = 0x8b78c6d8;



    /// The ownership handover slot of `newOwner` is given by:

    /// ```

    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))

    ///     let handoverSlot := keccak256(0x00, 0x20)

    /// ```

    /// It stores the expiry timestamp of the two-step ownership handover.

    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                     INTERNAL FUNCTIONS                     */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Initializes the owner directly without authorization guard.

    /// This function must be called upon initialization,

    /// regardless of whether the contract is upgradeable or not.

    /// This is to enable generalization to both regular and upgradeable contracts,

    /// and to save gas in case the initial owner is not the caller.

    /// For performance reasons, this function will not check if there

    /// is an existing owner.

    function _initializeOwner(address newOwner) internal virtual {

        /// @solidity memory-safe-assembly

        assembly {

            // Clean the upper 96 bits.

            newOwner := shr(96, shl(96, newOwner))

            // Store the new value.

            sstore(not(_OWNER_SLOT_NOT), newOwner)

            // Emit the {OwnershipTransferred} event.

            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)

        }

    }



    /// @dev Sets the owner directly without authorization guard.

    function _setOwner(address newOwner) internal virtual {

        /// @solidity memory-safe-assembly

        assembly {

            let ownerSlot := not(_OWNER_SLOT_NOT)

            // Clean the upper 96 bits.

            newOwner := shr(96, shl(96, newOwner))

            // Emit the {OwnershipTransferred} event.

            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)

            // Store the new value.

            sstore(ownerSlot, newOwner)

        }

    }



    /// @dev Throws if the sender is not the owner.

    function _checkOwner() internal view virtual {

        /// @solidity memory-safe-assembly

        assembly {

            // If the caller is not the stored owner, revert.

            if iszero(eq(caller(), sload(not(_OWNER_SLOT_NOT)))) {

                mstore(0x00, _UNAUTHORIZED_ERROR_SELECTOR)

                revert(0x1c, 0x04)

            }

        }

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                  PUBLIC UPDATE FUNCTIONS                   */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Allows the owner to transfer the ownership to `newOwner`.

    function transferOwnership(address newOwner) public payable virtual onlyOwner {

        if (newOwner == address(0)) revert NewOwnerIsZeroAddress();

        _setOwner(newOwner);

    }



    /// @dev Allows the owner to renounce their ownership.

    function renounceOwnership() public payable virtual onlyOwner {

        _setOwner(address(0));

    }



    /// @dev Request a two-step ownership handover to the caller.

    /// The request will be automatically expire in 48 hours (172800 seconds) by default.

    function requestOwnershipHandover() public payable virtual {

        unchecked {

            uint256 expires = block.timestamp + ownershipHandoverValidFor();

            /// @solidity memory-safe-assembly

            assembly {

                // Compute and set the handover slot to 1.

                mstore(0x0c, _HANDOVER_SLOT_SEED)

                mstore(0x00, caller())

                sstore(keccak256(0x0c, 0x20), expires)

                // Emit the {OwnershipHandoverRequested} event.

                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())

            }

        }

    }



    /// @dev Cancels the two-step ownership handover to the caller, if any.

    function cancelOwnershipHandover() public payable virtual {

        /// @solidity memory-safe-assembly

        assembly {

            // Compute and set the handover slot to 0.

            mstore(0x0c, _HANDOVER_SLOT_SEED)

            mstore(0x00, caller())

            sstore(keccak256(0x0c, 0x20), 0)

            // Emit the {OwnershipHandoverCanceled} event.

            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())

        }

    }



    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.

    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.

    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {

        /// @solidity memory-safe-assembly

        assembly {

            // Compute and set the handover slot to 0.

            mstore(0x0c, _HANDOVER_SLOT_SEED)

            mstore(0x00, pendingOwner)

            let handoverSlot := keccak256(0x0c, 0x20)

            // If the handover does not exist, or has expired.

            if gt(timestamp(), sload(handoverSlot)) {

                mstore(0x00, _NO_HANDOVER_REQUEST_ERROR_SELECTOR)

                revert(0x1c, 0x04)

            }

            // Set the handover slot to 0.

            sstore(handoverSlot, 0)

            // Clean the upper 96 bits.

            let newOwner := shr(96, mload(0x0c))

            // Emit the {OwnershipTransferred} event.

            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, caller(), newOwner)

            // Store the new value.

            sstore(not(_OWNER_SLOT_NOT), newOwner)

        }

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                   PUBLIC READ FUNCTIONS                    */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Returns the owner of the contract.

    function owner() public view virtual returns (address result) {

        /// @solidity memory-safe-assembly

        assembly {

            result := sload(not(_OWNER_SLOT_NOT))

        }

    }



    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.

    function ownershipHandoverExpiresAt(address pendingOwner)

        public

        view

        virtual

        returns (uint256 result)

    {

        /// @solidity memory-safe-assembly

        assembly {

            // Compute the handover slot.

            mstore(0x0c, _HANDOVER_SLOT_SEED)

            mstore(0x00, pendingOwner)

            // Load the handover slot.

            result := sload(keccak256(0x0c, 0x20))

        }

    }



    /// @dev Returns how long a two-step ownership handover is valid for in seconds.

    function ownershipHandoverValidFor() public view virtual returns (uint64) {

        return 48 * 3600;

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                         MODIFIERS                          */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Marks a function as only callable by the owner.

    modifier onlyOwner() virtual {

        _checkOwner();

        _;

    }

}



// File: solady/tokens/ERC1155.sol





pragma solidity ^0.8.4;



/// @notice Modern and gas efficient ERC1155 implementation.

/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC1155.sol)

/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)

/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC1155/ERC1155.sol)

abstract contract ERC1155 {

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                       CUSTOM ERRORS                        */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev The lengths of the input arrays are not the same.

    error ArrayLengthsMismatch();



    /// @dev Cannot mint or transfer to the zero address.

    error TransferToZeroAddress();



    /// @dev The recipient's balance has overflowed.

    error AccountBalanceOverflow();



    /// @dev Insufficient balance.

    error InsufficientBalance();



    /// @dev Only the token owner or an approved account can manage the tokens.

    error NotOwnerNorApproved();



    /// @dev Cannot safely transfer to a contract that does not implement

    /// the ERC1155Receiver interface.

    error TransferToNonERC1155ReceiverImplementer();



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                           EVENTS                           */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Emitted when `amount` of token `id` is transferred

    /// from `from` to `to` by `operator`.

    event TransferSingle(

        address indexed operator,

        address indexed from,

        address indexed to,

        uint256 id,

        uint256 amount

    );



    /// @dev Emitted when `amounts` of token `ids` are transferred

    /// from `from` to `to` by `operator`.

    event TransferBatch(

        address indexed operator,

        address indexed from,

        address indexed to,

        uint256[] ids,

        uint256[] amounts

    );



    /// @dev Emitted when `owner` enables or disables `operator` to manage all of their tokens.

    event ApprovalForAll(address indexed owner, address indexed operator, bool isApproved);



    /// @dev Emitted when the Uniform Resource Identifier (URI) for token `id`

    /// is updated to `value`. This event is not used in the base contract.

    /// You may need to emit this event depending on your URI logic.

    ///

    /// See: https://eips.ethereum.org/EIPS/eip-1155#metadata

    event URI(string value, uint256 indexed id);



    /// @dev `keccak256(bytes("TransferSingle(address,address,address,uint256,uint256)"))`.

    uint256 private constant _TRANSFER_SINGLE_EVENT_SIGNATURE =

        0xc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62;



    /// @dev `keccak256(bytes("TransferBatch(address,address,address,uint256[],uint256[])"))`.

    uint256 private constant _TRANSFER_BATCH_EVENT_SIGNATURE =

        0x4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb;



    /// @dev `keccak256(bytes("ApprovalForAll(address,address,bool)"))`.

    uint256 private constant _APPROVAL_FOR_ALL_EVENT_SIGNATURE =

        0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31;



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                          STORAGE                           */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev The `ownerSlotSeed` of a given owner is given by.

    /// ```

    ///     let ownerSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, owner))

    /// ```

    ///

    /// The balance slot of `owner` is given by.

    /// ```

    ///     mstore(0x20, ownerSlotSeed)

    ///     mstore(0x00, id)

    ///     let balanceSlot := keccak256(0x00, 0x40)

    /// ```

    ///

    /// The operator approval slot of `owner` is given by.

    /// ```

    ///     mstore(0x20, ownerSlotSeed)

    ///     mstore(0x00, operator)

    ///     let operatorApprovalSlot := keccak256(0x0c, 0x34)

    /// ```

    uint256 private constant _ERC1155_MASTER_SLOT_SEED = 0x9a31110384e0b0c9;



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                      ERC1155 METADATA                      */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Returns the URI for token `id`.

    ///

    /// Can either return the same templated URI for all token IDs,

    /// or substitute the `id` on the contract side.

    ///

    /// See: https://eips.ethereum.org/EIPS/eip-1155#metadata

    function uri(uint256 id) public view virtual returns (string memory);



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                          ERC1155                           */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Returns the amount of `id` owned by `owner`.

    function balanceOf(address owner, uint256 id) public view virtual returns (uint256 result) {

        /// @solidity memory-safe-assembly

        assembly {

            mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, shl(96, owner)))

            mstore(0x00, id)

            result := sload(keccak256(0x00, 0x40))

        }

    }



    /// @dev Returns whether `operator` is approved to manage the tokens of `owner`.

    function isApprovedForAll(address owner, address operator)

        public

        view

        virtual

        returns (bool result)

    {

        /// @solidity memory-safe-assembly

        assembly {

            mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, shl(96, owner)))

            mstore(0x00, operator)

            result := sload(keccak256(0x0c, 0x34))

        }

    }



    /// @dev Sets whether `operator` is approved to manage the tokens of the caller.

    ///

    /// Emits a {ApprovalForAll} event.

    function setApprovalForAll(address operator, bool isApproved) public virtual {

        /// @solidity memory-safe-assembly

        assembly {

            // Clear the upper 96 bits.

            operator := shr(96, shl(96, operator))

            // Convert to 0 or 1.

            isApproved := iszero(iszero(isApproved))

            // Update the `isApproved` for (`msg.sender`, `operator`).

            mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, shl(96, caller())))

            mstore(0x00, operator)

            sstore(keccak256(0x0c, 0x34), isApproved)

            // Emit the {ApprovalForAll} event.

            mstore(0x00, isApproved)

            log3(0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, caller(), operator)

        }

    }



    /// @dev Transfers `amount` of `id` from `from` to `to`.

    ///

    /// Requirements:

    /// - `to` cannot be the zero address.

    /// - `from` must have at least `amount` of `id`.

    /// - If the caller is not `from`,

    ///   it must be approved to manage the tokens of `from`.

    /// - If `to` refers to a smart contract, it must implement

    ///   {ERC1155-onERC1155Reveived}, which is called upon a batch transfer.

    ///

    /// Emits a {Transfer} event.

    function safeTransferFrom(

        address from,

        address to,

        uint256 id,

        uint256 amount,

        bytes calldata data

    ) public virtual {

        if (_useBeforeTokenTransfer()) {

            _beforeTokenTransfer(from, to, _single(id), _single(amount), data);

        }

        /// @solidity memory-safe-assembly

        assembly {

            let fromSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, from))

            let toSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, to))

            mstore(0x20, fromSlotSeed)

            // Clear the upper 96 bits.

            from := shr(96, fromSlotSeed)

            to := shr(96, toSlotSeed)

            // If the caller is not `from`, do the authorization check.

            if iszero(eq(caller(), from)) {

                mstore(0x00, caller())

                if iszero(sload(keccak256(0x0c, 0x34))) {

                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.

                    revert(0x1c, 0x04)

                }

            }

            // Revert if `to` is the zero address.

            if iszero(to) {

                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.

                revert(0x1c, 0x04)

            }

            // Subtract and store the updated balance of `from`.

            {

                mstore(0x00, id)

                let fromBalanceSlot := keccak256(0x00, 0x40)

                let fromBalance := sload(fromBalanceSlot)

                if gt(amount, fromBalance) {

                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.

                    revert(0x1c, 0x04)

                }

                sstore(fromBalanceSlot, sub(fromBalance, amount))

            }

            // Increase and store the updated balance of `to`.

            {

                mstore(0x20, toSlotSeed)

                let toBalanceSlot := keccak256(0x00, 0x40)

                let toBalanceBefore := sload(toBalanceSlot)

                let toBalanceAfter := add(toBalanceBefore, amount)

                if lt(toBalanceAfter, toBalanceBefore) {

                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.

                    revert(0x1c, 0x04)

                }

                sstore(toBalanceSlot, toBalanceAfter)

            }

            // Emit a {TransferSingle} event.

            {

                mstore(0x20, amount)

                log4(0x00, 0x40, _TRANSFER_SINGLE_EVENT_SIGNATURE, caller(), from, to)

            }

        }

        if (_useAfterTokenTransfer()) {

            _afterTokenTransfer(from, to, _single(id), _single(amount), data);

        }

        /// @solidity memory-safe-assembly

        assembly {

            // Do the {onERC1155Received} check if `to` is a smart contract.

            if extcodesize(to) {

                // Prepare the calldata.

                let m := mload(0x40)

                let onERC1155ReceivedSelector := 0xf23a6e61

                mstore(m, onERC1155ReceivedSelector)

                mstore(add(m, 0x20), caller())

                mstore(add(m, 0x40), from)

                mstore(add(m, 0x60), id)

                mstore(add(m, 0x80), amount)

                mstore(add(m, 0xa0), 0xa0)

                calldatacopy(add(m, 0xc0), sub(data.offset, 0x20), add(0x20, data.length))

                // Revert if the call reverts.

                if iszero(call(gas(), to, 0, add(m, 0x1c), add(0xc4, data.length), m, 0x20)) {

                    if returndatasize() {

                        // Bubble up the revert if the delegatecall reverts.

                        returndatacopy(0x00, 0x00, returndatasize())

                        revert(0x00, returndatasize())

                    }

                    mstore(m, 0)

                }

                // Load the returndata and compare it.

                if iszero(eq(mload(m), shl(224, onERC1155ReceivedSelector))) {

                    mstore(0x00, 0x9c05499b) // `TransferToNonERC1155ReceiverImplementer()`.

                    revert(0x1c, 0x04)

                }

            }

        }

    }



    /// @dev Transfers `amounts` of `ids` from `from` to `to`.

    ///

    /// Requirements:

    /// - `to` cannot be the zero address.

    /// - `from` must have at least `amount` of `id`.

    /// - `ids` and `amounts` must have the same length.

    /// - If the caller is not `from`,

    ///   it must be approved to manage the tokens of `from`.

    /// - If `to` refers to a smart contract, it must implement

    ///   {ERC1155-onERC1155BatchReveived}, which is called upon a batch transfer.

    ///

    /// Emits a {TransferBatch} event.

    function safeBatchTransferFrom(

        address from,

        address to,

        uint256[] calldata ids,

        uint256[] calldata amounts,

        bytes calldata data

    ) public virtual {

        if (_useBeforeTokenTransfer()) {

            _beforeTokenTransfer(from, to, ids, amounts, data);

        }

        /// @solidity memory-safe-assembly

        assembly {

            if iszero(eq(ids.length, amounts.length)) {

                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.

                revert(0x1c, 0x04)

            }

            let fromSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, from))

            let toSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, to))

            mstore(0x20, fromSlotSeed)

            // Clear the upper 96 bits.

            from := shr(96, fromSlotSeed)

            to := shr(96, toSlotSeed)

            // Revert if `to` is the zero address.

            if iszero(to) {

                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.

                revert(0x1c, 0x04)

            }

            // If the caller is not `from`, do the authorization check.

            if iszero(eq(caller(), from)) {

                mstore(0x00, caller())

                if iszero(sload(keccak256(0x0c, 0x34))) {

                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.

                    revert(0x1c, 0x04)

                }

            }

            // Loop through all the `ids` and update the balances.

            {

                let end := shl(5, ids.length)

                for { let i := 0 } iszero(eq(i, end)) { i := add(i, 0x20) } {

                    let amount := calldataload(add(amounts.offset, i))

                    // Subtract and store the updated balance of `from`.

                    {

                        mstore(0x20, fromSlotSeed)

                        mstore(0x00, calldataload(add(ids.offset, i)))

                        let fromBalanceSlot := keccak256(0x00, 0x40)

                        let fromBalance := sload(fromBalanceSlot)

                        if gt(amount, fromBalance) {

                            mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.

                            revert(0x1c, 0x04)

                        }

                        sstore(fromBalanceSlot, sub(fromBalance, amount))

                    }

                    // Increase and store the updated balance of `to`.

                    {

                        mstore(0x20, toSlotSeed)

                        let toBalanceSlot := keccak256(0x00, 0x40)

                        let toBalanceBefore := sload(toBalanceSlot)

                        let toBalanceAfter := add(toBalanceBefore, amount)

                        if lt(toBalanceAfter, toBalanceBefore) {

                            mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.

                            revert(0x1c, 0x04)

                        }

                        sstore(toBalanceSlot, toBalanceAfter)

                    }

                }

            }

            // Emit a {TransferBatch} event.

            {

                let m := mload(0x40)

                // Copy the `ids`.

                mstore(m, 0x40)

                let n := add(0x20, shl(5, ids.length))

                let o := add(m, 0x40)

                calldatacopy(o, sub(ids.offset, 0x20), n)

                // Copy the `amounts`.

                mstore(add(m, 0x20), add(0x40, n))

                o := add(o, n)

                n := add(0x20, shl(5, amounts.length))

                calldatacopy(o, sub(amounts.offset, 0x20), n)

                n := sub(add(o, n), m)

                // Do the emit.

                log4(m, n, _TRANSFER_BATCH_EVENT_SIGNATURE, caller(), from, to)

            }

        }

        if (_useAfterTokenTransfer()) {

            _afterTokenTransferCalldata(from, to, ids, amounts, data);

        }

        /// @solidity memory-safe-assembly

        assembly {

            // Do the {onERC1155BatchReceived} check if `to` is a smart contract.

            if extcodesize(to) {

                let m := mload(0x40)

                // Prepare the calldata.

                let onERC1155BatchReceivedSelector := 0xbc197c81

                mstore(m, onERC1155BatchReceivedSelector)

                mstore(add(m, 0x20), caller())

                mstore(add(m, 0x40), from)

                // Copy the `ids`.

                mstore(add(m, 0x60), 0xa0)

                let n := add(0x20, shl(5, ids.length))

                let o := add(m, 0xc0)

                calldatacopy(o, sub(ids.offset, 0x20), n)

                // Copy the `amounts`.

                let s := add(0xa0, n)

                mstore(add(m, 0x80), s)

                o := add(o, n)

                n := add(0x20, shl(5, amounts.length))

                calldatacopy(o, sub(amounts.offset, 0x20), n)

                // Copy the `data`.

                mstore(add(m, 0xa0), add(s, n))

                o := add(o, n)

                n := add(0x20, data.length)

                calldatacopy(o, sub(data.offset, 0x20), n)

                n := sub(add(o, n), add(m, 0x1c))

                // Revert if the call reverts.

                if iszero(call(gas(), to, 0, add(m, 0x1c), n, m, 0x20)) {

                    if returndatasize() {

                        // Bubble up the revert if the delegatecall reverts.

                        returndatacopy(0x00, 0x00, returndatasize())

                        revert(0x00, returndatasize())

                    }

                    mstore(m, 0)

                }

                // Load the returndata and compare it.

                if iszero(eq(mload(m), shl(224, onERC1155BatchReceivedSelector))) {

                    mstore(0x00, 0x9c05499b) // `TransferToNonERC1155ReceiverImplementer()`.

                    revert(0x1c, 0x04)

                }

            }

        }

    }



    /// @dev Returns the amounts of `ids` for `owners.

    ///

    /// Requirements:

    /// - `owners` and `ids` must have the same length.

    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)

        public

        view

        virtual

        returns (uint256[] memory balances)

    {

        /// @solidity memory-safe-assembly

        assembly {

            if iszero(eq(ids.length, owners.length)) {

                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.

                revert(0x1c, 0x04)

            }

            balances := mload(0x40)

            mstore(balances, ids.length)

            let o := add(balances, 0x20)

            let end := shl(5, ids.length)

            mstore(0x40, add(end, o))

            // Loop through all the `ids` and load the balances.

            for { let i := 0 } iszero(eq(i, end)) { i := add(i, 0x20) } {

                let owner := calldataload(add(owners.offset, i))

                mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, shl(96, owner)))

                mstore(0x00, calldataload(add(ids.offset, i)))

                mstore(add(o, i), sload(keccak256(0x00, 0x40)))

            }

        }

    }



    /// @dev Returns true if this contract implements the interface defined by `interfaceId`.

    /// See: https://eips.ethereum.org/EIPS/eip-165

    /// This function call must use less than 30000 gas.

    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {

        /// @solidity memory-safe-assembly

        assembly {

            let s := shr(224, interfaceId)

            // ERC165: 0x01ffc9a7, ERC1155: 0xd9b67a26, ERC1155MetadataURI: 0x0e89341c.

            result := or(or(eq(s, 0x01ffc9a7), eq(s, 0xd9b67a26)), eq(s, 0x0e89341c))

        }

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                  INTERNAL MINT FUNCTIONS                   */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Mints `amount` of `id` to `to`.

    ///

    /// Requirements:

    /// - `to` cannot be the zero address.

    /// - If `to` refers to a smart contract, it must implement

    ///   {ERC1155-onERC1155Reveived}, which is called upon a batch transfer.

    ///

    /// Emits a {Transfer} event.

    function _mint(address to, uint256 id, uint256 amount, bytes memory data) internal virtual {

        if (_useBeforeTokenTransfer()) {

            _beforeTokenTransfer(address(0), to, _single(id), _single(amount), data);

        }

        /// @solidity memory-safe-assembly

        assembly {

            let toSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, to))

            // Clear the upper 96 bits.

            to := shr(96, toSlotSeed)

            // Revert if `to` is the zero address.

            if iszero(to) {

                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.

                revert(0x1c, 0x04)

            }

            // Increase and store the updated balance of `to`.

            {

                mstore(0x20, toSlotSeed)

                mstore(0x00, id)

                let toBalanceSlot := keccak256(0x00, 0x40)

                let toBalanceBefore := sload(toBalanceSlot)

                let toBalanceAfter := add(toBalanceBefore, amount)

                if lt(toBalanceAfter, toBalanceBefore) {

                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.

                    revert(0x1c, 0x04)

                }

                sstore(toBalanceSlot, toBalanceAfter)

            }

            // Emit a {TransferSingle} event.

            {

                mstore(0x00, id)

                mstore(0x20, amount)

                log4(0x00, 0x40, _TRANSFER_SINGLE_EVENT_SIGNATURE, caller(), 0, to)

            }

        }

        if (_useAfterTokenTransfer()) {

            _afterTokenTransfer(address(0), to, _single(id), _single(amount), data);

        }

        if (_hasCode(to)) _checkOnERC1155Received(address(0), to, id, amount, data);

    }



    /// @dev Mints `amounts` of `ids` to `to`.

    ///

    /// Requirements:

    /// - `to` cannot be the zero address.

    /// - `ids` and `amounts` must have the same length.

    /// - If `to` refers to a smart contract, it must implement

    ///   {ERC1155-onERC1155BatchReveived}, which is called upon a batch transfer.

    ///

    /// Emits a {TransferBatch} event.

    function _batchMint(

        address to,

        uint256[] memory ids,

        uint256[] memory amounts,

        bytes memory data

    ) internal virtual {

        if (_useBeforeTokenTransfer()) {

            _beforeTokenTransfer(address(0), to, ids, amounts, data);

        }

        /// @solidity memory-safe-assembly

        assembly {

            if iszero(eq(mload(ids), mload(amounts))) {

                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.

                revert(0x1c, 0x04)

            }

            let toSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, to))

            // Clear the upper 96 bits.

            to := shr(96, toSlotSeed)

            // Revert if `to` is the zero address.

            if iszero(to) {

                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.

                revert(0x1c, 0x04)

            }

            // Loop through all the `ids` and update the balances.

            {

                let end := shl(5, mload(ids))

                for { let i := 0 } iszero(eq(i, end)) {} {

                    i := add(i, 0x20)

                    let amount := mload(add(amounts, i))

                    // Increase and store the updated balance of `to`.

                    {

                        mstore(0x20, toSlotSeed)

                        mstore(0x00, mload(add(ids, i)))

                        let toBalanceSlot := keccak256(0x00, 0x40)

                        let toBalanceBefore := sload(toBalanceSlot)

                        let toBalanceAfter := add(toBalanceBefore, amount)

                        if lt(toBalanceAfter, toBalanceBefore) {

                            mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.

                            revert(0x1c, 0x04)

                        }

                        sstore(toBalanceSlot, toBalanceAfter)

                    }

                }

            }

            // Emit a {TransferBatch} event.

            {

                let m := mload(0x40)

                // Copy the `ids`.

                mstore(m, 0x40)

                let n := add(0x20, shl(5, mload(ids)))

                let o := add(m, 0x40)

                pop(staticcall(gas(), 4, ids, n, o, n))

                // Copy the `amounts`.

                mstore(add(m, 0x20), add(0x40, returndatasize()))

                o := add(o, returndatasize())

                n := add(0x20, shl(5, mload(amounts)))

                pop(staticcall(gas(), 4, amounts, n, o, n))

                n := sub(add(o, returndatasize()), m)

                // Do the emit.

                log4(m, n, _TRANSFER_BATCH_EVENT_SIGNATURE, caller(), 0, to)

            }

        }

        if (_useAfterTokenTransfer()) {

            _afterTokenTransfer(address(0), to, ids, amounts, data);

        }

        if (_hasCode(to)) _checkOnERC1155BatchReceived(address(0), to, ids, amounts, data);

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                  INTERNAL BURN FUNCTIONS                   */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Equivalent to `_burn(address(0), from, id, amount)`.

    function _burn(address from, uint256 id, uint256 amount) internal virtual {

        _burn(address(0), from, id, amount);

    }



    /// @dev Destroys `amount` of `id` from `from`.

    ///

    /// Requirements:

    /// - `from` must have at least `amount` of `id`.

    /// - If `by` is not the zero address, it must be either `from`,

    ///   or approved to manage the tokens of `from`.

    ///

    /// Emits a {Transfer} event.

    function _burn(address by, address from, uint256 id, uint256 amount) internal virtual {

        if (_useBeforeTokenTransfer()) {

            _beforeTokenTransfer(from, address(0), _single(id), _single(amount), "");

        }

        /// @solidity memory-safe-assembly

        assembly {

            let fromSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, from))

            mstore(0x20, fromSlotSeed)

            // Clear the upper 96 bits.

            from := shr(96, fromSlotSeed)

            by := shr(96, shl(96, by))

            // If `by` is not the zero address, and not equal to `from`,

            // check if it is approved to manage all the tokens of `from`.

            if iszero(or(iszero(by), eq(by, from))) {

                mstore(0x00, by)

                if iszero(sload(keccak256(0x0c, 0x34))) {

                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.

                    revert(0x1c, 0x04)

                }

            }

            // Decrease and store the updated balance of `from`.

            {

                mstore(0x00, id)

                let fromBalanceSlot := keccak256(0x00, 0x40)

                let fromBalance := sload(fromBalanceSlot)

                if gt(amount, fromBalance) {

                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.

                    revert(0x1c, 0x04)

                }

                sstore(fromBalanceSlot, sub(fromBalance, amount))

            }

            // Emit a {TransferSingle} event.

            {

                mstore(0x00, id)

                mstore(0x20, amount)

                log4(0x00, 0x40, _TRANSFER_SINGLE_EVENT_SIGNATURE, caller(), from, 0)

            }

        }

        if (_useAfterTokenTransfer()) {

            _afterTokenTransfer(from, address(0), _single(id), _single(amount), "");

        }

    }



    /// @dev Equivalent to `_batchBurn(address(0), from, ids, amounts)`.

    function _batchBurn(address from, uint256[] memory ids, uint256[] memory amounts)

        internal

        virtual

    {

        _batchBurn(address(0), from, ids, amounts);

    }



    /// @dev Destroys `amounts` of `ids` from `from`.

    ///

    /// Requirements:

    /// - `ids` and `amounts` must have the same length.

    /// - `from` must have at least `amounts` of `ids`.

    /// - If `by` is not the zero address, it must be either `from`,

    ///   or approved to manage the tokens of `from`.

    ///

    /// Emits a {TransferBatch} event.

    function _batchBurn(address by, address from, uint256[] memory ids, uint256[] memory amounts)

        internal

        virtual

    {

        if (_useBeforeTokenTransfer()) {

            _beforeTokenTransfer(from, address(0), ids, amounts, "");

        }

        /// @solidity memory-safe-assembly

        assembly {

            if iszero(eq(mload(ids), mload(amounts))) {

                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.

                revert(0x1c, 0x04)

            }

            let fromSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, from))

            mstore(0x20, fromSlotSeed)

            // Clear the upper 96 bits.

            from := shr(96, fromSlotSeed)

            by := shr(96, shl(96, by))

            // If `by` is not the zero address, and not equal to `from`,

            // check if it is approved to manage all the tokens of `from`.

            if iszero(or(iszero(by), eq(by, from))) {

                mstore(0x00, by)

                if iszero(sload(keccak256(0x0c, 0x34))) {

                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.

                    revert(0x1c, 0x04)

                }

            }

            // Loop through all the `ids` and update the balances.

            {

                let end := shl(5, mload(ids))

                for { let i := 0 } iszero(eq(i, end)) {} {

                    i := add(i, 0x20)

                    let amount := mload(add(amounts, i))

                    // Increase and store the updated balance of `to`.

                    {

                        mstore(0x00, mload(add(ids, i)))

                        let fromBalanceSlot := keccak256(0x00, 0x40)

                        let fromBalance := sload(fromBalanceSlot)

                        if gt(amount, fromBalance) {

                            mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.

                            revert(0x1c, 0x04)

                        }

                        sstore(fromBalanceSlot, sub(fromBalance, amount))

                    }

                }

            }

            // Emit a {TransferBatch} event.

            {

                let m := mload(0x40)

                // Copy the `ids`.

                mstore(m, 0x40)

                let n := add(0x20, shl(5, mload(ids)))

                let o := add(m, 0x40)

                pop(staticcall(gas(), 4, ids, n, o, n))

                // Copy the `amounts`.

                mstore(add(m, 0x20), add(0x40, returndatasize()))

                o := add(o, returndatasize())

                n := add(0x20, shl(5, mload(amounts)))

                pop(staticcall(gas(), 4, amounts, n, o, n))

                n := sub(add(o, returndatasize()), m)

                // Do the emit.

                log4(m, n, _TRANSFER_BATCH_EVENT_SIGNATURE, caller(), from, 0)

            }

        }

        if (_useAfterTokenTransfer()) {

            _afterTokenTransfer(from, address(0), ids, amounts, "");

        }

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                INTERNAL APPROVAL FUNCTIONS                 */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Approve or remove the `operator` as an operator for `by`,

    /// without authorization checks.

    ///

    /// Emits a {ApprovalForAll} event.

    function _setApprovalForAll(address by, address operator, bool isApproved) internal virtual {

        /// @solidity memory-safe-assembly

        assembly {

            // Clear the upper 96 bits.

            operator := shr(96, shl(96, operator))

            // Convert to 0 or 1.

            isApproved := iszero(iszero(isApproved))

            // Update the `isApproved` for (`by`, `operator`).

            mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, shl(96, by)))

            mstore(0x00, operator)

            sstore(keccak256(0x0c, 0x34), isApproved)

            // Emit the {ApprovalForAll} event.

            mstore(0x00, isApproved)

            log3(0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, caller(), operator)

        }

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                INTERNAL TRANSFER FUNCTIONS                 */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Equivalent to `_safeTransfer(address(0), from, to, id, amount, data)`.

    function _safeTransfer(address from, address to, uint256 id, uint256 amount, bytes memory data)

        internal

        virtual

    {

        _safeTransfer(address(0), from, to, id, amount, data);

    }



    /// @dev Transfers `amount` of `id` from `from` to `to`.

    ///

    /// Requirements:

    /// - `to` cannot be the zero address.

    /// - `from` must have at least `amount` of `id`.

    /// - If `by` is not the zero address, it must be either `from`,

    ///   or approved to manage the tokens of `from`.

    /// - If `to` refers to a smart contract, it must implement

    ///   {ERC1155-onERC1155Reveived}, which is called upon a batch transfer.

    ///

    /// Emits a {Transfer} event.

    function _safeTransfer(

        address by,

        address from,

        address to,

        uint256 id,

        uint256 amount,

        bytes memory data

    ) internal virtual {

        if (_useBeforeTokenTransfer()) {

            _beforeTokenTransfer(from, to, _single(id), _single(amount), data);

        }

        /// @solidity memory-safe-assembly

        assembly {

            let fromSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, from))

            let toSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, to))

            mstore(0x20, fromSlotSeed)

            // Clear the upper 96 bits.

            from := shr(96, fromSlotSeed)

            to := shr(96, toSlotSeed)

            by := shr(96, shl(96, by))

            // If `by` is not the zero address, and not equal to `from`,

            // check if it is approved to manage all the tokens of `from`.

            if iszero(or(iszero(by), eq(by, from))) {

                mstore(0x00, by)

                if iszero(sload(keccak256(0x0c, 0x34))) {

                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.

                    revert(0x1c, 0x04)

                }

            }

            // Revert if `to` is the zero address.

            if iszero(to) {

                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.

                revert(0x1c, 0x04)

            }

            // Subtract and store the updated balance of `from`.

            {

                mstore(0x00, id)

                let fromBalanceSlot := keccak256(0x00, 0x40)

                let fromBalance := sload(fromBalanceSlot)

                if gt(amount, fromBalance) {

                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.

                    revert(0x1c, 0x04)

                }

                sstore(fromBalanceSlot, sub(fromBalance, amount))

            }

            // Increase and store the updated balance of `to`.

            {

                mstore(0x20, toSlotSeed)

                let toBalanceSlot := keccak256(0x00, 0x40)

                let toBalanceBefore := sload(toBalanceSlot)

                let toBalanceAfter := add(toBalanceBefore, amount)

                if lt(toBalanceAfter, toBalanceBefore) {

                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.

                    revert(0x1c, 0x04)

                }

                sstore(toBalanceSlot, toBalanceAfter)

            }

            // Emit a {TransferSingle} event.

            {

                mstore(0x20, amount)

                log4(0x00, 0x40, _TRANSFER_SINGLE_EVENT_SIGNATURE, caller(), from, to)

            }

        }

        if (_hasCode(to)) _checkOnERC1155Received(from, to, id, amount, data);

        if (_useAfterTokenTransfer()) {

            _afterTokenTransfer(from, to, _single(id), _single(amount), data);

        }

    }



    /// @dev Equivalent to `_safeBatchTransfer(address(0), from, to, ids, amounts, data)`.

    function _safeBatchTransfer(

        address from,

        address to,

        uint256[] memory ids,

        uint256[] memory amounts,

        bytes memory data

    ) internal virtual {

        _safeBatchTransfer(address(0), from, to, ids, amounts, data);

    }



    /// @dev Transfers `amounts` of `ids` from `from` to `to`.

    ///

    /// Requirements:

    /// - `to` cannot be the zero address.

    /// - `ids` and `amounts` must have the same length.

    /// - `from` must have at least `amounts` of `ids`.

    /// - If `by` is not the zero address, it must be either `from`,

    ///   or approved to manage the tokens of `from`.

    /// - If `to` refers to a smart contract, it must implement

    ///   {ERC1155-onERC1155BatchReveived}, which is called upon a batch transfer.

    ///

    /// Emits a {TransferBatch} event.

    function _safeBatchTransfer(

        address by,

        address from,

        address to,

        uint256[] memory ids,

        uint256[] memory amounts,

        bytes memory data

    ) internal virtual {

        if (_useBeforeTokenTransfer()) {

            _beforeTokenTransfer(from, to, ids, amounts, data);

        }

        /// @solidity memory-safe-assembly

        assembly {

            if iszero(eq(mload(ids), mload(amounts))) {

                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.

                revert(0x1c, 0x04)

            }

            let fromSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, from))

            let toSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, to))

            mstore(0x20, fromSlotSeed)

            // Clear the upper 96 bits.

            from := shr(96, fromSlotSeed)

            to := shr(96, toSlotSeed)

            by := shr(96, shl(96, by))

            // Revert if `to` is the zero address.

            if iszero(to) {

                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.

                revert(0x1c, 0x04)

            }

            // If `by` is not the zero address, and not equal to `from`,

            // check if it is approved to manage all the tokens of `from`.

            if iszero(or(iszero(by), eq(by, from))) {

                mstore(0x00, by)

                if iszero(sload(keccak256(0x0c, 0x34))) {

                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.

                    revert(0x1c, 0x04)

                }

            }

            // Loop through all the `ids` and update the balances.

            {

                let end := shl(5, mload(ids))

                for { let i := 0 } iszero(eq(i, end)) {} {

                    i := add(i, 0x20)

                    let amount := mload(add(amounts, i))

                    // Subtract and store the updated balance of `from`.

                    {

                        mstore(0x20, fromSlotSeed)

                        mstore(0x00, mload(add(ids, i)))

                        let fromBalanceSlot := keccak256(0x00, 0x40)

                        let fromBalance := sload(fromBalanceSlot)

                        if gt(amount, fromBalance) {

                            mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.

                            revert(0x1c, 0x04)

                        }

                        sstore(fromBalanceSlot, sub(fromBalance, amount))

                    }

                    // Increase and store the updated balance of `to`.

                    {

                        mstore(0x20, toSlotSeed)

                        let toBalanceSlot := keccak256(0x00, 0x40)

                        let toBalanceBefore := sload(toBalanceSlot)

                        let toBalanceAfter := add(toBalanceBefore, amount)

                        if lt(toBalanceAfter, toBalanceBefore) {

                            mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.

                            revert(0x1c, 0x04)

                        }

                        sstore(toBalanceSlot, toBalanceAfter)

                    }

                }

            }

            // Emit a {TransferBatch} event.

            {

                let m := mload(0x40)

                // Copy the `ids`.

                mstore(m, 0x40)

                let n := add(0x20, shl(5, mload(ids)))

                let o := add(m, 0x40)

                pop(staticcall(gas(), 4, ids, n, o, n))

                // Copy the `amounts`.

                mstore(add(m, 0x20), add(0x40, returndatasize()))

                o := add(o, returndatasize())

                n := add(0x20, shl(5, mload(amounts)))

                pop(staticcall(gas(), 4, amounts, n, o, n))

                n := sub(add(o, returndatasize()), m)

                // Do the emit.

                log4(m, n, _TRANSFER_BATCH_EVENT_SIGNATURE, caller(), from, to)

            }

        }

        if (_hasCode(to)) _checkOnERC1155BatchReceived(from, to, ids, amounts, data);

        if (_useAfterTokenTransfer()) {

            _afterTokenTransfer(from, to, ids, amounts, data);

        }

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                    HOOKS FOR OVERRIDING                    */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Override this function to return true if `_beforeTokenTransfer` is used.

    /// The is to help the compiler avoid producing dead bytecode.

    function _useBeforeTokenTransfer() internal view virtual returns (bool) {

        return false;

    }



    /// @dev Hook that is called before any token transfer.

    /// This includes minting and burning, as well as batched variants.

    ///

    /// The same hook is called on both single and batched variants.

    /// For single transfers, the length of the `id` and `amount` arrays are 1.

    function _beforeTokenTransfer(

        address from,

        address to,

        uint256[] memory ids,

        uint256[] memory amounts,

        bytes memory data

    ) internal virtual {}



    /// @dev Override this function to return true if `_afterTokenTransfer` is used.

    /// The is to help the compiler avoid producing dead bytecode.

    function _useAfterTokenTransfer() internal view virtual returns (bool) {

        return false;

    }



    /// @dev Hook that is called after any token transfer.

    /// This includes minting and burning, as well as batched variants.

    ///

    /// The same hook is called on both single and batched variants.

    /// For single transfers, the length of the `id` and `amount` arrays are 1.

    function _afterTokenTransfer(

        address from,

        address to,

        uint256[] memory ids,

        uint256[] memory amounts,

        bytes memory data

    ) internal virtual {}



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                      PRIVATE HELPERS                       */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Helper for calling the `_afterTokenTransfer` hook.

    /// The is to help the compiler avoid producing dead bytecode.

    function _afterTokenTransferCalldata(

        address from,

        address to,

        uint256[] calldata ids,

        uint256[] calldata amounts,

        bytes calldata data

    ) private {

        if (_useAfterTokenTransfer()) {

            _afterTokenTransfer(from, to, ids, amounts, data);

        }

    }



    /// @dev Returns if `a` has bytecode of non-zero length.

    function _hasCode(address a) private view returns (bool result) {

        /// @solidity memory-safe-assembly

        assembly {

            result := extcodesize(a) // Can handle dirty upper bits.

        }

    }



    /// @dev Perform a call to invoke {IERC1155Receiver-onERC1155Received} on `to`.

    /// Reverts if the target does not support the function correctly.

    function _checkOnERC1155Received(

        address from,

        address to,

        uint256 id,

        uint256 amount,

        bytes memory data

    ) private {

        /// @solidity memory-safe-assembly

        assembly {

            // Prepare the calldata.

            let m := mload(0x40)

            let onERC1155ReceivedSelector := 0xf23a6e61

            mstore(m, onERC1155ReceivedSelector)

            mstore(add(m, 0x20), caller())

            mstore(add(m, 0x40), shr(96, shl(96, from)))

            mstore(add(m, 0x60), id)

            mstore(add(m, 0x80), amount)

            mstore(add(m, 0xa0), 0xa0)

            let n := mload(data)

            mstore(add(m, 0xc0), n)

            if n { pop(staticcall(gas(), 4, add(data, 0x20), n, add(m, 0xe0), n)) }

            // Revert if the call reverts.

            if iszero(call(gas(), to, 0, add(m, 0x1c), add(0xc4, n), m, 0x20)) {

                if returndatasize() {

                    // Bubble up the revert if the delegatecall reverts.

                    returndatacopy(0x00, 0x00, returndatasize())

                    revert(0x00, returndatasize())

                }

                mstore(m, 0)

            }

            // Load the returndata and compare it.

            if iszero(eq(mload(m), shl(224, onERC1155ReceivedSelector))) {

                mstore(0x00, 0x9c05499b) // `TransferToNonERC1155ReceiverImplementer()`.

                revert(0x1c, 0x04)

            }

        }

    }



    /// @dev Perform a call to invoke {IERC1155Receiver-onERC1155BatchReceived} on `to`.

    /// Reverts if the target does not support the function correctly.

    function _checkOnERC1155BatchReceived(

        address from,

        address to,

        uint256[] memory ids,

        uint256[] memory amounts,

        bytes memory data

    ) private {

        /// @solidity memory-safe-assembly

        assembly {

            // Prepare the calldata.

            let m := mload(0x40)

            let onERC1155BatchReceivedSelector := 0xbc197c81

            mstore(m, onERC1155BatchReceivedSelector)

            mstore(add(m, 0x20), caller())

            mstore(add(m, 0x40), shr(96, shl(96, from)))

            // Copy the `ids`.

            mstore(add(m, 0x60), 0xa0)

            let n := add(0x20, shl(5, mload(ids)))

            let o := add(m, 0xc0)

            pop(staticcall(gas(), 4, ids, n, o, n))

            // Copy the `amounts`.

            let s := add(0xa0, returndatasize())

            mstore(add(m, 0x80), s)

            o := add(o, returndatasize())

            n := add(0x20, shl(5, mload(amounts)))

            pop(staticcall(gas(), 4, amounts, n, o, n))

            // Copy the `data`.

            mstore(add(m, 0xa0), add(s, returndatasize()))

            o := add(o, returndatasize())

            n := add(0x20, mload(data))

            pop(staticcall(gas(), 4, data, n, o, n))

            n := sub(add(o, returndatasize()), add(m, 0x1c))

            // Revert if the call reverts.

            if iszero(call(gas(), to, 0, add(m, 0x1c), n, m, 0x20)) {

                if returndatasize() {

                    // Bubble up the revert if the delegatecall reverts.

                    returndatacopy(0x00, 0x00, returndatasize())

                    revert(0x00, returndatasize())

                }

                mstore(m, 0)

            }

            // Load the returndata and compare it.

            if iszero(eq(mload(m), shl(224, onERC1155BatchReceivedSelector))) {

                mstore(0x00, 0x9c05499b) // `TransferToNonERC1155ReceiverImplementer()`.

                revert(0x1c, 0x04)

            }

        }

    }



    /// @dev Returns `x` in an array with a single element.

    function _single(uint256 x) private pure returns (uint256[] memory result) {

        assembly {

            result := mload(0x40)

            mstore(0x40, add(result, 0x40))

            mstore(result, 1)

            mstore(add(result, 0x20), x)

        }

    }

}



// File: miladystationrejects/rejects.sol







/// @title miladystationrejects

/// @author arthurt

/// @notice !pray ✦✦✦



pragma solidity ^0.8.17;











contract MiladyStationRejects is ERC1155, Ownable {



    error IDAmountMismatch();

    error WalletUnauthorizedToMint();

    error NotFriend();

    error IncorrectValueSent();

    error GreedyAlliance();

    error FirmamentReached();

    error NeedThree();



    string public name = "Mony MissingNo.";

    string public symbol = "MSX";

    string public _uri;

    bytes32 public root;





    struct Token {

        string name;

        uint currentSupply;

    }



    uint256 public count;



    mapping(uint => Token) public tokens;

    mapping(address => bool) public holderMints;



    constructor()  {      

        _initializeOwner(msg.sender); 

    }



    function setRoot(bytes32 newRoot) public onlyOwner {

        root = newRoot;

    }



    function mintSingle(

        uint id

    ) public payable {

        if (count + 1 > 123) { revert FirmamentReached();}

        if (msg.value != 7000000000000000) { revert IncorrectValueSent();}

        _mint(msg.sender, id, 1, "");

        tokens[id].currentSupply += 1;

        count += 1;

    }



    function mintMerkleSingle(

        bytes32[] calldata proof,

        uint id

    ) public payable {

        if (count + 3 > 123 || holderMints[msg.sender]) { revert FirmamentReached();}

        if(proven(proof, root, leafit())){

        _mint(msg.sender, id, 3, "");

        tokens[id].currentSupply += 3;

        count += 3;

        holderMints[msg.sender] = true;

        } else {

            revert WalletUnauthorizedToMint();

        }

    }



    function mintBatch(

        uint[] calldata ids,

        uint[] calldata amounts

    ) external payable {

        if(ids.length != amounts.length) revert IDAmountMismatch();

        uint256 _amt;

        uint totalEtherPrice;

        for (uint i = 0; i < ids.length; i++) {

            totalEtherPrice += amounts[i] * 7000000000000000;

            _amt += amounts[i];

        }

        if (count + _amt > 123) { revert FirmamentReached();}

        if (msg.value != totalEtherPrice) { revert IncorrectValueSent();}

        _batchMint(msg.sender, ids, amounts, "");

        for (uint i = 0; i < ids.length; i++) {

            tokens[ids[i]].currentSupply += amounts[i];

        }

        count += _amt;

    }



    function mintMerkleBatch(

        bytes32[] calldata proof,

        uint[] calldata ids

    ) external payable {



        if(ids.length != 3) revert NeedThree();



        uint256 amt = 1;

        uint256[] memory amts = new uint256[](3);

        amts[0] = amt;

        amts[1] = amt;

        amts[2] = amt;

        if (count + 3 > 123 || holderMints[msg.sender]) { revert FirmamentReached();}

        if(proven(proof, root, leafit())){

        _batchMint(msg.sender, ids, amts, "");

        for (uint i = 0; i < ids.length; i++) {

            tokens[ids[i]].currentSupply += 1;

        }

        count += 3;

        holderMints[msg.sender] = true;

        } else {

            revert WalletUnauthorizedToMint();

        }

    }



    //uses solady merkleprooflib to prove a merkle proof proves merkleness

    function proven (bytes32[] calldata proof, bytes32 key, bytes32 leaf) public pure returns (bool) {

        bool prove = MerkleProofLib.verifyCalldata(proof, key, leaf);

        return prove;

    }



    //hashes person interacting for merkling

    function leafit() public view returns (bytes32) {

        bytes20 me = bytes20(msg.sender);

        return keccak256(abi.encodePacked(me));

    }



    /// solady override with token id

    function uri(uint256) public view virtual override returns (string memory) {

        return _uri;

    }



    function setURI(string memory newuri) external onlyOwner {

        _uri = newuri;

    }



    function withdraw() external onlyOwner {

        uint balance = address(this).balance;

        payable(msg.sender).transfer(balance);

    }



}