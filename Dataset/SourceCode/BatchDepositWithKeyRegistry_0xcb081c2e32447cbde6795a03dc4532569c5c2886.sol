{{

  "language": "Solidity",

  "sources": {

    "@openzeppelin/contracts/access/Ownable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"

    },

    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/Context.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/math/SafeMath.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"

    },

    "contracts/contracts-BatchDepositWithKeyRegistry/BatchDepositWithKeyRegistry.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity  ^0.8.13;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\nimport \"./interfaces/IBatchDepositWithKeyRegistry.sol\";\nimport \"./interfaces/IDepositContract.sol\";\nimport \"./interfaces/IKeyRegistry.sol\";\n\ncontract BatchDepositWithKeyRegistry is IBatchDepositWithKeyRegistry, Ownable, ReentrancyGuard{\n    using SafeMath for uint256;\n\n    /// @dev asset manager address\n    address public assetManager;\n\n    /// @dev ETH2 depositContract address\n    address public immutable depositContract;\n\n    /// @dev KeyRegistry contract address\n    address public keyRegistry;\n\n    uint256 constant public DEPOSIT_AMOUNT = 32 ether;\n    uint256 internal constant DEPOSIT_AMOUNT_UNIT = 1000000000 wei;\n    uint256 constant public SIGNATURE_LENGTH = 96;\n\n    /// @dev default value for maximum number of Ethereum 2.0 validators registered in a single  call \n    uint256 public maxDepositsPerCall;\n\n    /// @dev deposit whitelist\n    mapping(address => bool) public whitelist;\n\n    /// @dev depositETH method switch\n    bool public depositEnabled;\n\n    constructor(\n        address _assetManager,\n        address _depositContract,\n        address _keyRegistry,\n        uint256 _initMaxDepositCount\n    ) {\n        require(address(_assetManager) != address(0), \"invalid init asset manager address\");\n        require(address(_depositContract) != address(0), \"invalid init ETH2 depositContract address\");\n        require(address(_keyRegistry) != address(0), \"invalid init KeyRegistry address\");\n        require(_initMaxDepositCount != 0, \"invalid init max deposit per call\");\n        assetManager = _assetManager;\n        depositContract = _depositContract;\n        keyRegistry = _keyRegistry;\n        maxDepositsPerCall = _initMaxDepositCount;\n\n        emit Deployed(msg.sender,_assetManager, _depositContract, _keyRegistry, _initMaxDepositCount);\n    }\n\n    /// @dev receive ETH and deposit\n    receive() external payable {\n        depositETH();\n    }\n\n    /// @dev asset manager authority\n    modifier onlyAssetManager() {\n        require(msg.sender == assetManager, \"not asset manager\");\n        _;\n    }\n\n    /// @dev whitelist users` authority\n    modifier onlyWhitelisted() {\n        require(whitelist[msg.sender] == true, \"not in the whitelist\");\n        _;\n    }\n\n    /// @dev depositETH method switch\n    modifier onlyDepositEnabled() {\n        require(depositEnabled == true, \"not enabled\");\n        _;\n    }\n\n    /// @dev Turn on the depositETH switch\n    function enable() public onlyOwner {\n        require(depositEnabled != true, \"already enabled\");\n        depositEnabled = true;\n        emit Enable();\n    }\n\n    /// @dev Turn off the depositETH switch\n    function pause() public onlyOwner {\n        require(depositEnabled != false, \"already paused\");\n        depositEnabled = false;\n        emit Pause();\n    }\n\n    /// @dev update asset manager address, only owner can operator\n    /// @param _newAssetManager new asset manager address\n    function updateAssetManager(address _newAssetManager) public onlyOwner {\n        require(address(_newAssetManager) != address(0), \"invalid new asset manager address\");\n        require(address(_newAssetManager) != address(assetManager), \"asset manager address repeat\");\n        assetManager = _newAssetManager;\n        emit UpdateAssetManager(_newAssetManager);\n    }\n\n    /// @dev update maxDepositsPerCall, only asset manager can operator\n    /// @param _newMaxDepositCount new maxDepositsPerCall\n    function updateMaxDepositCount(uint256 _newMaxDepositCount) public onlyAssetManager {\n        require(_newMaxDepositCount != 0, \"zero max deposit count set\");\n        require(_newMaxDepositCount != maxDepositsPerCall, \"repeat setting max deposit count\");                                                                                  \n        maxDepositsPerCall = _newMaxDepositCount;\n        emit UpdateMaxDeposit(_newMaxDepositCount);\n    }\n\n    /// @dev update KeyRegistry contract address, only owner can operator\n    /// @param _newKeyRegistry new KeyRegistry contract address\n    function updateKeyRegistry(address _newKeyRegistry) public onlyOwner {\n        require(address(_newKeyRegistry) != address(0), \"invalid new KeyRegistry address\");\n        require(address(_newKeyRegistry) != address(keyRegistry), \"KeyRegistry address repeat\");\n        keyRegistry = _newKeyRegistry;\n        emit UpdateKeyRegistry(_newKeyRegistry);\n    }\n\n    // @dev add single account or multiple accounts to whitelist\n    /// @param _addrs accounts addresses\n    function addAddressesToWhitelist(address[] memory _addrs) public onlyAssetManager {\n        for (uint256 i = 0; i < _addrs.length; i++) {\n            require(_addrs[i] != address(0),\"invalid address\");\n            require(whitelist[_addrs[i]] != true, \"already in the whitelist\");\n            whitelist[_addrs[i]] = true;\n            emit WhitelistAddressAdded(_addrs[i]);\n        }\n    }\n\n    /// @dev remove single accounts or multiple accounts from whitelist\n    /// @param _addrs accounts addresses\n    function removeAddressesFromWhitelist(address[] memory _addrs) public onlyAssetManager {\n        for (uint256 i = 0; i < _addrs.length; i++) {\n            require(_addrs[i] != address(0),\"invalid address\");\n            require(whitelist[_addrs[i]] == true, \"not in the whitelist\");\n            delete whitelist[_addrs[i]];\n            emit WhitelistAddressRemoved(_addrs[i]);\n        }\n    }\n\n    /// @dev deposit ETH to ETH2 depositContract, only in the whitelist can use this method\n    function depositETH() public payable nonReentrant onlyWhitelisted onlyDepositEnabled {\n        uint256 ethAmount = msg.value;\n        uint256 numKeys = ethAmount.div(DEPOSIT_AMOUNT);\n        require(ethAmount != 0, \"zero ETH deposited\");\n        require(ethAmount.mod(DEPOSIT_AMOUNT) == 0, \"not a multiple of 32\");\n        require(numKeys <= maxDepositsPerCall, \"over max keys\");\n\n        eth2Deposit(numKeys);\n\n        emit ETHDeposited(msg.sender, numKeys, ethAmount);\n    }\n\n    function eth2Deposit(uint256 numDeposit) internal {\n        (\n            bytes[] memory pubKeys,\n            bytes[] memory withdrawalCredentials,\n            bytes[] memory signatures\n        ) = IKeyRegistry(keyRegistry).assignKeys(msg.sender, numDeposit);\n\n        uint256 keyAmount = pubKeys.length;\n        require(keyAmount != 0, \"error pubKeys amounts\");\n        require(withdrawalCredentials.length == keyAmount, \"error withdrawalCredentials amounts\");\n        require(signatures.length == keyAmount, \"error signatures amounts\");\n\n        for (uint256 i = 0; i < keyAmount; i++) {\n            _deposit(pubKeys[i], withdrawalCredentials[i], signatures[i]);\n        }\n    }\n\n    function _deposit(bytes memory pubKey, bytes memory withdrawalCredential, bytes memory signature) internal {\n        uint256 valueAmount = DEPOSIT_AMOUNT;\n        uint256 depositAmounts = valueAmount.div(DEPOSIT_AMOUNT_UNIT);\n        require(depositAmounts.mul(DEPOSIT_AMOUNT_UNIT) == valueAmount, \"depositAmounts error\");\n\n        bytes32 pubkeyRoot = sha256(_pad64(pubKey));\n        bytes32 signatureRoot = sha256(\n            abi.encodePacked(\n                sha256(BytesLib.slice(signature, 0, 64)),\n                sha256(_pad64(BytesLib.slice(signature, 64, SIGNATURE_LENGTH.sub(64))))\n                )\n            );\n        \n        bytes32 depositDataRoot = sha256(\n          abi.encodePacked(\n              sha256(abi.encodePacked(pubkeyRoot,withdrawalCredential)),\n              sha256(abi.encodePacked(_toLittleEndian64(depositAmounts),signatureRoot))\n          )\n        );\n        uint256 targetBalance = address(this).balance.sub(valueAmount);\n\n        IDepositContract(depositContract).deposit{value : valueAmount}(pubKey, abi.encodePacked(withdrawalCredential), signature, depositDataRoot);\n        require(address(this).balance == targetBalance, \"expecting deposit to happen\");\n        emit Deposited(msg.sender, pubKey, withdrawalCredential, signature, depositDataRoot, valueAmount);\n    }\n\n    /// @dev sweep ETH in this contract\n    /// @param _receiver ETH receiver address\n    function sweep(address _receiver) public onlyOwner nonReentrant {\n        uint256 currentBalance = address(this).balance;\n        require(currentBalance != 0, \"invalid balance\");\n        require(_receiver != address(0), \"invalid receiver address\");\n        (bool sent,) = payable(_receiver).call{value: currentBalance}(\"\");\n        require(sent, \"failed sweep\");\n\n        emit Swept(msg.sender, _receiver, currentBalance);\n    }\n\n    function _pad64(bytes memory _b) internal pure returns (bytes memory) {\n        assert(_b.length >= 32 && _b.length <= 64);\n        if (64 == _b.length)\n            return _b;\n\n        bytes memory zero32 = new bytes(32);\n        assembly { mstore(add(zero32, 0x20), 0) }\n\n        if (32 == _b.length)\n            return BytesLib.concat(_b, zero32);\n        else\n            return BytesLib.concat(_b, BytesLib.slice(zero32, 0, uint256(64).sub(_b.length)));\n    }\n\n    function _toLittleEndian64(uint256 _value) internal pure returns (uint256 result) {\n        result = 0;\n        uint256 temp_value = _value;\n        for (uint256 i = 0; i < 8; ++i) {\n            result = (result << 8) | (temp_value & 0xFF);\n            temp_value >>= 8;\n        }\n\n        assert(0 == temp_value);    // fully converted\n        result <<= (24 * 8);\n    }\n}"

    },

    "contracts/contracts-BatchDepositWithKeyRegistry/interfaces/IBatchDepositWithKeyRegistry.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity  ^0.8.13;\n\ninterface IBatchDepositWithKeyRegistry {\n\n    event Deployed(\n        address indexed deployer,\n        address indexed assetManager, \n        address indexed depositContract,\n        address keyRegistry,\n        uint256 initMaxDepositCount\n    );\n\n    event ETHDeposited(address from, uint256 keysNumber, uint256 ethAmount);\n\n    event Enable();\n\n    event Pause();\n\n    event UpdateAssetManager(address newAssetManager);\n\n    event UpdateMaxDeposit(uint256 newMaxDepositCount);\n\n    event UpdateKeyRegistry(address newKeyRegistry);\n\n    event WhitelistAddressAdded(address userAddress);\n\n    event WhitelistAddressRemoved(address userAddress);\n\n    event Deposited(\n        address indexed from, \n        bytes pubkey, \n        bytes withdrawalCredentials, \n        bytes signature,\n        bytes32 depositDataRoot,\n        uint256 ethAmount\n    );\n\n    event Swept(address from, address to, uint256 amount);\n\n    function whitelist(address) external view returns(bool);\n\n    function enable() external;\n\n    function pause() external;\n\n    function updateAssetManager(address _newAssetManager) external;\n\n    function updateKeyRegistry(address _newKeyRegistry) external;\n\n    function addAddressesToWhitelist(address[] memory _addrs) external;\n\n    function removeAddressesFromWhitelist(address[] memory _addrs) external;\n\n    function depositETH() external payable;\n\n    function sweep(address _receiver) external;\n}"

    },

    "contracts/contracts-BatchDepositWithKeyRegistry/interfaces/IDepositContract.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\ninterface IDepositContract {\n    /// @notice A processed deposit event.\n    event DepositEvent(\n        bytes pubkey,\n        bytes withdrawal_credentials,\n        bytes amount,\n        bytes signature,\n        bytes index\n    );\n\n    function deposit(\n        bytes calldata pubkey,\n        bytes calldata withdrawal_credentials,\n        bytes calldata signature,\n        bytes32 deposit_data_root\n    ) external payable;\n\n    function get_deposit_root() external view returns (bytes32);\n\n    function get_deposit_count() external view returns (bytes memory);\n}"

    },

    "contracts/contracts-BatchDepositWithKeyRegistry/interfaces/IKeyRegistry.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\n\ninterface IKeyRegistry {\n\n    /// @dev Emitted when BatchDeposit contract address updated\n    event UpdateBatchDepositContract(address indexed newBatchDepositContract);\n\n    /// @param _newBatchDepositContract new BatchDeposit contract address\n    function updateBatchDepositContract(address _newBatchDepositContract) external;\n\n    /// @dev Emitted when Asset Manager updated\n    event UpdateAssetManager(address indexed _assetManager);\n\n    /// @param _assetManager assetManager address\n    function updateAssetManager(address _assetManager) external;\n\n\n    /// @dev Key structure\n    struct KeyInfo {\n        bytes pubkey;\n        bytes withdrawalCredential;\n        bytes signature;\n    }\n\n    /// @dev Emitted when one key added\n    event AddKey(bytes pubkey);\n\n    /// @dev AssetManager submit keys. pubkeys, withdrawalCredentials and signatures are one-to-one correspondence in array.\n    /// @param _addr address that can use keys submitted\n    /// @param quantity keys' quantity\n    /// @param pubkeys pubkeys\n    /// @param withdrawalCredentials withdrawalCredentials\n    /// @param signatures signatures\n    function addKeys(\n        address _addr,\n        uint256 quantity,\n        bytes[] calldata pubkeys,\n        bytes[] calldata withdrawalCredentials,\n        bytes[] calldata signatures\n    ) external;\n\n    /// @dev Emitted when one key removed\n    event RemoveKey(bytes pubkey);\n\n    /// @dev AssetManager remove keys. Will remove [startIdx, endIdx] range in keys[_addr].\n    /// @param _addr address's keys to remove\n    /// @param startIdx start index to remove, the startIdx element is removed\n    /// @param endIdx end index to remove, the endIdx element is removed.\n    function removeKeys(\n        address _addr,\n        uint256 startIdx,\n        uint256 endIdx\n    ) external;\n\n    /// @dev Emitted when one key assigned\n    event AssignKey(bytes pubkey);\n\n    /// @dev EPotter assign keys to use. require keys are enough.\n    /// @param _addr address's keys to assign\n    /// @param quantity quantity\n    /// @return return pubkeys, withdrawalCredentials and signatures, they are one-to-one correspondence in array.\n    function assignKeys(address _addr, uint256 quantity)\n        external\n        returns (\n            bytes[] memory,\n            bytes[] memory,\n            bytes[] memory\n        );\n\n    /// @dev Get total quantity of _addr's keys\n    /// @param _addr who's key\n    /// @return total quantity\n    function getTotalQuantity(address _addr) external view returns (uint256);\n\n    /// @dev Get used quantity of _addr's keys\n    /// @param _addr who's key\n    /// @return used quantity\n    function getUsedQuantity(address _addr) external view returns (uint256);\n\n    /// @dev Get unused quantity of _addr's keys\n    /// @param _addr who's key\n    /// @return unused quantity\n    function getUnusedQuantity(address _addr) external view returns (uint256);\n\n    /// @dev get keys from startIdx to endIdx\n    /// @param _addr who's key\n    /// @param startIdx start index\n    /// @param endIdx end index\n    /// @return from start index to en index, keys' info\n    function getMultipleKeys(address _addr, uint256 startIdx, uint256 endIdx) external view returns(KeyInfo[] memory);\n\n    /// @dev get pointed key\n    /// @param _addr who's key\n    /// @param _index index\n    function getSingleKey(address _addr, uint256 _index) external view returns(KeyInfo memory);\n}\n"

    },

    "solidity-bytes-utils/contracts/BytesLib.sol": {

      "content": "// SPDX-License-Identifier: Unlicense\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity >=0.8.0 <0.9.0;\n\n\nlibrary BytesLib {\n    function concat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n              not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n            // Read the first 32 bytes of _preBytes storage, which is the length\n            // of the array. (We don't need to use the offset into the slot\n            // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n                // Since the new array still fits in the slot, we just need to\n                // update the contents of the slot.\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                    _preBytes.slot,\n                    // all the modifications to the slot are inside this\n                    // next block\n                    add(\n                        // we can just add to the slot contents because the\n                        // bytes we want to change are the LSBs\n                        fslot,\n                        add(\n                            mul(\n                                div(\n                                    // load the bytes from memory\n                                    mload(add(_postBytes, 0x20)),\n                                    // zero all bytes to the right\n                                    exp(0x100, sub(32, mlength))\n                                ),\n                                // and now shift left the number of bytes to\n                                // leave space for the length in the slot\n                                exp(0x100, sub(32, newlength))\n                            ),\n                            // increase length by the double of the memory\n                            // bytes length\n                            mul(mlength, 2)\n                        )\n                    )\n                )\n            }\n            case 1 {\n                // The stored value fits in the slot, but the combined value\n                // will exceed it.\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // The contents of the _postBytes array start 32 bytes into\n                // the structure. Our first read should obtain the `submod`\n                // bytes that can fit into the unused space in the last word\n                // of the stored array. To get this, we read 32 bytes starting\n                // from `submod`, so the data we read overlaps with the array\n                // contents by `submod` bytes. Masking the lowest-order\n                // `submod` bytes allows us to add that value directly to the\n                // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                    sc,\n                    add(\n                        and(\n                            fslot,\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                        ),\n                        and(mload(mc), mask)\n                    )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // Copy over the first `submod` bytes of the new data as in\n                // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1 , \"toUint8_outOfBounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, \"toUint16_outOfBounds\");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, \"toUint32_outOfBounds\");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, \"toUint64_outOfBounds\");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, \"toUint96_outOfBounds\");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, \"toUint128_outOfBounds\");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, \"toUint256_outOfBounds\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, \"toBytes32_outOfBounds\");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                // the next line is the loop condition:\n                // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(\n        bytes storage _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        view\n        returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // slength can contain both the length and contents of the array\n                // if length < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while(uint256(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}\n"

    }

  },

  "settings": {

    "optimizer": {

      "enabled": true,

      "runs": 200

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "libraries": {}

  }

}}