// SPDX-License-Identifier: MIT
/*
                                                           .,,
                                                           ;░░▒▒
                                                           ;░φφ░╚╠
                                                       .░φ░░░░Γ╙╙
                                                       '░░░░
                                                           ░░░░
                                                           ¡░░░░
                                                           ¡░░░░
                                                           ¡░░░¡░
                                                           :░░▒░!-
                                                           ¡░¡░▒░│-
                                                       .│''░▒░┐'░
                                                       ;''¡░╠▒░.'░
                                                   .,,;'''¡░╠╠░░. ┌
                                               .░░░░░░┐..¡¡░╠╠▒░┐ '.
                                               .░│¡░░░░░░░¡░░░▒╠▒░░. '~
                                               ;│.¡░░░░░░░░░░░░▒╠╠░░' .
                                           ;░┌¡░░░░░░░░░░░░▒╠╠╠░░'.░⌐
                                             ;░.¡░░φ▒▒▒▒▒░░░░▒▒╠╬▒░░\░░
                                           ;░┐¡░φ╠╠╬╬╠╠▒▒▒▒▒╠╠╬╠▒░░░░
                                       .░░.░φ▒╠╬╬╬╣╣╣╬╬╠╠╠╠╬╬▒░░░░
                                       .░░│░░▒╠╠╠╠╬╬╬▓██▓▓╬╬╬╬▒░░░░
                                       ░░░░φ▒╩╚╩╚╚Γ└''└│╙╙╚╩╩╩╚╙Γ"
                                   .\¡░φ▒░░░░░░░       ''''''
                                   ¡¡░▒░░░│││¡└
                                   .¡░░░░░│'''¡'
                               .░░░░░░░░┐''│¡~
                       .,░φ░░░░░░░░░░░░░│..'!░
                   .░░░░░░░░░░░░░░░░░░░░░░┐. !-
                   ;░░φ▒▒▒▒░░░░░░░░░░░░░░░░░░░┐.'-
               .░░φ▒▒▒▒░░░░░░▒▒▒▒╠╠╠▒▒▒▒▒▒▒φ░░░¡░.
               .░░▒╠╠▒░░░░░░░░▒╠╠╩╩╩╩╩╩╬╬╣╣╣▓╣╬▒▒φ░░;
               .¡░▒╠╠▒░░░░░░░░░░Γ░└'''''''""╙╙╩╬╬╬╬╣╣╬▒φ░»,
               :░φ╠╬▒▒░░░░░░░░░░             '''!╙╚╩╠╠╠╠╠╠╠▒φφφ░,
               :░▒╬╬▒▒░░░░░░░░'                   '!░░░╠╠╠╠╠╠╠▒▒▒░░░.
               :░╠╬╬▒▒░░░░░░░'                     .░░░▒▒╠╠╠╠▒▒▒▒▒▒░░░.
               '░╚╬╬▒▒░░░░░░                     .≥░░░▒▒▒▒▒▒▒▒▒▒▒▒▒░░░┐-
               !░╠╬▒▒░░░░░                  ,;φ░░░░▒▒▒▒▒▒▒▒▒▒▒╠╠▒▒▒░░░┌.
               ^░╠╬╠▒▒░░░               ,φ░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒╠╠╠▒▒▒░░░│¡
               !╚╬╬▒▒░▒░            »░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒╠╠╠╠╠▒▒▒░░░░░
               '░╠╬▒▒▒▒░         ,φ░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒╠╠╠╠╠╠╠╠╠▒▒░░░░░
                   '╚╠▒▒▒▒░       ;░░░▒▒▒╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠╠▒▒░░░░░
                   ░╠▒▒▒▒▒░  .,φφ▒▒▒╠╠╠╬╬╬╬╬╬╬╬╬╬╬╬╠╠╠╬╬╬╬╬╬╬╬╬╬╠╠▒▒░░░░
                   ]╠▒▒▒▒▒▒▒╠╠╠╠╠╠╠╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╠▒▒░░░'
                   ]╠▒▒▒▒▒▒▒╠╠╠╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╠▒▒▒░'
                   !╠╠▒▒▒▒▒▒╠╠╠╠╬╬╬╬╬╬╬╬╬╬╬╬╬╬╣▓▓▓▓▓▓▓▓▓▓▓▓╬╬╬╬╬╬╠╠╩░'
                   '╙╬╬▒▒▒▒▒╠╠╠╠╠╠╬╬╬╬╬╬╬╬╬╬╬╬╣▓▓▓▓▓▓▓▓▓▓▓▓▓▓╬╬╬╬╩Γ"
                   '!╚╣╬╬╠╠╠╠╠╠╠╬╬╬╬╬╬╬╬╬╬╬╬╬╬╣▓▓▓▓▓▓▓▓▓▓▓▓╬╬╩╙░'
                       '░╚╣▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╣▓▓▓▓▀╩╩╙╙░└''
                       '!╙╩╣▓▓╣╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╩╙░"''
                           '!╙╚╬▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╩╙Γ"'


*/
pragma solidity ~0.8.22;

/// @author Draup, Inc.
/// @title DRAUP X Patternbase - REDUCE

import {IERC721A, ERC721A} from "erc721a/ERC721A.sol";
import {ERC721AQueryable} from "erc721a/extensions/ERC721AQueryable.sol";
import {IERC2981, ERC2981} from "openzeppelin-contracts/token/common/ERC2981.sol";
import {Ownable} from "openzeppelin-contracts/access/Ownable.sol";
import {Strings} from "openzeppelin-contracts/utils/Strings.sol";
import {OperatorFilterer} from "closedsea/OperatorFilterer.sol";

error ExceedsMaxMintsPerTx();
error InvalidFundsSent();
error InvalidSaleState();
error MintingNotActive();
error NoContracts();
error NoTokensToReveal();
error RejectTransferToZeroAddress();
error RejectZeroAddress();
error SaleHasFinished();
error SeedQueryForNonexistentToken();
error WithdrawalFailure();

contract DRAUPReduce is ERC721AQueryable, ERC2981, Ownable, OperatorFilterer {
    using Strings for uint256;

    enum SaleState {
        CLOSED,
        ADMIN,
        OPEN,
        FINISHED
    }

    SaleState public saleState;

    uint8 public constant MAX_MINTS_PER_TX = 20;
    uint64 public constant MINT_PRICE = 0.028 ether;
    uint256 private _lastTokenRevealed;

    string private _defaultURI;
    string private _tokenBaseURI;
    mapping(uint => bytes32) private _tokenSeeds;

    address private _revenueWallet;

    bool public operatorFilteringEnabled = true;

    modifier mintCompliant(uint8 quantity) {
        if (tx.origin != msg.sender) revert NoContracts();
        if (!mintingIsActive()) revert MintingNotActive();
        if (quantity > MAX_MINTS_PER_TX) revert ExceedsMaxMintsPerTx();
        if (msg.value != quantity * MINT_PRICE) revert InvalidFundsSent();
        _;
    }

    constructor(
        string memory defaultURI,
        string memory tokenBaseURI,
        address revenueWallet
    ) ERC721A("REDUCE", "R") {
        _defaultURI = defaultURI;
        _tokenBaseURI = tokenBaseURI;
        _revenueWallet = revenueWallet;

        _registerForOperatorFiltering();
        _setDefaultRoyalty(_revenueWallet, 750);
    }

    // -------
    // Minting
    // -------

    /// @notice Mint a token, if compliant per the modifier
    /// @param quantity Number of tokens to mint in one transaction, max of 20/tx
    function mint(uint8 quantity) external payable mintCompliant(quantity) {
        _mintItem(msg.sender, quantity);
    }

    /// @dev Admin minting for team and artist pieces
    /// @param to Wallet address to mint the item to
    function adminMintItem(address to) external onlyOwner {
        if (saleState < SaleState.ADMIN || saleState > SaleState.OPEN)
            revert MintingNotActive();
        _mintItem(to, 1);
    }

    /// @dev Get the boolean flag that indicates whether the sale is active
    function mintingIsActive() public view returns (bool) {
        return saleState == SaleState.OPEN;
    }

    /// @notice Mint an item alongside a generated seed.
    /// @dev The seed is used to generate the item assets off-chain.
    function _mintItem(address recipient, uint8 quantity) private {
        uint256 currentSupply = totalSupply();
        for (uint8 i; i < quantity; i++) {
            uint256 tokenId = currentSupply + i;
            bytes32 seed = keccak256(
                abi.encodePacked(
                    tokenId,
                    block.prevrandao,
                    blockhash(block.number - 1),
                    msg.sender
                )
            );
            _tokenSeeds[tokenId] = seed;
        }
        _mint(recipient, quantity);
    }

    // --------
    // Metadata
    // --------

    function setDefaultURI(string calldata newDefaultURI) external onlyOwner {
        _defaultURI = newDefaultURI;
    }

    function setTokenBaseURI(string calldata newBaseURI) external onlyOwner {
        _tokenBaseURI = newBaseURI;
    }

    function tokenURI(
        uint256 tokenId
    ) public view override(IERC721A, ERC721A) returns (string memory) {
        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();
        if (!_isRevealed(tokenId)) {
            return _defaultURI;
        }
        return string.concat(_tokenBaseURI, tokenId.toString());
    }

    /// @notice Get the seed associated with the tokenId
    /// @param tokenId The tokenId to query the seed for
    function tokenSeed(uint256 tokenId) external view returns (bytes32 seed) {
        if (tokenId >= totalSupply()) revert SeedQueryForNonexistentToken();
        return _tokenSeeds[tokenId];
    }

    // -------------
    // Admin Actions
    // -------------

    /// @notice Set the revenue wallet address to receive mint funds
    /// @param revenueWallet_ The address to receive mint funds
    function setRevenueWallet(address revenueWallet_) external onlyOwner {
        if (revenueWallet_ == address(0)) {
            revert RejectZeroAddress();
        }
        _revenueWallet = revenueWallet_;
    }

    function withdrawFunds() external onlyOwner {
        if (_revenueWallet == address(0)) {
            revert RejectTransferToZeroAddress();
        }
        (bool sent, ) = payable(_revenueWallet).call{
            value: address(this).balance
        }("");
        if (!sent) {
            revert WithdrawalFailure();
        }
    }

    /// @dev Set the sale state of the contract (CLOSED, ADMIN, OPEN)
    /// @dev The sale is explicitly set to FINISHED via the `endSale()` function
    /// @param state The uint8 associated with the sale state (CLOSED: 0, ADMIN: 1, OPEN: 2)
    function setSaleState(uint8 state) external onlyOwner {
        if (state > uint8(SaleState.OPEN)) {
            revert InvalidSaleState();
        }
        if (saleState == SaleState.FINISHED) revert SaleHasFinished();
        saleState = SaleState(state);
    }

    /// @dev End the sale by setting the sale state to FINISHED
    function endSale() external onlyOwner {
        saleState = SaleState(SaleState.FINISHED);
    }

    /**
     * @dev Reveal up to the last minted token
     *
     * This function will revert when totalSupply() is 1 but this is acceptable
     * given we will not call this until we've minted at least 2 tokens.
     */
    function reveal() external onlyOwner {
        if (totalSupply() == 0 || _lastTokenRevealed == totalSupply() - 1)
            revert NoTokensToReveal();
        _lastTokenRevealed = totalSupply() - 1;
    }

    function _isRevealed(uint256 tokenId) private view returns (bool) {
        return _lastTokenRevealed != 0 && tokenId <= _lastTokenRevealed;
    }

    // -----------------
    // Operator Filterer
    // -----------------

    function setApprovalForAll(
        address operator,
        bool approved
    ) public override(IERC721A, ERC721A) onlyAllowedOperatorApproval(operator) {
        super.setApprovalForAll(operator, approved);
    }

    function approve(
        address operator,
        uint256 tokenId
    )
        public
        payable
        override(IERC721A, ERC721A)
        onlyAllowedOperatorApproval(operator)
    {
        super.approve(operator, tokenId);
    }

    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public payable override(IERC721A, ERC721A) onlyAllowedOperator(from) {
        super.transferFrom(from, to, tokenId);
    }

    function setOperatorFilteringEnabled(bool value) public onlyOwner {
        operatorFilteringEnabled = value;
    }

    function _operatorFilteringEnabled() internal view override returns (bool) {
        return operatorFilteringEnabled;
    }

    // --------
    // ERC-2981
    // --------

    function setDefaultRoyalty(
        address receiver,
        uint96 feeNumerator
    ) external onlyOwner {
        _setDefaultRoyalty(receiver, feeNumerator);
    }

    // -------
    // ERC-165
    // -------

    /// @dev See {IERC165-supportsInterface}.
    /// @dev Supports ERC-4906 interfaceId 0x49064906
    function supportsInterface(
        bytes4 interfaceId
    ) public view override(IERC721A, ERC721A, ERC2981) returns (bool) {
        return
            ERC721A.supportsInterface(interfaceId) ||
            ERC2981.supportsInterface(interfaceId) ||
            interfaceId == bytes4(0x49064906);
    }

    // --------
    // ERC-4906
    // --------

    event MetadataUpdate(uint256 _tokenId);
    event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);

    function publishMetadataUpdated(uint256 tokenId) public onlyOwner {
        emit MetadataUpdate(tokenId);
    }

    function publishBatchMetadataUpdated(
        uint256 fromTokenId,
        uint256 toTokenId
    ) public onlyOwner {
        emit BatchMetadataUpdate(fromTokenId, toTokenId);
    }
}