// SPDX-License-Identifier: MIT

pragma solidity ^0.8.17;

import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";

import "erc721a/contracts/ERC721A.sol";

import "erc721a/contracts/extensions/ERC721AQueryable.sol";

import "erc721a/contracts/extensions/ERC4907A.sol";

import "@openzeppelin/contracts/access/Ownable.sol";

import "@openzeppelin/contracts/security/Pausable.sol";

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

import "@openzeppelin/contracts/token/common/ERC2981.sol";



contract ChampPortal is

    ERC721A,

    ERC721AQueryable,

    ERC4907A,

    Ownable,

    Pausable,

    ReentrancyGuard,

    ERC2981

{

    using ECDSA for bytes32;

    event Stake(uint256 indexed tokenId);

    event Unstake(uint256 indexed tokenId);



    address private presaleSignerAddress = 0xb55c8ADF8a9386d98daB6b4A05E562e89eE7465F;

    address public blocklistContractAddress;

    address public royaltyAddress = 0x11e5153c9eE5941e7B4e8aB864E53Dc094C81076;

    address[] public payoutAddresses = [

        0xB8D919dEF4f4d66bE77C66E6c4a42BECeA0F3e38,

        0xc5CdA35D109365465AA6E97938B0C7bb42e36211,

        0xDc972E9a15e11B1C2f85c1712EE4F1d52ed9BFC6,

        0x9Cbbb4DAD773fcF93d977cac74464d13E85fDC55

    ];

    bool public blocklistPermanentlyDisabled;

    bool public isPresaleActive;

    bool public isPublicSaleActive;

    bool public isStakingActive = false;

    bool public metadataFrozen;

    bool public payoutAddressesFrozen;

    bool public stakingTransferActive;

    mapping(uint256 => bool) public isExchangeBlocklisted;

    mapping(uint256 => bytes32) public randomHashStore;

    mapping(uint256 => uint256) public currentTimeStaked;

    mapping(uint256 => uint256) public totalTimeStaked;

    string public baseTokenURI = "ipfs://QmNYF9kzVJw8X36K35tLTLEF2w4HpGdDgdFo14j4kk4RoH/";

    uint256 public MAX_SUPPLY = 2222;

    uint256 public PRESALE_MAX_SUPPLY = 2222;

    uint256 public presaleMintsAllowedPerAddress = 2;

    uint256 public presaleMintsAllowedPerTransaction = 2;

    uint256 public presalePrice = 0.0055 ether;

    uint256 public publicMintsAllowedPerAddress = 3;

    uint256 public publicMintsAllowedPerTransaction = 3;

    uint256 public publicPrice = 0.0077 ether;

    uint256[] public payoutBasisPoints = [3000,3000,3000,1000];

    uint96 public royaltyFee = 550;



    constructor(address _blocklistContractAddress)

        ERC721A("ChampPortal", "CHAMP")

    {

        blocklistContractAddress = _blocklistContractAddress;

        _setDefaultRoyalty(royaltyAddress, royaltyFee);

        require(

            payoutAddresses.length == payoutBasisPoints.length,

            "PAYOUT_ARRAYS_NOT_SAME_LENGTH"

        );

        uint256 totalPayoutBasisPoints = 0;

        for (uint256 i = 0; i < payoutBasisPoints.length; i++) {

            totalPayoutBasisPoints += payoutBasisPoints[i];

        }

        require(

            totalPayoutBasisPoints == 10000,

            "TOTAL_BASIS_POINTS_MUST_BE_10000"

        );

        isExchangeBlocklisted[5] = true;

        isExchangeBlocklisted[2] = true;

        isExchangeBlocklisted[4] = true;

        isExchangeBlocklisted[7] = true;

    }



    modifier originalUser() {

        require(tx.origin == msg.sender, "CANNOT_CALL_FROM_CONTRACT");

        _;

    }



    function _baseURI() internal view virtual override returns (string memory) {

        return baseTokenURI;

    }



    function _startTokenId() internal view virtual override returns (uint256) {

        return 1;

    }





    function setRoyaltyFee(uint96 _feeNumerator) external onlyOwner {

        royaltyFee = _feeNumerator;

        _setDefaultRoyalty(royaltyAddress, royaltyFee);

    }





    function setRoyaltyAddress(address _royaltyAddress) external onlyOwner {

        royaltyAddress = _royaltyAddress;

        _setDefaultRoyalty(royaltyAddress, royaltyFee);

    }





    function numberMinted(address owner) public view returns (uint256) {

        return _numberMinted(owner);

    }





    function setBaseURI(string calldata _newBaseURI) external onlyOwner {

        require(!metadataFrozen, "METADATA_HAS_BEEN_FROZEN");

        baseTokenURI = _newBaseURI;

    }





    function reduceMaxSupply(uint256 _newMaxSupply) external onlyOwner {

        require(_newMaxSupply < MAX_SUPPLY, "NEW_MAX_SUPPLY_TOO_HIGH");

        require(

            _newMaxSupply >= totalSupply(),

            "SUPPLY_LOWER_THAN_MINTED_TOKENS"

        );

        MAX_SUPPLY = _newMaxSupply;

    }





    function freezeMetadata() external onlyOwner {

        require(!metadataFrozen, "METADATA_HAS_ALREADY_BEEN_FROZEN");

        metadataFrozen = true;

    }



    function pause() external onlyOwner {

        _pause();

    }



    function unpause() external onlyOwner {

        _unpause();

    }



    // https://chiru-labs.github.io/ERC721A/#/migration?id=supportsinterface

    function supportsInterface(bytes4 interfaceId)

        public

        view

        virtual

        override(ERC721A, IERC721A, ERC2981, ERC4907A)

        returns (bool)

    {

        // Supports the following interfaceIds:

        // - IERC165: 0x01ffc9a7

        // - IERC721: 0x80ac58cd

        // - IERC721Metadata: 0x5b5e139f

        // - IERC2981: 0x2a55205a

        // - IERC4907: 0xad092b5c

        return

            ERC721A.supportsInterface(interfaceId) ||

            ERC2981.supportsInterface(interfaceId) ||

            ERC4907A.supportsInterface(interfaceId);

    }





    function gift(address[] calldata receivers, uint256[] calldata mintNumber)

        external

        onlyOwner

    {

        require(

            receivers.length == mintNumber.length,

            "ARRAYS_MUST_BE_SAME_LENGTH"

        );

        uint256 totalMint = 0;

        for (uint256 i = 0; i < mintNumber.length; i++) {

            totalMint += mintNumber[i];

        }

        require(totalSupply() + totalMint <= MAX_SUPPLY, "MINT_TOO_LARGE");

        for (uint256 i = 0; i < receivers.length; i++) {

            _safeMint(receivers[i], mintNumber[i]);

        }

    }





    function setPublicSaleState(bool _saleActiveState) external onlyOwner {

        require(

            isPublicSaleActive != _saleActiveState,

            "NEW_STATE_IDENTICAL_TO_OLD_STATE"

        );

        isPublicSaleActive = _saleActiveState;

    }





    function setPublicPrice(uint256 _publicPrice) external onlyOwner {

        publicPrice = _publicPrice;

    }





    function setPublicMintsAllowedPerAddress(uint256 _mintsAllowed)

        external

        onlyOwner

    {

        publicMintsAllowedPerAddress = _mintsAllowed;

    }





    function setPublicMintsAllowedPerTransaction(uint256 _mintsAllowed)

        external

        onlyOwner

    {

        publicMintsAllowedPerTransaction = _mintsAllowed;

    }





    function mint(uint256 numTokens)

        external

        payable

        nonReentrant

        originalUser

    {

        require(isPublicSaleActive, "PUBLIC_SALE_IS_NOT_ACTIVE");



        require(

            numTokens <= publicMintsAllowedPerTransaction,

            "MAX_MINTS_PER_TX_EXCEEDED"

        );

        require(

            _numberMinted(msg.sender) + numTokens <=

                publicMintsAllowedPerAddress,

            "MAX_MINTS_EXCEEDED"

        );

        require(totalSupply() + numTokens <= MAX_SUPPLY, "MAX_SUPPLY_EXCEEDED");

        require(msg.value == publicPrice * numTokens, "PAYMENT_INCORRECT");



        _safeMint(msg.sender, numTokens);



        if (totalSupply() >= MAX_SUPPLY) {

            isPublicSaleActive = false;

        }

    }





    function setPresaleState(bool _saleActiveState) external onlyOwner {

        require(

            isPresaleActive != _saleActiveState,

            "NEW_STATE_IDENTICAL_TO_OLD_STATE"

        );

        isPresaleActive = _saleActiveState;

    }





    function setPresalePrice(uint256 _presalePrice) external onlyOwner {

        presalePrice = _presalePrice;

    }





    function setPresaleMintsAllowedPerAddress(uint256 _mintsAllowed)

        external

        onlyOwner

    {

        presaleMintsAllowedPerAddress = _mintsAllowed;

    }





    function setPresaleMintsAllowedPerTransaction(uint256 _mintsAllowed)

        external

        onlyOwner

    {

        presaleMintsAllowedPerTransaction = _mintsAllowed;

    }





    function reducePresaleMaxSupply(uint256 _newPresaleMaxSupply)

        external

        onlyOwner

    {

        require(

            _newPresaleMaxSupply < PRESALE_MAX_SUPPLY,

            "NEW_MAX_SUPPLY_TOO_HIGH"

        );

        PRESALE_MAX_SUPPLY = _newPresaleMaxSupply;

    }





    function setPresaleSignerAddress(address _presaleSignerAddress)

        external

        onlyOwner

    {

        require(_presaleSignerAddress != address(0));

        presaleSignerAddress = _presaleSignerAddress;

    }





    function verifySignerAddress(bytes32 messageHash, bytes calldata signature)

        private

        view

        returns (bool)

    {

        return

            presaleSignerAddress ==

            messageHash.toEthSignedMessageHash().recover(signature);

    }





    function presaleMint(

        bytes32 messageHash,

        bytes calldata signature,

        uint256 numTokens,

        uint256 maximumAllowedMints

    ) external payable nonReentrant originalUser {

        require(isPresaleActive, "PRESALE_IS_NOT_ACTIVE");



        require(

            numTokens <= presaleMintsAllowedPerTransaction,

            "MAX_MINTS_PER_TX_EXCEEDED"

        );

        require(

            _numberMinted(msg.sender) + numTokens <=

                presaleMintsAllowedPerAddress,

            "MAX_MINTS_PER_ADDRESS_EXCEEDED"

        );

        require(

            _numberMinted(msg.sender) + numTokens <= maximumAllowedMints,

            "MAX_MINTS_EXCEEDED"

        );

        require(

            totalSupply() + numTokens <= PRESALE_MAX_SUPPLY,

            "MAX_SUPPLY_EXCEEDED"

        );

        require(msg.value == presalePrice * numTokens, "PAYMENT_INCORRECT");

        require(

            keccak256(abi.encode(msg.sender, maximumAllowedMints)) ==

                messageHash,

            "MESSAGE_INVALID"

        );

        require(

            verifySignerAddress(messageHash, signature),

            "SIGNATURE_VALIDATION_FAILED"

        );



        _safeMint(msg.sender, numTokens);



        if (totalSupply() >= PRESALE_MAX_SUPPLY) {

            isPresaleActive = false;

        }

    }





    function freezePayoutAddresses() external onlyOwner {

        require(!payoutAddressesFrozen, "PAYOUT_ADDRESSES_ALREADY_FROZEN");

        payoutAddressesFrozen = true;

    }





    function updatePayoutAddressesAndBasisPoints(

        address[] calldata _payoutAddresses,

        uint256[] calldata _payoutBasisPoints

    ) external onlyOwner {

        require(!payoutAddressesFrozen, "PAYOUT_ADDRESSES_FROZEN");

        require(

            _payoutAddresses.length == _payoutBasisPoints.length,

            "ARRAY_LENGTHS_MUST_MATCH"

        );

        uint256 totalBasisPoints = 0;

        for (uint256 i = 0; i < _payoutBasisPoints.length; i++) {

            totalBasisPoints += _payoutBasisPoints[i];

        }

        require(totalBasisPoints == 10000, "TOTAL_BASIS_POINTS_MUST_BE_10000");

        payoutAddresses = _payoutAddresses;

        payoutBasisPoints = _payoutBasisPoints;

    }





    function withdraw() external nonReentrant onlyOwner {

        require(address(this).balance > 0, "CONTRACT_HAS_NO_BALANCE");

        uint256 balance = address(this).balance;

        for (uint256 i = 0; i < payoutAddresses.length; i++) {

            uint256 amount = (balance * payoutBasisPoints[i]) / 10000;

            (bool success, ) = payoutAddresses[i].call{value: amount}("");

            require(success, "Transfer failed.");

        }

    }





    function setStakingState(bool _stakingState) external onlyOwner {

        require(

            isStakingActive != _stakingState,

            "NEW_STATE_IDENTICAL_TO_OLD_STATE"

        );

        isStakingActive = _stakingState;

    }





    function stakeTokens(uint256[] calldata tokenIds) external {

        require(isStakingActive, "STAKING_IS_NOT_ACTIVE");

        for (uint256 i = 0; i < tokenIds.length; i++) {

            uint256 tokenId = tokenIds[i];

            require(ownerOf(tokenId) == msg.sender, "TOKEN_NOT_OWNED");

            if (currentTimeStaked[tokenId] == 0) {

                currentTimeStaked[tokenId] = block.timestamp;

                emit Stake(tokenId);

            }

        }

    }





    function unstakeTokens(uint256[] calldata tokenIds) external {

        for (uint256 i = 0; i < tokenIds.length; i++) {

            uint256 tokenId = tokenIds[i];

            require(ownerOf(tokenId) == msg.sender, "TOKEN_NOT_OWNED");

            if (currentTimeStaked[tokenId] != 0) {

                totalTimeStaked[tokenId] +=

                    block.timestamp -

                    currentTimeStaked[tokenId];

                currentTimeStaked[tokenId] = 0;

                emit Unstake(tokenId);

            }

        }

    }





    function stakingTransfer(

        address from,

        address to,

        uint256 tokenId

    ) external {

        require(ownerOf(tokenId) == msg.sender, "TOKEN_NOT_OWNED");

        stakingTransferActive = true;

        safeTransferFrom(from, to, tokenId);

        stakingTransferActive = false;

    }





    function adminUnstake(uint256 tokenId) external onlyOwner {

        require(currentTimeStaked[tokenId] != 0, "TOKEN_NOT_STAKED");

        totalTimeStaked[tokenId] +=

            block.timestamp -

            currentTimeStaked[tokenId];

        currentTimeStaked[tokenId] = 0;

        emit Unstake(tokenId);

    }





    function totalTokenStakeTime(uint256 tokenId)

        external

        view

        returns (uint256)

    {

        uint256 currentStakeStartTime = currentTimeStaked[tokenId];

        if (currentStakeStartTime != 0) {

            return

                (block.timestamp - currentStakeStartTime) +

                totalTimeStaked[tokenId];

        }

        return totalTimeStaked[tokenId];

    }





    function currentTokenStakeTime(uint256 tokenId)

        external

        view

        returns (uint256)

    {

        uint256 currentStakeStartTime = currentTimeStaked[tokenId];

        if (currentStakeStartTime != 0) {

            return block.timestamp - currentStakeStartTime;

        }

        return 0;

    }





    function _generateRandomHash(uint256 tokenId) internal {

        if (randomHashStore[tokenId] == bytes32(0)) {

            randomHashStore[tokenId] = keccak256(

                abi.encode(

                    block.timestamp,

                    block.difficulty,

                    blockhash(block.number - 1)

                )

            );

        }

    }





    modifier onlyAllowedOperatorApproval(address operator) {

        uint256 operatorExchangeId = IExchangeOperatorAddressList(

            blocklistContractAddress

        ).operatorAddressToExchange(operator);

        require(

            blocklistPermanentlyDisabled ||

                !isExchangeBlocklisted[operatorExchangeId],

            "BLOCKLISTED_EXCHANGE"

        );

        _;

    }





    function updateBlocklistContractAddress(address _blocklistContractAddress)

        external

        onlyOwner

    {

        blocklistContractAddress = _blocklistContractAddress;

    }





    function permanentlyDisableBlocklist() external onlyOwner {

        require(!blocklistPermanentlyDisabled, "BLOCKLIST_ALREADY_DISABLED");

        blocklistPermanentlyDisabled = true;

    }





    function updateBlocklistedExchanges(

        uint256[] calldata exchanges,

        bool[] calldata blocklisted

    ) external onlyOwner {

        require(

            exchanges.length == blocklisted.length,

            "ARRAYS_MUST_BE_SAME_LENGTH"

        );

        for (uint256 i = 0; i < exchanges.length; i++) {

            isExchangeBlocklisted[exchanges[i]] = blocklisted[i];

        }

    }



    function setApprovalForAll(address operator, bool approved)

        public

        override(ERC721A, IERC721A)

        onlyAllowedOperatorApproval(operator)

    {

        super.setApprovalForAll(operator, approved);

    }



    function approve(address to, uint256 tokenId)

        public

        override(ERC721A, IERC721A)

        onlyAllowedOperatorApproval(to)

    {

        super.approve(to, tokenId);

    }



    function _beforeTokenTransfers(

        address from,

        address to,

        uint256 tokenId,

        uint256 quantity

    ) internal override(ERC721A) whenNotPaused {

        require(

            currentTimeStaked[tokenId] == 0 || stakingTransferActive,

            "TOKEN_IS_STAKED"

        );

        if (from == address(0)) {

            _generateRandomHash(tokenId);

        }



        uint256 operatorExchangeId = IExchangeOperatorAddressList(

            blocklistContractAddress

        ).operatorAddressToExchange(msg.sender);

        require(

            blocklistPermanentlyDisabled ||

                !isExchangeBlocklisted[operatorExchangeId],

            "BLOCKLISTED_EXCHANGE"

        );

        super._beforeTokenTransfers(from, to, tokenId, quantity);

    }

}



interface IExchangeOperatorAddressList {

    function operatorAddressToExchange(address operatorAddress)

        external

        view

        returns (uint256);

}