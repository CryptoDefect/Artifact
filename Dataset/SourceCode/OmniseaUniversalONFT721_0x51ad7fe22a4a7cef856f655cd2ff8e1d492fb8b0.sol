{{

  "language": "Solidity",

  "sources": {

    "src/contracts/onft/OmniseaUniversalONFT721.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IOmniseaUniversalONFT721.sol\";\nimport \"../lzApp/NonblockingLzApp.sol\";\nimport \"../interfaces/IOmniseaRemoteERC721.sol\";\nimport \"../interfaces/IOmniseaDropsFactory.sol\";\nimport \"./OmniseaERC721Proxy.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {BasicCollectionParams} from \"../structs/erc721/ERC721Structs.sol\";\n\ncontract OmniseaUniversalONFT721 is NonblockingLzApp, ERC165, ReentrancyGuard, IOmniseaUniversalONFT721 {\n    uint16 public constant FUNCTION_TYPE_SEND = 1;\n    uint16 private immutable _chainId;\n    uint256 public fixedFee;\n    address internal revenueManager;\n    mapping(address => bytes32) public collectionToId;\n    mapping(bytes32 => address) public idToCollection;\n    IOmniseaDropsFactory private _factory;\n\n    struct StoredCredit {\n        uint16 srcChainId;\n        address collection;\n        address toAddress;\n        uint256 index;\n        bool creditsRemain;\n    }\n\n    uint256 public minGasToTransferAndStore; // min amount of gas required to transfer, and also store the payload\n    mapping(uint16 => uint256) public dstChainIdToBatchLimit;\n    mapping(uint16 => uint256) public dstChainIdToTransferGas; // per transfer amount of gas required to mint/transfer on the dst\n    mapping(bytes32 => StoredCredit) public storedCredits;\n\n    constructor(uint16 chainId_, address _lzEndpoint, uint256 _minGasToTransferAndStore) NonblockingLzApp(_lzEndpoint) {\n        minGasToTransferAndStore = _minGasToTransferAndStore;\n        revenueManager = address(0x61104fBe07ecc735D8d84422c7f045f8d29DBf15);\n        fixedFee = 250000000000000;\n        _chainId = chainId_;\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IOmniseaUniversalONFT721).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function setFixedFee(uint256 fee) external onlyOwner {\n        fixedFee = fee;\n    }\n\n    function estimateSendFee(uint16 _dstChainId, bytes memory _toAddress, uint _tokenId, bool _useZro, bytes memory _adapterParams, BasicCollectionParams memory _collectionParams) public view virtual override returns (uint nativeFee, uint zroFee) {\n        return estimateSendBatchFee(_dstChainId, _toAddress, _toSingletonArray(_tokenId), _useZro, _adapterParams, _collectionParams);\n    }\n\n    function estimateSendBatchFee(uint16 _dstChainId, bytes memory _toAddress, uint[] memory _tokenIds, bool _useZro, bytes memory _adapterParams, BasicCollectionParams memory _collectionParams) public view virtual override returns (uint nativeFee, uint zroFee) {\n        bytes memory payload = abi.encode(_toAddress, _toAddress, _tokenIds, _collectionParams);\n        (nativeFee, zroFee) = lzEndpoint.estimateFees(_dstChainId, address(this), payload, _useZro, _adapterParams);\n        nativeFee += fixedFee;\n    }\n\n    function sendFrom(address _from, uint16 _dstChainId, bytes memory _toAddress, uint _tokenId, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams, BasicCollectionParams memory _collectionParams) public payable virtual override nonReentrant {\n        _send(_from, _dstChainId, _toAddress, _toSingletonArray(_tokenId), _refundAddress, _zroPaymentAddress, _adapterParams, _collectionParams);\n    }\n\n    function sendBatchFrom(address _from, uint16 _dstChainId, bytes memory _toAddress, uint[] memory _tokenIds, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams, BasicCollectionParams memory _collectionParams) public payable virtual override nonReentrant {\n        _send(_from, _dstChainId, _toAddress, _tokenIds, _refundAddress, _zroPaymentAddress, _adapterParams, _collectionParams);\n    }\n\n    function _send(\n        address _from,\n        uint16 _dstChainId,\n        bytes memory _toAddress,\n        uint[] memory _tokenIds,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes memory _adapterParams,\n        BasicCollectionParams memory _collectionParams\n    ) internal virtual {\n        require(_tokenIds.length > 0);\n        require(_tokenIds.length <= dstChainIdToBatchLimit[_dstChainId]);\n\n        bytes32 collectionId = collectionToId[msg.sender];\n        if (collectionId == bytes32(0)) {\n            require(_factory.drops(msg.sender));\n            collectionId = keccak256(abi.encode(msg.sender, _chainId));\n            idToCollection[collectionId] = msg.sender;\n            collectionToId[msg.sender] = collectionId;\n        }\n\n        for (uint i = 0; i < _tokenIds.length; i++) {\n            _debitFrom(_from, _dstChainId, msg.sender, _toAddress, _tokenIds[i]);\n        }\n\n        bytes memory payload = abi.encode(_toAddress, _tokenIds, _collectionParams, collectionId);\n        _checkGasLimit(_dstChainId, FUNCTION_TYPE_SEND, _adapterParams, dstChainIdToTransferGas[_dstChainId] * _tokenIds.length);\n        (uint nativeFee) = _payONFTFee(msg.value);\n        _lzSend(_dstChainId, payload, _refundAddress, _zroPaymentAddress, _adapterParams, nativeFee);\n        emit SendToChain(_dstChainId, _from, _toAddress, _tokenIds);\n    }\n\n    function _nonblockingLzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64, /*_nonce*/\n        bytes memory _payload\n    ) internal virtual override {\n        (bytes memory toAddressBytes, uint[] memory tokenIds, BasicCollectionParams memory _collectionParams, bytes32 _collectionId) = abi.decode(_payload, (bytes, uint[], BasicCollectionParams, bytes32));\n\n        address toAddress;\n        assembly {\n            toAddress := mload(add(toAddressBytes, 20))\n        }\n\n        address collection = idToCollection[_collectionId];\n        if (collection == address(0)) {\n            OmniseaERC721Proxy proxy = new OmniseaERC721Proxy();\n            collection = address(proxy);\n            IOmniseaRemoteERC721(collection).initialize(_collectionParams);\n            idToCollection[_collectionId] = collection;\n            collectionToId[collection] = _collectionId;\n        }\n\n        uint nextIndex = _creditTill(_srcChainId, collection, toAddress, 0, tokenIds);\n        if (nextIndex < tokenIds.length) {\n            // not enough gas to complete transfers, store to be cleared in another tx\n            bytes32 hashedPayload = keccak256(_payload);\n            storedCredits[hashedPayload] = StoredCredit(_srcChainId, collection, toAddress, nextIndex, true);\n            emit CreditStored(hashedPayload, _payload);\n        }\n\n        emit ReceiveFromChain(_srcChainId, _srcAddress, toAddress, tokenIds);\n    }\n\n    // Public function for anyone to clear and deliver the remaining batch sent tokenIds\n    function clearCredits(bytes memory _payload) external virtual nonReentrant {\n        bytes32 hashedPayload = keccak256(_payload);\n        require(storedCredits[hashedPayload].creditsRemain);\n\n        (,uint[] memory tokenIds) = abi.decode(_payload, (bytes, uint[]));\n\n        uint nextIndex = _creditTill(storedCredits[hashedPayload].srcChainId, storedCredits[hashedPayload].collection, storedCredits[hashedPayload].toAddress, storedCredits[hashedPayload].index, tokenIds);\n        require(nextIndex > storedCredits[hashedPayload].index);\n\n        if (nextIndex == tokenIds.length) {\n            // cleared the credits, delete the element\n            delete storedCredits[hashedPayload];\n            emit CreditCleared(hashedPayload);\n        } else {\n            // store the next index to mint\n            storedCredits[hashedPayload] = StoredCredit(storedCredits[hashedPayload].srcChainId, storedCredits[hashedPayload].collection, storedCredits[hashedPayload].toAddress, nextIndex, true);\n        }\n    }\n\n    // When a srcChain has the ability to transfer more chainIds in a single tx than the dst can do.\n    // Needs the ability to iterate and stop if the minGasToTransferAndStore is not met\n    function _creditTill(uint16 _srcChainId, address _collection, address _toAddress, uint _startIndex, uint[] memory _tokenIds) internal returns (uint256){\n        uint i = _startIndex;\n        while (i < _tokenIds.length) {\n            if (gasleft() < minGasToTransferAndStore) break;\n\n            _creditTo(_srcChainId, _collection, _toAddress, _tokenIds[i]);\n            i++;\n        }\n\n        return i;\n    }\n\n    // limit on src the amount of tokens to batch send\n    function setDstChainIdToLimits(uint16 _dstChainId, uint256 _dstChainIdToBatchLimit, uint256 _dstChainIdToTransferGas, uint256 _minGasToTransferAndStore) external onlyOwner {\n        dstChainIdToBatchLimit[_dstChainId] = _dstChainIdToBatchLimit;\n        dstChainIdToTransferGas[_dstChainId] = _dstChainIdToTransferGas;\n        minGasToTransferAndStore = _minGasToTransferAndStore;\n    }\n\n    function _payONFTFee(uint _nativeFee) internal virtual returns (uint amount) {\n        uint fee = fixedFee;\n        amount = _nativeFee - fee;\n        if (fee > 0) {\n            (bool p,) = payable(revenueManager).call{value : (fee)}(\"\");\n            require(p);\n        }\n    }\n\n    function _debitFrom(address _from, uint16, address _collection, bytes memory, uint _tokenId) internal virtual {\n        IOmniseaRemoteERC721 collection = IOmniseaRemoteERC721(_collection);\n        require(collection.ownerOf(_tokenId) == _from);\n        collection.transferFrom(_from, address(this), _tokenId);\n    }\n\n    function _creditTo(uint16, address _collection, address _toAddress, uint _tokenId) internal virtual {\n        IOmniseaRemoteERC721 collection = IOmniseaRemoteERC721(_collection);\n        bool exists = collection.exists(_tokenId);\n\n        require(!exists || (exists && collection.ownerOf(_tokenId) == address(this)));\n        if (exists) {\n            collection.transferFrom(address(this), _toAddress, _tokenId);\n            return;\n        }\n        collection.mint(_toAddress, _tokenId);\n    }\n\n    function _toSingletonArray(uint element) internal pure returns (uint[] memory) {\n        uint[] memory array = new uint[](1);\n        array[0] = element;\n        return array;\n    }\n\n    function setFactory(address _newFactory) external onlyOwner {\n        _factory = IOmniseaDropsFactory(_newFactory);\n    }\n}\n"

    },

    "src/contracts/onft/IOmniseaUniversalONFT721.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {BasicCollectionParams} from \"../structs/erc721/ERC721Structs.sol\";\n\n/**\n * @dev Interface of the ONFT Core standard\n */\ninterface IOmniseaUniversalONFT721 is IERC165 {\n    /**\n     * @dev Emitted when `_tokenIds[]` are moved from the `_sender` to (`_dstChainId`, `_toAddress`)\n     * `_nonce` is the outbound nonce from\n     */\n    event SendToChain(uint16 indexed _dstChainId, address indexed _from, bytes indexed _toAddress, uint[] _tokenIds);\n    event ReceiveFromChain(uint16 indexed _srcChainId, bytes indexed _srcAddress, address indexed _toAddress, uint[] _tokenIds);\n\n    /**\n     * @dev Emitted when `_payload` was received from lz, but not enough gas to deliver all tokenIds\n     */\n    event CreditStored(bytes32 _hashedPayload, bytes _payload);\n    /**\n     * @dev Emitted when `_hashedPayload` has been completely delivered\n     */\n    event CreditCleared(bytes32 _hashedPayload);\n\n    event CallONFTReceivedSuccess(uint16 indexed _srcChainId, bytes _srcAddress, address indexed _receiver);\n\n    /**\n     * @dev send token `_tokenId` to (`_dstChainId`, `_toAddress`) from `_from`\n     * `_toAddress` can be any size depending on the `dstChainId`.\n     * `_zroPaymentAddress` set to address(0x0) if not paying in ZRO (LayerZero Token)\n     * `_adapterParams` is a flexible bytes array to indicate messaging adapter services\n     */\n    function sendFrom(address _from, uint16 _dstChainId, bytes calldata _toAddress, uint _tokenId, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams, BasicCollectionParams memory _collectionParams) external payable;\n\n    /**\n     * @dev estimate send token `_tokenId` to (`_dstChainId`, `_toAddress`)\n     * _dstChainId - L0 defined chain id to send tokens too\n     * _toAddress - dynamic bytes array which contains the address to whom you are sending tokens to on the dstChain\n     * _tokenId - token Id to transfer\n     * _useZro - indicates to use zro to pay L0 fees\n     * _adapterParams - flexible bytes array to indicate messaging adapter services in L0\n     */\n    function estimateSendFee(uint16 _dstChainId, bytes calldata _toAddress, uint _tokenId, bool _useZro, bytes calldata _adapterParams, BasicCollectionParams memory _collectionParams) external view returns (uint nativeFee, uint zroFee);\n\n    /**\n     * @dev send tokens `_tokenIds[]` to (`_dstChainId`, `_toAddress`) from `_from`\n     * `_toAddress` can be any size depending on the `dstChainId`.\n     * `_zroPaymentAddress` set to address(0x0) if not paying in ZRO (LayerZero Token)\n     * `_adapterParams` is a flexible bytes array to indicate messaging adapter services\n     */\n    function sendBatchFrom(address _from, uint16 _dstChainId, bytes calldata _toAddress, uint[] calldata _tokenIds, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams, BasicCollectionParams memory _collectionParams) external payable;\n\n    /**\n     * @dev estimate send token `_tokenId` to (`_dstChainId`, `_toAddress`)\n     * _dstChainId - L0 defined chain id to send tokens too\n     * _toAddress - dynamic bytes array which contains the address to whom you are sending tokens to on the dstChain\n     * _tokenIds[] - token Ids to transfer\n     * _useZro - indicates to use zro to pay L0 fees\n     * _adapterParams - flexible bytes array to indicate messaging adapter services in L0\n     */\n    function estimateSendBatchFee(uint16 _dstChainId, bytes calldata _toAddress, uint[] calldata _tokenIds, bool _useZro, bytes calldata _adapterParams, BasicCollectionParams memory _collectionParams) external view returns (uint nativeFee, uint zroFee);\n}\n"

    },

    "src/contracts/lzApp/NonblockingLzApp.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./LzApp.sol\";\nimport \"../util/ExcessivelySafeCall.sol\";\n\nabstract contract NonblockingLzApp is LzApp {\n    using ExcessivelySafeCall for address;\n\n    constructor(address _endpoint) LzApp(_endpoint) {}\n\n    mapping(uint16 => mapping(bytes => mapping(uint64 => bytes32))) public failedMessages;\n\n    event MessageFailed(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes _payload, bytes _reason);\n    event RetryMessageSuccess(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes32 _payloadHash);\n\n    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual override {\n        (bool success, bytes memory reason) = address(this).excessivelySafeCall(gasleft(), 150, abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload));\n        if (!success) {\n            _storeFailedMessage(_srcChainId, _srcAddress, _nonce, _payload, reason);\n        }\n    }\n\n    function _storeFailedMessage(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload, bytes memory _reason) internal virtual {\n        failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);\n        emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload, _reason);\n    }\n\n    function nonblockingLzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public virtual {\n        require(msg.sender == address(this), \"NonblockingLzApp: caller must be LzApp\");\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    function _nonblockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;\n\n    function retryMessage(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public payable virtual {\n        bytes32 payloadHash = failedMessages[_srcChainId][_srcAddress][_nonce];\n        require(payloadHash != bytes32(0), \"NonblockingLzApp: no stored message\");\n        require(keccak256(_payload) == payloadHash, \"NonblockingLzApp: invalid payload\");\n        failedMessages[_srcChainId][_srcAddress][_nonce] = bytes32(0);\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n        emit RetryMessageSuccess(_srcChainId, _srcAddress, _nonce, payloadHash);\n    }\n}\n"

    },

    "src/contracts/interfaces/IOmniseaRemoteERC721.sol": {

      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.7;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\r\nimport { BasicCollectionParams } from \"../structs/erc721/ERC721Structs.sol\";\r\n\r\ninterface IOmniseaRemoteERC721 is IERC721 {\r\n    function initialize(BasicCollectionParams memory _collectionParams) external;\r\n    function mint(address owner, uint256 tokenId) external;\r\n    function exists(uint256 tokenId) external view returns (bool);\r\n}\r\n"

    },

    "src/contracts/interfaces/IOmniseaDropsFactory.sol": {

      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.7;\r\n\r\nimport {CreateParams} from \"../structs/erc721/ERC721Structs.sol\";\r\n\r\ninterface IOmniseaDropsFactory {\r\n    function create(CreateParams calldata params) external;\r\n    function drops(address) external returns (bool);\r\n}\r\n"

    },

    "src/contracts/onft/OmniseaERC721Proxy.sol": {

      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ncontract OmniseaERC721Proxy {\r\n    fallback() external payable {\r\n        _delegate(address(0x1000270B3eFe49dc83de59D9259F62DACb28841C));\r\n    }\r\n\r\n    receive() external payable {\r\n        _delegate(address(0x1000270B3eFe49dc83de59D9259F62DACb28841C));\r\n    }\r\n\r\n    function _delegate(address _proxyTo) internal {\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            calldatacopy(ptr, 0, calldatasize())\r\n            let result := delegatecall(gas(), _proxyTo, ptr, calldatasize(), 0, 0)\r\n            let size := returndatasize()\r\n            returndatacopy(ptr, 0, size)\r\n\r\n            switch result\r\n            case 0 { revert(ptr, size) }\r\n            default { return(ptr, size) }\r\n        }\r\n    }\r\n}\r\n"

    },

    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"

    },

    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"

    },

    "src/contracts/structs/erc721/ERC721Structs.sol": {

      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.7;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\nstruct CreateParams {\r\n    string name;\r\n    string symbol;\r\n    string uri;\r\n    string tokensURI;\r\n    uint24 maxSupply;\r\n    bool isZeroIndexed;\r\n    uint24 royaltyAmount;\r\n    uint256 endTime;\r\n}\r\n\r\nstruct MintParams {\r\n    address collection;\r\n    uint24 quantity;\r\n    bytes32[] merkleProof;\r\n    uint8 phaseId;\r\n}\r\n\r\nstruct OmnichainMintParams {\r\n    address collection;\r\n    uint24 quantity;\r\n    uint256 paid;\r\n    uint8 phaseId;\r\n    address minter;\r\n}\r\n\r\nstruct Phase {\r\n    uint256 from;\r\n    uint256 to;\r\n    uint24 maxPerAddress;\r\n    uint256 price;\r\n    bytes32 merkleRoot;\r\n}\r\n\r\nstruct BasicCollectionParams {\r\n    string name;\r\n    string symbol;\r\n    string uri;\r\n    string tokensURI;\r\n    uint24 maxSupply;\r\n    address owner;\r\n}\r\n"

    },

    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"

    },

    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"

    },

    "src/contracts/lzApp/LzApp.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/ILayerZeroReceiver.sol\";\nimport \"../interfaces/ILayerZeroUserApplicationConfig.sol\";\nimport \"../interfaces/ILayerZeroEndpoint.sol\";\nimport \"../util/BytesLib.sol\";\n\nabstract contract LzApp is ILayerZeroReceiver, ILayerZeroUserApplicationConfig {\n    uint constant public DEFAULT_PAYLOAD_SIZE_LIMIT = 10000;\n\n    ILayerZeroEndpoint public immutable lzEndpoint;\n    mapping(uint16 => bytes) public trustedRemoteLookup;\n    mapping(uint16 => mapping(uint16 => uint)) public minDstGasLookup;\n    address public owner;\n\n    event SetTrustedRemote(uint16 _remoteChainId, bytes _path);\n    event SetTrustedRemoteAddress(uint16 _remoteChainId, bytes _remoteAddress);\n    event SetMinDstGas(uint16 _dstChainId, uint16 _type, uint _minDstGas);\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"!owner\");\n        _;\n    }\n\n    constructor(address _endpoint) {\n        lzEndpoint = ILayerZeroEndpoint(_endpoint);\n        owner = msg.sender;\n    }\n\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) public virtual override {\n        require(msg.sender == address(lzEndpoint), \"LzApp: invalid endpoint caller\");\n\n        bytes memory trustedRemote = trustedRemoteLookup[_srcChainId];\n        require(_srcAddress.length == trustedRemote.length && trustedRemote.length > 0 && keccak256(_srcAddress) == keccak256(trustedRemote), \"LzApp: invalid source sending contract\");\n\n        _blockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    function _blockingLzReceive(uint16 _srcChainId, bytes memory _srcAddress, uint64 _nonce, bytes memory _payload) internal virtual;\n\n    function _lzSend(uint16 _dstChainId, bytes memory _payload, address payable _refundAddress, address _zroPaymentAddress, bytes memory _adapterParams, uint _nativeFee) internal virtual {\n        bytes memory trustedRemote = trustedRemoteLookup[_dstChainId];\n        require(trustedRemote.length != 0, \"LzApp: destination chain is not a trusted source\");\n        lzEndpoint.send{value: _nativeFee}(_dstChainId, trustedRemote, _payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    function _checkGasLimit(uint16 _dstChainId, uint16 _type, bytes memory _adapterParams, uint _extraGas) internal view virtual {\n        uint providedGasLimit = _getGasLimit(_adapterParams);\n        uint minGasLimit = minDstGasLookup[_dstChainId][_type] + _extraGas;\n        require(minGasLimit > 0, \"LzApp: minGasLimit not set\");\n        require(providedGasLimit >= minGasLimit, \"LzApp: gas limit is too low\");\n    }\n\n    function _getGasLimit(bytes memory _adapterParams) internal pure virtual returns (uint gasLimit) {\n        require(_adapterParams.length >= 34, \"LzApp: invalid adapterParams\");\n        assembly {\n            gasLimit := mload(add(_adapterParams, 34))\n        }\n    }\n\n    function getConfig(uint16 _version, uint16 _chainId, address, uint _configType) external view returns (bytes memory) {\n        return lzEndpoint.getConfig(_version, _chainId, address(this), _configType);\n    }\n\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external override onlyOwner {\n        lzEndpoint.setConfig(_version, _chainId, _configType, _config);\n    }\n\n    function setSendVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setSendVersion(_version);\n    }\n\n    function setReceiveVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setReceiveVersion(_version);\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override onlyOwner {\n        lzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\n    }\n\n    function setTrustedRemoteAddress(uint16 _remoteChainId, bytes calldata _remoteAddress) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = abi.encodePacked(_remoteAddress, address(this));\n        emit SetTrustedRemoteAddress(_remoteChainId, _remoteAddress);\n    }\n\n    function setMinDstGas(uint16 _dstChainId, uint16 _packetType, uint _minGas) external onlyOwner {\n        require(_minGas > 0);\n        minDstGasLookup[_dstChainId][_packetType] = _minGas;\n        emit SetMinDstGas(_dstChainId, _packetType, _minGas);\n    }\n\n    function isTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool) {\n        bytes memory trustedSource = trustedRemoteLookup[_srcChainId];\n        return keccak256(trustedSource) == keccak256(_srcAddress);\n    }\n}\n"

    },

    "src/contracts/util/ExcessivelySafeCall.sol": {

      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.7.6;\n\nlibrary ExcessivelySafeCall {\n    uint256 constant LOW_28_MASK =\n    0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    function excessivelySafeCall(\n        address _target,\n        uint256 _gas,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal returns (bool, bytes memory) {\n        // set up for assembly call\n        uint256 _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling \"handle\" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := call(\n            _gas, // gas\n            _target, // recipient\n            0, // ether value\n            add(_calldata, 0x20), // inloc\n            mload(_calldata), // inlen\n            0, // outloc\n            0 // outlen\n            )\n        // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n        // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n        // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n}\n"

    },

    "src/contracts/interfaces/ILayerZeroReceiver.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\ninterface ILayerZeroReceiver {\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) external;\n}\n"

    },

    "src/contracts/interfaces/ILayerZeroUserApplicationConfig.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\ninterface ILayerZeroUserApplicationConfig {\n    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external;\n\n    function setSendVersion(uint16 _version) external;\n\n    function setReceiveVersion(uint16 _version) external;\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\n}\n"

    },

    "src/contracts/interfaces/ILayerZeroEndpoint.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\nimport \"./ILayerZeroUserApplicationConfig.sol\";\n\ninterface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {\n    function send(uint16 _dstChainId, bytes calldata _destination, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;\n\n    function receivePayload(uint16 _srcChainId, bytes calldata _srcAddress, address _dstAddress, uint64 _nonce, uint _gasLimit, bytes calldata _payload) external;\n\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\n\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\n\n    function estimateFees(uint16 _dstChainId, address _userApplication, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParam) external view returns (uint nativeFee, uint zroFee);\n\n    function getChainId() external view returns (uint16);\n\n    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;\n\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\n\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\n\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\n\n    function isSendingPayload() external view returns (bool);\n\n    function isReceivingPayload() external view returns (bool);\n\n    function getConfig(uint16 _version, uint16 _chainId, address _userApplication, uint _configType) external view returns (bytes memory);\n\n    function getSendVersion(address _userApplication) external view returns (uint16);\n\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\n}\n"

    },

    "src/contracts/util/BytesLib.sol": {

      "content": "// SPDX-License-Identifier: Unlicense\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity >=0.8.0 <0.9.0;\n\n\nlibrary BytesLib {\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n    internal\n    pure\n    returns (bytes memory)\n    {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n            // The first word of the slice result is potentially a partial\n            // word read from the original array. To read it, we calculate\n            // the length of that partial word and start copying that many\n            // bytes into the array. The first word we copy will start with\n            // data we don't care about, but the last `lengthmod` bytes will\n            // land at the beginning of the contents of the new array. When\n            // we're done copying, we overwrite the full first word with\n            // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n            // The multiplication in the next line is necessary\n            // because when slicing multiples of 32 bytes (lengthmod == 0)\n            // the following copy loop was copying the origin's length\n            // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                // The multiplication in the next line has the same exact purpose\n                // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n            //update free-memory pointer\n            //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n            //zero out the 32 bytes slice we are about to return\n            //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1 , \"toUint8_outOfBounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, \"toUint16_outOfBounds\");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, \"toUint32_outOfBounds\");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, \"toUint64_outOfBounds\");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, \"toUint256_outOfBounds\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, \"toBytes32_outOfBounds\");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n}\n"

    },

    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"

    }

  },

  "settings": {

    "optimizer": {

      "enabled": true,

      "runs": 1

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "libraries": {}

  }

}}