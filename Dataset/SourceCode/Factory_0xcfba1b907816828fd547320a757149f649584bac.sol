{{

  "language": "Solidity",

  "sources": {

    "contracts/Factory.sol": {

      "content": "\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\nimport './Pool.sol';\r\n\r\n/**\r\n * @notice This contract is responsible for deploying new pools and providing them with the current fee and fee recipient\r\n */\r\ncontract Factory {\r\n\r\n    address public operator;\r\n    address public pendingOperator;\r\n    address public feeRecipient;\r\n    uint public feePoleis;\r\n    uint public constant MAX_FEE_POLEIS = 0.1e18;\r\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\r\n    bytes32 public immutable POOL_SYMBOL_PREFIX;\r\n    mapping (Pool => bool) public isPool;\r\n    Pool[] public pools;\r\n\r\n    constructor(address _operator, string memory _poolSymbolPrefix) {\r\n        operator = _operator;\r\n        POOL_SYMBOL_PREFIX = pack(_poolSymbolPrefix);\r\n    }\r\n\r\n    function pack(string memory unpacked) internal pure returns (bytes32 packed) {\r\n        require (bytes(unpacked).length < 32);\r\n        assembly {\r\n            packed := mload (add (unpacked, 31))\r\n        }\r\n    }\r\n\r\n    function unpack(bytes32 packed) internal pure returns (string memory unpacked) {\r\n        uint l = uint (packed >> 248);\r\n        require (l < 32);\r\n        unpacked = string (new bytes (l));\r\n        assembly {\r\n            mstore (add (unpacked, 31), packed) // Potentially writes into unallocated memory, which is fine\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Get the number of deployed pools\r\n     * @return uint number of deployed pools\r\n     * @dev Useful for iterating on all pools\r\n     */\r\n    function getPoolsLength() external view returns (uint) {\r\n        return pools.length;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the fee recipient for all pools\r\n     * @param _feeRecipient address of the new fee recipient\r\n     * @dev Only callable by the operator\r\n     */\r\n    function setFeeRecipient(address _feeRecipient) external {\r\n        require(msg.sender == operator, \"Factory: not operator\");\r\n        require(_feeRecipient != address(0), \"Factory: feeRecipient zero\");\r\n        feeRecipient = _feeRecipient;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers pool tokens to the recipient\r\n     * @param _feePoleis Transfers pool tokens to the recipient\r\n     * @dev \r\n     */\r\n    function setFeePoleis(uint _feePoleis) external {\r\n        require(msg.sender == operator, \"Factory: not operator\");\r\n        require(_feePoleis <= MAX_FEE_POLEIS, \"Factory: fee too high\");\r\n        if(_feePoleis > 0) require(feeRecipient != address(0), \"Factory: fee recipient is zero address\");\r\n        feePoleis = _feePoleis;\r\n    }\r\n\r\n    /**\r\n     * @notice Set a pending operator for the factory\r\n     * @param _pendingOperator address of the new pending operator\r\n     * @dev Only callable by the operator\r\n     */\r\n    function setPendingOperator(address _pendingOperator) external {\r\n        require(msg.sender == operator, \"Factory: not operator\");\r\n        pendingOperator = _pendingOperator;\r\n    }\r\n\r\n    /**\r\n     * @notice Accept the pending operator\r\n     * @dev Only callable by the pending operator\r\n     */\r\n    function acceptOperator() external {\r\n        require(msg.sender == pendingOperator, \"Factory: not pending operator\");\r\n        operator = pendingOperator;\r\n        pendingOperator = address(0);\r\n    }\r\n\r\n    /**\r\n     * @notice \r\n     * @return address \r\n     * @dev\r\n     */\r\n    function getFee() external view returns (address, uint) {\r\n        uint _feePoleis = feePoleis;\r\n        if(_feePoleis == 0) return (address(0), 0);\r\n        return (feeRecipient, _feePoleis);\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, rounded down, of a positive value. Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >= 10 ** 64) {\r\n                value /= 10 ** 64;\r\n                result += 64;\r\n            }\r\n            if (value >= 10 ** 32) {\r\n                value /= 10 ** 32;\r\n                result += 32;\r\n            }\r\n            if (value >= 10 ** 16) {\r\n                value /= 10 ** 16;\r\n                result += 16;\r\n            }\r\n            if (value >= 10 ** 8) {\r\n                value /= 10 ** 8;\r\n                result += 8;\r\n            }\r\n            if (value >= 10 ** 4) {\r\n                value /= 10 ** 4;\r\n                result += 4;\r\n            }\r\n            if (value >= 10 ** 2) {\r\n                value /= 10 ** 2;\r\n                result += 2;\r\n            }\r\n            if (value >= 10 ** 1) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }    \r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        unchecked {\r\n            uint256 length = log10(value) + 1;\r\n            string memory buffer = new string(length);\r\n            uint256 ptr;\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                ptr := add(buffer, add(32, length))\r\n            }\r\n            while (true) {\r\n                ptr--;\r\n                /// @solidity memory-safe-assembly\r\n                assembly {\r\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\r\n                }\r\n                value /= 10;\r\n                if (value == 0) break;\r\n            }\r\n            return buffer;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers pool tokens to the recipient\r\n     * @param _collateralToken Transfers pool tokens to the recipient\r\n     * @param _loanToken Transfers pool tokens to the recipient\r\n     * @param _maxCollateralRatioPoleis Transfers pool tokens to the recipient\r\n     * @param _financePoleis Transfers pool tokens to the recipient\r\n     * @param _collateralRatioFallDuration Transfers pool tokens to the recipient\r\n     * @param _collateralRatioRecoveryDuration Transfers pool tokens to the recipient\r\n     * @param _minRatePoleis Transfers pool tokens to the recipient\r\n     * @param _financeRatePoleis Transfers pool tokens to the recipient\r\n     * @param _maxRatePoleis Transfers pool tokens to the recipient\r\n     * @return Pool Transfers pool tokens to the recipient\r\n     */\r\n    function deployFinancePool(\r\n        IERC20 _collateralToken,\r\n        IERC20 _loanToken,\r\n        uint _maxCollateralRatioPoleis,\r\n        uint _financePoleis,\r\n        uint _collateralRatioFallDuration,\r\n        uint _collateralRatioRecoveryDuration,\r\n        uint _minRatePoleis,\r\n        uint _financeRatePoleis,\r\n        uint _maxRatePoleis\r\n    ) external returns (Pool) {\r\n        string memory poolNumberString = toString(pools.length);\r\n        string memory prefix = unpack(POOL_SYMBOL_PREFIX);\r\n        Pool pool = new Pool(\r\n            string(abi.encodePacked(prefix, poolNumberString)),\r\n            string(abi.encodePacked(\"Poleis \", prefix, poolNumberString, \" Pool\")),\r\n            _collateralToken,\r\n            _loanToken,\r\n            _maxCollateralRatioPoleis,\r\n            _financePoleis,\r\n            _collateralRatioFallDuration,\r\n            _collateralRatioRecoveryDuration,\r\n            _minRatePoleis,\r\n            _financeRatePoleis,\r\n            _maxRatePoleis\r\n        );\r\n        isPool[pool] = true;\r\n        emit PoolDeployed(pools.length, address(pool), address(_collateralToken), address(_loanToken), _maxCollateralRatioPoleis, _financePoleis, _collateralRatioFallDuration, _collateralRatioRecoveryDuration, _minRatePoleis, _financeRatePoleis, _maxRatePoleis);\r\n        pools.push(pool);\r\n        return pool;\r\n    }\r\n    event PoolDeployed(uint poolId, address pool, address indexed collateralToken, address indexed loanToken, uint indexed maxCollateralRatioPoleis, uint financePoleis, uint collateralRatioFallDuration, uint collateralRatioRecoveryDuration, uint minRatePoleis, uint financeRatePoleis, uint maxRatePoleis);\r\n}"

    },

    "contracts/Pool.sol": {

      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\ninterface IFactory {\r\n    function getFee() external view returns (address to, uint feePoleis);\r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address) external view returns(uint);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns(bool);\r\n    function transfer(address, uint) external returns (bool);\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\ncontract Pool {\r\n\r\n    IFactory public immutable FACTORY;\r\n    IERC20 public immutable COLLATERAL_TOKEN;\r\n    IERC20 public immutable LOAN_TOKEN;\r\n    string public symbol;\r\n    string public name;\r\n    uint8 public constant decimals = 18;\r\n    uint private constant RATE_CEILING = 100e18; \r\n    uint public constant MINIMUM_LIQUIDITY = 10 ** 3;\r\n    uint public constant MIN_LOCKUP_DURATION = 30 minutes;\r\n    uint public immutable MIN_RATE;\r\n    uint public immutable FINANCE_RATE;\r\n    uint public immutable MAX_RATE;\r\n    uint public immutable MAX_COLLATERAL_RATIO_POLEIS;\r\n    uint public immutable FINANCE_POLEIS;\r\n    uint public immutable COLLATERAL_RATIO_FALL_DURATION;\r\n    uint public immutable COLLATERAL_RATIO_RECOVERY_DURATION;\r\n    bytes4 private constant TRANSFER_SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n    bytes4 private constant TRANSFER_FROM_SELECTOR = bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n    uint public lastCollateralRatioPoleis;\r\n    uint public debtSharesSupply;\r\n    mapping (address => uint) public debtSharesBalanceOf;\r\n    uint public lastTotalDebt;\r\n    uint public lastAccrueInterestTime;\r\n    uint public totalSupply;\r\n    mapping (address => mapping (address => uint)) public allowance;\r\n    mapping (address => uint) public balanceOf;\r\n    mapping (address => uint) public collateralBalanceOf;\r\n    uint public lastLoanTokenBalance;\r\n    mapping (address => uint) public lastDepositTimestamp;\r\n\r\n    constructor(\r\n        string memory _symbol,\r\n        string memory _name,\r\n        IERC20 _collateralToken,\r\n        IERC20 _loanToken,\r\n        uint _maxCollateralRatioPoleis,\r\n        uint _financePoleis,\r\n        uint _collateralRatioFallDuration,\r\n        uint _collateralRatioRecoveryDuration,\r\n        uint _minRatePoleis,\r\n        uint _financeRatePoleis,\r\n        uint _maxRatePoleis\r\n    ) {\r\n        require(_collateralToken != _loanToken, \"Pool: collateral and loan tokens are the same\");\r\n        require(_collateralRatioFallDuration > 0, \"Pool: _collateralRatioFallDuration too low\");\r\n        require(_collateralRatioFallDuration <= _maxCollateralRatioPoleis, \"Pool: _collateralRatioFallDuration too high\");\r\n        require(_collateralRatioRecoveryDuration > 0, \"Pool: _collateralRatioRecoveryDuration too low\");\r\n        require(_collateralRatioRecoveryDuration <= _maxCollateralRatioPoleis, \"Pool: _collateralRatioRecoveryDuration too high\");\r\n        require(_maxCollateralRatioPoleis> 0, \"Pool: _maxCollateralRatioPoleis too low\");\r\n        require(_financePoleis < 1e18, \"Pool: _financePoleis too high\");\r\n        require(_minRatePoleis <= _financeRatePoleis, \"Pool: _minRatePoleis too high\");\r\n        require(_financeRatePoleis <= _maxRatePoleis, \"Pool: _financeRatePoleis too high\");\r\n        require(_maxRatePoleis <= RATE_CEILING, \"Pool: _maxRatePoleis too high\");\r\n        symbol = _symbol;\r\n        name = _name;\r\n        FACTORY = IFactory(msg.sender);\r\n        COLLATERAL_TOKEN = _collateralToken;\r\n        LOAN_TOKEN = _loanToken;\r\n        MAX_COLLATERAL_RATIO_POLEIS = _maxCollateralRatioPoleis;\r\n        FINANCE_POLEIS = _financePoleis;\r\n        COLLATERAL_RATIO_FALL_DURATION = _collateralRatioFallDuration;\r\n        COLLATERAL_RATIO_RECOVERY_DURATION = _collateralRatioRecoveryDuration;\r\n        lastCollateralRatioPoleis = _maxCollateralRatioPoleis;\r\n        MIN_RATE = _minRatePoleis;\r\n        FINANCE_RATE = _financeRatePoleis;\r\n        MAX_RATE = _maxRatePoleis;\r\n    }\r\n\r\n    function safeTransfer(IERC20 token, address to, uint value) internal {\r\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(TRANSFER_SELECTOR, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'Pool: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint value) internal {\r\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(TRANSFER_FROM_SELECTOR, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'Pool: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the current state of pool variables based on the current time\r\n     * @param _loanTokenBalance The current balance of the loan token in the pool\r\n     * @param _feePoleis The fee to be charged on interest accrual\r\n     * @param _lastCollateralRatioPoleis The collateral ratio at the last interest accrual\r\n     * @param _totalSupply The total supply of pool tokens at the last interest accrual\r\n     * @param _lastAccrueInterestTime The last time interest was accrued\r\n     * @param _totalDebt The total debt of the pool at the last interest accrual\r\n     * @return _currentTotalSupply The current total supply of pool tokens\r\n     * @return _accruedFeeShares The accrued fee shares to be transferred to the fee recipient\r\n     * @return _currentCollateralRatioPoleis The current collateral ratio\r\n     * @return _currentTotalDebt The current total debt of the pool\r\n     * @dev This view function behaves as a pure function with the exception of immutable variables (which are constant)\r\n     */\r\n    function getCurrentState(\r\n        uint _loanTokenBalance,\r\n        uint _feePoleis,\r\n        uint _lastCollateralRatioPoleis,\r\n        uint _totalSupply,\r\n        uint _lastAccrueInterestTime,\r\n        uint _totalDebt\r\n        ) internal view returns (\r\n            uint _currentTotalSupply,\r\n            uint _accruedFeeShares,\r\n            uint _currentCollateralRatioPoleis,\r\n            uint _currentTotalDebt\r\n        ) {\r\n        \r\n        /**\r\n         * @dev 1. Set default return values\r\n         */\r\n        _currentTotalSupply = _totalSupply;\r\n        _currentTotalDebt = _totalDebt;\r\n        _currentCollateralRatioPoleis = _lastCollateralRatioPoleis;\r\n        // _accruedFeeShares = 0;\r\n\r\n        /**\r\n         * @dev 2. Get the time passed since the last interest accrual\r\n         */\r\n        uint _timeDelta = block.timestamp - _lastAccrueInterestTime;\r\n        \r\n        /**\r\n         * @dev 3. If the time passed is 0, return the current values\r\n         */\r\n        if(_timeDelta == 0) return (_currentTotalSupply, _accruedFeeShares, _currentCollateralRatioPoleis, _currentTotalDebt);\r\n        \r\n        /**\r\n         * @dev 4. Calculate the supplied value\r\n         */\r\n        uint _supplied = _totalDebt + _loanTokenBalance;\r\n\r\n        /**\r\n         * @dev 5. Calculate the utilization\r\n         */\r\n        uint _util = getUtilizationPoleis(_totalDebt, _supplied);\r\n\r\n        /**\r\n         * @dev 6. Calculate the collateral ratio\r\n         */\r\n        _currentCollateralRatioPoleis = getCollateralRatioPoleis(\r\n            _util,\r\n            _lastAccrueInterestTime,\r\n            block.timestamp,\r\n            _lastCollateralRatioPoleis,\r\n            COLLATERAL_RATIO_FALL_DURATION,\r\n            COLLATERAL_RATIO_RECOVERY_DURATION,\r\n            MAX_COLLATERAL_RATIO_POLEIS,\r\n            FINANCE_POLEIS\r\n        );\r\n\r\n        /**\r\n         * @dev 7. If there is no debt, return the current values\r\n         */\r\n        if(_totalDebt == 0) return (_currentTotalSupply, _accruedFeeShares, _currentCollateralRatioPoleis, _currentTotalDebt);\r\n\r\n        /**\r\n         * @dev 8. Calculate the borrow rate\r\n         */\r\n        uint _borrowRate = getBorrowRatePoleis(_util, FINANCE_POLEIS, MIN_RATE, FINANCE_RATE, MAX_RATE);\r\n        \r\n        /**\r\n         * @dev 9. Calculate the interest\r\n         */\r\n        uint _interest = _totalDebt * _borrowRate * _timeDelta / (365 days * 1e18); // does the optimizer optimize this? or should it be a constant?\r\n        \r\n        /**\r\n         * @dev 10. Update the total debt\r\n         */\r\n        _currentTotalDebt += _interest;\r\n        \r\n        /**\r\n         * @dev 11. If there is no fee, return the current values\r\n         */\r\n        if(_feePoleis == 0) return (_currentTotalSupply, _accruedFeeShares, _currentCollateralRatioPoleis, _currentTotalDebt);\r\n        \r\n        /**\r\n         * @dev 12. Calculate the fee\r\n         */\r\n        uint fee = _interest * _feePoleis / 1e18;\r\n        \r\n        /**\r\n         * @dev 13. Calculate the accrued fee shares\r\n         */\r\n        _accruedFeeShares = fee * _totalSupply / (_supplied + _interest - fee); \r\n        \r\n        /**\r\n         * @dev 14. Update the total supply\r\n         */\r\n        _currentTotalSupply += _accruedFeeShares;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the current borrow rate in Poleis (scaled by 1e18)\r\n     * @param _util The utilization in Poleis (scaled by 1e18)\r\n     * @param _financePoleis The utilization at which the borrow rate will be at the finance rate in Poleis (scaled by 1e18)\r\n     * @param _minRatePoleis The minimum borrow rate at 0% utilization in Poleis (scaled by 1e18)\r\n     * @param _financeRatePoleis The borrow rate at the finance utilization in Poleis (scaled by 1e18)\r\n     * @param _maxRatePoleis The maximum borrow rate at 100% utilization in Poleis (scaled by 1e18)\r\n     * @return uint The borrow rate in Poleis (scaled by 1e18)\r\n     */\r\n    function getBorrowRatePoleis(uint _util, uint _financePoleis, uint _minRatePoleis, uint _financeRatePoleis, uint _maxRatePoleis) internal pure returns (uint) {\r\n        if(_util <= _financePoleis) {\r\n            return (_financeRatePoleis - _minRatePoleis) * 1e18 * _util / _financePoleis / 1e18 + _minRatePoleis; \r\n        } else {\r\n            uint excessUtil = _util - _financePoleis;\r\n            return (_maxRatePoleis - _financeRatePoleis) * 1e18 * excessUtil / (1e18 - _financePoleis) / 1e18 + _financeRatePoleis; \r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the current pool utilization rate in Poleis (scaled by 1e18)\r\n     * @param _totalDebt The total debt of the pool\r\n     * @param _supplied The total supplied loan tokens of the pool\r\n     * @return uint The pool utilization rate in Poleis (scaled by 1e18)\r\n     */\r\n    function getUtilizationPoleis(uint _totalDebt, uint _supplied) internal pure returns (uint) {\r\n        if(_supplied == 0) return 0;\r\n        return _totalDebt * 1e18 / _supplied;\r\n    }\r\n\r\n    /**\r\n     * @notice Converts a loan token amount to shares\r\n     * @param _tokenAmount The loan token amount to convert\r\n     * @param _supplied The total supplied loan tokens of the pool\r\n     * @param _sharesTotalSupply The total supply of shares of the pool\r\n     * @param roundUpCheck Whether to check and round up the shares amount\r\n     * @return uint The shares amount\r\n     */\r\n    function tokenToShares(uint _tokenAmount, uint _supplied, uint _sharesTotalSupply, bool roundUpCheck) internal pure returns (uint) {\r\n        if(_supplied == 0) return _tokenAmount;\r\n        uint shares = _tokenAmount * _sharesTotalSupply / _supplied;\r\n        if(roundUpCheck && shares * _supplied < _tokenAmount * _sharesTotalSupply) shares++;\r\n        return shares;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers pool tokens to the recipient\r\n     * @param _util Transfers pool tokens to the recipient\r\n     * @param _lastAccrueInterestTime Transfers pool tokens to the recipient\r\n     * @param _now Transfers pool tokens to the recipient\r\n     * @param _lastCollateralRatioPoleis Transfers pool tokens to the recipient\r\n     * @param _collateralRatioFallDuration Transfers pool tokens to the recipient\r\n     * @param _collateralRatioRecoveryDuration Transfers pool tokens to the recipient\r\n     * @param _maxCollateralRatioPoleis Transfers pool tokens to the recipient\r\n     * @param _financePoleis Transfers pool tokens to the recipient\r\n     * @return uint \r\n     */\r\n    function getCollateralRatioPoleis(\r\n        uint _util,\r\n        uint _lastAccrueInterestTime,\r\n        uint _now,\r\n        uint _lastCollateralRatioPoleis,\r\n        uint _collateralRatioFallDuration,\r\n        uint _collateralRatioRecoveryDuration,\r\n        uint _maxCollateralRatioPoleis,\r\n        uint _financePoleis\r\n        ) internal pure returns (uint) {\r\n        unchecked {\r\n            if(_lastAccrueInterestTime == _now) return _lastCollateralRatioPoleis;\r\n            \r\n            // If utilization is less than or equal to finance, we are increasing collateral ratio\r\n            if(_util <= _financePoleis) {\r\n                // The collateral ratio can only increase if it is less than the max collateral ratio\r\n                if(_lastCollateralRatioPoleis == _maxCollateralRatioPoleis) return _lastCollateralRatioPoleis;\r\n\r\n                // If the collateral ratio can increase, we calculate the increase\r\n                uint timeDelta = _now - _lastAccrueInterestTime;\r\n                uint change = timeDelta * _maxCollateralRatioPoleis / _collateralRatioRecoveryDuration;\r\n\r\n                // If the change in collateral ratio is greater than the max collateral ratio, we set the collateral ratio to the max collateral ratio\r\n                if(_lastCollateralRatioPoleis + change >= _maxCollateralRatioPoleis) {\r\n                    return _maxCollateralRatioPoleis;\r\n                } else {\r\n                    // Otherwise we increase the collateral ratio by the change\r\n                    return _lastCollateralRatioPoleis + change;\r\n                }\r\n            } else {\r\n                // If utilization is greater than the finance, we are decreasing collateral ratio\r\n                // The collateral ratio can only decrease if it is greater than 0\r\n                if(_lastCollateralRatioPoleis == 0) return 0;\r\n\r\n                // If the collateral ratio can decrease, we calculate the decrease\r\n                uint timeDelta = _now - _lastAccrueInterestTime;\r\n                uint change = timeDelta * _maxCollateralRatioPoleis / _collateralRatioFallDuration;\r\n\r\n                // If the change in collateral ratio is greater than the collateral ratio, we set the collateral ratio to 0\r\n                if(_lastCollateralRatioPoleis <= change) {\r\n                    return 0;\r\n                } else {\r\n                    // Otherwise we decrease the collateral ratio by the change\r\n                    return _lastCollateralRatioPoleis - change;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Transfers pool tokens to the recipient\r\n    /// @param to The address of the recipient\r\n    /// @param amount The amount of pool tokens to transfer\r\n    /// @return bool that indicates if the operation was successful\r\n    function transfer(address to, uint amount) external returns (bool) {\r\n        require(to != address(0), \"Pool: to cannot be address 0\");\r\n        require(lastDepositTimestamp[msg.sender] + MIN_LOCKUP_DURATION <= block.timestamp, \"Pool: cannot transfer within lockup duration\");\r\n        balanceOf[msg.sender] -= amount;\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n        emit Transfer(msg.sender, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers pool tokens on behalf of one address to another\r\n     * @param from The address of the sender\r\n     * @param to The address of the recipient\r\n     * @param amount The amount of pool tokens to transfer\r\n     * @return bool that indicates if the operation was successful\r\n     */\r\n    function transferFrom(address from, address to, uint amount) external returns (bool) {\r\n        require(to != address(0), \"Pool: to cannot be address 0\");\r\n        require(lastDepositTimestamp[from] + MIN_LOCKUP_DURATION <= block.timestamp, \"Pool: cannot transfer within lockup duration\");\r\n        if(from != msg.sender) {\r\n            allowance[from][msg.sender] -= amount;\r\n        }\r\n        balanceOf[from] -= amount;\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n        emit Transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Approves an address to spend pool tokens on behalf of the sender\r\n     * @param spender The address of the spender\r\n     * @param amount The amount of pool tokens to approve\r\n     * @return bool that indicates if the operation was successful\r\n     */\r\n    function approve(address spender, uint amount) external returns (bool) {\r\n        allowance[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Increases the allowance of an address to spend tokens on behalf of the sender\r\n     * @param spender The address of the spender\r\n     * @param addedValue The amount of tokens to increase the allowance by \r\n     */\r\n    function increaseAllowance(address spender, uint addedValue) external returns (bool) {\r\n        allowance[msg.sender][spender] += addedValue;\r\n        emit Approval(msg.sender, spender, allowance[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Decreases the allowance of an address to spend tokens on behalf of the sender\r\n     * @param spender The address of the spender\r\n     * @param subtractedValue The amount of tokens to decrease the allowance by\r\n     */\r\n    function decreaseAllowance(address spender, uint subtractedValue) external returns (bool) {\r\n        allowance[msg.sender][spender] -= subtractedValue;\r\n        emit Approval(msg.sender, spender, allowance[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Deposit loan tokens in exchange for pool tokens\r\n     * @param amount The amount of loan tokens to deposit \r\n     */\r\n    function deposit(uint amount) external {\r\n        (address _feeRecipient, uint _feePoleis) = FACTORY.getFee();\r\n        (  \r\n            uint _currentTotalSupply,\r\n            uint _accruedFeeShares,\r\n            uint _currentCollateralRatioPoleis,\r\n            uint _currentTotalDebt\r\n        ) = getCurrentState(\r\n            lastLoanTokenBalance,\r\n            _feePoleis,\r\n            lastCollateralRatioPoleis,\r\n            totalSupply,\r\n            lastAccrueInterestTime,\r\n            lastTotalDebt\r\n        );\r\n\r\n        if(_currentTotalSupply == 0) {\r\n            _currentTotalSupply = MINIMUM_LIQUIDITY;\r\n            balanceOf[address(0)] = MINIMUM_LIQUIDITY;\r\n            emit Transfer(address(0), address(0), MINIMUM_LIQUIDITY);\r\n        }\r\n        \r\n        uint _shares = tokenToShares(amount, (_currentTotalDebt + lastLoanTokenBalance), _currentTotalSupply, false);\r\n        require(_shares > 0, \"Pool: 0 shares\");\r\n        _currentTotalSupply += _shares;\r\n\r\n        // commit current state\r\n        balanceOf[msg.sender] += _shares;\r\n        totalSupply = _currentTotalSupply;\r\n        // avoid recording accrue interest time if there is no change in total debt i.e. 0 interest\r\n        if (lastTotalDebt != _currentTotalDebt) {\r\n            lastTotalDebt = _currentTotalDebt;\r\n            lastAccrueInterestTime = block.timestamp;\r\n        }\r\n        lastCollateralRatioPoleis = _currentCollateralRatioPoleis;\r\n        emit Deposit(msg.sender, amount);\r\n        emit Transfer(address(0), msg.sender, _shares);\r\n        if(_accruedFeeShares > 0) {\r\n            balanceOf[_feeRecipient] += _accruedFeeShares;\r\n            emit Transfer(address(0), _feeRecipient, _accruedFeeShares);\r\n        }\r\n        lastDepositTimestamp[msg.sender] = block.timestamp; // commiting the last commit time for the user to prevent transfers within the lockup duration\r\n\r\n        // interactions\r\n        safeTransferFrom(LOAN_TOKEN, msg.sender, address(this), amount);\r\n\r\n        // sync balance\r\n        lastLoanTokenBalance = LOAN_TOKEN.balanceOf(address(this));\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw loan tokens in exchange for pool tokens\r\n     * @param amount The amount of loan tokens to withdraw\r\n     * @dev If amount is type(uint).max, withdraws all loan tokens\r\n     */\r\n    function withdraw(uint amount) external {\r\n        require(lastDepositTimestamp[msg.sender] + MIN_LOCKUP_DURATION <= block.timestamp, \"Pool: cannot transfer within lockup duration\");\r\n        (address _feeRecipient, uint _feePoleis) = FACTORY.getFee();\r\n        (  \r\n            uint _currentTotalSupply,\r\n            uint _accruedFeeShares,\r\n            uint _currentCollateralRatioPoleis,\r\n            uint _currentTotalDebt\r\n        ) = getCurrentState(\r\n            lastLoanTokenBalance,\r\n            _feePoleis,\r\n            lastCollateralRatioPoleis,\r\n            totalSupply,\r\n            lastAccrueInterestTime,\r\n            lastTotalDebt\r\n        );\r\n\r\n        uint _shares;\r\n        if (amount == type(uint).max) {\r\n            amount = balanceOf[msg.sender] * (_currentTotalDebt + lastLoanTokenBalance) / _currentTotalSupply;\r\n            _shares = balanceOf[msg.sender];\r\n        } else {\r\n            _shares = tokenToShares(amount, (_currentTotalDebt + lastLoanTokenBalance), _currentTotalSupply, true);\r\n        }\r\n        _currentTotalSupply -= _shares;\r\n\r\n        // commit current state\r\n        balanceOf[msg.sender] -= _shares;\r\n        totalSupply = _currentTotalSupply;\r\n        // avoid recording accrue interest time if there is no change in total debt i.e. 0 interest\r\n        if (lastTotalDebt != _currentTotalDebt) {\r\n            lastTotalDebt = _currentTotalDebt;\r\n            lastAccrueInterestTime = block.timestamp;\r\n        }\r\n        lastCollateralRatioPoleis = _currentCollateralRatioPoleis;\r\n        emit Withdraw(msg.sender, amount);\r\n        emit Transfer(msg.sender, address(0), _shares);\r\n        if(_accruedFeeShares > 0) {\r\n            balanceOf[_feeRecipient] += _accruedFeeShares;\r\n            emit Transfer(address(0), _feeRecipient, _accruedFeeShares);\r\n        }\r\n\r\n        // interactions\r\n        safeTransfer(LOAN_TOKEN, msg.sender, amount);\r\n\r\n        // sync balance\r\n        lastLoanTokenBalance = LOAN_TOKEN.balanceOf(address(this));\r\n    }\r\n\r\n    /**\r\n     * @notice Deposit collateral tokens\r\n     * @param to The address to receive the collateral deposit\r\n     * @param amount The amount of collateral tokens to deposit \r\n     */\r\n    function addCollateral(address to, uint amount) external {\r\n        collateralBalanceOf[to] += amount;\r\n        safeTransferFrom(COLLATERAL_TOKEN, msg.sender, address(this), amount);\r\n        emit AddCollateral(to, msg.sender, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the debt of a user\r\n     * @param _userDebtShares The amount of debt shares of the user\r\n     * @param _debtSharesSupply The total amount of debt shares\r\n     * @param _totalDebt The total amount of debt\r\n     * @return uint The debt of the user\r\n     */\r\n    function getDebtOf(uint _userDebtShares, uint _debtSharesSupply, uint _totalDebt) internal pure returns (uint) {\r\n        if (_debtSharesSupply == 0) return 0;\r\n        uint debt = _userDebtShares * _totalDebt / _debtSharesSupply;\r\n        if(debt * _debtSharesSupply < _userDebtShares * _totalDebt) debt++;\r\n        return debt;\r\n    }\r\n    \r\n    /**\r\n     * @notice Withdraw collateral tokens\r\n     * @param amount The amount of collateral tokens to withdraw\r\n     */\r\n    function removeCollateral(uint amount) external {\r\n        (address _feeRecipient, uint _feePoleis) = FACTORY.getFee();\r\n        (  \r\n            uint _currentTotalSupply,\r\n            uint _accruedFeeShares,\r\n            uint _currentCollateralRatioPoleis,\r\n            uint _currentTotalDebt\r\n        ) = getCurrentState(\r\n            lastLoanTokenBalance,\r\n            _feePoleis,\r\n            lastCollateralRatioPoleis,\r\n            totalSupply,\r\n            lastAccrueInterestTime,\r\n            lastTotalDebt\r\n        );\r\n\r\n        uint userDebt = getDebtOf(debtSharesBalanceOf[msg.sender], debtSharesSupply, _currentTotalDebt);\r\n        if(userDebt > 0) {\r\n            uint userCollateralRatioPoleis = userDebt * 1e36 / (collateralBalanceOf[msg.sender] - amount);\r\n            require(userCollateralRatioPoleis <= (_currentCollateralRatioPoleis * 1e18), \"Pool: user collateral ratio too high\");\r\n        }\r\n\r\n        // commit current state\r\n        totalSupply = _currentTotalSupply;\r\n        // avoid recording accrue interest time if there is no change in total debt i.e. 0 interest\r\n        if (lastTotalDebt != _currentTotalDebt) {\r\n            lastTotalDebt = _currentTotalDebt;\r\n            lastAccrueInterestTime = block.timestamp;\r\n        }\r\n        lastCollateralRatioPoleis = _currentCollateralRatioPoleis;\r\n        collateralBalanceOf[msg.sender] -= amount;\r\n        emit RemoveCollateral(msg.sender, amount);\r\n        if(_accruedFeeShares > 0) {\r\n            balanceOf[_feeRecipient] += _accruedFeeShares;\r\n            emit Transfer(address(0), _feeRecipient, _accruedFeeShares);\r\n        }\r\n\r\n        // interactions\r\n        safeTransfer(COLLATERAL_TOKEN, msg.sender, amount);\r\n\r\n        // sync balance\r\n        lastLoanTokenBalance = LOAN_TOKEN.balanceOf(address(this));\r\n    }\r\n\r\n    /**\r\n     * @notice Borrow loan tokens\r\n     * @param amount The amount of loan tokens to borrow\r\n     */\r\n    function borrow(uint amount) external {\r\n        (address _feeRecipient, uint _feePoleis) = FACTORY.getFee();\r\n        (  \r\n            uint _currentTotalSupply,\r\n            uint _accruedFeeShares,\r\n            uint _currentCollateralRatioPoleis,\r\n            uint _currentTotalDebt\r\n        ) = getCurrentState(\r\n            lastLoanTokenBalance,\r\n            _feePoleis,\r\n            lastCollateralRatioPoleis,\r\n            totalSupply,\r\n            lastAccrueInterestTime,\r\n            lastTotalDebt\r\n        );\r\n\r\n        uint _debtSharesSupply = debtSharesSupply;\r\n        uint userDebt = getDebtOf(debtSharesBalanceOf[msg.sender], _debtSharesSupply, _currentTotalDebt) + amount;\r\n        uint userCollateralRatioPoleis = userDebt * 1e36 / collateralBalanceOf[msg.sender];\r\n        require(userCollateralRatioPoleis <= (_currentCollateralRatioPoleis * 1e18), \"Pool: user collateral ratio too high\");\r\n\r\n        uint _newUtil = getUtilizationPoleis(_currentTotalDebt + amount, (_currentTotalDebt + lastLoanTokenBalance));\r\n        require(_newUtil <= FINANCE_POLEIS, \"Pool: utilization too high\");\r\n\r\n        uint _shares = tokenToShares(amount, _currentTotalDebt, _debtSharesSupply, true);\r\n        _currentTotalDebt += amount;\r\n\r\n        // commit current state\r\n        debtSharesBalanceOf[msg.sender] += _shares;\r\n        debtSharesSupply = _debtSharesSupply + _shares;\r\n        totalSupply = _currentTotalSupply;\r\n        // avoid recording accrue interest time if there is no change in total debt i.e. 0 interest\r\n        if (lastTotalDebt != _currentTotalDebt) {\r\n            lastTotalDebt = _currentTotalDebt;\r\n            lastAccrueInterestTime = block.timestamp;\r\n        }\r\n        lastCollateralRatioPoleis = _currentCollateralRatioPoleis;\r\n        emit Borrow(msg.sender, amount);\r\n        if(_accruedFeeShares > 0) {\r\n            balanceOf[_feeRecipient] += _accruedFeeShares;\r\n            emit Transfer(address(0), _feeRecipient, _accruedFeeShares);\r\n        }\r\n\r\n        // interactions\r\n        safeTransfer(LOAN_TOKEN, msg.sender, amount);\r\n\r\n        // sync balance\r\n        lastLoanTokenBalance = LOAN_TOKEN.balanceOf(address(this));\r\n    }\r\n\r\n    /**\r\n     * @notice Repay loan tokens debt\r\n     * @param borrower The address of the borrower to repay on their behalf\r\n     * @param amount The amount of loan tokens to repay\r\n     * @dev If amount is max uint, all debt will be repaid\r\n     */\r\n    function repay(address borrower, uint amount) external {\r\n        (address _feeRecipient, uint _feePoleis) = FACTORY.getFee();\r\n        (  \r\n            uint _currentTotalSupply,\r\n            uint _accruedFeeShares,\r\n            uint _currentCollateralRatioPoleis,\r\n            uint _currentTotalDebt\r\n        ) = getCurrentState(\r\n            lastLoanTokenBalance,\r\n            _feePoleis,\r\n            lastCollateralRatioPoleis,\r\n            totalSupply,\r\n            lastAccrueInterestTime,\r\n            lastTotalDebt\r\n        );\r\n\r\n        uint _debtSharesSupply = debtSharesSupply;\r\n\r\n        uint _shares;\r\n        if(amount == type(uint).max) {\r\n            amount = getDebtOf(debtSharesBalanceOf[borrower], _debtSharesSupply, _currentTotalDebt);\r\n            _shares = debtSharesBalanceOf[borrower];\r\n        } else {\r\n            _shares = tokenToShares(amount, _currentTotalDebt, _debtSharesSupply, false);\r\n        }\r\n        _currentTotalDebt -= amount;\r\n\r\n        // commit current state\r\n        debtSharesBalanceOf[borrower] -= _shares;\r\n        debtSharesSupply = _debtSharesSupply - _shares;\r\n        totalSupply = _currentTotalSupply;\r\n        // avoid recording accrue interest time if there is no change in total debt i.e. 0 interest\r\n        if (lastTotalDebt != _currentTotalDebt) {\r\n            lastTotalDebt = _currentTotalDebt;\r\n            lastAccrueInterestTime = block.timestamp;\r\n        }\r\n        lastCollateralRatioPoleis = _currentCollateralRatioPoleis;\r\n        emit Repay(borrower, msg.sender, amount);\r\n        if(_accruedFeeShares > 0) {\r\n            balanceOf[_feeRecipient] += _accruedFeeShares;\r\n            emit Transfer(address(0), _feeRecipient, _accruedFeeShares);\r\n        }\r\n\r\n        // interactions\r\n        safeTransferFrom(LOAN_TOKEN, msg.sender, address(this), amount);\r\n        \r\n        // sync balance\r\n        lastLoanTokenBalance = LOAN_TOKEN.balanceOf(address(this));\r\n    }\r\n\r\n    /**\r\n     * @notice Seize collateral from an underwater borrower in exchange for repaying their debt\r\n     * @param borrower The address of the borrower to liquidate\r\n     * @param amount The amount of debt to repay\r\n     * @dev If amount is max uint, all debt will be liquidated\r\n     */\r\n    function liquidate(address borrower, uint amount) external {\r\n        (address _feeRecipient, uint _feePoleis) = FACTORY.getFee();\r\n        (  \r\n            uint _currentTotalSupply,\r\n            uint _accruedFeeShares,\r\n            uint _currentCollateralRatioPoleis,\r\n            uint _currentTotalDebt\r\n        ) = getCurrentState(\r\n            lastLoanTokenBalance,\r\n            _feePoleis,\r\n            lastCollateralRatioPoleis,\r\n            totalSupply,\r\n            lastAccrueInterestTime,\r\n            lastTotalDebt\r\n        );\r\n\r\n        uint collateralBalance = collateralBalanceOf[borrower];\r\n        uint _debtSharesSupply = debtSharesSupply;\r\n        uint userDebt = getDebtOf(debtSharesBalanceOf[borrower], _debtSharesSupply, _currentTotalDebt);\r\n        uint userCollateralRatioPoleis = userDebt * 1e36 / collateralBalance;\r\n        require(userCollateralRatioPoleis > (_currentCollateralRatioPoleis * 1e18), \"Pool: borrower not liquidatable\");\r\n\r\n        address _borrower = borrower; // avoid stack too deep\r\n        uint _amount = amount; // avoid stack too deep\r\n        uint _shares;\r\n        uint collateralReward;\r\n        if(_amount == type(uint).max || _amount == userDebt) {\r\n            collateralReward = collateralBalance;\r\n            _shares = debtSharesBalanceOf[_borrower];\r\n            _amount = userDebt;\r\n        } else {\r\n            collateralReward = _amount * collateralBalance / userDebt;\r\n            _shares = tokenToShares(_amount, _currentTotalDebt, _debtSharesSupply, false);\r\n        }\r\n\r\n        require(_shares != 0, \"Pool: zero shares to liquidate\");\r\n        _currentTotalDebt -= _amount;\r\n\r\n        // commit current state\r\n        debtSharesBalanceOf[_borrower] -= _shares;\r\n        debtSharesSupply = _debtSharesSupply - _shares;\r\n        collateralBalanceOf[_borrower] = collateralBalance - collateralReward;\r\n        totalSupply = _currentTotalSupply;\r\n        // avoid recording accrue interest time if there is no change in total debt i.e. 0 interest\r\n        if (lastTotalDebt != _currentTotalDebt) {\r\n            lastTotalDebt = _currentTotalDebt;\r\n            lastAccrueInterestTime = block.timestamp;\r\n        }\r\n        lastCollateralRatioPoleis = _currentCollateralRatioPoleis;\r\n        emit Liquidate(_borrower, msg.sender, _amount, collateralReward);\r\n        if(_accruedFeeShares > 0) {\r\n            address __feeRecipient = _feeRecipient; // avoid stack too deep\r\n            balanceOf[__feeRecipient] += _accruedFeeShares;\r\n            emit Transfer(address(0), __feeRecipient, _accruedFeeShares);\r\n        }\r\n\r\n        // interactions\r\n        safeTransferFrom(LOAN_TOKEN, msg.sender, address(this), _amount);\r\n        safeTransfer(COLLATERAL_TOKEN, msg.sender, collateralReward);\r\n\r\n\r\n        // sync balance\r\n        lastLoanTokenBalance = LOAN_TOKEN.balanceOf(address(this));\r\n    }\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Deposit(address indexed user, uint amount);\r\n    event Withdraw(address indexed user, uint amount);\r\n    event Borrow(address indexed user, uint amount);\r\n    event Repay(address indexed user, address indexed caller, uint amount);\r\n    event Liquidate(address indexed user, address indexed liquidator, uint amount, uint collateralReward);\r\n    event AddCollateral(address indexed user, address indexed caller, uint amount);\r\n    event RemoveCollateral(address indexed user, uint amount);\r\n}"

    }

  },

  "settings": {

    "optimizer": {

      "enabled": true,

      "runs": 200

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "libraries": {}

  }

}}