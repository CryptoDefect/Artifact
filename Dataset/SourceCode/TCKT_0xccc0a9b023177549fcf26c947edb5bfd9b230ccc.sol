{{

  "language": "Solidity",

  "sources": {

    "interfaces/Addresses.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// dev.kimlikdao.eth\n// dev.kimlikdao.avax\naddress constant DEV_KASASI = 0xC152e02e54CbeaCB51785C174994c2084bd9EF51;\n\n// kimlikdao.eth\n// kimlikdao.avax\naddress payable constant DAO_KASASI = payable(\n    0xcCc0106Dbc0291A0d5C97AAb42052Cb46dE60cCc\n);\naddress constant DAO_KASASI_DEPLOYER = 0x0DabB96F2320A170ac0dDc985d105913D937ea9A;\n\n// OYLAMA addresses\naddress constant OYLAMA = 0xcCc01Ec0E6Fb38Cce8b313c3c8dbfe66efD01cCc;\naddress constant OYLAMA_DEPLOYER = 0xD808C187Ef7D6f9999b6D9538C72E095db8c6df9;\n\n// TCKT addresses\naddress constant TCKT_ADDR = 0xcCc0a9b023177549fcf26c947edb5bfD9B230cCc;\naddress constant TCKT_DEPLOYER = 0x305166299B002a9aDE0e907dEd848878FD2237D7;\naddress constant TCKT_SIGNERS = 0xcCc09aA0d174271259D093C598FCe9Feb2791cCc;\naddress constant TCKT_SIGNERS_DEPLOYER = 0x4DeA92Bcb2C22011217C089797A270DfA5A51d53;\n\n// TCKO addresses\naddress constant TCKO_ADDR = 0xcCc0AC04C9251B74b0b30A20Fc7cb26EB62B0cCc;\naddress constant TCKO_DEPLOYER = 0xe7671eb60A45c905387df2b19A3803c6Be0Eb8f9;\n\n// TCKOK addresses\naddress constant TCKOK = 0xcCc0c4e5d57d251551575CEd12Aba80B43fF1cCc;\naddress constant TCKOK_DEPLOYER = 0x2EF1308e8641a20b509DC90d0568b96359498BBa;\n"

    },

    "interfaces/IDIDSigners.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nuint256 constant END_TS_OFFSET = 112;\n\nuint256 constant END_TS_MASK = uint256(type(uint64).max) << 112;\n\nuint256 constant WITHDRAW_OFFSET = 176;\n\nuint256 constant WITHDRAW_MASK = uint256(type(uint48).max) << 176;\n\ninterface IDIDSigners {\n    /**\n     * Maps a signer node address to a bit packed struct.\n     *\n     *`signerInfo` layout:\n     * |-- color --|-- withdraw --|--  endTs --|-- deposit --|-- startTs --|\n     * |--   32  --|--    48    --|--   64   --|--   48    --|--   64    --|\n     */\n    function signerInfo(address signer) external view returns (uint256);\n}\n"

    },

    "interfaces/IERC20.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 amount\n    );\n}\n"

    },

    "interfaces/IERC20Permit.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\n\ninterface IERC20Permit is IERC20 {\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function nonces(address owner) external view returns (uint256);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"

    },

    "interfaces/IERC721.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IERC721 {\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function balanceOf(address) external view returns (uint256);\n\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool);\n\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n}\n"

    },

    "TCKT.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.18;\n\nimport {DAO_KASASI, OYLAMA, TCKT_DEPLOYER, TCKT_SIGNERS} from \"interfaces/Addresses.sol\";\nimport {IDIDSigners, END_TS_OFFSET} from \"interfaces/IDIDSigners.sol\";\nimport {IERC20, IERC20Permit} from \"interfaces/IERC20Permit.sol\";\nimport {IERC721} from \"interfaces/IERC721.sol\";\n\n/**\n * An ECDSA signature (over secp256k1 curve) represented in compact form.\n *\n * See https://eips.ethereum.org/EIPS/eip-2098 for more information\n * on the compact form.\n */\nstruct Signature {\n    bytes32 r;\n    uint256 yParityAndS;\n}\n\n/**\n * @title TCKT: KimlikDAO DID Token.\n *\n * TCKT is a decentralized identifier (DID) NFT which can be minted by\n * interacting with the KimlikDAO protocol. To interact with the protocol,\n * one can use the reference dApp deployed at https://kimlikdao.org or run it\n * locally by cloning the repo https://github.com/KimlikDAO/dapp and following\n * the instructions therein.\n *\n * The contents of each TCKT is cryptographically committed to a single EVM\n * address, making it unusable from any other address.\n * TCKT implements most of the ERC-721 NFT interface excluding, notably, the\n * transfer-related methods, since TCKTs are non-transferrable.\n *\n * Minting\n * ========\n * One can mint a TCKT by using the various flavors of the `create()` method.\n * These methods differ in the payment type and whether a revoker list is\n * included. A discount is offerent for including a revoker list, which\n * increases security as explained below.\n *\n * Revoking\n * =========\n * A TCKT owner may call the `revoke()` method of a TCKT at any time to revoke\n * it, thereby making it unusable. This is useful, for example, when a user\n * gets their wallet private keys stolen.\n *\n * Social revoking\n * ================\n * When minting a TCKT, you can nominate 3-5 addresses as revokers, assign each\n * a weight and choose a revoke threshold. If enough of these addresses vote to\n * revoke the TCKT (with total weight at least the chosen threshold), it will\n * be revoked and become unusable.\n *\n * This feature is useful in the event that your wallet private keys are stolen\n * and, further, you no longer have access to them. In such circumstances, you\n * can inform the nominated revokers and request them to cast a revoke vote.\n *\n * To encourage setting up social revoke, a discount of 33% is offered\n * initially, and the discount rate is determined by the DAO vote thereafter.\n * The discount rate is set through the `updatePricesBulk()` method, which can\n * only be called by `OYLAMA`, the KimlikDAO voting contract.\n * (https://github.com/KimlikDAO/Oylama)\n *\n * Exposure report\n * ================\n * In the case a TCKT holder\n *\n *   1) gets their private keys stolen, and\n *   2) lose access to the keys themselves, and\n *   3) did not set up social revoke when minting the TCKT,\n *\n * there is one final way of disabling the stolen TCKT. The victim mints a new\n * TCKT and submits the `exposureReport` that comes with it to the\n * `reportExposure()` method of this contract. Doing so will disable *all*\n * previous TCKTs across all chains belonging to this person. For convenience,\n * one may use the interface at https://kimlikdao.org/report to submit the\n * `exposureReport` to the TCKT contract.\n *\n * Modifying the revoker list\n * ===========================\n * One can add new revokers, increase the weight of existing revokers or reduce\n * the revoke threshold after minting their TCKT by invoking the corresponding\n * methods of this contract. Removing a revoker is not possible since it would\n * allow an attacker having access to user privates key to remove all revokers.\n *\n * Pricing and payments\n * =====================\n * The price of a TCKT is set by the `updatePrice()` or the `updatePricesBulk()`\n * methods, which can only be called by `OYLAMA`, the KimlikDAO voting\n * contract.\n *\n * Fees collected as an ERC-20 token are transferred directly to the\n * `DAO_KASASI`, the KimlikDAO treasury and fees collected in the native token\n * are accumulated in this contract first and then swept to `DAO_KASASI`\n * periodically. The sweep mechanism was put in place to minimize the gas cost\n * of minting a TCKT. The sweep is completely permissionless; anyone can call\n * the `sweepNativeToken()` to transfer the native token balance of this\n * contract over to `DAO_KASASI`. Further, weekly sweeps are done by KimlikDAO\n * automation, covering the gas fee.\n *\n * @author KimlikDAO (https://kimlikdao.org)\n */\ncontract TCKT is IERC721 {\n    /**\n     * Returns the KimlikDAO protocol IPFS handle (in compact form) of an\n     * address or zero if the address does not have a TCKT.\n     */\n    mapping(address => uint256) public handleOf;\n\n    function name() external pure override returns (string memory) {\n        return \"KimlikDAO Kimlik Tokeni\";\n    }\n\n    function symbol() external pure override returns (string memory) {\n        return \"TCKT\";\n    }\n\n    /**\n     * Returns the number of TCKTs in a given account, which can be 0 or 1.\n     *\n     * Each account can hold at most one TCKT, however a new TCKT can be minted\n     * to the same address at any time replacing the previous one. While\n     * obtaining a TCKT is subject to a KimlikDAO fee, subsequent updates can\n     * be done by only paying the network fee.\n     */\n    function balanceOf(address addr) external view override returns (uint256) {\n        return handleOf[addr] == 0 ? 0 : 1;\n    }\n\n    /**\n     * Returns the URI of a TCKT with the given id (handle).\n     *\n     * @dev The handle of each TCKT is a compact representation of its\n     * KimlikDAO protocol IPFS cid. Given the handle, the IPFS cid can be\n     * obtained as\n     *\n     *     base58([0x12, 0x20, handle]).\n     *\n     * This method computes this value in a a gas efficient manner.\n     */\n    function tokenURI(uint256 id)\n        external\n        pure\n        override\n        returns (string memory)\n    {\n        unchecked {\n            bytes memory toChar = bytes(\n                \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n            );\n            uint256 magic = 0x4e5a461f976ce5b9229582822e96e6269e5d6f18a5960a04480c6825748ba04;\n            bytes\n                memory out = \"https://ipfs.kimlikdao.org/ipfs/Qm____________________________________________\";\n            out[77] = toChar[id % 58];\n            id /= 58;\n            for (uint256 p = 76; p > 34; --p) {\n                uint256 t = id + (magic & 63);\n                out[p] = toChar[t % 58];\n                magic >>= 6;\n                id = t / 58;\n            }\n            out[34] = toChar[id + 21];\n            return string(out);\n        }\n    }\n\n    /**\n     * Returns whether a given ERC-165 interface is supported.\n     *\n     * Here we claim to support the full ERC-721 interface so that wallets\n     * recognize TCKT as an NFT, even though we do not implement transfer\n     * related methods since TCKTs are non-transferrable.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-165 for more information.\n     *\n     * @param                  interfaceId to check support for.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        external\n        pure\n        override\n        returns (bool)\n    {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\n            interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.\n            interfaceId == 0x5b5e139f; // ERC165 interface ID for ERC721Metadata.\n    }\n\n    /**\n     * Creates a new TCKT and collects the fee in the native token.\n     *\n     * @param                  handle the compact encoding of the IPFS handle.\n     */\n    function create(uint256 handle) external payable {\n        require(msg.value >= (priceIn[address(0)] >> 128));\n        handleOf[msg.sender] = handle;\n        emit Transfer(address(this), msg.sender, handle);\n    }\n\n    /**\n     * Transfers the entire native token balance of this contract to\n     * `DAO_KASASI`.\n     *\n     * @dev To optimize the TCKT creation gas fees, we do not forward fees\n     * collected in the networks native token to `DAO_KASASI` in each TCKT\n     * creation.\n     *\n     * Instead, the fees are accumulated in this contract until the following\n     * method is called. The method is fully permissionless and can be invoked\n     * by anyone. Further, KimlikDAO does weekly sweeps, again using this\n     * method and covering the gas fee.\n     *\n     * @dev `DAO_KASASI` has an empty `receive()` method therefore the\n     * `transfer()` below should have enough gas to complete.\n     */\n    function sweepNativeToken() external {\n        DAO_KASASI.transfer(address(this).balance);\n    }\n\n    /**\n     * Moves ERC-20 tokens sent to this address by accident to `DAO_KASASI`.\n     */\n    function sweepToken(IERC20 token) external {\n        token.transfer(DAO_KASASI, token.balanceOf(address(this)));\n    }\n\n    /**\n     * Creates a new TCKT with the given social revokers and collects the fee\n     * in the native token.\n     *\n     * @param handle           IPFS handle of the persisted TCKT.\n     * @param revokers         A list of pairs (weight, address), bit packed\n     *                         into a single word, where the weight is a uint96\n     *                         and the address is 20 bytes. Further, the first\n     *                         word contains the revokeThreshold in the\n     *                         leftmost 64 bits.\n     */\n    function createWithRevokers(uint256 handle, uint256[5] calldata revokers)\n        external\n        payable\n    {\n        require(msg.value >= uint128(priceIn[address(0)]));\n        handleOf[msg.sender] = handle;\n        emit Transfer(address(this), msg.sender, handle);\n        setRevokers(revokers);\n    }\n\n    /**\n     * Creates a new TCKT collecting the fee in the provided `token`.\n     *\n     * This method works only with DAO approved tokens: the token must have\n     * been approved and set a nonzero price by the DAO vote beforehand.\n     *\n     * @param handle           IPFS handle of the persisted TCKT.\n     * @param token            Contract address of an ERC-20 token.\n     */\n    function createWithTokenPayment(uint256 handle, IERC20 token) external {\n        uint256 price = priceIn[address(token)] >> 128;\n        require(price > 0);\n        token.transferFrom(msg.sender, DAO_KASASI, price);\n        handleOf[msg.sender] = handle;\n        emit Transfer(address(this), msg.sender, handle);\n    }\n\n    /**\n     * Creates a TCKT and collects the fee in the provided `token` using the\n     * provided ERC-2612 permit signature.\n     *\n     * The provided token has to be IERC20Permit, in particular, it needs to\n     * support approval by signature.\n     *\n     * Note if a price change occurs between the moment the user signs off the\n     * payment and this method is called, the method call will fail as the\n     * signature will be invalid. However, the price changes happen at most\n     * once a week and off peak hours by the DAO vote.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2612 for more information on the\n     * ERC-20 permit extension.\n     *\n     * @param handle           IPFS handle of the persisted TCKT.\n     * @param deadlineAndToken Contract address of a IERC20Permit token and\n     *                         the timestamp until which the payment\n     *                         authorization is valid for.\n     * @param signature        Signature authorizing the token spend.\n     */\n    function createWithTokenPermit(\n        uint256 handle,\n        uint256 deadlineAndToken,\n        Signature calldata signature\n    ) external {\n        IERC20Permit token = IERC20Permit(address(uint160(deadlineAndToken)));\n        uint256 price = priceIn[address(token)] >> 128;\n        require(price > 0);\n        unchecked {\n            token.permit(\n                msg.sender,\n                address(this),\n                price,\n                deadlineAndToken >> 160,\n                uint8(signature.yParityAndS >> 255) + 27,\n                signature.r,\n                bytes32(signature.yParityAndS & ((1 << 255) - 1))\n            );\n        }\n        token.transferFrom(msg.sender, DAO_KASASI, price);\n        handleOf[msg.sender] = handle;\n        emit Transfer(address(this), msg.sender, handle);\n    }\n\n    /**\n     * @param handle           IPFS handle of the persisted TCKT.\n     * @param revokers         A list of pairs (weight, address), bit packed\n     *                         into a single word, where the weight is a uint96\n     *                         and the address is 20 bytes.\n     * @param token            Contract address of a IERC20Permit token.\n     */\n    function createWithRevokersWithTokenPayment(\n        uint256 handle,\n        uint256[5] calldata revokers,\n        IERC20 token\n    ) external {\n        uint256 price = uint128(priceIn[address(token)]);\n        require(price > 0);\n        token.transferFrom(msg.sender, DAO_KASASI, price);\n        handleOf[msg.sender] = handle;\n        emit Transfer(address(this), msg.sender, handle);\n        setRevokers(revokers);\n    }\n\n    /**\n     * @param handle           IPFS handle of the persisted TCKT.\n     * @param revokers         A list of pairs (weight, address), bit packed\n     *                         into a single word, where the weight is a uint96\n     *                         and the address is 20 bytes.\n     * @param deadlineAndToken Contract address of a IERC20Permit token.\n     * @param signature        Signature authorizing the token spend.\n     */\n    function createWithRevokersWithTokenPermit(\n        uint256 handle,\n        uint256[5] calldata revokers,\n        uint256 deadlineAndToken,\n        Signature calldata signature\n    ) external {\n        IERC20Permit token = IERC20Permit(address(uint160(deadlineAndToken)));\n        uint256 price = uint128(priceIn[address(token)]);\n        require(price > 0);\n        unchecked {\n            token.permit(\n                msg.sender,\n                address(this),\n                price,\n                deadlineAndToken >> 160,\n                uint8(signature.yParityAndS >> 255) + 27,\n                signature.r,\n                bytes32(signature.yParityAndS & ((1 << 255) - 1))\n            );\n        }\n        token.transferFrom(msg.sender, DAO_KASASI, price);\n        handleOf[msg.sender] = handle;\n        emit Transfer(address(this), msg.sender, handle);\n        setRevokers(revokers);\n    }\n\n    // keccak256(\n    //     abi.encode(\n    //         keccak256(\n    //             \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n    //         ),\n    //         keccak256(bytes(\"TCKT\")),\n    //         keccak256(bytes(\"1\")),\n    //         43114,\n    //         0xcCc0FD2f0D06873683aC90e8d89B79d62236BcCc\n    //     )\n    // );\n    bytes32 public constant DOMAIN_SEPARATOR =\n        0x7db0d3990a4f8f0132edfa8e2fbaadb7766971eb7fddc29f98969d9982dfe366;\n\n    // keccak256(\"CreateFor(uint256 handle)\")\n    bytes32 public constant CREATE_FOR_TYPEHASH =\n        0xe0b70ef26ac646b5fe42b7831a9d039e8afa04a2698e03b3321e5ca3516efe70;\n\n    /**\n     * Creates a TCKT on users behalf, covering the transaction fee.\n     *\n     * The user has to explicitly authorize the TCKT creation with the\n     * `createSig` and the token payment with the `paymentSig`.\n     *\n     * The gas fee is paid by the transaction sender, which can be either\n     * `OYLAMA` or `TCKT_DEPLOYER`. We restrict the method to these two\n     * addresses since the intent of a signature request is not as clear as\n     * that of a transaction and therefore a user may be tricked into creating\n     * a TCKT with incorrect and invalid contents. Note this restriction is not\n     * about TCKTs soundness; even if we made this method unrestricted, only the\n     * account owner could have created a valid TCKT. Still, we do not want\n     * users to be tricked into creating invalid TCKTs for whatever reason.\n     *\n     * @param handle           IPFS handle with which to create the TCKT.\n     * @param createSig        Signature endorsing the TCKT creation.\n     * @param deadlineAndToken The payment token and the deadline for the token\n     *                         permit signature.\n     * @param paymentSig       Token spend permission from the TCKT creator.\n     */\n    function createFor(\n        uint256 handle,\n        Signature calldata createSig,\n        uint256 deadlineAndToken,\n        Signature calldata paymentSig\n    ) external {\n        require(msg.sender == OYLAMA || msg.sender == TCKT_DEPLOYER);\n        IERC20Permit token = IERC20Permit(address(uint160(deadlineAndToken)));\n        uint256 price = priceIn[address(token)] >> 128;\n        require(price > 0);\n        unchecked {\n            bytes32 digest = keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR,\n                    keccak256(abi.encode(CREATE_FOR_TYPEHASH, handle))\n                )\n            );\n            address signer = ecrecover(\n                digest,\n                uint8(createSig.yParityAndS >> 255) + 27,\n                createSig.r,\n                bytes32(createSig.yParityAndS & ((1 << 255) - 1))\n            );\n            require(signer != address(0) && handleOf[signer] == 0);\n            token.permit(\n                signer,\n                address(this),\n                price,\n                deadlineAndToken >> 160,\n                uint8(paymentSig.yParityAndS >> 255) + 27,\n                paymentSig.r,\n                bytes32(paymentSig.yParityAndS & ((1 << 255) - 1))\n            );\n            token.transferFrom(signer, DAO_KASASI, price);\n            handleOf[signer] = handle;\n            emit Transfer(address(this), signer, handle);\n        }\n    }\n\n    /**\n     * @param handle           Updates the contents of the TCKT with the given\n     *                         IPFS handle.\n     */\n    function update(uint256 handle) external {\n        require(handleOf[msg.sender] != 0);\n        handleOf[msg.sender] = handle;\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    //\n    // Revoking related fields and methods\n    //\n    ///////////////////////////////////////////////////////////////////////////\n\n    event RevokerAssignment(\n        address indexed owner,\n        address indexed revoker,\n        uint256 weight\n    );\n\n    // keccak256(\"RevokeFriendFor(address friend)\");\n    bytes32 public constant REVOKE_FRIEND_FOR_TYPEHASH =\n        0xfbf2f0fb915c060d6b3043ea7458b132e0cbcd7973bac5644e78e4f17cd28b8e;\n\n    uint256 private constant REVOKES_REMAINING_MASK =\n        uint256(type(uint64).max) << 192;\n\n    mapping(address => mapping(address => uint256)) public revokerWeight;\n\n    // `revokeInfo` layout:\n    // |-- revokesRemaining --|--   empty   --|-- lastRevokeTimestamp --|\n    // |--        64        --|--    128    --|--          64         --|\n    mapping(address => uint256) public revokeInfo;\n\n    function revokesRemaining() external view returns (uint256) {\n        return revokeInfo[msg.sender] >> 192;\n    }\n\n    /**\n     * Returns the timestamp of the most recent revoke event for this account.\n     *\n     * All TCKTs obtained before this timestamp on this address across all\n     * chains are considered invalid.\n     *\n     * If no revoke event happened, the zero value is returned.\n     *\n     * @return timestamp of the last revoke event, or zero if none happened.\n     */\n    function lastRevokeTimestamp(address addr) external view returns (uint64) {\n        return uint64(revokeInfo[addr]);\n    }\n\n    function setRevokers(uint256[5] calldata revokers) internal {\n        revokeInfo[msg.sender] =\n            (revokeInfo[msg.sender] & type(uint64).max) |\n            (revokers[0] & REVOKES_REMAINING_MASK);\n\n        address rev0Addr = address(uint160(revokers[0]));\n        uint256 rev0Weight = (revokers[0] >> 160) & type(uint32).max;\n        require(rev0Addr != address(0) && rev0Addr != msg.sender);\n        revokerWeight[msg.sender][rev0Addr] = rev0Weight;\n        emit RevokerAssignment(msg.sender, rev0Addr, rev0Weight);\n\n        address rev1Addr = address(uint160(revokers[1]));\n        require(rev1Addr != address(0) && rev1Addr != msg.sender);\n        require(rev1Addr != rev0Addr);\n        revokerWeight[msg.sender][rev1Addr] = revokers[1] >> 160;\n        emit RevokerAssignment(msg.sender, rev1Addr, revokers[1] >> 160);\n\n        address rev2Addr = address(uint160(revokers[2]));\n        require(rev2Addr != address(0) && rev2Addr != msg.sender);\n        require(rev2Addr != rev1Addr && rev2Addr != rev0Addr);\n        revokerWeight[msg.sender][rev2Addr] = revokers[2] >> 160;\n        emit RevokerAssignment(msg.sender, rev2Addr, revokers[2] >> 160);\n\n        address rev3Addr = address(uint160(revokers[3]));\n        if (rev3Addr == address(0)) return;\n        revokerWeight[msg.sender][rev3Addr] = revokers[3] >> 160;\n        emit RevokerAssignment(msg.sender, rev3Addr, revokers[3] >> 160);\n\n        address rev4Addr = address(uint160(revokers[4]));\n        if (rev4Addr == address(0)) return;\n        revokerWeight[msg.sender][rev4Addr] = revokers[4] >> 160;\n        emit RevokerAssignment(msg.sender, rev4Addr, revokers[4] >> 160);\n    }\n\n    /**\n     * Revokes user's own TCKT, rendering it invalid.\n     *\n     * The owner may delete their TCKT at any time using this method.\n     */\n    function revoke() external {\n        emit Transfer(msg.sender, address(this), handleOf[msg.sender]);\n        revokeInfo[msg.sender] = block.timestamp;\n        delete handleOf[msg.sender];\n    }\n\n    /**\n     * Casts a \"social revoke\" vote on a friends TCKT.\n     *\n     * If a friend has granted the user a nonzero \"social revoke\" weight, the\n     * user can invoke this method to cast a \"social revoke\" vote on their\n     * friends TCKT. After calling this method, the users revoke weight is set\n     * to zero.\n     *\n     * @param friend           The wallet address of a friends TCKT.\n     */\n    function revokeFriend(address friend) external {\n        uint256 revInfo = revokeInfo[friend];\n        uint256 senderWeight = revokerWeight[friend][msg.sender] << 192;\n\n        require(senderWeight > 0);\n        delete revokerWeight[friend][msg.sender];\n\n        unchecked {\n            if (senderWeight >= (revInfo & REVOKES_REMAINING_MASK)) {\n                revokeInfo[friend] = block.timestamp;\n                if (handleOf[friend] != 0) {\n                    emit Transfer(friend, address(this), handleOf[friend]);\n                    delete handleOf[friend];\n                }\n            } else revokeInfo[friend] = revInfo - senderWeight;\n        }\n    }\n\n    /**\n     * Casts a social revoke vote for a friend on `signature` creators behalf.\n     *\n     * This method is particularly useful when the revoker is virtual; the TCKT\n     * owner generates a private key and immediately signs a `revokeFriendFor`\n     * request and emails the signature to a fiend. This way a friend without an\n     * EVM adress (but an email address) can cast a social revoke vote.\n     *\n     * @param friend           Account whose TCKT will be cast a revoke vote.\n     * @param signature        Signature from the revoker, authorizing a revoke\n     *                         for `friend`.\n     */\n    function revokeFriendFor(address friend, Signature calldata signature)\n        external\n    {\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(REVOKE_FRIEND_FOR_TYPEHASH, friend))\n            )\n        );\n        unchecked {\n            address revoker = ecrecover(\n                digest,\n                uint8(signature.yParityAndS >> 255) + 27,\n                signature.r,\n                bytes32(signature.yParityAndS & ((1 << 255) - 1))\n            );\n            require(revoker != address(0));\n            uint256 revInfo = revokeInfo[friend];\n            uint256 revokerW = revokerWeight[friend][revoker] << 192;\n            // revokerW > 0 if and only if revokerWeight[friend][revoker] > 0.\n            require(revokerW > 0);\n            delete revokerWeight[friend][revoker];\n\n            if (revokerW >= (revInfo & REVOKES_REMAINING_MASK)) {\n                revokeInfo[friend] = block.timestamp;\n                if (handleOf[friend] != 0) {\n                    emit Transfer(friend, address(this), handleOf[friend]);\n                    delete handleOf[friend];\n                }\n            } else revokeInfo[friend] = revInfo - revokerW;\n        }\n    }\n\n    /**\n     * Adds a revoker or increase a revokers weight.\n     *\n     * @param deltaAndRevoker  Address who is given the revoke vote permission\n     *                         and the added weight packed into a single word.\n     *                         The first 4 bytes have to be zero, the following\n     *                         8 bytes encode the added weight and the last 20\n     *                         bytes are the revoker address.\n     */\n    function addRevoker(uint256 deltaAndRevoker) external {\n        address revoker = address(uint160(deltaAndRevoker));\n        unchecked {\n            uint256 weight = revokerWeight[msg.sender][revoker] +\n                (deltaAndRevoker >> 160);\n            // Even after a complete compromise of the wallet private key, the\n            // attacker should not be able to decrease revoker weights by\n            // overflowing.\n            require(weight <= type(uint64).max);\n            revokerWeight[msg.sender][revoker] = weight;\n            emit RevokerAssignment(msg.sender, revoker, weight);\n        }\n    }\n\n    /**\n     * Reduces a TCKTs revoke threshold by the given amount.\n     *\n     * @param reduce           The amount to reduce.\n     */\n    function reduceRevokeThreshold(uint256 reduce) external {\n        uint256 threshold = revokeInfo[msg.sender] >> 192;\n        revokeInfo[msg.sender] = (threshold - reduce) << 192; // Checked substraction\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    //\n    // Price fields and methods\n    //\n    ///////////////////////////////////////////////////////////////////////////\n\n    event PriceChange(address indexed token, uint256 price);\n\n    /**\n     * The multiplicative premium for getting a TCKT wihout setting up social\n     * revoke. The initial value is 3/2, and adjusted by the DAO vote\n     * thereafter.\n     */\n    uint256 private revokerlessPremium = (3 << 128) | uint256(2);\n\n    /**\n     * The price of creating a TCKT with and without a revoker list denominated\n     * in a given token.\n     *\n     * The first 128 bytes of the returned vaule denotes the price without a\n     * revoker list and the last 128 bytes are the discounted price for setting\n     * up social revoke.\n     *\n     * The address 0 is understood as the native token.\n     */\n    mapping(address => uint256) public priceIn;\n\n    constructor() {\n        priceIn[0x0000000000000000000000000000000000000000] =\n            (0.0009e18 << 128) |\n            0.0006e18;\n        priceIn[0xdAC17F958D2ee523a2206206994597C13D831ec7] =\n            (1.5e6 << 128) |\n            1e6;\n        priceIn[0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48] =\n            (1.5e6 << 128) |\n            1e6;\n        priceIn[0x2C537E5624e4af88A7ae4060C022609376C8D0EB] =\n            (28.5e6 << 128) |\n            19e6;\n        priceIn[0x4Fabb145d64652a948d72533023f6E7A623C7C53] =\n            (1.5e18 << 128) |\n            1e18;\n    }\n\n    /**\n     * Updates TCKT prices in a given list of tokens.\n     *\n     * @param premium          The multiplicative price premium for getting a\n     *                         TCKT without specifying a social revokers list.\n     *                         The 256-bit value is understood as 128-bit\n     *                         numerator followed by 128-bit denominator.\n     * @param prices           A list of tuples (price, address) where the\n     *                         price is an uint96 and the address is 20 bytes.\n     */\n    function updatePricesBulk(uint256 premium, uint256[5] calldata prices)\n        external\n    {\n        require(msg.sender == OYLAMA);\n        unchecked {\n            revokerlessPremium = premium;\n            for (uint256 i = 0; i < 5; ++i) {\n                if (prices[i] == 0) break;\n                address token = address(uint160(prices[i]));\n                uint256 price = prices[i] >> 160;\n                uint256 t = (price * premium) / uint128(premium);\n                priceIn[token] = (t & (type(uint256).max << 128)) | price;\n                emit PriceChange(token, price);\n            }\n        }\n    }\n\n    /**\n     * Updates the price of a TCKT denominated in a given token.\n     *\n     * @param priceAndToken    The price as a 96 bit integer, followed by the\n     *                         token address for a ERC-20 token or the zero\n     *                         address, which is understood as the native\n     *                         token.\n     */\n    function updatePrice(uint256 priceAndToken) external {\n        require(msg.sender == OYLAMA);\n        unchecked {\n            address token = address(uint160(priceAndToken));\n            uint256 price = priceAndToken >> 160;\n            uint256 premium = revokerlessPremium;\n            uint256 t = (price * premium) / uint128(premium);\n            priceIn[token] = (t & (type(uint256).max << 128)) | price;\n            emit PriceChange(token, price);\n        }\n    }\n}"

    }

  },

  "settings": {

    "optimizer": {

      "enabled": true,

      "runs": 10000

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "abi"

        ]

      }

    }

  }

}}