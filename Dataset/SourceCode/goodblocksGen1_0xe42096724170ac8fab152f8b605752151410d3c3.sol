{{

  "language": "Solidity",

  "sources": {

    "contracts/Bytecode.sol": {

      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n\r\nlibrary Bytecode {\r\n  error InvalidCodeAtRange(uint256 _size, uint256 _start, uint256 _end);\r\n\r\n  /**\r\n    @notice Generate a creation code that results on a contract with `_code` as bytecode\r\n    @param _code The returning value of the resulting `creationCode`\r\n    @return creationCode (constructor) for new contract\r\n  */\r\n  function creationCodeFor(bytes memory _code) internal pure returns (bytes memory) {\r\n    /*\r\n      0x00    0x63         0x63XXXXXX  PUSH4 _code.length  size\r\n      0x01    0x80         0x80        DUP1                size size\r\n      0x02    0x60         0x600e      PUSH1 14            14 size size\r\n      0x03    0x60         0x6000      PUSH1 00            0 14 size size\r\n      0x04    0x39         0x39        CODECOPY            size\r\n      0x05    0x60         0x6000      PUSH1 00            0 size\r\n      0x06    0xf3         0xf3        RETURN\r\n      <CODE>\r\n    */\r\n\r\n    return abi.encodePacked(\r\n      hex\"63\",\r\n      uint32(_code.length),\r\n      hex\"80_60_0E_60_00_39_60_00_F3\",\r\n      _code\r\n    );\r\n  }\r\n\r\n  /**\r\n    @notice Returns the size of the code on a given address\r\n    @param _addr Address that may or may not contain code\r\n    @return size of the code on the given `_addr`\r\n  */\r\n  function codeSize(address _addr) internal view returns (uint256 size) {\r\n    assembly { size := extcodesize(_addr) }\r\n  }\r\n\r\n  /**\r\n    @notice Returns the code of a given address\r\n    @dev It will fail if `_end < _start`\r\n    @param _addr Address that may or may not contain code\r\n    @param _start number of bytes of code to skip on read\r\n    @param _end index before which to end extraction\r\n    @return oCode read from `_addr` deployed bytecode\r\n\r\n    Forked from: https://gist.github.com/KardanovIR/fe98661df9338c842b4a30306d507fbd\r\n  */\r\n  function codeAt(address _addr, uint256 _start, uint256 _end) internal view returns (bytes memory oCode) {\r\n    uint256 csize = codeSize(_addr);\r\n    if (csize == 0) return bytes(\"\");\r\n\r\n    if (_start > csize) return bytes(\"\");\r\n    if (_end < _start) revert InvalidCodeAtRange(csize, _start, _end); \r\n\r\n    unchecked {\r\n      uint256 reqSize = _end - _start;\r\n      uint256 maxSize = csize - _start;\r\n\r\n      uint256 size = maxSize < reqSize ? maxSize : reqSize;\r\n\r\n      assembly {\r\n        // allocate output byte array - this could also be done without assembly\r\n        // by using o_code = new bytes(size)\r\n        oCode := mload(0x40)\r\n        // new \"memory end\" including padding\r\n        mstore(0x40, add(oCode, and(add(add(size, 0x20), 0x1f), not(0x1f))))\r\n        // store length in memory\r\n        mstore(oCode, size)\r\n        // actually retrieve the code, this needs assembly\r\n        extcodecopy(_addr, add(oCode, 0x20), _start, size)\r\n      }\r\n    }\r\n  }\r\n}"

    },

    "contracts/gbGen1.sol": {

      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\nimport \"./SSTORE2.sol\";\r\n\r\nerror YooooThatTokenIdIsWayTooHigh();\r\nerror GottaUnlockGen1Please();\r\nerror YoureNotTheOwnerHomie();\r\n\r\n/*\r\n\r\n     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆ       â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ \r\n    â–ˆâ–ˆ       â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ      â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆ      â–ˆâ–ˆ  â–ˆâ–ˆ  â–ˆâ–ˆ      \r\n    â–ˆâ–ˆ   â–ˆâ–ˆâ–ˆ â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆ      â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆ      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ \r\n    â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ      â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆ      â–ˆâ–ˆ  â–ˆâ–ˆ       â–ˆâ–ˆ \r\n     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ \r\n                                                                                        \r\n                                                                                        \r\n     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆ        â–ˆâ–ˆ                                                \r\n    â–ˆâ–ˆ       â–ˆâ–ˆ      â–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆ       â–ˆâ–ˆâ–ˆ                                                \r\n    â–ˆâ–ˆ   â–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ  â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆ                                                \r\n    â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆ      â–ˆâ–ˆ  â–ˆâ–ˆ â–ˆâ–ˆ        â–ˆâ–ˆ                                                \r\n     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆâ–ˆâ–ˆ        â–ˆâ–ˆ\r\n\r\n    \r\n    circles and squares\r\n\r\n*/\r\n\r\n\r\ncontract goodblocksGen1\r\n{\r\n    // gen-1 description\r\n    string private constant Gen1Description = unicode\"who said circles and squares cant get along? welcome to gen-1 where these two shapes come together in perfect harmony. you know the drill... enjoy the art, explore the code, and dont forget to click around for some extra fun! ðŸ˜‰\";\r\n\r\n\r\n\r\n    /*\r\n\r\n        â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆ     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆ       â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ \r\n        â–ˆâ–ˆ         â–ˆâ–ˆ    â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ             â–ˆâ–ˆ    â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ      â–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆ     â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ      â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆ      â–ˆâ–ˆ  â–ˆâ–ˆ  â–ˆâ–ˆ      \r\n        â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ    â–ˆâ–ˆ    â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ          â–ˆâ–ˆ    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆ     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆ      â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆ      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ \r\n             â–ˆâ–ˆ    â–ˆâ–ˆ    â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ             â–ˆâ–ˆ    â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ      â–ˆâ–ˆ  â–ˆâ–ˆ  â–ˆâ–ˆ     â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ      â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆ      â–ˆâ–ˆ  â–ˆâ–ˆ       â–ˆâ–ˆ \r\n        â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ    â–ˆâ–ˆ     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ        â–ˆâ–ˆ    â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆ      â–ˆâ–ˆ     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\r\n\r\n    */\r\n\r\n    // gen-1 block struct\r\n    struct Gen1Block\r\n    {\r\n        uint256 numLevels;\r\n        uint256 widthInterval;\r\n        uint256 circleCount;\r\n        uint256 squareCount;\r\n        uint256 noneCount;\r\n        uint256 complexityLevel;\r\n        bool glitchy;\r\n        string svg;\r\n        string name;\r\n        string[4] palette;\r\n    }\r\n\r\n    // struct to store complex shapes\r\n    struct ComplexShape\r\n    {\r\n        // array of addresses that store complex shape string pieces\r\n        address[] pointers;\r\n    }\r\n\r\n    // 32 complex shapes for gen-1\r\n    ComplexShape[32] private ComplexShapes;\r\n\r\n    // write string with sstore2\r\n    function writeString(string memory _string) external onlyOwner returns(address)\r\n    {\r\n        return SSTORE2.write(bytes(_string));\r\n    }\r\n\r\n    // add pointer to complex shape address data\r\n    function addComplexShapePointer(uint256 _shapeIndex, uint256 _pointerIndex, address _pointer) external onlyOwner\r\n    {\r\n        ComplexShapes[_shapeIndex].pointers[_pointerIndex] = _pointer;\r\n    }\r\n\r\n    // add another sstore2 contract address to a complex shape array by index\r\n    function addComplexShapeString(uint256 _shapeIndex, string memory _string) external onlyOwner\r\n    {\r\n        // write string and get pointer\r\n        address _newPointer = SSTORE2.write(bytes(_string));\r\n        // add pointer to complex shape array\r\n        ComplexShapes[_shapeIndex].pointers.push(_newPointer);\r\n    }\r\n\r\n    // returns the svg shapes of a complex shape\r\n    function getComplexShape(uint256 _shapeIndex) public view returns(string memory)\r\n    {\r\n        // if complex shape not loaded, return empty string\r\n        if(ComplexShapes[_shapeIndex].pointers.length == 0)\r\n        {\r\n            return \"\";\r\n        }\r\n\r\n        uint256 i;\r\n        string memory output;\r\n        address[] memory pointers = ComplexShapes[_shapeIndex].pointers;\r\n        unchecked\r\n        {\r\n            do\r\n            {\r\n                output = string.concat(output, string(SSTORE2.read(pointers[i])));\r\n                ++i;\r\n            } while(i<pointers.length);\r\n        }\r\n        return output;\r\n    }\r\n\r\n    // reset complex shape to rewrite shape\r\n    function resetComplexShapePointers(uint256 _shapeIndex) external onlyOwner\r\n    {\r\n        delete ComplexShapes[_shapeIndex].pointers;\r\n    }\r\n\r\n    // borrowed colors and palettes from gen0\r\n    string[7] private ColorGroupNames = [\"Joy\", \"Night\", \"Cosmos\", \"Earth\", \"Arctic\", \"Serenity\", \"Twilight\"];\r\n    string[4][56] private ColorPalettes = \r\n    [\r\n        [\"#FDFF8F\",\"#A8ECE7\",\"#F4BEEE\",\"#D47AE8\"], // 0 palette (Joy)\r\n        [\"#FD6F96\",\"#FFEBA1\",\"#95DAC1\",\"#6F69AC\"],\r\n        [\"#FFDF6B\",\"#FF79CD\",\"#AA2EE6\",\"#23049D\"],\r\n        [\"#95E1D3\",\"#EAFFD0\",\"#FCE38A\",\"#FF75A0\"],\r\n        [\"#FFCC29\",\"#F58634\",\"#007965\",\"#00AF91\"],\r\n        [\"#998CEB\",\"#77E4D4\",\"#B4FE98\",\"#FBF46D\"],\r\n        [\"#EEEEEE\",\"#77D970\",\"#172774\",\"#FF0075\"],\r\n        [\"#005F99\",\"#FF449F\",\"#FFF5B7\",\"#00EAD3\"],\r\n        [\"#0B0B0D\",\"#474A56\",\"#929AAB\",\"#D3D5FD\"], // 1 palette (Night)\r\n        [\"#07031A\",\"#4F8A8B\",\"#B1B493\",\"#FFCB74\"],\r\n        [\"#2E3A63\",\"#665C84\",\"#71A0A5\",\"#FAB95B\"],\r\n        [\"#000000\",\"#226089\",\"#4592AF\",\"#E3C4A8\"],\r\n        [\"#1B1F3A\",\"#53354A\",\"#A64942\",\"#FF7844\"],\r\n        [\"#1a1a1a\",\"#153B44\",\"#2D6E7E\",\"#C6DE41\"],\r\n        [\"#0F0A3C\",\"#07456F\",\"#009F9D\",\"#CDFFEB\"],\r\n        [\"#130026\",\"#801336\",\"#C72C41\",\"#EE4540\"],\r\n        [\"#111D5E\",\"#C70039\",\"#F37121\",\"#C0E218\"], // 2 palette (Cosmos)\r\n        [\"#02383C\",\"#230338\",\"#ED5107\",\"#C70D3A\"],\r\n        [\"#03C4A1\",\"#C62A88\",\"#590995\",\"#150485\"],\r\n        [\"#00A8CC\",\"#005082\",\"#000839\",\"#FFA41B\"],\r\n        [\"#E94560\",\"#0F3460\",\"#16213E\",\"#1A1A2E\"],\r\n        [\"#D2FAFB\",\"#FE346E\",\"#512B58\",\"#2C003E\"],\r\n        [\"#706C61\",\"#E1F4F3\",\"#FFFFFF\",\"#333333\"],\r\n        [\"#FAF7F2\",\"#2BB3C0\",\"#161C2E\",\"#EF6C35\"],\r\n        [\"#FFFBE9\",\"#E3CAA5\",\"#CEAB93\",\"#AD8B73\"], // 3 palette (Earth)\r\n        [\"#A09F57\",\"#C56824\",\"#CFB784\",\"#EADEB8\"],\r\n        [\"#E3D0B9\",\"#E1BC91\",\"#C19277\",\"#62959C\"],\r\n        [\"#E9C891\",\"#8A8635\",\"#AE431E\",\"#D06224\"],\r\n        [\"#83B582\",\"#D6E4AA\",\"#FFFFC5\",\"#F0DD92\"],\r\n        [\"#303E27\",\"#B4BB72\",\"#E7EAA8\",\"#F6FAF7\"],\r\n        [\"#A8896C\",\"#F1E8A7\",\"#AED09E\",\"#61B292\"],\r\n        [\"#F4DFBA\",\"#EEC373\",\"#CA965C\",\"#876445\"],\r\n        [\"#42C2FF\",\"#85F4FF\",\"#B8FFF9\",\"#EFFFFD\"], // 4 palette (Arctic)\r\n        [\"#E8F0F2\",\"#A2DBFA\",\"#39A2DB\",\"#053742\"],\r\n        [\"#3E64FF\",\"#5EDFFF\",\"#B2FCFF\",\"#ECFCFF\"],\r\n        [\"#D1FFFA\",\"#4AA9AF\",\"#3E31AE\",\"#1C226B\"],\r\n        [\"#F7F3F3\",\"#C1EAF2\",\"#5CC2F2\",\"#191BA9\"],\r\n        [\"#F3F3F3\",\"#303841\",\"#3A4750\",\"#2185D5\"],\r\n        [\"#769FCD\",\"#B9D7EA\",\"#D6E6F2\",\"#F7FBFC\"],\r\n        [\"#3D6CB9\",\"#00D1FF\",\"#00FFF0\",\"#FAFAF6\"],\r\n        [\"#99FEFF\",\"#94DAFF\",\"#94B3FD\",\"#B983FF\"], // 5 palette (Serenity)\r\n        [\"#E5707E\",\"#E6B566\",\"#E8E9A1\",\"#A3DDCB\"],\r\n        [\"#6892D5\",\"#79D1C3\",\"#C9FDD7\",\"#F8FCFB\"],\r\n        [\"#6C5B7B\",\"#C06C84\",\"#F67280\",\"#F8B195\"],\r\n        [\"#30475E\",\"#BA6B57\",\"#F1935C\",\"#E7B2A5\"],\r\n        [\"#FFEBD3\",\"#264E70\",\"#679186\",\"#FFB4AC\"],\r\n        [\"#6DDCCF\",\"#94EBCD\",\"#FFEFA1\",\"#FFCB91\"],\r\n        [\"#D8EFF0\",\"#B0E0A8\",\"#F0F69F\",\"#F3C1C6\"],\r\n        [\"#35477D\",\"#6C5B7B\",\"#C06C84\",\"#F67280\"], // 6 palette (Twilight)\r\n        [\"#F6C065\",\"#55B3B1\",\"#AF0069\",\"#09015F\"],\r\n        [\"#470D21\",\"#9C0F48\",\"#D67D3E\",\"#F9E4D4\"],\r\n        [\"#001F52\",\"#A10054\",\"#FF8D68\",\"#FFECBA\"],\r\n        [\"#FF6C00\",\"#A0204C\",\"#23103A\",\"#282D4F\"],\r\n        [\"#FFF9B2\",\"#ECAC5D\",\"#B24080\",\"#3F0713\"],\r\n        [\"#FFE98A\",\"#C84771\",\"#61105E\",\"#280B45\"],\r\n        [\"#EDE862\",\"#FA9856\",\"#F27370\",\"#22559C\"]\r\n    ];\r\n\r\n    // bones of the gen-1 svg\r\n    address[4] private SVGAddresses;\r\n\r\n    // set svg piece\r\n    function setSvgPiece(uint256 _index, string memory _string) external onlyOwner returns(address)\r\n    {\r\n        SVGAddresses[_index] = SSTORE2.write(bytes(_string));\r\n        return SVGAddresses[_index];\r\n    }\r\n    \r\n    // read svg piece\r\n    function readSvgPiece(uint256 _index) public view returns(string memory)\r\n    {\r\n        return string(SSTORE2.read(SVGAddresses[_index]));\r\n    }\r\n    \r\n\r\n\r\n    /*\r\n\r\n        â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆ     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆ       â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ \r\n        â–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ  â–ˆâ–ˆ  â–ˆâ–ˆ          â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ      â–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆ     â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ      â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆ      â–ˆâ–ˆ  â–ˆâ–ˆ  â–ˆâ–ˆ      \r\n        â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ       â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆ     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆ      â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆ      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ \r\n        â–ˆâ–ˆ  â–ˆâ–ˆ  â–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ  â–ˆâ–ˆ  â–ˆâ–ˆ          â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ      â–ˆâ–ˆ  â–ˆâ–ˆ  â–ˆâ–ˆ     â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ      â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆ      â–ˆâ–ˆ  â–ˆâ–ˆ       â–ˆâ–ˆ \r\n        â–ˆâ–ˆ      â–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆ      â–ˆâ–ˆ     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ \r\n\r\n    */\r\n\r\n    // get token uri for gen-1\r\n    function tokenGenURI(uint256 _tokenId, string memory _tokenMetadata, string memory _tokenAttributes) public view returns(string memory)\r\n    {\r\n        // check if valid token ID\r\n        if(_tokenId > 8280) revert YooooThatTokenIdIsWayTooHigh();\r\n        // get token data\r\n        IGBContract.TokenData memory tokenData = GBTokenContract.getTokenData(_tokenId);\r\n        // check if gen-1 has been unlocked\r\n        if(tokenData.highestGenLevel < 1) revert GottaUnlockGen1Please();\r\n        // get gen-0 block\r\n        IGen0Contract.GoodBlock memory gen0_block = Gen0Contract.tokenToGoodblock(_tokenId);\r\n        // get gen-1 block\r\n        Gen1Block memory gen1_block = getGen1Block(_tokenId, tokenData, gen0_block);\r\n        // get token metadata\r\n        string memory metadata = blockToMetadata(tokenData, gen0_block, gen1_block, _tokenAttributes);\r\n\r\n        // construct token uri\r\n        string memory tokenUri = string.concat(\r\n            '{\"name\":\"',\r\n            ColorGroupNames[gen0_block.colorGroupIndex],\r\n            ' #',\r\n            OZ.toString(_tokenId),\r\n            '\",\"description\":\"',\r\n            Gen1Description,\r\n            '\",',\r\n            _tokenMetadata,\r\n            '\"attributes\":[',\r\n            metadata,\r\n            '],\"image\":\"data:image/svg+xml;base64,',\r\n            string(OZ.encode(bytes(gen1_block.svg))),\r\n            '\"}'\r\n        );\r\n        // return that suckah!\r\n        return string.concat(\"data:application/json;base64,\", string(OZ.encode(bytes(tokenUri))));\r\n    }\r\n\r\n    // get token svg (interoperability)\r\n    function getTokenSVG(uint256 _tokenId) public view returns(string memory)\r\n    {\r\n        // check if valid token ID\r\n        if(_tokenId > 8280) revert YooooThatTokenIdIsWayTooHigh();\r\n        // get token data\r\n        IGBContract.TokenData memory tokenData = GBTokenContract.getTokenData(_tokenId);\r\n        // check if gen-1 has been unlocked\r\n        if(tokenData.highestGenLevel < 1) revert GottaUnlockGen1Please();\r\n        // get gen-0 block\r\n        IGen0Contract.GoodBlock memory gen0_block = Gen0Contract.tokenToGoodblock(_tokenId);\r\n\r\n        Gen1Block memory gen1Block = getGen1Block(_tokenId, tokenData, gen0_block);\r\n        return gen1Block.svg;\r\n    }\r\n\r\n    // get gen-1 block\r\n    function getGen1Block(uint256 _tokenId, IGBContract.TokenData memory _tokenData, IGen0Contract.GoodBlock memory _gen0block) private view returns(Gen1Block memory)\r\n    {\r\n        // create gen-1 block\r\n        Gen1Block memory gen1_block;\r\n        // create token id as string\r\n        string memory tokenIdString = OZ.toString(_tokenId);\r\n        unchecked\r\n        {\r\n            // set levels and shape width interval\r\n            gen1_block.numLevels = (random(string.concat(tokenIdString, \"create x innovate x impact x do good\"))%4) + 5;\r\n            gen1_block.widthInterval = 3000/gen1_block.numLevels;   \r\n            // retrieve color palette\r\n            string[4] memory palette = ColorPalettes[(_gen0block.colorGroupIndex * 8) + _gen0block.paletteIndex];    \r\n            gen1_block.palette = palette;\r\n        }\r\n        // get svg\r\n        gen1_block.svg = getGen1SVG(_tokenId, _tokenData, _gen0block, gen1_block);\r\n        // return gen-1 block\r\n        return gen1_block;\r\n    }\r\n    \r\n    // generate svg for gen-1 block\r\n    function getGen1SVG(uint256 _tokenId, IGBContract.TokenData memory _tokenData, IGen0Contract.GoodBlock memory _gen0Block,  Gen1Block memory _gen1Block) private view returns(string memory)\r\n    {\r\n        uint256 width;\r\n        uint256 shapeDesign;\r\n        uint256 tokenRand;\r\n        uint256 scale;\r\n        uint256 i;\r\n\r\n        // svg intro\r\n        string memory svg = string.concat(\r\n            readSvgPiece(1),\r\n            '<g id=\"art\"',\r\n            _gen0Block.symmetryIndex == 5 ? ' filter=\"url(#glitch)\">\\n\\n' : '>\\n\\n',\r\n            '<rect x=\"0\" y=\"0\" width=\"100%\" height=\"100%\" fill=\"',\r\n            _gen0Block.isDarkBlock ? '#000' : _gen1Block.palette[0],\r\n            '\"/>\\n\\n<g id=\"shapes\"',\r\n            _gen0Block.symmetryIndex == 5 ? ' filter=\"url(#noise)\">\\n\\n' : '>\\n\\n'\r\n        );\r\n\r\n        unchecked\r\n        {\r\n            do\r\n            {\r\n                // get random number\r\n                tokenRand = (_tokenId+13)*(i+1);\r\n                \r\n                // check if complexity is possible\r\n                if(_gen1Block.complexityLevel > 1  || i > 5)\r\n                {\r\n                    // get simpler shape\r\n                    shapeDesign = getShapeDesign(tokenRand, 150);\r\n                } else\r\n                {\r\n                    // get more complex shape\r\n                    shapeDesign = getShapeDesign(tokenRand, 300);\r\n                }\r\n\r\n                // update width\r\n                width = _gen1Block.widthInterval*(_gen1Block.numLevels-i);\r\n\r\n                // none\r\n                if(shapeDesign == 0)\r\n                {\r\n                    // nothing to see here folks!\r\n                    ++_gen1Block.noneCount;\r\n\r\n\r\n                // basic circle\r\n                } else if(shapeDesign == 1)\r\n                {\r\n                    // add to svg\r\n                    svg = string.concat(\r\n                        svg,\r\n                        '<g id=\"shapeGroup_',\r\n                        OZ.toString(i),\r\n                        '\" fill=\"',\r\n                        _gen0Block.isDarkBlock && (tokenRand % 13 == 0) ? \"#000\" : _gen1Block.palette[(tokenRand+1)%4],\r\n                        '\" stroke=\"',\r\n                        _gen1Block.palette[(tokenRand+2)%4],\r\n                        '\" stroke-width=\"50\">\\n',\r\n                        drawCircle(width/2),\r\n                        '</g>\\n\\n'\r\n                    );\r\n                    ++_gen1Block.circleCount;\r\n\r\n\r\n                // basic square\r\n                } else if(shapeDesign == 2)\r\n                {\r\n                    // add to svg\r\n                    svg = string.concat(\r\n                        svg,\r\n                        '<g id=\"shapeGroup_',\r\n                        OZ.toString(i),\r\n                        '\" fill=\"',\r\n                        _gen0Block.isDarkBlock && (tokenRand % 13 == 0) ? \"#000\" : _gen1Block.palette[(tokenRand+10)%4],\r\n                        '\" stroke=\"',\r\n                        _gen1Block.palette[(tokenRand+11)%4],\r\n                        '\" stroke-width=\"50\">\\n',\r\n                        drawSquare(width),\r\n                        '</g>\\n\\n'\r\n                    );\r\n                    ++_gen1Block.squareCount;\r\n\r\n\r\n                // repeated circle\r\n                } else if(shapeDesign == 3)\r\n                {\r\n                    // add to svg\r\n                    scale = (width*100)/(4000);\r\n                    svg = string.concat(\r\n                        svg,\r\n                        '<g id=\"shapeGroup_',\r\n                        OZ.toString(i),\r\n                        string.concat(\r\n                            '\" fill=\"',\r\n                            _gen0Block.isDarkBlock && (tokenRand % 13 == 0) ? \"#000\" : _gen1Block.palette[(tokenRand+3)%4],\r\n                            '\" stroke=\"',\r\n                            _gen1Block.palette[(tokenRand+4)%4]\r\n                            ),\r\n                        '\" stroke-width=\"10\" transform=\"translate(',\r\n                        string.concat(addDecimalFromTheRight(200000-2000*(scale), 2), ', ', addDecimalFromTheRight(200000-2000*(scale), 2))\r\n                    );\r\n                    svg = string.concat(\r\n                        svg,\r\n                        ') scale(',\r\n                        string.concat(addDecimalFromTheRight((scale), 2), ', ', addDecimalFromTheRight((scale), 2)),\r\n                        ')\" >\\n',\r\n                        getComplexShape((tokenRand)%12),\r\n                        '</g>\\n\\n'\r\n                    );\r\n                    // update counts\r\n                    ++_gen1Block.circleCount;\r\n                    ++_gen1Block.complexityLevel;\r\n\r\n\r\n                // repeated square\r\n                } else if(shapeDesign == 4)\r\n                {\r\n                    // add to svg\r\n                    scale = (width*100)/(4000);\r\n                    svg = string.concat(\r\n                        svg,\r\n                        '<g id=\"shapeGroup_',\r\n                        OZ.toString(i),\r\n                        string.concat(\r\n                            '\" fill=\"',\r\n                            _gen0Block.isDarkBlock && (tokenRand % 13 == 0) ? \"#000\" : _gen1Block.palette[(tokenRand+3)%4],\r\n                            '\" stroke=\"',\r\n                            _gen1Block.palette[(tokenRand+4)%4]\r\n                            ),\r\n                        '\" stroke-width=\"10\" transform=\"translate(',\r\n                        string.concat(addDecimalFromTheRight(200000-2000*(scale), 2), ', ', addDecimalFromTheRight(200000-2000*(scale), 2))\r\n                    );\r\n                    svg = string.concat(\r\n                        svg,\r\n                        ') scale(',\r\n                        string.concat(addDecimalFromTheRight((scale), 2), ', ', addDecimalFromTheRight((scale), 2)),\r\n                        ')\" >\\n',\r\n                        getComplexShape((tokenRand)%12),\r\n                        '</g>\\n\\n'\r\n                    );\r\n                    // update counts\r\n                    ++_gen1Block.squareCount;\r\n                    ++_gen1Block.complexityLevel;\r\n\r\n\r\n                // rotated square same\r\n                } else if(shapeDesign == 5)\r\n                {\r\n                    // add to svg\r\n                    scale = (width*100)/(4000);\r\n                    svg = string.concat(\r\n                        svg,\r\n                        '<g id=\"shapeGroup_',\r\n                        OZ.toString(i),\r\n                        string.concat(\r\n                            '\" fill=\"',\r\n                            _gen0Block.isDarkBlock && (tokenRand % 13 == 0) ? \"#000\" : _gen1Block.palette[(tokenRand+3)%4],\r\n                            '\" stroke=\"',\r\n                            _gen1Block.palette[(tokenRand+4)%4]\r\n                            ),\r\n                        '\" stroke-width=\"10\" transform=\"translate(',\r\n                        string.concat(addDecimalFromTheRight(200000-2000*(scale), 2), ', ', addDecimalFromTheRight(200000-2000*(scale), 2))\r\n                    );\r\n                    svg = string.concat(\r\n                        svg,\r\n                        ') scale(',\r\n                        string.concat(addDecimalFromTheRight((scale), 2), ', ', addDecimalFromTheRight((scale), 2)),\r\n                        ')\" >\\n',\r\n                        getComplexShape((tokenRand)%12),\r\n                        '</g>\\n\\n'\r\n                    );\r\n                    // update counts\r\n                    ++_gen1Block.squareCount;\r\n                    ++_gen1Block.complexityLevel;\r\n\r\n\r\n                //rotated square bi direction\r\n                } else if(shapeDesign == 6)\r\n                {\r\n                    // add to svg\r\n                    scale = (width*100)/(4000);\r\n                    svg = string.concat(\r\n                        svg,\r\n                        '<g id=\"shapeGroup_',\r\n                        OZ.toString(i),\r\n                        string.concat(\r\n                            '\" fill=\"',\r\n                            _gen0Block.isDarkBlock && (tokenRand % 13 == 0) ? \"#000\" : _gen1Block.palette[(tokenRand+7)%4],\r\n                            '\" stroke=\"',\r\n                            _gen1Block.palette[(tokenRand+8)%4]\r\n                            ),\r\n                        '\" stroke-width=\"10\" transform=\"translate(',\r\n                        string.concat(addDecimalFromTheRight(200000-2000*(scale), 2), ', ', addDecimalFromTheRight(200000-2000*(scale), 2))\r\n                    );\r\n                    svg = string.concat(\r\n                        svg,\r\n                        ') scale(',\r\n                        string.concat(addDecimalFromTheRight((scale), 2), ', ', addDecimalFromTheRight((scale), 2)),\r\n                        ')\" >\\n',\r\n                        getComplexShape(((tokenRand)%12)+12),\r\n                        '</g>\\n\\n'\r\n                    );\r\n                    // update counts\r\n                    ++_gen1Block.squareCount;\r\n                    ++_gen1Block.complexityLevel;\r\n                }\r\n                // iterate to next shape\r\n                ++i;\r\n\r\n            // continue until all levels are complete\r\n            } while (i<_gen1Block.numLevels);\r\n        }\r\n\r\n        // return final svg\r\n        return string.concat(\r\n            readSvgPiece(0),\r\n            getTokenDataString(_tokenId, _tokenData, _gen0Block, _gen1Block),\r\n            svg,\r\n            // end shapes group and add token name\r\n            readSvgPiece(2),\r\n            _gen0Block.symmetryIndex == 5 ? readSvgPiece(3) : '',\r\n            '\\n\\n</svg>' // close svg\r\n        );\r\n    }\r\n\r\n    // get metadata for gen-1 block\r\n    function blockToMetadata(IGBContract.TokenData memory _tokenData, IGen0Contract.GoodBlock memory _gen0Block, Gen1Block memory _gen1Block, string memory _tokenAttributes) private view returns(string memory)\r\n    {\r\n        // get attribute substring\r\n        string[2] memory ogAttributes = cleanAttributes(_tokenAttributes);\r\n        // begin metadata\r\n        string memory metadata = string.concat(\r\n            '{\"trait_type\": \"Generations Unlocked\", \"value\":',\r\n            OZ.toString(_tokenData.highestGenLevel+1),\r\n            '},{\"trait_type\": \"Active Generation\", \"value\":',\r\n            OZ.toString(_tokenData.activeGen),\r\n            '},{\"trait_type\": \"Times Transferred\", \"value\":\"',\r\n            ogAttributes[0],\r\n            '\"},{\"trait_type\": \"Owned Since\", \"value\":\"',\r\n            ogAttributes[1]\r\n        );\r\n        metadata = string.concat(\r\n            metadata,\r\n            '\"},{\"trait_type\": \"Color Group\", \"value\":\"',\r\n            ColorGroupNames[_gen0Block.colorGroupIndex],\r\n            '\"},{\"trait_type\": \"Palette Index\", \"value\":\"',\r\n            OZ.toString(_gen0Block.paletteIndex),\r\n\r\n            '{\"trait_type\": \"Shape Count\", \"value\":\"',\r\n            OZ.toString(_gen1Block.numLevels),\r\n            '\"},{\"trait_type\": \"Circle Count\", \"value\":\"',\r\n            OZ.toString(_gen1Block.circleCount),\r\n            '\"},{\"trait_type\": \"Square Count\", \"value\":\"',\r\n            OZ.toString(_gen1Block.squareCount),\r\n            '\"},{\"trait_type\": \"None Count\", \"value\":\"',\r\n            OZ.toString(_gen1Block.noneCount)\r\n        );\r\n        metadata = string.concat(\r\n            metadata,\r\n            '\"},{\"trait_type\": \"Complexity Level\", \"value\":\"',\r\n            OZ.toString(_gen1Block.complexityLevel),\r\n            '\"},{\"trait_type\": \"Glitchy\", \"value\":\"',\r\n            _gen0Block.symmetryIndex == 5 ? \"True\" : \"False\",\r\n            '\"},{\"trait_type\": \"Special Trait\", \"value\":\"',\r\n            _gen0Block.isDarkBlock ? 'Do Good\"}' : 'None\"}'\r\n        );\r\n        // return metadata string\r\n        return metadata;\r\n    }\r\n\r\n    // create token data string\r\n    function getTokenDataString(uint256 _tokenId, IGBContract.TokenData memory _tokenData, IGen0Contract.GoodBlock memory _gen0Block, Gen1Block memory _gen1Block) private view returns(string memory)\r\n    {\r\n        // create name\r\n        _gen1Block.name = string.concat(ColorGroupNames[_gen0Block.colorGroupIndex], ' #', OZ.toString(_tokenId));\r\n        // begin token data string for token\r\n        string memory tokenDataString = string.concat(\r\n            OZ.toString(_tokenId),\r\n            \"|\",\r\n            _gen1Block.name,\r\n            \"|\",\r\n            OZ.toHexString(_tokenData.tokenOwner),\r\n            \"|\",\r\n            OZ.toString(_tokenData.ownedSince),\r\n            \"|\",\r\n            OZ.toString(_tokenData.timesTransferred),\r\n            \"|\",\r\n            OZ.toString(_tokenData.highestGenLevel),\r\n            \"|\",\r\n            OZ.toString(_tokenData.activeGen),\r\n            \"|\",\r\n            ColorGroupNames[_gen0Block.colorGroupIndex],\r\n            \"|\",\r\n            OZ.toString(_gen0Block.paletteIndex),\r\n            \"|\"\r\n        );\r\n        tokenDataString = string.concat(\r\n            tokenDataString,\r\n            OZ.toString(_gen1Block.numLevels),\r\n            \"|\",\r\n            OZ.toString(_gen1Block.circleCount),\r\n            \"|\",\r\n            OZ.toString(_gen1Block.squareCount),\r\n            \"|\",\r\n            OZ.toString(_gen1Block.noneCount),\r\n            \"|\",\r\n            OZ.toString(_gen1Block.complexityLevel),\r\n            \"|\",\r\n            _gen0Block.symmetryIndex == 5 ? \"true\" : \"false\",\r\n            \"|\",\r\n            _gen0Block.isDarkBlock ? \"Do Good\" : \"None\",\r\n            \"|\",\r\n            _gen1Block.palette[0],\r\n            \"|\",\r\n            _gen1Block.palette[1],\r\n            \"|\",\r\n            _gen1Block.palette[2],\r\n            \"|\",\r\n            _gen1Block.palette[3]\r\n        );\r\n        // return token data string\r\n        return tokenDataString;\r\n    }\r\n\r\n    // determine shape design\r\n    function getShapeDesign(uint256 _seed, uint256 _limit) private pure returns(uint256)\r\n    {\r\n        // set shape weights\r\n        uint8[7] memory ShapeDesignWeights = [50, 50, 50, 15, 15, 60, 60];\r\n        // select a shape at random\r\n        unchecked\r\n        {\r\n            uint256 index = 0;\r\n            uint256 j = ShapeDesignWeights[0];\r\n            uint256 i = random(string.concat(\"its a good day\", OZ.toString(_seed*13), \"to have a good day\"))%_limit;\r\n            while (j <= i)\r\n            {\r\n                ++index;\r\n                j += ShapeDesignWeights[index];\r\n            }\r\n            return index;\r\n        }\r\n    }\r\n\r\n\r\n\r\n    /*\r\n        â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆ      â–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆ      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\r\n        â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ      â–ˆâ–ˆ â–ˆâ–ˆ             â–ˆâ–ˆ    â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆ      â–ˆâ–ˆ     \r\n        â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆ      â–ˆâ–ˆ â–ˆâ–ˆ             â–ˆâ–ˆ    â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆ      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\r\n        â–ˆâ–ˆ      â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ      â–ˆâ–ˆ â–ˆâ–ˆ             â–ˆâ–ˆ    â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆ           â–ˆâ–ˆ\r\n        â–ˆâ–ˆ       â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ        â–ˆâ–ˆ     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\r\n    */\r\n\r\n    // draw circle centered at (2000,2000)\r\n    function drawCircle(uint256 _radius) public pure returns(string memory)\r\n    {\r\n        return string.concat(\r\n            '<circle cx=\"2000\" cy=\"2000\" r=\"',\r\n            OZ.toString(_radius),\r\n            '\"/>\\n'\r\n        );\r\n    }\r\n\r\n    // draw circle centered at (2000,2000)\r\n    function drawSquare(uint256 _width) public pure returns(string memory)\r\n    {\r\n        uint256 o = 2000 - _width/2;\r\n        string memory outputSVG = string.concat(\r\n            '<rect x=\"',\r\n            OZ.toString(o),\r\n            '\" y=\"',\r\n            OZ.toString(o),\r\n            '\" width=\"',\r\n            OZ.toString(_width),\r\n            '\" height=\"',\r\n            OZ.toString(_width),\r\n            '\"/>\\n'\r\n        );\r\n        return outputSVG;\r\n    }\r\n\r\n    // add decimal number from the right\r\n    function addDecimalFromTheRight(uint256 _number, uint256 _sigFigs) public pure returns(string memory)\r\n    {\r\n        // get initial variables\r\n        string memory numString = OZ.toString(_number);\r\n        uint256 length = bytes(numString).length;\r\n        bytes memory decimal = new bytes(_sigFigs);\r\n\r\n        unchecked\r\n        {\r\n            // check if sig fig greater thant length (0 padded)\r\n            if(_sigFigs > length)\r\n            {\r\n                uint256 i = _sigFigs-length;\r\n                do\r\n                {\r\n                    if(i < _sigFigs-length)\r\n                    {\r\n                        decimal[i] = bytes(\"0\")[0];\r\n                    } else\r\n                    {\r\n                        decimal[i] = bytes(numString)[i-(_sigFigs-length)];\r\n                    }\r\n                    --i;\r\n                } while(i>0);\r\n                \r\n                decimal[0] = \"0\";\r\n                // return string\r\n                return string.concat(\"0\", \".\", string(decimal));\r\n\r\n            // sig figs is = length\r\n            } else if(_sigFigs == length)\r\n            {\r\n                // return string\r\n                return string.concat(\"0\", \".\", numString);\r\n            \r\n            // sig figs < length\r\n            } else\r\n            {\r\n                uint256 wholeIndex;\r\n                uint256 decimalIndex;\r\n                uint256 i;\r\n                bytes memory whole = new bytes(length-_sigFigs);\r\n                do\r\n                {\r\n                    if(i < length-_sigFigs)\r\n                    {\r\n                        whole[wholeIndex] = bytes(numString)[i];\r\n                        ++wholeIndex;\r\n                    } else\r\n                    {\r\n                        decimal[decimalIndex] = bytes(numString)[i];\r\n                        ++decimalIndex;\r\n                    }\r\n                    ++i;\r\n                } while(i<length);\r\n                \r\n                // return string\r\n                return string.concat(string(whole), \".\", string(decimal));\r\n            }   \r\n        }\r\n    }\r\n\r\n    // get random number back\r\n    function random(string memory _input) public pure returns (uint256)\r\n    {\r\n        return uint256(keccak256(abi.encodePacked(_input)));\r\n    }\r\n\r\n    // attribute data\r\n    struct AttData\r\n    {\r\n        uint256 ownedStart;\r\n        uint256 ownedEnd;\r\n        uint256 ownedLength;\r\n        uint256 transferStart;\r\n        uint256 transferEnd;\r\n        uint256 transferLength;\r\n    }\r\n\r\n    // funciton clean original attributes\r\n    function cleanAttributes(string memory _attributes) public pure returns(string[2] memory)\r\n    {\r\n        uint256 i;\r\n        bytes memory attBytes = bytes(_attributes);\r\n        AttData memory attData;\r\n        // get time owned attribute\r\n        attData.ownedEnd = attBytes.length-3;\r\n        for(i=attData.ownedEnd; i>0; --i)\r\n        {\r\n            if(attBytes[i] == bytes1('\"'))\r\n            {\r\n                attData.ownedStart = i+1;\r\n                attData.ownedLength = (attData.ownedEnd-attData.ownedStart+1);\r\n                break;\r\n            }\r\n        }\r\n        // get times transfrerred attribute\r\n        attData.transferEnd = attData.ownedStart-43;\r\n        for(i=attData.transferEnd; i>0; --i)\r\n        {\r\n            if(attBytes[i] == bytes1('\"'))\r\n            {\r\n                attData.transferStart = i+1;\r\n                attData.transferLength = (attData.transferEnd-attData.transferStart+1);\r\n                break;\r\n            }            \r\n        }\r\n\r\n        bytes memory timesTransferredBytes = new bytes(attData.transferLength);\r\n        bytes memory ownedSinceBytes = new bytes(attData.ownedLength);\r\n        \r\n        for(i=0; i<attData.transferLength; i++)\r\n        {\r\n            timesTransferredBytes[i] = attBytes[attData.transferStart + i];\r\n        }\r\n        \r\n        for(i=0; i<attData.ownedLength; i++)\r\n        {\r\n            ownedSinceBytes[i] = attBytes[attData.ownedStart + i];\r\n        }\r\n\r\n        // return attributes\r\n        return [string(timesTransferredBytes), string(ownedSinceBytes)];\r\n    }\r\n\r\n\r\n\r\n    /*\r\n\r\n        â–ˆâ–ˆ â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ \r\n        â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆ    â–ˆâ–ˆ    â–ˆâ–ˆ      â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ      â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ      â–ˆâ–ˆ          â–ˆâ–ˆ         â–ˆâ–ˆ    â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆ      â–ˆâ–ˆ      \r\n        â–ˆâ–ˆ â–ˆâ–ˆ â–ˆâ–ˆ  â–ˆâ–ˆ    â–ˆâ–ˆ    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆ      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ       â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ    â–ˆâ–ˆ    â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   \r\n        â–ˆâ–ˆ â–ˆâ–ˆ  â–ˆâ–ˆ â–ˆâ–ˆ    â–ˆâ–ˆ    â–ˆâ–ˆ      â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ      â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ      â–ˆâ–ˆ               â–ˆâ–ˆ    â–ˆâ–ˆ    â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆ      â–ˆâ–ˆ      \r\n        â–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆâ–ˆâ–ˆ    â–ˆâ–ˆ    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ      â–ˆâ–ˆ   â–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ    â–ˆâ–ˆ     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆ      â–ˆâ–ˆ\r\n\r\n    */\r\n\r\n    // interface contracts\r\n    IGBContract private GBTokenContract = IGBContract(address(0x29B4Ea6B1164C7cd8A3a0a1dc4ad88d1E0589124));\r\n    IGen0Contract private Gen0Contract = IGen0Contract(address(0xAd77f8106d1E4891be0428133f35F78977671F2F));\r\n    \r\n    // set contract addresses\r\n    function setInterfaceAddresses(address[2] memory _newAddresses) external onlyOwner\r\n    {\r\n        GBTokenContract = IGBContract(_newAddresses[0]);\r\n        Gen0Contract = IGen0Contract(_newAddresses[1]);    \r\n    } \r\n\r\n\r\n\r\n    /*\r\n  \r\n         â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆ     â–ˆâ–ˆ â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ \r\n        â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆ     â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ      â–ˆâ–ˆ   â–ˆâ–ˆ     â–ˆâ–ˆ      â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ    â–ˆâ–ˆâ–ˆ  \r\n        â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆ  â–ˆ  â–ˆâ–ˆ â–ˆâ–ˆ â–ˆâ–ˆ  â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆâ–ˆ   \r\n        â–ˆâ–ˆ    â–ˆâ–ˆ â–ˆâ–ˆ â–ˆâ–ˆâ–ˆ â–ˆâ–ˆ â–ˆâ–ˆ  â–ˆâ–ˆ â–ˆâ–ˆ â–ˆâ–ˆ      â–ˆâ–ˆ   â–ˆâ–ˆ          â–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ  â–ˆâ–ˆâ–ˆ    \r\n         â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆ  â–ˆâ–ˆ   â–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆ     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\r\n  \r\n    */\r\n\r\n    // construct that thing\r\n    constructor()\r\n    {\r\n        ContractOwner = msg.sender;\r\n    }\r\n\r\n    // contract owner \r\n    address private ContractOwner;\r\n\r\n    // only owner modifier\r\n    function _onlyOwner() private view\r\n    {\r\n        if(msg.sender != ContractOwner) revert YoureNotTheOwnerHomie();\r\n    }\r\n    modifier onlyOwner()\r\n    {\r\n        _onlyOwner();\r\n        _;\r\n    }\r\n\r\n    // transfer contract ownership\r\n    function transferOwnership(address _newOwner) external onlyOwner\r\n    {\r\n        ContractOwner = _newOwner;\r\n    }\r\n\r\n    // if youre reading this, make a goodblocks collage with all our tokens\r\n}\r\n\r\n\r\n// interface for the goodblocks contract\r\ninterface IGBContract\r\n{\r\n    struct TokenData\r\n    {\r\n        uint8 activeGen;\r\n        uint8 highestGenLevel;\r\n        uint64 timesTransferred;\r\n        uint64 ownedSince;\r\n        address tokenOwner;\r\n    }\r\n    function ownerOf(uint256 _tokenId) external view returns(address);\r\n    function getTokenData(uint256 _tokenId) external view returns (TokenData memory);\r\n}\r\n\r\n// interface for the gen-0 contract\r\ninterface IGen0Contract\r\n{\r\n    struct GoodBlock\r\n    {\r\n        uint8 pixelSizeIndex;\r\n        uint8 symmetryIndex;\r\n        uint8 colorGroupIndex;\r\n        uint8 paletteIndex;\r\n        bool isDarkBlock; \r\n        uint16 tokenIndex;\r\n        bytes3 labelColor;\r\n        string blockDNA;\r\n    }\r\n    \r\n    function tokenToGoodblock(uint256 _tokenId) external view returns(GoodBlock memory);\r\n}\r\n\r\n\r\n\r\n/*\r\n\r\n        â–ˆâ–ˆ      â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ \r\n        â–ˆâ–ˆ      â–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ â–ˆâ–ˆ      â–ˆâ–ˆ      \r\n        â–ˆâ–ˆ      â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ \r\n        â–ˆâ–ˆ      â–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ â–ˆâ–ˆ           â–ˆâ–ˆ \r\n        â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ   â–ˆâ–ˆ â–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\r\n\r\n        using OpenZeppelin Strings and Base64 contracts\r\n\r\n    */\r\n\r\nlibrary OZ\r\n{\r\n    // OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\r\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\r\n    uint8 private constant _ADDRESS_LENGTH = 20;\r\n    /**\r\n     * @dev Return the log in base 10, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value) internal pure returns (uint256)\r\n    {\r\n        uint256 result = 0;\r\n        unchecked\r\n        {\r\n            if (value >= 10**64)\r\n            {\r\n                value /= 10**64;\r\n                result += 64;\r\n            }\r\n            if (value >= 10**32)\r\n            {\r\n                value /= 10**32;\r\n                result += 32;\r\n            }\r\n            if (value >= 10**16)\r\n            {\r\n                value /= 10**16;\r\n                result += 16;\r\n            }\r\n            if (value >= 10**8)\r\n            {\r\n                value /= 10**8;\r\n                result += 8;\r\n            }\r\n            if (value >= 10**4)\r\n            {\r\n                value /= 10**4;\r\n                result += 4;\r\n            }\r\n            if (value >= 10**2)\r\n            {\r\n                value /= 10**2;\r\n                result += 2;\r\n            }\r\n            if (value >= 10**1)\r\n            {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory)\r\n    {\r\n        unchecked\r\n        {\r\n            uint256 length = log10(value) + 1;\r\n            string memory buffer = new string(length);\r\n            uint256 ptr;\r\n            /// @solidity memory-safe-assembly\r\n            assembly\r\n            {\r\n                ptr := add(buffer, add(32, length))\r\n            }\r\n            while (true)\r\n            {\r\n                ptr--;\r\n                /// @solidity memory-safe-assembly\r\n                assembly\r\n                {\r\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\r\n                }\r\n                value /= 10;\r\n                if (value == 0) break;\r\n            }\r\n            return buffer;\r\n        }\r\n    }\r\n    /**\r\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(address addr) internal pure returns (string memory)\r\n    {\r\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\r\n    }\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory)\r\n    {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i)\r\n        {\r\n            buffer[i] = _SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n\r\n\r\n    // OpenZeppelin Contracts (last updated v4.7.0) (utils/Base64.sol)\r\n    /**\r\n     * @dev Base64 Encoding/Decoding Table\r\n     */\r\n    string internal constant _TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\r\n    /**\r\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\r\n     */\r\n    function encode(bytes memory data) internal pure returns (string memory)\r\n    {\r\n        /**\r\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\r\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\r\n         */\r\n        if (data.length == 0) return \"\";\r\n\r\n        // Loads the table into memory\r\n        string memory table = _TABLE;\r\n\r\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\r\n        // and split into 4 numbers of 6 bits.\r\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\r\n        // - `data.length + 2`  -> Round up\r\n        // - `/ 3`              -> Number of 3-bytes chunks\r\n        // - `4 *`              -> 4 characters for each chunk\r\n        string memory result = new string(4 * ((data.length + 2) / 3));\r\n\r\n        /// @solidity memory-safe-assembly\r\n        assembly\r\n        {\r\n            // Prepare the lookup table (skip the first \"length\" byte)\r\n            let tablePtr := add(table, 1)\r\n\r\n            // Prepare result pointer, jump over length\r\n            let resultPtr := add(result, 32)\r\n\r\n            // Run over the input, 3 bytes at a time\r\n            for\r\n            {\r\n                let dataPtr := data\r\n                let endPtr := add(data, mload(data))\r\n            } lt(dataPtr, endPtr)\r\n            {\r\n\r\n            }\r\n            {\r\n                // Advance 3 bytes\r\n                dataPtr := add(dataPtr, 3)\r\n                let input := mload(dataPtr)\r\n\r\n                // To write each character, shift the 3 bytes (18 bits) chunk\r\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\r\n                // and apply logical AND with 0x3F which is the number of\r\n                // the previous character in the ASCII table prior to the Base64 Table\r\n                // The result is then added to the table to get the character to write,\r\n                // and finally write it in the result pointer but with a left shift\r\n                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\r\n\r\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\r\n                resultPtr := add(resultPtr, 1) // Advance\r\n\r\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\r\n                resultPtr := add(resultPtr, 1) // Advance\r\n\r\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\r\n                resultPtr := add(resultPtr, 1) // Advance\r\n\r\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\r\n                resultPtr := add(resultPtr, 1) // Advance\r\n            }\r\n\r\n            // When data `bytes` is not exactly 3 bytes long\r\n            // it is padded with `=` characters at the end\r\n            switch mod(mload(data), 3)\r\n            case 1\r\n            {\r\n                mstore8(sub(resultPtr, 1), 0x3d)\r\n                mstore8(sub(resultPtr, 2), 0x3d)\r\n            }\r\n            case 2\r\n            {\r\n                mstore8(sub(resultPtr, 1), 0x3d)\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}"

    },

    "contracts/SSTORE2.sol": {

      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./Bytecode.sol\";\r\n\r\n/**\r\n  @title A key-value storage with auto-generated keys for storing chunks of data with a lower write & read cost.\r\n  @author Agustin Aguilar <aa@horizon.io>\r\n\r\n  Readme: https://github.com/0xsequence/sstore2#readme\r\n*/\r\nlibrary SSTORE2 {\r\n  error WriteError();\r\n\r\n  /**\r\n    @notice Stores `_data` and returns `pointer` as key for later retrieval\r\n    @dev The pointer is a contract address with `_data` as code\r\n    @param _data to be written\r\n    @return pointer Pointer to the written `_data`\r\n  */\r\n  function write(bytes memory _data) internal returns (address pointer) {\r\n    // Append 00 to _data so contract can't be called\r\n    // Build init code\r\n    bytes memory code = Bytecode.creationCodeFor(\r\n      abi.encodePacked(\r\n        hex'00',\r\n        _data\r\n      )\r\n    );\r\n\r\n    // Deploy contract using create\r\n    assembly { pointer := create(0, add(code, 32), mload(code)) }\r\n\r\n    // Address MUST be non-zero\r\n    if (pointer == address(0)) revert WriteError();\r\n  }\r\n\r\n  /**\r\n    @notice Reads the contents of the `_pointer` code as data, skips the first byte \r\n    @dev The function is intended for reading pointers generated by `write`\r\n    @param _pointer to be read\r\n    @return data read from `_pointer` contract\r\n  */\r\n  function read(address _pointer) internal view returns (bytes memory) {\r\n    return Bytecode.codeAt(_pointer, 1, type(uint256).max);\r\n  }\r\n\r\n  /**\r\n    @notice Reads the contents of the `_pointer` code as data, skips the first byte \r\n    @dev The function is intended for reading pointers generated by `write`\r\n    @param _pointer to be read\r\n    @param _start number of bytes to skip\r\n    @return data read from `_pointer` contract\r\n  */\r\n  function read(address _pointer, uint256 _start) internal view returns (bytes memory) {\r\n    return Bytecode.codeAt(_pointer, _start + 1, type(uint256).max);\r\n  }\r\n\r\n  /**\r\n    @notice Reads the contents of the `_pointer` code as data, skips the first byte \r\n    @dev The function is intended for reading pointers generated by `write`\r\n    @param _pointer to be read\r\n    @param _start number of bytes to skip\r\n    @param _end index before which to end extraction\r\n    @return data read from `_pointer` contract\r\n  */\r\n  function read(address _pointer, uint256 _start, uint256 _end) internal view returns (bytes memory) {\r\n    return Bytecode.codeAt(_pointer, _start + 1, _end + 1);\r\n  }\r\n}"

    }

  },

  "settings": {

    "optimizer": {

      "enabled": false,

      "runs": 200

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "libraries": {}

  }

}}