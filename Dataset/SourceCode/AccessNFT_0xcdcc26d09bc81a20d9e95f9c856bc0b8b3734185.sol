{{

  "language": "Solidity",

  "sources": {

    "@openzeppelin/contracts/access/IAccessControl.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"

    },

    "@openzeppelin/contracts/token/ERC1155/ERC1155.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner or approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner or approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `ids` and `amounts` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"

    },

    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"

    },

    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"

    },

    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"

    },

    "@openzeppelin/contracts/utils/Address.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/Context.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"

    },

    "contracts/interfaces/IAccessManager.sol": {

      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.10;\r\n\r\nimport {IAddressesRegistry} from \"./IAddressesRegistry.sol\";\r\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\r\n\r\n/**\r\n * @title IAccessManager\r\n * @author Souq.Finance\r\n * @notice The interface for the Access Manager Contract\r\n * @notice License: https://souq-peripheral-v1.s3.amazonaws.com/LICENSE.md\r\n */\r\ninterface IAccessManager is IAccessControl {\r\n    \r\n    /**\r\n     * @notice Returns the contract address of the PoolAddressesProvider\r\n     * @return The address of the PoolAddressesProvider\r\n     */\r\n    function ADDRESSES_PROVIDER() external view returns (IAddressesRegistry);\r\n\r\n    /**\r\n     * @notice Returns the identifier of the Pool Operations role\r\n     * @return The id of the Pool Operations role\r\n     */\r\n    function POOL_OPERATIONS_ROLE() external view returns (bytes32);\r\n\r\n    /**\r\n     * @notice Returns the identifier of the PoolAdmin role\r\n     * @return The id of the PoolAdmin role\r\n     */\r\n    function POOL_ADMIN_ROLE() external view returns (bytes32);\r\n\r\n    /**\r\n     * @notice Returns the identifier of the EmergencyAdmin role\r\n     * @return The id of the EmergencyAdmin role\r\n     */\r\n    function EMERGENCY_ADMIN_ROLE() external view returns (bytes32);\r\n\r\n    /**\r\n     * @notice Returns the identifier of the OracleAdmin role\r\n     * @return The id of the Oracle role\r\n     */\r\n    function ORACLE_ADMIN_ROLE() external view returns (bytes32);\r\n\r\n    /**\r\n     * @notice Returns the identifier of the ConnectorRouterAdmin role\r\n     * @return The id of the ConnectorRouterAdmin role\r\n     */\r\n    function CONNECTOR_ROUTER_ADMIN_ROLE() external view returns (bytes32);\r\n\r\n    /**\r\n     * @notice Returns the identifier of the StablecoinYieldConnectorAdmin role\r\n     * @return The id of the StablecoinYieldConnectorAdmin role\r\n     */\r\n    function STABLECOIN_YIELD_CONNECTOR_ADMIN_ROLE() external view returns (bytes32);\r\n\r\n    /**\r\n     * @notice Returns the identifier of the StablecoinYieldConnectorLender role\r\n     * @return The id of the StablecoinYieldConnectorLender role\r\n     */\r\n    function STABLECOIN_YIELD_CONNECTOR_LENDER_ROLE() external view returns (bytes32);\r\n\r\n    /**\r\n     * @notice Returns the identifier of the UpgraderAdmin role\r\n     * @return The id of the UpgraderAdmin role\r\n     */\r\n\r\n    function UPGRADER_ADMIN_ROLE() external view returns (bytes32);\r\n\r\n    /**\r\n     * @notice Returns the identifier of the TimelockAdmin role\r\n     * @return The id of the TimelockAdmin role\r\n     */\r\n\r\n    function TIMELOCK_ADMIN_ROLE() external view returns (bytes32);\r\n\r\n    /**\r\n     * @dev set the default admin for the contract\r\n     * @param newAdmin The new default admin address\r\n     */\r\n    function changeDefaultAdmin(address newAdmin) external;\r\n    \r\n    /**\r\n     * @dev return the version of the contract\r\n     * @return the version of the contract\r\n     */\r\n    function getVersion() external pure returns (uint256);\r\n    /**\r\n     * @notice Set the role as admin of a specific role.\r\n     * @dev By default the admin role for all roles is `DEFAULT_ADMIN_ROLE`.\r\n     * @param role The role to be managed by the admin role\r\n     * @param adminRole The admin role\r\n     */\r\n\r\n    function setRoleAdmin(bytes32 role, bytes32 adminRole) external;\r\n\r\n    /**\r\n     * @notice Adds a new admin as PoolAdmin\r\n     * @param admin The address of the new admin\r\n     */\r\n    function addPoolAdmin(address admin) external;\r\n\r\n    /**\r\n     * @notice Removes an admin as PoolAdmin\r\n     * @param admin The address of the admin to remove\r\n     */\r\n    function removePoolAdmin(address admin) external;\r\n\r\n    /**\r\n     * @notice Returns true if the address is PoolAdmin, false otherwise\r\n     * @param admin The address to check\r\n     * @return True if the given address is PoolAdmin, false otherwise\r\n     */\r\n    function isPoolAdmin(address admin) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Adds a new admin as Pool Operations\r\n     * @param admin The address of the new admin\r\n     */\r\n    function addPoolOperations(address admin) external;\r\n\r\n    /**\r\n     * @notice Removes an admin as Pool Operations\r\n     * @param admin The address of the admin to remove\r\n     */\r\n    function removePoolOperations(address admin) external;\r\n\r\n    /**\r\n     * @notice Returns true if the address is Pool Operations, false otherwise\r\n     * @param admin The address to check\r\n     * @return True if the given address is Pool Operations, false otherwise\r\n     */\r\n    function isPoolOperations(address admin) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Adds a new admin as EmergencyAdmin\r\n     * @param admin The address of the new admin\r\n     */\r\n    function addEmergencyAdmin(address admin) external;\r\n\r\n    /**\r\n     * @notice Removes an admin as EmergencyAdmin\r\n     * @param admin The address of the admin to remove\r\n     */\r\n    function removeEmergencyAdmin(address admin) external;\r\n\r\n    /**\r\n     * @notice Returns true if the address is EmergencyAdmin, false otherwise\r\n     * @param admin The address to check\r\n     * @return True if the given address is EmergencyAdmin, false otherwise\r\n     */\r\n    function isEmergencyAdmin(address admin) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Adds a new admin as OracleAdmin\r\n     * @param admin The address of the new admin\r\n     */\r\n    function addOracleAdmin(address admin) external;\r\n\r\n    /**\r\n     * @notice Removes an admin as OracleAdmin\r\n     * @param admin The address of the admin to remove\r\n     */\r\n    function removeOracleAdmin(address admin) external;\r\n\r\n    /**\r\n     * @notice Returns true if the address is OracleAdmin, false otherwise\r\n     * @param admin The address to check\r\n     * @return True if the given address is OracleAdmin, false otherwise\r\n     */\r\n    function isOracleAdmin(address admin) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Adds a new admin as ConnectorRouterAdmin\r\n     * @param admin The address of the new admin\r\n     */\r\n    function addConnectorAdmin(address admin) external;\r\n\r\n    /**\r\n     * @notice Removes an admin as ConnectorRouterAdmin\r\n     * @param admin The address of the admin to remove\r\n     */\r\n    function removeConnectorAdmin(address admin) external;\r\n\r\n    /**\r\n     * @notice Returns true if the address is ConnectorRouterAdmin, false otherwise\r\n     * @param admin The address to check\r\n     * @return True if the given address is ConnectorRouterAdmin, false otherwise\r\n     */\r\n    function isConnectorAdmin(address admin) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Adds a new admin as StablecoinYieldConnectorAdmin\r\n     * @param admin The address of the new admin\r\n     */\r\n    function addStablecoinYieldAdmin(address admin) external;\r\n\r\n    /**\r\n     * @notice Removes an admin as StablecoinYieldConnectorAdmin\r\n     * @param admin The address of the admin to remove\r\n     */\r\n    function removeStablecoinYieldAdmin(address admin) external;\r\n\r\n    /**\r\n     * @notice Returns true if the address is StablecoinYieldConnectorAdmin, false otherwise\r\n     * @param admin The address to check\r\n     * @return True if the given address is StablecoinYieldConnectorAdmin, false otherwise\r\n     */\r\n    function isStablecoinYieldAdmin(address admin) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Adds a new admin as StablecoinYieldLender\r\n     * @param lender The address of the new lender\r\n     */\r\n    function addStablecoinYieldLender(address lender) external;\r\n\r\n    /**\r\n     * @notice Removes an lender as StablecoinYieldLender\r\n     * @param lender The address of the lender to remove\r\n     */\r\n    function removeStablecoinYieldLender(address lender) external;\r\n\r\n    /**\r\n     * @notice Returns true if the address is StablecoinYieldLender, false otherwise\r\n     * @param lender The address to check\r\n     * @return True if the given address is StablecoinYieldLender, false otherwise\r\n     */\r\n    function isStablecoinYieldLender(address lender) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Adds a new admin as UpgraderAdmin\r\n     * @param admin The address of the new admin\r\n     */\r\n    function addUpgraderAdmin(address admin) external;\r\n\r\n    /**\r\n     * @notice Removes an admin as UpgraderAdmin\r\n     * @param admin The address of the admin to remove\r\n     */\r\n    function removeUpgraderAdmin(address admin) external;\r\n\r\n    /**\r\n     * @notice Returns true if the address is UpgraderAdmin, false otherwise\r\n     * @param admin The address to check\r\n     * @return True if the given address is UpgraderAdmin, false otherwise\r\n     */\r\n    function isUpgraderAdmin(address admin) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Adds a new admin as TimelockAdmin\r\n     * @param admin The address of the new admin\r\n     */\r\n    function addTimelockAdmin(address admin) external;\r\n\r\n    /**\r\n     * @notice Removes an admin as TimelockAdmin\r\n     * @param admin The address of the admin to remove\r\n     */\r\n    function removeTimelockAdmin(address admin) external;\r\n\r\n    /**\r\n     * @notice Returns true if the address is TimelockAdmin, false otherwise\r\n     * @param admin The address to check\r\n     * @return True if the given address is TimelockAdmin, false otherwise\r\n     */\r\n    function isTimelockAdmin(address admin) external view returns (bool);\r\n}\r\n"

    },

    "contracts/interfaces/IAccessNFT.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0\r\npragma solidity 0.8.10;\r\n\r\n/**\r\n * @title IAccessNFT\r\n * @author Souq.Finance\r\n * @notice Defines the interface of the Access NFT contract\r\n * @notice License: https://souq-peripheral-v1.s3.amazonaws.com/LICENSE.md\r\n */\r\ninterface IAccessNFT {\r\n    /**\r\n     * @dev Event emitted wjem deadline for the function name and token id combination is set\r\n     * @param functionName The function name in bytes32\r\n     * @param deadline The deadline is seconds\r\n     * @param tokenId The token id\r\n     */\r\n    event DeadlineSet(string functionName, bytes32 functionHash, uint256 deadline, uint256 tokenId);\r\n\r\n    /**\r\n     * @dev event emitted when the use of deadlines in the contract is toggled\r\n     * @param deadlinesOn The flag returned (true=turned on)\r\n     */\r\n    event ToggleDeadlines(bool deadlinesOn);\r\n\r\n    /**\r\n     * @dev Checks if a user has access to a specific function based on ownership of NFTs. If current time > deadline of the function and token id combination\r\n     * @param user The address of the user\r\n     * @param tokenId The token id\r\n     * @param functionName The function name\r\n     * @return bool The boolean (true = has nft)\r\n     */\r\n    function HasAccessNFT(address user, uint256 tokenId, string calldata functionName) external view returns (bool);\r\n    /**\r\n     * @dev Sets the deadline for a specific function and token id (NFT)\r\n     * @param functionName The function name\r\n     * @param deadline The new deadline\r\n     * @param tokenId The token id\r\n     */\r\n    function setDeadline(string calldata functionName, uint256 deadline, uint256 tokenId) external;\r\n    /**\r\n     * @dev Retrieves the deadline for a specific function and NFT.\r\n     * @param hashedFunctionName The hashed function name\r\n     * @param tokenId The token id\r\n     * @return deadline The deadline\r\n     */\r\n    function getDeadline(bytes32 hashedFunctionName, uint256 tokenId) external view returns (uint256);\r\n    /**\r\n     * @dev Toggles the state of deadlines for function access.\r\n     */\r\n    function toggleDeadlines() external;\r\n    /**\r\n     * @dev Sets the fee discount percentage for a specific NFT\r\n     * @param tokenId The token id\r\n     * @param discount The discount in wei\r\n     */\r\n    function setFeeDiscount(uint256 tokenId, uint256 discount) external;\r\n    /**\r\n     * @dev Sets the URI for the token metadata\r\n     * @param newuri The token id\r\n     */\r\n    function setURI(string memory newuri) external;\r\n    /**\r\n     * @dev Burns a specific amount of tokens owned by an account\r\n     * @param account The account to burn from\r\n     * @param id The token id\r\n     * @param amount The amount to burn\r\n     */\r\n    function adminBurn(address account, uint256 id, uint256 amount) external;\r\n}\r\n"

    },

    "contracts/interfaces/IAddressesRegistry.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0\r\npragma solidity 0.8.10;\r\n\r\n/**\r\n * @title IAddressesRegistry\r\n * @author Souq.Finance\r\n * @notice Defines the interface of the addresses registry.\r\n * @notice License: https://souq-peripheral-v1.s3.amazonaws.com/LICENSE.md\r\n */\r\n \r\ninterface IAddressesRegistry {\r\n    /**\r\n     * @dev Emitted when the connectors router address is updated.\r\n     * @param oldAddress The old address\r\n     * @param newAddress The new address\r\n     */\r\n    event RouterUpdated(address indexed oldAddress, address indexed newAddress);\r\n    /**\r\n     * @dev Emitted when the Access manager address is updated.\r\n     * @param oldAddress The old address\r\n     * @param newAddress The new address\r\n     */\r\n    event AccessManagerUpdated(address indexed oldAddress, address indexed newAddress);\r\n    /**\r\n     * @dev Emitted when the access admin address is updated.\r\n     * @param oldAddress The old address\r\n     * @param newAddress The new address\r\n     */\r\n    event AccessAdminUpdated(address indexed oldAddress, address indexed newAddress);\r\n\r\n    /**\r\n     * @dev Emitted when the collection connector address is updated.\r\n     * @param oldAddress the old address\r\n     * @param newAddress the new address\r\n     */\r\n    event CollectionConnectorUpdated(address indexed oldAddress, address indexed newAddress);\r\n\r\n    /**\r\n     * @dev Emitted when a specific pool factory address is updated.\r\n     * @param id The short id of the pool factory.\r\n     * @param oldAddress The old address\r\n     * @param newAddress The new address\r\n     */\r\n\r\n    event PoolFactoryUpdated(bytes32 id, address indexed oldAddress, address indexed newAddress);\r\n    /**\r\n     * @dev Emitted when a specific pool factory address is added.\r\n     * @param id The short id of the pool factory.\r\n     * @param newAddress The new address\r\n     */\r\n    event PoolFactoryAdded(bytes32 id, address indexed newAddress);\r\n    /**\r\n     * @dev Emitted when a specific vault factory address is updated.\r\n     * @param id The short id of the vault factory.\r\n     * @param oldAddress The old address\r\n     * @param newAddress The new address\r\n     */\r\n    event VaultFactoryUpdated(bytes32 id, address indexed oldAddress, address indexed newAddress);\r\n    /**\r\n     * @dev Emitted when a specific vault factory address is added.\r\n     * @param id The short id of the vault factory.\r\n     * @param newAddress The new address\r\n     */\r\n    event VaultFactoryAdded(bytes32 id, address indexed newAddress);\r\n    /**\r\n     * @dev Emitted when a any address is updated.\r\n     * @param id The full id of the address.\r\n     * @param oldAddress The old address\r\n     * @param newAddress The new address\r\n     */\r\n    event AddressUpdated(bytes32 id, address indexed oldAddress, address indexed newAddress);\r\n\r\n    /**\r\n     * @dev Emitted when a proxy is deployed for an implementation\r\n     * @param id The full id of the address to be saved\r\n     * @param logic The address of the implementation\r\n     * @param proxy The address of the proxy deployed in that id slot\r\n     */\r\n    event ProxyDeployed(bytes32 id, address indexed logic, address indexed proxy);\r\n\r\n    /**\r\n     * @dev Emitted when a proxy is deployed for an implementation\r\n     * @param id The full id of the address to be upgraded\r\n     * @param newLogic The address of the new implementation\r\n     * @param proxy The address of the proxy that was upgraded\r\n     */\r\n    event ProxyUpgraded(bytes32 id, address indexed newLogic, address indexed proxy);\r\n\r\n    /**\r\n     * @notice Returns the address of the identifier.\r\n     * @param _id The id of the contract\r\n     * @return The Pool proxy address\r\n     */\r\n    function getAddress(bytes32 _id) external view returns (address);\r\n\r\n    /**\r\n     * @notice Sets the address of the identifier.\r\n     * @param _id The id of the contract\r\n     * @param _add The address to set\r\n     */\r\n    function setAddress(bytes32 _id, address _add) external;\r\n\r\n    /**\r\n     * @notice Returns the address of the connectors router defined as: CONNECTORS_ROUTER\r\n     * @return The address\r\n     */\r\n    function getConnectorsRouter() external view returns (address);\r\n\r\n    /**\r\n     * @notice Sets the address of the Connectors router.\r\n     * @param _add The address to set\r\n     */\r\n    function setConnectorsRouter(address _add) external;\r\n\r\n    /**\r\n     * @notice Returns the address of access manager defined as: ACCESS_MANAGER\r\n     * @return The address\r\n     */\r\n    function getAccessManager() external view returns (address);\r\n\r\n    /**\r\n     * @notice Sets the address of the Access Manager.\r\n     * @param _add The address to set\r\n     */\r\n    function setAccessManager(address _add) external;\r\n\r\n    /**\r\n     * @notice Returns the address of access admin defined as: ACCESS_ADMIN\r\n     * @return The address\r\n     */\r\n    function getAccessAdmin() external view returns (address);\r\n\r\n    /**\r\n     * @notice Sets the address of the Access Admin.\r\n     * @param _add The address to set\r\n     */\r\n    function setAccessAdmin(address _add) external;\r\n\r\n    /**\r\n     * @notice Returns the address of the specific pool factory short id\r\n     * @param _id The pool factory id such as \"SVS\"\r\n     * @return The address\r\n     */\r\n    function getPoolFactoryAddress(bytes32 _id) external view returns (address);\r\n\r\n    /**\r\n     * @notice Returns the full id of pool factory short id\r\n     * @param _id The pool factory id such as \"SVS\"\r\n     * @return The full id\r\n     */\r\n    function getIdFromPoolFactory(bytes32 _id) external view returns (bytes32);\r\n\r\n    /**\r\n     * @notice Sets the address of a specific pool factory using short id.\r\n     * @param _id the pool factory short id\r\n     * @param _add The address to set\r\n     */\r\n    function setPoolFactory(bytes32 _id, address _add) external;\r\n\r\n    /**\r\n     * @notice adds a new pool factory with address and short id. The short id will be converted to full id and saved.\r\n     * @param _id the pool factory short id\r\n     * @param _add The address to add\r\n     */\r\n    function addPoolFactory(bytes32 _id, address _add) external;\r\n\r\n    /**\r\n     * @notice Returns the address of the specific vault factory short id\r\n     * @param _id The vault id such as \"SVS\"\r\n     * @return The address\r\n     */\r\n    function getVaultFactoryAddress(bytes32 _id) external view returns (address);\r\n\r\n    /**\r\n     * @notice Returns the full id of vault factory id\r\n     * @param _id The vault factory id such as \"SVS\"\r\n     * @return The full id\r\n     */\r\n    function getIdFromVaultFactory(bytes32 _id) external view returns (bytes32);\r\n\r\n    /**\r\n     * @notice Sets the address of a specific vault factory using short id.\r\n     * @param _id the vault factory short id\r\n     * @param _add The address to set\r\n     */\r\n    function setVaultFactory(bytes32 _id, address _add) external;\r\n\r\n    /**\r\n     * @notice adds a new vault factory with address and short id. The short id will be converted to full id and saved.\r\n     * @param _id the vault factory short id\r\n     * @param _add The address to add\r\n     */\r\n    function addVaultFactory(bytes32 _id, address _add) external;\r\n\r\n    /**\r\n     * @notice Deploys a proxy for an implimentation and initializes then saves in the registry.\r\n     * @param _id the full id to be saved.\r\n     * @param _logic The address of the implementation\r\n     * @param _data The initialization low data\r\n     */\r\n    function updateImplementation(bytes32 _id, address _logic, bytes memory _data) external;\r\n\r\n    /**\r\n     * @notice Updates a proxy with a new implementation logic while keeping the store intact.\r\n     * @param _id the full id to be saved.\r\n     * @param _logic The address of the new implementation\r\n     */\r\n    function updateProxy(bytes32 _id, address _logic) external;\r\n}\r\n"

    },

    "contracts/libraries/Errors.sol": {

      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.10;\r\n\r\n/**\r\n * @title library for Errors mapping\r\n * @author Souq\r\n * @notice Defines the output of error messages reverted by the contracts of the Souq protocol\r\n * @notice License: https://souq-peripheral-v1.s3.amazonaws.com/LICENSE.md\r\n */\r\nlibrary Errors {\r\n    string public constant ADDRESS_IS_ZERO = \"ADDRESS_IS_ZERO\";\r\n    string public constant NOT_ENOUGH_USER_BALANCE = \"NOT_ENOUGH_USER_BALANCE\";\r\n    string public constant NOT_ENOUGH_APPROVED = \"NOT_ENOUGH_APPROVED\";\r\n    string public constant INVALID_AMOUNT = \"INVALID_AMOUNT\";\r\n    string public constant AMM_PAUSED = \"AMM_PAUSED\";\r\n    string public constant VAULT_PAUSED = \"VAULT_PAUSED\";\r\n    string public constant FLASHLOAN_DISABLED = \"FLASHLOAN_DISABLED\";\r\n    string public constant ADDRESSES_REGISTRY_NOT_SET = \"ADDRESSES_REGISTRY_NOT_SET\";\r\n    string public constant UPGRADEABILITY_DISABLED = \"UPGRADEABILITY_DISABLED\";\r\n    string public constant CALLER_NOT_UPGRADER = \"CALLER_NOT_UPGRADER\";\r\n    string public constant CALLER_NOT_POOL_ADMIN = \"CALLER_NOT_POOL_ADMIN\";\r\n    string public constant CALLER_NOT_ACCESS_ADMIN = \"CALLER_NOT_ACCESS_ADMIN\";\r\n    string public constant CALLER_NOT_POOL_ADMIN_OR_OPERATIONS = \"CALLER_NOT_POOL_ADMIN_OR_OPERATIONS\";\r\n    string public constant CALLER_NOT_ORACLE_ADMIN = \"CALLER_NOT_ORACLE_ADMIN\";\r\n    string public constant CALLER_NOT_TIMELOCK=\"CALLER_NOT_TIMELOCK\";\r\n    string public constant CALLER_NOT_TIMELOCK_ADMIN=\"CALLER_NOT_TIMELOCK_ADMIN\";\r\n    string public constant ADDRESS_IS_PROXY = \"ADDRESS_IS_PROXY\";\r\n    string public constant ARRAY_NOT_SAME_LENGTH = \"ARRAY_NOT_SAME_LENGTH\";\r\n    string public constant NO_SUB_POOL_AVAILABLE = \"NO_SUB_POOL_AVAILABLE\";\r\n    string public constant LIQUIDITY_MODE_RESTRICTED = \"LIQUIDITY_MODE_RESTRICTED\";\r\n    string public constant TVL_LIMIT_REACHED = \"TVL_LIMIT_REACHED\";\r\n    string public constant CALLER_MUST_BE_POOL = \"CALLER_MUST_BE_POOL\";\r\n    string public constant CANNOT_RESCUE_POOL_TOKEN = \"CANNOT_RESCUE_POOL_TOKEN\";\r\n    string public constant CALLER_MUST_BE_STABLEYIELD_ADMIN = \"CALLER_MUST_BE_STABLEYIELD_ADMIN\";\r\n    string public constant CALLER_MUST_BE_STABLEYIELD_LENDER = \"CALLER_MUST_BE_STABLEYIELD_LENDER\";\r\n    string public constant FUNCTION_REQUIRES_ACCESS_NFT = \"FUNCTION_REQUIRES_ACCESS_NFT\";\r\n    string public constant FEE_OUT_OF_BOUNDS = \"FEE_OUT_OF_BOUNDS\";\r\n    string public constant ONLY_ADMIN_CAN_ADD_LIQUIDITY = \"ONLY_ADMIN_CAN_ADD_LIQUIDITY\";\r\n    string public constant NOT_ENOUGH_POOL_RESERVE = \"NOT_ENOUGH_POOL_RESERVE\";\r\n    string public constant NOT_ENOUGH_SUBPOOL_RESERVE = \"NOT_ENOUGH_SUBPOOL_RESERVE\";\r\n    string public constant NOT_ENOUGH_SUBPOOL_SHARES = \"NOT_ENOUGH_SUBPOOL_SHARES\";\r\n    string public constant SUBPOOL_DISABLED = \"SUBPOOL_DISABLED\";\r\n    string public constant ADDRESS_NOT_CONNECTOR_ADMIN = \"ADDRESS_NOT_CONNECTOR_ADMIN\";\r\n    string public constant WITHDRAW_LIMIT_REACHED = \"WITHDRAW_LIMIT_REACHED\";\r\n    string public constant DEPOSIT_LIMIT_REACHED = \"DEPOSIT_LIMIT_REACHED\";\r\n    string public constant SHARES_VALUE_EXCEEDS_TARGET = \"SHARES_VALUE_EXCEEDS_TARGET\";\r\n    string public constant SHARES_VALUE_BELOW_TARGET = \"SHARES_VALUE_BELOW_TARGET\";\r\n    string public constant SHARES_TARGET_EXCEEDS_RESERVE = \"SHARES_TARGET_EXCEEDS_RESERVE\";\r\n    string public constant SWAPPING_SHARES_TEMPORARY_DISABLED_DUE_TO_LOW_CONDITIONS =\r\n        \"SWAPPING_SHARES_TEMPORARY_DISABLED_DUE_TO_LOW_CONDITIONS\";\r\n    string public constant ADDING_SHARES_TEMPORARY_DISABLED_DUE_TO_LOW_CONDITIONS =\r\n        \"ADDING_SHARES_TEMPORARY_DISABLED_DUE_TO_LOW_CONDITIONS\";\r\n    string public constant UPGRADE_DISABLED = \"UPGRADE_DISABLED\";\r\n    string public constant USER_CANNOT_BE_CONTRACT = \"USER_CANNOT_BE_CONTRACT\";\r\n    string public constant DEADLINE_NOT_FOUND = \"DEADLINE_NOT_FOUND\";\r\n    string public constant FLASHLOAN_PROTECTION_ENABLED = \"FLASHLOAN_PROTECTION_ENABLED\";\r\n    string public constant INVALID_POOL_ADDRESS = \"INVALID_POOL_ADDRESS\";\r\n    string public constant INVALID_SUBPOOL_ID = \"INVALID_SUBPOOL_ID\";\r\n    string public constant INVALID_YIELD_DISTRIBUTOR_ADDRESS=\"INVALID_YIELD_DISTRIBUTOR_ADDRESS\";\r\n    string public constant YIELD_DISTRIBUTOR_NOT_FOUND=\"YIELD_DISTRIBUTOR_NOT_FOUND\";\r\n    string public constant INVALID_TOKEN_ID=\"INVALID_TOKEN_ID\";\r\n    string public constant INVALID_VAULT_ADDRESS = \"INVALID_VAULT_ADDRESS\";\r\n    string public constant VAULT_NOT_FOUND=\"VAULT_NOT_FOUND\";\r\n    string public constant INVALID_TOKEN_ADDRESS=\"INVALID_TOKEN_ADDRESS\";\r\n    string public constant INVALID_STAKING_CONTRACT=\"INVALID_STAKING_CONTRACT\";\r\n    string public constant STAKING_CONTRACT_NOT_FOUND=\"STAKING_CONTRACT_NOT_FOUND\";\r\n    string public constant INVALID_SWAP_CONTRACT=\"INVALID_SWAP_CONTRACT\";\r\n    string public constant SWAP_CONTRACT_NOT_FOUND=\"SWAP_CONTRACT_NOT_FOUND\";\r\n    string public constant INVALID_ORACLE_CONNECTOR=\"INVALID_ORACLE_CONNECTOR\";\r\n    string public constant ORACLE_CONNECTOR_NOT_FOUND=\"ORACLE_CONNECTOR_NOT_FOUND\";\r\n    string public constant INVALID_COLLECTION_CONTRACT=\"INVALID_COLLECTION_CONTRACT\";\r\n    string public constant COLLECTION_CONTRACT_NOT_FOUND=\"COLLECTION_CONTRACT_NOT_FOUND\";\r\n    string public constant INVALID_STABLECOIN_YIELD_CONNECTOR=\"INVALID_STABLECOIN_YIELD_CONNECTOR\";\r\n    string public constant STABLECOIN_YIELD_CONNECTOR_NOT_FOUND=\"STABLECOIN_YIELD_CONNECTOR_NOT_FOUND\";\r\n    string public constant TIMELOCK_USES_ACCESS_CONTROL=\"TIMELOCK_USES_ACCESS_CONTROL\";\r\n}\r\n"

    },

    "contracts/peripherals/AccessNFT.sol": {

      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.10;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\r\nimport \"../interfaces/IAccessManager.sol\";\r\nimport \"../interfaces/IAddressesRegistry.sol\";\r\nimport \"../libraries/Errors.sol\";\r\nimport {IAccessNFT} from \"../interfaces/IAccessNFT.sol\";\r\n\r\n/**\r\n * @title AccessNFT\r\n * @author Souq.Finance\r\n * @notice The ERC1155 Access NFT Contract that enables users to interact with the Pool at approved times and get discounts if set\r\n * @notice License: https://souq-peripheral-v1.s3.amazonaws.com/LICENSE.md\r\n */\r\n\r\ncontract AccessNFT is ERC1155, IAccessNFT {\r\n    bool public deadlinesOn;\r\n    address public immutable addressesRegistry;\r\n    //function hashes -> tokenIDs -> deadline\r\n    mapping(bytes32 => mapping(uint256 => uint256)) public deadlines;\r\n    //tokenIDs -> fee discount percentage\r\n    mapping(uint256 => uint256) public discountPercentage;\r\n    //flashloan protection\r\n    mapping(uint256 => bytes32) public tokenUsedInTransaction;\r\n\r\n    constructor(address _addressesRegistry, bool _deadlinesOn) ERC1155(\"\") {\r\n        addressesRegistry = _addressesRegistry;\r\n        deadlinesOn = _deadlinesOn;\r\n    }\r\n\r\n    /**\r\n     * @dev modifier for when the address is the pool admin only\r\n     */\r\n    modifier onlyPoolAdmin() {\r\n        require(\r\n            IAccessManager(IAddressesRegistry(addressesRegistry).getAccessManager()).isPoolAdmin(msg.sender),\r\n            Errors.CALLER_NOT_POOL_ADMIN\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// @inheritdoc IAccessNFT\r\n    function HasAccessNFT(address user, uint256 tokenId, string calldata functionName) external view returns (bool) {\r\n        bytes32 hashedName = keccak256(bytes(functionName));\r\n        require(!isContract(user), Errors.USER_CANNOT_BE_CONTRACT);\r\n        require(deadlines[hashedName][tokenId] != 0, Errors.DEADLINE_NOT_FOUND);\r\n        //Everyone has access after deadline ends\r\n        //Using block.timestamp is safer than block number\r\n        //See: https://ethereum.stackexchange.com/questions/11060/what-is-block-timestamp/11072#11072\r\n        if ((block.timestamp > deadlines[hashedName][tokenId]) || (deadlinesOn == false)) {\r\n            return true;\r\n        }\r\n        return this.balanceOf(user, tokenId) > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers NFTs from one address to another with flashloan protection\r\n     * @param from The account to transfer from\r\n     * @param to The account to transfer to\r\n     * @param id the token id\r\n     * @param amount The amount\r\n     * @param data The data of the transaction\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes memory data) public virtual override {\r\n        bytes32 currentTransaction = keccak256(abi.encodePacked(block.number));\r\n        require(tokenUsedInTransaction[id] != currentTransaction, Errors.FLASHLOAN_PROTECTION_ENABLED);\r\n        tokenUsedInTransaction[id] = keccak256(abi.encodePacked(block.number));\r\n        super.safeTransferFrom(from, to, id, amount, data);\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers multiple NFTs from one address to another with flashloan protection\r\n     * @param from The account to transfer from\r\n     * @param to The account to transfer to\r\n     * @param ids the token ids array\r\n     * @param amounts The amounts array\r\n     * @param data The data of the transaction\r\n     */\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) public virtual override {\r\n        bytes32 currentTransaction = keccak256(abi.encodePacked(block.number));\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            require(tokenUsedInTransaction[ids[i]] != currentTransaction, Errors.FLASHLOAN_PROTECTION_ENABLED);\r\n            tokenUsedInTransaction[ids[i]] = keccak256(abi.encodePacked(block.number));\r\n        }\r\n        super.safeBatchTransferFrom(from, to, ids, amounts, data);\r\n    }\r\n\r\n    /// @inheritdoc IAccessNFT\r\n    function setDeadline(string calldata functionName, uint256 deadline, uint256 tokenId) external onlyPoolAdmin {\r\n        bytes32 hashedName = keccak256(bytes(functionName));\r\n        deadlines[hashedName][tokenId] = deadline;\r\n\r\n        emit DeadlineSet(functionName, hashedName, deadline, tokenId);\r\n    }\r\n\r\n    /// @inheritdoc IAccessNFT\r\n    function getDeadline(bytes32 hashedFunctionName, uint256 tokenId) external view returns (uint256) {\r\n        return deadlines[hashedFunctionName][tokenId];\r\n    }\r\n\r\n    /// @inheritdoc IAccessNFT\r\n    function toggleDeadlines() external onlyPoolAdmin {\r\n        deadlinesOn = !deadlinesOn;\r\n\r\n        emit ToggleDeadlines(deadlinesOn);\r\n    }\r\n\r\n    /// @inheritdoc IAccessNFT\r\n    function setFeeDiscount(uint256 tokenId, uint256 discount) external onlyPoolAdmin {\r\n        require(discount >= 0, \"Discount must not be less than 0\");\r\n        require(discount <= 100, \"Discount must be less than or equal to 100\");\r\n        discountPercentage[tokenId] = discount;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if an account address is a contract\r\n     * @param account The account address\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470; // hash of empty string\r\n        assembly {\r\n            codehash := extcodehash(account)\r\n        }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /// @inheritdoc IAccessNFT\r\n    function setURI(string memory newuri) external onlyPoolAdmin {\r\n        _setURI(newuri);\r\n    }\r\n\r\n    /// @inheritdoc IAccessNFT\r\n    function adminBurn(address account, uint256 id, uint256 amount) external onlyPoolAdmin {\r\n        _burn(account, id, amount);\r\n    }\r\n\r\n        function mint(address account, uint256 id, uint256 amount, bytes memory data) external onlyPoolAdmin {\r\n        _mint(account, id, amount, data);\r\n    }\r\n\r\n    function mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) external onlyPoolAdmin {\r\n        _mintBatch(to, ids, amounts, data);\r\n    }\r\n}\r\n"

    }

  },

  "settings": {

    "metadata": {

      "bytecodeHash": "none",

      "useLiteralContent": true

    },

    "optimizer": {

      "enabled": true,

      "runs": 200,

      "details": {

        "yul": true,

        "yulDetails": {

          "optimizerSteps": "dhfoDgvulfnTUtnIf [xa[r]scLM cCTUtTOntnfDIul Lcul Vcul [j] Tpeul xa[rul] xa[r]cL gvif CTUca[r]LsTOtfDnca[r]Iulc] jmul[jul] VcTOcul jmul"

        }

      }

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "libraries": {}

  }

}}