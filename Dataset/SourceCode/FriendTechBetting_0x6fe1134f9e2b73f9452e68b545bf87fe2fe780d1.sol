{{

  "language": "Solidity",

  "sources": {

    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"

    },

    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"

    },

    "contracts/FriendBetsVersion.sol": {

      "content": "// SPDX-License-Identifier: MIT\r\n\r\n/*\r\nðŸŽ² Bet on the key prices of your favorite twitter users\r\n\r\nTwitter: https://twitter.com/friendbet_tech\r\nTelegram: https://t.me/FriendBetPortal\r\nWebsite: https://friendbet.tech/\r\nDocs: https://docs.friendbet.tech/\r\n*/\r\npragma solidity ^0.8.19;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport {Ownable} from \"solady/src/auth/Ownable.sol\";\r\n\r\ncontract FriendTechBetting is ReentrancyGuard, Ownable {\r\n    enum States {\r\n        Open,\r\n        Closed,\r\n        Resolved\r\n    }\r\n\r\n    /*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*/\r\n    /*               STORAGE                                      */\r\n    /*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*/\r\n    IERC20 public xbetsToken;\r\n    address public botAddress;\r\n    uint256 public totalEarned;\r\n    uint256 public totalVolume;\r\n    uint256 public totalBetsPlayed;\r\n\r\n    struct BetInfo {\r\n        uint8 prediction;\r\n        uint256 amount;\r\n    }\r\n\r\n    struct ReturnIdData {\r\n        uint256 totalBet;\r\n        BetInfo[] bets;\r\n        RoundInfo round;\r\n    }\r\n\r\n    struct RoundInfo {\r\n        address targetAddress;\r\n        address otherAddress;\r\n        States state;\r\n        uint256 totalOther;\r\n        uint256 totalTarget;\r\n        uint256 winningOutcome;\r\n        uint256 totalUsersOther;\r\n        uint256 totalUsersTarget;\r\n    }\r\n\r\n    struct ReturnInfo {\r\n        bytes32 id;\r\n        States state;\r\n        uint256 totalBet;\r\n        uint8 prediction;\r\n    }\r\n\r\n    mapping(bytes32 => bool) public isOpen;\r\n    mapping(bytes32 => bool) public isClosed;\r\n    mapping(bytes32 => uint256) public latestVersion;\r\n    mapping(uint256 => ReturnInfo[]) public openBets;\r\n    mapping(uint256 => mapping(bytes32 => uint256)) public total;\r\n    mapping(uint256 => mapping(bytes32 => RoundInfo)) public rounds;\r\n    mapping(uint256 => mapping(bytes32 => address[])) public betUsers;\r\n    mapping(address => mapping(address => bytes32)) public addressToId;\r\n    mapping(uint256 => mapping(bytes32 => address[])) public roundBettors;\r\n    mapping(uint256 => mapping(bytes32 => mapping(address => BetInfo)))\r\n        public bets;\r\n\r\n    bytes32[] public allIds;\r\n\r\n    /*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*/\r\n    /*               EVENTS                                       */\r\n    /*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*/\r\n    event BetPlaced(\r\n        bytes32 id,\r\n        address indexed user,\r\n        uint256 prediction,\r\n        uint256 amount,\r\n        uint256 version\r\n    );\r\n    event BetResolved(bytes32 id, uint256 winningOutcome, uint256 version);\r\n    event Claimed(\r\n        bytes32 id,\r\n        address indexed user,\r\n        uint256 amount,\r\n        uint256 version\r\n    );\r\n    event BettingOpened(bytes32 id, uint256 version);\r\n    event BettingClosed(bytes32 id, uint256 version);\r\n\r\n    /*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*/\r\n    /*               ERRORS                                       */\r\n    /*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*/\r\n    error Bet_Closed();\r\n    error Bet_InvalidId();\r\n    error Bet_NotResolved();\r\n    error Bet_InvalidState();\r\n    error Bet_NotClaimable();\r\n    error Bet_AmountToSmall();\r\n    error Bet_InvalidAddress();\r\n    error Bet_InvalidPrediction();\r\n    error Bet_OnlyOnePrediction();\r\n    error Bet_ContractInsufficientTokens();\r\n\r\n    constructor(IERC20 _xbetsToken) {\r\n        _initializeOwner(msg.sender);\r\n        xbetsToken = _xbetsToken;\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    modifier onlyOwnerBot() {\r\n        require(\r\n            (msg.sender == owner()) || (msg.sender == botAddress),\r\n            \"Only Owner or Bot\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*/\r\n    /*               PUBLIC NON-PAYABLE FUNCTIONS                 */\r\n    /*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*/\r\n\r\n    /**\r\n     * @notice Function to place a bet on whether the price of a specific address will go up or down\r\n     * @param _id The Id of the betting pool\r\n     * @param _prediction The prediction made by the bettor (1 for Target, 2 for Other)\r\n     * @param _amount The bet amount\r\n     */\r\n    function friendBet(\r\n        bytes32 _id,\r\n        uint8 _prediction,\r\n        uint256 _amount\r\n    ) public nonReentrant {\r\n        if (_id == bytes32(0)) {\r\n            revert Bet_InvalidId();\r\n        }\r\n        if (_prediction != 1 && _prediction != 2) {\r\n            revert Bet_InvalidPrediction();\r\n        }\r\n        if (_amount < 1000 * 1e18) {\r\n            revert Bet_AmountToSmall();\r\n        }\r\n\r\n        uint256 version = latestVersion[_id];\r\n\r\n        RoundInfo storage _rounds = rounds[version][_id];\r\n        BetInfo storage _bets = bets[version][_id][msg.sender];\r\n        if (_rounds.state != States.Open) {\r\n            revert Bet_Closed();\r\n        }\r\n\r\n        uint256 prediction = _bets.prediction;\r\n        if (prediction != 0 && prediction != _prediction) {\r\n            revert Bet_OnlyOnePrediction();\r\n        }\r\n\r\n        xbetsToken.transferFrom(msg.sender, address(this), _amount);\r\n\r\n        totalBetsPlayed += 1;\r\n        totalVolume += _amount;\r\n\r\n        betUsers[version][_id].push(msg.sender);\r\n\r\n        roundBettors[version][_id].push(msg.sender);\r\n\r\n        _rounds.totalUsersTarget += _prediction == 1 ? 1 : 0;\r\n        _rounds.totalUsersOther += _prediction == 2 ? 1 : 0;\r\n        _rounds.totalTarget += _prediction == 1 ? _amount : 0;\r\n        _rounds.totalOther += _prediction == 2 ? _amount : 0;\r\n\r\n        _bets.prediction = _prediction;\r\n        _bets.amount += _amount;\r\n\r\n        total[version][_id] += _amount;\r\n\r\n        emit BetPlaced(_id, msg.sender, _prediction, _amount, version);\r\n    }\r\n\r\n    /**\r\n     * @notice Function to claim winnings for a specific bet on an address\r\n     * @param _id The Id of the betting pool\r\n     * @param _version The version of the betting pool to claim (default 0 to get latest)\r\n     */\r\n    function claimRewards(bytes32 _id, uint256 _version) public nonReentrant {\r\n        if (_id == bytes32(0)) {\r\n            revert Bet_InvalidId();\r\n        }\r\n        uint256 version = _version;\r\n        if (version == 0) {\r\n            version = latestVersion[_id];\r\n        }\r\n        if (rounds[version][_id].state != States.Resolved) {\r\n            revert Bet_NotResolved();\r\n        }\r\n\r\n        BetInfo storage _bets = bets[version][_id][msg.sender];\r\n        RoundInfo memory _rounds = rounds[version][_id];\r\n        uint256 currentOutcome = _rounds.winningOutcome;\r\n        uint256 totalCurrent = _rounds.winningOutcome == 1\r\n            ? _rounds.totalTarget\r\n            : _rounds.totalOther;\r\n\r\n        if (_bets.prediction != currentOutcome) {\r\n            revert Bet_NotClaimable();\r\n        }\r\n        uint256 amount = (_bets.amount * total[version][_id]) / totalCurrent;\r\n\r\n        if (xbetsToken.balanceOf(address(this)) < amount) {\r\n            revert Bet_ContractInsufficientTokens();\r\n        }\r\n\r\n        xbetsToken.transfer(msg.sender, amount);\r\n        totalEarned += amount;\r\n        _bets.amount = 0;\r\n        _bets.prediction = 0;\r\n\r\n        emit Claimed(_id, msg.sender, amount, version);\r\n    }\r\n\r\n    /*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*/\r\n    /*                  PUBLIC VIEW FUNCTIONS                     */\r\n    /*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*/\r\n\r\n    /**\r\n     * @notice Function to get the total bet amount for a particular outcome\r\n     * @param _id The Id of the betting pool\r\n     * @param _version The version to check\r\n     * @param _outcome The outcome to check\r\n     * @return The total bet amount for the outcome\r\n     */\r\n    function getTotalBetsForOutcome(\r\n        bytes32 _id,\r\n        uint256 _version,\r\n        uint256 _outcome\r\n    ) public view returns (uint256) {\r\n        uint256 version = _version;\r\n        if (version == 0) {\r\n            version = latestVersion[_id];\r\n        }\r\n        RoundInfo memory _rounds = rounds[version][_id];\r\n        uint256 totalCurrent = _outcome == 1\r\n            ? _rounds.totalTarget\r\n            : _rounds.totalOther;\r\n        return totalCurrent;\r\n    }\r\n\r\n    /**\r\n     * @notice Function to get the total bet amount a user has placed for a particular outcome\r\n     * @param _user The user to check\r\n     * @param _id The Id of the betting pool\r\n     * @param _version The version to check\r\n     * @param _outcome The outcome to check\r\n     * @return The total bet amount the user has placed for the outcome\r\n     */\r\n    function getUserPredictionForOutcome(\r\n        address _user,\r\n        bytes32 _id,\r\n        uint256 _version,\r\n        uint8 _outcome\r\n    ) public view returns (uint256) {\r\n        uint256 version = _version;\r\n        if (version == 0) {\r\n            version = latestVersion[_id];\r\n        }\r\n        BetInfo memory _bets = bets[version][_id][_user];\r\n        uint8 outcome = _bets.prediction;\r\n        uint256 amount = _bets.amount;\r\n        return _outcome == outcome ? amount : 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Function to get all outcomes a user has bet on\r\n     * @param _user The address of the user\r\n     * @param _id The Id of the betting pool\r\n     * @param _version The version to check\r\n     * @return An array of outcomes the user has bet on\r\n     */\r\n    function getUserOutcomes(\r\n        address _user,\r\n        bytes32 _id,\r\n        uint256 _version\r\n    ) public view returns (uint8) {\r\n        uint256 version = _version;\r\n        if (version == 0) {\r\n            version = latestVersion[_id];\r\n        }\r\n        BetInfo memory _bets = bets[version][_id][_user];\r\n        return _bets.prediction;\r\n    }\r\n\r\n    /**\r\n     * @notice Function to get amount to claim for current version\r\n     * @return amount The amount to claim\r\n     * @param _id The Id of the betting pool\r\n     * @param _version The version to check\r\n     */\r\n    function getAmountToClaim(\r\n        bytes32 _id,\r\n        uint256 _version\r\n    ) public view returns (uint256) {\r\n        uint256 version = _version;\r\n        if (version == 0) {\r\n            version = latestVersion[_id];\r\n        }\r\n        BetInfo memory _bets = bets[version][_id][msg.sender];\r\n        RoundInfo memory _rounds = rounds[version][_id];\r\n        uint256 totalCurrent = _rounds.winningOutcome == 1\r\n            ? _rounds.totalTarget\r\n            : _rounds.totalOther;\r\n        if (_bets.prediction == _rounds.winningOutcome) {\r\n            uint256 amount = (_bets.amount * total[version][_id]) /\r\n                totalCurrent;\r\n\r\n            return amount;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Function to get amount to claim for current version\r\n     * @return amount The amount to claim\r\n     * @param _userAddress The user Address to check\r\n     * @param _id The Id of the betting pool\r\n     * @param _version The version to check\r\n     */\r\n    function getAmountToClaimUser(\r\n        address _userAddress,\r\n        bytes32 _id,\r\n        uint256 _version\r\n    ) public view returns (uint256) {\r\n        uint256 version = _version;\r\n        if (version == 0) {\r\n            version = latestVersion[_id];\r\n        }\r\n        BetInfo memory _bets = bets[version][_id][_userAddress];\r\n        RoundInfo memory _rounds = rounds[version][_id];\r\n        uint256 totalCurrent = _rounds.winningOutcome == 1\r\n            ? _rounds.totalTarget\r\n            : _rounds.totalOther;\r\n        if (_bets.prediction == _rounds.winningOutcome) {\r\n            uint256 amount = (_bets.amount * total[version][_id]) /\r\n                totalCurrent;\r\n\r\n            return amount;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Function to get a list of users by betting pool\r\n     * @return ReturnInfo[] An array of ReturnInfo Structs with user betting information\r\n     * @param _id The Id of the betting pool\r\n     * @param _version The version to check\r\n     */\r\n    function getUsersBetList(\r\n        bytes32 _id,\r\n        uint256 _version\r\n    ) public view returns (ReturnInfo[] memory) {\r\n        uint256 version = _version;\r\n        if (version == 0) {\r\n            version = latestVersion[_id];\r\n        }\r\n        address[] memory bettors = roundBettors[version][_id];\r\n        ReturnInfo[] memory returnInfoList = new ReturnInfo[](bettors.length);\r\n\r\n        for (uint i = 0; i < bettors.length; i++) {\r\n            address userAddress = bettors[i];\r\n            BetInfo memory userBet = bets[version][_id][userAddress];\r\n            RoundInfo memory roundInfo = rounds[version][_id];\r\n\r\n            returnInfoList[i] = ReturnInfo({\r\n                id: _id,\r\n                state: roundInfo.state,\r\n                totalBet: userBet.amount,\r\n                prediction: userBet.prediction\r\n            });\r\n        }\r\n\r\n        return returnInfoList;\r\n    }\r\n\r\n    /**\r\n     * @notice Function to get total users for either outcome\r\n     * @param _id The Id of the betting pool\r\n     * @param _version The version to check\r\n     * @return uint256 Total amount the user has bet on the outcome\r\n     */\r\n    function getTotalUserOutcome(\r\n        bytes32 _id,\r\n        uint256 _version,\r\n        uint8 _outcome\r\n    ) public view returns (uint256) {\r\n        if (_outcome != 1 && _outcome != 2) {\r\n            revert Bet_InvalidPrediction();\r\n        }\r\n\r\n        uint256 version = _version;\r\n        if (version == 0) {\r\n            version = latestVersion[_id];\r\n        }\r\n\r\n        RoundInfo memory _rounds = rounds[version][_id];\r\n        return\r\n            _outcome == 1 ? _rounds.totalUsersTarget : _rounds.totalUsersOther;\r\n    }\r\n\r\n    /**\r\n     * @notice Function to get relevent data by id and version\r\n     * @param _id The Id of the betting pool\r\n     * @param _version The version to check\r\n     * @return ReturnIdData Struct with all the data\r\n     */\r\n    function getBetData(\r\n        bytes32 _id,\r\n        uint256 _version\r\n    ) public view returns (ReturnIdData memory) {\r\n        uint256 version = _version;\r\n        if (version == 0) {\r\n            version = latestVersion[_id];\r\n        }\r\n        RoundInfo memory roundInfo = rounds[version][_id];\r\n        address[] memory users = betUsers[version][_id];\r\n        BetInfo[] memory betInfoList = new BetInfo[](users.length);\r\n\r\n        for (uint256 i = 0; i < users.length; i++) {\r\n            betInfoList[i] = bets[version][_id][users[i]];\r\n        }\r\n\r\n        uint256 totalBet = total[version][_id];\r\n\r\n        return\r\n            ReturnIdData({\r\n                totalBet: totalBet,\r\n                bets: betInfoList,\r\n                round: roundInfo\r\n            });\r\n    }\r\n\r\n    /**\r\n     * @notice Function to get all open ids\r\n     * @return bytes32[] Array with all ids\r\n     */\r\n    function getAllBets() public view returns (bytes32[] memory) {\r\n        uint256 openCount = 0;\r\n        for (uint256 i = 0; i < allIds.length; i++) {\r\n            if (isOpen[allIds[i]]) {\r\n                openCount++;\r\n            }\r\n        }\r\n\r\n        bytes32[] memory openIds = new bytes32[](openCount);\r\n        uint256 index = 0;\r\n        for (uint256 i = 0; i < allIds.length; i++) {\r\n            if (isOpen[allIds[i]]) {\r\n                openIds[index] = allIds[i];\r\n                index++;\r\n            }\r\n        }\r\n        return openIds;\r\n    }\r\n\r\n    /**\r\n     * @notice Function to get all closed ids\r\n     * @return bytes32[] Array with all ids\r\n     */\r\n    function getClosedBets() public view returns (bytes32[] memory) {\r\n        uint256 closedCount = 0;\r\n        for (uint256 i = 0; i < allIds.length; i++) {\r\n            if (isClosed[allIds[i]]) {\r\n                closedCount++;\r\n            }\r\n        }\r\n\r\n        bytes32[] memory closedIds = new bytes32[](closedCount);\r\n        uint256 index = 0;\r\n        for (uint256 i = 0; i < allIds.length; i++) {\r\n            if (isClosed[allIds[i]]) {\r\n                closedIds[index] = allIds[i];\r\n                index++;\r\n            }\r\n        }\r\n        return closedIds;\r\n    }\r\n\r\n    /*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*/\r\n    /*               EXTERNAL ONLY-OWNER FUNCTIONS                */\r\n    /*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*/\r\n\r\n    function setBotAddress(address _botAddress) external onlyOwner {\r\n        botAddress = _botAddress;\r\n    }\r\n\r\n    /*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*/\r\n    /*               EXTERNAL ONLY-OWNERBOT FUNCTIONS             */\r\n    /*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*/\r\n    /**\r\n     * @notice Function to open betting\r\n     * @param _targetAddress The target address to initialize\r\n     * @param _otherAddress The target address to initialize\r\n     */\r\n    function openBetting(\r\n        address _targetAddress,\r\n        address _otherAddress\r\n    ) external onlyOwnerBot {\r\n        if (_targetAddress == address(0)) {\r\n            revert Bet_InvalidAddress();\r\n        }\r\n        if (_otherAddress == address(0)) {\r\n            revert Bet_InvalidAddress();\r\n        }\r\n        bytes32 id = addressToId[_targetAddress][_otherAddress];\r\n        if (id == bytes32(0)) {\r\n            id = keccak256(abi.encodePacked(_targetAddress, _otherAddress));\r\n            allIds.push(id);\r\n            addressToId[_targetAddress][_otherAddress] = id;\r\n        }\r\n        isClosed[id] = false;\r\n        latestVersion[id] += 1;\r\n        uint256 version = latestVersion[id];\r\n\r\n        RoundInfo storage _rounds = rounds[version][id];\r\n        _rounds.state = States.Open;\r\n        isOpen[id] = true;\r\n        _rounds.targetAddress = _targetAddress;\r\n        _rounds.otherAddress = _otherAddress;\r\n        emit BettingOpened(id, version);\r\n    }\r\n\r\n    /**\r\n     * @notice Function to close betting and resolve\r\n     * @param _id The Id of the betting pool\r\n     */\r\n    function closeBetting(bytes32 _id) external onlyOwnerBot {\r\n        uint256 version = latestVersion[_id];\r\n        RoundInfo storage _rounds = rounds[version][_id];\r\n        if (_rounds.state != States.Open) {\r\n            revert Bet_InvalidState();\r\n        }\r\n        _rounds.state = States.Closed;\r\n        isOpen[_id] = false;\r\n        isClosed[_id] = true;\r\n        emit BettingClosed(_id, version);\r\n    }\r\n\r\n    /**\r\n     * @notice Function to resolve a bet\r\n     * @param _winningOutcome The winning outcome\r\n     * @param _id The Id of the betting pool\r\n     */\r\n    function resolveBet(\r\n        uint256 _winningOutcome,\r\n        bytes32 _id\r\n    ) external onlyOwnerBot {\r\n        uint256 version = latestVersion[_id];\r\n        RoundInfo storage _rounds = rounds[version][_id];\r\n        if (_rounds.state != States.Closed) {\r\n            revert Bet_InvalidState();\r\n        }\r\n        _rounds.state = States.Resolved;\r\n        _rounds.winningOutcome = _winningOutcome;\r\n\r\n        emit BetResolved(_id, _winningOutcome, version);\r\n    }\r\n\r\n    /**\r\n     * @notice Function to withdraw Tokens Stuck in CA.\r\n     * @param _recipient Address to receive the withdrawn Tokens\r\n     * @param _amount Amount to withdraw\r\n     */\r\n    function withdrawStuckTokens(\r\n        address _recipient,\r\n        uint256 _amount\r\n    ) external onlyOwner {\r\n        xbetsToken.transfer(_recipient, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Function to withdraw contract Eth\r\n     * @param _recipient Address to receive the withdrawn Eth\r\n     */\r\n    function withdraw(address _recipient) external onlyOwner {\r\n        (bool success, ) = address(_recipient).call{\r\n            value: address(this).balance\r\n        }(\"\");\r\n        require(success);\r\n    }\r\n}\r\n"

    },

    "solady/src/auth/Ownable.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\n///\n/// @dev Note:\n/// This implementation does NOT auto-initialize the owner to `msg.sender`.\n/// You MUST call the `_initializeOwner` in the constructor / initializer.\n///\n/// While the ownable portion follows\n/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,\n/// the nomenclature for the 2-step ownership handover may be unique to this codebase.\nabstract contract Ownable {\n    /*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*/\n\n    /// @dev The caller is not authorized to call the function.\n    error Unauthorized();\n\n    /// @dev The `newOwner` cannot be the zero address.\n    error NewOwnerIsZeroAddress();\n\n    /// @dev The `pendingOwner` does not have a valid handover request.\n    error NoHandoverRequest();\n\n    /*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*/\n    /*                           EVENTS                           */\n    /*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*/\n\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\n    /// despite it not being as lightweight as a single argument event.\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\n\n    /// @dev An ownership handover to `pendingOwner` has been requested.\n    event OwnershipHandoverRequested(address indexed pendingOwner);\n\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\n\n    /// @dev `keccak256(bytes(\"OwnershipTransferred(address,address)\"))`.\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverRequested(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverCanceled(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\n\n    /*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*/\n    /*                          STORAGE                           */\n    /*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*/\n\n    /// @dev The owner slot is given by: `not(_OWNER_SLOT_NOT)`.\n    /// It is intentionally chosen to be a high value\n    /// to avoid collision with lower slots.\n    /// The choice of manual storage layout is to enable compatibility\n    /// with both regular and upgradeable contracts.\n    uint256 private constant _OWNER_SLOT_NOT = 0x8b78c6d8;\n\n    /// The ownership handover slot of `newOwner` is given by:\n    /// ```\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\n    ///     let handoverSlot := keccak256(0x00, 0x20)\n    /// ```\n    /// It stores the expiry timestamp of the two-step ownership handover.\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\n\n    /*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*/\n    /*                     INTERNAL FUNCTIONS                     */\n    /*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*/\n\n    /// @dev Initializes the owner directly without authorization guard.\n    /// This function must be called upon initialization,\n    /// regardless of whether the contract is upgradeable or not.\n    /// This is to enable generalization to both regular and upgradeable contracts,\n    /// and to save gas in case the initial owner is not the caller.\n    /// For performance reasons, this function will not check if there\n    /// is an existing owner.\n    function _initializeOwner(address newOwner) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Clean the upper 96 bits.\n            newOwner := shr(96, shl(96, newOwner))\n            // Store the new value.\n            sstore(not(_OWNER_SLOT_NOT), newOwner)\n            // Emit the {OwnershipTransferred} event.\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\n        }\n    }\n\n    /// @dev Sets the owner directly without authorization guard.\n    function _setOwner(address newOwner) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ownerSlot := not(_OWNER_SLOT_NOT)\n            // Clean the upper 96 bits.\n            newOwner := shr(96, shl(96, newOwner))\n            // Emit the {OwnershipTransferred} event.\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\n            // Store the new value.\n            sstore(ownerSlot, newOwner)\n        }\n    }\n\n    /// @dev Throws if the sender is not the owner.\n    function _checkOwner() internal view virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the caller is not the stored owner, revert.\n            if iszero(eq(caller(), sload(not(_OWNER_SLOT_NOT)))) {\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\n    /// Override to return a different value if needed.\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\n    function _ownershipHandoverValidFor() internal view virtual returns (uint64) {\n        return 48 * 3600;\n    }\n\n    /*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*/\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\n    /*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*/\n\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(shl(96, newOwner)) {\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        _setOwner(newOwner);\n    }\n\n    /// @dev Allows the owner to renounce their ownership.\n    function renounceOwnership() public payable virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /// @dev Request a two-step ownership handover to the caller.\n    /// The request will automatically expire in 48 hours (172800 seconds) by default.\n    function requestOwnershipHandover() public payable virtual {\n        unchecked {\n            uint256 expires = block.timestamp + _ownershipHandoverValidFor();\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Compute and set the handover slot to `expires`.\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\n                mstore(0x00, caller())\n                sstore(keccak256(0x0c, 0x20), expires)\n                // Emit the {OwnershipHandoverRequested} event.\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\n            }\n        }\n    }\n\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\n    function cancelOwnershipHandover() public payable virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, caller())\n            sstore(keccak256(0x0c, 0x20), 0)\n            // Emit the {OwnershipHandoverCanceled} event.\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\n        }\n    }\n\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            let handoverSlot := keccak256(0x0c, 0x20)\n            // If the handover does not exist, or has expired.\n            if gt(timestamp(), sload(handoverSlot)) {\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\n                revert(0x1c, 0x04)\n            }\n            // Set the handover slot to 0.\n            sstore(handoverSlot, 0)\n        }\n        _setOwner(pendingOwner);\n    }\n\n    /*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*/\n    /*                   PUBLIC READ FUNCTIONS                    */\n    /*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*/\n\n    /// @dev Returns the owner of the contract.\n    function owner() public view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(not(_OWNER_SLOT_NOT))\n        }\n    }\n\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\n    function ownershipHandoverExpiresAt(address pendingOwner)\n        public\n        view\n        virtual\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the handover slot.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            // Load the handover slot.\n            result := sload(keccak256(0x0c, 0x20))\n        }\n    }\n\n    /*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*/\n    /*                         MODIFIERS                          */\n    /*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*/\n\n    /// @dev Marks a function as only callable by the owner.\n    modifier onlyOwner() virtual {\n        _checkOwner();\n        _;\n    }\n}\n"

    }

  },

  "settings": {

    "optimizer": {

      "enabled": true,

      "runs": 200

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "libraries": {}

  }

}}