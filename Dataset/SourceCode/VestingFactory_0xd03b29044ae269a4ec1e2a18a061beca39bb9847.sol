{{

  "language": "Solidity",

  "sources": {

    "lib/openzeppelin-contracts/contracts/access/Ownable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/utils/Context.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"

    },

    "src/VestingFactory.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.11;\n/**\n * @title VestingFactory\n *\n * @notice This contract allows the owner to create, initialize and manage vesting pools with specified percentage\n * shares and names. The total percentage share of all pools cannot exceed 100%.\n *\n * @dev The contract uses OpenZeppelin's Ownable, SafeERC20, and IERC20 libraries.\n */\n\nimport \"./VestingPool.sol\";\nimport \"./interface/IVestingFactory.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-contracts/contracts/access/Ownable.sol\";\n\ncontract VestingFactory is Ownable, IVestingFactory {\n    /**\n     * @dev Mapping to store information about each vesting pool, with the address of the pool contract as the key and a\n     * PoolInfo struct as the value.\n     */\n    mapping(address => PoolInfo) private _pools;\n    /**\n     * @dev Total percentage of the token held by all vesting pools combined.\n     */\n    uint256 public poolTotalPercent = 0;\n    /**\n     * @dev Total token distributed to the vesting pools.\n     */\n    uint256 public totalDistributed;\n    /**\n     * @dev Address of the token for vesting.\n     */\n    address public constant token = 0x37C997B35C619C21323F3518B9357914E8B99525;\n    /**\n     * @dev Immutable reference to the token being used in the vesting pools.\n     */\n    IERC20 private immutable _token;\n    /**\n     * @dev Maximum percentage allowed for a single vesting pool.\n     */\n    uint256 private _maxPercentage = 100e18;\n    /**\n     * @dev Modifier to check that the overall percentage share for a new vesting pool does not exceed 100%.\n     */\n\n    modifier checkPercent(uint256 poolShare) {\n        if (poolShare == 0) revert InvalidPoolShare();\n        if (poolTotalPercent + poolShare > _maxPercentage) revert PoolAmountExceeded();\n        _;\n    }\n    /**\n     * @notice Creates a new VestingFactory contract instance.\n     */\n\n    constructor() Ownable() {\n        _token = IERC20(token);\n    }\n    /**\n     * @notice Creates a new vesting pool with the specified parameters.\n     * @param poolShare The percentage share to be allotted for the pool.\n     * @param poolName The name of the pool.\n     * @return poolAddress The address of the created pool.\n     */\n\n    function createPool(\n        uint256 poolShare,\n        string memory poolName\n    )\n        external\n        onlyOwner\n        checkPercent(poolShare)\n        returns (address)\n    {\n        address poolAddress = address(\n            new VestingPool{\n                salt: keccak256(\n                    abi.encodePacked(\n                        poolShare,\n                        address(this),\n                        poolName\n                    )\n                )\n            }(msg.sender)\n        );\n        poolTotalPercent += poolShare;\n        _pools[poolAddress] = PoolInfo(poolShare, 0, poolName);\n        emit PoolCreated(poolAddress, poolShare, poolName);\n        return poolAddress;\n    }\n    /**\n     * @dev Initializes a vesting pool by transferring the required tokens to the pool contract.\n     * @param pool The address of the vesting pool contract to be initialized.\n     * @notice The vesting pool must have been created before it can be initialized.\n     * @notice The pool must have a positive percentage share and the contract must have enough tokens to initialize the\n     * pool.\n     */\n\n    function initPool(address pool, uint256 amount) external onlyOwner {\n        PoolInfo storage poolInfo = _pools[pool];\n        if (poolInfo.poolShare == 0) revert InvalidPoolAddress();\n        if (balanceOf() == 0) revert InsufficientTokenAmounts();\n        poolInfo.poolAmount = _getPoolShareAmount(poolInfo.poolShare, amount);\n        _token.transfer(pool, poolInfo.poolAmount);\n        totalDistributed += poolInfo.poolAmount;\n        emit PoolInitialized(pool, poolInfo.poolShare, poolInfo.poolAmount);\n    }\n\n    /**\n     * @dev Recovers ERC20 tokens that were mistakenly sent to the contract.\n     * @param tokenAddress The address of the ERC20 token to be recovered.\n     * @param tokenAmount The amount of tokens to be recovered.\n     * @notice Only the contract owner can recover ERC20 tokens.\n     */\n\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOwner {\n        IERC20(tokenAddress).transfer(msg.sender, tokenAmount);\n    }\n    /**\n     * @dev Returns the PoolInfo struct of a given vesting pool.\n     * @param pool The address of the vesting pool contract to get information about.\n     * @return The PoolInfo struct of the given vesting pool.\n     */\n\n    function getPoolInfo(address pool) external view returns (PoolInfo memory) {\n        return _pools[pool];\n    }\n    /**\n     * @dev Returns the balance of the token held by the contract.\n     * @return The balance of the token held by the contract.\n     */\n\n    function balanceOf() public view returns (uint256) {\n        return IERC20(token).balanceOf(address(this));\n    }\n    /**\n     * @dev Calculates the amount of tokens to be held by a vesting pool based on its percentage share.\n     * @param poolShare The percentage share of the token to be alloted for the pool.\n     * @return The amount of tokens to be held by the vesting pool.\n     */\n\n    function _getPoolShareAmount(uint256 poolShare, uint256 amount) private view returns (uint256) {\n        return amount * poolShare / _maxPercentage;\n    }\n}\n"

    },

    "src/VestingPool.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.11;\n\n/**\n * @title VestingPool\n * @dev A contract that manages token vesting schedules for beneficiaries.\n * It allows an owner to create and manage multiple vesting schedules for different beneficiaries.\n * The vesting schedules can be revocable or non-revocable based on the provided configuration.\n * This contract is compatible with ERC20 tokens.\n */\nimport \"./VestingFactory.sol\";\nimport \"./interface/IVestingPool.sol\";\nimport \"openzeppelin-contracts/contracts/access/Ownable.sol\";\nimport \"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\";\n\ncontract VestingPool is IVestingPool, Ownable {\n    /**\n     * @dev Address of the token for vesting.\n     */\n    address public constant token = 0x37C997B35C619C21323F3518B9357914E8B99525;\n    /**\n     * @dev Private variable to store ERC20 token interface\n     */\n    IERC20 private _token;\n    /**\n     * @dev Private variable to store total amount of vested tokens\n     */\n    uint256 private _vestingSchedulesTotalAmount;\n    /**\n     * @dev Public variable to store total supply\n     */\n    uint256 public totalSupply;\n    /**\n     * @dev Public variable to store total released tokens over the time\n     */\n    uint256 public totalReleased;\n    /**\n     * @dev Private variable to store an array of vesting schedule beneficiaries\n     */\n    address[] private _vestingSchedulesBeneficiaries;\n    /**\n     * @dev Mapping to store vesting schedule information for each beneficiary\n     */\n    mapping(address => VestingSchedule) private _vestingSchedules;\n    /**\n     * @dev Mapping to store vesting count for each holder\n     */\n    mapping(address => uint256) private _holdersVestingCount;\n    /**\n     * @dev Reverts if the vesting schedule does not exist or has been revoked.\n     */\n\n    modifier onlyIfVestingScheduleNotRevoked(address beneficiary) {\n        if (_vestingSchedules[beneficiary].initialized == false) revert NotInitialized();\n        if (_vestingSchedules[beneficiary].revoked == true) revert AlreadyRevoked();\n        _;\n    }\n    /**\n     * @dev Initializes the vesting pool with the provided parameters.\n     * @param poolOwner The owner of the vesting pool.\n     */\n\n    constructor(address poolOwner) {\n        transferOwnership(poolOwner);\n        _token = IERC20(token);\n    }\n    /**\n     * @dev Fallback function is executed if none of the other functions match the function\n     * identifier or no data was provided with the function call.\n     */\n\n    fallback() external { }\n    /**\n     * @notice Creates a vesting schedule for a beneficiary.\n     * @param beneficiary The address of the beneficiary.\n     * @param start The start time of the vesting schedule.\n     * @param cliff The duration of the cliff in seconds.\n     * @param duration The total duration of the vesting schedule in seconds.\n     * @param revocable A boolean indicating if the vesting schedule can be revoked.\n     * @param amount The total amount of tokens in the vesting schedule.\n     */\n\n    function createVestingSchedule(\n        address beneficiary,\n        uint256 start,\n        uint256 cliff,\n        uint256 duration,\n        bool revocable,\n        uint256 amount\n    )\n        external\n        onlyOwner\n    {\n        if (beneficiary == address(0)) {\n            revert AddressCannotBeZero();\n        }\n        if (duration == 0) revert DurationMustBeGreaterThanZero();\n        if (amount == 0) revert AmountMustBeGreaterThanZero();\n        if (duration <= cliff) revert DurationMustBeGreaterThanCliff();\n        uint256 cliffFromStart = start + cliff;\n        _vestingSchedules[beneficiary] =\n            VestingSchedule(true, beneficiary, cliffFromStart, start, duration, revocable, amount, 0, false);\n        _vestingSchedulesTotalAmount = _vestingSchedulesTotalAmount + amount;\n        totalSupply = totalSupply + amount;\n        _vestingSchedulesBeneficiaries.push(beneficiary);\n        emit Created(beneficiary, amount);\n    }\n    /**\n     * @notice Updates the beneficiary address of a vesting schedule.\n     * @param previousBeneficiary The address of the previous beneficiary.\n     * @param newBeneficiary The address of the new beneficiary.\n     */\n\n    function updateBeneficiary(\n        address previousBeneficiary,\n        address newBeneficiary\n    )\n        external\n        onlyIfVestingScheduleNotRevoked(previousBeneficiary)\n        onlyOwner\n    {\n        if (newBeneficiary == address(0)) {\n            revert AddressCannotBeZero();\n        }\n        VestingSchedule storage vestingSchedule = _vestingSchedules[previousBeneficiary];\n        uint256 releasedAmount = vestingSchedule.released;\n        uint256 amountTotal = vestingSchedule.amountTotal;\n        bool revocable = vestingSchedule.revocable;\n        uint256 start = vestingSchedule.start;\n        uint256 cliff = vestingSchedule.cliff;\n        uint256 duration = vestingSchedule.duration;\n        _vestingSchedules[newBeneficiary] =\n            VestingSchedule(true, newBeneficiary, cliff, start, duration, revocable, amountTotal, releasedAmount, false);\n        delete _vestingSchedules[previousBeneficiary];\n        emit BeneficiaryUpdated(previousBeneficiary, newBeneficiary);\n    }\n\n    /**\n     * @notice Updates the beneficiary amount for vesting schedule.\n     * @param beneficiary The address of the beneficiary.\n     * @param amount The updated amount for the beneficiary.\n     * * @param increase boolean check to increase the amount or decrease.\n     */\n\n    function updateBeneficiaryAmount(\n        address beneficiary,\n        uint256 amount,\n        bool increase\n    )\n        external\n        onlyIfVestingScheduleNotRevoked(beneficiary)\n        onlyOwner\n    {\n        VestingSchedule storage vestingSchedule = _vestingSchedules[beneficiary];\n        uint256 previousAmount = vestingSchedule.amountTotal;\n\n        uint256 updatedAmount = increase ? previousAmount + amount : previousAmount - amount;\n\n        if (updatedAmount < vestingSchedule.released) {\n            revert InsufficientUpdatedAmount();\n        }\n\n        uint256 vestedAmount = _computeReleasableAmount(vestingSchedule);\n        if (vestedAmount > 0) {\n            _release(beneficiary);\n        }\n\n        vestingSchedule.amountTotal = updatedAmount;\n        if (increase) {\n            totalSupply += amount;\n        }\n        emit BeneficiaryAmountUpdated(previousAmount, updatedAmount);\n    }\n\n    /**\n     * @notice Revokes a vesting schedule for a beneficiary.\n     * @param beneficiary The address of the beneficiary.\n     */\n\n    function revoke(address beneficiary) external onlyOwner onlyIfVestingScheduleNotRevoked(beneficiary) {\n        VestingSchedule storage vestingSchedule = _vestingSchedules[beneficiary];\n        if (vestingSchedule.revocable == false) revert VestingNotRevocable();\n        uint256 vestedAmount = _computeReleasableAmount(vestingSchedule);\n        if (vestedAmount > 0) {\n            _release(beneficiary);\n        }\n        uint256 unreleased = vestingSchedule.amountTotal - vestingSchedule.released;\n        _vestingSchedulesTotalAmount = _vestingSchedulesTotalAmount - unreleased;\n        vestingSchedule.revoked = true;\n        if (unreleased > 0) {\n            _token.transfer(owner(), unreleased);\n        }\n    }\n    /**\n     * @notice Withdraws a specified amount of tokens from the vesting pool.\n     * @param amount The amount of tokens to be withdrawn.\n     */\n\n    function withdraw(uint256 amount, address recipient) external onlyOwner {\n        if (amount > getWithdrawableAmount()) revert NotEnoughWithdrawableFunds();\n        _token.transfer(recipient, amount);\n    }\n    /**\n     * @notice Releases the vested tokens for a beneficiary.\n     * @param beneficiary The address of the beneficiary.\n     */\n\n    function release(address beneficiary) external onlyIfVestingScheduleNotRevoked(beneficiary) {\n        _release(beneficiary);\n    }\n    /**\n     * @notice Recovers ERC20 tokens sent to the contract by mistake.\n     * @param tokenAddress The address of the ERC20 token.\n     * @param tokenAmount The amount of tokens to be recovered.\n     */\n\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOwner {\n        IERC20(tokenAddress).transfer(msg.sender, tokenAmount);\n    }\n\n    /**\n     * @notice Returns the vesting schedule of a beneficiary.\n     * @param beneficiary The address of the beneficiary.\n     * @return The vesting schedule struct.\n     */\n\n    function getVestingSchedule(address beneficiary) external view returns (VestingSchedule memory) {\n        if (_vestingSchedules[beneficiary].initialized) {\n            return _vestingSchedules[beneficiary];\n        } else {\n            revert BeneficiaryDoesNotExists();\n        }\n    }\n    /**\n     * @notice Returns the total amount of tokens in all vesting schedules.\n     * @return The total amount of tokens.\n     */\n\n    function getVestingSchedulesTotalAmount() external view returns (uint256) {\n        return _vestingSchedulesTotalAmount;\n    }\n    /**\n     * @notice Computes the releasable amount of tokens for a beneficiary.\n     * @param beneficiary The address of the beneficiary.\n     * @return The releasable amount of tokens.\n     */\n\n    function computeReleasableAmount(address beneficiary)\n        external\n        view\n        onlyIfVestingScheduleNotRevoked(beneficiary)\n        returns (uint256)\n    {\n        VestingSchedule storage vestingSchedule = _vestingSchedules[beneficiary];\n        return _computeReleasableAmount(vestingSchedule);\n    }\n    /**\n     * @notice Computes the total amount of tokens in contract.\n     * @return The total amount of tokens.\n     */\n\n    function balanceOf() external view returns (uint256) {\n        return _balanceOf();\n    }\n\n    /**\n     * @notice Calculates the amount of tokens that can be withdrawn by the owner.\n     * @return The amount of tokens that can be withdrawn.\n     */\n\n    function getWithdrawableAmount() public view returns (uint256) {\n        if (_balanceOf() > _vestingSchedulesTotalAmount) {\n            return _balanceOf() - _vestingSchedulesTotalAmount;\n        } else {\n            return 0;\n        }\n    }\n    /**\n     * @notice Returns the total number of vesting schedules managed by this contract.\n     * @return The number of vesting schedules.\n     */\n\n    function getVestingSchedulesCount() public view returns (uint256) {\n        return _vestingSchedulesBeneficiaries.length;\n    }\n    /**\n     * @dev Releases the vested amount of tokens for the specified beneficiary.\n     * @param beneficiary The address of the beneficiary whose tokens will be released.\n     */\n\n    function _release(address beneficiary) private onlyIfVestingScheduleNotRevoked(beneficiary) {\n        VestingSchedule storage vestingSchedule = _vestingSchedules[beneficiary];\n        uint256 vestedAmount = _computeReleasableAmount(vestingSchedule);\n        uint256 releasedAmount = vestingSchedule.released;\n        if (vestedAmount > 0) {\n            vestingSchedule.released = releasedAmount + vestedAmount;\n            totalReleased = totalReleased + vestedAmount;\n            _vestingSchedulesTotalAmount -= vestedAmount;\n            _token.transfer(beneficiary, vestedAmount);\n            emit Released(beneficiary, vestedAmount);\n        }\n    }\n    /**\n     * @dev Calculates the releasable amount of tokens for a given vesting schedule.\n     * @param vestingSchedule The vesting schedule to compute the releasable amount for.\n     * @return The amount of releasable tokens.\n     */\n\n    function _computeReleasableAmount(VestingSchedule memory vestingSchedule) private view returns (uint256) {\n        uint256 currentTime = block.timestamp;\n        if ((currentTime < vestingSchedule.cliff) || vestingSchedule.revoked) {\n            return 0;\n        } else if (currentTime >= vestingSchedule.start + vestingSchedule.duration) {\n            return vestingSchedule.amountTotal - vestingSchedule.released;\n        } else {\n            uint256 timeFromStart = currentTime - vestingSchedule.start;\n            uint256 vestedAmount = (vestingSchedule.amountTotal / vestingSchedule.duration) * timeFromStart;\n            return vestedAmount - vestingSchedule.released;\n        }\n    }\n    /**\n     * @dev Retrieves the contract balance of the vested token.\n     * @return The current balance of vested tokens.\n     */\n\n    function _balanceOf() private view returns (uint256) {\n        return _token.balanceOf(address(this));\n    }\n}\n"

    },

    "src/interface/IVestingFactory.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.11;\n\ninterface IVestingFactory {\n    /**\n     * @dev Error thrown when an invalid pool share is provided\n     */\n    error InvalidPoolShare();\n\n    /**\n     * @dev Error thrown when pool amount exceeds the total available tokens\n     */\n    error PoolAmountExceeded();\n\n    /**\n     * @dev Error thrown when an invalid pool address is provided\n     */\n    error InvalidPoolAddress();\n\n    /**\n     * @dev Error thrown when there are insufficient token amounts\n     */\n    error InsufficientTokenAmounts();\n\n    /**\n     * @dev Stores information about each vesting pool.\n     * @param poolShare The percentage share of the pool.\n     * @param poolAmount The amount of tokens in the pool.\n     * @param poolName The name of the pool.\n     */\n    struct PoolInfo {\n        uint256 poolShare;\n        uint256 poolAmount;\n        string poolName;\n    }\n\n    /**\n     * @dev Emitted when a new vesting pool is created.\n     * @param poolAddress The address of the newly created pool.\n     * @param poolShare The percentage share of the pool.\n     * @param poolName The name of the pool.\n     */\n    event PoolCreated(address indexed poolAddress, uint256 poolShare, string poolName);\n\n    /**\n     * @dev Emitted when a vesting pool is initialized.\n     * @param poolAddress The address of the initialized pool.\n     * @param poolShare The percentage share of the pool.\n     * @param poolAmount The amount of tokens in the pool.\n     */\n    event PoolInitialized(address indexed poolAddress, uint256 poolShare, uint256 poolAmount);\n\n    /**\n     * @dev Emitted when a vesting pool is updated.\n     * @param poolAddress The address of the updated pool.\n     * @param poolShare The updated percentage share of the pool.\n     * @param poolAmount The updated amount of tokens in the pool.\n     * @param poolName The name of the pool.\n     */\n    event PoolUpdated(address indexed poolAddress, uint256 poolShare, uint256 poolAmount, string poolName);\n}\n"

    },

    "src/interface/IVestingPool.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.11;\n\n/**\n * @title Vesting Pool Interface\n * @dev Interface for a vesting pool with common functionalities.\n */\n\ninterface IVestingPool {\n    /**\n     * @dev AddressCannotBeZero - Error thrown when the provided address is zero.\n     */\n    error AddressCannotBeZero();\n    /**\n     * @dev DurationMustBeGreaterThanZero - Error thrown when the duration of the vesting schedule is set to zero.\n     */\n    error DurationMustBeGreaterThanZero();\n    /**\n     * @dev AmountMustBeGreaterThanZero - Error thrown when the amount of tokens for vesting is set to zero.\n     */\n    error AmountMustBeGreaterThanZero();\n    /**\n     *  @dev DurationMustBeGreaterThanCliff - Error thrown when the duration of the vesting schedule is less than or\n     * equal to the cliff period.\n     */\n    error DurationMustBeGreaterThanCliff();\n    /**\n     * @dev VestingNotRevocable - Error thrown when attempting to revoke a non-revocable vesting schedule.\n     */\n    error VestingNotRevocable();\n    /**\n     * @dev NotEnoughWithdrawableFunds - Error thrown when attempting to withdraw more funds than available.\n     */\n\n    error NotEnoughWithdrawableFunds();\n\n    /**\n     * @dev BeneficiaryDoesNotExists - Error thrown when the beneficiary does not exist.\n     */\n    error BeneficiaryDoesNotExists();\n\n    /**\n     * @dev IndexOutOfBound - Error thrown when attempting to access an index that is out of bounds.\n     */\n\n    error IndexOutOfBound();\n\n    /**\n     * @dev OnlyBeneficiaryAndOwnerCanReleaseVestedTokens - Error thrown when a non-beneficiary or non-owner attempts to\n     * release vested tokens.\n     */\n    error OnlyBeneficiaryAndOwnerCanReleaseVestedTokens();\n\n    /**\n     * @dev NotEnoughVestedTokens - Error thrown when there are not enough vested tokens to release.\n     */\n    error NotEnoughVestedTokens();\n\n    /**\n     * @dev NotInitialized - Error thrown when a vesting schedule is not initialized.\n     */\n    error NotInitialized();\n\n    /**\n     * @dev AlreadyRevoked - Error thrown when a vesting schedule has already been revoked.\n     */\n    error AlreadyRevoked();\n\n    /**\n     * @dev InsufficientUpdatedAmount - Error thrown when a wrong inputs are entered.\n     */\n    error InsufficientUpdatedAmount();\n\n    /**\n     *  @dev VestingSchedule - Struct representing a vesting schedule.\n     *  @param initialized: Indicates if the vesting schedule is initialized.\n     *  @param beneficiary: The beneficiary of the tokens after they are released.\n     *  @param cliff: The cliff period in seconds.\n     *  @param start: The start time of the vesting period.\n     *  @param duration: The duration of the vesting period in seconds.\n     *  @param revocable: Indicates if the vesting schedule is revocable.\n     *  @param amountTotal: The total amount of tokens to be released at the end of the vesting.\n     *  @param released: The amount of tokens already released.\n     *  @param revoked: Indicates if the vesting schedule has been revoked.\n     */\n\n    struct VestingSchedule {\n        bool initialized;\n        address beneficiary;\n        uint256 cliff;\n        uint256 start;\n        uint256 duration;\n        bool revocable;\n        uint256 amountTotal;\n        uint256 released;\n        bool revoked;\n    }\n\n    /**\n     * @dev Struct containing information about the vesting pool.\n     * @param poolShare The percentage share of the vesting pool.\n     * @param distributer The address of the token distributer.\n     * @param tokenAmount The total amount of tokens in the vesting pool.\n     * @param poolName The name of the vesting pool.\n     */\n\n    struct PoolInfo {\n        uint256 poolShare;\n        address distributer;\n        uint256 tokenAmount;\n        string poolName;\n    }\n    /**\n     *    @dev Created - Emitted when a new vesting schedule is created.\n     * @param beneficiary: The beneficiary of the tokens after they are released.\n     * @param amountTotal: The total amount of tokens to be released at the end of the vesting.\n     */\n\n    event Created(address indexed beneficiary, uint256 amountTotal);\n    /**\n     * @dev Released - Emitted when vested tokens are released\n     *   @param beneficiary: The beneficiary of the released tokens.\n     *   @param amount: The amount of tokens released.\n     */\n    event Released(address indexed beneficiary, uint256 amount);\n\n    /**\n     * @dev BeneficiaryUpdated - Emitted when beneficiary is updated\n     *   @param previousBeneficiary: previous address of beneficiary.\n     *   @param newBeneficiary: new address of beneficiary.\n     */\n    event BeneficiaryUpdated(address previousBeneficiary, address newBeneficiary);\n\n    /**\n     * @dev BeneficiaryAmountUpdated - Emitted when beneficiary tokens are updated\n     *   @param previousAmount: Previous amounts of beneficiary.\n     *   @param newAmount: New amount of beneficiary.\n     */\n    event BeneficiaryAmountUpdated(uint256 previousAmount, uint256 newAmount);\n}\n"

    }

  },

  "settings": {

    "remappings": [

      "@prb/test/=lib/prb-test/src/",

      "ds-test/=lib/forge-std/lib/ds-test/src/",

      "forge-std/=lib/forge-std/src/",

      "openzeppelin-contracts/=lib/openzeppelin-contracts/",

      "prb-math/=lib/prb-math/src/",

      "prb-test/=lib/prb-test/src/",

      "src/=src/"

    ],

    "optimizer": {

      "enabled": true,

      "runs": 10000

    },

    "metadata": {

      "bytecodeHash": "ipfs"

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "evmVersion": "london",

    "libraries": {}

  }

}}