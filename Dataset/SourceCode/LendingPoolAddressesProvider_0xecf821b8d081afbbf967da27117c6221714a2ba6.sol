{{

  "language": "Solidity",

  "sources": {

    "contracts/protocol/configuration/LendingPoolAddressesProvider.sol": {

      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.7.6;\r\n\r\nimport {Ownable} from \"../../dependencies/openzeppelin/contracts/Ownable.sol\";\r\n\r\n// Prettier ignore to prevent buidler flatter bug\r\n// prettier-ignore\r\nimport {InitializableImmutableAdminUpgradeabilityProxy} from '../libraries/aave-upgradeability/InitializableImmutableAdminUpgradeabilityProxy.sol';\r\n\r\nimport {ILendingPoolAddressesProvider} from \"../../interfaces/ILendingPoolAddressesProvider.sol\";\r\n\r\n/**\r\n * @title LendingPoolAddressesProvider contract\r\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\r\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\r\n * - Owned by the Aave Governance\r\n * @author Aave\r\n **/\r\ncontract LendingPoolAddressesProvider is\r\n    Ownable,\r\n    ILendingPoolAddressesProvider\r\n{\r\n    string private _marketId;\r\n    mapping(bytes32 => address) private _addresses;\r\n\r\n    bytes32 private constant LENDING_POOL = \"LENDING_POOL\";\r\n    bytes32 private constant LENDING_POOL_CONFIGURATOR =\r\n        \"LENDING_POOL_CONFIGURATOR\";\r\n    bytes32 private constant POOL_ADMIN = \"POOL_ADMIN\";\r\n    bytes32 private constant EMERGENCY_ADMIN = \"EMERGENCY_ADMIN\";\r\n    bytes32 private constant LENDING_POOL_COLLATERAL_MANAGER =\r\n        \"COLLATERAL_MANAGER\";\r\n    bytes32 private constant PRICE_ORACLE = \"PRICE_ORACLE\";\r\n    bytes32 private constant LENDING_RATE_ORACLE = \"LENDING_RATE_ORACLE\";\r\n    bytes32 private constant INCENTIVE_CONTROLLER = \"INCENTIVE_CONTROLLER\";\r\n\r\n    constructor(string memory marketId) {\r\n        _setMarketId(marketId);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the id of the Aave market to which this contracts points to\r\n     * @return The market id\r\n     **/\r\n    function getMarketId() external view override returns (string memory) {\r\n        return _marketId;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows to set the market which this LendingPoolAddressesProvider represents\r\n     * @param marketId The market id\r\n     */\r\n    function setMarketId(string memory marketId) external override onlyOwner {\r\n        _setMarketId(marketId);\r\n    }\r\n\r\n    /**\r\n     * @dev General function to update the implementation of a proxy registered with\r\n     * certain `id`. If there is no proxy registered, it will instantiate one and\r\n     * set as implementation the `implementationAddress`\r\n     * IMPORTANT Use this function carefully, only for ids that don't have an explicit\r\n     * setter function, in order to avoid unexpected consequences\r\n     * @param id The id\r\n     * @param implementationAddress The address of the new implementation\r\n     */\r\n    function setAddressAsProxy(bytes32 id, address implementationAddress)\r\n        external\r\n        override\r\n        onlyOwner\r\n    {\r\n        _updateImpl(id, implementationAddress);\r\n        emit AddressSet(id, implementationAddress, true);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets an address for an id replacing the address saved in the addresses map\r\n     * IMPORTANT Use this function carefully, as it will do a hard replacement\r\n     * @param id The id\r\n     * @param newAddress The address to set\r\n     */\r\n    function setAddress(bytes32 id, address newAddress)\r\n        external\r\n        override\r\n        onlyOwner\r\n    {\r\n        _addresses[id] = newAddress;\r\n        emit AddressSet(id, newAddress, false);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an address by id\r\n     * @return The address\r\n     */\r\n    function getAddress(bytes32 id) public view override returns (address) {\r\n        return _addresses[id];\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the LendingPool proxy\r\n     * @return The LendingPool proxy address\r\n     **/\r\n    function getLendingPool() external view override returns (address) {\r\n        return getAddress(LENDING_POOL);\r\n    }\r\n\r\n    /**\r\n     * @dev Updates the implementation of the LendingPool, or creates the proxy\r\n     * setting the new `pool` implementation on the first time calling it\r\n     * @param pool The new LendingPool implementation\r\n     **/\r\n    function setLendingPoolImpl(address pool) external override onlyOwner {\r\n        _updateImpl(LENDING_POOL, pool);\r\n        emit LendingPoolUpdated(pool);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the LendingPoolConfigurator proxy\r\n     * @return The LendingPoolConfigurator proxy address\r\n     **/\r\n    function getLendingPoolConfigurator()\r\n        external\r\n        view\r\n        override\r\n        returns (address)\r\n    {\r\n        return getAddress(LENDING_POOL_CONFIGURATOR);\r\n    }\r\n\r\n    /**\r\n     * @dev Updates the implementation of the LendingPoolConfigurator, or creates the proxy\r\n     * setting the new `configurator` implementation on the first time calling it\r\n     * @param configurator The new LendingPoolConfigurator implementation\r\n     **/\r\n    function setLendingPoolConfiguratorImpl(address configurator)\r\n        external\r\n        override\r\n        onlyOwner\r\n    {\r\n        _updateImpl(LENDING_POOL_CONFIGURATOR, configurator);\r\n        emit LendingPoolConfiguratorUpdated(configurator);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the LendingPoolCollateralManager. Since the manager is used\r\n     * through delegateCall within the LendingPool contract, the proxy contract pattern does not work properly hence\r\n     * the addresses are changed directly\r\n     * @return The address of the LendingPoolCollateralManager\r\n     **/\r\n\r\n    function getLendingPoolCollateralManager()\r\n        external\r\n        view\r\n        override\r\n        returns (address)\r\n    {\r\n        return getAddress(LENDING_POOL_COLLATERAL_MANAGER);\r\n    }\r\n\r\n    /**\r\n     * @dev Updates the address of the LendingPoolCollateralManager\r\n     * @param manager The new LendingPoolCollateralManager address\r\n     **/\r\n    function setLendingPoolCollateralManager(address manager)\r\n        external\r\n        override\r\n        onlyOwner\r\n    {\r\n        _addresses[LENDING_POOL_COLLATERAL_MANAGER] = manager;\r\n        emit LendingPoolCollateralManagerUpdated(manager);\r\n    }\r\n\r\n    /**\r\n     * @dev The functions below are getters/setters of addresses that are outside the context\r\n     * of the protocol hence the upgradable proxy pattern is not used\r\n     **/\r\n\r\n    function getPoolAdmin() external view override returns (address) {\r\n        return getAddress(POOL_ADMIN);\r\n    }\r\n\r\n    function setPoolAdmin(address admin) external override onlyOwner {\r\n        _addresses[POOL_ADMIN] = admin;\r\n        emit ConfigurationAdminUpdated(admin);\r\n    }\r\n\r\n    function getEmergencyAdmin() external view override returns (address) {\r\n        return getAddress(EMERGENCY_ADMIN);\r\n    }\r\n\r\n    function setEmergencyAdmin(address emergencyAdmin)\r\n        external\r\n        override\r\n        onlyOwner\r\n    {\r\n        _addresses[EMERGENCY_ADMIN] = emergencyAdmin;\r\n        emit EmergencyAdminUpdated(emergencyAdmin);\r\n    }\r\n\r\n    function getPriceOracle() external view override returns (address) {\r\n        return getAddress(PRICE_ORACLE);\r\n    }\r\n\r\n    function setPriceOracle(address priceOracle) external override onlyOwner {\r\n        _addresses[PRICE_ORACLE] = priceOracle;\r\n        emit PriceOracleUpdated(priceOracle);\r\n    }\r\n\r\n    function getLendingRateOracle() external view override returns (address) {\r\n        return getAddress(LENDING_RATE_ORACLE);\r\n    }\r\n\r\n    function setLendingRateOracle(address lendingRateOracle)\r\n        external\r\n        override\r\n        onlyOwner\r\n    {\r\n        _addresses[LENDING_RATE_ORACLE] = lendingRateOracle;\r\n        emit LendingRateOracleUpdated(lendingRateOracle);\r\n    }\r\n\r\n    function getIncentivesController()\r\n        external\r\n        view\r\n        override\r\n        returns (address)\r\n    {\r\n        return getAddress(INCENTIVE_CONTROLLER);\r\n    }\r\n\r\n    function setIncentivesController(address incentivesController)\r\n        external\r\n        override\r\n        onlyOwner\r\n    {\r\n        _addresses[INCENTIVE_CONTROLLER] = incentivesController;\r\n        emit IncentivesControllerUpdated(incentivesController);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to update the implementation of a specific proxied component of the protocol\r\n     * - If there is no proxy registered in the given `id`, it creates the proxy setting `newAdress`\r\n     *   as implementation and calls the initialize() function on the proxy\r\n     * - If there is already a proxy registered, it just updates the implementation to `newAddress` and\r\n     *   calls the initialize() function via upgradeToAndCall() in the proxy\r\n     * @param id The id of the proxy to be updated\r\n     * @param newAddress The address of the new implementation\r\n     **/\r\n    function _updateImpl(bytes32 id, address newAddress) internal {\r\n        address payable proxyAddress = payable(_addresses[id]);\r\n\r\n        InitializableImmutableAdminUpgradeabilityProxy proxy = InitializableImmutableAdminUpgradeabilityProxy(\r\n                proxyAddress\r\n            );\r\n        bytes memory params = abi.encodeWithSignature(\r\n            \"initialize(address)\",\r\n            address(this)\r\n        );\r\n\r\n        if (proxyAddress == address(0)) {\r\n            proxy = new InitializableImmutableAdminUpgradeabilityProxy(\r\n                address(this)\r\n            );\r\n            proxy.initialize(newAddress, params);\r\n            _addresses[id] = address(proxy);\r\n            emit ProxyCreated(id, address(proxy));\r\n        } else {\r\n            proxy.upgradeToAndCall(newAddress, params);\r\n        }\r\n    }\r\n\r\n    function _setMarketId(string memory marketId) internal {\r\n        _marketId = marketId;\r\n        emit MarketIdSet(marketId);\r\n    }\r\n}\r\n"

    },

    "contracts/dependencies/openzeppelin/contracts/Ownable.sol": {

      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\nimport \"./Context.sol\";\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n"

    },

    "contracts/protocol/libraries/aave-upgradeability/InitializableImmutableAdminUpgradeabilityProxy.sol": {

      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.7.6;\r\n\r\nimport \"./BaseImmutableAdminUpgradeabilityProxy.sol\";\r\nimport \"../../../dependencies/openzeppelin/upgradeability/InitializableUpgradeabilityProxy.sol\";\r\n\r\n/**\r\n * @title InitializableAdminUpgradeabilityProxy\r\n * @dev Extends BaseAdminUpgradeabilityProxy with an initializer function\r\n */\r\ncontract InitializableImmutableAdminUpgradeabilityProxy is\r\n    BaseImmutableAdminUpgradeabilityProxy,\r\n    InitializableUpgradeabilityProxy\r\n{\r\n    constructor(address admin) BaseImmutableAdminUpgradeabilityProxy(admin) {}\r\n\r\n    /**\r\n     * @dev Only fall back when the sender is not the admin.\r\n     */\r\n    function _willFallback()\r\n        internal\r\n        override(BaseImmutableAdminUpgradeabilityProxy, Proxy)\r\n    {\r\n        BaseImmutableAdminUpgradeabilityProxy._willFallback();\r\n    }\r\n}\r\n"

    },

    "contracts/interfaces/ILendingPoolAddressesProvider.sol": {

      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.7.6;\r\n\r\n/**\r\n * @title LendingPoolAddressesProvider contract\r\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\r\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\r\n * - Owned by the Aave Governance\r\n * @author Aave\r\n **/\r\ninterface ILendingPoolAddressesProvider {\r\n    event MarketIdSet(string newMarketId);\r\n    event LendingPoolUpdated(address indexed newAddress);\r\n    event ConfigurationAdminUpdated(address indexed newAddress);\r\n    event EmergencyAdminUpdated(address indexed newAddress);\r\n    event LendingPoolConfiguratorUpdated(address indexed newAddress);\r\n    event LendingPoolCollateralManagerUpdated(address indexed newAddress);\r\n    event PriceOracleUpdated(address indexed newAddress);\r\n    event LendingRateOracleUpdated(address indexed newAddress);\r\n    event IncentivesControllerUpdated(address indexed newAddress);\r\n    event ProxyCreated(bytes32 id, address indexed newAddress);\r\n    event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\r\n\r\n    function getMarketId() external view returns (string memory);\r\n\r\n    function setMarketId(string calldata marketId) external;\r\n\r\n    function setAddress(bytes32 id, address newAddress) external;\r\n\r\n    function setAddressAsProxy(bytes32 id, address impl) external;\r\n\r\n    function getAddress(bytes32 id) external view returns (address);\r\n\r\n    function getLendingPool() external view returns (address);\r\n\r\n    function setLendingPoolImpl(address pool) external;\r\n\r\n    function getLendingPoolConfigurator() external view returns (address);\r\n\r\n    function setLendingPoolConfiguratorImpl(address configurator) external;\r\n\r\n    function getLendingPoolCollateralManager() external view returns (address);\r\n\r\n    function setLendingPoolCollateralManager(address manager) external;\r\n\r\n    function getPoolAdmin() external view returns (address);\r\n\r\n    function setPoolAdmin(address admin) external;\r\n\r\n    function getEmergencyAdmin() external view returns (address);\r\n\r\n    function setEmergencyAdmin(address admin) external;\r\n\r\n    function getPriceOracle() external view returns (address);\r\n\r\n    function setPriceOracle(address priceOracle) external;\r\n\r\n    function getLendingRateOracle() external view returns (address);\r\n\r\n    function setLendingRateOracle(address lendingRateOracle) external;\r\n\r\n    function getIncentivesController() external view returns (address);\r\n\r\n    function setIncentivesController(address lendingRateOracle) external;\r\n}\r\n"

    },

    "contracts/dependencies/openzeppelin/contracts/Context.sol": {

      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n"

    },

    "contracts/protocol/libraries/aave-upgradeability/BaseImmutableAdminUpgradeabilityProxy.sol": {

      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.7.6;\r\n\r\nimport \"../../../dependencies/openzeppelin/upgradeability/BaseUpgradeabilityProxy.sol\";\r\n\r\n/**\r\n * @title BaseImmutableAdminUpgradeabilityProxy\r\n * @author Aave, inspired by the OpenZeppelin upgradeability proxy pattern\r\n * @dev This contract combines an upgradeability proxy with an authorization\r\n * mechanism for administrative tasks. The admin role is stored in an immutable, which\r\n * helps saving transactions costs\r\n * All external functions in this contract must be guarded by the\r\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\r\n * feature proposal that would enable this to be done automatically.\r\n */\r\ncontract BaseImmutableAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\r\n    address immutable ADMIN;\r\n\r\n    constructor(address admin) {\r\n        require(admin != address(0), \"Admin can not be zero address\");\r\n        ADMIN = admin;\r\n    }\r\n\r\n    modifier ifAdmin() {\r\n        if (msg.sender == ADMIN) {\r\n            _;\r\n        } else {\r\n            _fallback();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return The address of the proxy admin.\r\n     */\r\n    function admin() external ifAdmin returns (address) {\r\n        return ADMIN;\r\n    }\r\n\r\n    /**\r\n     * @return The address of the implementation.\r\n     */\r\n    function implementation() external ifAdmin returns (address) {\r\n        return _implementation();\r\n    }\r\n\r\n    /**\r\n     * @dev Upgrade the backing implementation of the proxy.\r\n     * Only the admin can call this function.\r\n     * @param newImplementation Address of the new implementation.\r\n     */\r\n    function upgradeTo(address newImplementation) external ifAdmin {\r\n        _upgradeTo(newImplementation);\r\n    }\r\n\r\n    /**\r\n     * @dev Upgrade the backing implementation of the proxy and call a function\r\n     * on the new implementation.\r\n     * This is useful to initialize the proxied contract.\r\n     * @param newImplementation Address of the new implementation.\r\n     * @param data Data to send as msg.data in the low level call.\r\n     * It should include the signature and the parameters of the function to be called, as described in\r\n     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\r\n     */\r\n    function upgradeToAndCall(address newImplementation, bytes calldata data)\r\n        external\r\n        payable\r\n        ifAdmin\r\n    {\r\n        _upgradeTo(newImplementation);\r\n        (bool success, ) = newImplementation.delegatecall(data);\r\n        require(success, \"Call on new implementation failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Only fall back when the sender is not the admin.\r\n     */\r\n    function _willFallback() internal virtual override {\r\n        require(\r\n            msg.sender != ADMIN,\r\n            \"Cannot call fallback function from the proxy admin\"\r\n        );\r\n        super._willFallback();\r\n    }\r\n}\r\n"

    },

    "contracts/dependencies/openzeppelin/upgradeability/InitializableUpgradeabilityProxy.sol": {

      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.7.6;\r\n\r\nimport \"./BaseUpgradeabilityProxy.sol\";\r\n\r\n/**\r\n * @title InitializableUpgradeabilityProxy\r\n * @dev Extends BaseUpgradeabilityProxy with an initializer for initializing\r\n * implementation and init data.\r\n */\r\ncontract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {\r\n    /**\r\n     * @dev Contract initializer.\r\n     * @param _logic Address of the initial implementation.\r\n     * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\r\n     * It should include the signature and the parameters of the function to be called, as described in\r\n     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\r\n     * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\r\n     */\r\n    function initialize(address _logic, bytes memory _data) public payable {\r\n        require(_implementation() == address(0));\r\n        assert(\r\n            IMPLEMENTATION_SLOT ==\r\n                bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1)\r\n        );\r\n        _setImplementation(_logic);\r\n        if (_data.length > 0) {\r\n            (bool success, ) = _logic.delegatecall(_data);\r\n            require(success);\r\n        }\r\n    }\r\n}\r\n"

    },

    "contracts/dependencies/openzeppelin/upgradeability/BaseUpgradeabilityProxy.sol": {

      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.7.6;\r\n\r\nimport \"./Proxy.sol\";\r\nimport \"../contracts/Address.sol\";\r\n\r\n/**\r\n * @title BaseUpgradeabilityProxy\r\n * @dev This contract implements a proxy that allows to change the\r\n * implementation address to which it will delegate.\r\n * Such a change is called an implementation upgrade.\r\n */\r\ncontract BaseUpgradeabilityProxy is Proxy {\r\n    /**\r\n     * @dev Emitted when the implementation is upgraded.\r\n     * @param implementation Address of the new implementation.\r\n     */\r\n    event Upgraded(address indexed implementation);\r\n\r\n    /**\r\n     * @dev Storage slot with the address of the current implementation.\r\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\r\n     * validated in the constructor.\r\n     */\r\n    bytes32 internal constant IMPLEMENTATION_SLOT =\r\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\r\n\r\n    /**\r\n     * @dev Returns the current implementation.\r\n     * @return impl Address of the current implementation\r\n     */\r\n    function _implementation() internal view override returns (address impl) {\r\n        bytes32 slot = IMPLEMENTATION_SLOT;\r\n        //solium-disable-next-line\r\n        assembly {\r\n            impl := sload(slot)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Upgrades the proxy to a new implementation.\r\n     * @param newImplementation Address of the new implementation.\r\n     */\r\n    function _upgradeTo(address newImplementation) internal {\r\n        _setImplementation(newImplementation);\r\n        emit Upgraded(newImplementation);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the implementation address of the proxy.\r\n     * @param newImplementation Address of the new implementation.\r\n     */\r\n    function _setImplementation(address newImplementation) internal {\r\n        require(\r\n            Address.isContract(newImplementation),\r\n            \"Cannot set a proxy implementation to a non-contract address\"\r\n        );\r\n\r\n        bytes32 slot = IMPLEMENTATION_SLOT;\r\n\r\n        //solium-disable-next-line\r\n        assembly {\r\n            sstore(slot, newImplementation)\r\n        }\r\n    }\r\n}\r\n"

    },

    "contracts/dependencies/openzeppelin/upgradeability/Proxy.sol": {

      "content": "// SPDX-License-Identifier: agpl-3.0\r\npragma solidity 0.7.6;\r\n\r\n/**\r\n * @title Proxy\r\n * @dev Implements delegation of calls to other contracts, with proper\r\n * forwarding of return values and bubbling of failures.\r\n * It defines a fallback function that delegates all calls to the address\r\n * returned by the abstract _implementation() internal function.\r\n */\r\nabstract contract Proxy {\r\n    /**\r\n     * @dev Fallback function.\r\n     * Implemented entirely in `_fallback`.\r\n     */\r\n    fallback() external payable {\r\n        _fallback();\r\n    }\r\n\r\n    /**\r\n     * @return The Address of the implementation.\r\n     */\r\n    function _implementation() internal view virtual returns (address);\r\n\r\n    /**\r\n     * @dev Delegates execution to an implementation contract.\r\n     * This is a low level function that doesn't return to its internal call site.\r\n     * It will return to the external caller whatever the implementation returns.\r\n     * @param implementation Address to delegate.\r\n     */\r\n    function _delegate(address implementation) internal {\r\n        //solium-disable-next-line\r\n        assembly {\r\n            // Copy msg.data. We take full control of memory in this inline assembly\r\n            // block because it will not return to Solidity code. We overwrite the\r\n            // Solidity scratch pad at memory position 0.\r\n            calldatacopy(0, 0, calldatasize())\r\n\r\n            // Call the implementation.\r\n            // out and outsize are 0 because we don't know the size yet.\r\n            let result := delegatecall(\r\n                gas(),\r\n                implementation,\r\n                0,\r\n                calldatasize(),\r\n                0,\r\n                0\r\n            )\r\n\r\n            // Copy the returned data.\r\n            returndatacopy(0, 0, returndatasize())\r\n\r\n            switch result\r\n            // delegatecall returns 0 on error.\r\n            case 0 {\r\n                revert(0, returndatasize())\r\n            }\r\n            default {\r\n                return(0, returndatasize())\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Function that is run as the first thing in the fallback function.\r\n     * Can be redefined in derived contracts to add functionality.\r\n     * Redefinitions must call super._willFallback().\r\n     */\r\n    function _willFallback() internal virtual {}\r\n\r\n    /**\r\n     * @dev fallback implementation.\r\n     * Extracted to enable manual triggering.\r\n     */\r\n    function _fallback() internal {\r\n        _willFallback();\r\n        _delegate(_implementation());\r\n    }\r\n}\r\n"

    },

    "contracts/dependencies/openzeppelin/contracts/Address.sol": {

      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.2 <0.8.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(\r\n            address(this).balance >= amount,\r\n            \"Address: insufficient balance\"\r\n        );\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(\r\n            success,\r\n            \"Address: unable to send value, recipient may have reverted\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data)\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return\r\n            functionCallWithValue(\r\n                target,\r\n                data,\r\n                value,\r\n                \"Address: low-level call with value failed\"\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(\r\n            address(this).balance >= value,\r\n            \"Address: insufficient balance for call\"\r\n        );\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{value: value}(\r\n            data\r\n        );\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data)\r\n        internal\r\n        view\r\n        returns (bytes memory)\r\n    {\r\n        return\r\n            functionStaticCall(\r\n                target,\r\n                data,\r\n                \"Address: low-level static call failed\"\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data)\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        return\r\n            functionDelegateCall(\r\n                target,\r\n                data,\r\n                \"Address: low-level delegate call failed\"\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) private pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n"

    }

  },

  "settings": {

    "optimizer": {

      "enabled": true,

      "runs": 200

    },

    "evmVersion": "istanbul",

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "libraries": {}

  }

}}