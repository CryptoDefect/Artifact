// SPDX-License-Identifier: MIT



// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM

// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM

// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM

// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM

// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM

// MMMMMMMMMMMMMMMMMMMMMMMMMMMMWNNNNNNNNNNNNNNWMMMWNNNNWMMMMMMMMWNNNNNWMMMMMMMMMMMMMWWWMMMMMMMMMMMWNNNNNNNNNWWMMMMMMMMMMMMMMMMMMMMMMMMMMMM

// MMMMMMMMMMMMMMMMMMMMMMMMMMMMO;'''''''''''''dNMMO;''':0MMMMMMWk;''''cKMMMMMMMN0dl:;;;:cdOXWMMMMWx,'''''''',;cdONWMMMMMMMMMMMMMMMMMMMMMMM

// MMMMMMMMMMMMMMMMMMMMMMMMMMMWl    ......    ;KMWo     :XMMMMM0,     .OMMMMWKo'.          .cOWMMWl     ....    .'dXMMMMMMMMMMMMMMMMMMMMMM

// MMMMMMMMMMMMMMMMMMMMMMMMMMMX;   .dXXXXk.   '0MNc      oNMMMNc      .dMMMXo.   .;oxkxl,    .cKMWl    cKXXKOd,    ;0MMMMMMMMMMMMMMMMMMMMM

// MMMMMMMMMMMMMMMMMMMMMMMMMMMO.   '0MMMMX;   .kMK,      .kWMWx.       lWMK:    :0WMMMMMNk,    ,0Nl    oWMMMMMX:    cNMMMMMMMMMMMMMMMMMMMM

// MMMMMMMMMMMMMMMMMMMMMMMMMMWd.   :NMMMMNc    dWO.       ,KM0'        ;XX:    :XMMMMMMMMM0,    ;0l    oWMMMMMWo    :XMMMMMMMMMMMMMMMMMMMM

// MMMMMMMMMMMMMMMMMMMMMMMMMMNc    dWMMMMWo    lNx.        c0c         '0x.   .OMMMMMMMMMMMk.   .oc    oWMMMMNk.   .xWMMMMMMMMMMMMMMMMMMMM

// MMMMMMMMMMMMMMMMMMMMMMMMMMK,    'cccccc'    :Kl    ,,   .'.   ..    .xc    ;XMMMMMMMMMMMK,    cc    ,oddol,.   ,kWMMMMMMMMMMMMMMMMMMMMM

// MMMMMMMMMMMMMMMMMMMMMMMMMMk.                ,k;   .xk.       .xc    .lc    ;XMMMMMMMMMMMK,    cc            'ckNMMMMMMMMMMMMMMMMMMMMMMM

// MMMMMMMMMMMMMMMMMMMMMMMMMWo    ;xkkkkkko.   .l'   .OWd.     .oNd     co.   .kMMMMMMMMMMMk.   .xl    'l:.   .kMMMMMMMMMMMMMMMMMMMMMMMMMM

// MMMMMMMMMMMMMMMMMMMMMMMMMX:   .dWMMMMMMX:   .'.   ;KMXc     :XMk.    ;k:    ,0MMMMMMMMM0,    oXl    oWNo    cXMMMMMMMMMMMMMMMMMMMMMMMMM

// MMMMMMMMMMMMMMMMMMMMMMMMM0'   .OMMMMMMMWl         cNMMKl:::l0MM0'    '00;    'xXMMMMMNx'   .lXNl    oWMMK;   .dWMMMMMMMMMMMMMMMMMMMMMMM

// MMMMMMMMMMMMMMMMMMMMMMMMMx.   ;XMMMMMMMWd.       .dWMMMMMMMMMMMX;    .kMXl.    'codoc'    ,kNMNl    oWMMMO.   'OMMMMMMMMMMMMMMMMMMMMMMM

// MMMMMMMMMMMMMMMMMMMMMMMMWl    lNMMMMMMMMk.       .kMMMMMMMMMMMMNl     oWMW0o,.         .:kXMMMNl    oWMMMWd.   :XMMMMMMMMMMMMMMMMMMMMMM

// MMMMMMMMMMMMMMMMMMMMMMMMMNx:;;c0MMMMMMMMMXo;;;;;;;oXMMMMMMMMMMMMWOc;;;:kWMMMMN0xocc:cldOXWMMMMMWk:;;:OWMMMMXd;;;c0MMMMMMMMMMMMMMMMMMMMM

// MMMMMMMMMMMMMMMMMMMMMMMMMMMMWMMMMMMMMMMMMMMMWMWWWMMMMMMMMMMMMMMMMMMMMMWMMMMMMMMMMMMMMMMMMMMMMMMMMMWMMMMMMMMMMMWWWMMMMMMMMMMMMMMMMMMMMMM

// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM

// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM

// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM

// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM

// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM





pragma solidity 0.8.11;

import "@openzeppelin/contracts/access/Ownable.sol";

import "@openzeppelin/contracts/utils/math/SafeMath.sol";

import "@openzeppelin/contracts/utils/Address.sol";

import "@openzeppelin/contracts/utils/Strings.sol";

import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";

import "erc721a/contracts/ERC721A.sol";



contract AMOR is Ownable, ERC721A, ReentrancyGuard {

 

    using Strings for uint256;

    using SafeMath for uint256;

    // AMORLIST = WL 

    enum SaleStatus {

        PAUSED,

        AMORLIST,

        PUBLIC

    }

    // set default Pause

    SaleStatus public saleStatus = SaleStatus.PAUSED;

    bool public revealed = false; 

    string private baseTokenURI;

    string public notRevealedURI;



    bytes32 public merkleRoot;

    address private teamWallet; 

    address public royaltyAddress; // Only in unsupported marketplaces, we need to go directly to setup

    uint96 public royaltyFeesInBips;

     

    //1 ether == 1000000000000000000

    uint256 public amorListPrice = 0.0055 ether; 

    uint256 public publicPrice = 0.0088 ether; 

    uint256 private constant _TotalCollectionSize = 444;

    uint256 public MAX_PER_Address_FOR_AMOR_LIST = 1; 

    uint256 public MAX_PER_Transaction = 1; 



    // set each spots 

    uint256 private teamNFTsTaked;

    uint16 private teamLimit = 30; 

    

    uint256 private soldAmorList;

    uint256 private AmorListSpots = 300;



     

    constructor( string memory _hiddenURI, uint96 _royaltyFeesInBips, bytes32 _root, address _teamWallet) ERC721A("AMOR","AMOR")

    {

        setNotRevealedURI(_hiddenURI);

        royaltyFeesInBips = _royaltyFeesInBips;

        merkleRoot = _root;

        teamWallet = _teamWallet;

        setRoyaltyInfo(teamWallet,_royaltyFeesInBips);   

        reserveNFT(30); //if reverse and deploy same time, also opensea create same time   

    }

    

    

    modifier checkMintCount(uint256 _quantity,uint256 _price){

        require(totalSupply().add(_quantity) <= _TotalCollectionSize, "reached max supply");

        require(_quantity <= MAX_PER_Transaction, "Max per transaction exceeded");

        require(msg.value >= _price.mul(_quantity), "Need to send more ETH.");  

         _;

    }



    /* sale function start*/

    // team minting 

     function reserveNFT(uint256 quantity) public onlyOwner {

        require(totalSupply().add(quantity) <= _TotalCollectionSize, "reached max supply");

        require(teamNFTsTaked.add(quantity) <= teamLimit, "Reserve limit exceeded.");

        teamNFTsTaked = teamNFTsTaked.add(quantity);

        _safeMint(teamWallet, quantity);

    }



    

    function amorListMint(uint256 quantity, bytes32[] calldata merkleproof) public payable checkMintCount(quantity,amorListPrice){     

        require(saleStatus == SaleStatus.AMORLIST, "not start AmorList mint");

        require(isValid(merkleproof, keccak256(abi.encodePacked(msg.sender))), "Not Amor list");

        require((_numberMinted(msg.sender).add(quantity) <= MAX_PER_Address_FOR_AMOR_LIST),"Quantity exceeds allowed Mints"); 

        require(soldAmorList.add(quantity) <= AmorListSpots,"AmorList sold out");

        soldAmorList = soldAmorList.add(quantity);

        _safeMint(msg.sender, quantity);

    }



    // public sale 

    function publicMint(uint256 quantity) public payable checkMintCount(quantity,publicPrice) {

        require(saleStatus == SaleStatus.PUBLIC, "Public minting not start");

        _safeMint(msg.sender, quantity);

    }





    function supportsInterface(bytes4 interfaceId)   public view override(ERC721A) returns (bool){

        return interfaceId == 0x2a55205a || super.supportsInterface(interfaceId);

    }

        

    function isValid(bytes32[] memory merkleproof,bytes32 leaf) public view returns (bool) {

        return MerkleProof.verify(merkleproof, merkleRoot, leaf);

    }



    //get function

    function getSaleStatus() public view returns (SaleStatus){

        return saleStatus;

    }



    function getPrice(uint256 _count) public view returns(uint256){  

        if(saleStatus == SaleStatus.PUBLIC)

         return publicPrice.mul(_count);

        else

         return amorListPrice.mul(_count);

    }



    function getOwnershipData(uint256 tokenId) external view returns (TokenOwnership memory){

        return _ownershipOf(tokenId);

    }



     function _baseURI() internal view virtual override returns (string memory) {

        return baseTokenURI;

    }



    function getNumberMinted(address _address) public view returns (uint256) { 

        return _numberMinted(_address);

    }

    

    function getSoldNum() public view returns (uint256) {

       if(saleStatus == SaleStatus.AMORLIST)

         return soldAmorList;

       else 

        return 0;

    }

    function getSpots() public view returns (uint256) { 

       if(saleStatus == SaleStatus.AMORLIST)

         return AmorListSpots;

       else if(saleStatus == SaleStatus.PUBLIC)

         return _TotalCollectionSize;

       else 

        return 0;

    }



    function royaltyInfo(uint256 _salePrice) external view virtual returns (address, uint256){

        return (royaltyAddress, calculateRoyalty(_salePrice));

    }



    function calculateRoyalty(uint256 _salePrice) view public returns (uint256) {

        return (_salePrice.div(10000)).mul(royaltyFeesInBips);

    }





    //set function

    function setBaseURI(string memory baseURI) public onlyOwner {

        baseTokenURI = baseURI;

    }



    function setNotRevealedURI(string memory URI) public onlyOwner {

        notRevealedURI = URI;

    }



    function setPublicPrice(uint256 _newPrice) public onlyOwner {  

        publicPrice = _newPrice;

    }



    function setAmorListPrice(uint256 _newPrice) public onlyOwner {  

        amorListPrice = _newPrice;

    }



    function setMerkleRoot(bytes32 _merkleRoot) public onlyOwner {

        merkleRoot = _merkleRoot;

    } 



    function setAmorListLimit(uint256 _newLimit) public onlyOwner {

        AmorListSpots = _newLimit;

    }



    function setMAX_PER_Transaction(uint256 _newLimit) public onlyOwner {

        MAX_PER_Transaction = _newLimit;

    }



    function setMAX_PER_Address_FOR_AMOR_LIST(uint256 _newLimit) public onlyOwner {

        MAX_PER_Address_FOR_AMOR_LIST = _newLimit;

    }



    function setTeamWallet(address _newTeamWallet) public onlyOwner {

        teamWallet = _newTeamWallet;

    }



    function setRoyaltyInfo(address _receiver, uint96 _royaltyFeesInBips) public onlyOwner {

        royaltyAddress = _receiver;

        royaltyFeesInBips = _royaltyFeesInBips;

    }



    function setSaleStatus(SaleStatus _status) public onlyOwner {

        saleStatus = _status;

    }





    function tokenURI(uint256 tokenId) public view virtual override returns (string memory){

        require( _exists(tokenId), "ERC721Metadata: URI query for nonexistent token");

           if (revealed) {

             string memory baseURI = _baseURI();

            return bytes(baseURI).length > 0 ? string( abi.encodePacked(baseURI, tokenId.toString(),".json") ) : "";

        } else {

            return notRevealedURI;

        }

    }

    

    function reveal(string memory _uri) public onlyOwner {

        if(!revealed){

            setBaseURI(_uri);

        }

        revealed = !revealed;

    } 



    function withdraw() public onlyOwner nonReentrant { 

        (bool os, ) = payable(teamWallet).call{value: address(this).balance}("");

        require(os);

    }



    function airdrop(address beneficiary, uint256 amount) public onlyOwner {

        require(beneficiary != address(0), "Cannot airdrop to zero address");

        require(totalSupply().add(amount) <= _TotalCollectionSize, "reached max supply");

        _safeMint(beneficiary, amount);

    }

}