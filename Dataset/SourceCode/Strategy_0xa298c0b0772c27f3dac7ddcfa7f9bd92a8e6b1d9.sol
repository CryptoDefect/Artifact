{{

  "language": "Solidity",

  "sources": {

    "src/roller/Strategy.sol": {

      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\n\nimport {IStrategy} from 'src/interfaces/IStrategy.sol';\nimport {SafeERC20Namer} from 'src/erc/SafeERC20Namer.sol';\nimport {MinimalTransferHelper} from 'src/utils/MinimalTransferHelper.sol';\nimport {IERC20} from 'src/interfaces/IERC20.sol';\nimport {ERC20Permit} from 'src/erc/ERC20Permit.sol';\nimport {IFYToken} from 'src/interfaces/IFYToken.sol';\nimport {IPool} from 'src/interfaces/IPool.sol';\nimport {ILender} from 'src/interfaces/ILender.sol';\n\n/// @dev The Strategy contract allows liquidity providers to provide liquidity in yieldspace\n/// pool tokens and receive strategy tokens that represent a stake in a YieldSpace pool contract.\n/// Upon maturity, the strategy can `divest` from the mature pool, becoming a proportional\n/// ownership underlying vault. When not invested, the strategy can `invest` into a Pool using\n/// all its underlying.\n/// The strategy can also `eject` from a Pool before maturity. Any fyToken obtained will be available\n/// to be bought by anyone at face value. If the pool tokens can't be burned, they will be ejected\n/// and the strategy can be recapitalized.\ncontract Strategy is ERC20Permit, IStrategy {\n    using MinimalTransferHelper for IERC20;\n    using MinimalTransferHelper for IFYToken;\n    using MinimalTransferHelper for IPool;\n\n    event Invested(\n        address indexed pool,\n        uint256 baseInvested,\n        uint256 lpTokensObtained\n    );\n    event Divested(\n        address indexed pool,\n        uint256 lpTokenDivested,\n        uint256 baseObtained\n    );\n    event Ejected(\n        address indexed pool,\n        uint256 lpTokenDivested,\n        uint256 baseObtained,\n        uint256 fyTokenObtained\n    );\n    event Drained(address indexed pool, uint256 lpTokenDivested);\n    event SoldFYToken(uint256 soldFYToken, uint256 returnedBase);\n    event Trade(\n        address indexed sent,\n        address indexed received,\n        uint256 amountIn,\n        uint256 amountOut,\n        address receiver\n    );\n\n    address public admin; // The admin executes the transition to the next pool\n    address public lender; // The lender contract used for getting fyTokens in the invest call\n\n    State public state; // The state determines which functions are available\n\n    IERC20 public immutable base; // Base token for this strategy\n    IFYToken public fyToken; // Current fyToken for this strategy\n    uint256 public maturity; // Current maturity for this strategy\n    IPool public pool; // Current pool that this strategy invests in\n\n    uint256 public baseCached; // Base tokens held by the strategy\n    uint256 public poolCached; // Pool tokens held by the strategy\n    uint256 public fyTokenCached; // In emergencies, the strategy can keep fyToken\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        IFYToken fyToken_\n    )\n        ERC20Permit(\n            string(name_),\n            string(symbol_),\n            SafeERC20Namer.tokenDecimals(address(fyToken_))\n        )\n    {\n        // Deploy with a seriesId_ matching the migrating strategy if using the migration feature\n        // Deploy with any series matching the desired base in any other case\n        fyToken = fyToken_;\n\n        base = IERC20(fyToken_.underlying());\n\n        admin = msg.sender; // Enable the `mint` -> `init` hook.\n    }\n\n    modifier isState(State target) {\n        require(target == state, 'Not allowed in this state');\n        _;\n    }\n\n    modifier authorized(address a) {\n        require(msg.sender == a);\n        _;\n    }\n\n    /// @notice Allows for the transfer of the admin contract\n    /// @param a New admin\n    function setAdmin(address a) external authorized(admin) {\n        admin = a;\n    }\n\n    /// @notice Allows for the transfer of the lender contract\n    /// @param l New lender\n    function setLender(address l) external authorized(admin) {\n        lender = l;\n    }\n\n    /// @notice Allows the admin to approve an underlying asset for the Strategy\n    /// @param base_ The underlying asset that will be approved\n    function approveUnderlying(address base_) external authorized(admin) {\n        // Approve the lender to spend the base asset\n        IERC20(base_).approve(lender, type(uint256).max);\n    }\n\n    /// @dev State and state variable management\n    /// @param target State to transition to\n    /// @param pool_ If transitioning to invested, update pool state variable with this parameter\n    function _transition(State target, IPool pool_) internal {\n        if (target == State.INVESTED) {\n            pool = pool_;\n            fyToken = IFYToken(address(pool_.fyToken()));\n            maturity = pool_.maturity();\n        } else if (target == State.DIVESTED) {\n            delete fyToken;\n            delete maturity;\n            delete pool;\n        } else if (target == State.EJECTED) {\n            delete maturity;\n            delete pool;\n        } else if (target == State.DRAINED) {\n            delete maturity;\n            delete pool;\n        }\n        state = target;\n    }\n\n    /// @dev State and state variable management\n    /// @param target State to transition to\n    function _transition(State target) internal {\n        require(target != State.INVESTED, 'Must provide a pool');\n        _transition(target, IPool(address(0)));\n    }\n\n    // ----------------------- INVEST & DIVEST --------------------------- //\n\n    /// @dev Mint the first strategy tokens, without investing\n    /// @param to Recipient for the strategy tokens\n    /// @return minted Amount of strategy tokens minted from base tokens\n    function init(\n        address to\n    ) external authorized(admin) returns (uint256 minted) {\n        minted = _init(to);\n    }\n\n    /// @dev Mint the first strategy tokens, without investing\n    /// @param to Recipient for the strategy tokens\n    /// @return minted Amount of strategy tokens minted from base tokens\n    function _init(\n        address to\n    ) internal isState(State.DEPLOYED) returns (uint256 minted) {\n        // Clear fyToken in case we initialized through `mint`\n        delete fyToken;\n\n        baseCached = minted = base.balanceOf(address(this));\n        require(minted > 0, 'Not enough base in');\n        // Make sure that at the end of the transaction the strategy has enough tokens as to not expose itself to a rounding-down liquidity attack.\n        _mint(to, minted);\n\n        _transition(State.DIVESTED);\n    }\n\n    /// @dev Start the strategy investments in the next pool\n    /// @param pool_ Pool to invest into\n    /// @param initial_ Amount of base that will be used to call Pool::init\n    /// @param ptsToSell_ Amount of iPTs that will be sold to the pool to set a rate\n    /// @param minRatio_ Minimum ratio to use in the mint call\n    /// @param maxRatio_ Maximum ratio to use in the mint call\n    /// @param lends_ Data used to conduct lending operations in pool's new market (target is to acquire ptsToSell + ptsToMint iPTs)\n    /// @return poolTokensObtained Amount of pool tokens minted from base tokens\n    /// @notice When calling this function for the first pool, some underlying needs to be transferred to the strategy first, using a batchable router.\n    /// @notice Caller should take care to ensure that \"initial_ + [amount spent in lends_] = baseCached\" is true prior to call\n    /// @notice Caller should grant Strategy admin control of pool_ prior to calling invest\n    function invest(\n        IPool pool_,\n        uint256 initial_,\n        uint256 ptsToSell_,\n        uint256 minRatio_,\n        uint256 maxRatio_,\n        bytes[] calldata lends_\n    )\n        external\n        authorized(admin)\n        isState(State.DIVESTED)\n        returns (uint256 poolTokensObtained)\n    {\n        // Caching\n        IFYToken fyToken_ = IFYToken(address(pool_.fyToken()));\n        uint256 baseCached_ = baseCached; // We could read the real balance, but this is a bit safer\n\n        require(base == pool_.base(), 'Mismatched base');\n\n        // Mint LP tokens and initialize the pool\n        delete baseCached;\n        base.safeTransfer(address(pool_), initial_);\n        (, , poolTokensObtained) = pool_.init(address(this));\n\n        // Acquire iPTs via lending in the new market\n        ILender(lender).batch(lends_);\n\n        // Transfer the acquired tokens to the pool\n        fyToken_.transfer(address(pool_), ptsToSell_);\n\n        // Swap FY tokens for base in the new market\n        // NOTE: We sell to the pool to avoid a subsequent transfer to the pool\n        pool_.sellFYToken(address(pool_), 0);\n\n        // At this stage, the Strategy will hold iPTs (the ones not sold)\n        uint256 fyTokensRemaining = fyToken_.balanceOf(address(this));\n\n        // Transfer remaining acquired iPTs to the pool for the mint call\n        fyToken_.transfer(address(pool_), fyTokensRemaining);\n\n        // Mint at the current rate with the remaining iPTs, any excess is returned to the admin\n        (, , uint256 mintedLpTokens) = IPool(pool_).mint(\n            address(this),\n            admin,\n            minRatio_,\n            maxRatio_\n        );\n\n        // Update amount of LP tokens held by the strategy\n        poolTokensObtained += mintedLpTokens;\n        poolCached = poolTokensObtained;\n\n        // Set the pool's strategy\n        IPool(pool_).setStrategy(address(this));\n\n        // Return control of pool's admin to admin\n        pool_.setAdmin(admin);\n\n        // Update state variables\n        fyToken = fyToken_;\n        maturity = pool_.maturity();\n        pool = pool_;\n\n        _transition(State.INVESTED, pool_);\n        emit Invested(address(pool_), baseCached_, poolTokensObtained);\n    }\n\n    /// @dev Divest out of a pool once it has matured\n    /// @return baseObtained Amount of base tokens obtained from burning pool tokens\n    function divest()\n        external\n        isState(State.INVESTED)\n        returns (uint256 baseObtained)\n    {\n        // Caching\n        IPool pool_ = pool;\n        IFYToken fyToken_ = fyToken;\n        require(uint32(block.timestamp) >= maturity, 'Only after maturity');\n\n        uint256 toDivest = pool_.balanceOf(address(this));\n\n        // Burn lpTokens\n        delete poolCached;\n        pool_.safeTransfer(address(pool_), toDivest);\n        (, uint256 baseFromBurn, uint256 fyTokenFromBurn) = pool_.burn(\n            address(this),\n            address(this),\n            0,\n            type(uint256).max\n        ); // We don't care about slippage, because the strategy holds to maturity\n\n        // Redeem any fyToken\n        uint256 baseFromRedeem = fyToken_.redeem(\n            fyTokenFromBurn,\n            address(this),\n            address(this)\n        );\n\n        // Reset the base cache\n        baseCached = base.balanceOf(address(this));\n\n        // Transition to Divested\n        _transition(State.DIVESTED, pool_);\n        emit Divested(\n            address(pool_),\n            toDivest,\n            baseObtained = baseFromBurn + baseFromRedeem\n        );\n    }\n\n    // ----------------------- EJECT --------------------------- //\n\n    /// @dev Divest out of a pool at any time. If possible the pool tokens will be burnt for base and fyToken, the latter of which\n    /// must be sold to return the strategy to a functional state. If the pool token burn reverts, the pool tokens will be transferred\n    /// to the caller as a last resort.\n    /// @return baseReceived Amount of base tokens received from pool tokens\n    /// @return fyTokenReceived Amount of fyToken received from pool tokens\n    /// @notice The caller must take care of slippage when selling fyToken, if relevant.\n    function eject()\n        external\n        authorized(admin)\n        isState(State.INVESTED)\n        returns (uint256 baseReceived, uint256 fyTokenReceived)\n    {\n        // Caching\n        IPool pool_ = pool;\n        uint256 toDivest = pool_.balanceOf(address(this));\n\n        // Burn lpTokens, if not possible, eject the pool tokens out. Slippage should be managed by the caller.\n        delete poolCached;\n        try this.burnPoolTokens(pool_, toDivest) returns (\n            uint256 baseReceived_,\n            uint256 fyTokenReceived_\n        ) {\n            baseCached = baseReceived = baseReceived_;\n            fyTokenCached = fyTokenReceived = fyTokenReceived_;\n            if (fyTokenReceived > 0) {\n                _transition(State.EJECTED, pool_);\n                emit Ejected(\n                    address(pool_),\n                    toDivest,\n                    baseReceived,\n                    fyTokenReceived\n                );\n            } else {\n                _transition(State.DIVESTED, pool_);\n                emit Divested(address(pool_), toDivest, baseReceived);\n            }\n        } catch {\n            pool_.safeTransfer(msg.sender, toDivest);\n            _transition(State.DRAINED, pool_);\n            emit Drained(address(pool_), toDivest);\n        }\n    }\n\n    /// @dev Burn an amount of pool tokens.\n    /// @notice Only the Strategy itself can call this function. It is external and exists so that the transfer is reverted if the burn also reverts.\n    /// @param pool_ Pool for the pool tokens.\n    /// @param poolTokens Amount of tokens to burn.\n    /// @return baseReceived Amount of base tokens received from pool tokens\n    /// @return fyTokenReceived Amount of fyToken received from pool tokens\n    function burnPoolTokens(\n        IPool pool_,\n        uint256 poolTokens\n    ) external returns (uint256 baseReceived, uint256 fyTokenReceived) {\n        require(msg.sender == address(this), 'Unauthorized');\n\n        // Burn lpTokens\n        pool_.safeTransfer(address(pool_), poolTokens);\n        uint256 baseBalance = base.balanceOf(address(this));\n        uint256 fyTokenBalance = fyToken.balanceOf(address(this));\n        (, baseReceived, fyTokenReceived) = pool_.burn(\n            address(this),\n            address(this),\n            0,\n            type(uint256).max\n        );\n        require(\n            base.balanceOf(address(this)) - baseBalance == baseReceived,\n            'Burn failed - base'\n        );\n        require(\n            fyToken.balanceOf(address(this)) - fyTokenBalance ==\n                fyTokenReceived,\n            'Burn failed - fyToken'\n        );\n    }\n\n    /// @dev Buy ejected fyToken in the strategy at face value\n    /// @param fyTokenTo Address to send the purchased fyToken to.\n    /// @param baseTo Address to send any remaining base to.\n    /// @return soldFYToken Amount of fyToken sold.\n    /// @return returnedBase Amount of base unused and returned.\n    function buyFYToken(\n        address fyTokenTo,\n        address baseTo\n    )\n        external\n        isState(State.EJECTED)\n        returns (uint256 soldFYToken, uint256 returnedBase)\n    {\n        // Caching\n        IFYToken fyToken_ = fyToken;\n        uint256 baseCached_ = baseCached;\n        uint256 fyTokenCached_ = fyTokenCached;\n\n        uint256 baseIn = base.balanceOf(address(this)) - baseCached_;\n        (soldFYToken, returnedBase) = baseIn > fyTokenCached_\n            ? (fyTokenCached_, baseIn - fyTokenCached_)\n            : (baseIn, 0);\n\n        // Update base and fyToken cache\n        baseCached = baseCached_ + soldFYToken; // soldFYToken is base not returned\n        fyTokenCached = fyTokenCached_ -= soldFYToken;\n\n        // Transition to divested if done\n        if (fyTokenCached_ == 0) {\n            // Transition to Divested\n            _transition(State.DIVESTED);\n            emit Divested(address(0), 0, 0);\n        }\n\n        // Transfer fyToken and base (if surplus)\n        fyToken_.safeTransfer(fyTokenTo, soldFYToken);\n        if (soldFYToken < baseIn) {\n            base.safeTransfer(baseTo, baseIn - soldFYToken);\n        }\n\n        emit SoldFYToken(soldFYToken, returnedBase);\n    }\n\n    /// @dev If we drained the strategy, we can recapitalize it with base to avoid a forced migration\n    /// @return baseIn Amount of base tokens used to restart\n    function restart()\n        external\n        authorized(admin)\n        isState(State.DRAINED)\n        returns (uint256 baseIn)\n    {\n        require(\n            (baseCached = baseIn = base.balanceOf(address(this))) > 0,\n            'No base to restart'\n        );\n        _transition(State.DIVESTED);\n        emit Divested(address(0), 0, 0);\n    }\n\n    // ----------------------- MINT & BURN --------------------------- //\n\n    /// @dev Mint strategy tokens with pool tokens. It can be called only when invested.\n    /// @param to Recipient for the strategy tokens\n    /// @return minted Amount of strategy tokens minted\n    /// @notice The pool tokens that the user contributes need to have been transferred previously, using a batchable router.\n    function mint(\n        address to\n    ) external isState(State.INVESTED) returns (uint256 minted) {\n        // Caching\n        IPool pool_ = pool;\n        uint256 poolCached_ = poolCached;\n\n        // Find how much was deposited\n        uint256 deposit = pool_.balanceOf(address(this)) - poolCached_;\n\n        // Update the pool cache\n        poolCached = poolCached_ + deposit;\n\n        // Mint strategy tokens\n        minted = (_totalSupply * deposit) / poolCached_;\n        _mint(to, minted);\n\n        emit Trade(address(pool), address(this), deposit, minted, to);\n    }\n\n    /// @dev Burn strategy tokens to withdraw pool tokens. It can be called only when invested.\n    /// @param to Recipient for the pool tokens\n    /// @return poolTokensObtained Amount of pool tokens obtained\n    /// @notice The strategy tokens that the user burns need to have been transferred previously, using a batchable router.\n    function burn(\n        address to\n    ) external isState(State.INVESTED) returns (uint256 poolTokensObtained) {\n        // Caching\n        IPool pool_ = pool;\n        uint256 poolCached_ = poolCached;\n        uint256 totalSupply_ = _totalSupply;\n\n        // Burn strategy tokens\n        uint256 burnt = _balanceOf[address(this)];\n        _burn(address(this), burnt);\n\n        poolTokensObtained = (poolCached_ * burnt) / totalSupply_;\n        pool_.safeTransfer(address(to), poolTokensObtained);\n\n        // Update pool cache\n        poolCached = poolCached_ - poolTokensObtained;\n\n        emit Trade(address(this), address(pool), burnt, poolTokensObtained, to);\n    }\n\n    /// @dev Mint strategy tokens with base tokens. It can be called only when not invested and not ejected.\n    /// @param to Recipient for the strategy tokens\n    /// @return minted Amount of strategy tokens minted\n    /// @notice The base tokens that the user invests need to have been transferred previously, using a batchable router.\n    function mintDivested(\n        address to\n    ) external isState(State.DIVESTED) returns (uint256 minted) {\n        // minted = supply * value(deposit) / value(strategy)\n        uint256 baseCached_ = baseCached;\n        uint256 deposit = base.balanceOf(address(this)) - baseCached_;\n        baseCached = baseCached_ + deposit;\n\n        minted = (_totalSupply * deposit) / baseCached_;\n\n        _mint(to, minted);\n\n        emit Trade(address(base), address(this), deposit, minted, to);\n    }\n\n    /// @dev Burn strategy tokens to withdraw base tokens. It can be called when not invested and not ejected.\n    /// @param to Recipient for the base tokens\n    /// @return baseObtained Amount of base tokens obtained\n    /// @notice The strategy tokens that the user burns need to have been transferred previously, using a batchable router.\n    function burnDivested(\n        address to\n    ) external isState(State.DIVESTED) returns (uint256 baseObtained) {\n        // strategy * burnt/supply = withdrawal\n        uint256 baseCached_ = baseCached;\n        uint256 burnt = _balanceOf[address(this)];\n        baseObtained = (baseCached_ * burnt) / _totalSupply;\n        baseCached = baseCached_ - baseObtained;\n\n        _burn(address(this), burnt);\n        base.safeTransfer(to, baseObtained);\n\n        emit Trade(address(this), address(base), burnt, baseObtained, to);\n    }\n}\n"

    },

    "src/interfaces/IStrategy.sol": {

      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\n\nimport {IERC20} from 'src/interfaces/IERC20.sol';\nimport {IFYToken} from 'src/interfaces/IFYToken.sol';\nimport {IPool} from 'src/interfaces/IPool.sol';\n\n/// @dev The Strategy contract allows liquidity providers to provide liquidity in underlying\n/// and receive strategy tokens that represent a stake in a YieldSpace pool contract.\n/// Upon maturity, the strategy can `divest` from the mature pool, becoming a proportional\n/// ownership underlying vault. When not invested, the strategy can `invest` into a Pool using\n/// all its underlying.\n/// The strategy can also `eject` from a Pool before maturity, immediately converting its assets\n/// to underlying as much as possible. If any fyToken can't be exchanged for underlying, the\n/// strategy will hold them until maturity when `redeemEjected` can be used.\ninterface IStrategy {\n    enum State {\n        DEPLOYED,\n        DIVESTED,\n        INVESTED,\n        EJECTED,\n        DRAINED\n    }\n\n    function state() external view returns (State); // The state determines which functions are available\n\n    function base() external view returns (IERC20); // Base token for this strategy\n\n    function fyToken() external view returns (IFYToken); // Current fyToken for this strategy\n\n    function pool() external view returns (IPool); // Current pool that this strategy invests in\n\n    function maturity() external view returns (uint256); // Current maturity of the pool that this strategy investes in\n\n    function baseCached() external view returns (uint256); // Base tokens owned by the strategy after the last operation\n\n    function fyTokenCached() external view returns (uint256); // In emergencies, the strategy can keep fyToken of one series\n\n    function poolCached() external view returns (uint256); // Pool tokens owned by the strategy during the investment period\n\n    /// @dev Mint the first strategy tokens, without investing\n    function init(address to) external returns (uint256 minted);\n\n    /// @dev Start the strategy investments in the next pool\n    /// @notice When calling this function for the first pool, some underlying needs to be transferred to the strategy first, using a batchable router.\n    function invest(\n        IPool pool_,\n        uint256 initial_,\n        uint256 ptsToSell_,\n        uint256 minRatio_,\n        uint256 maxRatio_,\n        bytes[] calldata lends_\n    ) external returns (uint256 poolTokensObtained);\n\n    /// @dev Divest out of a pool once it has matured\n    function divest() external returns (uint256 baseObtained);\n\n    /// @dev Divest out of a pool at any time. If possible the pool tokens will be burnt for base and fyToken, the latter of which\n    /// must be sold to return the strategy to a functional state. If the pool token burn reverts, the pool tokens will be transferred\n    /// to the caller as a last resort.\n    /// @notice The caller must take care of slippage when selling fyToken, if relevant.\n    function eject()\n        external\n        returns (uint256 baseObtained, uint256 fyTokenObtained);\n\n    /// @dev Buy ejected fyToken in the strategy at face value\n    /// @param fyTokenTo Address to send the purchased fyToken to.\n    /// @param baseTo Address to send any remaining base to.\n    /// @return soldFYToken Amount of fyToken sold.\n    /// @return returnedBase Amount of base unused and returned.\n    function buyFYToken(\n        address fyTokenTo,\n        address baseTo\n    ) external returns (uint256 soldFYToken, uint256 returnedBase);\n\n    /// @dev If we ejected the pool tokens, we can recapitalize the strategy to avoid a forced migration\n    function restart() external returns (uint256 baseIn);\n\n    /// @dev Mint strategy tokens with pool tokens. It can be called only when invested.\n    /// @notice The pool tokens that the user contributes need to have been transferred previously, using a batchable router.\n    function mint(address to) external returns (uint256 minted);\n\n    /// @dev Burn strategy tokens to withdraw pool tokens. It can be called only when invested.\n    /// @notice The strategy tokens that the user burns need to have been transferred previously, using a batchable router.\n    function burn(address to) external returns (uint256 poolTokensObtained);\n\n    /// @dev Mint strategy tokens with base tokens. It can be called only when not invested and not ejected.\n    /// @notice The base tokens that the user invests need to have been transferred previously, using a batchable router.\n    function mintDivested(address to) external returns (uint256 minted);\n\n    /// @dev Burn strategy tokens to withdraw base tokens. It can be called when not invested and not ejected.\n    /// @notice The strategy tokens that the user burns need to have been transferred previously, using a batchable router.\n    function burnDivested(\n        address baseTo\n    ) external returns (uint256 baseObtained);\n\n    /// @dev Allows transfer of the admin\n    function setAdmin(address) external;\n\n    /// @dev Allows admin to set the lender\n    function setLender(address) external;\n\n    /// @dev Returns the admin\n    function admin() external view returns (address);\n\n    /// @dev Returns the lender\n    function lender() external view returns (address);\n\n    /// @dev Approves the usage of the lender's lend methods\n    function approveUnderlying(address) external;\n}\n"

    },

    "src/erc/SafeERC20Namer.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// Last audit: https://github.com/yieldprotocol/yield-utils-v2/commit/0d0b08b6b67cef6dfa69e6e6539bee542f49e25b\n// Report: https://code4rena.com/reports/2021-05-yield\n\npragma solidity >=0.5.0;\n\nimport 'src/interfaces/IERC20Metadata.sol';\nimport 'src/utils/AddressStringUtil.sol';\n\n// produces token descriptors from inconsistent or absent ERC20 symbol implementations that can return string or bytes32\n// this library will always produce a string symbol to represent the token\nlibrary SafeERC20Namer {\n    function bytes32ToString(bytes32 x) private pure returns (string memory) {\n        bytes memory bytesString = new bytes(32);\n        uint256 charCount = 0;\n        for (uint256 j = 0; j < 32; j++) {\n            bytes1 char = x[j];\n            if (char != 0) {\n                bytesString[charCount] = char;\n                charCount++;\n            }\n        }\n        bytes memory bytesStringTrimmed = new bytes(charCount);\n        for (uint256 j = 0; j < charCount; j++) {\n            bytesStringTrimmed[j] = bytesString[j];\n        }\n        return string(bytesStringTrimmed);\n    }\n\n    // assumes the data is in position 2\n    function parseStringData(\n        bytes memory b\n    ) private pure returns (string memory) {\n        uint256 charCount = 0;\n        // first parse the charCount out of the data\n        for (uint256 i = 32; i < 64; i++) {\n            charCount <<= 8;\n            charCount += uint8(b[i]);\n        }\n\n        bytes memory bytesStringTrimmed = new bytes(charCount);\n        for (uint256 i = 0; i < charCount; i++) {\n            bytesStringTrimmed[i] = b[i + 64];\n        }\n\n        return string(bytesStringTrimmed);\n    }\n\n    // uses a heuristic to produce a token name from the address\n    // the heuristic returns the full hex of the address string in upper case\n    function addressToName(address token) private pure returns (string memory) {\n        return AddressStringUtil.toAsciiString(token, 40);\n    }\n\n    // uses a heuristic to produce a token symbol from the address\n    // the heuristic returns the first 6 hex of the address string in upper case\n    function addressToSymbol(\n        address token\n    ) private pure returns (string memory) {\n        return AddressStringUtil.toAsciiString(token, 6);\n    }\n\n    // calls an external view token contract method that returns a symbol or name, and parses the output into a string\n    function callAndParseStringReturn(\n        address token,\n        bytes4 selector\n    ) private view returns (string memory) {\n        (bool success, bytes memory data) = token.staticcall(\n            abi.encodeWithSelector(selector)\n        );\n        // if not implemented, or returns empty data, return empty string\n        if (!success || data.length == 0) {\n            return '';\n        }\n        // bytes32 data always has length 32\n        if (data.length == 32) {\n            bytes32 decoded = abi.decode(data, (bytes32));\n            return bytes32ToString(decoded);\n        } else if (data.length > 64) {\n            return abi.decode(data, (string));\n        }\n        return '';\n    }\n\n    // attempts to extract the token symbol. if it does not implement symbol, returns a symbol derived from the address\n    function tokenSymbol(address token) public view returns (string memory) {\n        string memory symbol = callAndParseStringReturn(\n            token,\n            IERC20Metadata.symbol.selector\n        );\n        if (bytes(symbol).length == 0) {\n            // fallback to 6 uppercase hex of address\n            return addressToSymbol(token);\n        }\n        return symbol;\n    }\n\n    // attempts to extract the token name. if it does not implement name, returns a name derived from the address\n    function tokenName(address token) public view returns (string memory) {\n        string memory name = callAndParseStringReturn(\n            token,\n            IERC20Metadata.name.selector\n        );\n        if (bytes(name).length == 0) {\n            // fallback to full hex of address\n            return addressToName(token);\n        }\n        return name;\n    }\n\n    /// @notice Provides a safe ERC20.decimals version which returns '0' as fallback value.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (uint8) Token decimals.\n    function tokenDecimals(address token) public view returns (uint8) {\n        (bool success, bytes memory data) = token.staticcall(\n            abi.encodeWithSelector(IERC20Metadata.decimals.selector)\n        );\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 0;\n    }\n}\n"

    },

    "src/utils/MinimalTransferHelper.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// Taken from https://github.com/Uniswap/uniswap-lib/blob/master/contracts/libraries/TransferHelper.sol\n\npragma solidity >=0.6.0;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"./RevertMsgExtractor.sol\";\n\n\n// helper methods for transferring ERC20 tokens that do not consistently return true/false\nlibrary MinimalTransferHelper {\n    /// @notice Transfers tokens from msg.sender to a recipient\n    /// @dev Errors with the base revert message if transfer fails\n    /// @param token The contract address of the token which will be transferred\n    /// @param to The recipient of the transfer\n    /// @param value The value of the transfer\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n        if (!(success && (data.length == 0 || abi.decode(data, (bool))))) revert(RevertMsgExtractor.getRevertMsg(data));\n    }\n}"

    },

    "src/interfaces/IERC20.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the number of decimals the token uses\n     */\n    function decimals() external view returns (uint8);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(\n        address owner,\n        address spender\n    ) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"

    },

    "src/erc/ERC20Permit.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// AdaFYTokened from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/53516bc555a454862470e7860a9b5254db4d00f5/contracts/token/ERC20/ERC20Permit.sol\npragma solidity ^0.8.0;\n\nimport './ERC20.sol';\nimport '../interfaces/IERC2612.sol';\n\n/**\n * @dev Extension of {ERC20} that allows token holders to use their tokens\n * without sending any transactions by setting {IERC20-allowance} with a\n * signature using the {permit} method, and then spend them via\n * {IERC20-transferFrom}.\n *\n * The {permit} signature mechanism conforms to the {IERC2612} interface.\n */\nabstract contract ERC20Permit is ERC20, IERC2612 {\n    mapping(address => uint256) public override nonces;\n\n    bytes32 public immutable PERMIT_TYPEHASH =\n        keccak256(\n            'Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)'\n        );\n    bytes32 private immutable _DOMAIN_SEPARATOR;\n    uint256 public immutable deploymentChainId;\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) ERC20(name_, symbol_, decimals_) {\n        deploymentChainId = block.chainid;\n        _DOMAIN_SEPARATOR = _calculateDomainSeparator(block.chainid);\n    }\n\n    /// @dev Calculate the DOMAIN_SEPARATOR.\n    function _calculateDomainSeparator(\n        uint256 chainId\n    ) private view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        'EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'\n                    ),\n                    keccak256(bytes(name)),\n                    keccak256(bytes(version())),\n                    chainId,\n                    address(this)\n                )\n            );\n    }\n\n    /// @dev Return the DOMAIN_SEPARATOR.\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return\n            block.chainid == deploymentChainId\n                ? _DOMAIN_SEPARATOR\n                : _calculateDomainSeparator(block.chainid);\n    }\n\n    /// @dev Setting the version as a function so that it can be overriden\n    function version() public pure virtual returns (string memory) {\n        return '1';\n    }\n\n    /**\n     * @dev See {IERC2612-permit}.\n     *\n     * In cases where the free oFYTokenion is not a concern, deadline can simply be\n     * set to uint(-1), so it should be seen as an oFYTokenional parameter\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external virtual override {\n        require(deadline >= block.timestamp, 'ERC20Permit: expired deadline');\n\n        bytes32 hashStruct = keccak256(\n            abi.encode(\n                PERMIT_TYPEHASH,\n                owner,\n                spender,\n                amount,\n                nonces[owner]++,\n                deadline\n            )\n        );\n\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                '\\x19\\x01',\n                block.chainid == deploymentChainId\n                    ? _DOMAIN_SEPARATOR\n                    : _calculateDomainSeparator(block.chainid),\n                hashStruct\n            )\n        );\n\n        address signer = ecrecover(hash, v, r, s);\n        require(\n            signer != address(0) && signer == owner,\n            'ERC20Permit: invalid signature'\n        );\n\n        _setAllowance(owner, spender, amount);\n    }\n}\n"

    },

    "src/interfaces/IFYToken.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport './IERC20.sol';\nimport './IERC5095.sol';\nimport './IJoin.sol';\n\ninterface IFYToken is IERC20, IERC5095 {\n    /// @dev Asset that is returned on redemption.\n    function base() external view returns (address);\n\n    /// @dev Source of redemption funds.\n    function join() external view returns (IJoin);\n\n    /// @dev Unix time at which redemption of FYToken for base are possible\n    function maturity() external view returns (uint256);\n\n    /// @dev Record price data at maturity\n    function mature() external;\n\n    /// @dev Mint FYToken providing an equal amount of base to the protocol\n    function mintWithbase(address to, uint256 amount) external;\n\n    /// @dev Burn FYToken after maturity for an amount of base.\n    function redeem(address to, uint256 amount) external returns (uint256);\n\n    /// @dev Mint FYToken.\n    /// This function can only be called by other Yield contracts, not users directly.\n    /// @param to Wallet to mint the FYToken in.\n    /// @param FYTokenAmount Amount of FYToken to mint.\n    function mint(address to, uint256 FYTokenAmount) external;\n\n    /// @dev Burn FYToken.\n    /// This function can only be called by other Yield contracts, not users directly.\n    /// @param from Wallet to burn the FYToken from.\n    /// @param FYTokenAmount Amount of FYToken to burn.\n    function burn(address from, uint256 FYTokenAmount) external;\n}\n"

    },

    "src/interfaces/IPool.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\nimport {IERC20} from './IERC20.sol';\nimport {IERC2612} from './IERC2612.sol';\nimport {IFYToken} from './IFYToken.sol';\nimport {IMaturingToken} from './IMaturingToken.sol';\nimport {IERC20Metadata} from '../erc/ERC20.sol';\nimport {IERC20Like} from './IERC20Like.sol';\n\ninterface IPool is IERC20, IERC2612 {\n    function baseToken() external view returns (IERC20Like);\n\n    function base() external view returns (IERC20);\n\n    function burn(\n        address baseTo,\n        address fyTokenTo,\n        uint256 minRatio,\n        uint256 maxRatio\n    ) external returns (uint256, uint256, uint256);\n\n    function burnForBase(\n        address to,\n        uint256 minRatio,\n        uint256 maxRatio\n    ) external returns (uint256, uint256);\n\n    function buyBase(\n        address to,\n        uint128 baseOut,\n        uint128 max\n    ) external returns (uint128);\n\n    function buyBasePreview(uint128 baseOut) external view returns (uint128);\n\n    function buyFYToken(\n        address to,\n        uint128 fyTokenOut,\n        uint128 max\n    ) external returns (uint128);\n\n    function buyFYTokenPreview(\n        uint128 fyTokenOut\n    ) external view returns (uint128);\n\n    function currentCumulativeRatio()\n        external\n        view\n        returns (\n            uint256 currentCumulativeRatio_,\n            uint256 blockTimestampCurrent\n        );\n\n    function cumulativeRatioLast() external view returns (uint256);\n\n    function fyToken() external view returns (IMaturingToken);\n\n    function g1() external view returns (int128);\n\n    function g2() external view returns (int128);\n\n    function getC() external view returns (int128);\n\n    function getCurrentSharePrice() external view returns (uint256);\n\n    function getCache()\n        external\n        view\n        returns (\n            uint104 baseCached,\n            uint104 fyTokenCached,\n            uint32 blockTimestampLast,\n            uint16 g1Fee_\n        );\n\n    function getBaseBalance() external view returns (uint128);\n\n    function getFYTokenBalance() external view returns (uint128);\n\n    function getSharesBalance() external view returns (uint128);\n\n    function init(address to) external returns (uint256, uint256, uint256);\n\n    function maturity() external view returns (uint32);\n\n    function mint(\n        address to,\n        address remainder,\n        uint256 minRatio,\n        uint256 maxRatio\n    ) external returns (uint256, uint256, uint256);\n\n    function mu() external view returns (int128);\n\n    function mintWithBase(\n        address to,\n        address remainder,\n        uint256 fyTokenToBuy,\n        uint256 minRatio,\n        uint256 maxRatio\n    ) external returns (uint256, uint256, uint256);\n\n    function retrieveBase(address to) external returns (uint128 retrieved);\n\n    function retrieveFYToken(address to) external returns (uint128 retrieved);\n\n    function retrieveShares(address to) external returns (uint128 retrieved);\n\n    function scaleFactor() external view returns (uint96);\n\n    function sellBase(address to, uint128 min) external returns (uint128);\n\n    function sellBasePreview(uint128 baseIn) external view returns (uint128);\n\n    function sellFYToken(address to, uint128 min) external returns (uint128);\n\n    function sellFYTokenPreview(\n        uint128 fyTokenIn\n    ) external view returns (uint128);\n\n    function setFees(uint16 g1Fee_) external;\n\n    function sharesToken() external view returns (IERC20Like);\n\n    function ts() external view returns (int128);\n\n    function wrap(address receiver) external returns (uint256 shares);\n\n    function wrapPreview(uint256 assets) external view returns (uint256 shares);\n\n    function unwrap(address receiver) external returns (uint256 assets);\n\n    function unwrapPreview(\n        uint256 shares\n    ) external view returns (uint256 assets);\n\n    /// Returns the max amount of FYTokens that can be sold to the pool\n    function maxFYTokenIn() external view returns (uint128);\n\n    /// Returns the max amount of FYTokens that can be bought from the pool\n    function maxFYTokenOut() external view returns (uint128);\n\n    /// Returns the max amount of Base that can be sold to the pool\n    function maxBaseIn() external view returns (uint128);\n\n    /// Returns the max amount of Base that can be bought from the pool\n    function maxBaseOut() external view returns (uint128);\n\n    /// Returns the result of the total supply invariant function\n    function invariant() external view returns (uint128);\n\n    /// Sets the pool's admin\n    function setAdmin(address) external;\n\n    /// Returns the admin\n    function admin() external view returns (address);\n\n    /// Sets the pool's strategy\n    function setStrategy(address) external;\n\n    /// Returns the pool's strategy\n    function strategy() external view returns (address);\n\n    /// Pauses the pool\n    function pause(bool) external;\n\n    /// Returns whether the pool is paused or not\n    function paused() external view returns (bool);\n}\n"

    },

    "src/interfaces/ILender.sol": {

      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\n\ninterface ILender {\n    function batch(\n        bytes[] calldata c\n    ) external payable returns (bytes[] memory results);\n\n    function approve(address, uint256, address) external returns (bool);\n}\n"

    },

    "src/interfaces/IERC20Metadata.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// Taken from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/IERC20Metadata.sol\n\npragma solidity ^0.8.0;\n\nimport './IERC20.sol';\n\n/**\n * @dev Interface for the oFYTokenional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"

    },

    "src/utils/AddressStringUtil.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\nlibrary AddressStringUtil {\n    // converts an address to the uppercase hex string, extracting only len bytes (up to 20, multiple of 2)\n    function toAsciiString(\n        address addr,\n        uint256 len\n    ) internal pure returns (string memory) {\n        require(\n            len % 2 == 0 && len > 0 && len <= 40,\n            'AddressStringUtil: INVALID_LEN'\n        );\n        bytes memory s = new bytes(len);\n        uint256 addrNum = uint256(uint160(addr));\n        for (uint256 ii = 0; ii < len; ii += 2) {\n            uint8 b = uint8(addrNum >> (4 * (38 - ii)));\n            s[ii] = char(b >> 4);\n            s[ii + 1] = char(b & 0x0f);\n        }\n        return string(s);\n    }\n\n    // hi and lo are only 4 bits and between 0 and 16\n    // this method converts those values to the unicode/ascii code point for the hex representation\n    // uses upper case for the characters\n    function char(uint8 b) private pure returns (bytes1 c) {\n        if (b < 10) {\n            return bytes1(b + 0x30);\n        } else {\n            return bytes1(b + 0x37);\n        }\n    }\n}\n"

    },

    "src/utils/RevertMsgExtractor.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// Taken from https://github.com/sushiswap/BoringSolidity/blob/441e51c0544cf2451e6116fe00515e71d7c42e2c/contracts/BoringBatchable.sol\n\npragma solidity >=0.6.0;\n\n\nlibrary RevertMsgExtractor {\n    /// @dev Helper function to extract a useful revert message from a failed call.\n    /// If the returned data is malformed or not correctly abi encoded then this call can fail itself.\n    function getRevertMsg(bytes memory returnData)\n        internal pure\n        returns (string memory)\n    {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (returnData.length < 68) return \"Transaction reverted silently\";\n\n        assembly {\n            // Slice the sighash.\n            returnData := add(returnData, 0x04)\n        }\n        return abi.decode(returnData, (string)); // All that remains is the revert string\n    }\n}"

    },

    "src/erc/ERC20.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// Inspired on token.sol from DappHub. Natspec adpated from OpenZeppelin.\n\npragma solidity ^0.8.0;\nimport '../interfaces/IERC20Metadata.sol';\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Calls to {transferFrom} do not check for allowance if the caller is the owner\n * of the funds. This allows to reduce the number of approvals that are necessary.\n *\n * Finally, {transferFrom} does not decrease the allowance if it is set to\n * type(uint256).max. This reduces the gas costs without any likely impact.\n */\ncontract ERC20 is IERC20Metadata {\n    uint256 internal _totalSupply;\n    mapping(address => uint256) internal _balanceOf;\n    mapping(address => mapping(address => uint256)) internal _allowance;\n    string public override name = '???';\n    string public override symbol = '???';\n    uint8 public override decimals = 18;\n\n    /**\n     *  @dev Sets the values for {name}, {symbol} and {decimals}.\n     */\n    constructor(string memory name_, string memory symbol_, uint8 decimals_) {\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() external view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(\n        address guy\n    ) external view virtual override returns (uint256) {\n        return _balanceOf[guy];\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(\n        address owner,\n        address spender\n    ) external view virtual override returns (uint256) {\n        return _allowance[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     */\n    function approve(\n        address spender,\n        uint wad\n    ) external virtual override returns (bool) {\n        return _setAllowance(msg.sender, spender, wad);\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - the caller must have a balance of at least `wad`.\n     */\n    function transfer(\n        address dst,\n        uint wad\n    ) external virtual override returns (bool) {\n        return _transfer(msg.sender, dst, wad);\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `src` must have a balance of at least `wad`.\n     * - the caller is not `src`, it must have allowance for ``src``'s tokens of at least\n     * `wad`.\n     */\n    /// if_succeeds {:msg \"TransferFrom - decrease allowance\"} msg.sender != src ==> old(_allowance[src][msg.sender]) >= wad;\n    function transferFrom(\n        address src,\n        address dst,\n        uint wad\n    ) external virtual override returns (bool) {\n        _decreaseAllowance(src, wad);\n\n        return _transfer(src, dst, wad);\n    }\n\n    /**\n     * @dev Moves tokens `wad` from `src` to `dst`.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `src` must have a balance of at least `amount`.\n     */\n    /// if_succeeds {:msg \"Transfer - src decrease\"} old(_balanceOf[src]) >= _balanceOf[src];\n    /// if_succeeds {:msg \"Transfer - dst increase\"} _balanceOf[dst] >= old(_balanceOf[dst]);\n    /// if_succeeds {:msg \"Transfer - supply\"} old(_balanceOf[src]) + old(_balanceOf[dst]) == _balanceOf[src] + _balanceOf[dst];\n    function _transfer(\n        address src,\n        address dst,\n        uint wad\n    ) internal virtual returns (bool) {\n        require(_balanceOf[src] >= wad, 'ERC20: Insufficient balance');\n        unchecked {\n            _balanceOf[src] = _balanceOf[src] - wad;\n        }\n        _balanceOf[dst] = _balanceOf[dst] + wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n\n    /**\n     * @dev Sets the allowance granted to `spender` by `owner`.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     */\n    function _setAllowance(\n        address owner,\n        address spender,\n        uint wad\n    ) internal virtual returns (bool) {\n        _allowance[owner][spender] = wad;\n        emit Approval(owner, spender, wad);\n\n        return true;\n    }\n\n    /**\n     * @dev Decreases the allowance granted to the caller by `src`, unless src == msg.sender or _allowance[src][msg.sender] == MAX\n     *\n     * Emits an {Approval} event indicating the updated allowance, if the allowance is updated.\n     *\n     * Requirements:\n     *\n     * - `spender` must have allowance for the caller of at least\n     * `wad`, unless src == msg.sender\n     */\n    /// if_succeeds {:msg \"Decrease allowance - underflow\"} old(_allowance[src][msg.sender]) <= _allowance[src][msg.sender];\n    function _decreaseAllowance(\n        address src,\n        uint wad\n    ) internal virtual returns (bool) {\n        if (src != msg.sender) {\n            uint256 allowed = _allowance[src][msg.sender];\n            if (allowed != type(uint).max) {\n                require(allowed >= wad, 'ERC20: Insufficient approval');\n                unchecked {\n                    _setAllowance(src, msg.sender, allowed - wad);\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /** @dev Creates `wad` tokens and assigns them to `dst`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     */\n    /// if_succeeds {:msg \"Mint - balance overflow\"} old(_balanceOf[dst]) >= _balanceOf[dst];\n    /// if_succeeds {:msg \"Mint - supply overflow\"} old(_totalSupply) >= _totalSupply;\n    function _mint(address dst, uint wad) internal virtual returns (bool) {\n        _balanceOf[dst] = _balanceOf[dst] + wad;\n        _totalSupply = _totalSupply + wad;\n        emit Transfer(address(0), dst, wad);\n\n        return true;\n    }\n\n    /**\n     * @dev Destroys `wad` tokens from `src`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `src` must have at least `wad` tokens.\n     */\n    /// if_succeeds {:msg \"Burn - balance underflow\"} old(_balanceOf[src]) <= _balanceOf[src];\n    /// if_succeeds {:msg \"Burn - supply underflow\"} old(_totalSupply) <= _totalSupply;\n    function _burn(address src, uint wad) internal virtual returns (bool) {\n        unchecked {\n            require(_balanceOf[src] >= wad, 'ERC20: Insufficient balance');\n            _balanceOf[src] = _balanceOf[src] - wad;\n            _totalSupply = _totalSupply - wad;\n            emit Transfer(src, address(0), wad);\n        }\n\n        return true;\n    }\n}\n"

    },

    "src/interfaces/IERC2612.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// Code adaFYTokened from https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2237/\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC2612 standard as defined in the EIP.\n *\n * Adds the {permit} method, which can be used to change one's\n * {IERC20-allowance} without having to send a transaction, by signing a\n * message. This allows users to spend tokens without having to hold Ether.\n *\n * See https://eips.ethereum.org/EIPS/eip-2612.\n */\ninterface IERC2612 {\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\n     * given `owner`'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n}\n"

    },

    "src/interfaces/IERC5095.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.16;\n\nimport 'src/interfaces/IERC2612.sol';\n\ninterface IERC5095 is IERC2612 {\n    function maturity() external view returns (uint256);\n\n    function underlying() external view returns (address);\n\n    function convertToUnderlying(uint256) external view returns (uint256);\n\n    function convertToShares(uint256) external view returns (uint256);\n\n    function maxRedeem(address) external view returns (uint256);\n\n    function previewRedeem(uint256) external view returns (uint256);\n\n    function maxWithdraw(address) external view returns (uint256);\n\n    function previewWithdraw(uint256) external view returns (uint256);\n\n    function previewDeposit(uint256) external view returns (uint256);\n\n    function withdraw(uint256, address, address) external returns (uint256);\n\n    function redeem(uint256, address, address) external returns (uint256);\n\n    function deposit(uint256, address) external returns (uint256);\n\n    function mint(uint256, address) external returns (uint256);\n\n    function authMint(address, uint256) external returns (bool);\n\n    function authBurn(address, uint256) external returns (bool);\n\n    function authApprove(address, address, uint256) external returns (bool);\n}\n"

    },

    "src/interfaces/IJoin.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport './IERC20.sol';\n\ninterface IJoin {\n    /// @dev asset managed by this contract\n    function asset() external view returns (address);\n\n    /// @dev Add tokens to this contract.\n    function join(address user, uint128 wad) external returns (uint128);\n\n    /// @dev Remove tokens to this contract.\n    function exit(address user, uint128 wad) external returns (uint128);\n}\n"

    },

    "src/interfaces/IMaturingToken.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15;\nimport './IERC20.sol';\n\ninterface IMaturingToken is IERC20 {\n    function maturity() external view returns (uint256);\n}\n"

    },

    "src/interfaces/IERC20Like.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.15;\nimport './IERC20Metadata.sol';\nimport './IERC20.sol';\n\ninterface IERC20Like is IERC20, IERC20Metadata {\n    function mint(address receiver, uint256 shares) external;\n}\n"

    }

  },

  "settings": {

    "remappings": [

      "ds-test/=lib/forge-std/lib/ds-test/src/",

      "forge-std/=lib/forge-std/src/"

    ],

    "optimizer": {

      "enabled": true,

      "runs": 200

    },

    "metadata": {

      "bytecodeHash": "ipfs"

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "evmVersion": "london",

    "libraries": {

      "src/erc/SafeERC20Namer.sol": {

        "SafeERC20Namer": "0xbafaab7b9aaa6b400d6023b90114d3d2368d31cb"

      }

    }

  }

}}