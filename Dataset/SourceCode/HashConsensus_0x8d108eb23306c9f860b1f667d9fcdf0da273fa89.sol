{{

  "language": "Solidity",

  "sources": {

    "@openzeppelin/contracts-v4.4/access/IAccessControl.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"

    },

    "@openzeppelin/contracts-v4.4/access/IAccessControlEnumerable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"

    },

    "@openzeppelin/contracts-v4.4/utils/Context.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"

    },

    "@openzeppelin/contracts-v4.4/utils/introspection/ERC165.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"

    },

    "@openzeppelin/contracts-v4.4/utils/introspection/IERC165.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"

    },

    "@openzeppelin/contracts-v4.4/utils/math/SafeCast.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"

    },

    "@openzeppelin/contracts-v4.4/utils/Strings.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"

    },

    "@openzeppelin/contracts-v4.4/utils/structs/EnumerableSet.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"

    },

    "contracts/0.8.9/lib/Math.sol": {

      "content": "// SPDX-FileCopyrightText: 2023 Lido <info@lido.fi>\n// SPDX-License-Identifier: MIT\n\n// See contracts/COMPILERS.md\npragma solidity 0.8.9;\n\nlibrary Math {\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /// @notice Tests if x ∈ [a, b) (mod n)\n    ///\n    function pointInHalfOpenIntervalModN(uint256 x, uint256 a, uint256 b, uint256 n)\n        internal pure returns (bool)\n    {\n        return (x + n - a) % n < (b - a) % n;\n    }\n\n    /// @notice Tests if x ∈ [a, b] (mod n)\n    ///\n    function pointInClosedIntervalModN(uint256 x, uint256 a, uint256 b, uint256 n)\n        internal pure returns (bool)\n    {\n        return (x + n - a) % n <= (b - a) % n;\n    }\n}\n"

    },

    "contracts/0.8.9/oracle/HashConsensus.sol": {

      "content": "// SPDX-FileCopyrightText: 2023 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.9;\n\nimport { SafeCast } from \"@openzeppelin/contracts-v4.4/utils/math/SafeCast.sol\";\n\nimport { Math } from \"../lib/Math.sol\";\nimport { AccessControlEnumerable } from \"../utils/access/AccessControlEnumerable.sol\";\n\n\n/// @notice A contract that gets consensus reports (i.e. hashes) pushed to and processes them\n/// asynchronously.\n///\n/// HashConsensus doesn't expect any specific behavior from a report processor, and guarantees\n/// the following:\n///\n/// 1. HashConsensus won't submit reports via `IReportAsyncProcessor.submitConsensusReport` or ask\n///    to discard reports via `IReportAsyncProcessor.discardConsensusReport` for any slot up to (and\n///    including) the slot returned from `IReportAsyncProcessor.getLastProcessingRefSlot`.\n///\n/// 2. HashConsensus won't accept member reports (and thus won't include such reports in calculating\n///    the consensus) that have `consensusVersion` argument of the `HashConsensus.submitReport` call\n///    holding a diff. value than the one returned from `IReportAsyncProcessor.getConsensusVersion()`\n///    at the moment of the `HashConsensus.submitReport` call.\n///\ninterface IReportAsyncProcessor {\n    /// @notice Submits a consensus report for processing.\n    ///\n    /// Note that submitting the report doesn't require the processor to start processing it right\n    /// away, this can happen later (see `getLastProcessingRefSlot`). Until processing is started,\n    /// HashConsensus is free to reach consensus on another report for the same reporting frame an\n    /// submit it using this same function, or to lose the consensus on the submitted report,\n    /// notifying the processor via `discardConsensusReport`.\n    ///\n    function submitConsensusReport(bytes32 report, uint256 refSlot, uint256 deadline) external;\n\n    /// @notice Notifies that the report for the given ref. slot is not a conensus report anymore\n    /// and should be discarded. This can happen when a member changes their report, is removed\n    /// from the set, or when the quorum value gets increased.\n    ///\n    /// Only called when, for the given reference slot:\n    ///\n    ///   1. there previously was a consensus report; AND\n    ///   1. processing of the consensus report hasn't started yet; AND\n    ///   2. report processing deadline is not expired yet; AND\n    ///   3. there's no consensus report now (otherwise, `submitConsensusReport` is called instead).\n    ///\n    /// Can be called even when there's no submitted non-discarded consensus report for the current\n    /// reference slot, i.e. can be called multiple times in succession.\n    ///\n    function discardConsensusReport(uint256 refSlot) external;\n\n    /// @notice Returns the last reference slot for which processing of the report was started.\n    ///\n    /// HashConsensus won't submit reports for any slot less than or equal to this slot.\n    ///\n    function getLastProcessingRefSlot() external view returns (uint256);\n\n    /// @notice Returns the current consensus version.\n    ///\n    /// Consensus version must change every time consensus rules change, meaning that\n    /// an oracle looking at the same reference slot would calculate a different hash.\n    ///\n    /// HashConsensus won't accept member reports any consensus version different form the\n    /// one returned from this function.\n    ///\n    function getConsensusVersion() external view returns (uint256);\n}\n\n\n/// @notice A contract managing oracle members committee and allowing the members to reach\n/// consensus on a hash for each reporting frame.\n///\n/// Time is divided in frames of equal length, each having reference slot and processing\n/// deadline. Report data must be gathered by looking at the world state at the moment of\n/// the frame's reference slot (including any state changes made in that slot), and must\n/// be processed before the frame's processing deadline.\n///\n/// Frame length is defined in Ethereum consensus layer epochs. Reference slot for each\n/// frame is set to the last slot of the epoch preceding the frame's first epoch. The\n/// processing deadline is set to the last slot of the last epoch of the frame.\n///\n/// This means that all state changes a report processing could entail are guaranteed to be\n/// observed while gathering data for the next frame's report. This is an important property\n/// given that oracle reports sometimes have to contain diffs instead of the full state which\n/// might be impractical or even impossible to transmit and process.\n///\ncontract HashConsensus is AccessControlEnumerable {\n    using SafeCast for uint256;\n\n    error InvalidChainConfig();\n    error NumericOverflow();\n    error AdminCannotBeZero();\n    error ReportProcessorCannotBeZero();\n    error DuplicateMember();\n    error AddressCannotBeZero();\n    error InitialEpochIsYetToArrive();\n    error InitialEpochAlreadyArrived();\n    error InitialEpochRefSlotCannotBeEarlierThanProcessingSlot();\n    error EpochsPerFrameCannotBeZero();\n    error NonMember();\n    error UnexpectedConsensusVersion(uint256 expected, uint256 received);\n    error QuorumTooSmall(uint256 minQuorum, uint256 receivedQuorum);\n    error InvalidSlot();\n    error DuplicateReport();\n    error EmptyReport();\n    error StaleReport();\n    error NonFastLaneMemberCannotReportWithinFastLaneInterval();\n    error NewProcessorCannotBeTheSame();\n    error ConsensusReportAlreadyProcessing();\n    error FastLanePeriodCannotBeLongerThanFrame();\n\n    event FrameConfigSet(uint256 newInitialEpoch, uint256 newEpochsPerFrame);\n    event FastLaneConfigSet(uint256 fastLaneLengthSlots);\n    event MemberAdded(address indexed addr, uint256 newTotalMembers, uint256 newQuorum);\n    event MemberRemoved(address indexed addr, uint256 newTotalMembers, uint256 newQuorum);\n    event QuorumSet(uint256 newQuorum, uint256 totalMembers, uint256 prevQuorum);\n    event ReportReceived(uint256 indexed refSlot, address indexed member, bytes32 report);\n    event ConsensusReached(uint256 indexed refSlot, bytes32 report, uint256 support);\n    event ConsensusLost(uint256 indexed refSlot);\n    event ReportProcessorSet(address indexed processor, address indexed prevProcessor);\n\n    struct FrameConfig {\n        uint64 initialEpoch;\n        uint64 epochsPerFrame;\n        uint64 fastLaneLengthSlots;\n    }\n\n    /// @dev Oracle reporting is divided into frames, each lasting the same number of slots.\n    ///\n    /// The start slot of the next frame is always the next slot after the end slot of the previous\n    /// frame.\n    ///\n    /// Each frame also has a reference slot: if the oracle report contains any data derived from\n    /// onchain data, the onchain data should be sampled at the reference slot.\n    ///\n    struct ConsensusFrame {\n        // frame index; increments by 1 with each frame but resets to zero on frame size change\n        uint256 index;\n        // the slot at which to read the state around which consensus is being reached;\n        // if the slot contains a block, the state should include all changes from that block\n        uint256 refSlot;\n        // the last slot at which a report can be reported and processed\n        uint256 reportProcessingDeadlineSlot;\n    }\n\n    struct ReportingState {\n        // the last reference slot any report was received for\n        uint64 lastReportRefSlot;\n        // the last reference slot a consensus was reached for\n        uint64 lastConsensusRefSlot;\n        // the last consensus variant index\n        uint64 lastConsensusVariantIndex;\n    }\n\n    struct MemberState {\n        // the last reference slot a report from this member was received for\n        uint64 lastReportRefSlot;\n        // the variant index of the last report from this member\n        uint64 lastReportVariantIndex;\n    }\n\n    struct ReportVariant {\n        // the reported hash\n        bytes32 hash;\n        // how many unique members from the current set reported this hash in the current frame\n        uint64 support;\n    }\n\n    /// @notice An ACL role granting the permission to modify members list members and\n    /// change the quorum by calling addMember, removeMember, and setQuorum functions.\n    bytes32 public constant MANAGE_MEMBERS_AND_QUORUM_ROLE =\n        keccak256(\"MANAGE_MEMBERS_AND_QUORUM_ROLE\");\n\n    /// @notice An ACL role granting the permission to disable the consensus by calling\n    /// the disableConsensus function. Enabling the consensus back requires the possession\n    /// of the MANAGE_QUORUM_ROLE.\n    bytes32 public constant DISABLE_CONSENSUS_ROLE = keccak256(\"DISABLE_CONSENSUS_ROLE\");\n\n    /// @notice An ACL role granting the permission to change reporting interval duration\n    /// and fast lane reporting interval length by calling setFrameConfig.\n    bytes32 public constant MANAGE_FRAME_CONFIG_ROLE = keccak256(\"MANAGE_FRAME_CONFIG_ROLE\");\n\n    /// @notice An ACL role granting the permission to change fast lane reporting interval\n    /// length by calling setFastLaneLengthSlots.\n    bytes32 public constant MANAGE_FAST_LANE_CONFIG_ROLE = keccak256(\"MANAGE_FAST_LANE_CONFIG_ROLE\");\n\n    /// @notice An ACL role granting the permission to change еру report processor\n    /// contract by calling setReportProcessor.\n    bytes32 public constant MANAGE_REPORT_PROCESSOR_ROLE = keccak256(\"MANAGE_REPORT_PROCESSOR_ROLE\");\n\n    /// Chain specification\n    uint64 internal immutable SLOTS_PER_EPOCH;\n    uint64 internal immutable SECONDS_PER_SLOT;\n    uint64 internal immutable GENESIS_TIME;\n\n    /// @dev A quorum value that effectively disables the oracle.\n    uint256 internal constant UNREACHABLE_QUORUM = type(uint256).max;\n    bytes32 internal constant ZERO_HASH = bytes32(0);\n\n    /// @dev An offset from the processing deadline slot of the previous frame (i.e. the last slot\n    /// at which a report for the prev. frame can be submitted and its processing started) to the\n    /// reference slot of the next frame (equal to the last slot of the previous frame).\n    /// frame[i].reportProcessingDeadlineSlot := frame[i + 1].refSlot - DEADLINE_SLOT_OFFSET\n    uint256 internal constant DEADLINE_SLOT_OFFSET = 0;\n\n    /// @dev Reporting frame configuration\n    FrameConfig internal _frameConfig;\n\n    /// @dev Oracle committee members states array\n    MemberState[] internal _memberStates;\n\n    /// @dev Oracle committee members' addresses array\n    address[] internal _memberAddresses;\n\n    /// @dev Mapping from an oracle committee member address to the 1-based index in the\n    /// members array\n    mapping(address => uint256) internal _memberIndices1b;\n\n    /// @dev A structure containing the last reference slot any report was received for, the last\n    /// reference slot consensus report was achieved for, and the last consensus variant index\n    ReportingState internal _reportingState;\n\n    /// @dev Oracle committee members quorum value, must be larger than totalMembers // 2\n    uint256 internal _quorum;\n\n    /// @dev Mapping from a report variant index to the ReportVariant structure\n    mapping(uint256 => ReportVariant) internal _reportVariants;\n\n    /// @dev The number of report variants\n    uint256 internal _reportVariantsLength;\n\n    /// @dev The address of the report processor contract\n    address internal _reportProcessor;\n\n    ///\n    /// Initialization\n    ///\n\n    constructor(\n        uint256 slotsPerEpoch,\n        uint256 secondsPerSlot,\n        uint256 genesisTime,\n        uint256 epochsPerFrame,\n        uint256 fastLaneLengthSlots,\n        address admin,\n        address reportProcessor\n    ) {\n        if (slotsPerEpoch == 0) revert InvalidChainConfig();\n        if (secondsPerSlot == 0) revert InvalidChainConfig();\n\n        SLOTS_PER_EPOCH = slotsPerEpoch.toUint64();\n        SECONDS_PER_SLOT = secondsPerSlot.toUint64();\n        GENESIS_TIME = genesisTime.toUint64();\n\n        if (admin == address(0)) revert AdminCannotBeZero();\n        if (reportProcessor == address(0)) revert ReportProcessorCannotBeZero();\n\n        _setupRole(DEFAULT_ADMIN_ROLE, admin);\n\n        uint256 farFutureEpoch = _computeEpochAtTimestamp(type(uint64).max);\n        _setFrameConfig(farFutureEpoch, epochsPerFrame, fastLaneLengthSlots, FrameConfig(0, 0, 0));\n\n        _reportProcessor = reportProcessor;\n    }\n\n    ///\n    /// Time\n    ///\n\n    /// @notice Returns the immutable chain parameters required to calculate epoch and slot\n    /// given a timestamp.\n    ///\n    function getChainConfig() external view returns (\n        uint256 slotsPerEpoch,\n        uint256 secondsPerSlot,\n        uint256 genesisTime\n    ) {\n        return (SLOTS_PER_EPOCH, SECONDS_PER_SLOT, GENESIS_TIME);\n    }\n\n    /// @notice Returns the time-related configuration.\n    ///\n    /// @return initialEpoch Epoch of the frame with zero index.\n    /// @return epochsPerFrame Length of a frame in epochs.\n    /// @return fastLaneLengthSlots Length of the fast lane interval in slots; see `getIsFastLaneMember`.\n    ///\n    function getFrameConfig() external view returns (\n        uint256 initialEpoch,\n        uint256 epochsPerFrame,\n        uint256 fastLaneLengthSlots\n    ) {\n        FrameConfig memory config = _frameConfig;\n        return (config.initialEpoch, config.epochsPerFrame, config.fastLaneLengthSlots);\n    }\n\n    /// @notice Returns the current reporting frame.\n    ///\n    /// @return refSlot The frame's reference slot: if the data the consensus is being reached upon\n    ///         includes or depends on any onchain state, this state should be queried at the\n    ///         reference slot. If the slot contains a block, the state should include all changes\n    ///         from that block.\n    ///\n    /// @return reportProcessingDeadlineSlot The last slot at which the report can be processed by\n    ///         the report processor contract.\n    ///\n    function getCurrentFrame() external view returns (\n        uint256 refSlot,\n        uint256 reportProcessingDeadlineSlot\n    ) {\n        ConsensusFrame memory frame = _getCurrentFrame();\n        return (frame.refSlot, frame.reportProcessingDeadlineSlot);\n    }\n\n    /// @notice Returns the earliest possible reference slot, i.e. the reference slot of the\n    /// reporting frame with zero index.\n    ///\n    function getInitialRefSlot() external view returns (uint256) {\n        return _getInitialFrame().refSlot;\n    }\n\n    /// @notice Sets a new initial epoch given that the current initial epoch is in the future.\n    ///\n    /// @param initialEpoch The new initial epoch.\n    ///\n    function updateInitialEpoch(uint256 initialEpoch) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        FrameConfig memory prevConfig = _frameConfig;\n\n        if (_computeEpochAtTimestamp(_getTime()) >= prevConfig.initialEpoch) {\n            revert InitialEpochAlreadyArrived();\n        }\n\n        _setFrameConfig(\n            initialEpoch,\n            prevConfig.epochsPerFrame,\n            prevConfig.fastLaneLengthSlots,\n            prevConfig\n        );\n\n        if (_getInitialFrame().refSlot < _getLastProcessingRefSlot()) {\n            revert InitialEpochRefSlotCannotBeEarlierThanProcessingSlot();\n        }\n    }\n\n    /// @notice Updates the time-related configuration.\n    ///\n    /// @param epochsPerFrame Length of a frame in epochs.\n    /// @param fastLaneLengthSlots Length of the fast lane interval in slots; see `getIsFastLaneMember`.\n    ///\n    function setFrameConfig(uint256 epochsPerFrame, uint256 fastLaneLengthSlots)\n        external onlyRole(MANAGE_FRAME_CONFIG_ROLE)\n    {\n        // Updates epochsPerFrame in a way that either keeps the current reference slot the same\n        // or increases it by at least the minimum of old and new frame sizes.\n        uint256 timestamp = _getTime();\n        uint256 currentFrameStartEpoch = _computeFrameStartEpoch(timestamp, _frameConfig);\n        _setFrameConfig(currentFrameStartEpoch, epochsPerFrame, fastLaneLengthSlots, _frameConfig);\n    }\n\n    ///\n    /// Members\n    ///\n\n    /// @notice Returns whether the given address is currently a member of the consensus.\n    ///\n    function getIsMember(address addr) external view returns (bool) {\n        return _isMember(addr);\n    }\n\n    /// @notice Returns whether the given address is a fast lane member for the current reporting\n    /// frame.\n    ///\n    /// Fast lane members is a subset of all members that changes each reporting frame. These\n    /// members can, and are expected to, submit a report during the first part of the frame called\n    /// the \"fast lane interval\" and defined via `setFrameConfig` or `setFastLaneLengthSlots`. Under\n    /// regular circumstances, all other members are only allowed to submit a report after the fast\n    /// lane interval passes.\n    ///\n    /// The fast lane subset consists of `quorum` members; selection is implemented as a sliding\n    /// window of the `quorum` width over member indices (mod total members). The window advances\n    /// by one index each reporting frame.\n    ///\n    /// This is done to encourage each member from the full set to participate in reporting on a\n    /// regular basis, and identify any malfunctioning members.\n    ///\n    /// With the fast lane mechanism active, it's sufficient for the monitoring to check that\n    /// consensus is consistently reached during the fast lane part of each frame to conclude that\n    /// all members are active and share the same consensus rules.\n    ///\n    /// However, there is no guarantee that, at any given time, it holds true that only the current\n    /// fast lane members can or were able to report during the currently-configured fast lane\n    /// interval of the current frame. In particular, this assumption can be violated in any frame\n    /// during which the members set, initial epoch, or the quorum number was changed, or the fast\n    /// lane interval length was increased. Thus, the fast lane mechanism should not be used for any\n    /// purpose other than monitoring of the members liveness, and monitoring tools should take into\n    /// consideration the potential irregularities within frames with any configuration changes.\n    ///\n    function getIsFastLaneMember(address addr) external view returns (bool) {\n        uint256 index1b = _memberIndices1b[addr];\n        unchecked {\n            return index1b > 0 && _isFastLaneMember(index1b - 1, _getCurrentFrame().index);\n        }\n    }\n\n    /// @notice Returns all current members, together with the last reference slot each member\n    /// submitted a report for.\n    ///\n    function getMembers() external view returns (\n        address[] memory addresses,\n        uint256[] memory lastReportedRefSlots\n    ) {\n        return _getMembers(false);\n    }\n\n    /// @notice Returns the subset of the oracle committee members (consisting of `quorum` items)\n    /// that changes each frame.\n    ///\n    /// See `getIsFastLaneMember`.\n    ///\n    function getFastLaneMembers() external view returns (\n        address[] memory addresses,\n        uint256[] memory lastReportedRefSlots\n    ) {\n        return _getMembers(true);\n    }\n\n    /// @notice Sets the duration of the fast lane interval of the reporting frame.\n    ///\n    /// See `getIsFastLaneMember`.\n    ///\n    /// @param fastLaneLengthSlots The length of the fast lane reporting interval in slots. Setting\n    ///        it to zero disables the fast lane subset, allowing any oracle to report starting from\n    ///        the first slot of a frame and until the frame's reporting deadline.\n    ///\n    function setFastLaneLengthSlots(uint256 fastLaneLengthSlots)\n        external onlyRole(MANAGE_FAST_LANE_CONFIG_ROLE)\n    {\n        _setFastLaneLengthSlots(fastLaneLengthSlots);\n    }\n\n    function addMember(address addr, uint256 quorum)\n        external\n        onlyRole(MANAGE_MEMBERS_AND_QUORUM_ROLE)\n    {\n        _addMember(addr, quorum);\n    }\n\n    function removeMember(address addr, uint256 quorum)\n        external\n        onlyRole(MANAGE_MEMBERS_AND_QUORUM_ROLE)\n    {\n        _removeMember(addr, quorum);\n    }\n\n    function getQuorum() external view returns (uint256) {\n        return _quorum;\n    }\n\n    function setQuorum(uint256 quorum) external {\n        // access control is performed inside the next call\n        _setQuorumAndCheckConsensus(quorum, _memberStates.length);\n    }\n\n    /// @notice Disables the oracle by setting the quorum to an unreachable value.\n    ///\n    function disableConsensus() external {\n        // access control is performed inside the next call\n        _setQuorumAndCheckConsensus(UNREACHABLE_QUORUM, _memberStates.length);\n    }\n\n    ///\n    /// Report processor\n    ///\n\n    function getReportProcessor() external view returns (address) {\n        return _reportProcessor;\n    }\n\n    function setReportProcessor(address newProcessor)\n        external\n        onlyRole(MANAGE_REPORT_PROCESSOR_ROLE)\n    {\n        _setReportProcessor(newProcessor);\n    }\n\n    ///\n    /// Consensus\n    ///\n\n    /// @notice Returns info about the current frame and consensus state in that frame.\n    ///\n    /// @return refSlot Reference slot of the current reporting frame.\n    ///\n    /// @return consensusReport Consensus report for the current frame, if any.\n    ///         Zero bytes otherwise.\n    ///\n    /// @return isReportProcessing If consensus report for the current frame is already\n    ///         being processed. Consensus can be changed before the processing starts.\n    ///\n    function getConsensusState() external view returns (\n        uint256 refSlot,\n        bytes32 consensusReport,\n        bool isReportProcessing\n    ) {\n        refSlot = _getCurrentFrame().refSlot;\n        (consensusReport,,) = _getConsensusReport(refSlot, _quorum);\n        isReportProcessing = _getLastProcessingRefSlot() == refSlot;\n    }\n\n    /// @notice Returns report variants and their support for the current reference slot.\n    ///\n    function getReportVariants() external view returns (\n        bytes32[] memory variants,\n        uint256[] memory support\n    ) {\n        if (_reportingState.lastReportRefSlot != _getCurrentFrame().refSlot) {\n            return (variants, support);\n        }\n\n        uint256 variantsLength = _reportVariantsLength;\n        variants = new bytes32[](variantsLength);\n        support = new uint256[](variantsLength);\n\n        for (uint256 i = 0; i < variantsLength; ++i) {\n            ReportVariant memory variant = _reportVariants[i];\n            variants[i] = variant.hash;\n            support[i] = variant.support;\n        }\n    }\n\n    struct MemberConsensusState {\n        /// @notice Current frame's reference slot.\n        uint256 currentFrameRefSlot;\n\n        /// @notice Consensus report for the current frame, if any. Zero bytes otherwise.\n        bytes32 currentFrameConsensusReport;\n\n        /// @notice Whether the provided address is a member of the oracle committee.\n        bool isMember;\n\n        /// @notice Whether the oracle committee member is in the fast lane members subset\n        /// of the current reporting frame. See `getIsFastLaneMember`.\n        bool isFastLane;\n\n        /// @notice Whether the oracle committee member is allowed to submit a report at\n        /// the moment of the call.\n        bool canReport;\n\n        /// @notice The last reference slot for which the member submitted a report.\n        uint256 lastMemberReportRefSlot;\n\n        /// @notice The hash reported by the member for the current frame, if any.\n        /// Zero bytes otherwise.\n        bytes32 currentFrameMemberReport;\n    }\n\n    /// @notice Returns the extended information related to an oracle committee member with the\n    /// given address and the current consensus state. Provides all the information needed for\n    /// an oracle daemon to decide if it needs to submit a report.\n    ///\n    /// @param addr The member address.\n    /// @return result See the docs for `MemberConsensusState`.\n    ///\n    function getConsensusStateForMember(address addr)\n        external view returns (MemberConsensusState memory result)\n    {\n        ConsensusFrame memory frame = _getCurrentFrame();\n        result.currentFrameRefSlot = frame.refSlot;\n        (result.currentFrameConsensusReport,,) = _getConsensusReport(frame.refSlot, _quorum);\n\n        uint256 index = _memberIndices1b[addr];\n        result.isMember = index != 0;\n\n        if (index != 0) {\n            unchecked { --index; } // convert to 0-based\n            MemberState memory memberState = _memberStates[index];\n\n            result.lastMemberReportRefSlot = memberState.lastReportRefSlot;\n            result.currentFrameMemberReport =\n                result.lastMemberReportRefSlot == frame.refSlot\n                    ? _reportVariants[memberState.lastReportVariantIndex].hash\n                    : ZERO_HASH;\n\n            uint256 slot = _computeSlotAtTimestamp(_getTime());\n\n            result.canReport = slot <= frame.reportProcessingDeadlineSlot &&\n                frame.refSlot > _getLastProcessingRefSlot();\n\n            result.isFastLane = _isFastLaneMember(index, frame.index);\n\n            if (!result.isFastLane && result.canReport) {\n                result.canReport = slot > frame.refSlot + _frameConfig.fastLaneLengthSlots;\n            }\n        }\n    }\n\n    /// @notice Used by oracle members to submit hash of the data calculated for the given\n    /// reference slot.\n    ///\n    /// @param slot The reference slot the data was calculated for. Reverts if doesn't match\n    ///        the current reference slot.\n    ///\n    /// @param report Hash of the data calculated for the given reference slot.\n    ///\n    /// @param consensusVersion Version of the oracle consensus rules. Reverts if doesn't\n    ///        match the version returned by the currently set consensus report processor,\n    ///        or zero if no report processor is set.\n    ///\n    function submitReport(uint256 slot, bytes32 report, uint256 consensusVersion) external {\n        _submitReport(slot, report, consensusVersion);\n    }\n\n    ///\n    /// Implementation: time\n    ///\n\n    function _setFrameConfig(\n        uint256 initialEpoch,\n        uint256 epochsPerFrame,\n        uint256 fastLaneLengthSlots,\n        FrameConfig memory prevConfig\n    ) internal {\n        if (epochsPerFrame == 0) revert EpochsPerFrameCannotBeZero();\n\n        if (fastLaneLengthSlots > epochsPerFrame * SLOTS_PER_EPOCH) {\n            revert FastLanePeriodCannotBeLongerThanFrame();\n        }\n\n        _frameConfig = FrameConfig(\n            initialEpoch.toUint64(),\n            epochsPerFrame.toUint64(),\n            fastLaneLengthSlots.toUint64()\n        );\n\n        if (initialEpoch != prevConfig.initialEpoch || epochsPerFrame != prevConfig.epochsPerFrame) {\n            emit FrameConfigSet(initialEpoch, epochsPerFrame);\n        }\n\n        if (fastLaneLengthSlots != prevConfig.fastLaneLengthSlots) {\n            emit FastLaneConfigSet(fastLaneLengthSlots);\n        }\n    }\n\n    function _getCurrentFrame() internal view returns (ConsensusFrame memory) {\n        return _getFrameAtTimestamp(_getTime(), _frameConfig);\n    }\n\n    function _getInitialFrame() internal view returns (ConsensusFrame memory) {\n        return _getFrameAtIndex(0, _frameConfig);\n    }\n\n    function _getFrameAtTimestamp(uint256 timestamp, FrameConfig memory config)\n        internal view returns (ConsensusFrame memory)\n    {\n        return _getFrameAtIndex(_computeFrameIndex(timestamp, config), config);\n    }\n\n    function _getFrameAtIndex(uint256 frameIndex, FrameConfig memory config)\n        internal view returns (ConsensusFrame memory)\n    {\n        uint256 frameStartEpoch = _computeStartEpochOfFrameWithIndex(frameIndex, config);\n        uint256 frameStartSlot = _computeStartSlotAtEpoch(frameStartEpoch);\n        uint256 nextFrameStartSlot = frameStartSlot + config.epochsPerFrame * SLOTS_PER_EPOCH;\n\n        return ConsensusFrame({\n            index: frameIndex,\n            refSlot: uint64(frameStartSlot - 1),\n            reportProcessingDeadlineSlot: uint64(nextFrameStartSlot - 1 - DEADLINE_SLOT_OFFSET)\n        });\n    }\n\n    function _computeFrameStartEpoch(uint256 timestamp, FrameConfig memory config)\n        internal view returns (uint256)\n    {\n        return _computeStartEpochOfFrameWithIndex(_computeFrameIndex(timestamp, config), config);\n    }\n\n    function _computeStartEpochOfFrameWithIndex(uint256 frameIndex, FrameConfig memory config)\n        internal pure returns (uint256)\n    {\n        return config.initialEpoch + frameIndex * config.epochsPerFrame;\n    }\n\n    function _computeFrameIndex(uint256 timestamp, FrameConfig memory config)\n        internal view returns (uint256)\n    {\n        uint256 epoch = _computeEpochAtTimestamp(timestamp);\n        if (epoch < config.initialEpoch) {\n            revert InitialEpochIsYetToArrive();\n        }\n        return (epoch - config.initialEpoch) / config.epochsPerFrame;\n    }\n\n    function _computeTimestampAtSlot(uint256 slot) internal view returns (uint256) {\n        // See: github.com/ethereum/consensus-specs/blob/dev/specs/bellatrix/beacon-chain.md#compute_timestamp_at_slot\n        return GENESIS_TIME + slot * SECONDS_PER_SLOT;\n    }\n\n    function _computeSlotAtTimestamp(uint256 timestamp) internal view returns (uint256) {\n        return (timestamp - GENESIS_TIME) / SECONDS_PER_SLOT;\n    }\n\n    function _computeEpochAtSlot(uint256 slot) internal view returns (uint256) {\n        // See: github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#compute_epoch_at_slot\n        return slot / SLOTS_PER_EPOCH;\n    }\n\n    function _computeEpochAtTimestamp(uint256 timestamp) internal view returns (uint256) {\n        return _computeEpochAtSlot(_computeSlotAtTimestamp(timestamp));\n    }\n\n    function _computeStartSlotAtEpoch(uint256 epoch) internal view returns (uint256) {\n        // See: github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md#compute_start_slot_at_epoch\n        return epoch * SLOTS_PER_EPOCH;\n    }\n\n    function _getTime() internal virtual view returns (uint256) {\n        return block.timestamp; // solhint-disable-line not-rely-on-time\n    }\n\n    ///\n    /// Implementation: members\n    ///\n\n    function _isMember(address addr) internal view returns (bool) {\n        return _memberIndices1b[addr] != 0;\n    }\n\n    function _getMemberIndex(address addr) internal view returns (uint256) {\n        uint256 index1b = _memberIndices1b[addr];\n        if (index1b == 0) {\n            revert NonMember();\n        }\n        unchecked {\n            return uint256(index1b - 1);\n        }\n    }\n\n    function _addMember(address addr, uint256 quorum) internal {\n        if (_isMember(addr)) revert DuplicateMember();\n        if (addr == address(0)) revert AddressCannotBeZero();\n\n        _memberStates.push(MemberState(0, 0));\n        _memberAddresses.push(addr);\n\n        uint256 newTotalMembers = _memberStates.length;\n        _memberIndices1b[addr] = newTotalMembers;\n\n        emit MemberAdded(addr, newTotalMembers, quorum);\n\n        _setQuorumAndCheckConsensus(quorum, newTotalMembers);\n    }\n\n    function _removeMember(address addr, uint256 quorum) internal {\n        uint256 index = _getMemberIndex(addr);\n        uint256 newTotalMembers = _memberStates.length - 1;\n\n        assert(index <= newTotalMembers);\n        MemberState memory memberState = _memberStates[index];\n\n        if (index != newTotalMembers) {\n            address addrToMove = _memberAddresses[newTotalMembers];\n            _memberAddresses[index] = addrToMove;\n            _memberStates[index] = _memberStates[newTotalMembers];\n            _memberIndices1b[addrToMove] = index + 1;\n        }\n\n        _memberStates.pop();\n        _memberAddresses.pop();\n        _memberIndices1b[addr] = 0;\n\n        emit MemberRemoved(addr, newTotalMembers, quorum);\n\n        if (memberState.lastReportRefSlot > 0) {\n            // member reported at least once\n            ConsensusFrame memory frame = _getCurrentFrame();\n\n            if (memberState.lastReportRefSlot == frame.refSlot &&\n                _getLastProcessingRefSlot() < frame.refSlot\n            ) {\n                // member reported for the current ref. slot and the consensus report\n                // is not processing yet => need to cancel the member's report\n                --_reportVariants[memberState.lastReportVariantIndex].support;\n            }\n        }\n\n        _setQuorumAndCheckConsensus(quorum, newTotalMembers);\n    }\n\n    function _setFastLaneLengthSlots(uint256 fastLaneLengthSlots) internal {\n        FrameConfig memory frameConfig = _frameConfig;\n        if (fastLaneLengthSlots > frameConfig.epochsPerFrame * SLOTS_PER_EPOCH) {\n            revert FastLanePeriodCannotBeLongerThanFrame();\n        }\n        if (fastLaneLengthSlots != frameConfig.fastLaneLengthSlots) {\n            _frameConfig.fastLaneLengthSlots = fastLaneLengthSlots.toUint64();\n            emit FastLaneConfigSet(fastLaneLengthSlots);\n        }\n    }\n\n    /// @dev Returns start and past-end incides (mod totalMembers) of the fast lane members subset.\n    ///\n    function _getFastLaneSubset(uint256 frameIndex, uint256 totalMembers)\n        internal view returns (uint256 startIndex, uint256 pastEndIndex)\n    {\n        uint256 quorum = _quorum;\n        if (quorum >= totalMembers) {\n            startIndex = 0;\n            pastEndIndex = totalMembers;\n        } else {\n            startIndex = frameIndex % totalMembers;\n            pastEndIndex = startIndex + quorum;\n        }\n    }\n\n    /// @dev Tests whether the member with the given `index` is in the fast lane subset for the\n    /// given reporting `frameIndex`.\n    ///\n    function _isFastLaneMember(uint256 index, uint256 frameIndex) internal view returns (bool) {\n        uint256 totalMembers = _memberStates.length;\n        (uint256 flLeft, uint256 flPastRight) = _getFastLaneSubset(frameIndex, totalMembers);\n        unchecked {\n            return (\n                flPastRight != 0 &&\n                Math.pointInClosedIntervalModN(index, flLeft, flPastRight - 1, totalMembers)\n            );\n        }\n    }\n\n    function _getMembers(bool fastLane) internal view returns (\n        address[] memory addresses,\n        uint256[] memory lastReportedRefSlots\n    ) {\n        uint256 totalMembers = _memberStates.length;\n        uint256 left;\n        uint256 right;\n\n        if (fastLane) {\n            (left, right) = _getFastLaneSubset(_getCurrentFrame().index, totalMembers);\n        } else {\n            right = totalMembers;\n        }\n\n        addresses = new address[](right - left);\n        lastReportedRefSlots = new uint256[](addresses.length);\n\n        for (uint256 i = left; i < right; ++i) {\n            uint256 iModTotal = i % totalMembers;\n            MemberState memory memberState = _memberStates[iModTotal];\n            uint256 k = i - left;\n            addresses[k] = _memberAddresses[iModTotal];\n            lastReportedRefSlots[k] = memberState.lastReportRefSlot;\n        }\n    }\n\n    ///\n    /// Implementation: consensus\n    ///\n\n    function _submitReport(uint256 slot, bytes32 report, uint256 consensusVersion) internal {\n        if (slot == 0) revert InvalidSlot();\n        if (slot > type(uint64).max) revert NumericOverflow();\n        if (report == ZERO_HASH) revert EmptyReport();\n\n        uint256 memberIndex = _getMemberIndex(_msgSender());\n        MemberState memory memberState = _memberStates[memberIndex];\n\n        uint256 expectedConsensusVersion = _getConsensusVersion();\n        if (consensusVersion != expectedConsensusVersion) {\n            revert UnexpectedConsensusVersion(expectedConsensusVersion, consensusVersion);\n        }\n\n        uint256 timestamp = _getTime();\n        uint256 currentSlot = _computeSlotAtTimestamp(timestamp);\n        FrameConfig memory config = _frameConfig;\n        ConsensusFrame memory frame = _getFrameAtTimestamp(timestamp, config);\n\n        if (slot != frame.refSlot) revert InvalidSlot();\n        if (currentSlot > frame.reportProcessingDeadlineSlot) revert StaleReport();\n\n        if (currentSlot <= frame.refSlot + config.fastLaneLengthSlots &&\n            !_isFastLaneMember(memberIndex, frame.index)\n        ) {\n            revert NonFastLaneMemberCannotReportWithinFastLaneInterval();\n        }\n\n        if (slot <= _getLastProcessingRefSlot()) {\n            // consensus for the ref. slot was already reached and consensus report is processing\n            if (slot == memberState.lastReportRefSlot) {\n                // member sends a report for the same slot => let them know via a revert\n                revert ConsensusReportAlreadyProcessing();\n            } else {\n                // member hasn't sent a report for this slot => normal operation, do nothing\n                return;\n            }\n        }\n\n        uint256 variantsLength;\n\n        if (_reportingState.lastReportRefSlot != slot) {\n            // first report for a new slot => clear report variants\n            _reportingState.lastReportRefSlot = uint64(slot);\n            variantsLength = 0;\n        } else {\n            variantsLength = _reportVariantsLength;\n        }\n\n        uint64 varIndex = 0;\n        bool prevConsensusLost = false;\n\n        while (varIndex < variantsLength && _reportVariants[varIndex].hash != report) {\n            ++varIndex;\n        }\n\n        if (slot == memberState.lastReportRefSlot) {\n            uint64 prevVarIndex = memberState.lastReportVariantIndex;\n            assert(prevVarIndex < variantsLength);\n            if (varIndex == prevVarIndex) {\n                revert DuplicateReport();\n            } else {\n                uint256 support = --_reportVariants[prevVarIndex].support;\n                if (support == _quorum - 1) {\n                    prevConsensusLost = true;\n                }\n            }\n        }\n\n        uint256 support;\n\n        if (varIndex < variantsLength) {\n            support = ++_reportVariants[varIndex].support;\n        } else {\n            support = 1;\n            _reportVariants[varIndex] = ReportVariant({hash: report, support: 1});\n            _reportVariantsLength = ++variantsLength;\n        }\n\n        _memberStates[memberIndex] = MemberState({\n            lastReportRefSlot: uint64(slot),\n            lastReportVariantIndex: varIndex\n        });\n\n        emit ReportReceived(slot, _msgSender(), report);\n\n        if (support >= _quorum) {\n            _consensusReached(frame, report, varIndex, support);\n        } else if (prevConsensusLost) {\n            _consensusNotReached(frame);\n        }\n    }\n\n    function _consensusReached(\n        ConsensusFrame memory frame,\n        bytes32 report,\n        uint256 variantIndex,\n        uint256 support\n    ) internal {\n        if (_reportingState.lastConsensusRefSlot != frame.refSlot ||\n            _reportingState.lastConsensusVariantIndex != variantIndex\n        ) {\n            _reportingState.lastConsensusRefSlot = uint64(frame.refSlot);\n            _reportingState.lastConsensusVariantIndex = uint64(variantIndex);\n            emit ConsensusReached(frame.refSlot, report, support);\n            _submitReportForProcessing(frame, report);\n        }\n    }\n\n    function _consensusNotReached(ConsensusFrame memory frame) internal {\n        if (_reportingState.lastConsensusRefSlot == frame.refSlot) {\n            _reportingState.lastConsensusRefSlot = 0;\n            emit ConsensusLost(frame.refSlot);\n            _cancelReportProcessing(frame);\n        }\n    }\n\n    function _setQuorumAndCheckConsensus(uint256 quorum, uint256 totalMembers) internal {\n        if (quorum <= totalMembers / 2) {\n            revert QuorumTooSmall(totalMembers / 2 + 1, quorum);\n        }\n\n        // we're explicitly allowing quorum values greater than the number of members to\n        // allow effectively disabling the oracle in case something unpredictable happens\n\n        uint256 prevQuorum = _quorum;\n        if (quorum != prevQuorum) {\n            _checkRole(\n                quorum == UNREACHABLE_QUORUM ? DISABLE_CONSENSUS_ROLE : MANAGE_MEMBERS_AND_QUORUM_ROLE,\n                _msgSender()\n            );\n            _quorum = quorum;\n            emit QuorumSet(quorum, totalMembers, prevQuorum);\n        }\n\n        if (_computeEpochAtTimestamp(_getTime()) >= _frameConfig.initialEpoch) {\n            _checkConsensus(quorum);\n        }\n    }\n\n    function _checkConsensus(uint256 quorum) internal {\n        uint256 timestamp = _getTime();\n        ConsensusFrame memory frame = _getFrameAtTimestamp(timestamp, _frameConfig);\n\n        if (_computeSlotAtTimestamp(timestamp) > frame.reportProcessingDeadlineSlot) {\n            // a report for the current ref. slot cannot be processed anymore\n            return;\n        }\n\n        if (_getLastProcessingRefSlot() >= frame.refSlot) {\n            // a consensus report for the current ref. slot is already being processed\n            return;\n        }\n\n        (bytes32 consensusReport, int256 consensusVariantIndex, uint256 support) =\n            _getConsensusReport(frame.refSlot, quorum);\n\n        if (consensusVariantIndex >= 0) {\n            _consensusReached(frame, consensusReport, uint256(consensusVariantIndex), support);\n        } else {\n            _consensusNotReached(frame);\n        }\n    }\n\n    function _getConsensusReport(uint256 currentRefSlot, uint256 quorum)\n        internal view returns (bytes32 report, int256 variantIndex, uint256 support)\n    {\n        if (_reportingState.lastReportRefSlot != currentRefSlot) {\n            // there were no reports for the current ref. slot\n            return (ZERO_HASH, -1, 0);\n        }\n\n        uint256 variantsLength = _reportVariantsLength;\n        variantIndex = -1;\n        report = ZERO_HASH;\n        support = 0;\n\n        for (uint256 i = 0; i < variantsLength; ++i) {\n            uint256 iSupport = _reportVariants[i].support;\n            if (iSupport >= quorum) {\n                variantIndex = int256(i);\n                report = _reportVariants[i].hash;\n                support = iSupport;\n                break;\n            }\n        }\n\n        return (report, variantIndex, support);\n    }\n\n    ///\n    /// Implementation: report processing\n    ///\n\n    function _setReportProcessor(address newProcessor) internal {\n        address prevProcessor = _reportProcessor;\n        if (newProcessor == address(0)) revert ReportProcessorCannotBeZero();\n        if (newProcessor == prevProcessor) revert NewProcessorCannotBeTheSame();\n\n        _reportProcessor = newProcessor;\n        emit ReportProcessorSet(newProcessor, prevProcessor);\n\n        ConsensusFrame memory frame = _getCurrentFrame();\n        uint256 lastConsensusRefSlot = _reportingState.lastConsensusRefSlot;\n\n        uint256 processingRefSlotPrev = IReportAsyncProcessor(prevProcessor).getLastProcessingRefSlot();\n        uint256 processingRefSlotNext = IReportAsyncProcessor(newProcessor).getLastProcessingRefSlot();\n\n        if (\n            processingRefSlotPrev < frame.refSlot &&\n            processingRefSlotNext < frame.refSlot &&\n            lastConsensusRefSlot == frame.refSlot\n        ) {\n            bytes32 report = _reportVariants[_reportingState.lastConsensusVariantIndex].hash;\n            _submitReportForProcessing(frame, report);\n        }\n    }\n\n    function _getLastProcessingRefSlot() internal view returns (uint256) {\n        return IReportAsyncProcessor(_reportProcessor).getLastProcessingRefSlot();\n    }\n\n    function _submitReportForProcessing(ConsensusFrame memory frame, bytes32 report) internal {\n        IReportAsyncProcessor(_reportProcessor).submitConsensusReport(\n            report,\n            frame.refSlot,\n            _computeTimestampAtSlot(frame.reportProcessingDeadlineSlot)\n        );\n    }\n\n    function _cancelReportProcessing(ConsensusFrame memory frame) internal {\n        IReportAsyncProcessor(_reportProcessor).discardConsensusReport(frame.refSlot);\n    }\n\n    function _getConsensusVersion() internal view returns (uint256) {\n        return IReportAsyncProcessor(_reportProcessor).getConsensusVersion();\n    }\n}\n"

    },

    "contracts/0.8.9/utils/access/AccessControl.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/AccessControl.sol)\n//\n// A modified AccessControl contract using unstructured storage. Copied from tree:\n// https://github.com/OpenZeppelin/openzeppelin-contracts/tree/6bd6b76/contracts/access\n//\n/* See contracts/COMPILERS.md */\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-v4.4/access/IAccessControl.sol\";\nimport \"@openzeppelin/contracts-v4.4/utils/Context.sol\";\nimport \"@openzeppelin/contracts-v4.4/utils/Strings.sol\";\nimport \"@openzeppelin/contracts-v4.4/utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    /// @dev Storage slot: mapping(bytes32 => RoleData) _roles\n    bytes32 private constant ROLES_POSITION = keccak256(\"openzeppelin.AccessControl._roles\");\n\n    function _storageRoles() private pure returns (mapping(bytes32 => RoleData) storage _roles) {\n        bytes32 position = ROLES_POSITION;\n        assembly { _roles.slot := position }\n    }\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _storageRoles()[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _storageRoles()[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _storageRoles()[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _storageRoles()[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _storageRoles()[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"

    },

    "contracts/0.8.9/utils/access/AccessControlEnumerable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/AccessControlEnumerable.sol)\n//\n// A modified AccessControlEnumerable contract using unstructured storage. Copied from tree:\n// https://github.com/OpenZeppelin/openzeppelin-contracts/tree/6bd6b76/contracts/access\n//\n/* See contracts/COMPILERS.md */\npragma solidity 0.8.9;\n\nimport \"@openzeppelin/contracts-v4.4/access/IAccessControlEnumerable.sol\";\nimport \"@openzeppelin/contracts-v4.4/utils/structs/EnumerableSet.sol\";\n\nimport \"./AccessControl.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @dev Storage slot: mapping(bytes32 => EnumerableSet.AddressSet) _roleMembers\n    bytes32 private constant ROLE_MEMBERS_POSITION = keccak256(\"openzeppelin.AccessControlEnumerable._roleMembers\");\n\n    function _storageRoleMembers() private pure returns (\n        mapping(bytes32 => EnumerableSet.AddressSet) storage _roleMembers\n    ) {\n        bytes32 position = ROLE_MEMBERS_POSITION;\n        assembly { _roleMembers.slot := position }\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view override returns (address) {\n        return _storageRoleMembers()[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view override returns (uint256) {\n        return _storageRoleMembers()[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _storageRoleMembers()[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _storageRoleMembers()[role].remove(account);\n    }\n}\n"

    }

  },

  "settings": {

    "optimizer": {

      "enabled": true,

      "runs": 200

    },

    "evmVersion": "istanbul",

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "libraries": {}

  }

}}