//miladystation

//milady has no limits

// File: solady/utils/MerkleProofLib.sol





pragma solidity ^0.8.4;



/// @notice Gas optimized verification of proof of inclusion for a leaf in a Merkle tree.

/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/MerkleProofLib.sol)

/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/MerkleProofLib.sol)

/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/MerkleProof.sol)

library MerkleProofLib {

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*            MERKLE PROOF VERIFICATION OPERATIONS            */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Returns whether `leaf` exists in the Merkle tree with `root`, given `proof`.

    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf)

        internal

        pure

        returns (bool isValid)

    {

        /// @solidity memory-safe-assembly

        assembly {

            if mload(proof) {

                // Initialize `offset` to the offset of `proof` elements in memory.

                let offset := add(proof, 0x20)

                // Left shift by 5 is equivalent to multiplying by 0x20.

                let end := add(offset, shl(5, mload(proof)))

                // Iterate over proof elements to compute root hash.

                for {} 1 {} {

                    // Slot of `leaf` in scratch space.

                    // If the condition is true: 0x20, otherwise: 0x00.

                    let scratch := shl(5, gt(leaf, mload(offset)))

                    // Store elements to hash contiguously in scratch space.

                    // Scratch space is 64 bytes (0x00 - 0x3f) and both elements are 32 bytes.

                    mstore(scratch, leaf)

                    mstore(xor(scratch, 0x20), mload(offset))

                    // Reuse `leaf` to store the hash to reduce stack operations.

                    leaf := keccak256(0x00, 0x40)

                    offset := add(offset, 0x20)

                    if iszero(lt(offset, end)) { break }

                }

            }

            isValid := eq(leaf, root)

        }

    }



    /// @dev Returns whether `leaf` exists in the Merkle tree with `root`, given `proof`.

    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf)

        internal

        pure

        returns (bool isValid)

    {

        /// @solidity memory-safe-assembly

        assembly {

            if proof.length {

                // Left shift by 5 is equivalent to multiplying by 0x20.

                let end := add(proof.offset, shl(5, proof.length))

                // Initialize `offset` to the offset of `proof` in the calldata.

                let offset := proof.offset

                // Iterate over proof elements to compute root hash.

                for {} 1 {} {

                    // Slot of `leaf` in scratch space.

                    // If the condition is true: 0x20, otherwise: 0x00.

                    let scratch := shl(5, gt(leaf, calldataload(offset)))

                    // Store elements to hash contiguously in scratch space.

                    // Scratch space is 64 bytes (0x00 - 0x3f) and both elements are 32 bytes.

                    mstore(scratch, leaf)

                    mstore(xor(scratch, 0x20), calldataload(offset))

                    // Reuse `leaf` to store the hash to reduce stack operations.

                    leaf := keccak256(0x00, 0x40)

                    offset := add(offset, 0x20)

                    if iszero(lt(offset, end)) { break }

                }

            }

            isValid := eq(leaf, root)

        }

    }



    /// @dev Returns whether all `leafs` exist in the Merkle tree with `root`,

    /// given `proof` and `flags`.

    function verifyMultiProof(

        bytes32[] memory proof,

        bytes32 root,

        bytes32[] memory leafs,

        bool[] memory flags

    ) internal pure returns (bool isValid) {

        // Rebuilds the root by consuming and producing values on a queue.

        // The queue starts with the `leafs` array, and goes into a `hashes` array.

        // After the process, the last element on the queue is verified

        // to be equal to the `root`.

        //

        // The `flags` array denotes whether the sibling

        // should be popped from the queue (`flag == true`), or

        // should be popped from the `proof` (`flag == false`).

        /// @solidity memory-safe-assembly

        assembly {

            // Cache the lengths of the arrays.

            let leafsLength := mload(leafs)

            let proofLength := mload(proof)

            let flagsLength := mload(flags)



            // Advance the pointers of the arrays to point to the data.

            leafs := add(0x20, leafs)

            proof := add(0x20, proof)

            flags := add(0x20, flags)



            // If the number of flags is correct.

            for {} eq(add(leafsLength, proofLength), add(flagsLength, 1)) {} {

                // For the case where `proof.length + leafs.length == 1`.

                if iszero(flagsLength) {

                    // `isValid = (proof.length == 1 ? proof[0] : leafs[0]) == root`.

                    isValid := eq(mload(xor(leafs, mul(xor(proof, leafs), proofLength))), root)

                    break

                }



                // We can use the free memory space for the queue.

                // We don't need to allocate, since the queue is temporary.

                let hashesFront := mload(0x40)

                // Copy the leafs into the hashes.

                // Sometimes, a little memory expansion costs less than branching.

                // Should cost less, even with a high free memory offset of 0x7d00.

                // Left shift by 5 is equivalent to multiplying by 0x20.

                leafsLength := shl(5, leafsLength)

                for { let i := 0 } iszero(eq(i, leafsLength)) { i := add(i, 0x20) } {

                    mstore(add(hashesFront, i), mload(add(leafs, i)))

                }

                // Compute the back of the hashes.

                let hashesBack := add(hashesFront, leafsLength)

                // This is the end of the memory for the queue.

                // We recycle `flagsLength` to save on stack variables

                // (this trick may not always save gas).

                flagsLength := add(hashesBack, shl(5, flagsLength))



                for {} 1 {} {

                    // Pop from `hashes`.

                    let a := mload(hashesFront)

                    // Pop from `hashes`.

                    let b := mload(add(hashesFront, 0x20))

                    hashesFront := add(hashesFront, 0x40)



                    // If the flag is false, load the next proof,

                    // else, pops from the queue.

                    if iszero(mload(flags)) {

                        // Loads the next proof.

                        b := mload(proof)

                        proof := add(proof, 0x20)

                        // Unpop from `hashes`.

                        hashesFront := sub(hashesFront, 0x20)

                    }



                    // Advance to the next flag.

                    flags := add(flags, 0x20)



                    // Slot of `a` in scratch space.

                    // If the condition is true: 0x20, otherwise: 0x00.

                    let scratch := shl(5, gt(a, b))

                    // Hash the scratch space and push the result onto the queue.

                    mstore(scratch, a)

                    mstore(xor(scratch, 0x20), b)

                    mstore(hashesBack, keccak256(0x00, 0x40))

                    hashesBack := add(hashesBack, 0x20)

                    if iszero(lt(hashesBack, flagsLength)) { break }

                }

                // Checks if the last value in the queue is same as the root.

                isValid := eq(mload(sub(hashesBack, 0x20)), root)

                break

            }

        }

    }



    /// @dev Returns whether all `leafs` exist in the Merkle tree with `root`,

    /// given `proof` and `flags`.

    function verifyMultiProofCalldata(

        bytes32[] calldata proof,

        bytes32 root,

        bytes32[] calldata leafs,

        bool[] calldata flags

    ) internal pure returns (bool isValid) {

        // Rebuilds the root by consuming and producing values on a queue.

        // The queue starts with the `leafs` array, and goes into a `hashes` array.

        // After the process, the last element on the queue is verified

        // to be equal to the `root`.

        //

        // The `flags` array denotes whether the sibling

        // should be popped from the queue (`flag == true`), or

        // should be popped from the `proof` (`flag == false`).

        /// @solidity memory-safe-assembly

        assembly {

            // If the number of flags is correct.

            for {} eq(add(leafs.length, proof.length), add(flags.length, 1)) {} {

                // For the case where `proof.length + leafs.length == 1`.

                if iszero(flags.length) {

                    // `isValid = (proof.length == 1 ? proof[0] : leafs[0]) == root`.

                    // forgefmt: disable-next-item

                    isValid := eq(

                        calldataload(

                            xor(leafs.offset, mul(xor(proof.offset, leafs.offset), proof.length))

                        ),

                        root

                    )

                    break

                }



                // We can use the free memory space for the queue.

                // We don't need to allocate, since the queue is temporary.

                let hashesFront := mload(0x40)

                // Copy the leafs into the hashes.

                // Sometimes, a little memory expansion costs less than branching.

                // Should cost less, even with a high free memory offset of 0x7d00.

                // Left shift by 5 is equivalent to multiplying by 0x20.

                calldatacopy(hashesFront, leafs.offset, shl(5, leafs.length))

                // Compute the back of the hashes.

                let hashesBack := add(hashesFront, shl(5, leafs.length))

                // This is the end of the memory for the queue.

                // We recycle `flags.length` to save on stack variables

                // (this trick may not always save gas).

                flags.length := add(hashesBack, shl(5, flags.length))



                // We don't need to make a copy of `proof.offset` or `flags.offset`,

                // as they are pass-by-value (this trick may not always save gas).



                for {} 1 {} {

                    // Pop from `hashes`.

                    let a := mload(hashesFront)

                    // Pop from `hashes`.

                    let b := mload(add(hashesFront, 0x20))

                    hashesFront := add(hashesFront, 0x40)



                    // If the flag is false, load the next proof,

                    // else, pops from the queue.

                    if iszero(calldataload(flags.offset)) {

                        // Loads the next proof.

                        b := calldataload(proof.offset)

                        proof.offset := add(proof.offset, 0x20)

                        // Unpop from `hashes`.

                        hashesFront := sub(hashesFront, 0x20)

                    }



                    // Advance to the next flag offset.

                    flags.offset := add(flags.offset, 0x20)



                    // Slot of `a` in scratch space.

                    // If the condition is true: 0x20, otherwise: 0x00.

                    let scratch := shl(5, gt(a, b))

                    // Hash the scratch space and push the result onto the queue.

                    mstore(scratch, a)

                    mstore(xor(scratch, 0x20), b)

                    mstore(hashesBack, keccak256(0x00, 0x40))

                    hashesBack := add(hashesBack, 0x20)

                    if iszero(lt(hashesBack, flags.length)) { break }

                }

                // Checks if the last value in the queue is same as the root.

                isValid := eq(mload(sub(hashesBack, 0x20)), root)

                break

            }

        }

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                   EMPTY CALLDATA HELPERS                   */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Returns an empty calldata bytes32 array.

    function emptyProof() internal pure returns (bytes32[] calldata proof) {

        /// @solidity memory-safe-assembly

        assembly {

            proof.length := 0

        }

    }



    /// @dev Returns an empty calldata bytes32 array.

    function emptyLeafs() internal pure returns (bytes32[] calldata leafs) {

        /// @solidity memory-safe-assembly

        assembly {

            leafs.length := 0

        }

    }



    /// @dev Returns an empty calldata bool array.

    function emptyFlags() internal pure returns (bool[] calldata flags) {

        /// @solidity memory-safe-assembly

        assembly {

            flags.length := 0

        }

    }

}

// File: solady/tokens/ERC721.sol





pragma solidity ^0.8.4;



/// @notice Simple ERC721 implementation with storage hitchhiking.

/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC721.sol)

/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)

/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC721/ERC721.sol)

abstract contract ERC721 {

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                         CONSTANTS                          */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev An account can hold up to 4294967295 tokens.

    uint256 internal constant _MAX_ACCOUNT_BALANCE = 0xffffffff;



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                       CUSTOM ERRORS                        */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Only the token owner or an approved account can manage the token.

    error NotOwnerNorApproved();



    /// @dev The token does not exist.

    error TokenDoesNotExist();



    /// @dev The token already exists.

    error TokenAlreadyExists();



    /// @dev Cannot query the balance for the zero address.

    error BalanceQueryForZeroAddress();



    /// @dev Cannot mint or transfer to the zero address.

    error TransferToZeroAddress();



    /// @dev The token must be owned by `from`.

    error TransferFromIncorrectOwner();



    /// @dev The recipient's balance has overflowed.

    error AccountBalanceOverflow();



    /// @dev Cannot safely transfer to a contract that does not implement

    /// the ERC721Receiver interface.

    error TransferToNonERC721ReceiverImplementer();



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                           EVENTS                           */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Emitted when token `id` is transferred from `from` to `to`.

    event Transfer(address indexed from, address indexed to, uint256 indexed id);



    /// @dev Emitted when `owner` enables `account` to manage the `id` token.

    event Approval(address indexed owner, address indexed account, uint256 indexed id);



    /// @dev Emitted when `owner` enables or disables `operator` to manage all of their tokens.

    event ApprovalForAll(address indexed owner, address indexed operator, bool isApproved);



    /// @dev `keccak256(bytes("Transfer(address,address,uint256)"))`.

    uint256 private constant _TRANSFER_EVENT_SIGNATURE =

        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;



    /// @dev `keccak256(bytes("Approval(address,address,uint256)"))`.

    uint256 private constant _APPROVAL_EVENT_SIGNATURE =

        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;



    /// @dev `keccak256(bytes("ApprovalForAll(address,address,bool)"))`.

    uint256 private constant _APPROVAL_FOR_ALL_EVENT_SIGNATURE =

        0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31;



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                          STORAGE                           */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev The ownership data slot of `id` is given by:

    /// ```

    ///     mstore(0x00, id)

    ///     mstore(0x1c, _ERC721_MASTER_SLOT_SEED)

    ///     let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))

    /// ```

    /// Bits Layout:

    // - [0..159]   `addr`

    // - [160..223] `extraData`

    ///

    /// The approved address slot is given by: `add(1, ownershipSlot)`.

    ///

    /// See: https://notes.ethereum.org/%40vbuterin/verkle_tree_eip

    ///

    /// The balance slot of `owner` is given by:

    /// ```

    ///     mstore(0x1c, _ERC721_MASTER_SLOT_SEED)

    ///     mstore(0x00, owner)

    ///     let balanceSlot := keccak256(0x0c, 0x1c)

    /// ```

    /// Bits Layout:

    /// - [0..31]   `balance`

    /// - [32..225] `aux`

    ///

    /// The `operator` approval slot of `owner` is given by:

    /// ```

    ///     mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, operator))

    ///     mstore(0x00, owner)

    ///     let operatorApprovalSlot := keccak256(0x0c, 0x30)

    /// ```

    uint256 private constant _ERC721_MASTER_SLOT_SEED = 0x7d8825530a5a2e7a << 192;



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                      ERC721 METADATA                       */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Returns the token collection name.

    function name() public view virtual returns (string memory);



    /// @dev Returns the token collection symbol.

    function symbol() public view virtual returns (string memory);



    /// @dev Returns the Uniform Resource Identifier (URI) for token `id`.

    function tokenURI(uint256 id) public view virtual returns (string memory);



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                           ERC721                           */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Returns the owner of token `id`.

    ///

    /// Requirements:

    /// - Token `id` must exist.

    function ownerOf(uint256 id) public view virtual returns (address result) {

        result = _ownerOf(id);

        /// @solidity memory-safe-assembly

        assembly {

            if iszero(result) {

                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.

                revert(0x1c, 0x04)

            }

        }

    }



    /// @dev Returns the number of tokens owned by `owner`.

    ///

    /// Requirements:

    /// - `owner` must not be the zero address.

    function balanceOf(address owner) public view virtual returns (uint256 result) {

        /// @solidity memory-safe-assembly

        assembly {

            // Revert if the `owner` is the zero address.

            if iszero(owner) {

                mstore(0x00, 0x8f4eb604) // `BalanceQueryForZeroAddress()`.

                revert(0x1c, 0x04)

            }

            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)

            mstore(0x00, owner)

            result := and(sload(keccak256(0x0c, 0x1c)), _MAX_ACCOUNT_BALANCE)

        }

    }



    /// @dev Returns the account approved to managed token `id`.

    ///

    /// Requirements:

    /// - Token `id` must exist.

    function getApproved(uint256 id) public view virtual returns (address result) {

        /// @solidity memory-safe-assembly

        assembly {

            mstore(0x00, id)

            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)

            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))

            if iszero(shr(96, shl(96, sload(ownershipSlot)))) {

                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.

                revert(0x1c, 0x04)

            }

            result := sload(add(1, ownershipSlot))

        }

    }



    /// @dev Sets `account` as the approved account to manage token `id`.

    ///

    /// Requirements:

    /// - Token `id` must exist.

    /// - The caller must be the owner of the token,

    ///   or an approved operator for the token owner.

    ///

    /// Emits a {Approval} event.

    function approve(address account, uint256 id) public payable virtual {

        _approve(msg.sender, account, id);

    }



    /// @dev Returns whether `operator` is approved to manage the tokens of `owner`.

    function isApprovedForAll(address owner, address operator)

        public

        view

        virtual

        returns (bool result)

    {

        /// @solidity memory-safe-assembly

        assembly {

            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, shr(96, shl(96, operator))))

            mstore(0x00, owner)

            result := sload(keccak256(0x0c, 0x30))

        }

    }



    /// @dev Sets whether `operator` is approved to manage the tokens of the caller.

    ///

    /// Emits a {ApprovalForAll} event.

    function setApprovalForAll(address operator, bool isApproved) public virtual {

        /// @solidity memory-safe-assembly

        assembly {

            // Clear the upper 96 bits.

            operator := shr(96, shl(96, operator))

            // Convert to 0 or 1.

            isApproved := iszero(iszero(isApproved))

            // Update the `isApproved` for (`msg.sender`, `operator`).

            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, operator))

            mstore(0x00, caller())

            sstore(keccak256(0x0c, 0x30), isApproved)

            // Emit the {ApprovalForAll} event.

            mstore(0x00, isApproved)

            log3(0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, caller(), operator)

        }

    }



    /// @dev Transfers token `id` from `from` to `to`.

    ///

    /// Requirements:

    ///

    /// - Token `id` must exist.

    /// - `from` must be the owner of the token.

    /// - `to` cannot be the zero address.

    /// - The caller must be the owner of the token, or be approved to manage the token.

    ///

    /// Emits a {Transfer} event.

    function transferFrom(address from, address to, uint256 id) public payable virtual {

        _beforeTokenTransfer(from, to, id);

        /// @solidity memory-safe-assembly

        assembly {

            // Clear the upper 96 bits.

            let bitmaskAddress := shr(96, not(0))

            from := and(bitmaskAddress, from)

            to := and(bitmaskAddress, to)

            // Load the ownership data.

            mstore(0x00, id)

            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, caller()))

            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))

            let ownershipPacked := sload(ownershipSlot)

            let owner := and(bitmaskAddress, ownershipPacked)

            // Revert if `from` is not the owner, or does not exist.

            if iszero(mul(owner, eq(owner, from))) {

                if iszero(owner) {

                    mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.

                    revert(0x1c, 0x04)

                }

                mstore(0x00, 0xa1148100) // `TransferFromIncorrectOwner()`.

                revert(0x1c, 0x04)

            }

            // Revert if `to` is the zero address.

            if iszero(to) {

                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.

                revert(0x1c, 0x04)

            }

            // Load, check, and update the token approval.

            {

                mstore(0x00, from)

                let approvedAddress := sload(add(1, ownershipSlot))

                // Revert if the caller is not the owner, nor approved.

                if iszero(or(eq(caller(), from), eq(caller(), approvedAddress))) {

                    if iszero(sload(keccak256(0x0c, 0x30))) {

                        mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.

                        revert(0x1c, 0x04)

                    }

                }

                // Delete the approved address if any.

                if approvedAddress { sstore(add(1, ownershipSlot), 0) }

            }

            // Update with the new owner.

            sstore(ownershipSlot, xor(ownershipPacked, xor(from, to)))

            // Decrement the balance of `from`.

            {

                let fromBalanceSlot := keccak256(0x0c, 0x1c)

                sstore(fromBalanceSlot, sub(sload(fromBalanceSlot), 1))

            }

            // Increment the balance of `to`.

            {

                mstore(0x00, to)

                let toBalanceSlot := keccak256(0x0c, 0x1c)

                let toBalanceSlotPacked := add(sload(toBalanceSlot), 1)

                if iszero(and(toBalanceSlotPacked, _MAX_ACCOUNT_BALANCE)) {

                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.

                    revert(0x1c, 0x04)

                }

                sstore(toBalanceSlot, toBalanceSlotPacked)

            }

            // Emit the {Transfer} event.

            log4(0x00, 0x00, _TRANSFER_EVENT_SIGNATURE, from, to, id)

        }

        _afterTokenTransfer(from, to, id);

    }



    /// @dev Equivalent to `safeTransferFrom(from, to, id, "")`.

    function safeTransferFrom(address from, address to, uint256 id) public payable virtual {

        transferFrom(from, to, id);

        if (_hasCode(to)) _checkOnERC721Received(from, to, id, "");

    }



    /// @dev Transfers token `id` from `from` to `to`.

    ///

    /// Requirements:

    ///

    /// - Token `id` must exist.

    /// - `from` must be the owner of the token.

    /// - `to` cannot be the zero address.

    /// - The caller must be the owner of the token, or be approved to manage the token.

    /// - If `to` refers to a smart contract, it must implement

    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.

    ///

    /// Emits a {Transfer} event.

    function safeTransferFrom(address from, address to, uint256 id, bytes calldata data)

        public

        payable

        virtual

    {

        transferFrom(from, to, id);

        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);

    }



    /// @dev Returns true if this contract implements the interface defined by `interfaceId`.

    /// See: https://eips.ethereum.org/EIPS/eip-165

    /// This function call must use less than 30000 gas.

    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {

        /// @solidity memory-safe-assembly

        assembly {

            let s := shr(224, interfaceId)

            // ERC165: 0x01ffc9a7, ERC721: 0x80ac58cd, ERC721Metadata: 0x5b5e139f.

            result := or(or(eq(s, 0x01ffc9a7), eq(s, 0x80ac58cd)), eq(s, 0x5b5e139f))

        }

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                  INTERNAL QUERY FUNCTIONS                  */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Returns if token `id` exists.

    function _exists(uint256 id) internal view virtual returns (bool result) {

        /// @solidity memory-safe-assembly

        assembly {

            mstore(0x00, id)

            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)

            result := shl(96, sload(add(id, add(id, keccak256(0x00, 0x20)))))

        }

    }



    /// @dev Returns the owner of token `id`.

    /// Returns the zero address instead of reverting if the token does not exist.

    function _ownerOf(uint256 id) internal view virtual returns (address result) {

        /// @solidity memory-safe-assembly

        assembly {

            mstore(0x00, id)

            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)

            result := shr(96, shl(96, sload(add(id, add(id, keccak256(0x00, 0x20))))))

        }

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*            INTERNAL DATA HITCHHIKING FUNCTIONS             */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Returns the auxiliary data for `owner`.

    /// Minting, transferring, burning the tokens of `owner` will not change the auxiliary data.

    /// Auxiliary data can be set for any address, even if it does not have any tokens.

    function _getAux(address owner) internal view virtual returns (uint224 result) {

        /// @solidity memory-safe-assembly

        assembly {

            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)

            mstore(0x00, owner)

            result := shr(32, sload(keccak256(0x0c, 0x1c)))

        }

    }



    /// @dev Set the auxiliary data for `owner` to `value`.

    /// Minting, transferring, burning the tokens of `owner` will not change the auxiliary data.

    /// Auxiliary data can be set for any address, even if it does not have any tokens.

    function _setAux(address owner, uint224 value) internal virtual {

        /// @solidity memory-safe-assembly

        assembly {

            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)

            mstore(0x00, owner)

            let balanceSlot := keccak256(0x0c, 0x1c)

            let packed := sload(balanceSlot)

            sstore(balanceSlot, xor(packed, shl(32, xor(value, shr(32, packed)))))

        }

    }



    /// @dev Returns the extra data for token `id`.

    /// Minting, transferring, burning a token will not change the extra data.

    /// The extra data can be set on a non existent token.

    function _getExtraData(uint256 id) internal view virtual returns (uint96 result) {

        /// @solidity memory-safe-assembly

        assembly {

            mstore(0x00, id)

            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)

            result := shr(160, sload(add(id, add(id, keccak256(0x00, 0x20)))))

        }

    }



    /// @dev Sets the extra data for token `id` to `value`.

    /// Minting, transferring, burning a token will not change the extra data.

    /// The extra data can be set on a non existent token.

    function _setExtraData(uint256 id, uint96 value) internal virtual {

        /// @solidity memory-safe-assembly

        assembly {

            mstore(0x00, id)

            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)

            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))

            let packed := sload(ownershipSlot)

            sstore(ownershipSlot, xor(packed, shl(160, xor(value, shr(160, packed)))))

        }

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                  INTERNAL MINT FUNCTIONS                   */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Mints token `id` to `to`.

    ///

    /// Requirements:

    ///

    /// - Token `id` must not exist.

    /// - `to` cannot be the zero address.

    ///

    /// Emits a {Transfer} event.

    function _mint(address to, uint256 id) internal virtual {

        _beforeTokenTransfer(address(0), to, id);

        /// @solidity memory-safe-assembly

        assembly {

            // Clear the upper 96 bits.

            to := shr(96, shl(96, to))

            // Revert if `to` is the zero address.

            if iszero(to) {

                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.

                revert(0x1c, 0x04)

            }

            // Load the ownership data.

            mstore(0x00, id)

            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)

            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))

            let ownershipPacked := sload(ownershipSlot)

            // Revert if the token already exists.

            if shl(96, ownershipPacked) {

                mstore(0x00, 0xc991cbb1) // `TokenAlreadyExists()`.

                revert(0x1c, 0x04)

            }

            // Update with the owner.

            sstore(ownershipSlot, or(ownershipPacked, to))

            // Increment the balance of the owner.

            {

                mstore(0x00, to)

                let balanceSlot := keccak256(0x0c, 0x1c)

                let balanceSlotPacked := add(sload(balanceSlot), 1)

                if iszero(and(balanceSlotPacked, _MAX_ACCOUNT_BALANCE)) {

                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.

                    revert(0x1c, 0x04)

                }

                sstore(balanceSlot, balanceSlotPacked)

            }

            // Emit the {Transfer} event.

            log4(0x00, 0x00, _TRANSFER_EVENT_SIGNATURE, 0, to, id)

        }

        _afterTokenTransfer(address(0), to, id);

    }



    /// @dev Equivalent to `_safeMint(to, id, "")`.

    function _safeMint(address to, uint256 id) internal virtual {

        _safeMint(to, id, "");

    }



    /// @dev Mints token `id` to `to`.

    ///

    /// Requirements:

    ///

    /// - Token `id` must not exist.

    /// - `to` cannot be the zero address.

    /// - If `to` refers to a smart contract, it must implement

    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.

    ///

    /// Emits a {Transfer} event.

    function _safeMint(address to, uint256 id, bytes memory data) internal virtual {

        _mint(to, id);

        if (_hasCode(to)) _checkOnERC721Received(address(0), to, id, data);

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                  INTERNAL BURN FUNCTIONS                   */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Equivalent to `_burn(address(0), id)`.

    function _burn(uint256 id) internal virtual {

        _burn(address(0), id);

    }



    /// @dev Destroys token `id`, using `by`.

    ///

    /// Requirements:

    ///

    /// - Token `id` must exist.

    /// - If `by` is not the zero address,

    ///   it must be the owner of the token, or be approved to manage the token.

    ///

    /// Emits a {Transfer} event.

    function _burn(address by, uint256 id) internal virtual {

        address owner = ownerOf(id);

        _beforeTokenTransfer(owner, address(0), id);

        /// @solidity memory-safe-assembly

        assembly {

            // Clear the upper 96 bits.

            by := shr(96, shl(96, by))

            // Load the ownership data.

            mstore(0x00, id)

            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, by))

            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))

            let ownershipPacked := sload(ownershipSlot)

            // Reload the owner in case it is changed in `_beforeTokenTransfer`.

            owner := shr(96, shl(96, ownershipPacked))

            // Revert if the token does not exist.

            if iszero(owner) {

                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.

                revert(0x1c, 0x04)

            }

            // Load and check the token approval.

            {

                mstore(0x00, owner)

                let approvedAddress := sload(add(1, ownershipSlot))

                // If `by` is not the zero address, do the authorization check.

                // Revert if the `by` is not the owner, nor approved.

                if iszero(or(iszero(by), or(eq(by, owner), eq(by, approvedAddress)))) {

                    if iszero(sload(keccak256(0x0c, 0x30))) {

                        mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.

                        revert(0x1c, 0x04)

                    }

                }

                // Delete the approved address if any.

                if approvedAddress { sstore(add(1, ownershipSlot), 0) }

            }

            // Clear the owner.

            sstore(ownershipSlot, xor(ownershipPacked, owner))

            // Decrement the balance of `owner`.

            {

                let balanceSlot := keccak256(0x0c, 0x1c)

                sstore(balanceSlot, sub(sload(balanceSlot), 1))

            }

            // Emit the {Transfer} event.

            log4(0x00, 0x00, _TRANSFER_EVENT_SIGNATURE, owner, 0, id)

        }

        _afterTokenTransfer(owner, address(0), id);

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                INTERNAL APPROVAL FUNCTIONS                 */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Returns whether `account` is the owner of token `id`, or is approved to managed it.

    ///

    /// Requirements:

    /// - Token `id` must exist.

    function _isApprovedOrOwner(address account, uint256 id)

        internal

        view

        virtual

        returns (bool result)

    {

        /// @solidity memory-safe-assembly

        assembly {

            result := 1

            // Clear the upper 96 bits.

            account := shr(96, shl(96, account))

            // Load the ownership data.

            mstore(0x00, id)

            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, account))

            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))

            let owner := shr(96, shl(96, sload(ownershipSlot)))

            // Revert if the token does not exist.

            if iszero(owner) {

                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.

                revert(0x1c, 0x04)

            }

            // Check if `account` is the `owner`.

            if iszero(eq(account, owner)) {

                mstore(0x00, owner)

                // Check if `account` is approved to

                if iszero(sload(keccak256(0x0c, 0x30))) {

                    result := eq(account, sload(add(1, ownershipSlot)))

                }

            }

        }

    }



    /// @dev Returns the account approved to manage token `id`.

    /// Returns the zero address instead of reverting if the token does not exist.

    function _getApproved(uint256 id) internal view virtual returns (address result) {

        /// @solidity memory-safe-assembly

        assembly {

            mstore(0x00, id)

            mstore(0x1c, _ERC721_MASTER_SLOT_SEED)

            result := sload(add(1, add(id, add(id, keccak256(0x00, 0x20)))))

        }

    }



    /// @dev Equivalent to `_approve(address(0), account, id)`.

    function _approve(address account, uint256 id) internal virtual {

        _approve(address(0), account, id);

    }



    /// @dev Sets `account` as the approved account to manage token `id`, using `by`.

    ///

    /// Requirements:

    /// - Token `id` must exist.

    /// - If `by` is not the zero address, `by` must be the owner

    ///   or an approved operator for the token owner.

    ///

    /// Emits a {Transfer} event.

    function _approve(address by, address account, uint256 id) internal virtual {

        assembly {

            // Clear the upper 96 bits.

            let bitmaskAddress := shr(96, not(0))

            account := and(bitmaskAddress, account)

            by := and(bitmaskAddress, by)

            // Load the owner of the token.

            mstore(0x00, id)

            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, by))

            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))

            let owner := and(bitmaskAddress, sload(ownershipSlot))

            // Revert if the token does not exist.

            if iszero(owner) {

                mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.

                revert(0x1c, 0x04)

            }

            // If `by` is not the zero address, do the authorization check.

            // Revert if `by` is not the owner, nor approved.

            if iszero(or(iszero(by), eq(by, owner))) {

                mstore(0x00, owner)

                if iszero(sload(keccak256(0x0c, 0x30))) {

                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.

                    revert(0x1c, 0x04)

                }

            }

            // Sets `account` as the approved account to manage `id`.

            sstore(add(1, ownershipSlot), account)

            // Emit the {Approval} event.

            log4(0x00, 0x00, _APPROVAL_EVENT_SIGNATURE, owner, account, id)

        }

    }



    /// @dev Approve or remove the `operator` as an operator for `by`,

    /// without authorization checks.

    ///

    /// Emits a {ApprovalForAll} event.

    function _setApprovalForAll(address by, address operator, bool isApproved) internal virtual {

        /// @solidity memory-safe-assembly

        assembly {

            // Clear the upper 96 bits.

            by := shr(96, shl(96, by))

            operator := shr(96, shl(96, operator))

            // Convert to 0 or 1.

            isApproved := iszero(iszero(isApproved))

            // Update the `isApproved` for (`by`, `operator`).

            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, operator))

            mstore(0x00, by)

            sstore(keccak256(0x0c, 0x30), isApproved)

            // Emit the {ApprovalForAll} event.

            mstore(0x00, isApproved)

            log3(0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, by, operator)

        }

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                INTERNAL TRANSFER FUNCTIONS                 */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Equivalent to `_transfer(address(0), from, to, id)`.

    function _transfer(address from, address to, uint256 id) internal virtual {

        _transfer(address(0), from, to, id);

    }



    /// @dev Transfers token `id` from `from` to `to`.

    ///

    /// Requirements:

    ///

    /// - Token `id` must exist.

    /// - `from` must be the owner of the token.

    /// - `to` cannot be the zero address.

    /// - If `by` is not the zero address,

    ///   it must be the owner of the token, or be approved to manage the token.

    ///

    /// Emits a {Transfer} event.

    function _transfer(address by, address from, address to, uint256 id) internal virtual {

        _beforeTokenTransfer(from, to, id);

        /// @solidity memory-safe-assembly

        assembly {

            // Clear the upper 96 bits.

            let bitmaskAddress := shr(96, not(0))

            from := and(bitmaskAddress, from)

            to := and(bitmaskAddress, to)

            by := and(bitmaskAddress, by)

            // Load the ownership data.

            mstore(0x00, id)

            mstore(0x1c, or(_ERC721_MASTER_SLOT_SEED, by))

            let ownershipSlot := add(id, add(id, keccak256(0x00, 0x20)))

            let ownershipPacked := sload(ownershipSlot)

            let owner := and(bitmaskAddress, ownershipPacked)

            // Revert if `from` is not the owner, or does not exist.

            if iszero(mul(owner, eq(owner, from))) {

                if iszero(owner) {

                    mstore(0x00, 0xceea21b6) // `TokenDoesNotExist()`.

                    revert(0x1c, 0x04)

                }

                mstore(0x00, 0xa1148100) // `TransferFromIncorrectOwner()`.

                revert(0x1c, 0x04)

            }

            // Revert if `to` is the zero address.

            if iszero(to) {

                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.

                revert(0x1c, 0x04)

            }

            // Load, check, and update the token approval.

            {

                mstore(0x00, from)

                let approvedAddress := sload(add(1, ownershipSlot))

                // If `by` is not the zero address, do the authorization check.

                // Revert if the `by` is not the owner, nor approved.

                if iszero(or(iszero(by), or(eq(by, from), eq(by, approvedAddress)))) {

                    if iszero(sload(keccak256(0x0c, 0x30))) {

                        mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.

                        revert(0x1c, 0x04)

                    }

                }

                // Delete the approved address if any.

                if approvedAddress { sstore(add(1, ownershipSlot), 0) }

            }

            // Update with the new owner.

            sstore(ownershipSlot, xor(ownershipPacked, xor(from, to)))

            // Decrement the balance of `from`.

            {

                let fromBalanceSlot := keccak256(0x0c, 0x1c)

                sstore(fromBalanceSlot, sub(sload(fromBalanceSlot), 1))

            }

            // Increment the balance of `to`.

            {

                mstore(0x00, to)

                let toBalanceSlot := keccak256(0x0c, 0x1c)

                let toBalanceSlotPacked := add(sload(toBalanceSlot), 1)

                if iszero(and(toBalanceSlotPacked, _MAX_ACCOUNT_BALANCE)) {

                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.

                    revert(0x1c, 0x04)

                }

                sstore(toBalanceSlot, toBalanceSlotPacked)

            }

            // Emit the {Transfer} event.

            log4(0x00, 0x00, _TRANSFER_EVENT_SIGNATURE, from, to, id)

        }

        _afterTokenTransfer(from, to, id);

    }



    /// @dev Equivalent to `_safeTransfer(from, to, id, "")`.

    function _safeTransfer(address from, address to, uint256 id) internal virtual {

        _safeTransfer(from, to, id, "");

    }



    /// @dev Transfers token `id` from `from` to `to`.

    ///

    /// Requirements:

    ///

    /// - Token `id` must exist.

    /// - `from` must be the owner of the token.

    /// - `to` cannot be the zero address.

    /// - The caller must be the owner of the token, or be approved to manage the token.

    /// - If `to` refers to a smart contract, it must implement

    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.

    ///

    /// Emits a {Transfer} event.

    function _safeTransfer(address from, address to, uint256 id, bytes memory data)

        internal

        virtual

    {

        _transfer(address(0), from, to, id);

        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);

    }



    /// @dev Equivalent to `_safeTransfer(by, from, to, id, "")`.

    function _safeTransfer(address by, address from, address to, uint256 id) internal virtual {

        _safeTransfer(by, from, to, id, "");

    }



    /// @dev Transfers token `id` from `from` to `to`.

    ///

    /// Requirements:

    ///

    /// - Token `id` must exist.

    /// - `from` must be the owner of the token.

    /// - `to` cannot be the zero address.

    /// - If `by` is not the zero address,

    ///   it must be the owner of the token, or be approved to manage the token.

    /// - If `to` refers to a smart contract, it must implement

    ///   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.

    ///

    /// Emits a {Transfer} event.

    function _safeTransfer(address by, address from, address to, uint256 id, bytes memory data)

        internal

        virtual

    {

        _transfer(by, from, to, id);

        if (_hasCode(to)) _checkOnERC721Received(from, to, id, data);

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                    HOOKS FOR OVERRIDING                    */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Hook that is called before any token transfers, including minting and burning.

    function _beforeTokenTransfer(address from, address to, uint256 id) internal virtual {}



    /// @dev Hook that is called after any token transfers, including minting and burning.

    function _afterTokenTransfer(address from, address to, uint256 id) internal virtual {}



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                      PRIVATE HELPERS                       */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Returns if `a` has bytecode of non-zero length.

    function _hasCode(address a) private view returns (bool result) {

        /// @solidity memory-safe-assembly

        assembly {

            result := extcodesize(a) // Can handle dirty upper bits.

        }

    }



    /// @dev Perform a call to invoke {IERC721Receiver-onERC721Received} on `to`.

    /// Reverts if the target does not support the function correctly.

    function _checkOnERC721Received(address from, address to, uint256 id, bytes memory data)

        private

    {

        /// @solidity memory-safe-assembly

        assembly {

            // Prepare the calldata.

            let m := mload(0x40)

            let onERC721ReceivedSelector := 0x150b7a02

            mstore(m, onERC721ReceivedSelector)

            mstore(add(m, 0x20), caller()) // The `operator`, which is always `msg.sender`.

            mstore(add(m, 0x40), shr(96, shl(96, from)))

            mstore(add(m, 0x60), id)

            mstore(add(m, 0x80), 0x80)

            let n := mload(data)

            mstore(add(m, 0xa0), n)

            if n { pop(staticcall(gas(), 4, add(data, 0x20), n, add(m, 0xc0), n)) }

            // Revert if the call reverts.

            if iszero(call(gas(), to, 0, add(m, 0x1c), add(n, 0xa4), m, 0x20)) {

                if returndatasize() {

                    // Bubble up the revert if the delegatecall reverts.

                    returndatacopy(0x00, 0x00, returndatasize())

                    revert(0x00, returndatasize())

                }

                mstore(m, 0)

            }

            // Load the returndata and compare it.

            if iszero(eq(mload(m), shl(224, onERC721ReceivedSelector))) {

                mstore(0x00, 0xd1a57ed6) // `TransferToNonERC721ReceiverImplementer()`.

                revert(0x1c, 0x04)

            }

        }

    }

}



// File: solady/tokens/ERC20.sol





pragma solidity ^0.8.4;



/// @notice Simple ERC20 + EIP-2612 implementation.

/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC20.sol)

/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokenss/ERC20.sol)

/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol)

abstract contract ERC20 {

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                       CUSTOM ERRORS                        */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev The total supply has overflowed.

    error TotalSupplyOverflow();



    /// @dev The allowance has overflowed.

    error AllowanceOverflow();



    /// @dev The allowance has underflowed.

    error AllowanceUnderflow();



    /// @dev Insufficient balance.

    error InsufficientBalance();



    /// @dev Insufficient allowance.

    error InsufficientAllowance();



    /// @dev The permit is invalid.

    error InvalidPermit();



    /// @dev The permit has expired.

    error PermitExpired();



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                           EVENTS                           */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Emitted when `amount` tokens is transferred from `from` to `to`.

    event Transfer(address indexed from, address indexed to, uint256 amount);



    /// @dev Emitted when `amount` tokens is approved by `owner` to be used by `spender`.

    event Approval(address indexed owner, address indexed spender, uint256 amount);



    /// @dev `keccak256(bytes("Transfer(address,address,uint256)"))`.

    uint256 private constant _TRANSFER_EVENT_SIGNATURE =

        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;



    /// @dev `keccak256(bytes("Approval(address,address,uint256)"))`.

    uint256 private constant _APPROVAL_EVENT_SIGNATURE =

        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                          STORAGE                           */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev The storage slot for the total supply.

    uint256 private constant _TOTAL_SUPPLY_SLOT = 0x05345cdf77eb68f44c;



    /// @dev The balance slot of `owner` is given by:

    /// ```

    ///     mstore(0x0c, _BALANCE_SLOT_SEED)

    ///     mstore(0x00, owner)

    ///     let balanceSlot := keccak256(0x0c, 0x20)

    /// ```

    uint256 private constant _BALANCE_SLOT_SEED = 0x87a211a2;



    /// @dev The allowance slot of (`owner`, `spender`) is given by:

    /// ```

    ///     mstore(0x20, spender)

    ///     mstore(0x0c, _ALLOWANCE_SLOT_SEED)

    ///     mstore(0x00, owner)

    ///     let allowanceSlot := keccak256(0x0c, 0x34)

    /// ```

    uint256 private constant _ALLOWANCE_SLOT_SEED = 0x7f5e9f20;



    /// @dev The nonce slot of `owner` is given by:

    /// ```

    ///     mstore(0x0c, _NONCES_SLOT_SEED)

    ///     mstore(0x00, owner)

    ///     let nonceSlot := keccak256(0x0c, 0x20)

    /// ```

    uint256 private constant _NONCES_SLOT_SEED = 0x38377508;



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                       ERC20 METADATA                       */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Returns the name of the token.

    function name() public view virtual returns (string memory);



    /// @dev Returns the symbol of the token.

    function symbol() public view virtual returns (string memory);



    /// @dev Returns the decimals places of the token.

    function decimals() public view virtual returns (uint8) {

        return 18;

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                           ERC20                            */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Returns the amount of tokens in existence.

    function totalSupply() public view virtual returns (uint256 result) {

        /// @solidity memory-safe-assembly

        assembly {

            result := sload(_TOTAL_SUPPLY_SLOT)

        }

    }



    /// @dev Returns the amount of tokens owned by `owner`.

    function balanceOf(address owner) public view virtual returns (uint256 result) {

        /// @solidity memory-safe-assembly

        assembly {

            mstore(0x0c, _BALANCE_SLOT_SEED)

            mstore(0x00, owner)

            result := sload(keccak256(0x0c, 0x20))

        }

    }



    /// @dev Returns the amount of tokens that `spender` can spend on behalf of `owner`.

    function allowance(address owner, address spender)

        public

        view

        virtual

        returns (uint256 result)

    {

        /// @solidity memory-safe-assembly

        assembly {

            mstore(0x20, spender)

            mstore(0x0c, _ALLOWANCE_SLOT_SEED)

            mstore(0x00, owner)

            result := sload(keccak256(0x0c, 0x34))

        }

    }



    /// @dev Sets `amount` as the allowance of `spender` over the caller's tokens.

    ///

    /// Emits a {Approval} event.

    function approve(address spender, uint256 amount) public virtual returns (bool) {

        /// @solidity memory-safe-assembly

        assembly {

            // Compute the allowance slot and store the amount.

            mstore(0x20, spender)

            mstore(0x0c, _ALLOWANCE_SLOT_SEED)

            mstore(0x00, caller())

            sstore(keccak256(0x0c, 0x34), amount)

            // Emit the {Approval} event.

            mstore(0x00, amount)

            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x2c)))

        }

        return true;

    }



    /// @dev Atomically increases the allowance granted to `spender` by the caller.

    ///

    /// Emits a {Approval} event.

    function increaseAllowance(address spender, uint256 difference) public virtual returns (bool) {

        /// @solidity memory-safe-assembly

        assembly {

            // Compute the allowance slot and load its value.

            mstore(0x20, spender)

            mstore(0x0c, _ALLOWANCE_SLOT_SEED)

            mstore(0x00, caller())

            let allowanceSlot := keccak256(0x0c, 0x34)

            let allowanceBefore := sload(allowanceSlot)

            // Add to the allowance.

            let allowanceAfter := add(allowanceBefore, difference)

            // Revert upon overflow.

            if lt(allowanceAfter, allowanceBefore) {

                mstore(0x00, 0xf9067066) // `AllowanceOverflow()`.

                revert(0x1c, 0x04)

            }

            // Store the updated allowance.

            sstore(allowanceSlot, allowanceAfter)

            // Emit the {Approval} event.

            mstore(0x00, allowanceAfter)

            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x2c)))

        }

        return true;

    }



    /// @dev Atomically decreases the allowance granted to `spender` by the caller.

    ///

    /// Emits a {Approval} event.

    function decreaseAllowance(address spender, uint256 difference) public virtual returns (bool) {

        /// @solidity memory-safe-assembly

        assembly {

            // Compute the allowance slot and load its value.

            mstore(0x20, spender)

            mstore(0x0c, _ALLOWANCE_SLOT_SEED)

            mstore(0x00, caller())

            let allowanceSlot := keccak256(0x0c, 0x34)

            let allowanceBefore := sload(allowanceSlot)

            // Revert if will underflow.

            if lt(allowanceBefore, difference) {

                mstore(0x00, 0x8301ab38) // `AllowanceUnderflow()`.

                revert(0x1c, 0x04)

            }

            // Subtract and store the updated allowance.

            let allowanceAfter := sub(allowanceBefore, difference)

            sstore(allowanceSlot, allowanceAfter)

            // Emit the {Approval} event.

            mstore(0x00, allowanceAfter)

            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x2c)))

        }

        return true;

    }



    /// @dev Transfer `amount` tokens from the caller to `to`.

    ///

    /// Requirements:

    /// - `from` must at least have `amount`.

    ///

    /// Emits a {Transfer} event.

    function transfer(address to, uint256 amount) public virtual returns (bool) {

        _beforeTokenTransfer(msg.sender, to, amount);

        /// @solidity memory-safe-assembly

        assembly {

            // Compute the balance slot and load its value.

            mstore(0x0c, _BALANCE_SLOT_SEED)

            mstore(0x00, caller())

            let fromBalanceSlot := keccak256(0x0c, 0x20)

            let fromBalance := sload(fromBalanceSlot)

            // Revert if insufficient balance.

            if gt(amount, fromBalance) {

                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.

                revert(0x1c, 0x04)

            }

            // Subtract and store the updated balance.

            sstore(fromBalanceSlot, sub(fromBalance, amount))

            // Compute the balance slot of `to`.

            mstore(0x00, to)

            let toBalanceSlot := keccak256(0x0c, 0x20)

            // Add and store the updated balance of `to`.

            // Will not overflow because the sum of all user balances

            // cannot exceed the maximum uint256 value.

            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))

            // Emit the {Transfer} event.

            mstore(0x20, amount)

            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, caller(), shr(96, mload(0x0c)))

        }

        _afterTokenTransfer(msg.sender, to, amount);

        return true;

    }



    /// @dev Transfers `amount` tokens from `from` to `to`.

    ///

    /// Note: does not update the allowance if it is the maximum uint256 value.

    ///

    /// Requirements:

    /// - `from` must at least have `amount`.

    /// - The caller must have at least `amount` of allowance to transfer the tokens of `from`.

    ///

    /// Emits a {Transfer} event.

    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {

        _beforeTokenTransfer(from, to, amount);

        /// @solidity memory-safe-assembly

        assembly {

            let from_ := shl(96, from)

            // Compute the allowance slot and load its value.

            mstore(0x20, caller())

            mstore(0x0c, or(from_, _ALLOWANCE_SLOT_SEED))

            let allowanceSlot := keccak256(0x0c, 0x34)

            let allowance_ := sload(allowanceSlot)

            // If the allowance is not the maximum uint256 value.

            if iszero(eq(allowance_, not(0))) {

                // Revert if the amount to be transferred exceeds the allowance.

                if gt(amount, allowance_) {

                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.

                    revert(0x1c, 0x04)

                }

                // Subtract and store the updated allowance.

                sstore(allowanceSlot, sub(allowance_, amount))

            }

            // Compute the balance slot and load its value.

            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))

            let fromBalanceSlot := keccak256(0x0c, 0x20)

            let fromBalance := sload(fromBalanceSlot)

            // Revert if insufficient balance.

            if gt(amount, fromBalance) {

                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.

                revert(0x1c, 0x04)

            }

            // Subtract and store the updated balance.

            sstore(fromBalanceSlot, sub(fromBalance, amount))

            // Compute the balance slot of `to`.

            mstore(0x00, to)

            let toBalanceSlot := keccak256(0x0c, 0x20)

            // Add and store the updated balance of `to`.

            // Will not overflow because the sum of all user balances

            // cannot exceed the maximum uint256 value.

            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))

            // Emit the {Transfer} event.

            mstore(0x20, amount)

            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))

        }

        _afterTokenTransfer(from, to, amount);

        return true;

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                          EIP-2612                          */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Returns the current nonce for `owner`.

    /// This value is used to compute the signature for EIP-2612 permit.

    function nonces(address owner) public view virtual returns (uint256 result) {

        /// @solidity memory-safe-assembly

        assembly {

            // Compute the nonce slot and load its value.

            mstore(0x0c, _NONCES_SLOT_SEED)

            mstore(0x00, owner)

            result := sload(keccak256(0x0c, 0x20))

        }

    }



    /// @dev Sets `value` as the allowance of `spender` over the tokens of `owner`,

    /// authorized by a signed approval by `owner`.

    ///

    /// Emits a {Approval} event.

    function permit(

        address owner,

        address spender,

        uint256 value,

        uint256 deadline,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) public virtual {

        bytes32 domainSeparator = DOMAIN_SEPARATOR();

        /// @solidity memory-safe-assembly

        assembly {

            // Revert if the block timestamp greater than `deadline`.

            if gt(timestamp(), deadline) {

                mstore(0x00, 0x1a15a3cc) // `PermitExpired()`.

                revert(0x1c, 0x04)

            }

            // Clean the upper 96 bits.

            owner := shr(96, shl(96, owner))

            spender := shr(96, shl(96, spender))

            // Compute the nonce slot and load its value.

            mstore(0x0c, _NONCES_SLOT_SEED)

            mstore(0x00, owner)

            let nonceSlot := keccak256(0x0c, 0x20)

            let nonceValue := sload(nonceSlot)

            // Increment and store the updated nonce.

            sstore(nonceSlot, add(nonceValue, 1))

            // Grab the free memory pointer.

            let m := mload(0x40)

            // Prepare the inner hash.

            // `keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)")`.

            // forgefmt: disable-next-item

            mstore(m, 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9)

            mstore(add(m, 0x20), owner)

            mstore(add(m, 0x40), spender)

            mstore(add(m, 0x60), value)

            mstore(add(m, 0x80), nonceValue)

            mstore(add(m, 0xa0), deadline)

            // Prepare the outer hash.

            mstore(0, 0x1901)

            mstore(0x20, domainSeparator)

            mstore(0x40, keccak256(m, 0xc0))

            // Prepare the ecrecover calldata.

            mstore(0, keccak256(0x1e, 0x42))

            mstore(0x20, and(0xff, v))

            mstore(0x40, r)

            mstore(0x60, s)

            pop(staticcall(gas(), 1, 0, 0x80, 0x20, 0x20))

            // Revert if the ecrecover fails (returndata will be 0x00),

            // or if the recovered address is not equal to `owner`.

            // If ecrecover succeeds, returndatasize will be 0x20.

            if iszero(mul(returndatasize(), eq(mload(returndatasize()), owner))) {

                mstore(0x00, 0xddafbaef) // `InvalidPermit()`.

                revert(0x1c, 0x04)

            }

            // Compute the allowance slot and store the value.

            mstore(0x20, spender)

            mstore(0x0c, _ALLOWANCE_SLOT_SEED)

            mstore(0x00, owner)

            sstore(keccak256(0x0c, 0x34), value)

            // Emit the {Approval} event.

            mstore(0x00, value)

            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, owner, spender)

            mstore(0x40, m) // Restore the free memory pointer.

            mstore(0x60, 0) // Restore the zero pointer.

        }

    }



    /// @dev Returns the EIP-2612 domains separator.

    function DOMAIN_SEPARATOR() public view virtual returns (bytes32 result) {

        /// @solidity memory-safe-assembly

        assembly {

            result := mload(0x40) // Grab the free memory pointer.

        }

        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.

        bytes32 nameHash = keccak256(bytes(name()));

        /// @solidity memory-safe-assembly

        assembly {

            let m := result

            // `keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)")`.

            // forgefmt: disable-next-item

            mstore(m, 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f)

            mstore(add(m, 0x20), nameHash)

            // `keccak256("1")`.

            // forgefmt: disable-next-item

            mstore(add(m, 0x40), 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6)

            mstore(add(m, 0x60), chainid())

            mstore(add(m, 0x80), address())

            result := keccak256(m, 0xa0)

        }

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                  INTERNAL MINT FUNCTIONS                   */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Mints `amount` tokens to `to`, increasing the total supply.

    ///

    /// Emits a {Transfer} event.

    function _mint(address to, uint256 amount) internal virtual {

        _beforeTokenTransfer(address(0), to, amount);

        /// @solidity memory-safe-assembly

        assembly {

            let totalSupplyBefore := sload(_TOTAL_SUPPLY_SLOT)

            let totalSupplyAfter := add(totalSupplyBefore, amount)

            // Revert if the total supply overflows.

            if lt(totalSupplyAfter, totalSupplyBefore) {

                mstore(0x00, 0xe5cfe957) // `TotalSupplyOverflow()`.

                revert(0x1c, 0x04)

            }

            // Store the updated total supply.

            sstore(_TOTAL_SUPPLY_SLOT, totalSupplyAfter)

            // Compute the balance slot and load its value.

            mstore(0x0c, _BALANCE_SLOT_SEED)

            mstore(0x00, to)

            let toBalanceSlot := keccak256(0x0c, 0x20)

            // Add and store the updated balance.

            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))

            // Emit the {Transfer} event.

            mstore(0x20, amount)

            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, 0, shr(96, mload(0x0c)))

        }

        _afterTokenTransfer(address(0), to, amount);

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                  INTERNAL BURN FUNCTIONS                   */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Burns `amount` tokens from `from`, reducing the total supply.

    ///

    /// Emits a {Transfer} event.

    function _burn(address from, uint256 amount) internal virtual {

        _beforeTokenTransfer(from, address(0), amount);

        /// @solidity memory-safe-assembly

        assembly {

            // Compute the balance slot and load its value.

            mstore(0x0c, _BALANCE_SLOT_SEED)

            mstore(0x00, from)

            let fromBalanceSlot := keccak256(0x0c, 0x20)

            let fromBalance := sload(fromBalanceSlot)

            // Revert if insufficient balance.

            if gt(amount, fromBalance) {

                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.

                revert(0x1c, 0x04)

            }

            // Subtract and store the updated balance.

            sstore(fromBalanceSlot, sub(fromBalance, amount))

            // Subtract and store the updated total supply.

            sstore(_TOTAL_SUPPLY_SLOT, sub(sload(_TOTAL_SUPPLY_SLOT), amount))

            // Emit the {Transfer} event.

            mstore(0x00, amount)

            log3(0x00, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, shl(96, from)), 0)

        }

        _afterTokenTransfer(from, address(0), amount);

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                INTERNAL TRANSFER FUNCTIONS                 */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Moves `amount` of tokens from `from` to `to`.

    function _transfer(address from, address to, uint256 amount) internal virtual {

        _beforeTokenTransfer(from, to, amount);

        /// @solidity memory-safe-assembly

        assembly {

            let from_ := shl(96, from)

            // Compute the balance slot and load its value.

            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))

            let fromBalanceSlot := keccak256(0x0c, 0x20)

            let fromBalance := sload(fromBalanceSlot)

            // Revert if insufficient balance.

            if gt(amount, fromBalance) {

                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.

                revert(0x1c, 0x04)

            }

            // Subtract and store the updated balance.

            sstore(fromBalanceSlot, sub(fromBalance, amount))

            // Compute the balance slot of `to`.

            mstore(0x00, to)

            let toBalanceSlot := keccak256(0x0c, 0x20)

            // Add and store the updated balance of `to`.

            // Will not overflow because the sum of all user balances

            // cannot exceed the maximum uint256 value.

            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))

            // Emit the {Transfer} event.

            mstore(0x20, amount)

            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))

        }

        _afterTokenTransfer(from, to, amount);

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                INTERNAL ALLOWANCE FUNCTIONS                */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Updates the allowance of `owner` for `spender` based on spent `amount`.

    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {

        /// @solidity memory-safe-assembly

        assembly {

            // Compute the allowance slot and load its value.

            mstore(0x20, spender)

            mstore(0x0c, _ALLOWANCE_SLOT_SEED)

            mstore(0x00, owner)

            let allowanceSlot := keccak256(0x0c, 0x34)

            let allowance_ := sload(allowanceSlot)

            // If the allowance is not the maximum uint256 value.

            if iszero(eq(allowance_, not(0))) {

                // Revert if the amount to be transferred exceeds the allowance.

                if gt(amount, allowance_) {

                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.

                    revert(0x1c, 0x04)

                }

                // Subtract and store the updated allowance.

                sstore(allowanceSlot, sub(allowance_, amount))

            }

        }

    }



    /// @dev Sets `amount` as the allowance of `spender` over the tokens of `owner`.

    ///

    /// Emits a {Approval} event.

    function _approve(address owner, address spender, uint256 amount) internal virtual {

        /// @solidity memory-safe-assembly

        assembly {

            let owner_ := shl(96, owner)

            // Compute the allowance slot and store the amount.

            mstore(0x20, spender)

            mstore(0x0c, or(owner_, _ALLOWANCE_SLOT_SEED))

            sstore(keccak256(0x0c, 0x34), amount)

            // Emit the {Approval} event.

            mstore(0x00, amount)

            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, shr(96, owner_), shr(96, mload(0x2c)))

        }

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                     HOOKS TO OVERRIDE                      */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Hook that is called before any transfer of tokens.

    /// This includes minting and burning.

    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}



    /// @dev Hook that is called after any transfer of tokens.

    /// This includes minting and burning.

    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}

}



// File: solady/auth/Ownable.sol





pragma solidity ^0.8.4;



/// @notice Simple single owner authorization mixin.

/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)

/// @dev While the ownable portion follows [EIP-173](https://eips.ethereum.org/EIPS/eip-173)

/// for compatibility, the nomenclature for the 2-step ownership handover

/// may be unique to this codebase.

abstract contract Ownable {

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                       CUSTOM ERRORS                        */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev The caller is not authorized to call the function.

    error Unauthorized();



    /// @dev The `newOwner` cannot be the zero address.

    error NewOwnerIsZeroAddress();



    /// @dev The `pendingOwner` does not have a valid handover request.

    error NoHandoverRequest();



    /// @dev `bytes4(keccak256(bytes("Unauthorized()")))`.

    uint256 private constant _UNAUTHORIZED_ERROR_SELECTOR = 0x82b42900;



    /// @dev `bytes4(keccak256(bytes("NewOwnerIsZeroAddress()")))`.

    uint256 private constant _NEW_OWNER_IS_ZERO_ADDRESS_ERROR_SELECTOR = 0x7448fbae;



    /// @dev `bytes4(keccak256(bytes("NoHandoverRequest()")))`.

    uint256 private constant _NO_HANDOVER_REQUEST_ERROR_SELECTOR = 0x6f5e8818;



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                           EVENTS                           */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.

    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be

    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),

    /// despite it not being as lightweight as a single argument event.

    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);



    /// @dev An ownership handover to `pendingOwner` has been requested.

    event OwnershipHandoverRequested(address indexed pendingOwner);



    /// @dev The ownership handover to `pendingOwner` has been canceled.

    event OwnershipHandoverCanceled(address indexed pendingOwner);



    /// @dev `keccak256(bytes("OwnershipTransferred(address,address)"))`.

    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =

        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;



    /// @dev `keccak256(bytes("OwnershipHandoverRequested(address)"))`.

    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =

        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;



    /// @dev `keccak256(bytes("OwnershipHandoverCanceled(address)"))`.

    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =

        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                          STORAGE                           */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev The owner slot is given by: `not(_OWNER_SLOT_NOT)`.

    /// It is intentionally choosen to be a high value

    /// to avoid collision with lower slots.

    /// The choice of manual storage layout is to enable compatibility

    /// with both regular and upgradeable contracts.

    uint256 private constant _OWNER_SLOT_NOT = 0x8b78c6d8;



    /// The ownership handover slot of `newOwner` is given by:

    /// ```

    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))

    ///     let handoverSlot := keccak256(0x00, 0x20)

    /// ```

    /// It stores the expiry timestamp of the two-step ownership handover.

    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                     INTERNAL FUNCTIONS                     */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Initializes the owner directly without authorization guard.

    /// This function must be called upon initialization,

    /// regardless of whether the contract is upgradeable or not.

    /// This is to enable generalization to both regular and upgradeable contracts,

    /// and to save gas in case the initial owner is not the caller.

    /// For performance reasons, this function will not check if there

    /// is an existing owner.

    function _initializeOwner(address newOwner) internal virtual {

        /// @solidity memory-safe-assembly

        assembly {

            // Clean the upper 96 bits.

            newOwner := shr(96, shl(96, newOwner))

            // Store the new value.

            sstore(not(_OWNER_SLOT_NOT), newOwner)

            // Emit the {OwnershipTransferred} event.

            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)

        }

    }



    /// @dev Sets the owner directly without authorization guard.

    function _setOwner(address newOwner) internal virtual {

        /// @solidity memory-safe-assembly

        assembly {

            let ownerSlot := not(_OWNER_SLOT_NOT)

            // Clean the upper 96 bits.

            newOwner := shr(96, shl(96, newOwner))

            // Emit the {OwnershipTransferred} event.

            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)

            // Store the new value.

            sstore(ownerSlot, newOwner)

        }

    }



    /// @dev Throws if the sender is not the owner.

    function _checkOwner() internal view virtual {

        /// @solidity memory-safe-assembly

        assembly {

            // If the caller is not the stored owner, revert.

            if iszero(eq(caller(), sload(not(_OWNER_SLOT_NOT)))) {

                mstore(0x00, _UNAUTHORIZED_ERROR_SELECTOR)

                revert(0x1c, 0x04)

            }

        }

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                  PUBLIC UPDATE FUNCTIONS                   */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Allows the owner to transfer the ownership to `newOwner`.

    function transferOwnership(address newOwner) public payable virtual onlyOwner {

        if (newOwner == address(0)) revert NewOwnerIsZeroAddress();

        _setOwner(newOwner);

    }



    /// @dev Allows the owner to renounce their ownership.

    function renounceOwnership() public payable virtual onlyOwner {

        _setOwner(address(0));

    }



    /// @dev Request a two-step ownership handover to the caller.

    /// The request will be automatically expire in 48 hours (172800 seconds) by default.

    function requestOwnershipHandover() public payable virtual {

        unchecked {

            uint256 expires = block.timestamp + ownershipHandoverValidFor();

            /// @solidity memory-safe-assembly

            assembly {

                // Compute and set the handover slot to 1.

                mstore(0x0c, _HANDOVER_SLOT_SEED)

                mstore(0x00, caller())

                sstore(keccak256(0x0c, 0x20), expires)

                // Emit the {OwnershipHandoverRequested} event.

                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())

            }

        }

    }



    /// @dev Cancels the two-step ownership handover to the caller, if any.

    function cancelOwnershipHandover() public payable virtual {

        /// @solidity memory-safe-assembly

        assembly {

            // Compute and set the handover slot to 0.

            mstore(0x0c, _HANDOVER_SLOT_SEED)

            mstore(0x00, caller())

            sstore(keccak256(0x0c, 0x20), 0)

            // Emit the {OwnershipHandoverCanceled} event.

            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())

        }

    }



    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.

    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.

    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {

        /// @solidity memory-safe-assembly

        assembly {

            // Compute and set the handover slot to 0.

            mstore(0x0c, _HANDOVER_SLOT_SEED)

            mstore(0x00, pendingOwner)

            let handoverSlot := keccak256(0x0c, 0x20)

            // If the handover does not exist, or has expired.

            if gt(timestamp(), sload(handoverSlot)) {

                mstore(0x00, _NO_HANDOVER_REQUEST_ERROR_SELECTOR)

                revert(0x1c, 0x04)

            }

            // Set the handover slot to 0.

            sstore(handoverSlot, 0)

            // Clean the upper 96 bits.

            let newOwner := shr(96, mload(0x0c))

            // Emit the {OwnershipTransferred} event.

            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, caller(), newOwner)

            // Store the new value.

            sstore(not(_OWNER_SLOT_NOT), newOwner)

        }

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                   PUBLIC READ FUNCTIONS                    */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Returns the owner of the contract.

    function owner() public view virtual returns (address result) {

        /// @solidity memory-safe-assembly

        assembly {

            result := sload(not(_OWNER_SLOT_NOT))

        }

    }



    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.

    function ownershipHandoverExpiresAt(address pendingOwner)

        public

        view

        virtual

        returns (uint256 result)

    {

        /// @solidity memory-safe-assembly

        assembly {

            // Compute the handover slot.

            mstore(0x0c, _HANDOVER_SLOT_SEED)

            mstore(0x00, pendingOwner)

            // Load the handover slot.

            result := sload(keccak256(0x0c, 0x20))

        }

    }



    /// @dev Returns how long a two-step ownership handover is valid for in seconds.

    function ownershipHandoverValidFor() public view virtual returns (uint64) {

        return 48 * 3600;

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                         MODIFIERS                          */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Marks a function as only callable by the owner.

    modifier onlyOwner() virtual {

        _checkOwner();

        _;

    }

}



// File: solady/tokens/ERC1155.sol





pragma solidity ^0.8.4;



/// @notice Modern and gas efficient ERC1155 implementation.

/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC1155.sol)

/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)

/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC1155/ERC1155.sol)

abstract contract ERC1155 {

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                       CUSTOM ERRORS                        */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev The lengths of the input arrays are not the same.

    error ArrayLengthsMismatch();



    /// @dev Cannot mint or transfer to the zero address.

    error TransferToZeroAddress();



    /// @dev The recipient's balance has overflowed.

    error AccountBalanceOverflow();



    /// @dev Insufficient balance.

    error InsufficientBalance();



    /// @dev Only the token owner or an approved account can manage the tokens.

    error NotOwnerNorApproved();



    /// @dev Cannot safely transfer to a contract that does not implement

    /// the ERC1155Receiver interface.

    error TransferToNonERC1155ReceiverImplementer();



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                           EVENTS                           */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Emitted when `amount` of token `id` is transferred

    /// from `from` to `to` by `operator`.

    event TransferSingle(

        address indexed operator,

        address indexed from,

        address indexed to,

        uint256 id,

        uint256 amount

    );



    /// @dev Emitted when `amounts` of token `ids` are transferred

    /// from `from` to `to` by `operator`.

    event TransferBatch(

        address indexed operator,

        address indexed from,

        address indexed to,

        uint256[] ids,

        uint256[] amounts

    );



    /// @dev Emitted when `owner` enables or disables `operator` to manage all of their tokens.

    event ApprovalForAll(address indexed owner, address indexed operator, bool isApproved);



    /// @dev Emitted when the Uniform Resource Identifier (URI) for token `id`

    /// is updated to `value`. This event is not used in the base contract.

    /// You may need to emit this event depending on your URI logic.

    ///

    /// See: https://eips.ethereum.org/EIPS/eip-1155#metadata

    event URI(string value, uint256 indexed id);



    /// @dev `keccak256(bytes("TransferSingle(address,address,address,uint256,uint256)"))`.

    uint256 private constant _TRANSFER_SINGLE_EVENT_SIGNATURE =

        0xc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62;



    /// @dev `keccak256(bytes("TransferBatch(address,address,address,uint256[],uint256[])"))`.

    uint256 private constant _TRANSFER_BATCH_EVENT_SIGNATURE =

        0x4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb;



    /// @dev `keccak256(bytes("ApprovalForAll(address,address,bool)"))`.

    uint256 private constant _APPROVAL_FOR_ALL_EVENT_SIGNATURE =

        0x17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31;



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                          STORAGE                           */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev The `ownerSlotSeed` of a given owner is given by.

    /// ```

    ///     let ownerSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, owner))

    /// ```

    ///

    /// The balance slot of `owner` is given by.

    /// ```

    ///     mstore(0x20, ownerSlotSeed)

    ///     mstore(0x00, id)

    ///     let balanceSlot := keccak256(0x00, 0x40)

    /// ```

    ///

    /// The operator approval slot of `owner` is given by.

    /// ```

    ///     mstore(0x20, ownerSlotSeed)

    ///     mstore(0x00, operator)

    ///     let operatorApprovalSlot := keccak256(0x0c, 0x34)

    /// ```

    uint256 private constant _ERC1155_MASTER_SLOT_SEED = 0x9a31110384e0b0c9;



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                      ERC1155 METADATA                      */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Returns the URI for token `id`.

    ///

    /// Can either return the same templated URI for all token IDs,

    /// or substitute the `id` on the contract side.

    ///

    /// See: https://eips.ethereum.org/EIPS/eip-1155#metadata

    function uri(uint256 id) public view virtual returns (string memory);



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                          ERC1155                           */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Returns the amount of `id` owned by `owner`.

    function balanceOf(address owner, uint256 id) public view virtual returns (uint256 result) {

        /// @solidity memory-safe-assembly

        assembly {

            mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, shl(96, owner)))

            mstore(0x00, id)

            result := sload(keccak256(0x00, 0x40))

        }

    }



    /// @dev Returns whether `operator` is approved to manage the tokens of `owner`.

    function isApprovedForAll(address owner, address operator)

        public

        view

        virtual

        returns (bool result)

    {

        /// @solidity memory-safe-assembly

        assembly {

            mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, shl(96, owner)))

            mstore(0x00, operator)

            result := sload(keccak256(0x0c, 0x34))

        }

    }



    /// @dev Sets whether `operator` is approved to manage the tokens of the caller.

    ///

    /// Emits a {ApprovalForAll} event.

    function setApprovalForAll(address operator, bool isApproved) public virtual {

        /// @solidity memory-safe-assembly

        assembly {

            // Clear the upper 96 bits.

            operator := shr(96, shl(96, operator))

            // Convert to 0 or 1.

            isApproved := iszero(iszero(isApproved))

            // Update the `isApproved` for (`msg.sender`, `operator`).

            mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, shl(96, caller())))

            mstore(0x00, operator)

            sstore(keccak256(0x0c, 0x34), isApproved)

            // Emit the {ApprovalForAll} event.

            mstore(0x00, isApproved)

            log3(0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, caller(), operator)

        }

    }



    /// @dev Transfers `amount` of `id` from `from` to `to`.

    ///

    /// Requirements:

    /// - `to` cannot be the zero address.

    /// - `from` must have at least `amount` of `id`.

    /// - If the caller is not `from`,

    ///   it must be approved to manage the tokens of `from`.

    /// - If `to` refers to a smart contract, it must implement

    ///   {ERC1155-onERC1155Reveived}, which is called upon a batch transfer.

    ///

    /// Emits a {Transfer} event.

    function safeTransferFrom(

        address from,

        address to,

        uint256 id,

        uint256 amount,

        bytes calldata data

    ) public virtual {

        if (_useBeforeTokenTransfer()) {

            _beforeTokenTransfer(from, to, _single(id), _single(amount), data);

        }

        /// @solidity memory-safe-assembly

        assembly {

            let fromSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, from))

            let toSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, to))

            mstore(0x20, fromSlotSeed)

            // Clear the upper 96 bits.

            from := shr(96, fromSlotSeed)

            to := shr(96, toSlotSeed)

            // If the caller is not `from`, do the authorization check.

            if iszero(eq(caller(), from)) {

                mstore(0x00, caller())

                if iszero(sload(keccak256(0x0c, 0x34))) {

                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.

                    revert(0x1c, 0x04)

                }

            }

            // Revert if `to` is the zero address.

            if iszero(to) {

                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.

                revert(0x1c, 0x04)

            }

            // Subtract and store the updated balance of `from`.

            {

                mstore(0x00, id)

                let fromBalanceSlot := keccak256(0x00, 0x40)

                let fromBalance := sload(fromBalanceSlot)

                if gt(amount, fromBalance) {

                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.

                    revert(0x1c, 0x04)

                }

                sstore(fromBalanceSlot, sub(fromBalance, amount))

            }

            // Increase and store the updated balance of `to`.

            {

                mstore(0x20, toSlotSeed)

                let toBalanceSlot := keccak256(0x00, 0x40)

                let toBalanceBefore := sload(toBalanceSlot)

                let toBalanceAfter := add(toBalanceBefore, amount)

                if lt(toBalanceAfter, toBalanceBefore) {

                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.

                    revert(0x1c, 0x04)

                }

                sstore(toBalanceSlot, toBalanceAfter)

            }

            // Emit a {TransferSingle} event.

            {

                mstore(0x20, amount)

                log4(0x00, 0x40, _TRANSFER_SINGLE_EVENT_SIGNATURE, caller(), from, to)

            }

        }

        if (_useAfterTokenTransfer()) {

            _afterTokenTransfer(from, to, _single(id), _single(amount), data);

        }

        /// @solidity memory-safe-assembly

        assembly {

            // Do the {onERC1155Received} check if `to` is a smart contract.

            if extcodesize(to) {

                // Prepare the calldata.

                let m := mload(0x40)

                let onERC1155ReceivedSelector := 0xf23a6e61

                mstore(m, onERC1155ReceivedSelector)

                mstore(add(m, 0x20), caller())

                mstore(add(m, 0x40), from)

                mstore(add(m, 0x60), id)

                mstore(add(m, 0x80), amount)

                mstore(add(m, 0xa0), 0xa0)

                calldatacopy(add(m, 0xc0), sub(data.offset, 0x20), add(0x20, data.length))

                // Revert if the call reverts.

                if iszero(call(gas(), to, 0, add(m, 0x1c), add(0xc4, data.length), m, 0x20)) {

                    if returndatasize() {

                        // Bubble up the revert if the delegatecall reverts.

                        returndatacopy(0x00, 0x00, returndatasize())

                        revert(0x00, returndatasize())

                    }

                    mstore(m, 0)

                }

                // Load the returndata and compare it.

                if iszero(eq(mload(m), shl(224, onERC1155ReceivedSelector))) {

                    mstore(0x00, 0x9c05499b) // `TransferToNonERC1155ReceiverImplementer()`.

                    revert(0x1c, 0x04)

                }

            }

        }

    }



    /// @dev Transfers `amounts` of `ids` from `from` to `to`.

    ///

    /// Requirements:

    /// - `to` cannot be the zero address.

    /// - `from` must have at least `amount` of `id`.

    /// - `ids` and `amounts` must have the same length.

    /// - If the caller is not `from`,

    ///   it must be approved to manage the tokens of `from`.

    /// - If `to` refers to a smart contract, it must implement

    ///   {ERC1155-onERC1155BatchReveived}, which is called upon a batch transfer.

    ///

    /// Emits a {TransferBatch} event.

    function safeBatchTransferFrom(

        address from,

        address to,

        uint256[] calldata ids,

        uint256[] calldata amounts,

        bytes calldata data

    ) public virtual {

        if (_useBeforeTokenTransfer()) {

            _beforeTokenTransfer(from, to, ids, amounts, data);

        }

        /// @solidity memory-safe-assembly

        assembly {

            if iszero(eq(ids.length, amounts.length)) {

                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.

                revert(0x1c, 0x04)

            }

            let fromSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, from))

            let toSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, to))

            mstore(0x20, fromSlotSeed)

            // Clear the upper 96 bits.

            from := shr(96, fromSlotSeed)

            to := shr(96, toSlotSeed)

            // Revert if `to` is the zero address.

            if iszero(to) {

                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.

                revert(0x1c, 0x04)

            }

            // If the caller is not `from`, do the authorization check.

            if iszero(eq(caller(), from)) {

                mstore(0x00, caller())

                if iszero(sload(keccak256(0x0c, 0x34))) {

                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.

                    revert(0x1c, 0x04)

                }

            }

            // Loop through all the `ids` and update the balances.

            {

                let end := shl(5, ids.length)

                for { let i := 0 } iszero(eq(i, end)) { i := add(i, 0x20) } {

                    let amount := calldataload(add(amounts.offset, i))

                    // Subtract and store the updated balance of `from`.

                    {

                        mstore(0x20, fromSlotSeed)

                        mstore(0x00, calldataload(add(ids.offset, i)))

                        let fromBalanceSlot := keccak256(0x00, 0x40)

                        let fromBalance := sload(fromBalanceSlot)

                        if gt(amount, fromBalance) {

                            mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.

                            revert(0x1c, 0x04)

                        }

                        sstore(fromBalanceSlot, sub(fromBalance, amount))

                    }

                    // Increase and store the updated balance of `to`.

                    {

                        mstore(0x20, toSlotSeed)

                        let toBalanceSlot := keccak256(0x00, 0x40)

                        let toBalanceBefore := sload(toBalanceSlot)

                        let toBalanceAfter := add(toBalanceBefore, amount)

                        if lt(toBalanceAfter, toBalanceBefore) {

                            mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.

                            revert(0x1c, 0x04)

                        }

                        sstore(toBalanceSlot, toBalanceAfter)

                    }

                }

            }

            // Emit a {TransferBatch} event.

            {

                let m := mload(0x40)

                // Copy the `ids`.

                mstore(m, 0x40)

                let n := add(0x20, shl(5, ids.length))

                let o := add(m, 0x40)

                calldatacopy(o, sub(ids.offset, 0x20), n)

                // Copy the `amounts`.

                mstore(add(m, 0x20), add(0x40, n))

                o := add(o, n)

                n := add(0x20, shl(5, amounts.length))

                calldatacopy(o, sub(amounts.offset, 0x20), n)

                n := sub(add(o, n), m)

                // Do the emit.

                log4(m, n, _TRANSFER_BATCH_EVENT_SIGNATURE, caller(), from, to)

            }

        }

        if (_useAfterTokenTransfer()) {

            _afterTokenTransferCalldata(from, to, ids, amounts, data);

        }

        /// @solidity memory-safe-assembly

        assembly {

            // Do the {onERC1155BatchReceived} check if `to` is a smart contract.

            if extcodesize(to) {

                let m := mload(0x40)

                // Prepare the calldata.

                let onERC1155BatchReceivedSelector := 0xbc197c81

                mstore(m, onERC1155BatchReceivedSelector)

                mstore(add(m, 0x20), caller())

                mstore(add(m, 0x40), from)

                // Copy the `ids`.

                mstore(add(m, 0x60), 0xa0)

                let n := add(0x20, shl(5, ids.length))

                let o := add(m, 0xc0)

                calldatacopy(o, sub(ids.offset, 0x20), n)

                // Copy the `amounts`.

                let s := add(0xa0, n)

                mstore(add(m, 0x80), s)

                o := add(o, n)

                n := add(0x20, shl(5, amounts.length))

                calldatacopy(o, sub(amounts.offset, 0x20), n)

                // Copy the `data`.

                mstore(add(m, 0xa0), add(s, n))

                o := add(o, n)

                n := add(0x20, data.length)

                calldatacopy(o, sub(data.offset, 0x20), n)

                n := sub(add(o, n), add(m, 0x1c))

                // Revert if the call reverts.

                if iszero(call(gas(), to, 0, add(m, 0x1c), n, m, 0x20)) {

                    if returndatasize() {

                        // Bubble up the revert if the delegatecall reverts.

                        returndatacopy(0x00, 0x00, returndatasize())

                        revert(0x00, returndatasize())

                    }

                    mstore(m, 0)

                }

                // Load the returndata and compare it.

                if iszero(eq(mload(m), shl(224, onERC1155BatchReceivedSelector))) {

                    mstore(0x00, 0x9c05499b) // `TransferToNonERC1155ReceiverImplementer()`.

                    revert(0x1c, 0x04)

                }

            }

        }

    }



    /// @dev Returns the amounts of `ids` for `owners.

    ///

    /// Requirements:

    /// - `owners` and `ids` must have the same length.

    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)

        public

        view

        virtual

        returns (uint256[] memory balances)

    {

        /// @solidity memory-safe-assembly

        assembly {

            if iszero(eq(ids.length, owners.length)) {

                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.

                revert(0x1c, 0x04)

            }

            balances := mload(0x40)

            mstore(balances, ids.length)

            let o := add(balances, 0x20)

            let end := shl(5, ids.length)

            mstore(0x40, add(end, o))

            // Loop through all the `ids` and load the balances.

            for { let i := 0 } iszero(eq(i, end)) { i := add(i, 0x20) } {

                let owner := calldataload(add(owners.offset, i))

                mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, shl(96, owner)))

                mstore(0x00, calldataload(add(ids.offset, i)))

                mstore(add(o, i), sload(keccak256(0x00, 0x40)))

            }

        }

    }



    /// @dev Returns true if this contract implements the interface defined by `interfaceId`.

    /// See: https://eips.ethereum.org/EIPS/eip-165

    /// This function call must use less than 30000 gas.

    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {

        /// @solidity memory-safe-assembly

        assembly {

            let s := shr(224, interfaceId)

            // ERC165: 0x01ffc9a7, ERC1155: 0xd9b67a26, ERC1155MetadataURI: 0x0e89341c.

            result := or(or(eq(s, 0x01ffc9a7), eq(s, 0xd9b67a26)), eq(s, 0x0e89341c))

        }

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                  INTERNAL MINT FUNCTIONS                   */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Mints `amount` of `id` to `to`.

    ///

    /// Requirements:

    /// - `to` cannot be the zero address.

    /// - If `to` refers to a smart contract, it must implement

    ///   {ERC1155-onERC1155Reveived}, which is called upon a batch transfer.

    ///

    /// Emits a {Transfer} event.

    function _mint(address to, uint256 id, uint256 amount, bytes memory data) internal virtual {

        if (_useBeforeTokenTransfer()) {

            _beforeTokenTransfer(address(0), to, _single(id), _single(amount), data);

        }

        /// @solidity memory-safe-assembly

        assembly {

            let toSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, to))

            // Clear the upper 96 bits.

            to := shr(96, toSlotSeed)

            // Revert if `to` is the zero address.

            if iszero(to) {

                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.

                revert(0x1c, 0x04)

            }

            // Increase and store the updated balance of `to`.

            {

                mstore(0x20, toSlotSeed)

                mstore(0x00, id)

                let toBalanceSlot := keccak256(0x00, 0x40)

                let toBalanceBefore := sload(toBalanceSlot)

                let toBalanceAfter := add(toBalanceBefore, amount)

                if lt(toBalanceAfter, toBalanceBefore) {

                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.

                    revert(0x1c, 0x04)

                }

                sstore(toBalanceSlot, toBalanceAfter)

            }

            // Emit a {TransferSingle} event.

            {

                mstore(0x00, id)

                mstore(0x20, amount)

                log4(0x00, 0x40, _TRANSFER_SINGLE_EVENT_SIGNATURE, caller(), 0, to)

            }

        }

        if (_useAfterTokenTransfer()) {

            _afterTokenTransfer(address(0), to, _single(id), _single(amount), data);

        }

        if (_hasCode(to)) _checkOnERC1155Received(address(0), to, id, amount, data);

    }



    /// @dev Mints `amounts` of `ids` to `to`.

    ///

    /// Requirements:

    /// - `to` cannot be the zero address.

    /// - `ids` and `amounts` must have the same length.

    /// - If `to` refers to a smart contract, it must implement

    ///   {ERC1155-onERC1155BatchReveived}, which is called upon a batch transfer.

    ///

    /// Emits a {TransferBatch} event.

    function _batchMint(

        address to,

        uint256[] memory ids,

        uint256[] memory amounts,

        bytes memory data

    ) internal virtual {

        if (_useBeforeTokenTransfer()) {

            _beforeTokenTransfer(address(0), to, ids, amounts, data);

        }

        /// @solidity memory-safe-assembly

        assembly {

            if iszero(eq(mload(ids), mload(amounts))) {

                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.

                revert(0x1c, 0x04)

            }

            let toSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, to))

            // Clear the upper 96 bits.

            to := shr(96, toSlotSeed)

            // Revert if `to` is the zero address.

            if iszero(to) {

                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.

                revert(0x1c, 0x04)

            }

            // Loop through all the `ids` and update the balances.

            {

                let end := shl(5, mload(ids))

                for { let i := 0 } iszero(eq(i, end)) {} {

                    i := add(i, 0x20)

                    let amount := mload(add(amounts, i))

                    // Increase and store the updated balance of `to`.

                    {

                        mstore(0x20, toSlotSeed)

                        mstore(0x00, mload(add(ids, i)))

                        let toBalanceSlot := keccak256(0x00, 0x40)

                        let toBalanceBefore := sload(toBalanceSlot)

                        let toBalanceAfter := add(toBalanceBefore, amount)

                        if lt(toBalanceAfter, toBalanceBefore) {

                            mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.

                            revert(0x1c, 0x04)

                        }

                        sstore(toBalanceSlot, toBalanceAfter)

                    }

                }

            }

            // Emit a {TransferBatch} event.

            {

                let m := mload(0x40)

                // Copy the `ids`.

                mstore(m, 0x40)

                let n := add(0x20, shl(5, mload(ids)))

                let o := add(m, 0x40)

                pop(staticcall(gas(), 4, ids, n, o, n))

                // Copy the `amounts`.

                mstore(add(m, 0x20), add(0x40, returndatasize()))

                o := add(o, returndatasize())

                n := add(0x20, shl(5, mload(amounts)))

                pop(staticcall(gas(), 4, amounts, n, o, n))

                n := sub(add(o, returndatasize()), m)

                // Do the emit.

                log4(m, n, _TRANSFER_BATCH_EVENT_SIGNATURE, caller(), 0, to)

            }

        }

        if (_useAfterTokenTransfer()) {

            _afterTokenTransfer(address(0), to, ids, amounts, data);

        }

        if (_hasCode(to)) _checkOnERC1155BatchReceived(address(0), to, ids, amounts, data);

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                  INTERNAL BURN FUNCTIONS                   */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Equivalent to `_burn(address(0), from, id, amount)`.

    function _burn(address from, uint256 id, uint256 amount) internal virtual {

        _burn(address(0), from, id, amount);

    }



    /// @dev Destroys `amount` of `id` from `from`.

    ///

    /// Requirements:

    /// - `from` must have at least `amount` of `id`.

    /// - If `by` is not the zero address, it must be either `from`,

    ///   or approved to manage the tokens of `from`.

    ///

    /// Emits a {Transfer} event.

    function _burn(address by, address from, uint256 id, uint256 amount) internal virtual {

        if (_useBeforeTokenTransfer()) {

            _beforeTokenTransfer(from, address(0), _single(id), _single(amount), "");

        }

        /// @solidity memory-safe-assembly

        assembly {

            let fromSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, from))

            mstore(0x20, fromSlotSeed)

            // Clear the upper 96 bits.

            from := shr(96, fromSlotSeed)

            by := shr(96, shl(96, by))

            // If `by` is not the zero address, and not equal to `from`,

            // check if it is approved to manage all the tokens of `from`.

            if iszero(or(iszero(by), eq(by, from))) {

                mstore(0x00, by)

                if iszero(sload(keccak256(0x0c, 0x34))) {

                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.

                    revert(0x1c, 0x04)

                }

            }

            // Decrease and store the updated balance of `from`.

            {

                mstore(0x00, id)

                let fromBalanceSlot := keccak256(0x00, 0x40)

                let fromBalance := sload(fromBalanceSlot)

                if gt(amount, fromBalance) {

                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.

                    revert(0x1c, 0x04)

                }

                sstore(fromBalanceSlot, sub(fromBalance, amount))

            }

            // Emit a {TransferSingle} event.

            {

                mstore(0x00, id)

                mstore(0x20, amount)

                log4(0x00, 0x40, _TRANSFER_SINGLE_EVENT_SIGNATURE, caller(), from, 0)

            }

        }

        if (_useAfterTokenTransfer()) {

            _afterTokenTransfer(from, address(0), _single(id), _single(amount), "");

        }

    }



    /// @dev Equivalent to `_batchBurn(address(0), from, ids, amounts)`.

    function _batchBurn(address from, uint256[] memory ids, uint256[] memory amounts)

        internal

        virtual

    {

        _batchBurn(address(0), from, ids, amounts);

    }



    /// @dev Destroys `amounts` of `ids` from `from`.

    ///

    /// Requirements:

    /// - `ids` and `amounts` must have the same length.

    /// - `from` must have at least `amounts` of `ids`.

    /// - If `by` is not the zero address, it must be either `from`,

    ///   or approved to manage the tokens of `from`.

    ///

    /// Emits a {TransferBatch} event.

    function _batchBurn(address by, address from, uint256[] memory ids, uint256[] memory amounts)

        internal

        virtual

    {

        if (_useBeforeTokenTransfer()) {

            _beforeTokenTransfer(from, address(0), ids, amounts, "");

        }

        /// @solidity memory-safe-assembly

        assembly {

            if iszero(eq(mload(ids), mload(amounts))) {

                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.

                revert(0x1c, 0x04)

            }

            let fromSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, from))

            mstore(0x20, fromSlotSeed)

            // Clear the upper 96 bits.

            from := shr(96, fromSlotSeed)

            by := shr(96, shl(96, by))

            // If `by` is not the zero address, and not equal to `from`,

            // check if it is approved to manage all the tokens of `from`.

            if iszero(or(iszero(by), eq(by, from))) {

                mstore(0x00, by)

                if iszero(sload(keccak256(0x0c, 0x34))) {

                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.

                    revert(0x1c, 0x04)

                }

            }

            // Loop through all the `ids` and update the balances.

            {

                let end := shl(5, mload(ids))

                for { let i := 0 } iszero(eq(i, end)) {} {

                    i := add(i, 0x20)

                    let amount := mload(add(amounts, i))

                    // Increase and store the updated balance of `to`.

                    {

                        mstore(0x00, mload(add(ids, i)))

                        let fromBalanceSlot := keccak256(0x00, 0x40)

                        let fromBalance := sload(fromBalanceSlot)

                        if gt(amount, fromBalance) {

                            mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.

                            revert(0x1c, 0x04)

                        }

                        sstore(fromBalanceSlot, sub(fromBalance, amount))

                    }

                }

            }

            // Emit a {TransferBatch} event.

            {

                let m := mload(0x40)

                // Copy the `ids`.

                mstore(m, 0x40)

                let n := add(0x20, shl(5, mload(ids)))

                let o := add(m, 0x40)

                pop(staticcall(gas(), 4, ids, n, o, n))

                // Copy the `amounts`.

                mstore(add(m, 0x20), add(0x40, returndatasize()))

                o := add(o, returndatasize())

                n := add(0x20, shl(5, mload(amounts)))

                pop(staticcall(gas(), 4, amounts, n, o, n))

                n := sub(add(o, returndatasize()), m)

                // Do the emit.

                log4(m, n, _TRANSFER_BATCH_EVENT_SIGNATURE, caller(), from, 0)

            }

        }

        if (_useAfterTokenTransfer()) {

            _afterTokenTransfer(from, address(0), ids, amounts, "");

        }

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                INTERNAL APPROVAL FUNCTIONS                 */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Approve or remove the `operator` as an operator for `by`,

    /// without authorization checks.

    ///

    /// Emits a {ApprovalForAll} event.

    function _setApprovalForAll(address by, address operator, bool isApproved) internal virtual {

        /// @solidity memory-safe-assembly

        assembly {

            // Clear the upper 96 bits.

            operator := shr(96, shl(96, operator))

            // Convert to 0 or 1.

            isApproved := iszero(iszero(isApproved))

            // Update the `isApproved` for (`by`, `operator`).

            mstore(0x20, or(_ERC1155_MASTER_SLOT_SEED, shl(96, by)))

            mstore(0x00, operator)

            sstore(keccak256(0x0c, 0x34), isApproved)

            // Emit the {ApprovalForAll} event.

            mstore(0x00, isApproved)

            log3(0x00, 0x20, _APPROVAL_FOR_ALL_EVENT_SIGNATURE, caller(), operator)

        }

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                INTERNAL TRANSFER FUNCTIONS                 */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Equivalent to `_safeTransfer(address(0), from, to, id, amount, data)`.

    function _safeTransfer(address from, address to, uint256 id, uint256 amount, bytes memory data)

        internal

        virtual

    {

        _safeTransfer(address(0), from, to, id, amount, data);

    }



    /// @dev Transfers `amount` of `id` from `from` to `to`.

    ///

    /// Requirements:

    /// - `to` cannot be the zero address.

    /// - `from` must have at least `amount` of `id`.

    /// - If `by` is not the zero address, it must be either `from`,

    ///   or approved to manage the tokens of `from`.

    /// - If `to` refers to a smart contract, it must implement

    ///   {ERC1155-onERC1155Reveived}, which is called upon a batch transfer.

    ///

    /// Emits a {Transfer} event.

    function _safeTransfer(

        address by,

        address from,

        address to,

        uint256 id,

        uint256 amount,

        bytes memory data

    ) internal virtual {

        if (_useBeforeTokenTransfer()) {

            _beforeTokenTransfer(from, to, _single(id), _single(amount), data);

        }

        /// @solidity memory-safe-assembly

        assembly {

            let fromSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, from))

            let toSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, to))

            mstore(0x20, fromSlotSeed)

            // Clear the upper 96 bits.

            from := shr(96, fromSlotSeed)

            to := shr(96, toSlotSeed)

            by := shr(96, shl(96, by))

            // If `by` is not the zero address, and not equal to `from`,

            // check if it is approved to manage all the tokens of `from`.

            if iszero(or(iszero(by), eq(by, from))) {

                mstore(0x00, by)

                if iszero(sload(keccak256(0x0c, 0x34))) {

                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.

                    revert(0x1c, 0x04)

                }

            }

            // Revert if `to` is the zero address.

            if iszero(to) {

                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.

                revert(0x1c, 0x04)

            }

            // Subtract and store the updated balance of `from`.

            {

                mstore(0x00, id)

                let fromBalanceSlot := keccak256(0x00, 0x40)

                let fromBalance := sload(fromBalanceSlot)

                if gt(amount, fromBalance) {

                    mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.

                    revert(0x1c, 0x04)

                }

                sstore(fromBalanceSlot, sub(fromBalance, amount))

            }

            // Increase and store the updated balance of `to`.

            {

                mstore(0x20, toSlotSeed)

                let toBalanceSlot := keccak256(0x00, 0x40)

                let toBalanceBefore := sload(toBalanceSlot)

                let toBalanceAfter := add(toBalanceBefore, amount)

                if lt(toBalanceAfter, toBalanceBefore) {

                    mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.

                    revert(0x1c, 0x04)

                }

                sstore(toBalanceSlot, toBalanceAfter)

            }

            // Emit a {TransferSingle} event.

            {

                mstore(0x20, amount)

                log4(0x00, 0x40, _TRANSFER_SINGLE_EVENT_SIGNATURE, caller(), from, to)

            }

        }

        if (_hasCode(to)) _checkOnERC1155Received(from, to, id, amount, data);

        if (_useAfterTokenTransfer()) {

            _afterTokenTransfer(from, to, _single(id), _single(amount), data);

        }

    }



    /// @dev Equivalent to `_safeBatchTransfer(address(0), from, to, ids, amounts, data)`.

    function _safeBatchTransfer(

        address from,

        address to,

        uint256[] memory ids,

        uint256[] memory amounts,

        bytes memory data

    ) internal virtual {

        _safeBatchTransfer(address(0), from, to, ids, amounts, data);

    }



    /// @dev Transfers `amounts` of `ids` from `from` to `to`.

    ///

    /// Requirements:

    /// - `to` cannot be the zero address.

    /// - `ids` and `amounts` must have the same length.

    /// - `from` must have at least `amounts` of `ids`.

    /// - If `by` is not the zero address, it must be either `from`,

    ///   or approved to manage the tokens of `from`.

    /// - If `to` refers to a smart contract, it must implement

    ///   {ERC1155-onERC1155BatchReveived}, which is called upon a batch transfer.

    ///

    /// Emits a {TransferBatch} event.

    function _safeBatchTransfer(

        address by,

        address from,

        address to,

        uint256[] memory ids,

        uint256[] memory amounts,

        bytes memory data

    ) internal virtual {

        if (_useBeforeTokenTransfer()) {

            _beforeTokenTransfer(from, to, ids, amounts, data);

        }

        /// @solidity memory-safe-assembly

        assembly {

            if iszero(eq(mload(ids), mload(amounts))) {

                mstore(0x00, 0x3b800a46) // `ArrayLengthsMismatch()`.

                revert(0x1c, 0x04)

            }

            let fromSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, from))

            let toSlotSeed := or(_ERC1155_MASTER_SLOT_SEED, shl(96, to))

            mstore(0x20, fromSlotSeed)

            // Clear the upper 96 bits.

            from := shr(96, fromSlotSeed)

            to := shr(96, toSlotSeed)

            by := shr(96, shl(96, by))

            // Revert if `to` is the zero address.

            if iszero(to) {

                mstore(0x00, 0xea553b34) // `TransferToZeroAddress()`.

                revert(0x1c, 0x04)

            }

            // If `by` is not the zero address, and not equal to `from`,

            // check if it is approved to manage all the tokens of `from`.

            if iszero(or(iszero(by), eq(by, from))) {

                mstore(0x00, by)

                if iszero(sload(keccak256(0x0c, 0x34))) {

                    mstore(0x00, 0x4b6e7f18) // `NotOwnerNorApproved()`.

                    revert(0x1c, 0x04)

                }

            }

            // Loop through all the `ids` and update the balances.

            {

                let end := shl(5, mload(ids))

                for { let i := 0 } iszero(eq(i, end)) {} {

                    i := add(i, 0x20)

                    let amount := mload(add(amounts, i))

                    // Subtract and store the updated balance of `from`.

                    {

                        mstore(0x20, fromSlotSeed)

                        mstore(0x00, mload(add(ids, i)))

                        let fromBalanceSlot := keccak256(0x00, 0x40)

                        let fromBalance := sload(fromBalanceSlot)

                        if gt(amount, fromBalance) {

                            mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.

                            revert(0x1c, 0x04)

                        }

                        sstore(fromBalanceSlot, sub(fromBalance, amount))

                    }

                    // Increase and store the updated balance of `to`.

                    {

                        mstore(0x20, toSlotSeed)

                        let toBalanceSlot := keccak256(0x00, 0x40)

                        let toBalanceBefore := sload(toBalanceSlot)

                        let toBalanceAfter := add(toBalanceBefore, amount)

                        if lt(toBalanceAfter, toBalanceBefore) {

                            mstore(0x00, 0x01336cea) // `AccountBalanceOverflow()`.

                            revert(0x1c, 0x04)

                        }

                        sstore(toBalanceSlot, toBalanceAfter)

                    }

                }

            }

            // Emit a {TransferBatch} event.

            {

                let m := mload(0x40)

                // Copy the `ids`.

                mstore(m, 0x40)

                let n := add(0x20, shl(5, mload(ids)))

                let o := add(m, 0x40)

                pop(staticcall(gas(), 4, ids, n, o, n))

                // Copy the `amounts`.

                mstore(add(m, 0x20), add(0x40, returndatasize()))

                o := add(o, returndatasize())

                n := add(0x20, shl(5, mload(amounts)))

                pop(staticcall(gas(), 4, amounts, n, o, n))

                n := sub(add(o, returndatasize()), m)

                // Do the emit.

                log4(m, n, _TRANSFER_BATCH_EVENT_SIGNATURE, caller(), from, to)

            }

        }

        if (_hasCode(to)) _checkOnERC1155BatchReceived(from, to, ids, amounts, data);

        if (_useAfterTokenTransfer()) {

            _afterTokenTransfer(from, to, ids, amounts, data);

        }

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                    HOOKS FOR OVERRIDING                    */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Override this function to return true if `_beforeTokenTransfer` is used.

    /// The is to help the compiler avoid producing dead bytecode.

    function _useBeforeTokenTransfer() internal view virtual returns (bool) {

        return false;

    }



    /// @dev Hook that is called before any token transfer.

    /// This includes minting and burning, as well as batched variants.

    ///

    /// The same hook is called on both single and batched variants.

    /// For single transfers, the length of the `id` and `amount` arrays are 1.

    function _beforeTokenTransfer(

        address from,

        address to,

        uint256[] memory ids,

        uint256[] memory amounts,

        bytes memory data

    ) internal virtual {}



    /// @dev Override this function to return true if `_afterTokenTransfer` is used.

    /// The is to help the compiler avoid producing dead bytecode.

    function _useAfterTokenTransfer() internal view virtual returns (bool) {

        return false;

    }



    /// @dev Hook that is called after any token transfer.

    /// This includes minting and burning, as well as batched variants.

    ///

    /// The same hook is called on both single and batched variants.

    /// For single transfers, the length of the `id` and `amount` arrays are 1.

    function _afterTokenTransfer(

        address from,

        address to,

        uint256[] memory ids,

        uint256[] memory amounts,

        bytes memory data

    ) internal virtual {}



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                      PRIVATE HELPERS                       */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Helper for calling the `_afterTokenTransfer` hook.

    /// The is to help the compiler avoid producing dead bytecode.

    function _afterTokenTransferCalldata(

        address from,

        address to,

        uint256[] calldata ids,

        uint256[] calldata amounts,

        bytes calldata data

    ) private {

        if (_useAfterTokenTransfer()) {

            _afterTokenTransfer(from, to, ids, amounts, data);

        }

    }



    /// @dev Returns if `a` has bytecode of non-zero length.

    function _hasCode(address a) private view returns (bool result) {

        /// @solidity memory-safe-assembly

        assembly {

            result := extcodesize(a) // Can handle dirty upper bits.

        }

    }



    /// @dev Perform a call to invoke {IERC1155Receiver-onERC1155Received} on `to`.

    /// Reverts if the target does not support the function correctly.

    function _checkOnERC1155Received(

        address from,

        address to,

        uint256 id,

        uint256 amount,

        bytes memory data

    ) private {

        /// @solidity memory-safe-assembly

        assembly {

            // Prepare the calldata.

            let m := mload(0x40)

            let onERC1155ReceivedSelector := 0xf23a6e61

            mstore(m, onERC1155ReceivedSelector)

            mstore(add(m, 0x20), caller())

            mstore(add(m, 0x40), shr(96, shl(96, from)))

            mstore(add(m, 0x60), id)

            mstore(add(m, 0x80), amount)

            mstore(add(m, 0xa0), 0xa0)

            let n := mload(data)

            mstore(add(m, 0xc0), n)

            if n { pop(staticcall(gas(), 4, add(data, 0x20), n, add(m, 0xe0), n)) }

            // Revert if the call reverts.

            if iszero(call(gas(), to, 0, add(m, 0x1c), add(0xc4, n), m, 0x20)) {

                if returndatasize() {

                    // Bubble up the revert if the delegatecall reverts.

                    returndatacopy(0x00, 0x00, returndatasize())

                    revert(0x00, returndatasize())

                }

                mstore(m, 0)

            }

            // Load the returndata and compare it.

            if iszero(eq(mload(m), shl(224, onERC1155ReceivedSelector))) {

                mstore(0x00, 0x9c05499b) // `TransferToNonERC1155ReceiverImplementer()`.

                revert(0x1c, 0x04)

            }

        }

    }



    /// @dev Perform a call to invoke {IERC1155Receiver-onERC1155BatchReceived} on `to`.

    /// Reverts if the target does not support the function correctly.

    function _checkOnERC1155BatchReceived(

        address from,

        address to,

        uint256[] memory ids,

        uint256[] memory amounts,

        bytes memory data

    ) private {

        /// @solidity memory-safe-assembly

        assembly {

            // Prepare the calldata.

            let m := mload(0x40)

            let onERC1155BatchReceivedSelector := 0xbc197c81

            mstore(m, onERC1155BatchReceivedSelector)

            mstore(add(m, 0x20), caller())

            mstore(add(m, 0x40), shr(96, shl(96, from)))

            // Copy the `ids`.

            mstore(add(m, 0x60), 0xa0)

            let n := add(0x20, shl(5, mload(ids)))

            let o := add(m, 0xc0)

            pop(staticcall(gas(), 4, ids, n, o, n))

            // Copy the `amounts`.

            let s := add(0xa0, returndatasize())

            mstore(add(m, 0x80), s)

            o := add(o, returndatasize())

            n := add(0x20, shl(5, mload(amounts)))

            pop(staticcall(gas(), 4, amounts, n, o, n))

            // Copy the `data`.

            mstore(add(m, 0xa0), add(s, returndatasize()))

            o := add(o, returndatasize())

            n := add(0x20, mload(data))

            pop(staticcall(gas(), 4, data, n, o, n))

            n := sub(add(o, returndatasize()), add(m, 0x1c))

            // Revert if the call reverts.

            if iszero(call(gas(), to, 0, add(m, 0x1c), n, m, 0x20)) {

                if returndatasize() {

                    // Bubble up the revert if the delegatecall reverts.

                    returndatacopy(0x00, 0x00, returndatasize())

                    revert(0x00, returndatasize())

                }

                mstore(m, 0)

            }

            // Load the returndata and compare it.

            if iszero(eq(mload(m), shl(224, onERC1155BatchReceivedSelector))) {

                mstore(0x00, 0x9c05499b) // `TransferToNonERC1155ReceiverImplementer()`.

                revert(0x1c, 0x04)

            }

        }

    }



    /// @dev Returns `x` in an array with a single element.

    function _single(uint256 x) private pure returns (uint256[] memory result) {

        assembly {

            result := mload(0x40)

            mstore(0x40, add(result, 0x40))

            mstore(result, 1)

            mstore(add(result, 0x20), x)

        }

    }

}



// File: market/monymarketIV.sol







/// @title monymarketIII

/// @author Arthur T. McDonald



pragma solidity ^0.8.17;















contract MonyMarketIV is Ownable {



    event Purchase(address seller, address buyer, address collection, address currency, uint256 tokenId, uint256 price);

    event StallRequest(uint256[] listings);



    error YouDontOwn();

    error SaleNotOn();

    error CurrencyAllowanceError();

    error TokenApprovalError();

    error FormatError();



    mapping(uint256=>listing) public listingList;



    struct listing {

        bool saleOn;

        uint256 erc;

        address seller;

        address collection;

        address currency;

        uint256 tokenId;

        uint256 price;

    }



    bytes32 private root;

    uint256 public listingCount;

    bool public marketOpen;



    constructor()  {      

        _initializeOwner(msg.sender); 

    }



    function writeListing(uint256 erc, address collection, address currency, uint256 tokenId, string calldata price) public payable{

            require(msg.value == 1000000000000000,"YOU MUST PAY .001");

            createListing(erc,collection,currency,tokenId,convertPrice(price));

    }



    function writeListingFriend(bytes32[] calldata proof, uint256 erc, address collection, address currency, uint256 tokenId, string calldata price) public {

            require(proven(proof, root, leafit()),"Oh you dont own a MiladyStation.. awkward");

            createListing(erc,collection,currency,tokenId,convertPrice(price));

    }



    function createListing(uint256 erc, address collection, address currency, uint256 tokenId, uint256 price) internal{

        require(marketOpen, "We are closed, come back later");

        if(checkFormat(erc,price)){

            if(erc == 721){

                if (!checkItemOwned721(collection,tokenId)){revert YouDontOwn();}

            }

            if (erc == 1155) {

                if (!checkItemOwned1155(collection,tokenId)){revert YouDontOwn();}

            }

            listing memory newListing = listing(true,erc,msg.sender,collection,currency,tokenId,price);

            listingList[listingCount] = newListing;

            ++listingCount;

        } else {revert FormatError();}

    }



    function deleteListing(uint256 listingId) public {

        listing storage target = listingList[listingId];

        require(target.seller == msg.sender,"this is not your listing");

        target.saleOn = false;

    }



    function editPrice(string calldata newPrice, uint256 listingId) public {

        listing storage target = listingList[listingId];

        require(target.seller == msg.sender,"this is not your listing");

        target.price = convertPrice(newPrice);

    }



    function requestMarketStall(uint256[] calldata listings) public payable {

        require(marketOpen, "We are closed, come back later");

        require(msg.value == 77700000000000000,"YOU MUST PAY .0777");

        emit StallRequest(listings);

    }



    function purchase(uint256 listingId) public payable{

        require(marketOpen, "We are closed, come back later");

        require(msg.value == 1000000000000000,"YOU MUST PAY .001");

        buy(listingId);

    }



    function purchaseFriend(bytes32[] calldata proof, uint256 listingId) public {

        require(marketOpen, "We are closed, come back later");

        require(proven(proof, root, leafit()),"Oh you dont own a MiladyStation.. awkward");

        buy(listingId);

    }



    function buy(uint256 listingId) internal{

        //storage call local listing instance

        listing memory _listing = listingList[listingId];



        //sale check

        if (_listing.saleOn == false) { revert SaleNotOn();}

        ERC20 coin = ERC20(_listing.currency);



        //check allowance

        if (coin.allowance(msg.sender,address(this)) < _listing.price){ revert CurrencyAllowanceError();}



        //erc tree

        if (_listing.erc == 721) {

            ERC721 nft = ERC721(_listing.collection);

            //check approval

            if(nft.isApprovedForAll(_listing.seller, address(this)) == false){ revert TokenApprovalError();}

            //SENDIT

            nft.transferFrom(_listing.seller, msg.sender, _listing.tokenId);

        } else if (_listing.erc == 1155) {

            ERC1155 nft = ERC1155(_listing.collection);

            //check approval

            if(nft.isApprovedForAll(_listing.seller,address(this)) == false){ revert TokenApprovalError();}

            //SENDIT

            nft.safeTransferFrom(_listing.seller, msg.sender, _listing.tokenId, 1, "");

        }



        //okay now payup

        coin.transferFrom(msg.sender, _listing.seller, _listing.price);



        //turn off the sale

        listingList[listingId].saleOn = false;



        emit Purchase(_listing.seller,msg.sender,_listing.collection,_listing.currency,_listing.tokenId,_listing.price);

    }



    function checkItemOwned721 (address collection, uint256 tokenId) internal view returns (bool) {

        ERC721 nft = ERC721(collection);

        if (msg.sender == nft.ownerOf(tokenId)){

            return true;

        } else {

            return false;

        }

    }



    function checkItemOwned1155 (address collection, uint256 tokenId) internal view returns (bool) {

        ERC1155 nft = ERC1155(collection);

        if (nft.balanceOf(msg.sender,tokenId) > 0){

            return true;

        } else {

            return false;

        }

    }



    function convertPrice(string memory _str) public pure returns(uint256 res) {

        for (uint256 i = 0; i < bytes(_str).length; i++) {

            if ((uint8(bytes(_str)[i]) - 48) < 0 || (uint8(bytes(_str)[i]) - 48) > 9) {

                return 0;

            }

            res += (uint8(bytes(_str)[i]) - 48) * 10**(bytes(_str).length - i - 1);

        }

        return res;

    }



    function checkFormat (uint256 erc, uint256 price) internal pure returns (bool) {

        require(erc==721||erc==1155,"must be 721 or 1155");

        require(price>1e6,"check your decimals");

        return true;

    }



    function setRoot(bytes32 newRoot) public onlyOwner {

        root = newRoot;

    }



    //uses solady merkleprooflib to prove a merkle proof proves merkleness

    function proven (bytes32[] calldata proof, bytes32 key, bytes32 leaf) internal pure returns (bool) {

        bool prove = MerkleProofLib.verifyCalldata(proof, key, leaf);

        return prove;

    }



    //hashes msg.sender for merkling

    function leafit() internal view returns (bytes32) {

        bytes20 me = bytes20(msg.sender);

        return keccak256(abi.encodePacked(me));

    }



    function openSwitch() public onlyOwner {

        marketOpen = !marketOpen;

    }



    function withdraw() external onlyOwner {

        uint balance = address(this).balance;

        payable(msg.sender).transfer(balance);

    }





}