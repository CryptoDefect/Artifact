// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";

/// @title Raffles manager (single winner and NFT prize)
/// @author Luis Pando
/// @notice It consumes VRF v1 from Chainlink. It has the role
/// "operator" that is the one used by a backend app to make some calls
/// @dev It saves in an ordered array the player wallet and the current
/// entries count. So buying entries has a complexity of O(1)
/// For calculating the winner, from the huge random number generated by Chainlink
/// a normalized random is generated by using the module method, adding 1 to have
/// a random from 1 to entriesCount.
/// So next step is to perform a binary search on the ordered array to get the
/// player O(log n)
/// Example:
/// 0 -> { 1, player1} as player1 buys 1 entry
/// 1 -> {51, player2} as player2 buys 50 entries
/// 2 -> {52, player3} as player3 buys 1 entry
/// 3 -> {53, player4} as player4 buys 1 entry
/// 4 -> {153, player5} as player5 buys 100 entries
/// So the setWinner method performs a binary search on that sorted array to get the upper bound.
/// If the random number generated is 150, the winner is player5. If the random number is 20, winner is player2

contract NFTSingle is AccessControl, ReentrancyGuard, VRFConsumerBase {
    ////////// CHAINLINK VRF v1 /////////////////
    bytes32 internal keyHash; // chainlink
    uint256 internal fee; // fee paid in LINK to chainlink. 0.1 in Rinkeby, 2 in mainnet

    struct RandomResult {
        uint256 randomNumber; // random number generated by chainlink.
        uint256 nomalizedRandomNumber; // random number % entriesLength + 1. So between 1 and entries.length
    }

    // event sent when the random number is generated by the VRF
    event RandomNumberCreated(
        uint256 indexed idFromMetawin,
        uint256 randomNumber,
        uint256 normalizedRandomNumber
    );

    struct RaffleInfo {
        uint256 id; // raffleId
        uint256 size; // length of the entries array of that raffle
    }

    mapping(uint256 => RandomResult) public requests;
    // map the requestId created by chainlink with the raffle info passed as param when calling getRandomNumber()
    mapping(bytes32 => RaffleInfo) public chainlinkRaffleInfo;

    /////////////// END CHAINKINK VRF V1 //////////////

    error EntryNotAllowed(string errorType);
   
    // Event sent when the raffle is created by the operator
    event RaffleCreated(
        uint256 indexed raffleId,
        address indexed nftAddress,
        uint256 indexed nftId
    );
    // Event sent when the owner of the nft stakes it for the raffle
    event RaffleStarted(uint256 indexed raffleId, address indexed seller);
    // Event sent when the raffle is finished (either early cashout or successful completion)
    event RaffleEnded(
        uint256 indexed raffleId,
        address indexed winner,
        uint256 amountRaised,
        uint256 randomNumber
    );
    // Event sent when one or more entries are sold (info from the price structure)
    event EntrySold(
        uint256 indexed raffleId,
        address indexed buyer,
        uint256 currentSize,
        uint256 priceStructureId
    );
    // Event sent when a free entry is added by the operator
    event FreeEntry(
        uint256 indexed raffleId,
        address[] buyer,
        uint256 amount,
        uint256 currentSize
    );
    // Event sent when a raffle is asked to cancel by the operator
    event RaffleCancelled(uint256 indexed raffleId, uint256 amountRaised);
    // The raffle is closed successfully and the platform receives the fee
    event FeeTransferredToPlatform(
        uint256 indexed raffleId,
        uint256 amountTransferred
    );
    // When the raffle is asked to be cancelled and 30 days have passed, the operator can call a method
    // to transfer the remaining funds and this event is emitted
    event RemainingFundsTransferred(
        uint256 indexed raffleId,
        uint256 amountInWeis
    );
    // When the raffle is asked to be cancelled and 30 days have not passed yet, the players can call a
    // method to refund the amount spent on the raffle and this event is emitted
    event Refund(
        uint256 indexed raffleId,
        uint256 amountInWeis,
        address indexed player
    );
    event EarlyCashoutTriggered(uint256 indexed raffleId, uint256 amountRaised);
    event SetWinnerTriggered(uint256 indexed raffleId, uint256 amountRaised);
    event StatusChangedInEmergency(uint256 indexed raffleId, uint256 newStatus);
    // Emitted when an entry is cancelled
    event EntryCancelled(
        uint256 indexed raffleId,
        uint256 amountOfEntriesCanceled,
        address player
    );

    /* every raffle has an array of price structure (max size = 5) with the different 
    prices for the different entries bought. The price for 1 entry is different than 
    for 5 entries where there is a discount*/
    struct PriceStructure {
        uint256 id;
        uint48 numEntries;
        uint256 price;
    }
    mapping(uint256 => PriceStructure[5]) public prices;

    // Every raffle has a funding structure.
    struct FundingStructure {
        uint128 minimumFundsInWeis;
        uint128 desiredFundsInWeis;
    }
    mapping(uint256 => FundingStructure) public fundingList;

    // In order to calculate the winner, in this struct is saved for each bought the data
    struct EntriesBought {
        uint256 currentEntriesLength; // current amount of entries bought in the raffle
        address player; // wallet address of the player
    }
    // every raffle has a sorted array of EntriesBought. Each element is created when calling
    // either buyEntry or giveBatchEntriesForFree
    mapping(uint256 => EntriesBought[]) public entriesList;

    // Main raffle data struct
    struct RaffleStruct {
        uint48 platformPercentage; // percentage of the funds raised that goes to the platform
        uint48 cancellingDate;
        uint48 collateralId; // NFT id of the NFT
        address collateralAddress; // address of the NFT
        address winner; // address of thed winner of the raffle. Address(0) if no winner yet
        address seller; // address of the seller of the NFT
        uint256 randomNumber; // normalized (0-Entries array size) random number generated by the VRF
    }
    // The main structure is an array of raffles
    RaffleStruct[] public raffles;

    struct EntryInfoStruct {
        STATUS status; // status of the raffle. Can be created, accepted, ended, etc
        ENTRY_TYPE entryType;
        uint48 maxEntries; // maximum number of entries allowed per user, to avoid abuse
        uint48 entriesLength; // to easy frontend, the length of the entries array is saved here
        uint128 amountRaised; // funds raised so far in wei
        address[] collectionWhitelist; // addresses of the required nfts. Will be empty if no NFT is required to buy
    }
    // The main structure is an array of raffles
    EntryInfoStruct[] public rafflesEntryInfo;

    // Map that contains the number of entries each user has bought, to prevent abuse, and the claiming info
    struct ClaimStruct {
        uint128 numEntriesPerUser;
        uint128 amountSpentInWeis;
        bool claimed;
    }
    mapping(bytes32 => ClaimStruct) public claimsData;

    // Map with the addresses linked to a particular raffle + nft
    mapping(bytes32 => address) public requiredNFTWallets;

    // All the different status a rafVRFCoordinatorfle can have
    enum STATUS {
        CREATED, // the operator creates the raffle
        ACCEPTED, // the seller stakes the nft for the raffle
        EARLY_CASHOUT, // the seller wants to cashout early
        CANCELLED, // the operator cancels the raffle and transfer the remaining funds after 30 days passes
        CLOSING_REQUESTED, // the operator sets a winner
        ENDED, // the raffle is finished, and NFT and funds were transferred
        CANCEL_REQUESTED // operator asks to cancel the raffle. Players has 30 days to ask for a refund
    }

    enum ENTRY_TYPE {
        ONLY_DIRECTLY,
        ONLY_EXTERNAL_CONTRACT,
        MIXED
    }

    // The operator role is operated by a backend application
    bytes32 public constant OPERATOR_ROLE = keccak256("OPERATOR");
    // requested by Hamburger. Role for the buy method of the hamburger (only that contract)
    bytes32 public constant MINTERCONTRACT_ROLE = keccak256("MINTERCONTRACT");

    // address of the wallet controlled by the platform that will receive the platform fee
    address payable public destinationWallet =
        payable(0x52a032cF59eA274f9D745f29b6D514fe95Ba192D);

    constructor(
        address _vrfCoordinator,
        address _linkToken,
        bytes32 _keyHash,
        bool _mainetFee
    )
        VRFConsumerBase(
            _vrfCoordinator, // VRF Coordinator
            _linkToken // LINK Token
        )
    {
        _setupRole(OPERATOR_ROLE, 0x13503B622abC0bD30A7e9687057DF6E8c42Fb928);
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);

        keyHash = _keyHash;
        if (_mainetFee == true)
            fee = 2 * 10 ** 18; // in mainnet, the fee must be 2 LINK
        else fee = 0.1 * 10 ** 18; // 0.1 LINK In Rinkeby and Goerli
    }

    function callVRFAndGetRequestId() internal returns (bytes32 requestId) {
        require(
            LINK.balanceOf(address(this)) >= fee,
            "Not enough LINK - fill contract with faucet"
        );
        bytes32 result = requestRandomness(keyHash, fee);
        return result;
    }

    /// @dev this is the method that will be called by the smart contract to get a random number
    /// @param _id Id of the raffle
    /// @param _entriesSize length of the entries array of that raffle
    /// @param _requestId id generated by Chainlink
    function getRandomNumber(
        uint256 _id,
        uint256 _entriesSize,
        bytes32 _requestId
    ) internal {
        chainlinkRaffleInfo[_requestId] = RaffleInfo({
            id: _id,
            size: _entriesSize
        });
    }

    /// @dev Callback function used by VRF Coordinator. Is called by chainlink
    /// the random number generated is normalized to the size of the entries array, and an event is
    /// generated, that will be listened by the platform backend to be checked if corresponds to a
    /// member of the MW community, and if true will call transferNFTAndFunds
    /// @param requestId id generated previously (on method getRandomNumber by chainlink)
    /// @param randomness random number (huge) generated by chainlink
    function fulfillRandomness(
        bytes32 requestId,
        uint256 randomness
    ) internal override {
        // randomness is the actual random number. Now extract from the aux map the original param id of the call
        RaffleInfo memory raffleInfo = chainlinkRaffleInfo[requestId];
        // save the random number on the map with the original id as key
        uint256 normalizedRandomNumber = (randomness % raffleInfo.size) + 1;

        RandomResult memory result = RandomResult({
            randomNumber: randomness,
            nomalizedRandomNumber: normalizedRandomNumber
        });

        requests[raffleInfo.id] = result;

        // send the event with the original id and the random number
        emit RandomNumberCreated(
            raffleInfo.id,
            randomness,
            normalizedRandomNumber
        );

        transferNFTAndFunds(raffleInfo.id, normalizedRandomNumber);
    }

    //////////////////////////////////////////////

    /// @param _desiredFundsInWeis the amount the seller would like to get from the raffle
    /// @param _maxEntriesPerUser To avoid whales, the number of entries an user can have is limited
    /// @param _collateralAddress The address of the NFT of the raffle
    /// @param _collateralId The id of the NFT (ERC721)
    /// @param _minimumFundsInWeis The mininum amount required for the raffle to set a winner
    /// @param _prices Array of prices and amount of entries the customer could purchase
    //   /// @param _commissionInBasicPoints commission for the platform, in basic points
    /// @param _collectionWhitelist array with the required collections to participate in the raffle. Empty if there is no collection
    /// @notice Creates a raffle
    /// @dev creates a raffle struct and push it to the raffles array. Some data is stored in the funding data structure
    /// sends an event when finished
    /// @return raffleId
    function createRaffle(
        uint128 _desiredFundsInWeis,
        uint48 _maxEntriesPerUser,
        address _collateralAddress,
        uint48 _collateralId,
        uint128 _minimumFundsInWeis,
        PriceStructure[] calldata _prices,
        uint48 _commissionInBasicPoints,
        address[] calldata _collectionWhitelist,
        ENTRY_TYPE _entryType
    ) external onlyRole(OPERATOR_ROLE) returns (uint256) {
        require(_maxEntriesPerUser > 0, "maxEntries is 0");
        require(_collateralAddress != address(0), "NFT is null");
             require(_commissionInBasicPoints <= 5000, "commission too high");

        RaffleStruct memory raffle = RaffleStruct({
            collateralAddress: _collateralAddress,
            collateralId: _collateralId,
            winner: address(0),
            randomNumber: 0,
            seller: address(0),
            platformPercentage: _commissionInBasicPoints,
            cancellingDate: 0
        });

        raffles.push(raffle);

        saveEntryInfo(_maxEntriesPerUser, _entryType, _collectionWhitelist);

        // uint256 idRaffle = raffles.length - 1;
      //  savePrices(raffles.length - 1, _prices);

            require(_prices.length > 0, "No prices");

        for (uint256 i = 0; i < _prices.length; i++) {
            require(_prices[i].numEntries > 0, "numEntries is 0");

            PriceStructure memory p = PriceStructure({
                id: _prices[i].id,
                numEntries: _prices[i].numEntries,
                price: _prices[i].price
            });

            prices[raffles.length - 1][i] = p;
        }
        

        fundingList[raffles.length - 1] = FundingStructure({
            minimumFundsInWeis: _minimumFundsInWeis,
            desiredFundsInWeis: _desiredFundsInWeis
        });

        emit RaffleCreated(
            raffles.length - 1,
            _collateralAddress,
            _collateralId
        );

        return raffles.length - 1;
    }

    function saveEntryInfo(
        uint48 _maxEntriesPerUser,
        ENTRY_TYPE _entryType,
        address[] calldata _collectionWhitelist
    ) internal {
        EntryInfoStruct memory entryInfo = EntryInfoStruct({
            status: STATUS.CREATED,
            maxEntries: _maxEntriesPerUser,
            amountRaised: 0,
            entriesLength: 0,
            collectionWhitelist: _collectionWhitelist,
            entryType: _entryType
        });
        rafflesEntryInfo.push(entryInfo);
    }

 /*   function savePrices(
        uint256 _raffleId,
        PriceStructure[] memory _prices
    ) internal {
        uint256 pricesLength = _prices.length;
        require(pricesLength > 0, "No prices");

        for (uint256 i; i < pricesLength; ++i) {
            require(_prices[i].numEntries > 0, "numEntries is 0");

            PriceStructure memory p = PriceStructure({
                id: _prices[i].id,
                numEntries: _prices[i].numEntries,
                price: _prices[i].price
            });

            prices[_raffleId][i] = p;
        }
    }
*/
    /* * Example of a price structure:
1 ticket 0.02
5 tickets 0.018 (10% discount)
10 tickets 0.16  (20% discount)
25 tickets 0.35  (30% discount) 
50 tickets 0.6 (40% discount)
*/
    /// @param _idRaffle raffleId
    /// @param _id Id of the price structure
    /// @return the price structure of that particular Id + raffle
    /// @dev Returns the price structure, used in the frontend
    function getPriceStructForId(
        uint256 _idRaffle,
        uint256 _id
    ) internal view returns (PriceStructure memory) {
        for (uint256 i = 0; i < 5; i++) {
            if (prices[_idRaffle][i].id == _id) {
                return prices[_idRaffle][i];
            }
        }
        return PriceStructure({id: 0, numEntries: 0, price: 0});
    }

    /*
    Callable only by the owner of the NFT
    Once the operator has created the raffle, he can stake the NFT
    At this moment, the NFT is locked and the players can buy entries
    */
    /// @param _raffleId Id of the raffle
    /// @notice The owner of the NFT can stake it on the raffle. At this moment the raffle starts and can sell entries to players
    /// @dev the owner must have approved this contract before. Otherwise will revert when transferring from the owner
    function stakeNFT(uint256 _raffleId) external {
        RaffleStruct storage raffle = raffles[_raffleId];
        EntryInfoStruct storage entryInfo = rafflesEntryInfo[_raffleId];
        // Check if the raffle is already created
        require(entryInfo.status == STATUS.CREATED, "Raffle not CREATED");
        // the owner of the NFT must be the current caller
        IERC721 token = IERC721(raffle.collateralAddress);
        require(
            token.ownerOf(raffle.collateralId) == msg.sender,
            "NFT is not owned by caller"
        );

        entryInfo.status = STATUS.ACCEPTED;
        raffle.seller = msg.sender;

        // transfer the asset to the contract
        token.transferFrom(msg.sender, address(this), raffle.collateralId); // transfer the token to the contract

        emit RaffleStarted(_raffleId, msg.sender);
    }

    /// @dev callable by players. Depending on the number of entries assigned to the price structure the player buys (_id parameter)
    /// one or more entries will be assigned to the player.
    /// Also it is checked the maximum number of entries per user is not reached
    /// As the method is payable, in msg.value there will be the amount paid by the user
    /// @notice If the operator set requiredNFTs when creating the raffle, only the owners of nft on that collection can make a call to this method. This will be
    /// used for special raffles
    /// @param _raffleId: id of the raffle
    /// @param _id: id of the price structure
    /// @param _collection: collection of the tokenId used. Not used if there is no required nft on the raffle
    /// @param _tokenIdUsed: id of the token used in private raffles (to avoid abuse can not be reused on the same raffle)
    function buyEntry(
        uint256 _raffleId,
        uint256 _id,
        address _collection,
        uint256 _tokenIdUsed
    ) external payable nonReentrant {
        EntryInfoStruct storage entryInfo = rafflesEntryInfo[_raffleId];
        //require(raffle.seller != msg.sender, "Seller cannot buy");
        // version with custom errors
           if (entryInfo.entryType == ENTRY_TYPE.ONLY_EXTERNAL_CONTRACT)
                revert EntryNotAllowed("Entry type not allowed");
        // if the raffle requires an nft
        uint256 whitelistLength = entryInfo.collectionWhitelist.length;
        if (whitelistLength > 0) {
            bool hasRequiredCollection = false;
            for (uint256 i; i < whitelistLength; ++i) {
                if (entryInfo.collectionWhitelist[i] == _collection) {
                    hasRequiredCollection = true;
                    break;
                }
            }
            require(
                hasRequiredCollection == true,
                "Not in required collection"
            );
            IERC721 requiredNFT = IERC721(_collection);
            require(
                requiredNFT.ownerOf(_tokenIdUsed) == msg.sender,
                "Not the owner of tokenId"
            );
            bytes32 hashRequiredNFT = keccak256(
                abi.encode(_collection, _raffleId, _tokenIdUsed)
            );
            // check the tokenId has not been using yet in the raffle, to avoid abuse
            if (requiredNFTWallets[hashRequiredNFT] == address(0)) {
                requiredNFTWallets[hashRequiredNFT] = msg.sender;
            } else
                require(
                    requiredNFTWallets[hashRequiredNFT] == msg.sender,
                    "tokenId used"
                );
        }

        //     require(msg.sender != address(0), "msg.sender is null"); // 37
       // require(_id > 0, "howMany is 0");
       if (_id == 0) revert EntryNotAllowed("howMany is 0");
       /* require(
            entryInfo.status == STATUS.ACCEPTED,
            "Raffle is not in accepted"
        );*/
        if (entryInfo.status != STATUS.ACCEPTED) revert EntryNotAllowed("Not in accepted status");
        PriceStructure memory priceStruct = getPriceStructForId(_raffleId, _id);
        uint48 numEntries = priceStruct.numEntries;
        //require(numEntries > 0, "id not supported");
        if (numEntries == 0) revert EntryNotAllowed("Id not supported");
        if (msg.value != priceStruct.price) revert EntryNotAllowed("msg.value must be equal to the price");
        /*    require(
            msg.value == priceStruct.price,
            "msg.value must be equal to the price"
        ); // 1722
*/
        bytes32 hash = keccak256(abi.encode(msg.sender, _raffleId));
        // check there are enough entries left for this particular user
    /*    require(
            claimsData[hash].numEntriesPerUser + numEntries <=
                entryInfo.maxEntries,
            "Bought too many entries"
        );*/
        if (claimsData[hash].numEntriesPerUser + numEntries >
                entryInfo.maxEntries) revert EntryNotAllowed("Bought too many entries");

        uint48 entriesLength = entryInfo.entriesLength;
        EntriesBought memory entryBought = EntriesBought({
            player: msg.sender,
            currentEntriesLength: entriesLength + numEntries
        });
        entriesList[_raffleId].push(entryBought);

        uint128 weisPaid = uint128(msg.value);

        entryInfo.amountRaised += weisPaid;
        // update the field entriesLength, used in frontend to avoid making extra calls
        entryInfo.entriesLength = entriesLength + numEntries;
        //update claim data
        claimsData[hash].numEntriesPerUser += numEntries;
        claimsData[hash].amountSpentInWeis += weisPaid;

        emit EntrySold(_raffleId, msg.sender, entryInfo.entriesLength, _id); // 2377
    }

    // The operator can add free entries to the raffle
    /// @param _raffleId Id of the raffle
    /// @param _freePlayers array of addresses corresponding to the wallet of the users that won a free entrie
    /// @dev only operator can make this call. Assigns a single entry per user, except if that user already reached the max limit of entries per user
    function giveBatchEntriesForFree(
        uint256 _raffleId,
        address[] memory _freePlayers
    ) external nonReentrant onlyRole(OPERATOR_ROLE) {
        EntryInfoStruct storage entryInfo = rafflesEntryInfo[_raffleId];
        require(
            entryInfo.status == STATUS.ACCEPTED,
            "Raffle is not in accepted"
        );

        uint256 freePlayersLength = _freePlayers.length;
        uint48 validPlayersCount = 0;
        for (uint256 i = 0; i < freePlayersLength; i++) {
            address entry = _freePlayers[i];
            if (
                claimsData[keccak256(abi.encode(entry, _raffleId))]
                    .numEntriesPerUser +
                    1 <=
                entryInfo.maxEntries
            ) {
                // add a new element to the entriesBought array.
                // as this method only adds 1 entry per call, the amountbought is always 1
                EntriesBought memory entryBought = EntriesBought({
                    player: entry,
                    currentEntriesLength: entryInfo.entriesLength + i + 1
                });
                entriesList[_raffleId].push(entryBought);

                claimsData[keccak256(abi.encode(entry, _raffleId))]
                    .numEntriesPerUser++;

                ++validPlayersCount;
            }
        }

        entryInfo.entriesLength = entryInfo.entriesLength + validPlayersCount;

        emit FreeEntry(
            _raffleId,
            _freePlayers,
            freePlayersLength,
            entryInfo.entriesLength
        );
    }

    // helper method to get the winner address of a raffle
    /// @param _raffleId Id of the raffle
    /// @param _normalizedRandomNumber Generated by chainlink
    /// @return the wallet that won the raffle
    /// @dev Uses a binary search on the sorted array to retreive the winner
    /// but if the winner candidate is blacklisted, loop through the left looking for
    /// a candidate not blacklisted
    function getWinnerAddressFromRandom(
        uint256 _raffleId,
        uint256 _normalizedRandomNumber
    ) public view returns (address) {
        uint256 position = findUpperBound(
            entriesList[_raffleId],
            _normalizedRandomNumber
        );

        address candidate = entriesList[_raffleId][position].player;
        // general case
        if (candidate != address(0)) return candidate;
        // special case. The user is blacklisted, so try next on the left until find a non-blacklisted
        else {
            bool ended = false;
            uint256 i = position;
            while (
                ended == false && entriesList[_raffleId][i].player == address(0)
            ) {
                if (i == 0) i = entriesList[_raffleId].length - 1;
                else i = i - 1;
                // we came to the beginning without finding a non blacklisted player
                if (i == position) ended == true;
            }
            require(!ended, "All users blacklisted");
            return entriesList[_raffleId][i].player;
        }
    }

    /// @param array sorted array of EntriesBought. CurrentEntriesLength is the numeric field used to sort
    /// @param element uint256 to find. Goes from 1 to entriesLength
    /// @dev based on openzeppelin code (v4.0), modified to use an array of EntriesBought
    /// Searches a sorted array and returns the first index that contains a value greater or equal to element.
    /// If no such index exists (i.e. all values in the array are strictly less than element), the array length is returned. Time complexity O(log n).
    /// array is expected to be sorted in ascending order, and to contain no repeated elements.
    /// https://docs.openzeppelin.com/contracts/3.x/api/utils#Arrays-findUpperBound-uint256---uint256-
    function findUpperBound(
        EntriesBought[] storage array,
        uint256 element
    ) internal view returns (uint256) {
        if (array.length == 0) {
            return 0;
        }

        uint256 low = 0;
        uint256 high = array.length;

        while (low < high) {
            uint256 mid = Math.average(low, high);

            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)
            // because Math.average rounds down (it does integer division with truncation).
            if (array[mid].currentEntriesLength > element) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }

        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.
        if (low > 0 && array[low - 1].currentEntriesLength == element) {
            return low - 1;
        } else {
            return low;
        }
    }

    // The operator can call this method once they receive the event "RandomNumberCreated"
    // triggered by the VRF v1 consumer contract (RandomNumber.sol)
    /// @param _raffleId Id of the raffle
    /// @param _normalizedRandomNumber index of the array that contains the winner of the raffle. Generated by chainlink
    /// @notice it is the method that sets the winner and transfers funds and nft
    /// @dev called by Chainlink callback
    function transferNFTAndFunds(
        uint256 _raffleId,
        uint256 _normalizedRandomNumber
    ) internal nonReentrant {
        RaffleStruct storage raffle = raffles[_raffleId];
        EntryInfoStruct storage entryInfo = rafflesEntryInfo[_raffleId];
        // Only when the raffle has been asked to be closed and the platform
        require(
            entryInfo.status == STATUS.EARLY_CASHOUT ||
                entryInfo.status == STATUS.CLOSING_REQUESTED,
            "Raffle in wrong status"
        );

        raffle.randomNumber = _normalizedRandomNumber;
        raffle.winner = getWinnerAddressFromRandom(
            _raffleId,
            _normalizedRandomNumber
        );
        entryInfo.status = STATUS.ENDED;

        IERC721 _asset = IERC721(raffle.collateralAddress);
        _asset.transferFrom(address(this), raffle.winner, raffle.collateralId); // transfer the tokens to the contract

        uint256 amountForPlatform = (entryInfo.amountRaised *
            raffle.platformPercentage) / 10000;
        uint256 amountForSeller = entryInfo.amountRaised - amountForPlatform;
        // transfer amount (75%) to the seller.
        (bool sent, ) = raffle.seller.call{value: amountForSeller}("");
        require(sent, "Failed to send Ether");
        // transfer the amount to the platform
        (bool sent2, ) = destinationWallet.call{value: amountForPlatform}("");
        require(sent2, "Failed send Eth to MW");
        emit FeeTransferredToPlatform(_raffleId, amountForPlatform);

        emit RaffleEnded(
            _raffleId,
            raffle.winner,
            entryInfo.amountRaised,
            _normalizedRandomNumber
        );
    }

    function setCashOutActions(
        uint256 _raffleId
    ) internal returns (EntryInfoStruct memory) {
        RaffleStruct memory raffle = raffles[_raffleId];
        EntryInfoStruct storage entryInfo = rafflesEntryInfo[_raffleId];
        FundingStructure memory funding = fundingList[_raffleId];

        require(raffle.seller == msg.sender, "Not the seller");
        // Check if the raffle is already accepted
        require(
            entryInfo.status == STATUS.ACCEPTED,
            "Raffle not in accepted status"
        );
        require(
            entryInfo.amountRaised >= funding.minimumFundsInWeis,
            "Not enough funds raised"
        );

        entryInfo.status = STATUS.EARLY_CASHOUT;

        emit EarlyCashoutTriggered(_raffleId, entryInfo.amountRaised);

        return entryInfo;
    }

    // can be called by the seller at every moment once enough funds has been raised
    /// @param _raffleId Id of the raffle
    /// @notice the seller of the nft, if the minimum amount has been reached, can call an early cashout, finishing the raffle
    /// @dev it triggers Chainlink VRF1 consumer, and generates a random number that is normalized and checked that corresponds to a MW player
    function earlyCashOut(uint256 _raffleId) external {
        EntryInfoStruct memory raffle = setWinnerActions(_raffleId);
        bytes32 requestId = callVRFAndGetRequestId();
        getRandomNumber(_raffleId, raffle.entriesLength, requestId);
    }

    function setWinnerActions(
        uint256 _raffleId
    ) internal returns (EntryInfoStruct memory) {
        EntryInfoStruct storage entryInfo = rafflesEntryInfo[_raffleId];
        // RaffleStruct storage raffle = raffles[_raffleId];
        FundingStructure storage funding = fundingList[_raffleId];
        // Check if the raffle is already accepted or is called again because early cashout failed
        require(entryInfo.status == STATUS.ACCEPTED, "Raffle in wrong status");
        require(
            entryInfo.amountRaised >= funding.minimumFundsInWeis,
            "Not enough funds raised"
        );

        require(
            funding.desiredFundsInWeis <= entryInfo.amountRaised,
            "Desired funds not raised"
        );
        entryInfo.status = STATUS.CLOSING_REQUESTED;

        emit SetWinnerTriggered(_raffleId, entryInfo.amountRaised);
        return entryInfo;
    }

    /// @param _raffleId Id of the raffle
    /// @notice the operator finish the raffle, if the desired funds has been reached
    /// @dev it triggers Chainlink VRF1 consumer, and generates a random number that is normalized and checked that corresponds to a MW player
    function setWinner(
        uint256 _raffleId
    ) external nonReentrant onlyRole(OPERATOR_ROLE) {
        EntryInfoStruct memory raffle = setWinnerActions(_raffleId);
        // this call trigers the VRF v1 process from Chainlink

        bytes32 requestId = callVRFAndGetRequestId();
        getRandomNumber(_raffleId, raffle.entriesLength, requestId);
    }

    /// @param _newAddress new address of the platform
    /// @dev Change the wallet of the platform. The one that will receive the platform fee when the raffle is closed.
    /// Only the admin can change this
    function setDestinationAddress(
        address payable _newAddress
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        destinationWallet = _newAddress;
    }

    /// @param _raffleId Id of the raffle
    /// @dev The operator can cancel the raffle. The NFT is sent back to the seller
    /// The raised funds are send to the destination wallet. The buyers will
    /// be refunded offchain in the metawin wallet
    function cancelRaffle(
        uint256 _raffleId
    ) external nonReentrant onlyRole(OPERATOR_ROLE) {
        RaffleStruct storage raffle = raffles[_raffleId];
        EntryInfoStruct storage entryInfo = rafflesEntryInfo[_raffleId];
        // Dont cancel twice, or cancel an already ended raffle
        require(
            entryInfo.status != STATUS.ENDED &&
                entryInfo.status != STATUS.CANCELLED &&
                entryInfo.status != STATUS.EARLY_CASHOUT &&
                entryInfo.status != STATUS.CLOSING_REQUESTED &&
                entryInfo.status != STATUS.CANCEL_REQUESTED,
            "Wrong status"
        );

        // only if the raffle is in accepted status the NFT is staked and could have entries sold
        if (entryInfo.status == STATUS.ACCEPTED) {
            // transfer nft to the owner
            IERC721 _asset = IERC721(raffle.collateralAddress);
            _asset.transferFrom(
                address(this),
                raffle.seller,
                raffle.collateralId
            );
        }
        entryInfo.status = STATUS.CANCEL_REQUESTED;
        raffle.cancellingDate = uint48(block.timestamp);

        emit RaffleCancelled(_raffleId, entryInfo.amountRaised);
    }

    /// @param _raffleId Id of the raffle
    /// @dev The player can claim a refund during the first 30 days after the raffle was cancelled
    /// in the map "ClaimsData" it is saves how much the player spent on that raffle, as they could
    /// have bought several entries
    function claimRefund(uint256 _raffleId) external nonReentrant {
        RaffleStruct memory raffle = raffles[_raffleId];
        EntryInfoStruct storage entryInfo = rafflesEntryInfo[_raffleId];
        require(entryInfo.status == STATUS.CANCEL_REQUESTED, "wrong status");
        require(
            block.timestamp <= raffle.cancellingDate + 30 days,
            "claim time expired"
        );

        ClaimStruct storage claimData = claimsData[
            keccak256(abi.encode(msg.sender, _raffleId))
        ];

        require(claimData.claimed == false, "already refunded");

        entryInfo.amountRaised =
            entryInfo.amountRaised -
            claimData.amountSpentInWeis;

        claimData.claimed = true;
        (bool sent, ) = msg.sender.call{value: claimData.amountSpentInWeis}("");
        require(sent, "Fail send refund");

        emit Refund(_raffleId, claimData.amountSpentInWeis, msg.sender);
    }

    /// @param _raffleId Id of the raffle
    /// @dev after 30 days after cancelling passes, the operator can transfer to
    /// destinationWallet the remaining funds
    function transferRemainingFunds(
        uint256 _raffleId
    ) external nonReentrant onlyRole(OPERATOR_ROLE) {
        RaffleStruct memory raffle = raffles[_raffleId];
        EntryInfoStruct storage entryInfo = rafflesEntryInfo[_raffleId];
        require(entryInfo.status == STATUS.CANCEL_REQUESTED, "Wrong status");
        require(
            block.timestamp > raffle.cancellingDate + 30 days,
            "claim too soon"
        );

        entryInfo.status = STATUS.CANCELLED;

        (bool sent, ) = destinationWallet.call{value: entryInfo.amountRaised}(
            ""
        );
        require(sent, "Fail send Eth to MW");

        emit RemainingFundsTransferred(_raffleId, entryInfo.amountRaised);

        entryInfo.amountRaised = 0;
    }

    /// @param _raffleId Id of the raffle
    /// @return array of entries bougth of that particular raffle
    function getEntriesBought(
        uint256 _raffleId
    ) external view returns (EntriesBought[] memory) {
        return entriesList[_raffleId];
    }

    /// @param _raffleId Id of the raffle
    /// @param _player wallet of the player
    /// @return Claims data of the player on that raffle
    function getClaimData(
        uint256 _raffleId,
        address _player
    ) external view returns (ClaimStruct memory) {
        return claimsData[keccak256(abi.encode(_player, _raffleId))];
    }

    /// @dev for different reasons player entries should be void
    /// this has a cost in gas, but this makes cheaper in gas the callback from chainlink
    /// This method has to be called for every raffle of the blacklisted player
    /// @param _raffleId Id of the raffle
    /// @param entriesToCancel array that contains the index of the entries to cancel. 0 based
    /// @param _player player who owns the entry to be voided
    function cancelEntry(
        uint256 _raffleId,
        uint256[] calldata entriesToCancel,
        address _player
    ) external onlyRole(OPERATOR_ROLE) {
        uint256 totalEntriesBoughtCancelled = 0;
        for (uint256 i = 0; i < entriesToCancel.length; i++) {
            EntriesBought storage entry = entriesList[_raffleId][
                entriesToCancel[i]
            ];

            require(entry.player == _player, "Entry did not belong to player");

            entry.player = address(0);

            uint256 previousTotalEntriesLength;
            if (entriesToCancel[i] == 0) previousTotalEntriesLength = 0;
            else
                previousTotalEntriesLength = entriesList[_raffleId][
                    entriesToCancel[i] - 1
                ].currentEntriesLength;
            totalEntriesBoughtCancelled +=
                entry.currentEntriesLength -
                previousTotalEntriesLength;
        }
        emit EntryCancelled(_raffleId, totalEntriesBoughtCancelled, _player);
    }

    // Requested by Valerio Di Napoli.
    /// @param _raffleId id of the raffle
    /// @param _amountOfEntries amount of entries. Must be lower than maxEntriesPerUser
    /// @param _player The address of the player
    /// @notice Called by other contract created by Valerio, that minted an NFT and after that call this method
    /// @dev add entries but they are free so no payable
    function createFreeEntriesFromExternalContract(
        uint256 _raffleId,
        uint48 _amountOfEntries,
        address _player
    ) external onlyRole(MINTERCONTRACT_ROLE) nonReentrant {
        // if can buy run this code.
        bytes32 hash = keccak256(abi.encode(_player, _raffleId));

        //    RaffleStruct storage raffle = raffles[_raffleId];
        EntryInfoStruct storage entryInfo = rafflesEntryInfo[_raffleId];

        require(
            entryInfo.entryType == ENTRY_TYPE.ONLY_EXTERNAL_CONTRACT ||
                entryInfo.entryType == ENTRY_TYPE.MIXED,
            "Entry type not allowed"
        );

        EntriesBought memory entryBought = EntriesBought({
            player: _player,
            currentEntriesLength: entryInfo.entriesLength + _amountOfEntries
        });
        entriesList[_raffleId].push(entryBought);

        // update the field entriesLength.
        entryInfo.entriesLength += _amountOfEntries;
        //update claim data
        claimsData[hash].numEntriesPerUser += _amountOfEntries;

        address[] memory players = new address[](1);
        players[0] = _player;
        emit FreeEntry(
            _raffleId,
            players,
            _amountOfEntries,
            entryInfo.entriesLength
        );
    }

    function getRafflesEntryInfo(
        uint256 _raffleId
    ) public view returns (EntryInfoStruct memory) {
        return rafflesEntryInfo[_raffleId];
    }

    function playerIsBlacklisted(address _player) external view returns (bool) {
      //  return blackListManager.isBlackListed(_player);
      return false;
    }

    function raffleNotInAcceptedState(
        uint256 _raffleId
    ) external view returns (bool) {
        EntryInfoStruct memory entryInfo = rafflesEntryInfo[_raffleId];
        return (entryInfo.status != STATUS.ACCEPTED);
    }

    function playerIsSeller(
        address _player,
        uint256 _raffleId
    ) external view returns (bool) {
        RaffleStruct memory raffle = raffles[_raffleId];
        return (raffle.seller == _player);
    }

    function playerReachedMaxEntries(
        address _player,
        uint256 _raffleId,
        uint256 _amountOfEntries
    ) external view returns (bool) {
        EntryInfoStruct storage entryInfo = rafflesEntryInfo[_raffleId];

        bytes32 hash = keccak256(abi.encode(_player, _raffleId));
        // check there are enough entries left for this particular user
        return (claimsData[hash].numEntriesPerUser + _amountOfEntries >
            entryInfo.maxEntries);
    }

    /* Requested by Valerio Di Napoli.
    @param _player The address of the player    
    @param _raffleId id of the raffle
    @param _colection Address of the required collection, if any
    @param _tokenIdUsed Id of the token of the required collection the player says he has and want to use in the raffle
    @returns bool if the player can buy or not, and string with the cause of the rejection. "" if can buy
    @notice Method that returns if the user can or cannot buy entries because the player owns an nft in the case or required collections.
    */
    function playerHasRequiredNFTs(
        address _player,
        uint256 _raffleId,
        address _collection,
        uint256 _tokenIdUsed
    ) external view returns (bool canBuy, string memory cause) {
        //   RaffleStruct memory raffle = raffles[_raffleId];
        EntryInfoStruct memory entryInfo = rafflesEntryInfo[_raffleId];

        // if the raffle requires an nft
        if (entryInfo.collectionWhitelist.length > 0) {
            bool hasRequiredCollection = false;
            for (uint256 i = 0; i < entryInfo.collectionWhitelist.length; i++) {
                if (entryInfo.collectionWhitelist[i] == _collection) {
                    hasRequiredCollection = true;
                    break;
                }
            }
            if (hasRequiredCollection == false)
                return (false, "Not in required collection");

            IERC721 requiredNFT = IERC721(_collection);
            if (requiredNFT.ownerOf(_tokenIdUsed) != _player)
                return (false, "Not the owner of tokenId");
            bytes32 hashRequiredNFT = keccak256(
                abi.encode(_collection, _raffleId, _tokenIdUsed)
            );
            // check the tokenId has not been using yet in the raffle, to avoid abuse
            if (requiredNFTWallets[hashRequiredNFT] != _player)
                return (false, "tokenId used");
        }

        return (true, "");
    }
}