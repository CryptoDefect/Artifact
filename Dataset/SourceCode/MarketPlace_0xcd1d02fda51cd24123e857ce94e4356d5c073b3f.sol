{{

  "language": "Solidity",

  "sources": {

    "src/Marketplace.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.16;\n\nimport 'src/tokens/ERC5095.sol';\nimport 'src/lib/Safe.sol';\nimport 'src/lib/RevertMsgExtractor.sol';\nimport 'src/errors/Exception.sol';\n\nimport 'src/interfaces/ILender.sol';\nimport 'src/interfaces/ICreator.sol';\nimport 'src/interfaces/IPool.sol';\nimport 'src/interfaces/IPendleToken.sol';\nimport 'src/interfaces/IAPWineToken.sol';\nimport 'src/interfaces/IAPWineFutureVault.sol';\n\n/// @title MarketPlace\n/// @author Sourabh Marathe, Julian Traversa, Rob Robbins\n/// @notice This contract is in charge of managing the available principals for each loan market.\n/// @notice In addition, this contract routes swap orders between Illuminate PTs and their respective underlying to YieldSpace pools.\ncontract MarketPlace {\n    /// @notice the available principals\n    /// @dev the order of this enum is used to select principals from the markets\n    /// mapping (e.g. Illuminate => 0, Swivel => 1, and so on)\n    enum Principals {\n        Illuminate, // 0\n        Swivel, // 1\n        Yield, // 2\n        Element, // 3\n        Pendle, // 4\n        Tempus, // 5\n        Sense, // 6\n        Apwine, // 7\n        Notional // 8\n    }\n\n    /// @notice markets are defined by a tuple that points to a fixed length array of principal token addresses.\n    mapping(address => mapping(uint256 => address[9])) public markets;\n\n    /// @notice pools map markets to their respective YieldSpace pools for the MetaPrincipal token\n    mapping(address => mapping(uint256 => address)) public pools;\n\n    /// @notice address that is allowed to create markets, set pools, etc. It is commonly used in the authorized modifier.\n    address public admin;\n    /// @notice address of the deployed redeemer contract\n    address public immutable redeemer;\n    /// @notice address of the deployed lender contract\n    address public immutable lender;\n    /// @notice address of the deployed creator contract\n    address public immutable creator;\n\n    /// @notice emitted upon the creation of a new market\n    event CreateMarket(\n        address indexed underlying,\n        uint256 indexed maturity,\n        address[9] tokens,\n        address element,\n        address apwine\n    );\n    /// @notice emitted upon setting a principal token\n    event SetPrincipal(\n        address indexed underlying,\n        uint256 indexed maturity,\n        address indexed principal,\n        uint8 protocol\n    );\n    /// @notice emitted upon swapping with the pool\n    event Swap(\n        address indexed underlying,\n        uint256 indexed maturity,\n        address sold,\n        address bought,\n        uint256 received,\n        uint256 spent,\n        address spender\n    );\n    /// @notice emitted upon minting tokens with the pool\n    event Mint(\n        address indexed underlying,\n        uint256 indexed maturity,\n        uint256 underlyingIn,\n        uint256 principalTokensIn,\n        uint256 minted,\n        address minter\n    );\n    /// @notice emitted upon burning tokens with the pool\n    event Burn(\n        address indexed underlying,\n        uint256 indexed maturity,\n        uint256 tokensBurned,\n        uint256 underlyingReceived,\n        uint256 principalTokensReceived,\n        address burner\n    );\n    /// @notice emitted upon changing the admin\n    event SetAdmin(address indexed admin);\n    /// @notice emitted upon setting a pool\n    event SetPool(\n        address indexed underlying,\n        uint256 indexed maturity,\n        address indexed pool\n    );\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Exception(0, 0, 0, msg.sender, a);\n        }\n        _;\n    }\n\n    /// @notice initializes the MarketPlace contract\n    /// @param r address of the deployed redeemer contract\n    /// @param l address of the deployed lender contract\n    /// @param c address of the deployed creator contract\n    constructor(address r, address l, address c) {\n        admin = msg.sender;\n        redeemer = r;\n        lender = l;\n        creator = c;\n    }\n\n    /// @notice creates a new market for the given underlying token and maturity\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param t principal token addresses for this market\n    /// @param n name for the Illuminate token\n    /// @param s symbol for the Illuminate token\n    /// @param a address of the APWine router that corresponds to this market\n    /// @param e address of the Element vault that corresponds to this market\n    /// @param h address of a helper contract, used for Sense approvals if active in the market\n    /// @param sensePeriphery address of the Sense periphery contract that must be approved by the lender\n    /// @return bool true if successful\n    function createMarket(\n        address u,\n        uint256 m,\n        address[8] calldata t,\n        string calldata n,\n        string calldata s,\n        address a,\n        address e,\n        address h,\n        address sensePeriphery\n    ) external authorized(admin) returns (bool) {\n        {\n            // Get the Illuminate principal token for this market (if one exists)\n            address illuminate = markets[u][m][0];\n\n            // If illuminate PT already exists, a new market cannot be created\n            if (illuminate != address(0)) {\n                revert Exception(9, 0, 0, illuminate, address(0));\n            }\n        }\n\n        // Create an Illuminate principal token for the new market\n        address illuminateToken = ICreator(creator).create(\n            u,\n            m,\n            redeemer,\n            lender,\n            address(this),\n            n,\n            s\n        );\n\n        {\n            // create the principal tokens array\n            address[9] memory market = [\n                illuminateToken, // Illuminate\n                t[0], // Swivel\n                t[1], // Yield\n                t[2], // Element\n                t[3], // Pendle\n                t[4], // Tempus\n                t[5], // Sense\n                t[6], // APWine\n                t[7] // Notional\n            ];\n\n            // Set the market\n            markets[u][m] = market;\n\n            // Have the lender contract approve the several contracts\n            ILender(lender).approve(u, a, e, t[7], sensePeriphery);\n\n            // Allow converter to spend interest bearing asset\n            if (t[5] != address(0)) {\n                IRedeemer(redeemer).approve(h);\n            }\n\n            // Approve interest bearing token conversion to underlying for APWine\n            if (t[6] != address(0)) {\n                address futureVault = IAPWineToken(t[6]).futureVault();\n                address interestBearingToken = IAPWineFutureVault(futureVault)\n                    .getIBTAddress();\n                IRedeemer(redeemer).approve(interestBearingToken);\n            }\n\n            emit CreateMarket(u, m, market, e, a);\n        }\n        return true;\n    }\n\n    /// @notice allows the admin to set an individual market\n    /// @param p principal value according to the MarketPlace's Principals Enum\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a address of the new principal token\n    /// @param h a supplementary address (apwine needs a router, element needs a vault, sense needs interest bearing asset)\n    /// @param sensePeriphery address of the Sense periphery contract that must be approved by the lender\n    /// @return bool true if the principal set, false otherwise\n    function setPrincipal(\n        uint8 p,\n        address u,\n        uint256 m,\n        address a,\n        address h,\n        address sensePeriphery\n    ) external authorized(admin) returns (bool) {\n        // Set the principal token in the markets mapping\n        markets[u][m][p] = a;\n\n        if (p == uint8(Principals.Element)) {\n            // Approve Element vault if setting Element's principal token\n            ILender(lender).approve(u, address(0), h, address(0), address(0));\n        } else if (p == uint8(Principals.Sense)) {\n            // Approve converter to transfer yield token for Sense's redeem\n            IRedeemer(redeemer).approve(h);\n\n            // Approve Periphery to be used from Lender\n            ILender(lender).approve(\n                u,\n                address(0),\n                address(0),\n                address(0),\n                sensePeriphery\n            );\n        } else if (p == uint8(Principals.Apwine)) {\n            // Approve converter to transfer yield token for APWine's redeem\n            address futureVault = IAPWineToken(a).futureVault();\n            address interestBearingToken = IAPWineFutureVault(futureVault)\n                .getIBTAddress();\n            IRedeemer(redeemer).approve(interestBearingToken);\n\n            // Approve APWine's router if setting APWine's principal token\n            ILender(lender).approve(u, h, address(0), address(0), address(0));\n        } else if (p == uint8(Principals.Notional)) {\n            // Principal token must be approved for Notional's lend\n            ILender(lender).approve(u, address(0), address(0), a, address(0));\n        }\n\n        emit SetPrincipal(u, m, a, p);\n        return true;\n    }\n\n    /// @notice sets the admin address\n    /// @param a Address of a new admin\n    /// @return bool true if the admin set, false otherwise\n    function setAdmin(address a) external authorized(admin) returns (bool) {\n        admin = a;\n        emit SetAdmin(a);\n        return true;\n    }\n\n    /// @notice sets the address for a pool\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a address of the pool\n    /// @return bool true if the pool set, false otherwise\n    function setPool(\n        address u,\n        uint256 m,\n        address a\n    ) external authorized(admin) returns (bool) {\n        // Set the pool\n        pools[u][m] = a;\n\n        // Get the principal token\n        ERC5095 pt = ERC5095(markets[u][m][uint8(Principals.Illuminate)]);\n\n        // Set the pool for the principal token\n        pt.setPool(a);\n\n        // Approve the marketplace to spend the principal and underlying tokens\n        pt.approveMarketPlace();\n\n        emit SetPool(u, m, a);\n        return true;\n    }\n\n    /// @notice sells the PT for the underlying via the pool\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of PTs to sell\n    /// @param s slippage cap, minimum amount of underlying that must be received\n    /// @return uint128 amount of underlying bought\n    function sellPrincipalToken(\n        address u,\n        uint256 m,\n        uint128 a,\n        uint128 s\n    ) external returns (uint128) {\n        // Get the pool for the market\n        IPool pool = IPool(pools[u][m]);\n\n        // Preview amount of underlying received by selling `a` PTs\n        uint256 expected = pool.sellFYTokenPreview(a);\n\n        // Verify that the amount needed does not exceed the slippage parameter\n        if (expected < s) {\n            revert Exception(16, expected, s, address(0), address(0));\n        }\n\n        // Transfer the principal tokens to the pool\n        Safe.transferFrom(\n            IERC20(address(pool.fyToken())),\n            msg.sender,\n            address(pool),\n            a\n        );\n\n        // Execute the swap\n        uint128 received = pool.sellFYToken(msg.sender, s);\n        emit Swap(u, m, address(pool.fyToken()), u, received, a, msg.sender);\n\n        return received;\n    }\n\n    /// @notice buys the PT for the underlying via the pool\n    /// @notice determines how many underlying to sell by using the preview\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of PTs to be purchased\n    /// @param s slippage cap, maximum number of underlying that can be sold\n    /// @return uint128 amount of underlying sold\n    function buyPrincipalToken(\n        address u,\n        uint256 m,\n        uint128 a,\n        uint128 s\n    ) external returns (uint128) {\n        // Get the pool for the market\n        IPool pool = IPool(pools[u][m]);\n\n        // Get the amount of base hypothetically required to purchase `a` PTs\n        uint128 expected = pool.buyFYTokenPreview(a);\n\n        // Verify that the amount needed does not exceed the slippage parameter\n        if (expected > s) {\n            revert Exception(16, expected, 0, address(0), address(0));\n        }\n\n        // Transfer the underlying tokens to the pool\n        Safe.transferFrom(\n            IERC20(pool.base()),\n            msg.sender,\n            address(pool),\n            expected\n        );\n\n        // Execute the swap to purchase `a` base tokens\n        uint128 spent = pool.buyFYToken(msg.sender, a, s);\n\n        emit Swap(u, m, u, address(pool.fyToken()), a, spent, msg.sender);\n        return spent;\n    }\n\n    /// @notice sells the underlying for the PT via the pool\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying to sell\n    /// @param s slippage cap, minimum number of PTs that must be received\n    /// @return uint128 amount of PT purchased\n    function sellUnderlying(\n        address u,\n        uint256 m,\n        uint128 a,\n        uint128 s\n    ) external returns (uint128) {\n        // Get the pool for the market\n        IPool pool = IPool(pools[u][m]);\n\n        // Get the number of PTs received for selling `a` underlying tokens\n        uint128 expected = pool.sellBasePreview(a);\n\n        // Verify slippage does not exceed the one set by the user\n        if (expected < s) {\n            revert Exception(16, expected, 0, address(0), address(0));\n        }\n\n        // Transfer the underlying tokens to the pool\n        Safe.transferFrom(IERC20(pool.base()), msg.sender, address(pool), a);\n\n        // Execute the swap\n        uint128 received = pool.sellBase(msg.sender, s);\n\n        emit Swap(u, m, u, address(pool.fyToken()), received, a, msg.sender);\n        return received;\n    }\n\n    /// @notice buys the underlying for the PT via the pool\n    /// @notice determines how many PTs to sell by using the preview\n    /// @param u address of an underlying asset\n    /// @param m maturity (timestamp) of the market\n    /// @param a amount of underlying to be purchased\n    /// @param s slippage cap, maximum number of PTs that can be sold\n    /// @return uint128 amount of PTs sold\n    function buyUnderlying(\n        address u,\n        uint256 m,\n        uint128 a,\n        uint128 s\n    ) external returns (uint128) {\n        // Get the pool for the market\n        IPool pool = IPool(pools[u][m]);\n\n        // Get the amount of PTs hypothetically required to purchase `a` underlying\n        uint256 expected = pool.buyBasePreview(a);\n\n        // Verify that the amount needed does not exceed the slippage parameter\n        if (expected > s) {\n            revert Exception(16, expected, 0, address(0), address(0));\n        }\n\n        // Transfer the principal tokens to the pool\n        Safe.transferFrom(\n            IERC20(address(pool.fyToken())),\n            msg.sender,\n            address(pool),\n            expected\n        );\n\n        // Execute the swap to purchase `a` underlying tokens\n        uint128 spent = pool.buyBase(msg.sender, a, s);\n\n        emit Swap(u, m, address(pool.fyToken()), u, a, spent, msg.sender);\n        return spent;\n    }\n\n    /// @notice mint liquidity tokens in exchange for adding underlying and PT\n    /// @dev amount of liquidity tokens to mint is calculated from the amount of unaccounted for PT in this contract.\n    /// @dev A proportional amount of underlying tokens need to be present in this contract, also unaccounted for.\n    /// @param u the address of the underlying token\n    /// @param m the maturity of the principal token\n    /// @param b number of base tokens\n    /// @param p the principal token amount being sent\n    /// @param minRatio minimum ratio of LP tokens to PT in the pool.\n    /// @param maxRatio maximum ratio of LP tokens to PT in the pool.\n    /// @return uint256 number of base tokens passed to the method\n    /// @return uint256 number of yield tokens passed to the method\n    /// @return uint256 the amount of tokens minted.\n    function mint(\n        address u,\n        uint256 m,\n        uint256 b,\n        uint256 p,\n        uint256 minRatio,\n        uint256 maxRatio\n    ) external returns (uint256, uint256, uint256) {\n        // Get the pool for the market\n        IPool pool = IPool(pools[u][m]);\n\n        // Transfer the underlying tokens to the pool\n        Safe.transferFrom(IERC20(pool.base()), msg.sender, address(pool), b);\n\n        // Transfer the principal tokens to the pool\n        Safe.transferFrom(\n            IERC20(address(pool.fyToken())),\n            msg.sender,\n            address(pool),\n            p\n        );\n\n        // Mint the tokens and return the leftover assets to the caller\n        (uint256 underlyingIn, uint256 principalTokensIn, uint256 minted) = pool\n            .mint(msg.sender, msg.sender, minRatio, maxRatio);\n\n        emit Mint(u, m, underlyingIn, principalTokensIn, minted, msg.sender);\n        return (underlyingIn, principalTokensIn, minted);\n    }\n\n    /// @notice Mint liquidity tokens in exchange for adding only underlying\n    /// @dev amount of liquidity tokens is calculated from the amount of PT to buy from the pool,\n    /// plus the amount of unaccounted for PT in this contract.\n    /// @param u the address of the underlying token\n    /// @param m the maturity of the principal token\n    /// @param a the underlying amount being sent\n    /// @param p amount of `PT` being bought in the Pool, from this we calculate how much underlying it will be taken in.\n    /// @param minRatio minimum ratio of LP tokens to PT in the pool.\n    /// @param maxRatio maximum ratio of LP tokens to PT in the pool.\n    /// @return uint256 number of base tokens passed to the method\n    /// @return uint256 number of yield tokens passed to the method\n    /// @return uint256 the amount of tokens minted.\n    function mintWithUnderlying(\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 p,\n        uint256 minRatio,\n        uint256 maxRatio\n    ) external returns (uint256, uint256, uint256) {\n        // Get the pool for the market\n        IPool pool = IPool(pools[u][m]);\n\n        // Transfer the underlying tokens to the pool\n        Safe.transferFrom(IERC20(pool.base()), msg.sender, address(pool), a);\n\n        // Mint the tokens to the user\n        (uint256 underlyingIn, , uint256 minted) = pool.mintWithBase(\n            msg.sender,\n            msg.sender,\n            p,\n            minRatio,\n            maxRatio\n        );\n\n        emit Mint(u, m, underlyingIn, 0, minted, msg.sender);\n        return (underlyingIn, 0, minted);\n    }\n\n    /// @notice burn liquidity tokens in exchange for underlying and PT.\n    /// @param u the address of the underlying token\n    /// @param m the maturity of the principal token\n    /// @param a the amount of liquidity tokens to burn\n    /// @param minRatio minimum ratio of LP tokens to PT in the pool\n    /// @param maxRatio maximum ratio of LP tokens to PT in the pool\n    /// @return uint256 amount of LP tokens burned\n    /// @return uint256 amount of base tokens received\n    /// @return uint256 amount of fyTokens received\n    function burn(\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 minRatio,\n        uint256 maxRatio\n    ) external returns (uint256, uint256, uint256) {\n        // Get the pool for the market\n        IPool pool = IPool(pools[u][m]);\n\n        // Transfer the underlying tokens to the pool\n        Safe.transferFrom(IERC20(address(pool)), msg.sender, address(pool), a);\n\n        // Burn the tokens\n        (\n            uint256 tokensBurned,\n            uint256 underlyingReceived,\n            uint256 principalTokensReceived\n        ) = pool.burn(msg.sender, msg.sender, minRatio, maxRatio);\n\n        emit Burn(\n            u,\n            m,\n            tokensBurned,\n            underlyingReceived,\n            principalTokensReceived,\n            msg.sender\n        );\n        return (tokensBurned, underlyingReceived, principalTokensReceived);\n    }\n\n    /// @notice burn liquidity tokens in exchange for underlying.\n    /// @param u the address of the underlying token\n    /// @param m the maturity of the principal token\n    /// @param a the amount of liquidity tokens to burn\n    /// @param minRatio minimum ratio of LP tokens to PT in the pool.\n    /// @param maxRatio minimum ratio of LP tokens to PT in the pool.\n    /// @return uint256 amount of PT tokens sent to the pool\n    /// @return uint256 amount of underlying tokens returned\n    function burnForUnderlying(\n        address u,\n        uint256 m,\n        uint256 a,\n        uint256 minRatio,\n        uint256 maxRatio\n    ) external returns (uint256, uint256) {\n        // Get the pool for the market\n        IPool pool = IPool(pools[u][m]);\n\n        // Transfer the underlying tokens to the pool\n        Safe.transferFrom(IERC20(address(pool)), msg.sender, address(pool), a);\n\n        // Burn the tokens in exchange for underlying tokens\n        (uint256 tokensBurned, uint256 underlyingReceived) = pool.burnForBase(\n            msg.sender,\n            minRatio,\n            maxRatio\n        );\n\n        emit Burn(u, m, tokensBurned, underlyingReceived, 0, msg.sender);\n        return (tokensBurned, underlyingReceived);\n    }\n\n    /// @notice Allows batched call to self (this contract).\n    /// @param c An array of inputs for each call.\n    function batch(\n        bytes[] calldata c\n    ) external payable returns (bytes[] memory results) {\n        results = new bytes[](c.length);\n        for (uint256 i; i < c.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(\n                c[i]\n            );\n            if (!success) revert(RevertMsgExtractor.getRevertMsg(result));\n            results[i] = result;\n        }\n    }\n}\n"

    },

    "src/errors/Exception.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.16;\n\n/// @dev A single custom error capable of indicating a wide range of detected errors by providing\n/// an error code value whose string representation is documented in errors.txt, and any possible other values\n/// that are pertinent to the error.\nerror Exception(uint8, uint256, uint256, address, address);\n"

    },

    "src/interfaces/IAPWineFutureVault.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.16;\n\ninterface IAPWineFutureVault {\n    function PERIOD_DURATION() external view returns (uint256);\n\n    function getControllerAddress() external view returns (address);\n\n    function getCurrentPeriodIndex() external view returns (uint256);\n\n    function getFYTofPeriod(uint256) external view returns (address);\n\n    function getIBTAddress() external view returns (address);\n\n    function startNewPeriod() external;\n}\n"

    },

    "src/interfaces/IAPWineToken.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.16;\n\ninterface IAPWineToken {\n    function futureVault() external view returns (address);\n}\n"

    },

    "src/interfaces/ICreator.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.16;\n\ninterface ICreator {\n    function create(\n        address,\n        uint256,\n        address,\n        address,\n        address,\n        string calldata,\n        string calldata\n    ) external returns (address);\n}\n"

    },

    "src/interfaces/IERC20.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.16;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Returns the number of decimals the token uses - e.g. 8, means to\n     * divide the token amount by 100000000 to get its user representation.\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"

    },

    "src/interfaces/IERC20Metadata.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.16;\n\nimport 'src/interfaces/IERC20.sol';\n\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"

    },

    "src/interfaces/IERC2612.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.16;\n\nimport 'src/interfaces/IERC20Metadata.sol';\n\n/**\n * @dev Interface of the ERC2612 standard as defined in the EIP.\n *\n * Adds the {permit} method, which can be used to change one's\n * {IERC20-allowance} without having to send a transaction, by signing a\n * message. This allows users to spend tokens without having to hold Ether.\n *\n * See https://eips.ethereum.org/EIPS/eip-2612.\n */\ninterface IERC2612 is IERC20Metadata {\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\n     * given `owner`'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n}\n"

    },

    "src/interfaces/IERC5095.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.16;\n\nimport 'src/interfaces/IERC2612.sol';\n\ninterface IERC5095 is IERC2612 {\n    function maturity() external view returns (uint256);\n\n    function underlying() external view returns (address);\n\n    function convertToUnderlying(uint256) external view returns (uint256);\n\n    function convertToShares(uint256) external view returns (uint256);\n\n    function maxRedeem(address) external view returns (uint256);\n\n    function previewRedeem(uint256) external view returns (uint256);\n\n    function maxWithdraw(address) external view returns (uint256);\n\n    function previewWithdraw(uint256) external view returns (uint256);\n\n    function previewDeposit(uint256) external view returns (uint256);\n\n    function withdraw(\n        uint256,\n        address,\n        address\n    ) external returns (uint256);\n\n    function redeem(\n        uint256,\n        address,\n        address\n    ) external returns (uint256);\n\n    function deposit(uint256, address) external returns (uint256);\n\n    function mint(uint256, address) external returns (uint256);\n\n    function authMint(address, uint256) external returns (bool);\n\n    function authBurn(address, uint256) external returns (bool);\n\n    function authApprove(\n        address,\n        address,\n        uint256\n    ) external returns (bool);\n}\n"

    },

    "src/interfaces/ILender.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.16;\n\ninterface ILender {\n    function approve(\n        address,\n        address,\n        address,\n        address,\n        address\n    ) external;\n\n    function transferFYTs(address, uint256) external;\n\n    function transferPremium(address, uint256) external;\n\n    function paused(uint8) external returns (bool);\n\n    function halted() external returns (bool);\n}\n"

    },

    "src/interfaces/IMarketPlace.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.16;\n\ninterface IMarketPlace {\n    function markets(\n        address,\n        uint256,\n        uint256\n    ) external returns (address);\n\n    function pools(address, uint256) external view returns (address);\n\n    function sellPrincipalToken(\n        address,\n        uint256,\n        uint128,\n        uint128\n    ) external returns (uint128);\n\n    function buyPrincipalToken(\n        address,\n        uint256,\n        uint128,\n        uint128\n    ) external returns (uint128);\n\n    function sellUnderlying(\n        address,\n        uint256,\n        uint128,\n        uint128\n    ) external returns (uint128);\n\n    function buyUnderlying(\n        address,\n        uint256,\n        uint128,\n        uint128\n    ) external returns (uint128);\n\n    function redeemer() external view returns (address);\n}\n"

    },

    "src/interfaces/IPendleToken.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.16;\n\ninterface IPendleToken {\n    function SY() external view returns (address);\n\n    function YT() external view returns (address);\n\n    function expiry() external view returns (uint256);\n}\n"

    },

    "src/interfaces/IPool.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport 'src/interfaces/IERC20.sol';\nimport 'src/interfaces/IERC5095.sol';\n\ninterface IPool {\n    function ts() external view returns (int128);\n\n    function g1() external view returns (int128);\n\n    function g2() external view returns (int128);\n\n    function maturity() external view returns (uint32);\n\n    function scaleFactor() external view returns (uint96);\n\n    function getCache()\n        external\n        view\n        returns (\n            uint112,\n            uint112,\n            uint32\n        );\n\n    // NOTE This will be deprecated\n    function base() external view returns (IERC20);\n\n    function baseToken() external view returns (address);\n\n    function fyToken() external view returns (IERC5095);\n\n    function getBaseBalance() external view returns (uint112);\n\n    function getFYTokenBalance() external view returns (uint112);\n\n    function retrieveBase(address) external returns (uint128 retrieved);\n\n    function retrieveFYToken(address) external returns (uint128 retrieved);\n\n    function sellBase(address, uint128) external returns (uint128);\n\n    function buyBase(\n        address,\n        uint128,\n        uint128\n    ) external returns (uint128);\n\n    function sellFYToken(address, uint128) external returns (uint128);\n\n    function buyFYToken(\n        address,\n        uint128,\n        uint128\n    ) external returns (uint128);\n\n    function sellBasePreview(uint128) external view returns (uint128);\n\n    function buyBasePreview(uint128) external view returns (uint128);\n\n    function sellFYTokenPreview(uint128) external view returns (uint128);\n\n    function buyFYTokenPreview(uint128) external view returns (uint128);\n\n    function mint(\n        address,\n        address,\n        uint256,\n        uint256\n    )\n        external\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function mintWithBase(\n        address,\n        address,\n        uint256,\n        uint256,\n        uint256\n    )\n        external\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function burn(\n        address,\n        address,\n        uint256,\n        uint256\n    )\n        external\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function burnForBase(\n        address,\n        uint256,\n        uint256\n    ) external returns (uint256, uint256);\n\n    function cumulativeBalancesRatio() external view returns (uint256);\n\n    function sync() external;\n}\n"

    },

    "src/interfaces/IRedeemer.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\ninterface IRedeemer {\n    function authRedeem(\n        address underlying,\n        uint256 maturity,\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (uint256);\n\n    function approve(address p) external;\n\n    function holdings(address u, uint256 m) external view returns (uint256);\n}\n"

    },

    "src/interfaces/IYield.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.16;\n\nimport 'src/interfaces/IERC20.sol';\n\ninterface IYield {\n    function maturity() external view returns (uint32);\n\n    function base() external view returns (IERC20);\n\n    function sellBase(address, uint128) external returns (uint128);\n\n    function sellBasePreview(uint128) external view returns (uint128);\n\n    function fyToken() external returns (address);\n\n    function sellFYToken(address, uint128) external returns (uint128);\n\n    function sellFYTokenPreview(uint128) external view returns (uint128);\n\n    function buyBase(\n        address,\n        uint128,\n        uint128\n    ) external returns (uint128);\n\n    function buyBasePreview(uint128) external view returns (uint128);\n\n    function buyFYToken(\n        address,\n        uint128,\n        uint128\n    ) external returns (uint128);\n\n    function buyFYTokenPreview(uint128) external view returns (uint128);\n}\n"

    },

    "src/lib/Cast.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.13;\n\nlibrary Cast {\n    /// @dev Safely cast an uint256 to an uint128\n    /// @param n the u256 to cast to u128\n    function u128(uint256 n) internal pure returns (uint128) {\n        if (n > type(uint128).max) {\n            revert();\n        }\n        return uint128(n);\n    }\n}\n"

    },

    "src/lib/RevertMsgExtractor.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// Taken from https://github.com/sushiswap/BoringSolidity/blob/441e51c0544cf2451e6116fe00515e71d7c42e2c/contracts/BoringBatchable.sol\n\npragma solidity >=0.6.0;\n\nlibrary RevertMsgExtractor {\n    /// @dev Helper function to extract a useful revert message from a failed call.\n    /// If the returned data is malformed or not correctly abi encoded then this call can fail itself.\n    function getRevertMsg(bytes memory returnData)\n        internal\n        pure\n        returns (string memory)\n    {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (returnData.length < 68) return 'Transaction reverted silently';\n\n        assembly {\n            // Slice the sighash.\n            returnData := add(returnData, 0x04)\n        }\n        return abi.decode(returnData, (string)); // All that remains is the revert string\n    }\n}\n"

    },

    "src/lib/Safe.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\n// Adapted from: https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol\n\npragma solidity ^0.8.13;\n\nimport 'src/interfaces/IERC20.sol';\n\n/**\n  @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n  @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\n  @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n*/\n\nlibrary Safe {\n    /// @param e Erc20 token to execute the call with\n    /// @param t To address\n    /// @param a Amount being transferred\n    function transfer(\n        IERC20 e,\n        address t,\n        uint256 a\n    ) internal {\n        bool result;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let pointer := mload(0x40)\n\n            // Write the abi-encoded calldata to memory piece by piece:\n            mstore(\n                pointer,\n                0xa9059cbb00000000000000000000000000000000000000000000000000000000\n            ) // Begin with the function selector.\n            mstore(\n                add(pointer, 4),\n                and(t, 0xffffffffffffffffffffffffffffffffffffffff)\n            ) // Mask and append the \"to\" argument.\n            mstore(add(pointer, 36), a) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\n\n            // Call the token and store if it succeeded or not.\n            // We use 68 because the calldata length is 4 + 32 * 2.\n            result := call(gas(), e, 0, pointer, 68, 0, 0)\n        }\n\n        require(success(result), 'transfer failed');\n    }\n\n    /// @param e Erc20 token to execute the call with\n    /// @param f From address\n    /// @param t To address\n    /// @param a Amount being transferred\n    function transferFrom(\n        IERC20 e,\n        address f,\n        address t,\n        uint256 a\n    ) internal {\n        bool result;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let pointer := mload(0x40)\n\n            // Write the abi-encoded calldata to memory piece by piece:\n            mstore(\n                pointer,\n                0x23b872dd00000000000000000000000000000000000000000000000000000000\n            ) // Begin with the function selector.\n            mstore(\n                add(pointer, 4),\n                and(f, 0xffffffffffffffffffffffffffffffffffffffff)\n            ) // Mask and append the \"from\" argument.\n            mstore(\n                add(pointer, 36),\n                and(t, 0xffffffffffffffffffffffffffffffffffffffff)\n            ) // Mask and append the \"to\" argument.\n            mstore(add(pointer, 68), a) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\n\n            // Call the token and store if it succeeded or not.\n            // We use 100 because the calldata length is 4 + 32 * 3.\n            result := call(gas(), e, 0, pointer, 100, 0, 0)\n        }\n\n        require(success(result), 'transfer from failed');\n    }\n\n    /// @notice normalize the acceptable values of true or null vs the unacceptable value of false (or something malformed)\n    /// @param r Return value from the assembly `call()` to Erc20['selector']\n    function success(bool r) private pure returns (bool) {\n        bool result;\n\n        assembly {\n            // Get how many bytes the call returned.\n            let returnDataSize := returndatasize()\n\n            // If the call reverted:\n            if iszero(r) {\n                // Copy the revert message into memory.\n                returndatacopy(0, 0, returnDataSize)\n\n                // Revert with the same message.\n                revert(0, returnDataSize)\n            }\n\n            switch returnDataSize\n            case 32 {\n                // Copy the return data into memory.\n                returndatacopy(0, 0, returnDataSize)\n\n                // Set success to whether it returned true.\n                result := iszero(iszero(mload(0)))\n            }\n            case 0 {\n                // There was no return data.\n                result := 1\n            }\n            default {\n                // It returned some malformed input.\n                result := 0\n            }\n        }\n\n        return result;\n    }\n\n    function approve(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool callStatus;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata to memory piece by piece:\n            mstore(\n                freeMemoryPointer,\n                0x095ea7b300000000000000000000000000000000000000000000000000000000\n            ) // Begin with the function selector.\n            mstore(\n                add(freeMemoryPointer, 4),\n                and(to, 0xffffffffffffffffffffffffffffffffffffffff)\n            ) // Mask and append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\n\n            // Call the token and store if it succeeded or not.\n            // We use 68 because the calldata length is 4 + 32 * 2.\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\n        }\n\n        require(didLastOptionalReturnCallSucceed(callStatus), 'APPROVE_FAILED');\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                         INTERNAL HELPER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function didLastOptionalReturnCallSucceed(bool callStatus)\n        private\n        pure\n        returns (bool)\n    {\n        bool result;\n        assembly {\n            // Get how many bytes the call returned.\n            let returnDataSize := returndatasize()\n\n            // If the call reverted:\n            if iszero(callStatus) {\n                // Copy the revert message into memory.\n                returndatacopy(0, 0, returnDataSize)\n\n                // Revert with the same message.\n                revert(0, returnDataSize)\n            }\n\n            switch returnDataSize\n            case 32 {\n                // Copy the return data into memory.\n                returndatacopy(0, 0, returnDataSize)\n\n                // Set success to whether it returned true.\n                result := iszero(iszero(mload(0)))\n            }\n            case 0 {\n                // There was no return data.\n                result := 1\n            }\n            default {\n                // It returned some malformed input.\n                result := 0\n            }\n        }\n\n        return result;\n    }\n}\n"

    },

    "src/tokens/ERC20.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// Inspired on token.sol from DappHub. Natspec adpated from OpenZeppelin.\npragma solidity 0.8.16;\n\nimport 'src/interfaces/IERC20Metadata.sol';\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Calls to {transferFrom} do not check for allowance if the caller is the owner\n * of the funds. This allows to reduce the number of approvals that are necessary.\n *\n * Finally, {transferFrom} does not decrease the allowance if it is set to\n * type(uint256).max. This reduces the gas costs without any likely impact.\n */\ncontract ERC20 is IERC20Metadata {\n    uint256 internal _totalSupply;\n    mapping(address => uint256) internal _balanceOf;\n    mapping(address => mapping(address => uint256)) internal _allowance;\n    string public override name = '???';\n    string public override symbol = '???';\n    uint8 public override decimals = 18;\n\n    /**\n     *  @dev Sets the values for {name}, {symbol} and {decimals}.\n     */\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) {\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() external view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address guy)\n        external\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balanceOf[guy];\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowance[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     */\n    function approve(address spender, uint256 wad)\n        external\n        virtual\n        override\n        returns (bool)\n    {\n        return _setAllowance(msg.sender, spender, wad);\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - the caller must have a balance of at least `wad`.\n     */\n    function transfer(address dst, uint256 wad)\n        external\n        virtual\n        override\n        returns (bool)\n    {\n        return _transfer(msg.sender, dst, wad);\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `src` must have a balance of at least `wad`.\n     * - the caller is not `src`, it must have allowance for ``src``'s tokens of at least\n     * `wad`.\n     */\n    /// if_succeeds {:msg \"TransferFrom - decrease allowance\"} msg.sender != src ==> old(_allowance[src][msg.sender]) >= wad;\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) external virtual override returns (bool) {\n        _decreaseAllowance(src, wad);\n\n        return _transfer(src, dst, wad);\n    }\n\n    /**\n     * @dev Moves tokens `wad` from `src` to `dst`.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `src` must have a balance of at least `amount`.\n     */\n    /// if_succeeds {:msg \"Transfer - src decrease\"} old(_balanceOf[src]) >= _balanceOf[src];\n    /// if_succeeds {:msg \"Transfer - dst increase\"} _balanceOf[dst] >= old(_balanceOf[dst]);\n    /// if_succeeds {:msg \"Transfer - supply\"} old(_balanceOf[src]) + old(_balanceOf[dst]) == _balanceOf[src] + _balanceOf[dst];\n    function _transfer(\n        address src,\n        address dst,\n        uint256 wad\n    ) internal virtual returns (bool) {\n        require(_balanceOf[src] >= wad, 'ERC20: Insufficient balance');\n        unchecked {\n            _balanceOf[src] = _balanceOf[src] - wad;\n        }\n        _balanceOf[dst] = _balanceOf[dst] + wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n\n    /**\n     * @dev Sets the allowance granted to `spender` by `owner`.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     */\n    function _setAllowance(\n        address owner,\n        address spender,\n        uint256 wad\n    ) internal virtual returns (bool) {\n        _allowance[owner][spender] = wad;\n        emit Approval(owner, spender, wad);\n\n        return true;\n    }\n\n    /**\n     * @dev Decreases the allowance granted to the caller by `src`, unless src == msg.sender or _allowance[src][msg.sender] == MAX\n     *\n     * Emits an {Approval} event indicating the updated allowance, if the allowance is updated.\n     *\n     * Requirements:\n     *\n     * - `spender` must have allowance for the caller of at least\n     * `wad`, unless src == msg.sender\n     */\n    /// if_succeeds {:msg \"Decrease allowance - underflow\"} old(_allowance[src][msg.sender]) <= _allowance[src][msg.sender];\n    function _decreaseAllowance(address src, uint256 wad)\n        internal\n        virtual\n        returns (bool)\n    {\n        if (src != msg.sender) {\n            uint256 allowed = _allowance[src][msg.sender];\n            if (allowed != type(uint256).max) {\n                require(allowed >= wad, 'ERC20: Insufficient approval');\n                unchecked {\n                    _setAllowance(src, msg.sender, allowed - wad);\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /** @dev Creates `wad` tokens and assigns them to `dst`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     */\n    /// if_succeeds {:msg \"Mint - balance overflow\"} old(_balanceOf[dst]) >= _balanceOf[dst];\n    /// if_succeeds {:msg \"Mint - supply overflow\"} old(_totalSupply) >= _totalSupply;\n    function _mint(address dst, uint256 wad) internal virtual returns (bool) {\n        _balanceOf[dst] = _balanceOf[dst] + wad;\n        _totalSupply = _totalSupply + wad;\n        emit Transfer(address(0), dst, wad);\n\n        return true;\n    }\n\n    /**\n     * @dev Destroys `wad` tokens from `src`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `src` must have at least `wad` tokens.\n     */\n    /// if_succeeds {:msg \"Burn - balance underflow\"} old(_balanceOf[src]) <= _balanceOf[src];\n    /// if_succeeds {:msg \"Burn - supply underflow\"} old(_totalSupply) <= _totalSupply;\n    function _burn(address src, uint256 wad) internal virtual returns (bool) {\n        unchecked {\n            require(_balanceOf[src] >= wad, 'ERC20: Insufficient balance');\n            _balanceOf[src] = _balanceOf[src] - wad;\n            _totalSupply = _totalSupply - wad;\n            emit Transfer(src, address(0), wad);\n        }\n\n        return true;\n    }\n}\n"

    },

    "src/tokens/ERC20Permit.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// Adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/53516bc555a454862470e7860a9b5254db4d00f5/contracts/token/ERC20/ERC20Permit.sol\npragma solidity 0.8.16;\n\nimport 'src/tokens/ERC20.sol';\nimport 'src/interfaces/IERC2612.sol';\n\n/**\n * @dev Extension of {ERC20} that allows token holders to use their tokens\n * without sending any transactions by setting {IERC20-allowance} with a\n * signature using the {permit} method, and then spend them via\n * {IERC20-transferFrom}.\n *\n * The {permit} signature mechanism conforms to the {IERC2612} interface.\n */\nabstract contract ERC20Permit is ERC20, IERC2612 {\n    mapping(address => uint256) public override nonces;\n\n    bytes32 public immutable PERMIT_TYPEHASH =\n        keccak256(\n            'Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)'\n        );\n    bytes32 private immutable _DOMAIN_SEPARATOR;\n    uint256 public immutable deploymentChainId;\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) ERC20(name_, symbol_, decimals_) {\n        deploymentChainId = block.chainid;\n        _DOMAIN_SEPARATOR = _calculateDomainSeparator(block.chainid);\n    }\n\n    /// @dev Calculate the DOMAIN_SEPARATOR.\n    function _calculateDomainSeparator(uint256 chainId)\n        private\n        view\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        'EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'\n                    ),\n                    keccak256(bytes(name)),\n                    keccak256(bytes(version())),\n                    chainId,\n                    address(this)\n                )\n            );\n    }\n\n    /// @dev Return the DOMAIN_SEPARATOR.\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return\n            block.chainid == deploymentChainId\n                ? _DOMAIN_SEPARATOR\n                : _calculateDomainSeparator(block.chainid);\n    }\n\n    /// @dev Setting the version as a function so that it can be overriden\n    function version() public pure virtual returns (string memory) {\n        return '1';\n    }\n\n    /**\n     * @dev See {IERC2612-permit}.\n     *\n     * In cases where the free option is not a concern, deadline can simply be\n     * set to uint(-1), so it should be seen as an optional parameter\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external virtual override {\n        require(deadline >= block.timestamp, 'ERC20Permit: expired deadline');\n\n        bytes32 hashStruct = keccak256(\n            abi.encode(\n                PERMIT_TYPEHASH,\n                owner,\n                spender,\n                amount,\n                nonces[owner]++,\n                deadline\n            )\n        );\n\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                '\\x19\\x01',\n                block.chainid == deploymentChainId\n                    ? _DOMAIN_SEPARATOR\n                    : _calculateDomainSeparator(block.chainid),\n                hashStruct\n            )\n        );\n\n        address signer = ecrecover(hash, v, r, s);\n        require(\n            signer != address(0) && signer == owner,\n            'ERC20Permit: invalid signature'\n        );\n\n        _setAllowance(owner, spender, amount);\n    }\n}\n"

    },

    "src/tokens/ERC5095.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport 'src/tokens/ERC20Permit.sol';\nimport 'src/interfaces/IERC5095.sol';\nimport 'src/interfaces/IRedeemer.sol';\nimport 'src/interfaces/IMarketPlace.sol';\nimport 'src/interfaces/IYield.sol';\nimport 'src/errors/Exception.sol';\n\nimport 'src/lib/Cast.sol';\nimport 'src/lib/Safe.sol';\n\ncontract ERC5095 is ERC20Permit, IERC5095 {\n    /// @dev unix timestamp when the ERC5095 token can be redeemed\n    uint256 public immutable override maturity;\n    /// @dev address of the ERC20 token that is returned on ERC5095 redemption\n    address public immutable override underlying;\n    /// @dev address of the minting authority\n    address public immutable lender;\n    /// @dev address of the \"marketplace\" YieldSpace AMM router\n    address public immutable marketplace;\n    ///@dev Interface to interact with the pool\n    address public pool;\n\n    /// @dev address and interface for an external custody contract (necessary for some project's backwards compatability)\n    address public immutable redeemer;\n\n    /// @notice ensures that only a certain address can call the function\n    /// @param a address that msg.sender must be to be authorized\n    modifier authorized(address a) {\n        if (msg.sender != a) {\n            revert Exception(0, 0, 0, msg.sender, a);\n        }\n        _;\n    }\n\n    constructor(\n        address _underlying,\n        uint256 _maturity,\n        address _redeemer,\n        address _lender,\n        address _marketplace,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) ERC20Permit(name_, symbol_, decimals_) {\n        underlying = _underlying;\n        maturity = _maturity;\n        redeemer = _redeemer;\n        lender = _lender;\n        marketplace = _marketplace;\n        pool = address(0);\n    }\n\n    /// @notice Allows the marketplace to set the pool\n    /// @param p Address of the pool\n    /// @return bool True if successful\n    function setPool(address p)\n        external\n        authorized(marketplace)\n        returns (bool)\n    {\n        pool = p;\n        return true;\n    }\n\n    /// @notice Allows the marketplace to spend underlying, principal tokens held by the token\n    /// @dev This is necessary when MarketPlace calls pool methods to swap tokens\n    /// @return True if successful\n    function approveMarketPlace()\n        external\n        authorized(marketplace)\n        returns (bool)\n    {\n        // Approve the marketplace to spend the token's underlying\n        Safe.approve(IERC20(underlying), marketplace, type(uint256).max);\n\n        // Approve the marketplace to spend illuminate PTs\n        Safe.approve(IERC20(address(this)), marketplace, type(uint256).max);\n\n        return true;\n    }\n\n    /// @notice Post or at maturity, converts an amount of principal tokens to an amount of underlying that would be returned.\n    /// @param s The amount of principal tokens to convert\n    /// @return uint256 The amount of underlying tokens returned by the conversion\n    function convertToUnderlying(uint256 s)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (block.timestamp < maturity) {\n            return previewRedeem(s);\n        }\n        return s;\n    }\n\n    /// @notice Post or at maturity, converts a desired amount of underlying tokens returned to principal tokens needed.\n    /// @param a The amount of underlying tokens to convert\n    /// @return uint256 The amount of principal tokens returned by the conversion\n    function convertToShares(uint256 a)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        if (block.timestamp < maturity) {\n            return previewWithdraw(a);\n        }\n        return a;\n    }\n\n    /// @notice Returns user's PT balance\n    /// @param o The address of the owner for which redemption is calculated\n    /// @return uint256 The maximum amount of principal tokens that `owner` can redeem.\n    function maxRedeem(address o) external view override returns (uint256) {\n        return _balanceOf[o];\n    }\n\n    /// @notice Post or at maturity, returns user's PT balance. Prior to maturity, returns a previewRedeem for owner's PT balance.\n    /// @param  o The address of the owner for which withdrawal is calculated\n    /// @return uint256 maximum amount of underlying tokens that `owner` can withdraw.\n    function maxWithdraw(address o) external view override returns (uint256) {\n        if (block.timestamp < maturity) {\n            return previewRedeem(_balanceOf[o]);\n        }\n        return _balanceOf[o];\n    }\n\n    /// @notice After maturity, returns 0. Prior to maturity, returns the amount of `shares` when spending `a` in underlying on a YieldSpace AMM.\n    /// @param a The amount of underlying spent\n    /// @return uint256 The amount of PT purchased by spending `a` of underlying\n    function previewDeposit(uint256 a) public view returns (uint256) {\n        if (block.timestamp < maturity) {\n            return IYield(pool).sellBasePreview(Cast.u128(a));\n        }\n        return 0;\n    }\n\n    /// @notice After maturity, returns 0. Prior to maturity, returns the amount of `assets` in underlying spent on a purchase of `s` in PT on a YieldSpace AMM.\n    /// @param s The amount of principal tokens bought in the simulation\n    /// @return uint256 The amount of underlying required to purchase `s` of PT\n    function previewMint(uint256 s) public view returns (uint256) {\n        if (block.timestamp < maturity) {\n            return IYield(pool).buyFYTokenPreview(Cast.u128(s));\n        }\n        return 0;\n    }\n\n    /// @notice Post or at maturity, simulates the effects of redemption. Prior to maturity, returns the amount of `assets` from a sale of `s` PTs on a YieldSpace AMM.\n    /// @param s The amount of principal tokens redeemed in the simulation\n    /// @return uint256 The amount of underlying returned by `s` of PT redemption\n    function previewRedeem(uint256 s) public view override returns (uint256) {\n        if (block.timestamp >= maturity) {\n            // After maturity, the amount redeemed is based on the Redeemer contract's holdings of the underlying\n            return\n                Cast.u128(\n                    s *\n                        Cast.u128(\n                            IRedeemer(redeemer).holdings(underlying, maturity)\n                        )\n                ) / _totalSupply;\n        }\n\n        // Prior to maturity, return a a preview of a swap on the pool\n        return IYield(pool).sellFYTokenPreview(Cast.u128(s));\n    }\n\n    /// @notice Post or at maturity, simulates the effects of withdrawal at the current block. Prior to maturity, simulates the amount of PTs necessary to receive `a` in underlying from the sale of PTs on a YieldSpace AMM.\n    /// @param a The amount of underlying tokens withdrawn in the simulation\n    /// @return uint256 The amount of principal tokens required for the withdrawal of `a`\n    function previewWithdraw(uint256 a) public view override returns (uint256) {\n        if (block.timestamp >= maturity) {\n            // After maturity, the amount redeemed is based on the Redeemer contract's holdings of the underlying\n            return\n                (a * _totalSupply) /\n                IRedeemer(redeemer).holdings(underlying, maturity);\n        }\n\n        // Prior to maturity, return a a preview of a swap on the pool\n        return IYield(pool).buyBasePreview(Cast.u128(a));\n    }\n\n    /// @notice Before maturity spends `a` of underlying, and sends PTs to `r`. Post or at maturity, reverts.\n    /// @param a The amount of underlying tokens deposited\n    /// @param r The receiver of the principal tokens\n    /// @param m Minimum number of shares that the user will receive\n    /// @return uint256 The amount of principal tokens purchased\n    function deposit(\n        uint256 a,\n        address r,\n        uint256 m\n    ) external returns (uint256) {\n        // Execute the deposit\n        return _deposit(r, a, m);\n    }\n\n    /// @notice Before maturity spends `assets` of underlying, and sends `shares` of PTs to `receiver`. Post or at maturity, reverts.\n    /// @param a The amount of underlying tokens deposited\n    /// @param r The receiver of the principal tokens\n    /// @return uint256 The amount of principal tokens burnt by the withdrawal\n    function deposit(uint256 a, address r) external override returns (uint256) {\n        // Execute the deposit\n        return _deposit(r, a, 0);\n    }\n\n    /// @notice Before maturity mints `s` of PTs to `r` by spending underlying. Post or at maturity, reverts.\n    /// @param s The amount of shares being minted\n    /// @param r The receiver of the underlying tokens being withdrawn\n    /// @param m Maximum amount of underlying that the user will spend\n    /// @return uint256 The amount of principal tokens purchased\n    function mint(\n        uint256 s,\n        address r,\n        uint256 m\n    ) external returns (uint256) {\n        // Execute the mint\n        return _mint(r, s, m);\n    }\n\n    /// @notice Before maturity mints `shares` of PTs to `receiver` by spending underlying. Post or at maturity, reverts.\n    /// @param s The amount of shares being minted\n    /// @param r The receiver of the underlying tokens being withdrawn\n    /// @return uint256 The amount of principal tokens purchased\n    function mint(uint256 s, address r) external override returns (uint256) {\n        // Execute the mint\n        return _mint(r, s, type(uint128).max);\n    }\n\n    /// @notice At or after maturity, burns PTs from owner and sends `a` underlying to `r`. Before maturity, sends `a` by selling shares of PT on a YieldSpace AMM.\n    /// @param a The amount of underlying tokens withdrawn\n    /// @param r The receiver of the underlying tokens being withdrawn\n    /// @param o The owner of the underlying tokens\n    /// @param m Maximum amount of PTs to be sold\n    /// @return uint256 The amount of principal tokens burnt by the withdrawal\n    function withdraw(\n        uint256 a,\n        address r,\n        address o,\n        uint256 m\n    ) external returns (uint256) {\n        // Execute the withdrawal\n        return _withdraw(a, r, o, m);\n    }\n\n    /// @notice At or after maturity, burns PTs from owner and sends `a` underlying to `r`. Before maturity, sends `a` by selling shares of PT on a YieldSpace AMM.\n    /// @param a The amount of underlying tokens withdrawn\n    /// @param r The receiver of the underlying tokens being withdrawn\n    /// @param o The owner of the underlying tokens\n    /// @return uint256 The amount of principal tokens burnt by the withdrawal\n    function withdraw(\n        uint256 a,\n        address r,\n        address o\n    ) external override returns (uint256) {\n        // Execute the withdrawal\n        return _withdraw(a, r, o, type(uint128).max);\n    }\n\n    /// @notice At or after maturity, burns exactly `s` of Principal Tokens from `o` and sends underlying tokens to `r`. Before maturity, sends underlying by selling `s` of PT on a YieldSpace AMM.\n    /// @param s The number of shares to be burned in exchange for the underlying asset\n    /// @param r The receiver of the underlying tokens being withdrawn\n    /// @param o Address of the owner of the shares being burned\n    /// @param m Minimum amount of underlying that must be received\n    /// @return uint256 The amount of underlying tokens distributed by the redemption\n    function redeem(\n        uint256 s,\n        address r,\n        address o,\n        uint256 m\n    ) external returns (uint256) {\n        // Execute the redemption\n        return _redeem(s, r, o, m);\n    }\n\n    /// @notice At or after maturity, burns exactly `shares` of Principal Tokens from `owner` and sends `assets` of underlying tokens to `receiver`. Before maturity, sells `s` of PT on a YieldSpace AMM.\n    /// @param s The number of shares to be burned in exchange for the underlying asset\n    /// @param r The receiver of the underlying tokens being withdrawn\n    /// @param o Address of the owner of the shares being burned\n    /// @return uint256 The amount of underlying tokens distributed by the redemption\n    function redeem(\n        uint256 s,\n        address r,\n        address o\n    ) external override returns (uint256) {\n        // Execute the redemption\n        return _redeem(s, r, o, 0);\n    }\n\n    /// @param f Address to burn from\n    /// @param a Amount to burn\n    /// @return bool true if successful\n    function authBurn(address f, uint256 a)\n        external\n        authorized(redeemer)\n        returns (bool)\n    {\n        _burn(f, a);\n        return true;\n    }\n\n    /// @param t Address recieving the minted amount\n    /// @param a The amount to mint\n    /// @return bool True if successful\n    function authMint(address t, uint256 a)\n        external\n        authorized(lender)\n        returns (bool)\n    {\n        _mint(t, a);\n        return true;\n    }\n\n    /// @param o Address of the owner of the tokens\n    /// @param s Address of the spender\n    /// @param a Amount to be approved\n    function authApprove(\n        address o,\n        address s,\n        uint256 a\n    ) external authorized(redeemer) returns (bool) {\n        _allowance[o][s] = a;\n        return true;\n    }\n\n    function _deposit(\n        address r,\n        uint256 a,\n        uint256 m\n    ) internal returns (uint256) {\n        // Revert if called at or after maturity\n        if (block.timestamp >= maturity) {\n            revert Exception(\n                21,\n                block.timestamp,\n                maturity,\n                address(0),\n                address(0)\n            );\n        }\n\n        // Receive the funds from the sender\n        Safe.transferFrom(IERC20(underlying), msg.sender, address(this), a);\n\n        // Sell the underlying assets for PTs\n        uint128 returned = IMarketPlace(marketplace).sellUnderlying(\n            underlying,\n            maturity,\n            Cast.u128(a),\n            Cast.u128(m)\n        );\n\n        // Pass the received shares onto the intended receiver\n        _transfer(address(this), r, returned);\n\n        return returned;\n    }\n\n    function _mint(\n        address r,\n        uint256 s,\n        uint256 m\n    ) internal returns (uint256) {\n        // Revert if called at or after maturity\n        if (block.timestamp >= maturity) {\n            revert Exception(\n                21,\n                block.timestamp,\n                maturity,\n                address(0),\n                address(0)\n            );\n        }\n\n        // Determine how many underlying tokens are needed to mint the shares\n        uint256 required = IYield(pool).buyFYTokenPreview(Cast.u128(s));\n\n        // Transfer the underlying to the token\n        Safe.transferFrom(\n            IERC20(underlying),\n            msg.sender,\n            address(this),\n            required\n        );\n\n        // Swap the underlying for principal tokens via the pool\n        uint128 sold = IMarketPlace(marketplace).buyPrincipalToken(\n            underlying,\n            maturity,\n            Cast.u128(s),\n            Cast.u128(m)\n        );\n\n        // Transfer the principal tokens to the desired receiver\n        _transfer(address(this), r, s);\n\n        return sold;\n    }\n\n    function _withdraw(\n        uint256 a,\n        address r,\n        address o,\n        uint256 m\n    ) internal returns (uint256) {\n        // Determine how many principal tokens are needed to purchase the underlying\n        uint256 needed = previewWithdraw(a);\n\n        // Pre maturity\n        if (block.timestamp < maturity) {\n            // Receive the shares from the caller\n            _transfer(o, address(this), needed);\n\n            // If owner is the sender, sell PT without allowance check\n            if (o == msg.sender) {\n                uint128 returned = IMarketPlace(marketplace).buyUnderlying(\n                    underlying,\n                    maturity,\n                    Cast.u128(a),\n                    Cast.u128(m)\n                );\n\n                // Transfer the underlying to the desired receiver\n                Safe.transfer(IERC20(underlying), r, a);\n\n                return returned;\n            } else {\n                // Else, sell PT with allowance check\n                // Get the allowance of the user spending the tokens\n                uint256 allowance = _allowance[o][msg.sender];\n\n                // Check for sufficient allowance\n                if (allowance < needed) {\n                    revert Exception(20, allowance, a, address(0), address(0));\n                }\n\n                // Update the caller's allowance\n                _allowance[o][msg.sender] = allowance - needed;\n\n                // Sell the principal tokens for underlying\n                uint128 returned = IMarketPlace(marketplace).buyUnderlying(\n                    underlying,\n                    maturity,\n                    Cast.u128(a),\n                    Cast.u128(m)\n                );\n\n                // Transfer the underlying to the desired receiver\n                Safe.transfer(IERC20(underlying), r, returned);\n\n                return returned;\n            }\n        }\n        // Post maturity\n        else {\n            // If owner is the sender, redeem PT without allowance check\n            if (o == msg.sender) {\n                // Execute the redemption to the desired receiver\n                return\n                    IRedeemer(redeemer).authRedeem(\n                        underlying,\n                        maturity,\n                        msg.sender,\n                        r,\n                        needed\n                    );\n            } else {\n                // Get the allowance of the user spending the tokens\n                uint256 allowance = _allowance[o][msg.sender];\n\n                // Check for sufficient allowance\n                if (allowance < needed) {\n                    revert Exception(\n                        20,\n                        allowance,\n                        needed,\n                        address(0),\n                        address(0)\n                    );\n                }\n\n                // Update the callers's allowance\n                _allowance[o][msg.sender] = allowance - needed;\n\n                // Execute the redemption to the desired receiver\n                return\n                    IRedeemer(redeemer).authRedeem(\n                        underlying,\n                        maturity,\n                        o,\n                        r,\n                        needed\n                    );\n            }\n        }\n    }\n\n    function _redeem(\n        uint256 s,\n        address r,\n        address o,\n        uint256 m\n    ) internal returns (uint256) {\n        // Pre-maturity\n        if (block.timestamp < maturity) {\n            // Receive the funds from the user\n            _transfer(o, address(this), s);\n\n            // If owner is the sender, sell PT without allowance check\n            if (o == msg.sender) {\n                // Swap principal tokens for the underlying asset\n                uint128 returned = IMarketPlace(marketplace).sellPrincipalToken(\n                    underlying,\n                    maturity,\n                    Cast.u128(s),\n                    Cast.u128(m)\n                );\n\n                // Transfer underlying to the desired receiver\n                Safe.transfer(IERC20(underlying), r, returned);\n                return returned;\n                // Else, sell PT with allowance check\n            } else {\n                // Get the allowance of the user spending the tokens\n                uint256 allowance = _allowance[o][msg.sender];\n\n                // Check for sufficient allowance\n                if (allowance < s) {\n                    revert Exception(20, allowance, s, address(0), address(0));\n                }\n\n                // Update the caller's allowance\n                _allowance[o][msg.sender] = allowance - s;\n\n                // Sell the principal tokens for the underlying\n                uint128 returned = IMarketPlace(marketplace).sellPrincipalToken(\n                    underlying,\n                    maturity,\n                    Cast.u128(s),\n                    Cast.u128(m)\n                );\n\n                // Transfer the underlying to the desired receiver\n                Safe.transfer(IERC20(underlying), r, returned);\n                return returned;\n            }\n            // Post-maturity\n        } else {\n            // If owner is the sender, redeem PT without allowance check\n            if (o == msg.sender) {\n                // Execute the redemption to the desired receiver\n                return\n                    IRedeemer(redeemer).authRedeem(\n                        underlying,\n                        maturity,\n                        msg.sender,\n                        r,\n                        s\n                    );\n            } else {\n                // Get the allowance of the user spending the tokens\n                uint256 allowance = _allowance[o][msg.sender];\n\n                // Check for sufficient allowance\n                if (allowance < s) {\n                    revert Exception(20, allowance, s, address(0), address(0));\n                }\n\n                // Update the caller's allowance\n                _allowance[o][msg.sender] = allowance - s;\n\n                // Execute the redemption to the desired receiver\n                return\n                    IRedeemer(redeemer).authRedeem(\n                        underlying,\n                        maturity,\n                        o,\n                        r,\n                        s\n                    );\n            }\n        }\n    }\n}\n"

    }

  },

  "settings": {

    "remappings": [

      "ds-test/=lib/forge-std/lib/ds-test/src/",

      "forge-std/=lib/forge-std/src/"

    ],

    "optimizer": {

      "enabled": true,

      "runs": 200

    },

    "metadata": {

      "bytecodeHash": "ipfs"

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "evmVersion": "london",

    "viaIR": true,

    "libraries": {}

  }

}}