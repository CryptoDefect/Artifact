// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/common/ERC2981.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

interface RefCode {
    function getCodeIdx(string memory group, string memory code) external view returns (int16[2] memory) ;
    function validateCodeIdx(string memory group, string memory code, uint16 groupIdx, uint16 codeIdx) external view returns (bool);
}

contract AntERC721 is ERC721, ERC2981, Ownable {

    event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);

    bool mint_allowed = false;
    uint8 special_minted;
    uint8 reveal_state = REVEAL_LOCKED;
    uint16 last_nft_id;

    uint8 public MAX_CNT_PER_MINT = 3;
    uint32 public LOCK_PERIOD = 86400 * 7;

    uint16[3] nftPool;

    uint256 public mintPrice = (1 ether / 100);
    uint256[3] first_nft_price = [0, (1 ether / 1000 * 5), (1 ether / 100)];

    address[2] refCodesContract;

    bool[8500] private single_codes_used;
    bool[6100] is_guardian;
    bool[6100] is_collector;
    uint16[6100] nft_family_idx;

    mapping(address => uint8) public cnt_minted;
    mapping(uint16 => uint32) public locked_until;
    mapping(uint16 => uint32) public last_transfered;
    mapping(uint16 => address) public owners;
    mapping(address => uint16[]) public owned;

    string initialMetadata;
    string preRevealMetadata;
    string revealMetadata;
    string contractUri;

    // admin entered + user autogenerated
    mapping(bytes18 => int16) public coupons;

    // guardians, miners, collectors
    uint8 public constant CNT_SPECIAL = 12;
    uint8 public constant fam_guardians = 0;
    uint8 public constant fam_collectors = 1;
    uint8 public constant fam_miners = 2;
    uint8 public constant REVEAL_LOCKED = 0;
    uint8 public constant REVEAL_EARLY = 1;
    uint8 public constant REVEAL_OPEN = 2;

    struct NFT {
        bool isRevealed;
        bool isGuardian;
        bool isMiner;
        bool isCollector;
        uint16 id;
    }

    constructor(
        address[2] memory refCodes,
        uint16[3] memory nftCounts,
        string memory name_,
        string memory symbol_)
        ERC721(name_, symbol_)
       {
        refCodesContract = refCodes;
        nftPool = nftCounts;
        _setDefaultRoyalty(msg.sender, 100);
    }

    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, ERC2981) returns (bool) {
        return super.supportsInterface(interfaceId);
    }

    function mintCustom() onlyOwner external {
        require(!mint_allowed, "Mint already started");
        require(last_nft_id == 0, "Something already minted");

        for (uint256 j = 1; j <= CNT_SPECIAL; j = j + 1) {
            last_nft_id++;
            _mint(msg.sender, last_nft_id);
            owners[last_nft_id] = msg.sender;
        }

        special_minted = CNT_SPECIAL;
    }

    function setMaxCountPerMint(uint8 cnt) onlyOwner external {
        MAX_CNT_PER_MINT = cnt;
    }

    function setLockPeriod(uint32 sec) onlyOwner external {
        LOCK_PERIOD = sec;
    }

    function setContractUri(string memory uri) onlyOwner external {
        contractUri = uri;
        emit BatchMetadataUpdate(0, last_nft_id);
    }

    function setInitialMetadataUri(string memory uri) onlyOwner external {
        initialMetadata = uri;
        emit BatchMetadataUpdate(0, last_nft_id);
    }

    function setPreRevealMetadataUri(string memory uri) onlyOwner external {
        preRevealMetadata = uri;
        emit BatchMetadataUpdate(0, last_nft_id);
    }

    function setRevealMetadataUri(string memory uri) onlyOwner external {
        revealMetadata = uri;
        emit BatchMetadataUpdate(0, last_nft_id);
    }

    function setCodesContract(address[2] memory addr) onlyOwner external {
        refCodesContract = addr;
    }

    function handleMint(address to, uint8 cnt) private {
        uint256 familyIdx = rand() % 3;
        uint32 ts = uint32(block.timestamp % 2**32);

        for (uint256 j = 1; j <= cnt; j = j + 1) {
            last_nft_id++;

            uint256 b;
            for (b = 0; b < 4; b = b + 1) {
                if (b == 3) {
                    revert("No NFTs left");
                }

                familyIdx = (familyIdx + 1) % 3;

                if (nftPool[familyIdx] > 0) {
                    _mint(to, last_nft_id);

                    is_guardian[last_nft_id] = familyIdx == fam_guardians;
                    is_collector[last_nft_id] = familyIdx == fam_collectors;

                    nft_family_idx[last_nft_id] = nftPool[familyIdx];
                    nftPool[familyIdx]--;

                    if (b == 0 && (owned[to].length == 0)) {
                        // lock the first NFT for 7 days
                        locked_until[last_nft_id] = ts + LOCK_PERIOD;

                        // set up user's own coupon code
                        bytes18 code = _calcCouponCode(to);

                        // unlimited mints
                        coupons[code] = -1;
                    }

                    owners[last_nft_id] = to;

                    owned[to].push(last_nft_id);

                    break;
                }
            }
        }

        cnt_minted[to] += cnt;
    }

    function mint(uint8 cnt, bytes18 coupon) external payable {
        address to = msg.sender;
        require(mint_allowed, "Mint not started");
        require(cnt >= 1 && (cnt + cnt_minted[to]) <= MAX_CNT_PER_MINT, "Wrong quantity");
        require(isCouponValid(coupon, cnt), "Invalid coupon");

        uint8 priceLevel = 1;

        for (uint8 j = 17; j > 0; j--) {
            bytes1 currentByte = coupon[j];
            if (currentByte != 0) {
                priceLevel = getCodePriceLevel(currentByte);
                break;
            }
        }

        require(msg.value == getNFTEthPrice(to, cnt, priceLevel), "Not enough ETH");

        handleMint(to, cnt);

        coupons[coupon] = coupons[coupon] - int16(int8(cnt));
    }

    function mintWithSingleUseCode(uint8 cnt, string memory group, string memory code, uint16 groupIdx, uint16 codeIdx, uint8 setIdx) external payable {
        address to = msg.sender;
        require(mint_allowed, "Mint not started");
        require(cnt >= 1 && (cnt + cnt_minted[to]) <= MAX_CNT_PER_MINT, "Wrong quantity");

        uint8 priceLevel = getStringCodePriceLevel(group);

        bool isValid = RefCode(refCodesContract[setIdx]).validateCodeIdx(group, code, groupIdx, codeIdx);
        require(isValid, "Validation failed");
        require(!single_codes_used[codeIdx], "Code used");
        require(msg.value == getNFTEthPrice(to, cnt, priceLevel), "Not enough ETH");

        single_codes_used[codeIdx] = true;

        handleMint(to, cnt);
    }

    function ownerMint(address to, uint8 cnt) onlyOwner external {
        // require(!mint_allowed, "Mint already started");

        handleMint(to, cnt);
    }

    function bulkMint(address[] memory to, uint8[] memory cnt) onlyOwner external {
        for (uint16 j = 0; j < to.length; j++) {
            handleMint(to[j], cnt[j]);
        }
    }

    function rand() private view returns(uint256) {
        uint256 seed = uint256(keccak256(abi.encodePacked(
            block.timestamp + block.prevrandao +
            ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (block.timestamp)) +
            block.gaslimit +
            ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (block.timestamp)) +
            block.number
        )));

        return (seed - ((seed / 1000) * 1000));
    }

    function burn(uint16 tokenId) external {
        require(owners[tokenId] == msg.sender, "Not an owner");
        require(tokenId <= special_minted, "Can't burn this NFT");

        _burn(tokenId);
    }

    function earlyReveal() onlyOwner external {
        reveal_state = REVEAL_EARLY;
    }

    function fullReveal() onlyOwner external {
        reveal_state = REVEAL_OPEN;
    }

    function tokenURI(uint256 _tokenId) public view virtual override returns (string memory) {
        if (owners[uint16(_tokenId)] == address(0)) {
            return string.concat(initialMetadata, "default.json") ;
        }

        if (_tokenId <= special_minted) {
            return string.concat(reveal_state == REVEAL_LOCKED ? initialMetadata : (reveal_state == REVEAL_EARLY ? preRevealMetadata : revealMetadata), Strings.toString(_tokenId), ".json") ;
        }

        // generic cocoon image before early reveal
        NFT memory nft = getNFT(uint16(_tokenId));
        if (reveal_state == REVEAL_LOCKED || !nft.isRevealed) {
            return string.concat(initialMetadata, "default.json") ;
        }

        string memory fileName = string.concat(is_collector[_tokenId] ? "1-" : (is_guardian[_tokenId] ? "2-" : "3-"), Strings.toString(nft_family_idx[_tokenId]));

        return string.concat(reveal_state == REVEAL_EARLY ? preRevealMetadata : revealMetadata, fileName, ".json");
    }

    function contractURI() public view returns (string memory) {
        return contractUri;
    }

    function setFirstNFTPrice(uint256 idx, uint256 price) onlyOwner external {
        first_nft_price[idx] = price;
    }

    function setMintStatus(bool isAllowed) onlyOwner external {
        mint_allowed = isAllowed;
    }

    function setMintPrice(uint256 price) onlyOwner external {
        mintPrice = price;
    }

    function registerCoupon(bytes18 coupon, int16 limit) onlyOwner external {
        coupons[coupon] = limit;
    }

    function registerBulkCoupons(bytes18[] memory cpns, int16[] memory limit) onlyOwner external {
        for (uint i = 0; i < cpns.length; i++) {
            coupons[cpns[i]] = limit[i];
        }
    }

    function isCouponValid(bytes18 coupon, uint8 cnt) view public returns (bool) {
        require(mint_allowed, "Mint not started");
        require(cnt >= 1 && cnt <= MAX_CNT_PER_MINT, "Wrong quantity");
        int16 remaining = coupons[coupon];
        return ((remaining > 0) && (remaining - int16(int8((cnt))) >= 0)) || (remaining < 0);
    }

    function getCodeIdx(string calldata group, string calldata code) public view returns (int16[3] memory) {
        for (int16 i = 0; i < 2; i++) {
            int16[2] memory idx = RefCode(refCodesContract[uint256(uint16(i))]).getCodeIdx(group, code);
            if (idx[0] > -1 && idx[1] > -1) {
                return [idx[0], idx[1], i];
            }
        }

        return [int16(-1), int16(-1), int16(-1)];
    }

    function transferFrom(address from, address to, uint256 tokenId) public override {
        safeTransferFrom(from, to, tokenId);
    }

    function safeTransferFrom(address from, address to, uint256 tokenId) public override {
        uint32 ts = uint32(block.timestamp % 2**32);
        uint16 safeId = uint16(tokenId);
        require (locked_until[safeId] < ts, "Locked");

        super.safeTransferFrom(from, to, safeId);

        owned[to].push(safeId);
        owners[safeId] = to;

        // remove the NFT from the owned list of the previous owner
        for (uint i = 0; i < owned[from].length; i++) {
            if (owned[from][i] == safeId) {
                owned[from][i] = 0;
            }
        }

        while (owned[from].length > 0 && (owned[from][owned[from].length - 1] == 0)) {
            owned[from].pop();
        }

        last_transfered[safeId] = ts;
    }

    function availableSupply() view public returns (uint256) {
        return nftPool[0] + nftPool[1] + nftPool[2];
    }

    function totalSupply() view public returns (uint256) {
        return last_nft_id + availableSupply();
    }

    function getStringCodePriceLevel(string memory coupon) pure public returns (uint8) {
        uint256 end = bytes(coupon).length - 1;

        return getCodePriceLevel(bytes(coupon)[end]);
    }

    function getCodePriceLevel(bytes1 coupon) pure public returns (uint8) {
        bytes32 last = keccak256(abi.encodePacked(coupon));

        if (keccak256(abi.encodePacked("a")) == last) {
            return 0;
        }
        else if (keccak256(abi.encodePacked("b")) == last) {
            return 1;
        }
        else if (keccak256(abi.encodePacked("c")) == last) {
            return 2;
        }
        else {
            return 1;
        }
    }

    function getNFTEthPrice(address to, uint256 count, uint256 priceLevel) view public returns (uint256) {
        bool firstMinted = owned[to].length > 0;
        uint256 price = ((mintPrice * count) - ((firstMinted ? 0 : 1) * mintPrice)) + (firstMinted ? 0 : first_nft_price[priceLevel]);

        if (count == 4) {
            price = (price * 9) / 10;
        }

        return price;
    }

    function isEligibleForEarlyReveal(address to) view public returns (bool) {
        return coupons[getCouponCode(to)] < -1;
    }

    function getMintPrice() view public returns (uint256) {
        return mintPrice;
    }

    function getFirstNftPrice(uint256 idx) view public returns (uint256) {
        return first_nft_price[idx];
    }

    function getAllPriceLevels() view public returns (uint256[3] memory) {
        return first_nft_price;
    }

    function getNFTs(address to) view public returns (NFT[] memory) {
        NFT[] memory userNfts = new NFT[](owned[to].length);

        uint16 idx = 0;
        for (uint16 i = 0; i < owned[to].length; i++) {
            if (owned[to][i] != 0) {
                userNfts[idx] = getNFT(owned[to][i]);
                idx++;
            }
        }

        return userNfts;
    }

    function getNFT(uint16 id) view public returns (NFT memory) {
        NFT memory nft = NFT({
            id: id,
            isRevealed: isRevealed(id),
            isGuardian: isGuardian(id),
            isMiner: isMiner(id),
            isCollector: isCollector(id)
        });

        return nft;
    }

    function isRevealed(uint16 id) view internal returns (bool) {
        return (reveal_state == REVEAL_OPEN) ||
               ((reveal_state == REVEAL_EARLY) && (last_transfered[id] == 0) && isEligibleForEarlyReveal(owners[id]));
    }

    function isGuardian(uint16 id) view internal returns (bool) {
        return isRevealed(id) && is_guardian[id];
    }

    function isCollector(uint16 id) view internal returns (bool) {
        return isRevealed(id) && is_collector[id];
    }

    function isMiner(uint16 id) view internal returns (bool) {
        return isRevealed(id) && !is_collector[id] && !is_guardian[id];
    }

    function getSliceBytes(bytes32 text, uint256 begin, uint256 end) internal pure returns (bytes memory) {
        if (end > text.length) {
            end = text.length;
        }

        bytes memory a = new bytes(end - begin + 1);

        for(uint i = 0; i <= end - begin; i++) {
            unchecked { a[i] = text[i + begin - 1]; }
        }

        return a;
    }

    function _calcCouponCode(address to) internal pure returns (bytes18) {
        bytes32 addressHashBytes = sha256(abi.encodePacked(to, 'antrep'));
        return iToHex(getSliceBytes(addressHashBytes, 1, 4));
    }

    function iToHex(bytes memory buffer) public pure returns (bytes18) {
        // Fixed buffer size for hexadecimal convertion
        bytes memory converted = new bytes(buffer.length * 2);

        bytes memory _base = "0123456789defghijklmnopqrstuvwxyz";

        for (uint256 i = 0; i < buffer.length; i++) {
            converted[i * 2] = _base[uint8(buffer[i]) / _base.length];
            converted[i * 2 + 1] = _base[uint8(buffer[i]) % _base.length];
        }

        return bytes10(abi.encodePacked(converted));
    }

    function getCouponCode(address to) internal view returns (bytes18) {
        bytes18 code = _calcCouponCode(to);
        if (coupons[code] < 0) {
            return code;
        } else {
            return "";
        }
    }

    function getMyCouponCode() public view returns (bytes18) {
        return getCouponCode(msg.sender);
    }

    function setDefaultRoyalty(address receiver, uint96 feeNumerator) onlyOwner external {
        _setDefaultRoyalty(receiver, feeNumerator);
    }

    function deleteDefaultRoyalty() onlyOwner external {
        _deleteDefaultRoyalty();
    }

    function setTokenRoyalty(uint256 tokenId, address receiver, uint96 feeNumerator) onlyOwner external {
        _setTokenRoyalty(tokenId, receiver, feeNumerator);
    }

    function resetTokenRoyalty(uint256 tokenId) onlyOwner external {
        _resetTokenRoyalty(tokenId);
    }

    function withdraw(address to) public onlyOwner {
        uint256 amount = address(this).balance;
        require(amount > 0, "Nothing to withdraw; contract balance empty");

        (bool sent, ) = to.call{value: amount}("");
        require(sent, "Failed to send Ether");
    }

    // Function to receive Ether. msg.data must be empty
    receive() external payable {}

    // Fallback function is called when msg.data is not empty
    fallback() external payable {}

}