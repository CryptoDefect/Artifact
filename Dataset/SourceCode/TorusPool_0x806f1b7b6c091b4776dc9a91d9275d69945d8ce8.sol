{{

  "language": "Solidity",

  "sources": {

    "contracts/TorusPool.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"../interfaces/pools/ITorusPool.sol\";\nimport \"../interfaces/pools/IRewardManager.sol\";\nimport \"../interfaces/ICurveHandler.sol\";\nimport \"../interfaces/ICurveRegistryCache.sol\";\nimport \"../interfaces/tokenomics/IInflationManager.sol\";\nimport \"../interfaces/tokenomics/ILpTokenStaker.sol\";\nimport \"../interfaces/IConvexHandler.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../interfaces/IOracle.sol\";\nimport \"../interfaces/vendor/IBaseRewardPool.sol\";\n\nimport \"./LpToken.sol\";\nimport \"./RewardManager.sol\";\n\nimport \"../libraries/ScaledMath.sol\";\nimport \"../libraries/ArrayExtensions.sol\";\nimport \"../libraries/UniversalERC20.sol\";\n\ncontract TorusPool is ITorusPool, Ownable {\n    using ArrayExtensions for uint256[];\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableMap for EnumerableMap.AddressToUintMap;\n    using UniversalERC20 for IERC20;\n    using UniversalERC20 for IERC20Metadata;\n    using SafeERC20 for ILpToken;\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IERC20Metadata;\n    using ScaledMath for uint256;\n    using Address for address;\n\n    // Avoid stack depth errors\n    struct DepositVars {\n        uint256 exchangeRate;\n        uint256 underlyingBalanceIncrease;\n        uint256 mintableUnderlyingAmount;\n        uint256 lpReceived;\n        uint256 underlyingBalanceBefore;\n        uint256 allocatedBalanceBefore;\n        uint256[] allocatedPerPoolBefore;\n        uint256 underlyingBalanceAfter;\n        uint256 allocatedBalanceAfter;\n        uint256[] allocatedPerPoolAfter;\n    }\n\n    uint256 internal constant _IDLE_RATIO_UPPER_BOUND = 0.2e18;\n    uint256 internal constant _MIN_DEPEG_THRESHOLD = 0.01e18;\n    uint256 internal constant _MAX_DEPEG_THRESHOLD = 0.1e18;\n    uint256 internal constant _MAX_DEVIATION_UPPER_BOUND = 0.2e18;\n    uint256 internal constant _DEPEG_UNDERLYING_MULTIPLIER = 2;\n    uint256 internal constant _TOTAL_UNDERLYING_CACHE_EXPIRY = 3 days;\n    uint256 internal constant _MAX_USD_LP_VALUE_FOR_REMOVING_CURVE_POOL = 100e18;\n\n    IERC20 public immutable TORUS;\n    address internal constant _WETH_ADDRESS = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address internal constant _ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    IERC20 internal constant CVX = IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);\n    IERC20 internal constant CRV = IERC20(0xD533a949740bb3306d119CC777fa900bA034cd52);\n\n    IERC20Metadata public immutable override underlying;\n    ILpToken public immutable override lpToken;\n\n    IRewardManager public rewardManager;\n    IController public immutable controller;\n\n    /// @dev once the deviation gets under this threshold, the reward distribution will be paused\n    /// until the next rebalancing. This is expressed as a ratio, scaled with 18 decimals\n    uint256 public maxDeviation = 0.02e18; // 2%\n    uint256 public maxIdleCurveLpRatio = 0.05e18; // triggers Convex staking when exceeded\n    bool public isShutdown;\n    uint256 public depegThreshold = 0.03e18; // 3%\n    uint256 internal _cacheUpdatedTimestamp;\n    uint256 internal _cachedTotalUnderlying;\n\n    /// @dev `true` while the reward distribution is active\n    bool public rebalancingRewardActive;\n\n    EnumerableSet.AddressSet internal _curvePools;\n    EnumerableMap.AddressToUintMap internal weights; // liquidity allocation weights\n\n    /// @dev the absolute value in terms of USD of the total deviation after\n    /// the weights have been updated\n    uint256 public totalDeviationAfterWeightUpdate;\n\n    mapping(address => uint256) _cachedPrices;\n\n    modifier onlyController() {\n        require(msg.sender == address(controller), \"not authorized\");\n        _;\n    }\n\n    constructor(\n        address _underlying,\n        address _controller,\n        string memory _lpTokenName,\n        string memory _symbol\n    ) {\n        require(\n            _underlying != address(CVX) && _underlying != address(CRV) && _underlying != IController(_controller).torusToken(),\n            \"invalid underlying\"\n        );\n        underlying = IERC20Metadata(_underlying);\n        controller = IController(_controller);\n        TORUS = IERC20(IController(controller).torusToken());\n        uint8 decimals = IERC20Metadata(_underlying).decimals();\n        lpToken = new LpToken(address(this), decimals, _lpTokenName, _symbol);\n    }\n\n    /// @dev We always delegate-call to the Curve handler, which means\n    /// that we need to be able to receive the ETH to unwrap it and\n    /// send it to the Curve pool, as well as to receive it back from\n    /// the Curve pool when withdrawing\n    receive() external payable {\n        require(address(underlying) == _WETH_ADDRESS, \"not WETH pool\");\n    }\n\n    /// @notice Deposit underlying on behalf of someone\n    /// @param underlyingAmount Amount of underlying to deposit\n    /// @param minLpReceived The minimum amount of LP to accept from the deposit\n    /// @return lpReceived The amount of LP received\n    function depositFor(\n        address account,\n        uint256 underlyingAmount,\n        uint256 minLpReceived,\n        bool stake\n    ) public payable override returns (uint256) {\n        DepositVars memory vars;\n\n        // Preparing deposit\n        require(!isShutdown, \"pool is shutdown\");\n        require(underlyingAmount > 0, \"deposit amount cannot be zero\");\n        uint256 underlyingPrice_ = controller.priceOracle().getUSDPrice(address(underlying));\n        (\n            vars.underlyingBalanceBefore,\n            vars.allocatedBalanceBefore,\n            vars.allocatedPerPoolBefore\n        ) = _getTotalAndPerPoolUnderlying(underlyingPrice_);\n        vars.exchangeRate = _exchangeRate(vars.underlyingBalanceBefore);\n\n        // Executing deposit\n        underlying.universalTransferFrom(msg.sender, address(this), underlyingAmount);\n        _depositToCurve(\n            vars.allocatedBalanceBefore,\n            vars.allocatedPerPoolBefore,\n            underlying.universalBalanceOf(address(this))\n        );\n\n        // Minting LP Tokens\n        (\n            vars.underlyingBalanceAfter,\n            vars.allocatedBalanceAfter,\n            vars.allocatedPerPoolAfter\n        ) = _getTotalAndPerPoolUnderlying(underlyingPrice_);\n        vars.underlyingBalanceIncrease = vars.underlyingBalanceAfter - vars.underlyingBalanceBefore;\n        vars.mintableUnderlyingAmount = _min(underlyingAmount, vars.underlyingBalanceIncrease);\n        vars.lpReceived = vars.mintableUnderlyingAmount.divDown(vars.exchangeRate);\n        require(vars.lpReceived >= minLpReceived, \"too much slippage\");\n\n        if (stake) {\n            lpToken.mint(address(this), vars.lpReceived);\n            ILpTokenStaker lpTokenStaker = controller.lpTokenStaker();\n            lpToken.safeApprove(address(lpTokenStaker), vars.lpReceived);\n            lpTokenStaker.stakeFor(vars.lpReceived, address(this), account);\n        } else {\n            lpToken.mint(account, vars.lpReceived);\n        }\n\n        _handleRebalancingRewards(\n            account,\n            vars.allocatedBalanceBefore,\n            vars.allocatedPerPoolBefore,\n            vars.allocatedBalanceAfter,\n            vars.allocatedPerPoolAfter\n        );\n\n        _cachedTotalUnderlying = vars.underlyingBalanceAfter;\n        _cacheUpdatedTimestamp = block.timestamp;\n\n        emit Deposit(msg.sender, account, underlyingAmount, vars.lpReceived);\n        return vars.lpReceived;\n    }\n\n    /// @notice Deposit underlying\n    /// @param underlyingAmount Amount of underlying to deposit\n    /// @param minLpReceived The minimum amoun of LP to accept from the deposit\n    /// @return lpReceived The amount of LP received\n    function deposit(uint256 underlyingAmount, uint256 minLpReceived)\n        external\n        payable\n        override\n        returns (uint256)\n    {\n        return depositFor(msg.sender, underlyingAmount, minLpReceived, true);\n    }\n\n    /// @notice Deposit underlying\n    /// @param underlyingAmount Amount of underlying to deposit\n    /// @param minLpReceived The minimum amoun of LP to accept from the deposit\n    /// @param stake Whether or not to stake in the LpTokenStaker\n    /// @return lpReceived The amount of LP received\n    function deposit(\n        uint256 underlyingAmount,\n        uint256 minLpReceived,\n        bool stake\n    ) external payable override returns (uint256) {\n        return depositFor(msg.sender, underlyingAmount, minLpReceived, stake);\n    }\n\n    function _depositToCurve(\n        uint256 totalUnderlying_,\n        uint256[] memory allocatedPerPool,\n        uint256 underlyingAmount_\n    ) internal {\n        uint256 depositsRemaining_ = underlyingAmount_;\n        uint256 totalAfterDeposit_ = totalUnderlying_ + underlyingAmount_;\n\n        // NOTE: avoid modifying `allocatedPerPool`\n        uint256[] memory allocatedPerPoolCopy = allocatedPerPool.copy();\n\n        while (depositsRemaining_ > 0) {\n            (uint256 curvePoolIndex_, uint256 maxDeposit_) = _getDepositPool(\n                totalAfterDeposit_,\n                allocatedPerPoolCopy\n            );\n            // account for rounding errors\n            if (depositsRemaining_ < maxDeposit_ + 1e2) {\n                maxDeposit_ = depositsRemaining_;\n            }\n\n            address curvePool_ = _curvePools.at(curvePoolIndex_);\n\n            // Depositing into least balanced pool\n            uint256 toDeposit_ = _min(depositsRemaining_, maxDeposit_);\n            _depositToCurvePool(curvePool_, toDeposit_);\n            depositsRemaining_ -= toDeposit_;\n            allocatedPerPoolCopy[curvePoolIndex_] += toDeposit_;\n        }\n    }\n\n    function _getDepositPool(uint256 totalUnderlying_, uint256[] memory allocatedPerPool)\n        internal\n        view\n        returns (uint256 poolIndex, uint256 maxDepositAmount)\n    {\n        uint256 curvePoolCount_ = allocatedPerPool.length;\n        int256 iPoolIndex = -1;\n        for (uint256 i; i < curvePoolCount_; i ++) {\n            address curvePool_ = _curvePools.at(i);\n            uint256 allocatedUnderlying_ = allocatedPerPool[i];\n            uint256 targetAllocation_ = totalUnderlying_.mulDown(weights.get(curvePool_));\n            if (allocatedUnderlying_ >= targetAllocation_) continue;\n            uint256 maxBalance_ = targetAllocation_ + targetAllocation_.mulDown(_getMaxDeviation());\n            uint256 maxDepositAmount_ = maxBalance_ - allocatedUnderlying_;\n            if (maxDepositAmount_ <= maxDepositAmount) continue;\n            maxDepositAmount = maxDepositAmount_;\n            iPoolIndex = int256(i);\n        }\n        require(iPoolIndex > -1, \"error retrieving deposit pool\");\n        poolIndex = uint256(iPoolIndex);\n    }\n\n    function _depositToCurvePool(address curvePool_, uint256 underlyingAmount_) internal {\n        if (underlyingAmount_ == 0) return;\n        controller.curveHandler().functionDelegateCall(\n            abi.encodeWithSignature(\n                \"deposit(address,address,uint256)\",\n                curvePool_,\n                underlying,\n                underlyingAmount_\n            )\n        );\n\n        uint256 idleCurveLpBalance_ = _idleCurveLpBalance(curvePool_);\n        uint256 totalCurveLpBalance_ = _stakedCurveLpBalance(curvePool_) + idleCurveLpBalance_;\n        if (idleCurveLpBalance_.divDown(totalCurveLpBalance_) >= maxIdleCurveLpRatio) {\n            controller.convexHandler().functionDelegateCall(\n                abi.encodeWithSignature(\"deposit(address,uint256)\", curvePool_, idleCurveLpBalance_)\n            );\n        }\n    }\n\n    /// @notice Get current underlying balance of pool\n    function totalUnderlying() public view virtual returns (uint256) {\n        (uint256 totalUnderlying_, , ) = getTotalAndPerPoolUnderlying();\n\n        return totalUnderlying_;\n    }\n\n    function _exchangeRate(uint256 totalUnderlying_) internal view returns (uint256) {\n        uint256 lpSupply = lpToken.totalSupply();\n        if (lpSupply == 0 || totalUnderlying_ == 0) return ScaledMath.ONE;\n\n        return totalUnderlying_.divDown(lpSupply);\n    }\n\n    /// @notice Get current exchange rate for the pool's LP token to the underlying\n    function exchangeRate() public view virtual override returns (uint256) {\n        return _exchangeRate(totalUnderlying());\n    }\n\n    /// @notice Get current exchange rate for the pool's LP token to USD\n    /// @dev This is using the cached total underlying value, so is not precisely accurate.\n    function usdExchangeRate() external view virtual override returns (uint256) {\n        uint256 underlyingPrice = controller.priceOracle().getUSDPrice(address(underlying));\n        return _exchangeRate(_cachedTotalUnderlying).mulDown(underlyingPrice);\n    }\n\n    /// @notice Unstake LP Tokens and withdraw underlying\n    /// @param torusLpAmount Amount of LP tokens to burn\n    /// @param minUnderlyingReceived Minimum amount of underlying to redeem\n    /// This should always be set to a reasonable value (e.g. 2%), otherwise\n    /// the user withdrawing could be forced into paying a withdrawal penalty fee\n    /// by another user\n    /// @return uint256 Total underlying withdrawn\n    function unstakeAndWithdraw(uint256 torusLpAmount, uint256 minUnderlyingReceived)\n        external\n        returns (uint256)\n    {\n        controller.lpTokenStaker().unstakeFrom(torusLpAmount, msg.sender);\n        return withdraw(torusLpAmount, minUnderlyingReceived);\n    }\n\n    /// @notice Withdraw underlying\n    /// @param torusLpAmount Amount of LP tokens to burn\n    /// @param minUnderlyingReceived Minimum amount of underlying to redeem\n    /// This should always be set to a reasonable value (e.g. 2%), otherwise\n    /// the user withdrawing could be forced into paying a withdrawal penalty fee\n    /// by another user\n    /// @return uint256 Total underlying withdrawn\n    function withdraw(uint256 torusLpAmount, uint256 minUnderlyingReceived)\n        public\n        override\n        returns (uint256)\n    {\n        // Preparing Withdrawals\n        require(lpToken.balanceOf(msg.sender) >= torusLpAmount, \"insufficient balance\");\n        uint256 underlyingBalanceBefore_ = underlying.universalBalanceOf(address(this));\n\n        // Processing Withdrawals\n        (\n            uint256 totalUnderlying_,\n            uint256 allocatedUnderlying_,\n            uint256[] memory allocatedPerPool\n        ) = getTotalAndPerPoolUnderlying();\n        uint256 underlyingToReceive_ = torusLpAmount.mulDown(_exchangeRate(totalUnderlying_));\n        {\n            if (underlyingBalanceBefore_ < underlyingToReceive_) {\n                uint256 underlyingToWithdraw_ = underlyingToReceive_ - underlyingBalanceBefore_;\n                _withdrawFromCurve(allocatedUnderlying_, allocatedPerPool, underlyingToWithdraw_);\n            }\n        }\n\n        // Sending Underlying and burning LP Tokens\n        uint256 underlyingWithdrawn_ = _min(\n            underlying.universalBalanceOf(address(this)),\n            underlyingToReceive_\n        );\n        require(underlyingWithdrawn_ >= minUnderlyingReceived, \"too much slippage\");\n        lpToken.burn(msg.sender, torusLpAmount);\n        underlying.universalTransfer(msg.sender, underlyingWithdrawn_);\n\n        _cachedTotalUnderlying = totalUnderlying_ - underlyingWithdrawn_;\n        _cacheUpdatedTimestamp = block.timestamp;\n\n        emit Withdraw(msg.sender, underlyingWithdrawn_);\n        return underlyingWithdrawn_;\n    }\n\n    function _withdrawFromCurve(\n        uint256 totalUnderlying_,\n        uint256[] memory allocatedPerPool,\n        uint256 amount_\n    ) internal {\n        uint256 withdrawalsRemaining_ = amount_;\n        uint256 totalAfterWithdrawal_ = totalUnderlying_ - amount_;\n\n        // NOTE: avoid modifying `allocatedPerPool`\n        uint256[] memory allocatedPerPoolCopy = allocatedPerPool.copy();\n\n        while (withdrawalsRemaining_ > 0) {\n            (uint256 curvePoolIndex_, uint256 maxWithdrawal_) = _getWithdrawPool(\n                totalAfterWithdrawal_,\n                allocatedPerPoolCopy\n            );\n            address curvePool_ = _curvePools.at(curvePoolIndex_);\n\n            // Withdrawing from least balanced Curve pool\n            uint256 toWithdraw_ = _min(withdrawalsRemaining_, maxWithdrawal_);\n            _withdrawFromCurvePool(curvePool_, toWithdraw_);\n            withdrawalsRemaining_ -= toWithdraw_;\n            allocatedPerPoolCopy[curvePoolIndex_] -= toWithdraw_;\n        }\n    }\n\n    function _getWithdrawPool(uint256 totalUnderlying_, uint256[] memory allocatedPerPool)\n        internal\n        view\n        returns (uint256 withdrawPoolIndex, uint256 maxWithdrawalAmount)\n    {\n        uint256 curvePoolCount_ = allocatedPerPool.length;\n        int256 iWithdrawPoolIndex = -1;\n        for (uint256 i; i < curvePoolCount_; i ++) {\n            address curvePool_ = _curvePools.at(i);\n            uint256 weight_ = weights.get(curvePool_);\n            uint256 allocatedUnderlying_ = allocatedPerPool[i];\n\n            // If a curve pool has a weight of 0,\n            // withdraw from it if it has more than the max lp value\n            if (weight_ == 0) {\n                uint256 price_ = controller.priceOracle().getUSDPrice(address(underlying));\n                uint256 allocatedUsd = (price_ * allocatedUnderlying_) / 10**underlying.universalDecimals();\n                if (allocatedUsd >= _MAX_USD_LP_VALUE_FOR_REMOVING_CURVE_POOL / 2) {\n                    return (i, allocatedUnderlying_);\n                }\n            }\n\n            uint256 targetAllocation_ = totalUnderlying_.mulDown(weight_);\n            if (allocatedUnderlying_ <= targetAllocation_) continue;\n            uint256 minBalance_ = targetAllocation_ - targetAllocation_.mulDown(_getMaxDeviation());\n            uint256 maxWithdrawalAmount_ = allocatedUnderlying_ - minBalance_;\n            if (maxWithdrawalAmount_ <= maxWithdrawalAmount) continue;\n            maxWithdrawalAmount = maxWithdrawalAmount_;\n            iWithdrawPoolIndex = int256(i);\n        }\n        require(iWithdrawPoolIndex > -1, \"error retrieving withdraw pool\");\n        withdrawPoolIndex = uint256(iWithdrawPoolIndex);\n    }\n\n    function _withdrawFromCurvePool(address curvePool_, uint256 underlyingAmount_) internal {\n        ICurveRegistryCache registryCache_ = controller.curveRegistryCache();\n        address curveLpToken_ = registryCache_.lpToken(curvePool_);\n        uint256 lpToWithdraw_ = _underlyingToCurveLp(curveLpToken_, underlyingAmount_);\n        if (lpToWithdraw_ == 0) return;\n\n        uint256 idleCurveLpBalance_ = _idleCurveLpBalance(curvePool_);\n        address rewardPool = registryCache_.getRewardPool(curvePool_);\n        uint256 stakedLpBalance = IBaseRewardPool(rewardPool).balanceOf(address(this));\n        uint256 totalAvailableLp = idleCurveLpBalance_ + stakedLpBalance;\n        // Due to rounding errors with the conversion of underlying to LP tokens,\n        // we may not have the precise amount of LP tokens to withdraw from the pool.\n        // In this case, we withdraw the maximum amount of LP tokens available.\n        if (totalAvailableLp < lpToWithdraw_) {\n            lpToWithdraw_ = totalAvailableLp;\n        }\n\n        if (lpToWithdraw_ > idleCurveLpBalance_) {\n            controller.convexHandler().functionDelegateCall(\n                abi.encodeWithSignature(\n                    \"withdraw(address,uint256)\",\n                    curvePool_,\n                    lpToWithdraw_ - idleCurveLpBalance_\n                )\n            );\n        }\n\n        controller.curveHandler().functionDelegateCall(\n            abi.encodeWithSignature(\n                \"withdraw(address,address,uint256)\",\n                curvePool_,\n                underlying,\n                lpToWithdraw_\n            )\n        );\n    }\n\n    function allCurvePools() external view override returns (address[] memory) {\n        return _curvePools.values();\n    }\n\n    function curvePoolsCount() external view override returns (uint256) {\n        return _curvePools.length();\n    }\n\n    function getCurvePoolAtIndex(uint256 _index) external view returns (address) {\n        return _curvePools.at(_index);\n    }\n\n    function isRegisteredCurvePool(address _pool) public view returns (bool) {\n        return _curvePools.contains(_pool);\n    }\n\n    function getPoolWeight(address _pool) external view returns (uint256) {\n        (, uint256 _weight) = weights.tryGet(_pool);\n        return _weight;\n    }\n\n    // Controller and Admin functions\n\n    function addCurvePool(address _pool) external override onlyOwner {\n        require(!_curvePools.contains(_pool), \"pool already added\");\n        ICurveRegistryCache curveRegistryCache_ = controller.curveRegistryCache();\n        curveRegistryCache_.initPool(_pool);\n        // underlying token is always WETH\n        bool supported_ = curveRegistryCache_.hasCoinAnywhere(_pool, address(underlying)) || curveRegistryCache_.hasCoinAnywhere(_pool, _ETH_ADDRESS);\n        require(supported_, \"coin not in pool\");\n        address curveLpToken = curveRegistryCache_.lpToken(_pool);\n        require(controller.priceOracle().isTokenSupported(curveLpToken), \"cannot price LP Token\");\n\n        address booster = controller.convexBooster();\n        IERC20(curveLpToken).safeApprove(booster, type(uint256).max);\n\n        if (!weights.contains(_pool)) weights.set(_pool, 0);\n        require(_curvePools.add(_pool), \"failed to add pool\");\n        emit CurvePoolAdded(_pool);\n    }\n\n    // This requires that the weight of the pool is first set to 0\n    function removeCurvePool(address _pool) external override onlyOwner {\n        require(_curvePools.contains(_pool), \"pool not added\");\n        require(_curvePools.length() > 1, \"cannot remove last pool\");\n        address curveLpToken = controller.curveRegistryCache().lpToken(_pool);\n        uint256 lpTokenPrice = controller.priceOracle().getUSDPrice(curveLpToken);\n        uint256 usdLpValue = totalCurveLpBalance(_pool).mulDown(lpTokenPrice);\n        require(usdLpValue < _MAX_USD_LP_VALUE_FOR_REMOVING_CURVE_POOL, \"pool has allocated funds\");\n        uint256 weight = weights.get(_pool);\n        IERC20(curveLpToken).safeApprove(controller.convexBooster(), 0);\n        require(weight == 0, \"pool has weight set\");\n        require(_curvePools.remove(_pool), \"pool not removed\");\n        require(weights.remove(_pool), \"weight not removed\");\n        emit CurvePoolRemoved(_pool);\n    }\n\n    function updateWeights(PoolWeight[] memory poolWeights) external onlyController {\n        require(poolWeights.length == _curvePools.length(), \"invalid pool weights\");\n        uint256 total;\n        for (uint256 i; i < poolWeights.length; i++) {\n            address pool = poolWeights[i].poolAddress;\n            require(isRegisteredCurvePool(pool), \"pool is not registered\");\n            uint256 newWeight = poolWeights[i].weight;\n            weights.set(pool, newWeight);\n            emit NewWeight(pool, newWeight);\n            total += newWeight;\n        }\n\n        require(total == ScaledMath.ONE, \"weights do not sum to 1\");\n\n        (\n            uint256 totalUnderlying_,\n            uint256 totalAllocated,\n            uint256[] memory allocatedPerPool\n        ) = getTotalAndPerPoolUnderlying();\n\n        uint256 totalDeviation = _computeTotalDeviation(totalUnderlying_, allocatedPerPool);\n        totalDeviationAfterWeightUpdate = totalDeviation;\n        rebalancingRewardActive = !_isBalanced(allocatedPerPool, totalAllocated);\n\n        // Updating price cache for all pools\n        // Used for seeing if a pool has depegged\n        _updatePriceCache();\n    }\n\n    function _updatePriceCache() internal {\n        uint256 length_ = _curvePools.length();\n        IOracle priceOracle_ = controller.priceOracle();\n        for (uint256 i; i < length_; i++) {\n            address lpToken_ = controller.curveRegistryCache().lpToken(_curvePools.at(i));\n            _cachedPrices[lpToken_] = priceOracle_.getUSDPrice(lpToken_);\n        }\n        address underlying_ = address(underlying);\n        _cachedPrices[underlying_] = priceOracle_.getUSDPrice(underlying_);\n    }\n\n    function shutdownPool() external override onlyController {\n        require(!isShutdown, \"pool already shutdown\");\n        isShutdown = true;\n        emit Shutdown();\n    }\n\n    function updateDepegThreshold(uint256 newDepegThreshold_) external onlyOwner {\n        require(newDepegThreshold_ >= _MIN_DEPEG_THRESHOLD, \"invalid depeg threshold\");\n        require(newDepegThreshold_ <= _MAX_DEPEG_THRESHOLD, \"invalid depeg threshold\");\n        depegThreshold = newDepegThreshold_;\n        emit DepegThresholdUpdated(newDepegThreshold_);\n    }\n\n    /// @notice Called when an underlying of a Curve Pool has depegged and we want to exit the pool.\n    /// Will check if a coin has depegged, and will revert if not.\n    /// Sets the weight of the Curve Pool to 0, and re-enables TORUS rewards for deposits.\n    /// @dev Cannot be called if the underlying of this pool itself has depegged.\n    /// @param curvePool_ The Curve Pool to handle.\n    function handleDepeggedCurvePool(address curvePool_) external override {\n        // Validation\n        require(isRegisteredCurvePool(curvePool_), \"pool is not registered\");\n        require(weights.get(curvePool_) != 0, \"pool weight already 0\");\n        require(!_isDepegged(address(underlying)), \"underlying is depegged\");\n        address lpToken_ = controller.curveRegistryCache().lpToken(curvePool_);\n        require(_isDepegged(lpToken_), \"pool is not depegged\");\n\n        // Set target curve pool weight to 0\n        // Scale up other weights to compensate\n        _setWeightToZero(curvePool_);\n        rebalancingRewardActive = true;\n\n        emit HandledDepeggedCurvePool(curvePool_);\n    }\n\n    function _setWeightToZero(address curvePool_) internal {\n        uint256 weight_ = weights.get(curvePool_);\n        if (weight_ == 0) return;\n        require(weight_ != ScaledMath.ONE, \"can't remove last pool\");\n        uint256 scaleUp_ = ScaledMath.ONE.divDown(ScaledMath.ONE - weights.get(curvePool_));\n        uint256 curvePoolLength_ = _curvePools.length();\n        for (uint256 i; i < curvePoolLength_; i++) {\n            address pool_ = _curvePools.at(i);\n            uint256 newWeight_ = pool_ == curvePool_ ? 0 : weights.get(pool_).mulDown(scaleUp_);\n            weights.set(pool_, newWeight_);\n            emit NewWeight(pool_, newWeight_);\n        }\n\n        // Updating total deviation\n        (\n            uint256 totalUnderlying_,\n            ,\n            uint256[] memory allocatedPerPool\n        ) = getTotalAndPerPoolUnderlying();\n        uint256 totalDeviation = _computeTotalDeviation(totalUnderlying_, allocatedPerPool);\n        totalDeviationAfterWeightUpdate = totalDeviation;\n    }\n\n    function _isDepegged(address asset_) internal view returns (bool) {\n        uint256 depegThreshold_ = depegThreshold;\n        if (asset_ == address(underlying)) depegThreshold_ *= _DEPEG_UNDERLYING_MULTIPLIER; // Threshold is higher for underlying\n        uint256 cachedPrice_ = _cachedPrices[asset_];\n        uint256 currentPrice_ = controller.priceOracle().getUSDPrice(asset_);\n        uint256 priceDiff_ = cachedPrice_.absSub(currentPrice_);\n        uint256 priceDiffPercent_ = priceDiff_.divDown(cachedPrice_);\n        return priceDiffPercent_ > depegThreshold_;\n    }\n\n    /**\n     * @notice Allows anyone to set the weight of a Curve pool to 0 if the Convex pool for the\n     * associated PID has been shutdown. This is a very unilkely outcomu and the method does\n     * not reenable rebalancing rewards.\n     * @param curvePool_ Curve pool for which the Convex PID is invalid (has been shut down)\n     */\n    function handleInvalidConvexPid(address curvePool_) external {\n        require(isRegisteredCurvePool(curvePool_), \"curve pool not registered\");\n        ICurveRegistryCache registryCache_ = controller.curveRegistryCache();\n        uint256 pid = registryCache_.getPid(curvePool_);\n        require(registryCache_.isShutdownPid(pid), \"convex pool pid is shutdown\");\n        _setWeightToZero(curvePool_);\n        emit HandledInvalidConvexPid(curvePool_, pid);\n    }\n\n    function setMaxIdleCurveLpRatio(uint256 maxIdleCurveLpRatio_) external onlyOwner {\n        require(maxIdleCurveLpRatio != maxIdleCurveLpRatio_, \"same as current\");\n        require(maxIdleCurveLpRatio_ <= _IDLE_RATIO_UPPER_BOUND, \"ratio exceeds upper bound\");\n        maxIdleCurveLpRatio = maxIdleCurveLpRatio_;\n        emit NewMaxIdleCurveLpRatio(maxIdleCurveLpRatio_);\n    }\n\n    function setMaxDeviation(uint256 maxDeviation_) external onlyOwner {\n        require(maxDeviation != maxDeviation_, \"same as current\");\n        require(maxDeviation_ <= _MAX_DEVIATION_UPPER_BOUND, \"deviation exceeds upper bound\");\n        maxDeviation = maxDeviation_;\n        emit MaxDeviationUpdated(maxDeviation_);\n    }\n\n    function setRewardManager(address _rewardManager) external onlyOwner {\n        rewardManager = IRewardManager(_rewardManager);\n\n        CVX.safeApprove(address(_rewardManager), type(uint256).max);\n        CRV.safeApprove(address(_rewardManager), type(uint256).max);\n        TORUS.safeApprove(address(_rewardManager), type(uint256).max);\n    }\n\n    function getWeight(address curvePool) external view returns (uint256) {\n        return weights.get(curvePool);\n    }\n\n    function getWeights() external view override returns (PoolWeight[] memory) {\n        uint256 length_ = _curvePools.length();\n        PoolWeight[] memory weights_ = new PoolWeight[](length_);\n        for (uint256 i; i < length_; i++) {\n            (address pool_, uint256 weight_) = weights.at(i);\n            weights_[i] = PoolWeight(pool_, weight_);\n        }\n        return weights_;\n    }\n\n    function getAllocatedUnderlying() external view override returns (PoolWithAmount[] memory) {\n        PoolWithAmount[] memory perPoolAllocated = new PoolWithAmount[](_curvePools.length());\n        (, , uint256[] memory allocated) = getTotalAndPerPoolUnderlying();\n\n        for (uint256 i; i < perPoolAllocated.length; i++) {\n            perPoolAllocated[i] = PoolWithAmount(_curvePools.at(i), allocated[i]);\n        }\n        return perPoolAllocated;\n    }\n\n    function computeTotalDeviation() external view override returns (uint256) {\n        (\n            ,\n            uint256 allocatedUnderlying_,\n            uint256[] memory perPoolUnderlying\n        ) = getTotalAndPerPoolUnderlying();\n        return _computeTotalDeviation(allocatedUnderlying_, perPoolUnderlying);\n    }\n\n    function computeDeviationRatio() external view returns (uint256) {\n        (\n            ,\n            uint256 allocatedUnderlying_,\n            uint256[] memory perPoolUnderlying\n        ) = getTotalAndPerPoolUnderlying();\n        if (allocatedUnderlying_ == 0) return 0;\n        uint256 deviation = _computeTotalDeviation(allocatedUnderlying_, perPoolUnderlying);\n        return deviation.divDown(allocatedUnderlying_);\n    }\n\n    function cachedTotalUnderlying() external view virtual override returns (uint256) {\n        if (block.timestamp > _cacheUpdatedTimestamp + _TOTAL_UNDERLYING_CACHE_EXPIRY) {\n            return totalUnderlying();\n        }\n        return _cachedTotalUnderlying;\n    }\n\n    function getTotalAndPerPoolUnderlying()\n        public\n        view\n        returns (\n            uint256 totalUnderlying_,\n            uint256 totalAllocated_,\n            uint256[] memory perPoolUnderlying_\n        )\n    {\n        uint256 underlyingPrice_ = controller.priceOracle().getUSDPrice(address(underlying));\n        return _getTotalAndPerPoolUnderlying(underlyingPrice_);\n    }\n\n    function totalCurveLpBalance(address curvePool_) public view returns (uint256) {\n        return _stakedCurveLpBalance(curvePool_) + _idleCurveLpBalance(curvePool_);\n    }\n\n    function isBalanced() external view override returns (bool) {\n        (\n            ,\n            uint256 allocatedUnderlying_,\n            uint256[] memory allocatedPerPool_\n        ) = getTotalAndPerPoolUnderlying();\n        return _isBalanced(allocatedPerPool_, allocatedUnderlying_);\n    }\n\n    /**\n     * @notice Returns several values related to the Omnipools's underlying assets.\n     * @param underlyingPrice_ Price of the underlying asset in USD\n     * @return totalUnderlying_ Total underlying value of the Omnipool\n     * @return totalAllocated_ Total underlying value of the Omnipool that is allocated to Curve pools\n     * @return perPoolUnderlying_ Array of underlying values of the Omnipool that is allocated to each Curve pool\n     */\n    function _getTotalAndPerPoolUnderlying(uint256 underlyingPrice_)\n        internal\n        view\n        returns (\n            uint256 totalUnderlying_,\n            uint256 totalAllocated_,\n            uint256[] memory perPoolUnderlying_\n        )\n    {\n        uint256 curvePoolsLength_ = _curvePools.length();\n        perPoolUnderlying_ = new uint256[](curvePoolsLength_);\n        for (uint256 i; i < curvePoolsLength_; i++) {\n            address curvePool_ = _curvePools.at(i);\n            uint256 poolUnderlying_ = _curveLpToUnderlying(\n                controller.curveRegistryCache().lpToken(curvePool_),\n                totalCurveLpBalance(curvePool_),\n                underlyingPrice_\n            );\n            perPoolUnderlying_[i] = poolUnderlying_;\n            totalAllocated_ += poolUnderlying_;\n        }\n        totalUnderlying_ = totalAllocated_ + underlying.universalBalanceOf(address(this));\n    }\n\n    function _stakedCurveLpBalance(address pool_) internal view returns (uint256) {\n        return\n            IBaseRewardPool(IConvexHandler(controller.convexHandler()).getRewardPool(pool_))\n                .balanceOf(address(this));\n    }\n\n    function _idleCurveLpBalance(address curvePool_) internal view returns (uint256) {\n        return IERC20(controller.curveRegistryCache().lpToken(curvePool_)).balanceOf(address(this));\n    }\n\n    function _curveLpToUnderlying(\n        address curveLpToken_,\n        uint256 curveLpAmount_,\n        uint256 underlyingPrice_\n    ) internal view returns (uint256) {\n        return\n            curveLpAmount_\n                .mulDown(controller.priceOracle().getUSDPrice(curveLpToken_))\n                .divDown(underlyingPrice_)\n                .convertScale(18, underlying.universalDecimals());\n    }\n\n    function _underlyingToCurveLp(address curveLpToken_, uint256 underlyingAmount_)\n        internal\n        view\n        returns (uint256)\n    {\n        return\n            underlyingAmount_\n                .mulDown(controller.priceOracle().getUSDPrice(address(underlying)))\n                .divDown(controller.priceOracle().getUSDPrice(curveLpToken_))\n                .convertScale(underlying.universalDecimals(), 18);\n    }\n\n    function _computeTotalDeviation(\n        uint256 allocatedUnderlying_,\n        uint256[] memory perPoolAllocations_\n    ) internal view returns (uint256) {\n        uint256 totalDeviation;\n        for (uint256 i; i < perPoolAllocations_.length; i ++) {\n            uint256 weight = weights.get(_curvePools.at(i));\n            uint256 targetAmount = allocatedUnderlying_.mulDown(weight);\n            totalDeviation += targetAmount.absSub(perPoolAllocations_[i]);\n        }\n        return totalDeviation;\n    }\n\n    function _handleRebalancingRewards(\n        address account,\n        uint256 allocatedBalanceBefore_,\n        uint256[] memory allocatedPerPoolBefore,\n        uint256 allocatedBalanceAfter_,\n        uint256[] memory allocatedPerPoolAfter\n    ) internal {\n        if (!rebalancingRewardActive) return;\n        uint256 deviationBefore = _computeTotalDeviation(\n            allocatedBalanceBefore_,\n            allocatedPerPoolBefore\n        );\n        uint256 deviationAfter = _computeTotalDeviation(\n            allocatedBalanceAfter_,\n            allocatedPerPoolAfter\n        );\n\n        controller.inflationManager().handleRebalancingRewards(\n            account,\n            deviationBefore,\n            deviationAfter\n        );\n\n        if (_isBalanced(allocatedPerPoolAfter, allocatedBalanceAfter_)) {\n            rebalancingRewardActive = false;\n        }\n    }\n\n    function _min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function _isBalanced(uint256[] memory allocatedPerPool_, uint256 totalAllocated_)\n        internal\n        view\n        returns (bool)\n    {\n        if (totalAllocated_ == 0) return true;\n        for (uint256 i; i < allocatedPerPool_.length; i ++) {\n            uint256 weight_ = weights.get(_curvePools.at(i));\n            uint256 currentAllocated_ = allocatedPerPool_[i];\n\n            // If a curve pool has a weight of 0,\n            if (weight_ == 0) {\n                uint256 price_ = controller.priceOracle().getUSDPrice(address(underlying));\n                uint256 allocatedUsd_ = (price_ * currentAllocated_) / 10**underlying.universalDecimals();\n                if (allocatedUsd_ >= _MAX_USD_LP_VALUE_FOR_REMOVING_CURVE_POOL / 2) {\n                    return false;\n                }\n                continue;\n            }\n\n            uint256 targetAmount = totalAllocated_.mulDown(weight_);\n            uint256 deviation = targetAmount.absSub(currentAllocated_);\n            uint256 deviationRatio = deviation.divDown(targetAmount);\n\n            if (deviationRatio > maxDeviation) return false;\n        }\n        return true;\n    }\n\n    function _getMaxDeviation() internal view returns (uint256) {\n        return rebalancingRewardActive ? 0 : maxDeviation;\n    }\n}\n"

    },

    "node_modules/@openzeppelin/contracts/access/Ownable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"

    },

    "node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"

    },

    "node_modules/@openzeppelin/contracts/utils/Address.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"

    },

    "node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"

    },

    "node_modules/@openzeppelin/contracts/utils/structs/EnumerableMap.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableMap.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableMap.js.\n\npragma solidity ^0.8.0;\n\nimport \"./EnumerableSet.sol\";\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * The following map types are supported:\n *\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32Map`) since v4.6.0\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableMap.\n * ====\n */\nlibrary EnumerableMap {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct Bytes32ToBytes32Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 => bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        Bytes32ToBytes32Map storage map,\n        bytes32 key,\n        bytes32 value\n    ) internal returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || contains(map, key), \"EnumerableMap: nonexistent key\");\n        return value;\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        Bytes32ToBytes32Map storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) internal view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || contains(map, key), errorMessage);\n        return value;\n    }\n\n    // UintToUintMap\n\n    struct UintToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        UintToUintMap storage map,\n        uint256 key,\n        uint256 value\n    ) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (uint256(key), uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(key)));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToUintMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(key), errorMessage));\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        UintToAddressMap storage map,\n        uint256 key,\n        address value\n    ) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToAddressMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, bytes32(key), errorMessage))));\n    }\n\n    // AddressToUintMap\n\n    struct AddressToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        AddressToUintMap storage map,\n        address key,\n        uint256 value\n    ) internal returns (bool) {\n        return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(AddressToUintMap storage map, address key) internal returns (bool) {\n        return remove(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\n        return contains(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(AddressToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (address(uint160(uint256(key))), uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        AddressToUintMap storage map,\n        address key,\n        string memory errorMessage\n    ) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(uint256(uint160(key))), errorMessage));\n    }\n\n    // Bytes32ToUintMap\n\n    struct Bytes32ToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        Bytes32ToUintMap storage map,\n        bytes32 key,\n        uint256 value\n    ) internal returns (bool) {\n        return set(map._inner, key, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\n        return remove(map._inner, key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\n        return contains(map._inner, key);\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (key, uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, key);\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\n        return uint256(get(map._inner, key));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        Bytes32ToUintMap storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) internal view returns (uint256) {\n        return uint256(get(map._inner, key, errorMessage));\n    }\n}\n"

    },

    "node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"

    },

    "node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"

    },

    "node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"

    },

    "interfaces/pools/ITorusPool.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.20;\n\nimport \"./ILpToken.sol\";\nimport \"./IRewardManager.sol\";\nimport \"../IOracle.sol\";\n\ninterface ITorusPool {\n    event Deposit(\n        address indexed sender,\n        address indexed receiver,\n        uint256 depositedAmount,\n        uint256 lpReceived\n    );\n    event Withdraw(address indexed account, uint256 amount);\n    event NewWeight(address indexed curvePool, uint256 newWeight);\n    event NewMaxIdleCurveLpRatio(uint256 newRatio);\n    event ClaimedRewards(uint256 claimedCrv, uint256 claimedCvx);\n    event HandledDepeggedCurvePool(address curvePool_);\n    event HandledInvalidConvexPid(address curvePool_, uint256 pid_);\n    event CurvePoolAdded(address curvePool_);\n    event CurvePoolRemoved(address curvePool_);\n    event Shutdown();\n    event DepegThresholdUpdated(uint256 newThreshold);\n    event MaxDeviationUpdated(uint256 newMaxDeviation);\n\n    struct PoolWeight {\n        address poolAddress;\n        uint256 weight;\n    }\n\n    struct PoolWithAmount {\n        address poolAddress;\n        uint256 amount;\n    }\n\n    function underlying() external view returns (IERC20Metadata);\n\n    function lpToken() external view returns (ILpToken);\n\n    function rewardManager() external view returns (IRewardManager);\n\n    function depositFor(\n        address _account,\n        uint256 _amount,\n        uint256 _minLpReceived,\n        bool stake\n    ) external payable returns (uint256);\n\n    function deposit(uint256 _amount, uint256 _minLpReceived) external payable returns (uint256);\n\n    function deposit(\n        uint256 _amount,\n        uint256 _minLpReceived,\n        bool stake\n    ) external payable returns (uint256);\n\n    function exchangeRate() external view returns (uint256);\n\n    function usdExchangeRate() external view returns (uint256);\n\n    function allCurvePools() external view returns (address[] memory);\n\n    function curvePoolsCount() external view returns (uint256);\n\n    function getCurvePoolAtIndex(uint256 _index) external view returns (address);\n\n    function unstakeAndWithdraw(uint256 _amount, uint256 _minAmount) external returns (uint256);\n\n    function withdraw(uint256 _amount, uint256 _minAmount) external returns (uint256);\n\n    function updateWeights(PoolWeight[] memory poolWeights) external;\n\n    function getWeight(address curvePool) external view returns (uint256);\n\n    function getWeights() external view returns (PoolWeight[] memory);\n\n    function getAllocatedUnderlying() external view returns (PoolWithAmount[] memory);\n\n    function removeCurvePool(address pool) external;\n\n    function addCurvePool(address pool) external;\n\n    function totalCurveLpBalance(address curvePool_) external view returns (uint256);\n\n    function rebalancingRewardActive() external view returns (bool);\n\n    function totalDeviationAfterWeightUpdate() external view returns (uint256);\n\n    function computeTotalDeviation() external view returns (uint256);\n\n    /// @notice returns the total amount of funds held by this pool in terms of underlying\n    function totalUnderlying() external view returns (uint256);\n\n    function getTotalAndPerPoolUnderlying()\n        external\n        view\n        returns (\n            uint256 totalUnderlying_,\n            uint256 totalAllocated_,\n            uint256[] memory perPoolUnderlying_\n        );\n\n    /// @notice same as `totalUnderlying` but returns a cached version\n    /// that might be slightly outdated if oracle prices have changed\n    /// @dev this is useful in cases where we want to reduce gas usage and do\n    /// not need a precise value\n    function cachedTotalUnderlying() external view returns (uint256);\n\n    function handleInvalidConvexPid(address pool) external;\n\n    function shutdownPool() external;\n\n    function isShutdown() external view returns (bool);\n\n    function handleDepeggedCurvePool(address curvePool_) external;\n\n    function isBalanced() external view returns (bool);\n}\n"

    },

    "interfaces/pools/IRewardManager.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.20;\n\ninterface IRewardManager {\n    event ClaimedRewards(uint256 claimedCrv, uint256 claimedCvx);\n    event SoldRewardTokens(uint256 targetTokenReceived);\n    event ExtraRewardAdded(address reward);\n    event ExtraRewardRemoved(address reward);\n    event ExtraRewardsCurvePoolSet(address extraReward, address curvePool);\n    event FeesSet(uint256 feePercentage);\n    event FeesEnabled(uint256 feePercentage);\n    event EarningsClaimed(\n        address indexed claimedBy,\n        uint256 torusEarned,\n        uint256 crvEarned,\n        uint256 cvxEarned\n    );\n\n    struct RewardMeta {\n        uint256 earnedIntegral;\n        uint256 lastEarned;\n        mapping(address => uint256) accountIntegral;\n        mapping(address => uint256) accountShare;\n    }\n\n    function accountCheckpoint(address account) external;\n\n    function poolCheckpoint() external returns (bool);\n\n    function addExtraReward(address reward) external returns (bool);\n\n    function addBatchExtraRewards(address[] memory rewards) external;\n\n    function pool() external view returns (address);\n\n    function setFeePercentage(uint256 _feePercentage) external;\n\n    function claimableRewards(address account)\n        external\n        view\n        returns (\n            uint256 torusRewards,\n            uint256 crvRewards,\n            uint256 cvxRewards\n        );\n\n    function claimEarnings()\n        external\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function claimPoolEarningsAndSellRewardTokens() external;\n}\n"

    },

    "interfaces/ICurveHandler.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.20;\n\ninterface ICurveHandler {\n    function deposit(\n        address _curvePool,\n        address _token,\n        uint256 _amount\n    ) external;\n\n    function withdraw(\n        address _curvePool,\n        address _token,\n        uint256 _amount\n    ) external;\n}\n"

    },

    "interfaces/ICurveRegistryCache.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.20;\n\nimport \"./vendor/IBooster.sol\";\nimport \"../libraries/CurvePoolUtils.sol\";\n\ninterface ICurveRegistryCache {\n    function BOOSTER() external view returns (IBooster);\n\n    function initPool(address pool_) external;\n\n    function initPool(address pool_, uint256 pid_) external;\n\n    function lpToken(address pool_) external view returns (address);\n\n    function assetType(address pool_) external view returns (CurvePoolUtils.AssetType);\n\n    function isRegistered(address pool_) external view returns (bool);\n\n    function hasCoinDirectly(address pool_, address coin_) external view returns (bool);\n\n    function hasCoinAnywhere(address pool_, address coin_) external view returns (bool);\n\n    function basePool(address pool_) external view returns (address);\n\n    function coinIndex(address pool_, address coin_) external view returns (int128);\n\n    function nCoins(address pool_) external view returns (uint256);\n\n    function coinIndices(\n        address pool_,\n        address from_,\n        address to_\n    )\n        external\n        view\n        returns (\n            int128,\n            int128,\n            bool\n        );\n\n    function decimals(address pool_) external view returns (uint256[] memory);\n\n    function interfaceVersion(address pool_) external view returns (uint256);\n\n    function poolFromLpToken(address lpToken_) external view returns (address);\n\n    function coins(address pool_) external view returns (address[] memory);\n\n    function getPid(address _pool) external view returns (uint256);\n\n    function getRewardPool(address _pool) external view returns (address);\n\n    function isShutdownPid(uint256 pid_) external view returns (bool);\n}\n"

    },

    "interfaces/tokenomics/IInflationManager.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.20;\n\ninterface IInflationManager {\n    event TokensClaimed(address indexed pool, uint256 torusAmount);\n    event RebalancingRewardHandlerAdded(address indexed pool, address indexed handler);\n    event RebalancingRewardHandlerRemoved(address indexed pool, address indexed handler);\n    event PoolWeightsUpdated();\n\n    function executeInflationRateUpdate() external;\n\n    function updatePoolWeights() external;\n\n    /// @notice returns the weights of the Torus pools to know how much inflation\n    /// each of them will receive, as well as the total amount of USD value in all the pools\n    function computePoolWeights()\n        external\n        view\n        returns (\n            address[] memory _pools,\n            uint256[] memory poolWeights,\n            uint256 totalUSDValue\n        );\n\n    function computePoolWeight(address pool)\n        external\n        view\n        returns (uint256 poolWeight, uint256 totalUSDValue);\n\n    function currentInflationRate() external view returns (uint256);\n\n    function getCurrentPoolInflationRate(address pool) external view returns (uint256);\n\n    function handleRebalancingRewards(\n        address account,\n        uint256 deviationBefore,\n        uint256 deviationAfter\n    ) external;\n\n    function addPoolRebalancingRewardHandler(address poolAddress, address rebalancingRewardHandler)\n        external;\n\n    function removePoolRebalancingRewardHandler(\n        address poolAddress,\n        address rebalancingRewardHandler\n    ) external;\n\n    function rebalancingRewardHandlers(address poolAddress)\n        external\n        view\n        returns (address[] memory);\n\n    function hasPoolRebalancingRewardHandlers(address poolAddress, address handler)\n        external\n        view\n        returns (bool);\n}\n"

    },

    "interfaces/tokenomics/ILpTokenStaker.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.20;\n\ninterface ILpTokenStaker {\n    event LpTokenStaked(address indexed account, uint256 amount);\n    event LpTokenUnstaked(address indexed account, uint256 amount);\n    event TokensClaimed(address indexed pool, uint256 torusAmount);\n    event Shutdown();\n\n    function stake(uint256 amount, address torusPool) external;\n\n    function unstake(uint256 amount, address torusPool) external;\n\n    function stakeFor(\n        uint256 amount,\n        address torusPool,\n        address account\n    ) external;\n\n    function unstakeFor(\n        uint256 amount,\n        address torusPool,\n        address account\n    ) external;\n\n    function unstakeFrom(uint256 amount, address account) external;\n\n    function getUserBalanceForPool(address torusPool, address account)\n        external\n        view\n        returns (uint256);\n\n    function getBalanceForPool(address torusPool) external view returns (uint256);\n\n    function updateBoost(address user) external;\n\n    function claimTORUSRewardsForPool(address pool) external;\n\n    function claimableTorus(address pool) external view returns (uint256);\n\n    function checkpoint(address pool) external returns (uint256);\n\n    function shutdown() external;\n\n    function getBoost(address user) external view returns (uint256);\n}\n"

    },

    "interfaces/IConvexHandler.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.20;\n\ninterface IConvexHandler {\n    function deposit(address _curvePool, uint256 _amount) external;\n\n    function claimBatchEarnings(address[] memory _curvePools, address _torusPool) external;\n\n    function getRewardPool(address _curvePool) external view returns (address);\n\n    function getCrvEarned(address _account, address _curvePool) external view returns (uint256);\n\n    function getCrvEarnedBatch(address _account, address[] memory _curvePools)\n        external\n        view\n        returns (uint256);\n\n    function computeClaimableConvex(uint256 crvAmount) external view returns (uint256);\n}\n"

    },

    "interfaces/IController.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.20;\n\nimport \"./pools/ITorusPool.sol\";\nimport \"./IOracle.sol\";\nimport \"./tokenomics/IInflationManager.sol\";\nimport \"./tokenomics/ILpTokenStaker.sol\";\nimport \"./ICurveRegistryCache.sol\";\n\ninterface IController {\n    event PoolAdded(address indexed pool);\n    event PoolRemoved(address indexed pool);\n    event PoolShutdown(address indexed pool);\n    event ConvexBoosterSet(address convexBooster);\n    event CurveHandlerSet(address curveHandler);\n    event ConvexHandlerSet(address convexHandler);\n    event CurveRegistryCacheSet(address curveRegistryCache);\n    event InflationManagerSet(address inflationManager);\n    event PriceOracleSet(address priceOracle);\n    event WeightUpdateMinDelaySet(uint256 weightUpdateMinDelay);\n\n    struct WeightUpdate {\n        address torusPoolAddress;\n        ITorusPool.PoolWeight[] weights;\n    }\n\n    // inflation manager\n\n    function inflationManager() external view returns (IInflationManager);\n\n    function setInflationManager(address manager) external;\n\n    // views\n    function curveRegistryCache() external view returns (ICurveRegistryCache);\n\n    /// lp token staker\n    function setLpTokenStaker(address _lpTokenStaker) external;\n\n    function lpTokenStaker() external view returns (ILpTokenStaker);\n\n    // oracle\n    function priceOracle() external view returns (IOracle);\n\n    function setPriceOracle(address oracle) external;\n\n    // pool functions\n\n    function listPools() external view returns (address[] memory);\n\n    function listActivePools() external view returns (address[] memory);\n\n    function isPool(address poolAddress) external view returns (bool);\n\n    function isActivePool(address poolAddress) external view returns (bool);\n\n    function addPool(address poolAddress) external;\n\n    function shutdownPool(address poolAddress) external;\n\n    function removePool(address poolAddress) external;\n\n    function torusToken() external view returns (address);\n\n    function lastWeightUpdate(address poolAddress) external view returns (uint256);\n\n    function updateWeights(WeightUpdate memory update) external;\n\n    function updateAllWeights(WeightUpdate[] memory weights) external;\n\n    // handler functions\n\n    function convexBooster() external view returns (address);\n\n    function curveHandler() external view returns (address);\n\n    function convexHandler() external view returns (address);\n\n    function setConvexBooster(address _convexBooster) external;\n\n    function setCurveHandler(address _curveHandler) external;\n\n    function setConvexHandler(address _convexHandler) external;\n\n    function setCurveRegistryCache(address curveRegistryCache_) external;\n\n    function emergencyMinter() external view returns (address);\n\n    function setWeightUpdateMinDelay(uint256 delay) external;\n}\n"

    },

    "interfaces/IOracle.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.20;\n\ninterface IOracle {\n    event TokenUpdated(address indexed token, address feed, uint256 maxDelay, bool isEthPrice);\n\n    /// @notice returns the price in USD of symbol.\n    function getUSDPrice(address token) external view returns (uint256);\n\n    /// @notice returns if the given token is supported for pricing.\n    function isTokenSupported(address token) external view returns (bool);\n}\n"

    },

    "interfaces/vendor/IBaseRewardPool.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\ninterface IBaseRewardPool {\n    function stakeFor(address, uint256) external;\n\n    function stake(uint256) external;\n\n    function stakeAll() external returns (bool);\n\n    function withdraw(uint256 amount, bool claim) external returns (bool);\n\n    function withdrawAndUnwrap(uint256 amount, bool claim) external returns (bool);\n\n    function earned(address account) external view returns (uint256);\n\n    function getReward() external;\n\n    function getReward(address _account, bool _claimExtras) external;\n\n    function extraRewardsLength() external view returns (uint256);\n\n    function extraRewards(uint256 _pid) external view returns (address);\n\n    function rewardToken() external view returns (address);\n\n    function balanceOf(address account) external view returns (uint256);\n}\n"

    },

    "contracts/LpToken.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../interfaces/pools/ILpToken.sol\";\nimport \"../interfaces/pools/ITorusPool.sol\";\n\ncontract LpToken is ILpToken, ERC20 {\n    address public immutable minter;\n    modifier onlyMinter() {\n        require(msg.sender == minter, \"not authorized\");\n        _;\n    }\n\n    uint8 private __decimals;\n\n    constructor(\n        address _minter,\n        uint8 _decimals,\n        string memory name,\n        string memory symbol\n    ) ERC20(name, symbol) {\n        minter = _minter;\n        __decimals = _decimals;\n    }\n\n    function decimals() public view virtual override(ERC20, IERC20Metadata) returns (uint8) {\n        return __decimals;\n    }\n\n    function mint(address _account, uint256 _amount)\n        external\n        override\n        onlyMinter\n        returns (uint256)\n    {\n        _mint(_account, _amount);\n        return _amount;\n    }\n\n    function burn(address _owner, uint256 _amount) external override onlyMinter returns (uint256) {\n        _burn(_owner, _amount);\n        return _amount;\n    }\n}\n"

    },

    "contracts/RewardManager.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"../interfaces/pools/ITorusPool.sol\";\nimport \"../interfaces/pools/ILpToken.sol\";\nimport \"../interfaces/pools/IRewardManager.sol\";\nimport \"../interfaces/IConvexHandler.sol\";\nimport \"../interfaces/ICurveHandler.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../interfaces/IOracle.sol\";\nimport \"../interfaces/tokenomics/IInflationManager.sol\";\nimport \"../interfaces/tokenomics/ILpTokenStaker.sol\";\nimport \"../interfaces/tokenomics/ITORUSLockerV2.sol\";\nimport \"../interfaces/vendor/ICurvePoolV2.sol\";\nimport \"../interfaces/vendor/UniswapRouter02.sol\";\n\nimport \"../libraries/ScaledMath.sol\";\nimport \"forge-std/console.sol\";\n\ncontract RewardManager is IRewardManager, Ownable {\n    using ScaledMath for uint256;\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    IERC20 public constant CVX = IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);\n    IERC20 public constant CRV = IERC20(0xD533a949740bb3306d119CC777fa900bA034cd52);\n    IERC20 public constant WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    IERC20 public immutable TORUS;\n    UniswapRouter02 public constant SUSHISWAP =\n        UniswapRouter02(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);\n    ICurvePoolV2 public TORUS_ETH_POOL;\n\n    uint256 public constant MAX_FEE_PERCENTAGE = 3e17;\n    uint256 public constant SLIPPAGE_THRESHOLD = 0.95e18; // 5% slippage as a multiplier\n\n    bytes32 internal constant _TORUS_KEY = \"torus\";\n    bytes32 internal constant _CRV_KEY = \"crv\";\n    bytes32 internal constant _CVX_KEY = \"cvx\";\n\n    address public immutable override pool;\n    ILpToken public immutable lpToken;\n    IERC20 public immutable underlying;\n    IController public immutable controller;\n    ITORUSLockerV2 public immutable locker;\n\n    uint256 internal _oldCrvBalance;\n    uint256 internal _oldCvxBalance;\n\n    EnumerableSet.AddressSet internal _extraRewards;\n    mapping(address => address) public extraRewardsCurvePool;\n    mapping(bytes32 => RewardMeta) internal _rewardsMeta;\n\n    bool public feesEnabled;\n    uint256 public feePercentage;\n\n    constructor(\n        address _controller,\n        address _pool,\n        address _lpToken,\n        address _underlying,\n        address torusLocker\n    ) {\n        TORUS = IERC20(IController(_controller).torusToken());\n        pool = _pool;\n        lpToken = ILpToken(_lpToken);\n        underlying = IERC20(_underlying);\n        controller = IController(_controller);\n        locker = ITORUSLockerV2(torusLocker);\n    }\n\n    /// @notice Updates the internal fee accounting state. Returns `true` if rewards were claimed\n    function poolCheckpoint() public override returns (bool) {\n        IConvexHandler convexHandler = IConvexHandler(controller.convexHandler());\n\n        (uint256 crvEarned, uint256 cvxEarned, uint256 torusEarned) = _getEarnedRewards(\n            convexHandler\n        );\n\n        uint256 crvFee;\n        uint256 cvxFee;\n\n        if (feesEnabled) {\n            crvFee = crvEarned.mulDown(feePercentage);\n            cvxFee = cvxEarned.mulDown(feePercentage);\n            crvEarned = crvEarned - crvFee;\n            cvxEarned = cvxEarned - cvxFee;\n        }\n\n        uint256 _totalStaked = controller.lpTokenStaker().getBalanceForPool(pool);\n        if (_totalStaked > 0) {\n            _updateEarned(_CVX_KEY, cvxEarned, _totalStaked);\n            _updateEarned(_CRV_KEY, crvEarned, _totalStaked);\n            _updateEarned(_TORUS_KEY, torusEarned, _totalStaked);\n        }\n\n        if (!feesEnabled) {\n            return false;\n        }\n\n        bool rewardsClaimed = false;\n\n        if (crvFee > CRV.balanceOf(pool) || cvxFee > CVX.balanceOf(pool)) {\n            _claimPoolEarningsAndSellRewardTokens();\n            rewardsClaimed = true;\n        }\n\n        CRV.safeTransferFrom(pool, address(this), crvFee);\n        CVX.safeTransferFrom(pool, address(this), cvxFee);\n\n        // Fee transfer to the TORUS locker\n        CRV.safeApprove(address(locker), crvFee);\n        CVX.safeApprove(address(locker), cvxFee);\n        locker.receiveFees(crvFee, cvxFee);\n\n        _oldCrvBalance = CRV.balanceOf(pool);\n        _oldCvxBalance = CVX.balanceOf(pool);\n\n        return rewardsClaimed;\n    }\n\n    function _updateEarned(\n        bytes32 key,\n        uint256 earned,\n        uint256 _totalSupply\n    ) internal {\n        _rewardsMeta[key].earnedIntegral += earned.divDown(_totalSupply);\n        _rewardsMeta[key].lastEarned += earned;\n    }\n\n    function _getEarnedRewards()\n        internal\n        view\n        returns (\n            uint256 crvEarned,\n            uint256 cvxEarned,\n            uint256 torusEarned\n        )\n    {\n        IConvexHandler convexHandler = IConvexHandler(controller.convexHandler());\n        return _getEarnedRewards(convexHandler);\n    }\n\n    function _getEarnedRewards(IConvexHandler convexHandler)\n        internal\n        view\n        returns (\n            uint256 crvEarned,\n            uint256 cvxEarned,\n            uint256 torusEarned\n        )\n    {\n        address[] memory curvePools = ITorusPool(pool).allCurvePools();\n\n        uint256 claimableCRV = convexHandler.getCrvEarnedBatch(pool, curvePools);\n        uint256 totalCRVEarned = CRV.balanceOf(pool) - _oldCrvBalance + claimableCRV;\n\n        uint256 claimableCVX = convexHandler.computeClaimableConvex(claimableCRV);\n        uint256 totalCVXEarned = CVX.balanceOf(pool) - _oldCvxBalance + claimableCVX;\n        uint256 totalTORUSEarned = controller.lpTokenStaker().claimableTorus(pool);\n\n        if (totalCRVEarned > _rewardsMeta[_CRV_KEY].lastEarned) {\n            crvEarned = totalCRVEarned - _rewardsMeta[_CRV_KEY].lastEarned;\n        }\n        if (totalCVXEarned > _rewardsMeta[_CVX_KEY].lastEarned) {\n            cvxEarned = totalCVXEarned - _rewardsMeta[_CVX_KEY].lastEarned;\n        }\n        if (totalTORUSEarned > _rewardsMeta[_TORUS_KEY].lastEarned) {\n            torusEarned = totalTORUSEarned - _rewardsMeta[_TORUS_KEY].lastEarned;\n        }\n    }\n\n    function accountCheckpoint(address account) external {\n        _accountCheckpoint(account);\n    }\n\n    function _accountCheckpoint(address account) internal {\n        uint256 accountBalance = controller.lpTokenStaker().getUserBalanceForPool(pool, account);\n        poolCheckpoint();\n        _updateAccountRewardsMeta(_TORUS_KEY, account, accountBalance);\n        _updateAccountRewardsMeta(_CRV_KEY, account, accountBalance);\n        _updateAccountRewardsMeta(_CVX_KEY, account, accountBalance);\n    }\n\n    function _updateAccountRewardsMeta(\n        bytes32 key,\n        address account,\n        uint256 balance\n    ) internal {\n        RewardMeta storage meta = _rewardsMeta[key];\n        uint256 share = balance.mulDown(meta.earnedIntegral - meta.accountIntegral[account]);\n        meta.accountShare[account] += share;\n        meta.accountIntegral[account] = meta.earnedIntegral;\n    }\n\n    /// @notice Claims all CRV, CVX and TORUS earned by a user. All extra reward\n    /// tokens earned will be sold for Torus.\n    /// @dev Torus pool LP tokens need to be staked in the `LpTokenStaker` in\n    /// order to receive a share of the CRV, CVX and TORUS earnings.\n    /// after selling all extra reward tokens.\n    function claimEarnings()\n        public\n        override\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        _accountCheckpoint(msg.sender);\n        uint256 crvAmount = _rewardsMeta[_CRV_KEY].accountShare[msg.sender];\n        uint256 cvxAmount = _rewardsMeta[_CVX_KEY].accountShare[msg.sender];\n        uint256 torusAmount = _rewardsMeta[_TORUS_KEY].accountShare[msg.sender];\n\n        if (\n            crvAmount > CRV.balanceOf(pool) ||\n            cvxAmount > CVX.balanceOf(pool) ||\n            torusAmount > TORUS.balanceOf(pool)\n        ) {\n            _claimPoolEarningsAndSellRewardTokens();\n        }\n        _rewardsMeta[_TORUS_KEY].accountShare[msg.sender] = 0;\n        _rewardsMeta[_CVX_KEY].accountShare[msg.sender] = 0;\n        _rewardsMeta[_CRV_KEY].accountShare[msg.sender] = 0;\n\n        CRV.safeTransferFrom(pool, msg.sender, crvAmount);\n        CVX.safeTransferFrom(pool, msg.sender, cvxAmount);\n        TORUS.safeTransferFrom(pool, msg.sender, torusAmount);\n\n        _oldCrvBalance = CRV.balanceOf(pool);\n        _oldCvxBalance = CVX.balanceOf(pool);\n\n        emit EarningsClaimed(msg.sender, torusAmount, crvAmount, cvxAmount);\n        return (torusAmount, crvAmount, cvxAmount);\n    }\n\n    /// @notice Claims all claimable CVX and CRV from Convex for all staked Curve LP tokens.\n    /// Then Swaps all additional rewards tokens for TORUS.\n    function claimPoolEarningsAndSellRewardTokens() external override {\n        if (!poolCheckpoint()) {\n            _claimPoolEarningsAndSellRewardTokens();\n            _oldCrvBalance = CRV.balanceOf(pool);\n            _oldCvxBalance = CVX.balanceOf(pool);\n        }\n    }\n\n    function _claimPoolEarningsAndSellRewardTokens() internal {\n        _rewardsMeta[_CRV_KEY].lastEarned = 0;\n        _rewardsMeta[_CVX_KEY].lastEarned = 0;\n        _rewardsMeta[_TORUS_KEY].lastEarned = 0;\n\n        _claimPoolEarnings();\n\n        uint256 torusBalanceBefore_ = TORUS.balanceOf(pool);\n\n        _sellRewardTokens();\n\n        uint256 receivedTorus_ = TORUS.balanceOf(pool) - torusBalanceBefore_;\n        uint256 _totalStaked = controller.lpTokenStaker().getBalanceForPool(pool);\n        if (_totalStaked > 0)\n            _rewardsMeta[_TORUS_KEY].earnedIntegral += receivedTorus_.divDown(_totalStaked);\n        emit SoldRewardTokens(receivedTorus_);\n    }\n\n    /// @notice Claims all claimable CVX and CRV from Convex for all staked Curve LP tokens\n    function _claimPoolEarnings() internal {\n        controller.lpTokenStaker().claimTORUSRewardsForPool(pool);\n\n        uint256 cvxBalance = CVX.balanceOf(pool);\n        uint256 crvBalance = CRV.balanceOf(pool);\n\n        address convexHandler = controller.convexHandler();\n\n        IConvexHandler(convexHandler).claimBatchEarnings(ITorusPool(pool).allCurvePools(), pool);\n\n        uint256 claimedCvx = CVX.balanceOf(pool) - cvxBalance;\n        uint256 claimedCrv = CRV.balanceOf(pool) - crvBalance;\n\n        emit ClaimedRewards(claimedCrv, claimedCvx);\n    }\n\n    /// @notice Swaps all additional rewards tokens for TORUS.\n    function _sellRewardTokens() internal {\n        uint256 extraRewardsLength_ = _extraRewards.length();\n        if (extraRewardsLength_ == 0) return;\n        for (uint256 i; i < extraRewardsLength_; i++) {\n            _swapRewardTokenForWeth(_extraRewards.at(i));\n        }\n        _swapWethForTORUS();\n    }\n\n    function listExtraRewards() external view returns (address[] memory) {\n        return _extraRewards.values();\n    }\n\n    function addExtraReward(address reward) public override onlyOwner returns (bool) {\n        require(reward != address(0), \"invalid address\");\n        require(\n            reward != address(CVX) &&\n                reward != address(CRV) &&\n                reward != address(underlying) &&\n                reward != address(TORUS),\n            \"token not allowed\"\n        );\n\n        // Checking reward token isn't a Curve Pool LP Token\n        address[] memory curvePools_ = ITorusPool(pool).allCurvePools();\n        for (uint256 i; i < curvePools_.length;) {\n            address curveLpToken_ = controller.curveRegistryCache().lpToken(curvePools_[i]);\n            require(reward != curveLpToken_, \"token not allowed\");\n\n            unchecked {\n                i ++;\n            }\n        }\n\n        IERC20(reward).safeApprove(address(SUSHISWAP), 0);\n        IERC20(reward).safeApprove(address(SUSHISWAP), type(uint256).max);\n        emit ExtraRewardAdded(reward);\n        return _extraRewards.add(reward);\n    }\n\n    function addBatchExtraRewards(address[] memory _rewards) external override onlyOwner {\n        for (uint256 i; i < _rewards.length;) {\n            addExtraReward(_rewards[i]);\n\n            unchecked {\n                i ++;\n            }\n        }\n    }\n\n    function removeExtraReward(address tokenAddress) external onlyOwner {\n        _extraRewards.remove(tokenAddress);\n        emit ExtraRewardRemoved(tokenAddress);\n    }\n\n    function setExtraRewardsCurvePool(address extraReward_, address curvePool_) external onlyOwner {\n        require(curvePool_ != extraRewardsCurvePool[extraReward_], \"must be different to current\");\n        if (curvePool_ != address(0)) {\n            IERC20(extraReward_).safeApprove(curvePool_, 0);\n            IERC20(extraReward_).safeApprove(curvePool_, type(uint256).max);\n        }\n        extraRewardsCurvePool[extraReward_] = curvePool_;\n        emit ExtraRewardsCurvePoolSet(extraReward_, curvePool_);\n    }\n\n    function setFeePercentage(uint256 _feePercentage) external override onlyOwner {\n        require(_feePercentage < MAX_FEE_PERCENTAGE, \"cannot set fee percentage to more than 30%\");\n        require(locker.totalBoosted() > 0);\n        feePercentage = _feePercentage;\n        feesEnabled = true;\n        emit FeesSet(feePercentage);\n    }\n\n    function setTorusETHPool(address _pool) external onlyOwner {\n        TORUS_ETH_POOL = ICurvePoolV2(_pool);\n        WETH.safeApprove(address(TORUS_ETH_POOL), type(uint256).max);\n    }\n\n    function claimableRewards(address account)\n        external\n        view\n        returns (\n            uint256 torusRewards,\n            uint256 crvRewards,\n            uint256 cvxRewards\n        )\n    {\n        uint256 _totalStaked = controller.lpTokenStaker().getBalanceForPool(pool);\n        if (_totalStaked == 0) return (0, 0, 0);\n        (uint256 crvEarned, uint256 cvxEarned, uint256 torusEarned) = _getEarnedRewards();\n        uint256 userBalance = controller.lpTokenStaker().getUserBalanceForPool(pool, account);\n        torusRewards = _getClaimableReward(\n            account,\n            _TORUS_KEY,\n            torusEarned,\n            userBalance,\n            _totalStaked,\n            false\n        );\n        crvRewards = _getClaimableReward(\n            account,\n            _CRV_KEY,\n            crvEarned,\n            userBalance,\n            _totalStaked,\n            feesEnabled\n        );\n        cvxRewards = _getClaimableReward(\n            account,\n            _CVX_KEY,\n            cvxEarned,\n            userBalance,\n            _totalStaked,\n            feesEnabled\n        );\n    }\n\n    function _getClaimableReward(\n        address account,\n        bytes32 key,\n        uint256 earned,\n        uint256 userBalance,\n        uint256 _totalSupply,\n        bool deductFee\n    ) internal view returns (uint256) {\n        RewardMeta storage meta = _rewardsMeta[key];\n        uint256 integral = meta.earnedIntegral;\n        if (deductFee) {\n            integral += earned.divDown(_totalSupply).mulDown(ScaledMath.ONE - feePercentage);\n        } else {\n            integral += earned.divDown(_totalSupply);\n        }\n        return\n            meta.accountShare[account] +\n            userBalance.mulDown(integral - meta.accountIntegral[account]);\n    }\n\n    function _swapRewardTokenForWeth(address rewardToken_) internal {\n        uint256 tokenBalance_ = IERC20(rewardToken_).balanceOf(address(this));\n        if (tokenBalance_ == 0) return;\n\n        ICurvePoolV2 curvePool_ = ICurvePoolV2(extraRewardsCurvePool[rewardToken_]);\n        if (address(curvePool_) != address(0)) {\n            (int128 i, int128 j, ) = controller.curveRegistryCache().coinIndices(\n                address(curvePool_),\n                rewardToken_,\n                address(WETH)\n            );\n            (uint256 from_, uint256 to_) = (uint256(uint128(i)), uint256(uint128(j)));\n            curvePool_.exchange(\n                from_,\n                to_,\n                tokenBalance_,\n                _minAmountOut(address(rewardToken_), address(WETH), tokenBalance_),\n                false,\n                address(this)\n            );\n            return;\n        }\n\n        address[] memory path_ = new address[](2);\n        path_[0] = rewardToken_;\n        path_[1] = address(WETH);\n        SUSHISWAP.swapExactTokensForTokens(\n            tokenBalance_,\n            _minAmountOut(address(rewardToken_), address(WETH), tokenBalance_),\n            path_,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function _swapWethForTORUS() internal {\n        uint256 wethBalance_ = WETH.balanceOf(address(this));\n        if (wethBalance_ == 0) return;\n        TORUS_ETH_POOL.exchange(\n            0,\n            1,\n            wethBalance_,\n            _minAmountOut(address(WETH), address(TORUS), wethBalance_),\n            false,\n            pool\n        );\n    }\n\n    function _minAmountOut(\n        address tokenIn_,\n        address tokenOut_,\n        uint256 amountIn_\n    ) internal view returns (uint256) {\n        IOracle oracle_ = controller.priceOracle();\n\n        if (tokenIn_ == tokenOut_) {\n            return amountIn_;\n        }\n\n        // If we don't have a price for either token, we can't calculate the min amount out\n        // This should only ever happen for very minor tokens, so we accept the risk of not having\n        // slippage protection in that case\n        if (!oracle_.isTokenSupported(tokenIn_) || !oracle_.isTokenSupported(tokenOut_)) {\n            return 0;\n        }\n\n        return\n            amountIn_\n                .mulDown(oracle_.getUSDPrice(tokenIn_))\n                .divDown(oracle_.getUSDPrice(tokenOut_))\n                .convertScale(\n                    IERC20Metadata(tokenIn_).decimals(),\n                    IERC20Metadata(tokenOut_).decimals()\n                )\n                .mulDown(SLIPPAGE_THRESHOLD);\n    }\n}\n"

    },

    "libraries/ScaledMath.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.20;\n\nlibrary ScaledMath {\n    uint256 internal constant DECIMALS = 18;\n    uint256 internal constant ONE = 10**DECIMALS;\n\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a * b) / ONE;\n    }\n\n    function mulDown(\n        uint256 a,\n        uint256 b,\n        uint256 decimals\n    ) internal pure returns (uint256) {\n        return (a * b) / (10**decimals);\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a * ONE) / b;\n    }\n\n    function divDown(\n        uint256 a,\n        uint256 b,\n        uint256 decimals\n    ) internal pure returns (uint256) {\n        return (a * 10**decimals) / b;\n    }\n\n    function divUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        return ((a * ONE) - 1) / b + 1;\n    }\n\n    function mulDown(int256 a, int256 b) internal pure returns (int256) {\n        return (a * b) / int256(ONE);\n    }\n\n    function mulDownUint128(uint128 a, uint128 b) internal pure returns (uint128) {\n        return (a * b) / uint128(ONE);\n    }\n\n    function mulDown(\n        int256 a,\n        int256 b,\n        uint256 decimals\n    ) internal pure returns (int256) {\n        return (a * b) / int256(10**decimals);\n    }\n\n    function divDown(int256 a, int256 b) internal pure returns (int256) {\n        return (a * int256(ONE)) / b;\n    }\n\n    function divDownUint128(uint128 a, uint128 b) internal pure returns (uint128) {\n        return (a * uint128(ONE)) / b;\n    }\n\n    function divDown(\n        int256 a,\n        int256 b,\n        uint256 decimals\n    ) internal pure returns (int256) {\n        return (a * int256(10**decimals)) / b;\n    }\n\n    function convertScale(\n        uint256 a,\n        uint8 fromDecimals,\n        uint8 toDecimals\n    ) internal pure returns (uint256) {\n        if (fromDecimals == toDecimals) return a;\n        if (fromDecimals > toDecimals) return downscale(a, fromDecimals, toDecimals);\n        return upscale(a, fromDecimals, toDecimals);\n    }\n\n    function convertScale(\n        int256 a,\n        uint8 fromDecimals,\n        uint8 toDecimals\n    ) internal pure returns (int256) {\n        if (fromDecimals == toDecimals) return a;\n        if (fromDecimals > toDecimals) return downscale(a, fromDecimals, toDecimals);\n        return upscale(a, fromDecimals, toDecimals);\n    }\n\n    function upscale(\n        uint256 a,\n        uint8 fromDecimals,\n        uint8 toDecimals\n    ) internal pure returns (uint256) {\n        return a * (10**(toDecimals - fromDecimals));\n    }\n\n    function downscale(\n        uint256 a,\n        uint8 fromDecimals,\n        uint8 toDecimals\n    ) internal pure returns (uint256) {\n        return a / (10**(fromDecimals - toDecimals));\n    }\n\n    function upscale(\n        int256 a,\n        uint8 fromDecimals,\n        uint8 toDecimals\n    ) internal pure returns (int256) {\n        return a * int256(10**(toDecimals - fromDecimals));\n    }\n\n    function downscale(\n        int256 a,\n        uint8 fromDecimals,\n        uint8 toDecimals\n    ) internal pure returns (int256) {\n        return a / int256(10**(fromDecimals - toDecimals));\n    }\n\n    function intPow(uint256 a, uint256 n) internal pure returns (uint256) {\n        uint256 result = ONE;\n        for (uint256 i; i < n; ) {\n            result = mulDown(result, a);\n            unchecked {\n                ++i;\n            }\n        }\n        return result;\n    }\n\n    function absSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            return a >= b ? a - b : b - a;\n        }\n    }\n}\n"

    },

    "libraries/ArrayExtensions.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.20;\n\nlibrary ArrayExtensions {\n    function copy(uint256[] memory array) internal pure returns (uint256[] memory) {\n        uint256[] memory copy_ = new uint256[](array.length);\n        for (uint256 i = 0; i < array.length; i++) {\n            copy_[i] = array[i];\n        }\n        return copy_;\n    }\n}\n"

    },

    "libraries/UniversalERC20.sol": {

      "content": "pragma solidity 0.8.20;\n\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n\nlibrary UniversalERC20 {\n\n    using SafeERC20 for IERC20;\n\n    IERC20 private constant ZERO_ADDRESS = IERC20(0x0000000000000000000000000000000000000000);\n    IERC20 private constant ETH_ADDRESS = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n    function universalTransfer(IERC20 token, address to, uint256 amount) internal returns(bool) {\n        if (amount == 0) {\n            return true;\n        }\n\n        if (isETH(token)) {\n            payable(address(uint160(to))).transfer(amount);\n        } else {\n            token.safeTransfer(to, amount);\n            return true;\n        }\n    }\n\n    function universalTransferFrom(IERC20 token, address from, address to, uint256 amount) internal {\n        if (amount == 0) {\n            return;\n        }\n\n        if (isETH(token)) {\n            require(from == msg.sender && msg.value >= amount, \"Wrong useage of ETH.universalTransferFrom()\");\n            if (to != address(this)) {\n                payable(address(uint160(to))).transfer(amount);\n            }\n            if (msg.value > amount) {\n                payable(msg.sender).transfer(msg.value - amount);\n            }\n        } else {\n            token.safeTransferFrom(from, to, amount);\n        }\n    }\n\n    function universalTransferFromSenderToThis(IERC20 token, uint256 amount) internal {\n        if (amount == 0) {\n            return;\n        }\n\n        if (isETH(token)) {\n            if (msg.value > amount) {\n                // Return remainder if exist\n                payable(msg.sender).transfer(msg.value - amount);\n            }\n        } else {\n            token.safeTransferFrom(msg.sender, address(this), amount);\n        }\n    }\n\n    function universalApprove(IERC20 token, address to, uint256 amount) internal {\n        if (!isETH(token)) {\n            if (amount == 0) {\n                token.safeApprove(to, 0);\n                return;\n            }\n\n            uint256 allowance = token.allowance(address(this), to);\n            if (allowance < amount) {\n                if (allowance > 0) {\n                    token.safeApprove(to, 0);\n                }\n                token.safeApprove(to, amount);\n            }\n        }\n    }\n\n    function universalBalanceOf(IERC20 token, address who) internal view returns (uint256) {\n        if (isETH(token)) {\n            return who.balance;\n        } else {\n            return token.balanceOf(who);\n        }\n    }\n\n    function universalDecimals(IERC20 token) internal view returns (uint8) {\n\n        if (isETH(token)) {\n            return 18;\n        }\n\n        (bool success, bytes memory data) = address(token).staticcall(\n            abi.encodeWithSignature(\"decimals()\")\n        );\n        if (!success || data.length == 0) {\n            (success, data) = address(token).staticcall(\n                abi.encodeWithSignature(\"DECIMALS()\")\n            );\n        }\n\n        return (success && data.length > 0) ? abi.decode(data, (uint8)) : 18;\n    }\n\n    function isETH(IERC20 token) internal pure returns(bool) {\n        return (address(token) == address(ZERO_ADDRESS) || address(token) == address(ETH_ADDRESS));\n    }\n\n    function eq(IERC20 a, IERC20 b) internal pure returns(bool) {\n        return a == b || (isETH(a) && isETH(b));\n    }\n}\n"

    },

    "node_modules/@openzeppelin/contracts/utils/Context.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"

    },

    "node_modules/@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"

    },

    "interfaces/pools/ILpToken.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\ninterface ILpToken is IERC20Metadata {\n    function mint(address account, uint256 amount) external returns (uint256);\n\n    function burn(address _owner, uint256 _amount) external returns (uint256);\n}\n"

    },

    "interfaces/vendor/IBooster.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.20;\n\ninterface IBooster {\n    function poolInfo(uint256 pid)\n        external\n        view\n        returns (\n            address lpToken,\n            address token,\n            address gauge,\n            address crvRewards,\n            address stash,\n            bool shutdown\n        );\n\n    function poolLength() external view returns (uint256);\n\n    function deposit(\n        uint256 _pid,\n        uint256 _amount,\n        bool _stake\n    ) external returns (bool);\n\n    function withdraw(uint256 _pid, uint256 _amount) external returns (bool);\n\n    function withdrawAll(uint256 _pid) external returns (bool);\n\n    function depositAll(uint256 _pid, bool _stake) external returns (bool);\n\n    function earmarkRewards(uint256 _pid) external returns (bool);\n\n    function isShutdown() external view returns (bool);\n}\n"

    },

    "libraries/CurvePoolUtils.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.20;\n\nimport \"../interfaces/vendor/ICurvePoolV2.sol\";\nimport \"../interfaces/vendor/ICurvePoolV1.sol\";\nimport \"./ScaledMath.sol\";\n\nlibrary CurvePoolUtils {\n    using ScaledMath for uint256;\n\n    uint256 internal constant _DEFAULT_IMBALANCE_THRESHOLD = 0.02e18;\n\n    enum AssetType {\n        USD,\n        ETH,\n        BTC,\n        OTHER,\n        CRYPTO\n    }\n\n    struct PoolMeta {\n        address pool;\n        uint256 numberOfCoins;\n        AssetType assetType;\n        uint256[] decimals;\n        uint256[] prices;\n        uint256[] thresholds;\n    }\n\n    function ensurePoolBalanced(PoolMeta memory poolMeta) internal view {\n        uint256 fromDecimals = poolMeta.decimals[0];\n        uint256 fromBalance = 10**fromDecimals;\n        uint256 fromPrice = poolMeta.prices[0];\n        for (uint256 i = 1; i < poolMeta.numberOfCoins; i++) {\n            uint256 toDecimals = poolMeta.decimals[i];\n            uint256 toPrice = poolMeta.prices[i];\n            uint256 toExpectedUnscaled = (fromBalance * fromPrice) / toPrice;\n            uint256 toExpected = toExpectedUnscaled.convertScale(\n                uint8(fromDecimals),\n                uint8(toDecimals)\n            );\n\n            uint256 toActual;\n\n            if (poolMeta.assetType == AssetType.CRYPTO) {\n                // Handling crypto pools\n                toActual = ICurvePoolV2(poolMeta.pool).get_dy(0, i, fromBalance);\n            } else {\n                // Handling other pools\n                toActual = ICurvePoolV1(poolMeta.pool).get_dy(0, int128(uint128(i)), fromBalance);\n            }\n\n            require(\n                _isWithinThreshold(toExpected, toActual, poolMeta.thresholds[i]),\n                \"pool is not balanced\"\n            );\n        }\n    }\n\n    function _isWithinThreshold(\n        uint256 a,\n        uint256 b,\n        uint256 imbalanceTreshold\n    ) internal pure returns (bool) {\n        if (imbalanceTreshold == 0) imbalanceTreshold = _DEFAULT_IMBALANCE_THRESHOLD;\n        if (a > b) return (a - b).divDown(a) <= imbalanceTreshold;\n        return (b - a).divDown(b) <= imbalanceTreshold;\n    }\n}\n"

    },

    "interfaces/tokenomics/ITORUSLockerV2.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.20;\n\nimport \"../../libraries/MerkleProof.sol\";\n\ninterface ITORUSLockerV2 {\n    event Locked(address indexed account, uint256 amount, uint256 unlockTime, bool relocked);\n    event UnlockExecuted(address indexed account, uint256 amount);\n    event Relocked(address indexed account, uint256 amount);\n    event KickExecuted(address indexed account, address indexed kicker, uint256 amount);\n    event FeesReceived(address indexed sender, uint256 crvAmount, uint256 cvxAmount);\n    event FeesClaimed(address indexed claimer, uint256 crvAmount, uint256 cvxAmount);\n    event AirdropBoostClaimed(address indexed claimer, uint256 amount);\n    event Shutdown();\n    event TokenRecovered(address indexed token);\n\n    struct VoteLock {\n        uint256 amount;\n        uint64 unlockTime;\n        uint128 boost;\n        uint64 id;\n    }\n\n    function lock(uint256 amount, uint64 lockTime) external;\n\n    function lock(\n        uint256 amount,\n        uint64 lockTime,\n        bool relock\n    ) external;\n\n    function lockFor(\n        uint256 amount,\n        uint64 lockTime,\n        bool relock,\n        address account\n    ) external;\n\n    function relock(uint64 lockId, uint64 lockTime) external;\n\n    function relock(uint64 lockTime) external;\n\n    function relockMultiple(uint64[] calldata lockIds, uint64 lockTime) external;\n\n    function totalBoosted() external view returns (uint256);\n\n    function shutDown() external;\n\n    function recoverToken(address token) external;\n\n    function executeAvailableUnlocks() external returns (uint256);\n\n    function executeAvailableUnlocksFor(address dst) external returns (uint256);\n\n    function executeUnlocks(address dst, uint64[] calldata lockIds) external returns (uint256);\n\n    // This will need to include the boosts etc.\n    function balanceOf(address user) external view returns (uint256);\n\n    function unlockableBalance(address user) external view returns (uint256);\n\n    function unlockableBalanceBoosted(address user) external view returns (uint256);\n\n    function kick(address user, uint64 lockId) external;\n\n    function receiveFees(uint256 amountCrv, uint256 amountCvx) external;\n\n    function claimableFees(address account)\n        external\n        view\n        returns (uint256 claimableCrv, uint256 claimableCvx);\n\n    function claimFees() external returns (uint256 crvAmount, uint256 cvxAmount);\n\n    function computeBoost(uint128 lockTime) external view returns (uint128);\n\n    function claimedAirdrop(address account) external view returns (bool);\n\n    function totalVoteBoost(address account) external view returns (uint256);\n\n    function totalRewardsBoost(address account) external view returns (uint256);\n\n    function userLocks(address account) external view returns (VoteLock[] memory);\n}\n"

    },

    "interfaces/vendor/ICurvePoolV2.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.20;\n\ninterface ICurvePoolV2 {\n    function token() external view returns (address);\n\n    function coins(uint256 i) external view returns (address);\n\n    function factory() external view returns (address);\n\n    function exchange(\n        uint256 i,\n        uint256 j,\n        uint256 dx,\n        uint256 min_dy,\n        bool use_eth,\n        address receiver\n    ) external returns (uint256);\n\n    function exchange_underlying(\n        uint256 i,\n        uint256 j,\n        uint256 dx,\n        uint256 min_dy,\n        address receiver\n    ) external returns (uint256);\n\n    function add_liquidity(\n        uint256[2] memory amounts,\n        uint256 min_mint_amount,\n        bool use_eth,\n        address receiver\n    ) external returns (uint256);\n\n    function add_liquidity(uint256[2] memory amounts, uint256 min_mint_amount)\n        external\n        returns (uint256);\n\n    function add_liquidity(\n        uint256[3] memory amounts,\n        uint256 min_mint_amount,\n        bool use_eth,\n        address receiver\n    ) external returns (uint256);\n\n    function add_liquidity(uint256[3] memory amounts, uint256 min_mint_amount)\n        external\n        returns (uint256);\n\n    function remove_liquidity(\n        uint256 _amount,\n        uint256[2] memory min_amounts,\n        bool use_eth,\n        address receiver\n    ) external;\n\n    function remove_liquidity(uint256 _amount, uint256[2] memory min_amounts)\n        external;\n\n    function remove_liquidity(\n        uint256 _amount,\n        uint256[3] memory min_amounts,\n        bool use_eth,\n        address receiver\n    ) external;\n\n    function remove_liquidity(uint256 _amount, uint256[3] memory min_amounts)\n        external;\n\n    function remove_liquidity_one_coin(\n        uint256 token_amount,\n        uint256 i,\n        uint256 min_amount,\n        bool use_eth,\n        address receiver\n    ) external returns (uint256);\n\n    function get_dy(\n        uint256 i,\n        uint256 j,\n        uint256 dx\n    ) external view returns (uint256);\n\n    function calc_token_amount(uint256[] memory amounts)\n        external\n        view\n        returns (uint256);\n\n    function calc_withdraw_one_coin(uint256 token_amount, uint256 i)\n        external\n        view\n        returns (uint256);\n\n    function get_virtual_price() external view returns (uint256);\n}\n"

    },

    "interfaces/vendor/UniswapRouter02.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.20;\n\ninterface UniswapRouter02 {\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external returns (uint256 amountIn);\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external view returns (uint256 amountOut);\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n\n    function getAmountsOut(uint256 amountIn, address[] memory path)\n        external\n        view\n        returns (uint256[] memory amounts);\n\n    function getReserves(\n        address factory,\n        address tokenA,\n        address tokenB\n    ) external view returns (uint256 reserveA, uint256 reserveB);\n\n    function WETH() external pure returns (address);\n}\n\ninterface UniswapV2Pair {\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 _reserve0,\n            uint112 _reserve1,\n            uint32 _blockTimestampLast\n        );\n}\n\ninterface UniswapV2Factory {\n    function getPair(address tokenA, address tokenB)\n        external\n        view\n        returns (address pair);\n}\n"

    },

    "lib/forge-std/src/console.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _sendLogPayload(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n    }\n\n    function logUint(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function logString(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function log(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n    }\n\n    function log(uint p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n    }\n\n    function log(uint p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n    }\n\n    function log(uint p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}"

    },

    "node_modules/@openzeppelin/contracts/interfaces/IERC20.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\n"

    },

    "interfaces/vendor/ICurvePoolV1.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.20;\n\ninterface ICurvePoolV1 {\n    function get_virtual_price() external view returns (uint256);\n\n    function add_liquidity(uint256[8] calldata amounts, uint256 min_mint_amount) external;\n\n    function add_liquidity(uint256[7] calldata amounts, uint256 min_mint_amount) external;\n\n    function add_liquidity(uint256[6] calldata amounts, uint256 min_mint_amount) external;\n\n    function add_liquidity(uint256[5] calldata amounts, uint256 min_mint_amount) external;\n\n    function add_liquidity(uint256[4] calldata amounts, uint256 min_mint_amount) external;\n\n    function add_liquidity(uint256[3] calldata amounts, uint256 min_mint_amount) external;\n\n    function add_liquidity(uint256[2] calldata amounts, uint256 min_mint_amount) external;\n\n    function remove_liquidity_imbalance(uint256[4] calldata amounts, uint256 max_burn_amount)\n        external;\n\n    function remove_liquidity_imbalance(uint256[3] calldata amounts, uint256 max_burn_amount)\n        external;\n\n    function remove_liquidity_imbalance(uint256[2] calldata amounts, uint256 max_burn_amount)\n        external;\n\n    function lp_token() external view returns (address);\n\n    function A_PRECISION() external view returns (uint256);\n\n    function A_precise() external view returns (uint256);\n\n    function remove_liquidity(uint256 _amount, uint256[3] calldata min_amounts) external;\n\n    function exchange(\n        int128 from,\n        int128 to,\n        uint256 _from_amount,\n        uint256 _min_to_amount\n    ) external;\n\n    function coins(uint256 i) external view returns (address);\n\n    function balances(uint256 i) external view returns (uint256);\n\n    function get_dy(\n        int128 i,\n        int128 j,\n        uint256 _dx\n    ) external view returns (uint256);\n\n    function calc_token_amount(uint256[4] calldata amounts, bool deposit)\n        external\n        view\n        returns (uint256);\n\n    function calc_token_amount(uint256[3] calldata amounts, bool deposit)\n        external\n        view\n        returns (uint256);\n\n    function calc_token_amount(uint256[2] calldata amounts, bool deposit)\n        external\n        view\n        returns (uint256);\n\n    function calc_withdraw_one_coin(uint256 _token_amount, int128 i)\n        external\n        view\n        returns (uint256);\n\n    function remove_liquidity_one_coin(\n        uint256 _token_amount,\n        int128 i,\n        uint256 min_amount\n    ) external;\n}\n"

    },

    "libraries/MerkleProof.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.20;\n\nlibrary MerkleProof {\n    struct Proof {\n        uint16 nodeIndex;\n        bytes32[] hashes;\n    }\n\n    function isValid(\n        Proof memory proof,\n        bytes32 node,\n        bytes32 merkleTorus\n    ) internal pure returns (bool) {\n        uint256 length = proof.hashes.length;\n        uint16 nodeIndex = proof.nodeIndex;\n        for (uint256 i = 0; i < length; i++) {\n            if (nodeIndex % 2 == 0) {\n                node = keccak256(abi.encodePacked(node, proof.hashes[i]));\n            } else {\n                node = keccak256(abi.encodePacked(proof.hashes[i], node));\n            }\n            nodeIndex /= 2;\n        }\n\n        return node == merkleTorus;\n    }\n}\n"

    }

  },

  "settings": {

    "remappings": [

      "@chainlink/contracts/=node_modules/@chainlink/contracts/src/v0.8/",

      "@openzeppelin/=node_modules/@openzeppelin/",

      "ds-test/=lib/forge-std/lib/ds-test/src/",

      "forge-std/=lib/forge-std/src/"

    ],

    "optimizer": {

      "enabled": true,

      "runs": 200

    },

    "metadata": {

      "bytecodeHash": "ipfs",

      "appendCBOR": true

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "evmVersion": "shanghai",

    "libraries": {}

  }

}}