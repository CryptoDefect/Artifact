{{

  "language": "Solidity",

  "sources": {

    "src/integrations/UniV3Swap.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {IOracle} from \"splits-oracle/interfaces/IOracle.sol\";\nimport {ISwapRouter} from \"v3-periphery/interfaces/ISwapRouter.sol\";\nimport {IWETH9} from \"splits-utils/interfaces/external/IWETH9.sol\";\nimport {QuoteParams} from \"splits-utils/LibQuotes.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {TokenUtils} from \"splits-utils/TokenUtils.sol\";\n\nimport {ISwapperFlashCallback} from \"../interfaces/ISwapperFlashCallback.sol\";\nimport {SwapperImpl} from \"../SwapperImpl.sol\";\nimport {SwapperFactory} from \"../SwapperFactory.sol\";\n\n/// @title Uniswap V3 Swapper Integration\n/// @author 0xSplits\n/// @notice Used by EOAs & simple bots to execute `Swapper#flash` with uniswap v3\n/// @dev This contract uses token = address(0) to refer to ETH.\ncontract UniV3Swap is ISwapperFlashCallback {\n    using SafeTransferLib for address;\n    using TokenUtils for address;\n\n    error Unauthorized();\n    error InsufficientFunds();\n\n    struct InitFlashParams {\n        QuoteParams[] quoteParams;\n        FlashCallbackData flashCallbackData;\n    }\n\n    struct FlashCallbackData {\n        ISwapRouter.ExactInputParams[] exactInputParams;\n        address excessRecipient;\n    }\n\n    SwapperFactory public immutable swapperFactory;\n    ISwapRouter public immutable swapRouter;\n    IWETH9 public immutable weth9;\n\n    constructor(SwapperFactory swapperFactory_, ISwapRouter swapRouter_, IWETH9 weth9_) {\n        swapperFactory = swapperFactory_;\n        swapRouter = swapRouter_;\n        weth9 = weth9_;\n    }\n\n    /// receive from weth9\n    receive() external payable {}\n\n    /// begin `Swapper#flash`\n    /// @dev trader may pay ETH & include the extra WETH in `params_.exactInputParams` to make up\n    /// for `Swapper#oracle` shortfall. If swapper incentives are insufficient and they still want to push\n    /// funds to `beneficiary`. Recipient in `params_.exactInputParams` should always be _this_ contract\n    /// so it can handle the approval / payback for Swapper\n    function initFlash(SwapperImpl swapper, InitFlashParams calldata params_) external payable {\n        swapper.flash(params_.quoteParams, abi.encode(params_.flashCallbackData));\n    }\n\n    /// `Swapper#flash` callback\n    /// @dev by end of function if `tokenToBeneficiary_` is ETH, must have sent `amountToBeneficiary_`\n    /// to `Swapper#payback`. Otherwise, must approve Swapper to transfer `amountToBeneficiary_`\n    /// DO NOT HOLD FUNDS IN THIS CONTRACT WITHOUT ADDING PROPER VERIFICATION OF MSG.SENDER\n    function swapperFlashCallback(address tokenToBeneficiary_, uint256 amountToBeneficiary_, bytes calldata data_)\n        external\n    {\n        FlashCallbackData memory flashCallbackData = abi.decode(data_, (FlashCallbackData));\n        ISwapRouter.ExactInputParams[] memory exactInputParams = flashCallbackData.exactInputParams;\n\n        uint256 ethBalance = address(this).balance;\n        if (ethBalance != 0) {\n            weth9.deposit{value: ethBalance}();\n        }\n        uint256 totalOut = (tokenToBeneficiary_._isETH())\n            ? weth9.balanceOf(address(this))\n            : tokenToBeneficiary_.balanceOf(address(this));\n\n        uint256 length = exactInputParams.length;\n        for (uint256 i; i < length;) {\n            ISwapRouter.ExactInputParams memory eip = exactInputParams[i];\n            address token = _getStartTokenFromPath(eip.path);\n\n            token.safeApprove(address(swapRouter), eip.amountIn);\n            totalOut += swapRouter.exactInput(eip);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (totalOut < amountToBeneficiary_) revert InsufficientFunds();\n\n        address excessRecipient = flashCallbackData.excessRecipient;\n        if (tokenToBeneficiary_._isETH()) {\n            // withdraw WETH from uni swaps to ETH\n            uint256 weth9Balance = weth9.balanceOf(address(this));\n            weth9.withdraw(weth9Balance);\n\n            // send req'd amt to swapper#payback\n            SwapperImpl(msg.sender).payback{value: amountToBeneficiary_}();\n\n            // xfr excess out\n            ethBalance = address(this).balance;\n            if (ethBalance != 0) {\n                excessRecipient.safeTransferETH(ethBalance);\n            }\n        } else {\n            // approve swapper to xfr req'd amt out\n            tokenToBeneficiary_.safeApprove(msg.sender, amountToBeneficiary_);\n\n            // xfr excess out\n            uint256 excessBalance = ERC20(tokenToBeneficiary_).balanceOf(address(this)) - amountToBeneficiary_;\n            if (excessBalance > 0) {\n                tokenToBeneficiary_.safeTransfer(excessRecipient, excessBalance);\n            }\n        }\n    }\n\n    function _getStartTokenFromPath(bytes memory path) internal pure returns (address token) {\n        assembly {\n            token := mload(add(path, 0x14))\n        }\n    }\n}\n"

    },

    "lib/solmate/src/tokens/ERC20.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"

    },

    "lib/splits-oracle/src/interfaces/IOracle.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\nimport {QuoteParams} from \"splits-utils/LibQuotes.sol\";\n\n/// @title Oracle Interface\n/// @author 0xSplits\ninterface IOracle {\n    function getQuoteAmounts(QuoteParams[] calldata quoteParams_) external view returns (uint256[] memory);\n}\n"

    },

    "lib/v3-periphery/contracts/interfaces/ISwapRouter.sol": {

      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\nimport '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol';\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface ISwapRouter is IUniswapV3SwapCallback {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n}\n"

    },

    "lib/splits-utils/src/interfaces/external/IWETH9.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\n/// @title Interface for WETH9\ninterface IWETH9 {\n    /// @notice Deposit ether to get wrapped ether\n    function deposit() external payable;\n\n    /// @notice Withdraw wrapped ether to get ether\n    function withdraw(uint256) external;\n\n    function balanceOf(address) external view returns (uint256);\n}\n"

    },

    "lib/splits-utils/src/LibQuotes.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\nimport {ConvertedQuotePair, SortedConvertedQuotePair} from \"./ConvertedQuotePair.sol\";\n\nusing {_sort, _convert, _convertAndSort} for QuotePair global;\n\nstruct QuoteParams {\n    QuotePair quotePair;\n    uint128 baseAmount;\n    bytes data;\n}\n\nstruct QuotePair {\n    address base;\n    address quote;\n}\n\nstruct SortedQuotePair {\n    address token0;\n    address token1;\n}\n\nfunction _sort(QuotePair memory qp) pure returns (SortedQuotePair memory) {\n    return (qp.base > qp.quote)\n        ? SortedQuotePair({token0: qp.quote, token1: qp.base})\n        : SortedQuotePair({token0: qp.base, token1: qp.quote});\n}\n\nfunction _convert(QuotePair calldata qp, function (address) internal view returns (address) convert)\n    view\n    returns (ConvertedQuotePair memory)\n{\n    return ConvertedQuotePair({cBase: convert(qp.base), cQuote: convert(qp.quote)});\n}\n\nfunction _convertAndSort(QuotePair calldata qp, function (address) internal view returns (address) convert)\n    view\n    returns (SortedConvertedQuotePair memory)\n{\n    return _convert(qp, convert)._sort();\n}\n"

    },

    "lib/solady/src/utils/SafeTransferLib.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Caution! This library won't check that a token has code, responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The ETH transfer has failed.\n    error ETHTransferFailed();\n\n    /// @dev The ERC20 `transferFrom` has failed.\n    error TransferFromFailed();\n\n    /// @dev The ERC20 `transfer` has failed.\n    error TransferFailed();\n\n    /// @dev The ERC20 `approve` has failed.\n    error ApproveFailed();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Suggested gas stipend for contract receiving ETH\n    /// that disallows any storage writes.\n    uint256 internal constant _GAS_STIPEND_NO_STORAGE_WRITES = 2300;\n\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\n    /// storage reads and writes, but low enough to prevent griefing.\n    /// Multiply by a small constant (e.g. 2), if needed.\n    uint256 internal constant _GAS_STIPEND_NO_GRIEF = 100000;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       ETH OPERATIONS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Sends `amount` (in wei) ETH to `to`.\n    /// Reverts upon failure.\n    function safeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and check if it succeeded or not.\n            if iszero(call(gas(), to, amount, 0, 0, 0, 0)) {\n                // Store the function selector of `ETHTransferFailed()`.\n                mstore(0x00, 0xb12d13eb)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    /// The `gasStipend` can be set to a low enough value to prevent\n    /// storage writes or gas griefing.\n    ///\n    /// If sending via the normal procedure fails, force sends the ETH by\n    /// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.\n    ///\n    /// Reverts if the current contract has insufficient balance.\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If insufficient balance, revert.\n            if lt(selfbalance(), amount) {\n                // Store the function selector of `ETHTransferFailed()`.\n                mstore(0x00, 0xb12d13eb)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            // Transfer the ETH and check if it succeeded or not.\n            if iszero(call(gasStipend, to, amount, 0, 0, 0, 0)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                // We can directly use `SELFDESTRUCT` in the contract creation.\n                // Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758\n                if iszero(create(amount, 0x0b, 0x16)) {\n                    // For better gas estimation.\n                    if iszero(gt(gas(), 1000000)) { revert(0, 0) }\n                }\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a gas stipend\n    /// equal to `_GAS_STIPEND_NO_GRIEF`. This gas stipend is a reasonable default\n    /// for 99% of cases and can be overriden with the three-argument version of this\n    /// function if necessary.\n    ///\n    /// If sending via the normal procedure fails, force sends the ETH by\n    /// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.\n    ///\n    /// Reverts if the current contract has insufficient balance.\n    function forceSafeTransferETH(address to, uint256 amount) internal {\n        // Manually inlined because the compiler doesn't inline functions with branches.\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If insufficient balance, revert.\n            if lt(selfbalance(), amount) {\n                // Store the function selector of `ETHTransferFailed()`.\n                mstore(0x00, 0xb12d13eb)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            // Transfer the ETH and check if it succeeded or not.\n            if iszero(call(_GAS_STIPEND_NO_GRIEF, to, amount, 0, 0, 0, 0)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                // We can directly use `SELFDESTRUCT` in the contract creation.\n                // Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758\n                if iszero(create(amount, 0x0b, 0x16)) {\n                    // For better gas estimation.\n                    if iszero(gt(gas(), 1000000)) { revert(0, 0) }\n                }\n            }\n        }\n    }\n\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    /// The `gasStipend` can be set to a low enough value to prevent\n    /// storage writes or gas griefing.\n    ///\n    /// Simply use `gasleft()` for `gasStipend` if you don't need a gas stipend.\n    ///\n    /// Note: Does NOT revert upon failure.\n    /// Returns whether the transfer of ETH is successful instead.\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and check if it succeeded or not.\n            success := call(gasStipend, to, amount, 0, 0, 0, 0)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      ERC20 OPERATIONS                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for\n    /// the current contract to manage.\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            // Store the function selector of `transferFrom(address,address,uint256)`.\n            mstore(0x0c, 0x23b872dd000000000000000000000000)\n\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    // Set success to whether the call reverted, if not we check it either\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n                )\n            ) {\n                // Store the function selector of `TransferFromFailed()`.\n                mstore(0x00, 0x7939f424)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for\n    /// the current contract to manage.\n    function safeTransferAllFrom(address token, address from, address to)\n        internal\n        returns (uint256 amount)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            // Store the function selector of `balanceOf(address)`.\n            mstore(0x0c, 0x70a08231000000000000000000000000)\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\n                )\n            ) {\n                // Store the function selector of `TransferFromFailed()`.\n                mstore(0x00, 0x7939f424)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Store the function selector of `transferFrom(address,address,uint256)`.\n            mstore(0x00, 0x23b872dd)\n            // The `amount` argument is already written to the memory word at 0x6c.\n            amount := mload(0x60)\n\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    // Set success to whether the call reverted, if not we check it either\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n                )\n            ) {\n                // Store the function selector of `TransferFromFailed()`.\n                mstore(0x00, 0x7939f424)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransfer(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            // Store the function selector of `transfer(address,uint256)`.\n            mstore(0x00, 0xa9059cbb000000000000000000000000)\n\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    // Set success to whether the call reverted, if not we check it either\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                // Store the function selector of `TransferFailed()`.\n                mstore(0x00, 0x90b8ec18)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            // Restore the part of the free memory pointer that was overwritten.\n            mstore(0x34, 0)\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\n            mstore(0x20, address()) // Store the address of the current contract.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\n                )\n            ) {\n                // Store the function selector of `TransferFailed()`.\n                mstore(0x00, 0x90b8ec18)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            mstore(0x14, to) // Store the `to` argument.\n            // The `amount` argument is already written to the memory word at 0x34.\n            amount := mload(0x34)\n            // Store the function selector of `transfer(address,uint256)`.\n            mstore(0x00, 0xa9059cbb000000000000000000000000)\n\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    // Set success to whether the call reverted, if not we check it either\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                // Store the function selector of `TransferFailed()`.\n                mstore(0x00, 0x90b8ec18)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            // Restore the part of the free memory pointer that was overwritten.\n            mstore(0x34, 0)\n        }\n    }\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// Reverts upon failure.\n    function safeApprove(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            // Store the function selector of `approve(address,uint256)`.\n            mstore(0x00, 0x095ea7b3000000000000000000000000)\n\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    // Set success to whether the call reverted, if not we check it either\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                )\n            ) {\n                // Store the function selector of `ApproveFailed()`.\n                mstore(0x00, 0x3e3f8f73)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            // Restore the part of the free memory pointer that was overwritten.\n            mstore(0x34, 0)\n        }\n    }\n\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\n    /// Returns zero if the `token` does not exist.\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, account) // Store the `account` argument.\n            // Store the function selector of `balanceOf(address)`.\n            mstore(0x00, 0x70a08231000000000000000000000000)\n            amount :=\n                mul(\n                    mload(0x20),\n                    and( // The arguments of `and` are evaluated from right to left.\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\n                    )\n                )\n        }\n    }\n}\n"

    },

    "lib/splits-utils/src/TokenUtils.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\n\n/// Library to handle basic token functions for ERC20s & ETH (represented by 0x0)\nlibrary TokenUtils {\n    using SafeTransferLib for address;\n\n    address internal constant ETH_ADDRESS = address(0);\n\n    function _isETH(address token) internal pure returns (bool) {\n        return (token == ETH_ADDRESS);\n    }\n\n    function _decimals(address token) internal view returns (uint8) {\n        return _isETH(token) ? 18 : ERC20(token).decimals();\n    }\n\n    function _balanceOf(address token, address addr) internal view returns (uint256) {\n        return _isETH(token) ? addr.balance : ERC20(token).balanceOf(addr);\n    }\n\n    function _safeTransfer(address token, address addr, uint256 amount) internal {\n        if (_isETH(token)) addr.safeTransferETH(amount);\n        else token.safeTransfer(addr, amount);\n    }\n}\n\ninterface ERC20 {\n    function decimals() external view returns (uint8);\n    function balanceOf(address addr) external view returns (uint256);\n}\n"

    },

    "src/interfaces/ISwapperFlashCallback.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\n/// @title Swapper Flash Callback\n/// @author 0xSplits\n/// @notice Callback for `Swapper#flash`\n/// @dev any contract that calls `Swapper#flash` must implement this interface.\n/// Inspired by IUniswapV3FlashCallback\ninterface ISwapperFlashCallback {\n    /// Called to `msg.sender` in `Swapper#flash` after transferring `quoteParams`.\n    /// @dev In the implementation you must complete the flash swap.\n    /// If `tokenToBeneficiary` is ETH, you must deposit `amountToBeneficiary` via `Swapper#payback`.\n    /// If `tokenToBeneficiary` is an ERC20, you must use approve Swapper to transfer `amountToBeneficiary`.\n    /// The caller of this method will use token = address(0) to refer to ETH.\n    /// @param tokenToBeneficiary The token due to the `beneficiary` by the end of `#flash`\n    /// @param amountToBeneficiary The amount of `tokenToBeneficiary` due to the `beneficiary` by the end of `#flash`\n    /// @param data Any `data` passed through by `msg.sender` of `Swapper#flash`\n    function swapperFlashCallback(address tokenToBeneficiary, uint256 amountToBeneficiary, bytes calldata data)\n        external;\n}\n"

    },

    "src/SwapperImpl.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\nimport {ERC20} from \"solmate/tokens/ERC20.sol\";\nimport {IOracle} from \"splits-oracle/interfaces/IOracle.sol\";\nimport {PausableImpl} from \"splits-utils/PausableImpl.sol\";\nimport {QuotePair, QuoteParams, SortedQuotePair} from \"splits-utils/LibQuotes.sol\";\nimport {SafeCastLib} from \"solady/utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {TokenUtils} from \"splits-utils/TokenUtils.sol\";\nimport {WalletImpl} from \"splits-utils/WalletImpl.sol\";\n\nimport {ISwapperFlashCallback} from \"./interfaces/ISwapperFlashCallback.sol\";\nimport {PairScaledOfferFactors} from \"./libraries/PairScaledOfferFactors.sol\";\n\n/// @title Swapper Implementation\n/// @author 0xSplits\n/// @notice A contract to trustlessly & automatically convert multi-token\n/// onchain revenue into a particular output token.\n/// Please be aware, owner has _FULL CONTROL_ of the deployment.\n/// @dev This contract uses a modular oracle. Be very careful to use a secure\n/// oracle with sensible settings for the desired behavior. Insecure oracles\n/// will  result in catastrophic loss of funds.\n/// This contract uses token = address(0) to refer to ETH.\ncontract SwapperImpl is WalletImpl, PausableImpl {\n    /// -----------------------------------------------------------------------\n    /// libraries\n    /// -----------------------------------------------------------------------\n\n    using SafeTransferLib for address;\n    using SafeCastLib for uint256;\n    using TokenUtils for address;\n    using PairScaledOfferFactors for mapping(address => mapping(address => uint32));\n\n    /// -----------------------------------------------------------------------\n    /// errors\n    /// -----------------------------------------------------------------------\n\n    error Invalid_AmountsToBeneficiary();\n    error Invalid_QuoteToken();\n    error InsufficientFunds_InContract();\n    error InsufficientFunds_FromTrader();\n\n    /// -----------------------------------------------------------------------\n    /// structs\n    /// -----------------------------------------------------------------------\n\n    struct InitParams {\n        address owner;\n        bool paused;\n        address beneficiary;\n        address tokenToBeneficiary;\n        IOracle oracle;\n        uint32 defaultScaledOfferFactor;\n        SetPairScaledOfferFactorParams[] pairScaledOfferFactors;\n    }\n\n    struct SetPairScaledOfferFactorParams {\n        QuotePair quotePair;\n        uint32 scaledOfferFactor;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// events\n    /// -----------------------------------------------------------------------\n\n    event SetBeneficiary(address beneficiary);\n    event SetTokenToBeneficiary(address tokenToBeneficiary);\n    event SetOracle(IOracle oracle);\n    event SetDefaultScaledOfferFactor(uint32 defaultScaledOfferFactor);\n    event SetPairScaledOfferFactors(SetPairScaledOfferFactorParams[] params);\n\n    event ReceiveETH(uint256 amount);\n    event Payback(address indexed payer, uint256 amount);\n    event Flash(\n        address indexed beneficiary,\n        address indexed trader,\n        QuoteParams[] quoteParams,\n        address tokenToBeneficiary,\n        uint256[] amountsToBeneficiary,\n        uint256 excessToBeneficiary\n    );\n\n    /// -----------------------------------------------------------------------\n    /// storage\n    /// -----------------------------------------------------------------------\n\n    /// -----------------------------------------------------------------------\n    /// storage - constants & immutables\n    /// -----------------------------------------------------------------------\n\n    address public immutable swapperFactory;\n\n    /// @dev percentages measured in hundredths of basis points\n    uint32 internal constant PERCENTAGE_SCALE = 100_00_00; // = 100%\n\n    /// -----------------------------------------------------------------------\n    /// storage - mutables\n    /// -----------------------------------------------------------------------\n\n    /// slot 0 - 11 bytes free\n\n    /// OwnableImpl storage\n    /// address internal $owner;\n    /// 20 bytes\n\n    /// PausableImpl storage\n    /// bool internal $paused;\n    /// 1 byte\n\n    /// slot 1 - 0 bytes free\n\n    /// address to receive post-swap tokens\n    address internal $beneficiary;\n    /// 20 bytes\n\n    /// used to track ETH payback in flash\n    uint96 internal $_payback;\n    /// 12 bytes\n\n    /// slot 2 - 8 bytes free\n\n    /// token type to send beneficiary\n    /// @dev 0x0 used for ETH\n    address internal $tokenToBeneficiary;\n    /// 20 bytes\n\n    /// default oracle price scaling factor\n    /// @dev PERCENTAGE_SCALE = 1e6 = 100_00_00 = 100% = no discount or premium\n    /// 99_00_00 = 99% = 1% discount to oracle; 101_00_00 = 101% = 1% premium to oracle\n    /// 4 bytes\n    uint32 internal $defaultScaledOfferFactor;\n\n    /// slot 3 - 12 bytes free\n\n    /// price oracle for `#flash`\n    IOracle internal $oracle;\n    /// 20 bytes\n\n    /// slot 4 - 0 bytes free\n\n    /// scaledOfferFactors for specific quote pairs\n    /// 32 bytes\n    mapping(address => mapping(address => uint32)) internal $_pairScaledOfferFactors;\n\n    /// -----------------------------------------------------------------------\n    /// constructor & initializer\n    /// -----------------------------------------------------------------------\n\n    constructor() {\n        swapperFactory = msg.sender;\n    }\n\n    function initializer(InitParams calldata params_) external {\n        // only swapperFactory may call `initializer`\n        if (msg.sender != swapperFactory) revert Unauthorized();\n\n        // don't need to init wallet separately\n        __initPausable({owner_: params_.owner, paused_: params_.paused});\n\n        $beneficiary = params_.beneficiary;\n        $tokenToBeneficiary = params_.tokenToBeneficiary;\n        $oracle = params_.oracle;\n        $defaultScaledOfferFactor = params_.defaultScaledOfferFactor;\n\n        $_pairScaledOfferFactors._set(params_.pairScaledOfferFactors);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// functions\n    /// -----------------------------------------------------------------------\n\n    /// -----------------------------------------------------------------------\n    /// functions - public & external\n    /// -----------------------------------------------------------------------\n\n    /// -----------------------------------------------------------------------\n    /// functions - public & external - onlyOwner\n    /// -----------------------------------------------------------------------\n\n    /// set beneficiary\n    function setBeneficiary(address beneficiary_) external onlyOwner {\n        $beneficiary = beneficiary_;\n        emit SetBeneficiary(beneficiary_);\n    }\n\n    /// set tokenToBeneficiary\n    function setTokenToBeneficiary(address tokenToBeneficiary_) external onlyOwner {\n        $tokenToBeneficiary = tokenToBeneficiary_;\n        emit SetTokenToBeneficiary(tokenToBeneficiary_);\n    }\n\n    /// set oracle\n    function setOracle(IOracle oracle_) external onlyOwner {\n        $oracle = oracle_;\n        emit SetOracle(oracle_);\n    }\n\n    /// set defaultScaledOfferFactor\n    function setDefaultScaledOfferFactor(uint32 defaultScaledOfferFactor_) external onlyOwner {\n        $defaultScaledOfferFactor = defaultScaledOfferFactor_;\n        emit SetDefaultScaledOfferFactor(defaultScaledOfferFactor_);\n    }\n\n    /// set pair scaled offer factors\n    function setPairScaledOfferFactors(SetPairScaledOfferFactorParams[] calldata params_) external onlyOwner {\n        $_pairScaledOfferFactors._set(params_);\n        emit SetPairScaledOfferFactors(params_);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// functions - public & external - view\n    /// -----------------------------------------------------------------------\n\n    function beneficiary() external view returns (address) {\n        return $beneficiary;\n    }\n\n    function tokenToBeneficiary() external view returns (address) {\n        return $tokenToBeneficiary;\n    }\n\n    function oracle() external view returns (IOracle) {\n        return $oracle;\n    }\n\n    function defaultScaledOfferFactor() external view returns (uint32) {\n        return $defaultScaledOfferFactor;\n    }\n\n    /// get pair scaled offer factors for an array of quote pairs\n    function getPairScaledOfferFactors(QuotePair[] calldata quotePairs_)\n        external\n        view\n        returns (uint32[] memory pairScaledOfferFactors)\n    {\n        uint256 length = quotePairs_.length;\n        pairScaledOfferFactors = new uint32[](length);\n        for (uint256 i; i < length;) {\n            pairScaledOfferFactors[i] = $_pairScaledOfferFactors._get(quotePairs_[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// -----------------------------------------------------------------------\n    /// functions - public & external - permissionless\n    /// -----------------------------------------------------------------------\n\n    /// emit event when receiving ETH\n    /// @dev implemented w/i clone bytecode\n    /* receive() external payable { */\n    /*     emit ReceiveETH(msg.value); */\n    /* } */\n\n    /// allows `#flash` to track ETH payback to `beneficiary`\n    /// @dev if used outside `#swapperFlashCallback`, msg.sender may lose funds.\n    /// Accumulates until next flash call\n    function payback() external payable {\n        $_payback += msg.value.toUint96();\n        emit Payback(msg.sender, msg.value);\n    }\n\n    /// allow third parties to withdraw tokens in return for sending `tokenToBeneficiary` to `beneficiary`\n    function flash(QuoteParams[] calldata quoteParams_, bytes calldata callbackData_)\n        external\n        pausable\n        returns (uint256)\n    {\n        address _tokenToBeneficiary = $tokenToBeneficiary;\n        (uint256 amountToBeneficiary, uint256[] memory amountsToBeneficiary) =\n            _transferToTrader(_tokenToBeneficiary, quoteParams_);\n\n        ISwapperFlashCallback(msg.sender).swapperFlashCallback({\n            tokenToBeneficiary: _tokenToBeneficiary,\n            amountToBeneficiary: amountToBeneficiary,\n            data: callbackData_\n        });\n\n        address _beneficiary = $beneficiary;\n        uint256 excessToBeneficiary = _transferToBeneficiary(_beneficiary, _tokenToBeneficiary, amountToBeneficiary);\n\n        emit Flash(\n            _beneficiary, msg.sender, quoteParams_, _tokenToBeneficiary, amountsToBeneficiary, excessToBeneficiary\n        );\n\n        return amountToBeneficiary + excessToBeneficiary;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// functions - private & internal\n    /// -----------------------------------------------------------------------\n\n    function _transferToTrader(address tokenToBeneficiary_, QuoteParams[] calldata quoteParams_)\n        internal\n        returns (uint256 amountToBeneficiary, uint256[] memory amountsToBeneficiary)\n    {\n        uint256[] memory unscaledAmountsToBeneficiary = $oracle.getQuoteAmounts(quoteParams_);\n        uint256 length = quoteParams_.length;\n        if (unscaledAmountsToBeneficiary.length != length) revert Invalid_AmountsToBeneficiary();\n\n        amountsToBeneficiary = new uint256[](length);\n        uint256 scaledAmountToBeneficiary;\n        uint128 amountToTrader;\n        address tokenToTrader;\n        for (uint256 i; i < length;) {\n            QuoteParams calldata qp = quoteParams_[i];\n\n            if (tokenToBeneficiary_ != qp.quotePair.quote) revert Invalid_QuoteToken();\n            tokenToTrader = qp.quotePair.base;\n            amountToTrader = qp.baseAmount;\n\n            if (amountToTrader > tokenToTrader._balanceOf(address(this))) {\n                revert InsufficientFunds_InContract();\n            }\n\n            uint32 scaledOfferFactor = $_pairScaledOfferFactors._get(qp.quotePair._sort());\n            if (scaledOfferFactor == 0) {\n                scaledOfferFactor = $defaultScaledOfferFactor;\n            }\n\n            scaledAmountToBeneficiary = unscaledAmountsToBeneficiary[i] * scaledOfferFactor / PERCENTAGE_SCALE;\n            amountsToBeneficiary[i] = scaledAmountToBeneficiary;\n            amountToBeneficiary += scaledAmountToBeneficiary;\n            tokenToTrader._safeTransfer(msg.sender, amountToTrader);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _transferToBeneficiary(address beneficiary_, address tokenToBeneficiary_, uint256 amountToBeneficiary_)\n        internal\n        returns (uint256 excessToBeneficiary)\n    {\n        if (tokenToBeneficiary_._isETH()) {\n            if ($_payback < amountToBeneficiary_) {\n                revert InsufficientFunds_FromTrader();\n            }\n            $_payback = 0;\n\n            // send ETH to `beneficiary`\n            uint256 ethBalance = address(this).balance;\n            excessToBeneficiary = ethBalance - amountToBeneficiary_;\n            beneficiary_.safeTransferETH(ethBalance);\n        } else {\n            tokenToBeneficiary_.safeTransferFrom(msg.sender, beneficiary_, amountToBeneficiary_);\n\n            // flush excess `tokenToBeneficiary` to `beneficiary`\n            excessToBeneficiary = ERC20(tokenToBeneficiary_).balanceOf(address(this));\n            if (excessToBeneficiary > 0) {\n                tokenToBeneficiary_.safeTransfer(beneficiary_, excessToBeneficiary);\n            }\n        }\n    }\n}\n"

    },

    "src/SwapperFactory.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\nimport {IOracle} from \"splits-oracle/interfaces/IOracle.sol\";\nimport {OracleParams} from \"splits-oracle/peripherals/OracleParams.sol\";\nimport {LibClone} from \"splits-utils/LibClone.sol\";\n\nimport {SwapperImpl} from \"./SwapperImpl.sol\";\n\n/// @title Swapper Factory\n/// @author 0xSplits\n/// @notice Factory for creating Swappers\n/// @dev This contract uses token = address(0) to refer to ETH.\ncontract SwapperFactory {\n    using LibClone for address;\n\n    event CreateSwapper(SwapperImpl indexed swapper, SwapperImpl.InitParams params);\n\n    struct CreateSwapperParams {\n        address owner;\n        bool paused;\n        address beneficiary;\n        address tokenToBeneficiary;\n        OracleParams oracleParams;\n        uint32 defaultScaledOfferFactor;\n        SwapperImpl.SetPairScaledOfferFactorParams[] pairScaledOfferFactors;\n    }\n\n    SwapperImpl public immutable swapperImpl;\n\n    constructor() {\n        swapperImpl = new SwapperImpl();\n    }\n\n    /// -----------------------------------------------------------------------\n    /// functions - public & external\n    /// -----------------------------------------------------------------------\n\n    function createSwapper(CreateSwapperParams calldata params_) external returns (SwapperImpl swapper) {\n        IOracle oracle = params_.oracleParams._parseIntoOracle();\n\n        swapper = SwapperImpl(payable(address(swapperImpl).clone()));\n        SwapperImpl.InitParams memory swapperInitParams = SwapperImpl.InitParams({\n            owner: params_.owner,\n            paused: params_.paused,\n            beneficiary: params_.beneficiary,\n            tokenToBeneficiary: params_.tokenToBeneficiary,\n            oracle: oracle,\n            defaultScaledOfferFactor: params_.defaultScaledOfferFactor,\n            pairScaledOfferFactors: params_.pairScaledOfferFactors\n        });\n        swapper.initializer(swapperInitParams);\n\n        emit CreateSwapper({swapper: swapper, params: swapperInitParams});\n    }\n}\n"

    },

    "lib/splits-oracle/lib/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol": {

      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n"

    },

    "lib/splits-utils/src/ConvertedQuotePair.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\nusing {_sort} for ConvertedQuotePair global;\n\nstruct ConvertedQuotePair {\n    address cBase;\n    address cQuote;\n}\n\nstruct SortedConvertedQuotePair {\n    address cToken0;\n    address cToken1;\n}\n\nfunction _sort(ConvertedQuotePair memory cqp) pure returns (SortedConvertedQuotePair memory) {\n    return (cqp.cBase > cqp.cQuote)\n        ? SortedConvertedQuotePair({cToken0: cqp.cQuote, cToken1: cqp.cBase})\n        : SortedConvertedQuotePair({cToken0: cqp.cBase, cToken1: cqp.cQuote});\n}\n"

    },

    "lib/splits-utils/src/PausableImpl.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\nimport {OwnableImpl} from \"./OwnableImpl.sol\";\n\n/// @title Pausable Implementation\n/// @author 0xSplits\n/// @notice Pausable clone-implementation\nabstract contract PausableImpl is OwnableImpl {\n    error Paused();\n\n    event SetPaused(bool paused);\n\n    /// -----------------------------------------------------------------------\n    /// storage - mutables\n    /// -----------------------------------------------------------------------\n\n    /// slot 0 - 11 bytes free\n\n    /// OwnableImpl storage\n    /// address internal $owner;\n    /// 20 bytes\n\n    bool internal $paused;\n    /// 1 byte\n\n    /// -----------------------------------------------------------------------\n    /// constructor & initializer\n    /// -----------------------------------------------------------------------\n\n    constructor() {}\n\n    function __initPausable(address owner_, bool paused_) internal virtual {\n        OwnableImpl.__initOwnable(owner_);\n        $paused = paused_;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// modifiers\n    /// -----------------------------------------------------------------------\n\n    modifier pausable() virtual {\n        if (paused()) revert Paused();\n        _;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// functions - public & external - onlyOwner\n    /// -----------------------------------------------------------------------\n\n    function setPaused(bool paused_) public virtual onlyOwner {\n        $paused = paused_;\n        emit SetPaused(paused_);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// functions - public & external - view\n    /// -----------------------------------------------------------------------\n\n    function paused() public view virtual returns (bool) {\n        return $paused;\n    }\n}\n"

    },

    "lib/solady/src/utils/SafeCastLib.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Safe integer casting library that reverts on overflow.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeCastLib.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)\nlibrary SafeCastLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    error Overflow();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*          UNSIGNED INTEGER SAFE CASTING OPERATIONS          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    function toUint8(uint256 x) internal pure returns (uint8) {\n        if (x >= 1 << 8) _revertOverflow();\n        return uint8(x);\n    }\n\n    function toUint16(uint256 x) internal pure returns (uint16) {\n        if (x >= 1 << 16) _revertOverflow();\n        return uint16(x);\n    }\n\n    function toUint24(uint256 x) internal pure returns (uint24) {\n        if (x >= 1 << 24) _revertOverflow();\n        return uint24(x);\n    }\n\n    function toUint32(uint256 x) internal pure returns (uint32) {\n        if (x >= 1 << 32) _revertOverflow();\n        return uint32(x);\n    }\n\n    function toUint40(uint256 x) internal pure returns (uint40) {\n        if (x >= 1 << 40) _revertOverflow();\n        return uint40(x);\n    }\n\n    function toUint48(uint256 x) internal pure returns (uint48) {\n        if (x >= 1 << 48) _revertOverflow();\n        return uint48(x);\n    }\n\n    function toUint56(uint256 x) internal pure returns (uint56) {\n        if (x >= 1 << 56) _revertOverflow();\n        return uint56(x);\n    }\n\n    function toUint64(uint256 x) internal pure returns (uint64) {\n        if (x >= 1 << 64) _revertOverflow();\n        return uint64(x);\n    }\n\n    function toUint72(uint256 x) internal pure returns (uint72) {\n        if (x >= 1 << 72) _revertOverflow();\n        return uint72(x);\n    }\n\n    function toUint80(uint256 x) internal pure returns (uint80) {\n        if (x >= 1 << 80) _revertOverflow();\n        return uint80(x);\n    }\n\n    function toUint88(uint256 x) internal pure returns (uint88) {\n        if (x >= 1 << 88) _revertOverflow();\n        return uint88(x);\n    }\n\n    function toUint96(uint256 x) internal pure returns (uint96) {\n        if (x >= 1 << 96) _revertOverflow();\n        return uint96(x);\n    }\n\n    function toUint104(uint256 x) internal pure returns (uint104) {\n        if (x >= 1 << 104) _revertOverflow();\n        return uint104(x);\n    }\n\n    function toUint112(uint256 x) internal pure returns (uint112) {\n        if (x >= 1 << 112) _revertOverflow();\n        return uint112(x);\n    }\n\n    function toUint120(uint256 x) internal pure returns (uint120) {\n        if (x >= 1 << 120) _revertOverflow();\n        return uint120(x);\n    }\n\n    function toUint128(uint256 x) internal pure returns (uint128) {\n        if (x >= 1 << 128) _revertOverflow();\n        return uint128(x);\n    }\n\n    function toUint136(uint256 x) internal pure returns (uint136) {\n        if (x >= 1 << 136) _revertOverflow();\n        return uint136(x);\n    }\n\n    function toUint144(uint256 x) internal pure returns (uint144) {\n        if (x >= 1 << 144) _revertOverflow();\n        return uint144(x);\n    }\n\n    function toUint152(uint256 x) internal pure returns (uint152) {\n        if (x >= 1 << 152) _revertOverflow();\n        return uint152(x);\n    }\n\n    function toUint160(uint256 x) internal pure returns (uint160) {\n        if (x >= 1 << 160) _revertOverflow();\n        return uint160(x);\n    }\n\n    function toUint168(uint256 x) internal pure returns (uint168) {\n        if (x >= 1 << 168) _revertOverflow();\n        return uint168(x);\n    }\n\n    function toUint176(uint256 x) internal pure returns (uint176) {\n        if (x >= 1 << 176) _revertOverflow();\n        return uint176(x);\n    }\n\n    function toUint184(uint256 x) internal pure returns (uint184) {\n        if (x >= 1 << 184) _revertOverflow();\n        return uint184(x);\n    }\n\n    function toUint192(uint256 x) internal pure returns (uint192) {\n        if (x >= 1 << 192) _revertOverflow();\n        return uint192(x);\n    }\n\n    function toUint200(uint256 x) internal pure returns (uint200) {\n        if (x >= 1 << 200) _revertOverflow();\n        return uint200(x);\n    }\n\n    function toUint208(uint256 x) internal pure returns (uint208) {\n        if (x >= 1 << 208) _revertOverflow();\n        return uint208(x);\n    }\n\n    function toUint216(uint256 x) internal pure returns (uint216) {\n        if (x >= 1 << 216) _revertOverflow();\n        return uint216(x);\n    }\n\n    function toUint224(uint256 x) internal pure returns (uint224) {\n        if (x >= 1 << 224) _revertOverflow();\n        return uint224(x);\n    }\n\n    function toUint232(uint256 x) internal pure returns (uint232) {\n        if (x >= 1 << 232) _revertOverflow();\n        return uint232(x);\n    }\n\n    function toUint240(uint256 x) internal pure returns (uint240) {\n        if (x >= 1 << 240) _revertOverflow();\n        return uint240(x);\n    }\n\n    function toUint248(uint256 x) internal pure returns (uint248) {\n        if (x >= 1 << 248) _revertOverflow();\n        return uint248(x);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*           SIGNED INTEGER SAFE CASTING OPERATIONS           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    function toInt8(int256 x) internal pure returns (int8) {\n        int8 y = int8(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt16(int256 x) internal pure returns (int16) {\n        int16 y = int16(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt24(int256 x) internal pure returns (int24) {\n        int24 y = int24(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt32(int256 x) internal pure returns (int32) {\n        int32 y = int32(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt40(int256 x) internal pure returns (int40) {\n        int40 y = int40(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt48(int256 x) internal pure returns (int48) {\n        int48 y = int48(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt56(int256 x) internal pure returns (int56) {\n        int56 y = int56(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt64(int256 x) internal pure returns (int64) {\n        int64 y = int64(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt72(int256 x) internal pure returns (int72) {\n        int72 y = int72(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt80(int256 x) internal pure returns (int80) {\n        int80 y = int80(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt88(int256 x) internal pure returns (int88) {\n        int88 y = int88(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt96(int256 x) internal pure returns (int96) {\n        int96 y = int96(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt104(int256 x) internal pure returns (int104) {\n        int104 y = int104(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt112(int256 x) internal pure returns (int112) {\n        int112 y = int112(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt120(int256 x) internal pure returns (int120) {\n        int120 y = int120(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt128(int256 x) internal pure returns (int128) {\n        int128 y = int128(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt136(int256 x) internal pure returns (int136) {\n        int136 y = int136(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt144(int256 x) internal pure returns (int144) {\n        int144 y = int144(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt152(int256 x) internal pure returns (int152) {\n        int152 y = int152(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt160(int256 x) internal pure returns (int160) {\n        int160 y = int160(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt168(int256 x) internal pure returns (int168) {\n        int168 y = int168(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt176(int256 x) internal pure returns (int176) {\n        int176 y = int176(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt184(int256 x) internal pure returns (int184) {\n        int184 y = int184(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt192(int256 x) internal pure returns (int192) {\n        int192 y = int192(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt200(int256 x) internal pure returns (int200) {\n        int200 y = int200(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt208(int256 x) internal pure returns (int208) {\n        int208 y = int208(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt216(int256 x) internal pure returns (int216) {\n        int216 y = int216(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt224(int256 x) internal pure returns (int224) {\n        int224 y = int224(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt232(int256 x) internal pure returns (int232) {\n        int232 y = int232(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt240(int256 x) internal pure returns (int240) {\n        int240 y = int240(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    function toInt248(int256 x) internal pure returns (int248) {\n        int248 y = int248(x);\n        if (x != y) _revertOverflow();\n        return y;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*         UNSIGNED TO SIGNED SAFE CASTING OPERATIONS         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    function toInt256(uint256 x) internal pure returns (int256) {\n        if (x >= 1 << 255) _revertOverflow();\n        return int256(x);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    function _revertOverflow() private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Store the function selector of `Overflow()`.\n            mstore(0x00, 0x35278d12)\n            // Revert with (offset, size).\n            revert(0x1c, 0x04)\n        }\n    }\n}\n"

    },

    "lib/splits-utils/src/WalletImpl.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\nimport {ERC1155TokenReceiver} from \"solmate/tokens/ERC1155.sol\";\nimport {ERC721TokenReceiver} from \"solmate/tokens/ERC721.sol\";\n\nimport {OwnableImpl} from \"./OwnableImpl.sol\";\n\n/// @title Wallet Implementation\n/// @author 0xSplits\n/// @notice Minimal smart wallet clone-implementation\nabstract contract WalletImpl is OwnableImpl, ERC721TokenReceiver, ERC1155TokenReceiver {\n    struct Call {\n        address to;\n        uint256 value;\n        bytes data;\n    }\n\n    event ExecCalls(Call[] calls);\n\n    /// -----------------------------------------------------------------------\n    /// storage - mutables\n    /// -----------------------------------------------------------------------\n\n    /// slot 0 - 12 bytes free\n\n    /// OwnableImpl storage\n    /// address internal $owner;\n    /// 20 bytes\n\n    /// -----------------------------------------------------------------------\n    /// constructor & initializer\n    /// -----------------------------------------------------------------------\n\n    constructor() {}\n\n    function __initWallet(address owner_) internal {\n        OwnableImpl.__initOwnable(owner_);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// functions - external & public - onlyOwner\n    /// -----------------------------------------------------------------------\n\n    /// allow owner to execute arbitrary calls\n    function execCalls(Call[] calldata calls_)\n        external\n        payable\n        onlyOwner\n        returns (uint256 blockNumber, bytes[] memory returnData)\n    {\n        blockNumber = block.number;\n        uint256 length = calls_.length;\n        returnData = new bytes[](length);\n\n        bool success;\n        for (uint256 i; i < length;) {\n            Call calldata calli = calls_[i];\n            (success, returnData[i]) = calli.to.call{value: calli.value}(calli.data);\n            require(success, string(returnData[i]));\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ExecCalls(calls_);\n    }\n}\n"

    },

    "src/libraries/PairScaledOfferFactors.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\nimport {QuotePair, SortedQuotePair} from \"splits-utils/LibQuotes.sol\";\n\nimport {SwapperImpl} from \"../SwapperImpl.sol\";\n\n/// @title PairScaledOfferFactors Library\n/// @author 0xSplits\n/// @notice Setters & getters for quote pairs' scaledOfferFactors\nlibrary PairScaledOfferFactors {\n    /// set pairs' scaled offer factors\n    function _set(\n        mapping(address => mapping(address => uint32)) storage self,\n        SwapperImpl.SetPairScaledOfferFactorParams[] calldata params_\n    ) internal {\n        uint256 length = params_.length;\n        for (uint256 i; i < length;) {\n            _set(self, params_[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// set pair's scaled offer factor\n    function _set(\n        mapping(address => mapping(address => uint32)) storage self,\n        SwapperImpl.SetPairScaledOfferFactorParams calldata params_\n    ) internal {\n        SortedQuotePair memory sqp = params_.quotePair._sort();\n        self[sqp.token0][sqp.token1] = params_.scaledOfferFactor;\n    }\n\n    /// get pair's scaled offer factor\n    function _get(mapping(address => mapping(address => uint32)) storage self, QuotePair calldata quotePair_)\n        internal\n        view\n        returns (uint32)\n    {\n        return _get(self, quotePair_._sort());\n    }\n\n    /// get pair's scaled offer factor\n    function _get(mapping(address => mapping(address => uint32)) storage self, SortedQuotePair memory sqp_)\n        internal\n        view\n        returns (uint32)\n    {\n        return self[sqp_.token0][sqp_.token1];\n    }\n}\n"

    },

    "lib/splits-oracle/src/peripherals/OracleParams.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\nimport {AddressUtils} from \"splits-utils/AddressUtils.sol\";\n\nimport {IOracle} from \"../interfaces/IOracle.sol\";\nimport {IOracleFactory} from \"../interfaces/IOracleFactory.sol\";\n\nusing {_parseIntoOracle} for OracleParams global;\n\nusing AddressUtils for address;\n\nstruct OracleParams {\n    IOracle oracle;\n    CreateOracleParams createOracleParams;\n}\n\nstruct CreateOracleParams {\n    IOracleFactory factory;\n    bytes data;\n}\n\nfunction _parseIntoOracle(OracleParams calldata oracleParams_) returns (IOracle) {\n    if (address(oracleParams_.oracle)._isNotEmpty()) {\n        return oracleParams_.oracle;\n    } else {\n        // if oracle not provided, create one with provided params\n        CreateOracleParams calldata createOracleParams = oracleParams_.createOracleParams;\n        return createOracleParams.factory.createOracle(createOracleParams.data);\n    }\n}\n"

    },

    "lib/splits-utils/src/LibClone.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\n/// @title Modified minimal proxy\n/// @author 0xSplits\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibClone.sol)\n/// @dev Modified minimal proxy includes a `receive()` method that emits the\n/// `ReceiveETH(uint256)` event to skip `DELEGATECALL` when there is no calldata.\n/// Enables us to accept hard gas-capped `sends` & `transfers` for maximum backwards\n/// composability.\nlibrary LibClone {\n    error DeploymentFailed();\n\n    uint256 private constant FREE_PTR = 0x40;\n    uint256 private constant ZERO_PTR = 0x60;\n\n    /// @dev Deploys a modified minimal proxy of `implementation`\n    function clone(address implementation) internal returns (address instance) {\n        assembly (\"memory-safe\") {\n            /**\n             * --------------------------------------------------------------------------+\n             * CREATION (9 bytes - 0x09)                                                 |\n             * --------------------------------------------------------------------------|\n             * Opcode     | Mnemonic          | Stack     | Memory                       |\n             * --------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize     | r         |                              |\n             * 3d         | RETURNDATASIZE    | 0 r       |                              |\n             * 81         | DUP2              | r 0 r     |                              |\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                              |\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                              |\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |\n             * f3         | RETURN            |           | [0..runSize): runtime code   |\n             * --------------------------------------------------------------------------|\n             * RUNTIME (89 bytes - 0x59)                                                 |\n             * --------------------------------------------------------------------------|\n             * Opcode  | Mnemonic       | Stack                  | Memory                |\n             * --------------------------------------------------------------------------|\n             *                                                                           |\n             * 36      | CALLDATASIZE   | cds                    |                       |\n             * 60 0x2c | PUSH1 0x2c     | 0x2c cds               |                       |\n             * 57      | JUMPI          |                        |                       |\n             * 34      | CALLVALUE      | cv                     |                       |\n             * 3d      | RETURNDATASIZE | 0 cv                   |                       |\n             * 52      | MSTORE         |                        | [0..0x20): callvalue  |\n             * 7f sig  | PUSH32 0x9e..  | sig                    | [0..0x20): callvalue  |\n             * 59      | MSIZE          | 0x20 sig               | [0..0x20): callvalue  |\n             * 3d      | RETURNDATASIZE | 0 0x20 sig             | [0..0x20): callvalue  |\n             * a1      | LOG1           |                        | [0..0x20): callvalue  |\n             * 00      | STOP           |                        | [0..0x20): callvalue  |\n             * 5b      | JUMPDEST       |                        |                       |\n             *                                                                           |\n             * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | 0                      |                       |\n             * 3d      | RETURNDATASIZE | 0 0                    |                       |\n             * 3d      | RETURNDATASIZE | 0 0 0                  |                       |\n             * 3d      | RETURNDATASIZE | 0 0 0 0                |                       |\n             *                                                                           |\n             * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            |                       |\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          |                       |\n             * 3d      | RETURNDATASIZE | 0 0 cds 0 0 0 0        |                       |\n             * 37      | CALLDATACOPY   | 0 0 0 0                | [0..cds): calldata    |\n             *                                                                           |\n             * ::: delegate call to the implementation contract :::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            | [0..cds): calldata    |\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          | [0..cds): calldata    |\n             * 73 addr | PUSH20 addr    | addr 0 cds 0 0 0 0     | [0..cds): calldata    |\n             * 5a      | GAS            | gas addr 0 cds 0 0 0 0 | [0..cds): calldata    |\n             * f4      | DELEGATECALL   | success 0 0            | [0..cds): calldata    |\n             *                                                                           |\n             * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | rds success 0 0        | [0..cds): calldata    |\n             * 3d      | RETURNDATASIZE | rds rds success 0 0    | [0..cds): calldata    |\n             * 93      | SWAP4          | 0 rds success 0 rds    | [0..cds): calldata    |\n             * 80      | DUP1           | 0 0 rds success 0 rds  | [0..cds): calldata    |\n             * 3e      | RETURNDATACOPY | success 0 rds          | [0..rds): returndata  |\n             *                                                                           |\n             * 60 0x57 | PUSH1 0x57     | 0x57 success 0 rds     | [0..rds): returndata  |\n             * 57      | JUMPI          | 0 rds                  | [0..rds): returndata  |\n             *                                                                           |\n             * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * fd      | REVERT         |                        | [0..rds): returndata  |\n             *                                                                           |\n             * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b      | JUMPDEST       | 0 rds                  | [0..rds): returndata  |\n             * f3      | RETURN         |                        | [0..rds): returndata  |\n             * --------------------------------------------------------------------------+\n             * TOTAL INIT (98 bytes - 0x62)                                                 |\n             * --------------------------------------------------------------------------|\n             */\n\n            // save free pointer\n            let fp := mload(FREE_PTR)\n\n            mstore(0x51, 0x5af43d3d93803e605757fd5bf3) // 13 bytes\n            mstore(0x44, implementation) // 20 bytes\n            mstore(0x30, 0x593da1005b3d3d3d3d363d3d37363d73) // 16 bytes\n            // `keccak256(\"ReceiveETH(uint256)\")`\n            mstore(0x20, 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff) // 32 bytes\n            mstore(0x00, 0x60593d8160093d39f336602c57343d527f) // 17 bytes\n\n            // total: 113 bytes = 0x71\n            // offset: 15 bytes = 0x0f\n            // data: 98 bytes = 0x62\n            instance := create(0, 0x0f, 0x71)\n\n            // restore free pointer, zero slot\n            mstore(FREE_PTR, fp)\n            mstore(ZERO_PTR, 0)\n\n            // If `instance` is zero, revert.\n            if iszero(instance) {\n                // Store the function selector of `DeploymentFailed()`.\n                mstore(0x00, 0x30116425)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n}\n"

    },

    "lib/splits-utils/src/OwnableImpl.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\n/// @title Ownable Implementation\n/// @author 0xSplits\n/// @notice Ownable clone-implementation\nabstract contract OwnableImpl {\n    error Unauthorized();\n\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\n\n    /// -----------------------------------------------------------------------\n    /// storage - mutables\n    /// -----------------------------------------------------------------------\n\n    /// slot 0 - 12 bytes free\n\n    address internal $owner;\n    /// 20 bytes\n\n    /// -----------------------------------------------------------------------\n    /// constructor & initializer\n    /// -----------------------------------------------------------------------\n\n    constructor() {}\n\n    function __initOwnable(address owner_) internal virtual {\n        emit OwnershipTransferred(address(0), owner_);\n        $owner = owner_;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// modifiers\n    /// -----------------------------------------------------------------------\n\n    modifier onlyOwner() virtual {\n        if (msg.sender != owner()) revert Unauthorized();\n        _;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// functions - public & external - onlyOwner\n    /// -----------------------------------------------------------------------\n\n    function transferOwnership(address owner_) public virtual onlyOwner {\n        $owner = owner_;\n        emit OwnershipTransferred(msg.sender, owner_);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// functions - public & external - view\n    /// -----------------------------------------------------------------------\n\n    function owner() public view virtual returns (address) {\n        return $owner;\n    }\n}\n"

    },

    "lib/solmate/src/tokens/ERC1155.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Minimalist and gas efficient standard ERC1155 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\nabstract contract ERC1155 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event TransferSingle(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 id,\n        uint256 amount\n    );\n\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] amounts\n    );\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    event URI(string value, uint256 indexed id);\n\n    /*//////////////////////////////////////////////////////////////\n                             ERC1155 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                             METADATA LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function uri(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC1155 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n\n        balanceOf[from][id] -= amount;\n        balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, from, to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        require(ids.length == amounts.length, \"LENGTH_MISMATCH\");\n\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \"NOT_AUTHORIZED\");\n\n        // Storing these outside the loop saves ~15 gas per iteration.\n        uint256 id;\n        uint256 amount;\n\n        for (uint256 i = 0; i < ids.length; ) {\n            id = ids[i];\n            amount = amounts[i];\n\n            balanceOf[from][id] -= amount;\n            balanceOf[to][id] += amount;\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\n        public\n        view\n        virtual\n        returns (uint256[] memory balances)\n    {\n        require(owners.length == ids.length, \"LENGTH_MISMATCH\");\n\n        balances = new uint256[](owners.length);\n\n        // Unchecked because the only math done is incrementing\n        // the array index counter which cannot possibly overflow.\n        unchecked {\n            for (uint256 i = 0; i < owners.length; ++i) {\n                balances[i] = balanceOf[owners[i]][ids[i]];\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        balanceOf[to][id] += amount;\n\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\n                    ERC1155TokenReceiver.onERC1155Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _batchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[to][ids[i]] += amounts[i];\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\n\n        require(\n            to.code.length == 0\n                ? to != address(0)\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _batchBurn(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        uint256 idsLength = ids.length; // Saves MLOADs.\n\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\n\n        for (uint256 i = 0; i < idsLength; ) {\n            balanceOf[from][ids[i]] -= amounts[i];\n\n            // An array can't have a total length\n            // larger than the max uint256 value.\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\n    }\n\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        balanceOf[from][id] -= amount;\n\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC1155 tokens.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC1155.sol)\nabstract contract ERC1155TokenReceiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\n    }\n}\n"

    },

    "lib/solmate/src/tokens/ERC721.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*//////////////////////////////////////////////////////////////\n                         METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) internal _ownerOf;\n\n    mapping(address => uint256) internal _balanceOf;\n\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\n    }\n\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), \"ZERO_ADDRESS\");\n\n        return _balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            _balanceOf[from]--;\n\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n\n        require(owner != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            _balanceOf[owner]--;\n        }\n\n        delete _ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721TokenReceiver {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n"

    },

    "lib/splits-utils/src/AddressUtils.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\naddress constant ADDRESS_ZERO = address(0);\n\nlibrary AddressUtils {\n    function _isEmpty(address addr) internal pure returns (bool) {\n        return (addr == ADDRESS_ZERO);\n    }\n\n    function _isNotEmpty(address addr) internal pure returns (bool) {\n        return (addr != ADDRESS_ZERO);\n    }\n}\n"

    },

    "lib/splits-oracle/src/interfaces/IOracleFactory.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.17;\n\nimport {IOracle} from \"./IOracle.sol\";\n\n/// @title Oracle factory interface\ninterface IOracleFactory {\n    function createOracle(bytes calldata data_) external returns (IOracle);\n}\n"

    }

  },

  "settings": {

    "remappings": [

      "@uniswap/v3-core/=lib/splits-oracle/lib/v3-core/",

      "@uniswap/v3-periphery/=lib/v3-periphery/",

      "chainlink/=lib/splits-oracle/lib/chainlink/contracts/src/v0.8/",

      "ds-test/=lib/forge-std/lib/ds-test/src/",

      "forge-std/=lib/forge-std/src/",

      "solady/=lib/solady/src/",

      "solmate/=lib/solmate/src/",

      "splits-oracle/=lib/splits-oracle/src/",

      "splits-tests/=lib/splits-utils/test/",

      "splits-utils/=lib/splits-utils/src/",

      "v3-core/=lib/splits-oracle/lib/v3-core/contracts/",

      "v3-periphery/=lib/v3-periphery/contracts/"

    ],

    "optimizer": {

      "enabled": true,

      "runs": 1000000

    },

    "metadata": {

      "bytecodeHash": "ipfs"

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "evmVersion": "london",

    "libraries": {}

  }

}}