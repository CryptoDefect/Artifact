{{

  "language": "Solidity",

  "sources": {

    "contracts/interfaces/node/IStafiNodeManager.sol": {

      "content": "pragma solidity 0.7.6;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface IStafiNodeManager {\n    function getNodeCount() external view returns (uint256);\n    function getNodeAt(uint256 _index) external view returns (address);\n    function getTrustedNodeCount() external view returns (uint256);\n    function getTrustedNodeAt(uint256 _index) external view returns (address);\n    function getSuperNodeCount() external view returns (uint256);\n    function getSuperNodeAt(uint256 _index) external view returns (address);\n    function getNodeExists(address _nodeAddress) external view returns (bool);\n    function getNodeTrusted(address _nodeAddress) external view returns (bool);\n    function getSuperNodeExists(address _nodeAddress) external view returns (bool);\n    function registerNode(address _nodeAddress) external;\n    function setNodeTrusted(address _nodeAddress, bool _trusted) external;\n    function setNodeSuper(address _nodeAddress, bool _super) external;\n}\n"

    },

    "contracts/interfaces/storage/IAddressSetStorage.sol": {

      "content": "pragma solidity 0.7.6;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface IAddressSetStorage {\n    function getCount(bytes32 _key) external view returns (uint256);\n    function getItem(bytes32 _key, uint256 _index) external view returns (address);\n    function getIndexOf(bytes32 _key, address _value) external view returns (int256);\n    function addItem(bytes32 _key, address _value) external;\n    function removeItem(bytes32 _key, address _value) external;\n}\n"

    },

    "contracts/interfaces/storage/IStafiStorage.sol": {

      "content": "pragma solidity 0.7.6;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface IStafiStorage {\n\n    // Getters\n    function getAddress(bytes32 _key) external view returns (address);\n    function getUint(bytes32 _key) external view returns (uint);\n    function getString(bytes32 _key) external view returns (string memory);\n    function getBytes(bytes32 _key) external view returns (bytes memory);\n    function getBool(bytes32 _key) external view returns (bool);\n    function getInt(bytes32 _key) external view returns (int);\n    function getBytes32(bytes32 _key) external view returns (bytes32);\n\n    // Setters\n    function setAddress(bytes32 _key, address _value) external;\n    function setUint(bytes32 _key, uint _value) external;\n    function setString(bytes32 _key, string calldata _value) external;\n    function setBytes(bytes32 _key, bytes calldata _value) external;\n    function setBool(bytes32 _key, bool _value) external;\n    function setInt(bytes32 _key, int _value) external;\n    function setBytes32(bytes32 _key, bytes32 _value) external;\n\n    // Deleters\n    function deleteAddress(bytes32 _key) external;\n    function deleteUint(bytes32 _key) external;\n    function deleteString(bytes32 _key) external;\n    function deleteBytes(bytes32 _key) external;\n    function deleteBool(bytes32 _key) external;\n    function deleteInt(bytes32 _key) external;\n    function deleteBytes32(bytes32 _key) external;\n\n}\n"

    },

    "contracts/node/StafiNodeManager.sol": {

      "content": "pragma solidity 0.7.6;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"../StafiBase.sol\";\nimport \"../interfaces/node/IStafiNodeManager.sol\";\nimport \"../interfaces/storage/IAddressSetStorage.sol\";\n\n// Node registration and management\ncontract StafiNodeManager is StafiBase, IStafiNodeManager {\n\n    // Events\n    event NodeRegistered(address indexed node, uint256 time);\n    event NodeTrustedSet(address indexed node, bool trusted, uint256 time);\n    event NodeSuperSet(address indexed node, bool trusted, uint256 time);\n\n    // Construct\n    constructor(address _stafiStorageAddress) StafiBase(_stafiStorageAddress) {\n        version = 1;\n    }\n\n    // Get the number of nodes in the network\n    function getNodeCount() override public view returns (uint256) {\n        IAddressSetStorage addressSetStorage = IAddressSetStorage(getContractAddress(\"addressSetStorage\"));\n        return addressSetStorage.getCount(keccak256(abi.encodePacked(\"nodes.index\")));\n    }\n\n    // Get a node address by index\n    function getNodeAt(uint256 _index) override public view returns (address) {\n        IAddressSetStorage addressSetStorage = IAddressSetStorage(getContractAddress(\"addressSetStorage\"));\n        return addressSetStorage.getItem(keccak256(abi.encodePacked(\"nodes.index\")), _index);\n    }\n\n    // Get the number of trusted nodes in the network\n    function getTrustedNodeCount() override public view returns (uint256) {\n        IAddressSetStorage addressSetStorage = IAddressSetStorage(getContractAddress(\"addressSetStorage\"));\n        return addressSetStorage.getCount(keccak256(abi.encodePacked(\"nodes.trusted.index\")));\n    }\n\n    // Get a trusted node address by index\n    function getTrustedNodeAt(uint256 _index) override public view returns (address) {\n        IAddressSetStorage addressSetStorage = IAddressSetStorage(getContractAddress(\"addressSetStorage\"));\n        return addressSetStorage.getItem(keccak256(abi.encodePacked(\"nodes.trusted.index\")), _index);\n    }\n\n    // Check whether a node exists\n    function getNodeExists(address _nodeAddress) override public view returns (bool) {\n        return getBool(keccak256(abi.encodePacked(\"node.exists\", _nodeAddress)));\n    }\n\n    // Check whether a node is trusted\n    function getNodeTrusted(address _nodeAddress) override public view returns (bool) {\n        return getBool(keccak256(abi.encodePacked(\"node.trusted\", _nodeAddress)));\n    }\n\n    // Get the number of super nodes in the network\n    function getSuperNodeCount() override public view returns (uint256) {\n        IAddressSetStorage addressSetStorage = IAddressSetStorage(getContractAddress(\"addressSetStorage\"));\n        return addressSetStorage.getCount(keccak256(abi.encodePacked(\"nodes.super.index\")));\n    }\n\n    // Get a trusted node address by index\n    function getSuperNodeAt(uint256 _index) override public view returns (address) {\n        IAddressSetStorage addressSetStorage = IAddressSetStorage(getContractAddress(\"addressSetStorage\"));\n        return addressSetStorage.getItem(keccak256(abi.encodePacked(\"nodes.super.index\")), _index);\n    }\n\n    // Check whether a node is trusted\n    function getSuperNodeExists(address _nodeAddress) override public view returns (bool) {\n        return getBool(keccak256(abi.encodePacked(\"node.super\", _nodeAddress)));\n    }\n\n    // Register a new node\n    function registerNode(address _nodeAddress) override external onlyLatestContract(\"stafiNodeManager\", address(this)) onlyLatestContract(\"stafiNodeDeposit\", msg.sender) {\n        if (!getBool(keccak256(abi.encodePacked(\"node.exists\", _nodeAddress)))) {\n            // Load contracts\n            IAddressSetStorage addressSetStorage = IAddressSetStorage(getContractAddress(\"addressSetStorage\"));\n            // Initialise node data\n            setBool(keccak256(abi.encodePacked(\"node.exists\", _nodeAddress)), true);\n            setBool(keccak256(abi.encodePacked(\"node.trusted\", _nodeAddress)), false);\n            // Add node to index\n            addressSetStorage.addItem(keccak256(abi.encodePacked(\"nodes.index\")), _nodeAddress);\n            // Emit node registered event\n            emit NodeRegistered(_nodeAddress, block.timestamp);\n        }\n    }\n\n    // Set a node's trusted status\n    // Only accepts calls from super users\n    function setNodeTrusted(address _nodeAddress, bool _trusted) override external onlyLatestContract(\"stafiNodeManager\", address(this)) onlySuperUser {\n        // Check current node status\n        require(getBool(keccak256(abi.encodePacked(\"node.trusted\", _nodeAddress))) != _trusted, \"The node's trusted status is already set\");\n        // Load contracts\n        IAddressSetStorage addressSetStorage = IAddressSetStorage(getContractAddress(\"addressSetStorage\"));\n        // Set status\n        setBool(keccak256(abi.encodePacked(\"node.trusted\", _nodeAddress)), _trusted);\n        // Add node to / remove node from trusted index\n        if (_trusted) { addressSetStorage.addItem(keccak256(abi.encodePacked(\"nodes.trusted.index\")), _nodeAddress); }\n        else { addressSetStorage.removeItem(keccak256(abi.encodePacked(\"nodes.trusted.index\")), _nodeAddress); }\n        // Emit node trusted set event\n        emit NodeTrustedSet(_nodeAddress, _trusted, block.timestamp);\n    }\n    \n    // Set a node's super status\n    // Only accepts calls from super users\n    function setNodeSuper(address _nodeAddress, bool _super) override external onlyLatestContract(\"stafiNodeManager\", address(this)) onlySuperUser {\n        // Check current node status\n        require(getBool(keccak256(abi.encodePacked(\"node.super\", _nodeAddress))) != _super, \"The node's super status is already set\");\n        // Load contracts\n        IAddressSetStorage addressSetStorage = IAddressSetStorage(getContractAddress(\"addressSetStorage\"));\n        // Set status\n        setBool(keccak256(abi.encodePacked(\"node.super\", _nodeAddress)), _super);\n        // Add node to / remove node from trusted index\n        if (_super) { addressSetStorage.addItem(keccak256(abi.encodePacked(\"nodes.super.index\")), _nodeAddress); }\n        else { addressSetStorage.removeItem(keccak256(abi.encodePacked(\"nodes.super.index\")), _nodeAddress); }\n        // Emit node trusted set event\n        emit NodeSuperSet(_nodeAddress, _super, block.timestamp);\n    }\n\n}\n"

    },

    "contracts/StafiBase.sol": {

      "content": "pragma solidity 0.7.6;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"./interfaces/storage/IStafiStorage.sol\";\n\nabstract contract StafiBase {\n\n    // Version of the contract\n    uint8 public version;\n\n    // The main storage contract where primary persistant storage is maintained\n    IStafiStorage stafiStorage = IStafiStorage(0);\n\n\n    /**\n    * @dev Throws if called by any sender that doesn't match a network contract\n    */\n    modifier onlyLatestNetworkContract() {\n        require(getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))), \"Invalid or outdated network contract\");\n        _;\n    }\n\n\n    /**\n    * @dev Throws if called by any sender that doesn't match one of the supplied contract or is the latest version of that contract\n    */\n    modifier onlyLatestContract(string memory _contractName, address _contractAddress) {\n        require(_contractAddress == getAddress(keccak256(abi.encodePacked(\"contract.address\", _contractName))), \"Invalid or outdated contract\");\n        _;\n    }\n\n\n    /**\n    * @dev Throws if called by any sender that isn't a trusted node\n    */\n    modifier onlyTrustedNode(address _nodeAddress) {\n        require(getBool(keccak256(abi.encodePacked(\"node.trusted\", _nodeAddress))), \"Invalid trusted node\");\n        _;\n    }\n    \n    /**\n    * @dev Throws if called by any sender that isn't a super node\n    */\n    modifier onlySuperNode(address _nodeAddress) {\n        require(getBool(keccak256(abi.encodePacked(\"node.super\", _nodeAddress))), \"Invalid super node\");\n        _;\n    }\n\n\n    /**\n    * @dev Throws if called by any sender that isn't a registered staking pool\n    */\n    modifier onlyRegisteredStakingPool(address _stakingPoolAddress) {\n        require(getBool(keccak256(abi.encodePacked(\"stakingpool.exists\", _stakingPoolAddress))), \"Invalid staking pool\");\n        _;\n    }\n\n\n    /**\n    * @dev Throws if called by any account other than the owner.\n    */\n    modifier onlyOwner() {\n        require(roleHas(\"owner\", msg.sender), \"Account is not the owner\");\n        _;\n    }\n\n\n    /**\n    * @dev Modifier to scope access to admins\n    */\n    modifier onlyAdmin() {\n        require(roleHas(\"admin\", msg.sender), \"Account is not an admin\");\n        _;\n    }\n\n\n    /**\n    * @dev Modifier to scope access to admins\n    */\n    modifier onlySuperUser() {\n        require(roleHas(\"owner\", msg.sender) || roleHas(\"admin\", msg.sender), \"Account is not a super user\");\n        _;\n    }\n\n\n    /**\n    * @dev Reverts if the address doesn't have this role\n    */\n    modifier onlyRole(string memory _role) {\n        require(roleHas(_role, msg.sender), \"Account does not match the specified role\");\n        _;\n    }\n\n\n    /// @dev Set the main Storage address\n    constructor(address _stafiStorageAddress) {\n        // Update the contract address\n        stafiStorage = IStafiStorage(_stafiStorageAddress);\n    }\n\n\n    /// @dev Get the address of a network contract by name\n    function getContractAddress(string memory _contractName) internal view returns (address) {\n        // Get the current contract address\n        address contractAddress = getAddress(keccak256(abi.encodePacked(\"contract.address\", _contractName)));\n        // Check it\n        require(contractAddress != address(0x0), \"Contract not found\");\n        // Return\n        return contractAddress;\n    }\n\n\n    /// @dev Get the name of a network contract by address\n    function getContractName(address _contractAddress) internal view returns (string memory) {\n        // Get the contract name\n        string memory contractName = getString(keccak256(abi.encodePacked(\"contract.name\", _contractAddress)));\n        // Check it\n        require(keccak256(abi.encodePacked(contractName)) != keccak256(abi.encodePacked(\"\")), \"Contract not found\");\n        // Return\n        return contractName;\n    }\n\n\n    /// @dev Storage get methods\n    function getAddress(bytes32 _key) internal view returns (address) { return stafiStorage.getAddress(_key); }\n    function getUint(bytes32 _key) internal view returns (uint256) { return stafiStorage.getUint(_key); }\n    function getString(bytes32 _key) internal view returns (string memory) { return stafiStorage.getString(_key); }\n    function getBytes(bytes32 _key) internal view returns (bytes memory) { return stafiStorage.getBytes(_key); }\n    function getBool(bytes32 _key) internal view returns (bool) { return stafiStorage.getBool(_key); }\n    function getInt(bytes32 _key) internal view returns (int256) { return stafiStorage.getInt(_key); }\n    function getBytes32(bytes32 _key) internal view returns (bytes32) { return stafiStorage.getBytes32(_key); }\n    function getAddressS(string memory _key) internal view returns (address) { return stafiStorage.getAddress(keccak256(abi.encodePacked(_key))); }\n    function getUintS(string memory _key) internal view returns (uint256) { return stafiStorage.getUint(keccak256(abi.encodePacked(_key))); }\n    function getStringS(string memory _key) internal view returns (string memory) { return stafiStorage.getString(keccak256(abi.encodePacked(_key))); }\n    function getBytesS(string memory _key) internal view returns (bytes memory) { return stafiStorage.getBytes(keccak256(abi.encodePacked(_key))); }\n    function getBoolS(string memory _key) internal view returns (bool) { return stafiStorage.getBool(keccak256(abi.encodePacked(_key))); }\n    function getIntS(string memory _key) internal view returns (int256) { return stafiStorage.getInt(keccak256(abi.encodePacked(_key))); }\n    function getBytes32S(string memory _key) internal view returns (bytes32) { return stafiStorage.getBytes32(keccak256(abi.encodePacked(_key))); }\n\n    /// @dev Storage set methods\n    function setAddress(bytes32 _key, address _value) internal { stafiStorage.setAddress(_key, _value); }\n    function setUint(bytes32 _key, uint256 _value) internal { stafiStorage.setUint(_key, _value); }\n    function setString(bytes32 _key, string memory _value) internal { stafiStorage.setString(_key, _value); }\n    function setBytes(bytes32 _key, bytes memory _value) internal { stafiStorage.setBytes(_key, _value); }\n    function setBool(bytes32 _key, bool _value) internal { stafiStorage.setBool(_key, _value); }\n    function setInt(bytes32 _key, int256 _value) internal { stafiStorage.setInt(_key, _value); }\n    function setBytes32(bytes32 _key, bytes32 _value) internal { stafiStorage.setBytes32(_key, _value); }\n    function setAddressS(string memory _key, address _value) internal { stafiStorage.setAddress(keccak256(abi.encodePacked(_key)), _value); }\n    function setUintS(string memory _key, uint256 _value) internal { stafiStorage.setUint(keccak256(abi.encodePacked(_key)), _value); }\n    function setStringS(string memory _key, string memory _value) internal { stafiStorage.setString(keccak256(abi.encodePacked(_key)), _value); }\n    function setBytesS(string memory _key, bytes memory _value) internal { stafiStorage.setBytes(keccak256(abi.encodePacked(_key)), _value); }\n    function setBoolS(string memory _key, bool _value) internal { stafiStorage.setBool(keccak256(abi.encodePacked(_key)), _value); }\n    function setIntS(string memory _key, int256 _value) internal { stafiStorage.setInt(keccak256(abi.encodePacked(_key)), _value); }\n    function setBytes32S(string memory _key, bytes32 _value) internal { stafiStorage.setBytes32(keccak256(abi.encodePacked(_key)), _value); }\n\n    /// @dev Storage delete methods\n    function deleteAddress(bytes32 _key) internal { stafiStorage.deleteAddress(_key); }\n    function deleteUint(bytes32 _key) internal { stafiStorage.deleteUint(_key); }\n    function deleteString(bytes32 _key) internal { stafiStorage.deleteString(_key); }\n    function deleteBytes(bytes32 _key) internal { stafiStorage.deleteBytes(_key); }\n    function deleteBool(bytes32 _key) internal { stafiStorage.deleteBool(_key); }\n    function deleteInt(bytes32 _key) internal { stafiStorage.deleteInt(_key); }\n    function deleteBytes32(bytes32 _key) internal { stafiStorage.deleteBytes32(_key); }\n    function deleteAddressS(string memory _key) internal { stafiStorage.deleteAddress(keccak256(abi.encodePacked(_key))); }\n    function deleteUintS(string memory _key) internal { stafiStorage.deleteUint(keccak256(abi.encodePacked(_key))); }\n    function deleteStringS(string memory _key) internal { stafiStorage.deleteString(keccak256(abi.encodePacked(_key))); }\n    function deleteBytesS(string memory _key) internal { stafiStorage.deleteBytes(keccak256(abi.encodePacked(_key))); }\n    function deleteBoolS(string memory _key) internal { stafiStorage.deleteBool(keccak256(abi.encodePacked(_key))); }\n    function deleteIntS(string memory _key) internal { stafiStorage.deleteInt(keccak256(abi.encodePacked(_key))); }\n    function deleteBytes32S(string memory _key) internal { stafiStorage.deleteBytes32(keccak256(abi.encodePacked(_key))); }\n\n\n    /**\n    * @dev Check if an address has this role\n    */\n    function roleHas(string memory _role, address _address) internal view returns (bool) {\n        return getBool(keccak256(abi.encodePacked(\"access.role\", _role, _address)));\n    }\n\n}\n"

    }

  },

  "settings": {

    "optimizer": {

      "enabled": false,

      "runs": 200

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "libraries": {}

  }

}}