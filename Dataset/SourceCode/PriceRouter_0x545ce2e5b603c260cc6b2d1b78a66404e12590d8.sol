{{

  "language": "Solidity",

  "sources": {

    "lib/chainlink/contracts/src/v0.8/interfaces/AggregatorInterface.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorInterface {\n  function latestAnswer() external view returns (int256);\n\n  function latestTimestamp() external view returns (uint256);\n\n  function latestRound() external view returns (uint256);\n\n  function getAnswer(uint256 roundId) external view returns (int256);\n\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"

    },

    "lib/chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./AggregatorInterface.sol\";\nimport \"./AggregatorV3Interface.sol\";\n\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\n"

    },

    "lib/chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"

    },

    "lib/chainlink/contracts/src/v0.8/interfaces/AutomationCompatibleInterface.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AutomationCompatibleInterface {\n  /**\n   * @notice method that is simulated by the keepers to see if any work actually\n   * needs to be performed. This method does does not actually need to be\n   * executable, and since it is only ever simulated it can consume lots of gas.\n   * @dev To ensure that it is never called, you may want to add the\n   * cannotExecute modifier from KeeperBase to your implementation of this\n   * method.\n   * @param checkData specified in the upkeep registration so it is always the\n   * same for a registered upkeep. This can easily be broken down into specific\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\n   * same contract and easily differentiated by the contract.\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\n   * performUpkeep or not.\n   * @return performData bytes that the keeper should call performUpkeep with, if\n   * upkeep is needed. If you would like to encode data to decode later, try\n   * `abi.encode`.\n   */\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\n\n  /**\n   * @notice method that is actually executed by the keepers, via the registry.\n   * The data returned by the checkUpkeep simulation will be passed into\n   * this method to actually be executed.\n   * @dev The input to this method should not be trusted, and the caller of the\n   * method should not even be restricted to any single registry. Anyone should\n   * be able call it, and the input should be validated, there is no guarantee\n   * that the data passed in is the performData returned from checkUpkeep. This\n   * could happen due to malicious keepers, racing keepers, or simply a state\n   * change while the performUpkeep transaction is waiting for confirmation.\n   * Always validate the data passed in.\n   * @param performData is the data which was passed back from the checkData\n   * simulation. If it is encoded, it can easily be decoded into other types by\n   * calling `abi.decode`. This data should not be trusted, and should be\n   * validated against the contract's current state.\n   */\n  function performUpkeep(bytes calldata performData) external;\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/access/Ownable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/utils/Address.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/utils/Context.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"

    },

    "src/base/ERC20.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal INITIAL_CHAIN_ID;\n\n    bytes32 internal INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"

    },

    "src/base/ERC4626.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport { ERC20 } from \"src/base/ERC20.sol\";\nimport { SafeTransferLib } from \"src/base/SafeTransferLib.sol\";\nimport { Math } from \"src/utils/Math.sol\";\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/mixins/ERC4626.sol)\nabstract contract ERC4626 is ERC20 {\n    using SafeTransferLib for ERC20;\n    using Math for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    ERC20 public asset;\n\n    constructor(\n        ERC20 _asset,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) ERC20(_name, _symbol, _decimals) {\n        asset = _asset;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n        beforeDeposit(assets, shares, receiver);\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares, receiver);\n    }\n\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        beforeDeposit(assets, shares, receiver);\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares, receiver);\n    }\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 shares) {\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        beforeWithdraw(assets, shares, receiver, owner);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n\n        afterWithdraw(assets, shares, receiver, owner);\n    }\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 assets) {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        beforeWithdraw(assets, shares, receiver, owner);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n\n        afterWithdraw(assets, shares, receiver, owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function totalAssets() public view virtual returns (uint256);\n\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n    }\n\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n    }\n\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return convertToAssets(balanceOf[owner]);\n    }\n\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function beforeDeposit(\n        uint256 assets,\n        uint256 shares,\n        address receiver\n    ) internal virtual {}\n\n    function afterDeposit(\n        uint256 assets,\n        uint256 shares,\n        address receiver\n    ) internal virtual {}\n\n    function beforeWithdraw(\n        uint256 assets,\n        uint256 shares,\n        address receiver,\n        address owner\n    ) internal virtual {}\n\n    function afterWithdraw(\n        uint256 assets,\n        uint256 shares,\n        address receiver,\n        address owner\n    ) internal virtual {}\n}\n"

    },

    "src/base/SafeTransferLib.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport { ERC20 } from \"src/base/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) // Append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"

    },

    "src/interfaces/external/IAaveToken.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IAaveToken {\n    function UNDERLYING_ASSET_ADDRESS() external view returns (address);\n}\n"

    },

    "src/interfaces/external/IChainlinkAggregator.sol": {

      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.16;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\";\n\ninterface IChainlinkAggregator is AggregatorV2V3Interface {\n    function maxAnswer() external view returns (int192);\n\n    function minAnswer() external view returns (int192);\n\n    function aggregator() external view returns (address);\n}\n"

    },

    "src/interfaces/external/ICurvePool.sol": {

      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.16;\n\ninterface ICurvePool {\n    function coins(uint256 i) external view returns (address);\n\n    function get_virtual_price() external view returns (uint256);\n\n    function claim_admin_fees() external; // For USDT/WETH/WBTC\n\n    function withdraw_admin_fees() external;\n\n    function gamma() external view returns (uint256);\n\n    function A() external view returns (uint256);\n\n    function lp_price() external view returns (uint256);\n\n    function price_oracle() external view returns (uint256);\n\n    function price_oracle(uint256 i) external view returns (uint256);\n}\n"

    },

    "src/modules/price-router/PriceRouter.sol": {

      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.16;\n\nimport { ERC20, SafeTransferLib } from \"src/base/ERC4626.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { AutomationCompatibleInterface } from \"@chainlink/contracts/src/v0.8/interfaces/AutomationCompatibleInterface.sol\";\nimport { IChainlinkAggregator } from \"src/interfaces/external/IChainlinkAggregator.sol\";\nimport { SafeCast } from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport { Math } from \"src/utils/Math.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { ICurvePool } from \"src/interfaces/external/ICurvePool.sol\";\nimport { IAaveToken } from \"src/interfaces/external/IAaveToken.sol\";\n\n/**\n * @title Sommelier Price Router\n * @notice Provides a universal interface allowing Sommelier contracts to retrieve secure pricing\n *         data from Chainlink.\n * @author crispymangoes, Brian Le\n */\ncontract PriceRouter is Ownable, AutomationCompatibleInterface {\n    using SafeTransferLib for ERC20;\n    using SafeCast for int256;\n    using Math for uint256;\n    using Address for address;\n\n    event AddAsset(address indexed asset);\n\n    // =========================================== ASSETS CONFIG ===========================================\n    /**\n     * @notice Bare minimum settings all derivatives support.\n     * @param derivative the derivative used to price the asset\n     * @param source the address used to price the asset\n     */\n    struct AssetSettings {\n        uint8 derivative;\n        address source;\n    }\n\n    /**\n     * @notice Mapping between an asset to price and its `AssetSettings`.\n     */\n    mapping(ERC20 => AssetSettings) public getAssetSettings;\n\n    // ======================================= ADAPTOR OPERATIONS =======================================\n\n    /**\n     * @notice Attempted to set a minimum price below the Chainlink minimum price (with buffer).\n     * @param minPrice minimum price attempted to set\n     * @param bufferedMinPrice minimum price that can be set including buffer\n     */\n    error PriceRouter__InvalidMinPrice(uint256 minPrice, uint256 bufferedMinPrice);\n\n    /**\n     * @notice Attempted to set a maximum price above the Chainlink maximum price (with buffer).\n     * @param maxPrice maximum price attempted to set\n     * @param bufferedMaxPrice maximum price that can be set including buffer\n     */\n    error PriceRouter__InvalidMaxPrice(uint256 maxPrice, uint256 bufferedMaxPrice);\n\n    /**\n     * @notice Attempted to add an invalid asset.\n     * @param asset address of the invalid asset\n     */\n    error PriceRouter__InvalidAsset(address asset);\n\n    /**\n     * @notice Attempted to add an asset, but actual answer was outside range of expectedAnswer.\n     */\n    error PriceRouter__BadAnswer(uint256 answer, uint256 expectedAnswer);\n\n    /**\n     * @notice Attempted to perform an operation using an unkown derivative.\n     */\n    error PriceRouter__UnkownDerivative(uint8 unkownDerivative);\n\n    /**\n     * @notice Attempted to add an asset with invalid min/max prices.\n     * @param min price\n     * @param max price\n     */\n    error PriceRouter__MinPriceGreaterThanMaxPrice(uint256 min, uint256 max);\n\n    /**\n     * @notice The allowed deviation between the expected answer vs the actual answer.\n     */\n    uint256 public constant EXPECTED_ANSWER_DEVIATION = 0.02e18;\n\n    /**\n     * @notice Stores pricing information during calls.\n     * @param asset the address of the asset\n     * @param price the USD price of the asset\n     * @dev If the price does not fit into a uint96, the asset is NOT added to the cache.\n     */\n    struct PriceCache {\n        address asset;\n        uint96 price;\n    }\n\n    /**\n     * @notice The size of the price cache. A larger cache can hold more values,\n     *         but incurs a larger gas cost overhead. A smaller cache has a\n     *         smaller gas overhead but caches less prices.\n     */\n    uint8 private constant PRICE_CACHE_SIZE = 8;\n\n    /**\n     * @notice Allows owner to add assets to the price router.\n     * @dev Performs a sanity check by comparing the price router computed price to\n     * a user input `_expectedAnswer`.\n     * @param _asset the asset to add to the pricing router\n     * @param _settings the settings for `_asset`\n     *        @dev The `derivative` value in settings MUST be non zero.\n     * @param _storage arbitrary bytes data used to configure `_asset` pricing\n     * @param _expectedAnswer the expected answer for the asset from  `_getPriceInUSD`\n     */\n    function addAsset(\n        ERC20 _asset,\n        AssetSettings memory _settings,\n        bytes memory _storage,\n        uint256 _expectedAnswer\n    ) external onlyOwner {\n        if (address(_asset) == address(0)) revert PriceRouter__InvalidAsset(address(_asset));\n        // Zero is an invalid derivative.\n        if (_settings.derivative == 0) revert PriceRouter__UnkownDerivative(_settings.derivative);\n\n        // Call setup function for appropriate derivative.\n        if (_settings.derivative == 1) {\n            _setupPriceForChainlinkDerivative(_asset, _settings.source, _storage);\n        } else if (_settings.derivative == 2) {\n            _setupPriceForCurveDerivative(_asset, _settings.source, _storage);\n        } else if (_settings.derivative == 3) {\n            _setupPriceForCurveV2Derivative(_asset, _settings.source, _storage);\n        } else if (_settings.derivative == 4) {\n            _setupPriceForAaveDerivative(_asset, _settings.source, _storage);\n        } else revert PriceRouter__UnkownDerivative(_settings.derivative);\n\n        // Check `_getPriceInUSD` against `_expectedAnswer`.\n        uint256 minAnswer = _expectedAnswer.mulWadDown((1e18 - EXPECTED_ANSWER_DEVIATION));\n        uint256 maxAnswer = _expectedAnswer.mulWadDown((1e18 + EXPECTED_ANSWER_DEVIATION));\n        // Create an empty Price Cache.\n        PriceCache[PRICE_CACHE_SIZE] memory cache;\n        getAssetSettings[_asset] = _settings;\n        uint256 answer = _getPriceInUSD(_asset, _settings, cache);\n        if (answer < minAnswer || answer > maxAnswer) revert PriceRouter__BadAnswer(answer, _expectedAnswer);\n\n        emit AddAsset(address(_asset));\n    }\n\n    /**\n     * @notice return bool indicating whether or not an asset has been set up.\n     * @dev Since `addAsset` enforces the derivative is non zero, checking if the stored setting\n     *      is nonzero is sufficient to see if the asset is set up.\n     */\n    function isSupported(ERC20 asset) external view returns (bool) {\n        return getAssetSettings[asset].derivative > 0;\n    }\n\n    // ======================================= CHAINLINK AUTOMATION =======================================\n    /**\n     * @notice `checkUpkeep` is set up to allow for multiple derivatives to use Chainlink Automation.\n     */\n    function checkUpkeep(bytes calldata checkData) external view returns (bool upkeepNeeded, bytes memory performData) {\n        (uint8 derivative, bytes memory derivativeCheckData) = abi.decode(checkData, (uint8, bytes));\n\n        if (derivative == 2) {\n            (upkeepNeeded, performData) = _checkVirtualPriceBound(derivativeCheckData);\n        } else if (derivative == 3) {\n            (upkeepNeeded, performData) = _checkVirtualPriceBound(derivativeCheckData);\n        } else revert PriceRouter__UnkownDerivative(derivative);\n    }\n\n    /**\n     * @notice `performUpkeep` is set up to allow for multiple derivatives to use Chainlink Automation.\n     */\n    function performUpkeep(bytes calldata performData) external {\n        (uint8 derivative, bytes memory derivativePerformData) = abi.decode(performData, (uint8, bytes));\n\n        if (derivative == 2) {\n            _updateVirtualPriceBound(derivativePerformData);\n        } else if (derivative == 3) {\n            _updateVirtualPriceBound(derivativePerformData);\n        } else revert PriceRouter__UnkownDerivative(derivative);\n    }\n\n    // ======================================= PRICING OPERATIONS =======================================\n\n    /**\n     * @notice Get `asset` price in USD.\n     * @dev Returns price in USD with 8 decimals.\n     */\n    function getPriceInUSD(ERC20 asset) external view returns (uint256) {\n        AssetSettings memory assetSettings = getAssetSettings[asset];\n        // Create an empty Price Cache.\n        PriceCache[PRICE_CACHE_SIZE] memory cache;\n        return _getPriceInUSD(asset, assetSettings, cache);\n    }\n\n    /**\n     * @notice Get the value of an asset in terms of another asset.\n     * @param baseAsset address of the asset to get the price of in terms of the quote asset\n     * @param amount amount of the base asset to price\n     * @param quoteAsset address of the asset that the base asset is priced in terms of\n     * @return value value of the amount of base assets specified in terms of the quote asset\n     */\n    function getValue(ERC20 baseAsset, uint256 amount, ERC20 quoteAsset) external view returns (uint256 value) {\n        AssetSettings memory baseSettings = getAssetSettings[baseAsset];\n        AssetSettings memory quoteSettings = getAssetSettings[quoteAsset];\n        if (baseSettings.derivative == 0) revert PriceRouter__UnsupportedAsset(address(baseAsset));\n        if (quoteSettings.derivative == 0) revert PriceRouter__UnsupportedAsset(address(quoteAsset));\n        PriceCache[PRICE_CACHE_SIZE] memory cache;\n        uint256 priceBaseUSD = _getPriceInUSD(baseAsset, baseSettings, cache);\n        uint256 priceQuoteUSD = _getPriceInUSD(quoteAsset, quoteSettings, cache);\n        value = _getValueInQuote(priceBaseUSD, priceQuoteUSD, baseAsset.decimals(), quoteAsset.decimals(), amount);\n    }\n\n    /**\n     * @notice Helper function that compares `_getValues` between input 0 and input 1.\n     */\n    function getValuesDelta(\n        ERC20[] calldata baseAssets0,\n        uint256[] calldata amounts0,\n        ERC20[] calldata baseAssets1,\n        uint256[] calldata amounts1,\n        ERC20 quoteAsset\n    ) external view returns (uint256) {\n        // Create an empty Price Cache.\n        PriceCache[PRICE_CACHE_SIZE] memory cache;\n\n        uint256 value0 = _getValues(baseAssets0, amounts0, quoteAsset, cache);\n        uint256 value1 = _getValues(baseAssets1, amounts1, quoteAsset, cache);\n        return value0 - value1;\n    }\n\n    /**\n     * @notice Helper function that determines the value of assets using `_getValues`.\n     */\n    function getValues(\n        ERC20[] calldata baseAssets,\n        uint256[] calldata amounts,\n        ERC20 quoteAsset\n    ) external view returns (uint256) {\n        // Create an empty Price Cache.\n        PriceCache[PRICE_CACHE_SIZE] memory cache;\n\n        return _getValues(baseAssets, amounts, quoteAsset, cache);\n    }\n\n    /**\n     * @notice Get the exchange rate between two assets.\n     * @param baseAsset address of the asset to get the exchange rate of in terms of the quote asset\n     * @param quoteAsset address of the asset that the base asset is exchanged for\n     * @return exchangeRate rate of exchange between the base asset and the quote asset\n     */\n    function getExchangeRate(ERC20 baseAsset, ERC20 quoteAsset) public view returns (uint256 exchangeRate) {\n        AssetSettings memory baseSettings = getAssetSettings[baseAsset];\n        AssetSettings memory quoteSettings = getAssetSettings[quoteAsset];\n        if (baseSettings.derivative == 0) revert PriceRouter__UnsupportedAsset(address(baseAsset));\n        if (quoteSettings.derivative == 0) revert PriceRouter__UnsupportedAsset(address(quoteAsset));\n\n        // Create an empty Price Cache.\n        PriceCache[PRICE_CACHE_SIZE] memory cache;\n        // Pass in zero for ethToUsd, since it has not been set yet.\n        exchangeRate = _getExchangeRate(\n            baseAsset,\n            baseSettings,\n            quoteAsset,\n            quoteSettings,\n            quoteAsset.decimals(),\n            cache\n        );\n    }\n\n    /**\n     * @notice Get the exchange rates between multiple assets and another asset.\n     * @param baseAssets addresses of the assets to get the exchange rates of in terms of the quote asset\n     * @param quoteAsset address of the asset that the base assets are exchanged for\n     * @return exchangeRates rate of exchange between the base assets and the quote asset\n     */\n    function getExchangeRates(\n        ERC20[] memory baseAssets,\n        ERC20 quoteAsset\n    ) external view returns (uint256[] memory exchangeRates) {\n        uint8 quoteAssetDecimals = quoteAsset.decimals();\n        AssetSettings memory quoteSettings = getAssetSettings[quoteAsset];\n        if (quoteSettings.derivative == 0) revert PriceRouter__UnsupportedAsset(address(quoteAsset));\n\n        // Create an empty Price Cache.\n        PriceCache[PRICE_CACHE_SIZE] memory cache;\n\n        uint256 numOfAssets = baseAssets.length;\n        exchangeRates = new uint256[](numOfAssets);\n        for (uint256 i; i < numOfAssets; i++) {\n            AssetSettings memory baseSettings = getAssetSettings[baseAssets[i]];\n            if (baseSettings.derivative == 0) revert PriceRouter__UnsupportedAsset(address(baseAssets[i]));\n            exchangeRates[i] = _getExchangeRate(\n                baseAssets[i],\n                baseSettings,\n                quoteAsset,\n                quoteSettings,\n                quoteAssetDecimals,\n                cache\n            );\n        }\n    }\n\n    // =========================================== HELPER FUNCTIONS ===========================================\n    ERC20 private constant WETH = ERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    /**\n     * @notice Attempted to update the asset to one that is not supported by the platform.\n     * @param asset address of the unsupported asset\n     */\n    error PriceRouter__UnsupportedAsset(address asset);\n\n    /**\n     * @notice Gets the exchange rate between a base and a quote asset\n     * @param baseAsset the asset to convert into quoteAsset\n     * @param quoteAsset the asset base asset is converted into\n     * @return exchangeRate value of base asset in terms of quote asset\n     */\n    function _getExchangeRate(\n        ERC20 baseAsset,\n        AssetSettings memory baseSettings,\n        ERC20 quoteAsset,\n        AssetSettings memory quoteSettings,\n        uint8 quoteAssetDecimals,\n        PriceCache[PRICE_CACHE_SIZE] memory cache\n    ) internal view returns (uint256) {\n        uint256 basePrice = _getPriceInUSD(baseAsset, baseSettings, cache);\n        uint256 quotePrice = _getPriceInUSD(quoteAsset, quoteSettings, cache);\n        uint256 exchangeRate = basePrice.mulDivDown(10 ** quoteAssetDecimals, quotePrice);\n        return exchangeRate;\n    }\n\n    /**\n     * @notice Helper function to get an assets price in USD.\n     * @dev Returns price in USD with 8 decimals.\n     * @dev Favors using cached prices if available.\n     */\n    function _getPriceInUSD(\n        ERC20 asset,\n        AssetSettings memory settings,\n        PriceCache[PRICE_CACHE_SIZE] memory cache\n    ) internal view returns (uint256) {\n        // First check if the price is in the price cache.\n        uint8 lastIndex = PRICE_CACHE_SIZE;\n        for (uint8 i; i < PRICE_CACHE_SIZE; ++i) {\n            // Did not find our price in the cache.\n            if (cache[i].asset == address(0)) {\n                // Save the last index.\n                lastIndex = i;\n                break;\n            }\n            // Did find our price in the cache.\n            if (cache[i].asset == address(asset)) return cache[i].price;\n        }\n\n        // Call get price function using appropriate derivative.\n        uint256 price;\n        if (settings.derivative == 1) {\n            price = _getPriceForChainlinkDerivative(asset, settings.source, cache);\n        } else if (settings.derivative == 2) {\n            price = _getPriceForCurveDerivative(asset, settings.source, cache);\n        } else if (settings.derivative == 3) {\n            price = _getPriceForCurveV2Derivative(asset, settings.source, cache);\n        } else if (settings.derivative == 4) {\n            price = _getPriceForAaveDerivative(asset, settings.source, cache);\n        } else revert PriceRouter__UnkownDerivative(settings.derivative);\n\n        // If there is room in the cache, the price fits in a uint96, then find the next spot available.\n        if (lastIndex < PRICE_CACHE_SIZE && price <= type(uint96).max) {\n            for (uint8 i = lastIndex; i < PRICE_CACHE_SIZE; ++i) {\n                // Found an empty cache slot, so fill it.\n                if (cache[i].asset == address(0)) {\n                    cache[i] = PriceCache(address(asset), uint96(price));\n                    break;\n                }\n            }\n        }\n\n        return price;\n    }\n\n    /**\n     * @notice math function that preserves precision by multiplying the amountBase before dividing.\n     * @param priceBaseUSD the base asset price in USD\n     * @param priceQuoteUSD the quote asset price in USD\n     * @param baseDecimals the base asset decimals\n     * @param quoteDecimals the quote asset decimals\n     * @param amountBase the amount of base asset\n     */\n    function _getValueInQuote(\n        uint256 priceBaseUSD,\n        uint256 priceQuoteUSD,\n        uint8 baseDecimals,\n        uint8 quoteDecimals,\n        uint256 amountBase\n    ) internal pure returns (uint256 valueInQuote) {\n        // Get value in quote asset, but maintain as much precision as possible.\n        // Cleaner equations below.\n        // baseToUSD = amountBase * priceBaseUSD / 10**baseDecimals.\n        // valueInQuote = baseToUSD * 10**quoteDecimals / priceQuoteUSD\n        valueInQuote = amountBase.mulDivDown(\n            (priceBaseUSD * 10 ** quoteDecimals),\n            (10 ** baseDecimals * priceQuoteUSD)\n        );\n    }\n\n    /**\n     * @notice Attempted an operation with arrays of unequal lengths that were expected to be equal length.\n     */\n    error PriceRouter__LengthMismatch();\n\n    /**\n     * @notice Get the total value of multiple assets in terms of another asset.\n     * @param baseAssets addresses of the assets to get the price of in terms of the quote asset\n     * @param amounts amounts of each base asset to price\n     * @param quoteAsset address of the assets that the base asset is priced in terms of\n     * @return value total value of the amounts of each base assets specified in terms of the quote asset\n     */\n    function _getValues(\n        ERC20[] calldata baseAssets,\n        uint256[] calldata amounts,\n        ERC20 quoteAsset,\n        PriceCache[PRICE_CACHE_SIZE] memory cache\n    ) internal view returns (uint256) {\n        if (baseAssets.length != amounts.length) revert PriceRouter__LengthMismatch();\n        uint256 quotePrice;\n        {\n            AssetSettings memory quoteSettings = getAssetSettings[quoteAsset];\n            if (quoteSettings.derivative == 0) revert PriceRouter__UnsupportedAsset(address(quoteAsset));\n            quotePrice = _getPriceInUSD(quoteAsset, quoteSettings, cache);\n        }\n        uint256 valueInQuote;\n        // uint256 price;\n        uint8 quoteDecimals = quoteAsset.decimals();\n\n        for (uint8 i = 0; i < baseAssets.length; i++) {\n            // Skip zero amount values.\n            if (amounts[i] == 0) continue;\n            ERC20 baseAsset = baseAssets[i];\n            if (baseAsset == quoteAsset) valueInQuote += amounts[i];\n            else {\n                uint256 basePrice;\n                {\n                    AssetSettings memory baseSettings = getAssetSettings[baseAsset];\n                    if (baseSettings.derivative == 0) revert PriceRouter__UnsupportedAsset(address(baseAsset));\n                    basePrice = _getPriceInUSD(baseAsset, baseSettings, cache);\n                }\n                valueInQuote += _getValueInQuote(\n                    basePrice,\n                    quotePrice,\n                    baseAsset.decimals(),\n                    quoteDecimals,\n                    amounts[i]\n                );\n                // uint256 valueInUSD = (amounts[i].mulDivDown(price, 10**baseAsset.decimals()));\n                // valueInQuote += valueInUSD.mulDivDown(10**quoteDecimals, quotePrice);\n            }\n        }\n        return valueInQuote;\n    }\n\n    // =========================================== CHAINLINK PRICE DERIVATIVE ===========================================\\\n    /**\n     * @notice Stores data for Chainlink derivative assets.\n     * @param max the max valid price of the asset\n     * @param min the min valid price of the asset\n     * @param heartbeat the max amount of time between price updates\n     * @param inETH bool indicating whether the price feed is\n     *        denominated in ETH(true) or USD(false)\n     */\n    struct ChainlinkDerivativeStorage {\n        uint144 max;\n        uint80 min;\n        uint24 heartbeat;\n        bool inETH;\n    }\n    /**\n     * @notice Returns Chainlink Derivative Storage\n     */\n    mapping(ERC20 => ChainlinkDerivativeStorage) public getChainlinkDerivativeStorage;\n\n    /**\n     * @notice If zero is specified for a Chainlink asset heartbeat, this value is used instead.\n     */\n    uint24 public constant DEFAULT_HEART_BEAT = 1 days;\n\n    /**\n     * @notice Setup function for pricing Chainlink derivative assets.\n     * @dev _source The address of the Chainlink Data feed.\n     * @dev _storage A ChainlinkDerivativeStorage value defining valid prices.\n     */\n    function _setupPriceForChainlinkDerivative(ERC20 _asset, address _source, bytes memory _storage) internal {\n        ChainlinkDerivativeStorage memory parameters = abi.decode(_storage, (ChainlinkDerivativeStorage));\n\n        // Use Chainlink to get the min and max of the asset.\n        IChainlinkAggregator aggregator = IChainlinkAggregator(IChainlinkAggregator(_source).aggregator());\n        uint256 minFromChainklink = uint256(uint192(aggregator.minAnswer()));\n        uint256 maxFromChainlink = uint256(uint192(aggregator.maxAnswer()));\n\n        // Add a ~10% buffer to minimum and maximum price from Chainlink because Chainlink can stop updating\n        // its price before/above the min/max price.\n        uint256 bufferedMinPrice = (minFromChainklink * 1.1e18) / 1e18;\n        uint256 bufferedMaxPrice = (maxFromChainlink * 0.9e18) / 1e18;\n\n        if (parameters.min == 0) {\n            // Revert if bufferedMinPrice overflows because uint80 is too small to hold the minimum price,\n            // and lowering it to uint80 is not safe because the price feed can stop being updated before\n            // it actually gets to that lower price.\n            if (bufferedMinPrice > type(uint80).max) revert(\"Buffered Min Overflow\");\n            parameters.min = uint80(bufferedMinPrice);\n        } else {\n            if (parameters.min < bufferedMinPrice)\n                revert PriceRouter__InvalidMinPrice(parameters.min, bufferedMinPrice);\n        }\n\n        if (parameters.max == 0) {\n            //Do not revert even if bufferedMaxPrice is greater than uint144, because lowering it to uint144 max is more conservative.\n            parameters.max = bufferedMaxPrice > type(uint144).max ? type(uint144).max : uint144(bufferedMaxPrice);\n        } else {\n            if (parameters.max > bufferedMaxPrice)\n                revert PriceRouter__InvalidMaxPrice(parameters.max, bufferedMaxPrice);\n        }\n\n        if (parameters.min >= parameters.max)\n            revert PriceRouter__MinPriceGreaterThanMaxPrice(parameters.min, parameters.max);\n\n        parameters.heartbeat = parameters.heartbeat != 0 ? parameters.heartbeat : DEFAULT_HEART_BEAT;\n\n        getChainlinkDerivativeStorage[_asset] = parameters;\n    }\n\n    /**\n     * @notice Get the price of a Chainlink derivative in terms of USD.\n     */\n    function _getPriceForChainlinkDerivative(\n        ERC20 _asset,\n        address _source,\n        PriceCache[PRICE_CACHE_SIZE] memory cache\n    ) internal view returns (uint256) {\n        ChainlinkDerivativeStorage memory parameters = getChainlinkDerivativeStorage[_asset];\n        IChainlinkAggregator aggregator = IChainlinkAggregator(_source);\n        (, int256 _price, , uint256 _timestamp, ) = aggregator.latestRoundData();\n        uint256 price = _price.toUint256();\n        _checkPriceFeed(address(_asset), price, _timestamp, parameters.max, parameters.min, parameters.heartbeat);\n        // If price is in ETH, then convert price into USD.\n        if (parameters.inETH) {\n            uint256 _ethToUsd = _getPriceInUSD(WETH, getAssetSettings[WETH], cache);\n            price = price.mulWadDown(_ethToUsd);\n        }\n        return price;\n    }\n\n    /**\n     * @notice Attempted an operation to price an asset that under its minimum valid price.\n     * @param asset address of the asset that is under its minimum valid price\n     * @param price price of the asset\n     * @param minPrice minimum valid price of the asset\n     */\n    error PriceRouter__AssetBelowMinPrice(address asset, uint256 price, uint256 minPrice);\n\n    /**\n     * @notice Attempted an operation to price an asset that under its maximum valid price.\n     * @param asset address of the asset that is under its maximum valid price\n     * @param price price of the asset\n     * @param maxPrice maximum valid price of the asset\n     */\n    error PriceRouter__AssetAboveMaxPrice(address asset, uint256 price, uint256 maxPrice);\n\n    /**\n     * @notice Attempted to fetch a price for an asset that has not been updated in too long.\n     * @param asset address of the asset thats price is stale\n     * @param timeSinceLastUpdate seconds since the last price update\n     * @param heartbeat maximum allowed time between price updates\n     */\n    error PriceRouter__StalePrice(address asset, uint256 timeSinceLastUpdate, uint256 heartbeat);\n\n    /**\n     * @notice helper function to validate a price feed is safe to use.\n     * @param asset ERC20 asset price feed data is for.\n     * @param value the price value the price feed gave.\n     * @param timestamp the last timestamp the price feed was updated.\n     * @param max the upper price bound\n     * @param min the lower price bound\n     * @param heartbeat the max amount of time between price updates\n     */\n    function _checkPriceFeed(\n        address asset,\n        uint256 value,\n        uint256 timestamp,\n        uint144 max,\n        uint88 min,\n        uint24 heartbeat\n    ) internal view {\n        if (value < min) revert PriceRouter__AssetBelowMinPrice(address(asset), value, min);\n\n        if (value > max) revert PriceRouter__AssetAboveMaxPrice(address(asset), value, max);\n\n        uint256 timeSinceLastUpdate = block.timestamp - timestamp;\n        if (timeSinceLastUpdate > heartbeat)\n            revert PriceRouter__StalePrice(address(asset), timeSinceLastUpdate, heartbeat);\n    }\n\n    // ======================================== CURVE VIRTUAL PRICE BOUND ========================================\n    /**\n     * @notice Curve virtual price is susceptible to re-entrancy attacks, if the attacker adds/removes pool liquidity,\n     *         and re-enters into one of our contracts. To mitigate this, all curve pricing operations check\n     *         the current `pool.get_virtual_price()` against logical bounds.\n     * @notice These logical bounds are updated when `addAsset` is called, or Chainlink Automation detects that\n     *         the bounds need to be updated, and that the gas price is reasonable.\n     * @notice Once the on chain virtual price goes out of bounds, all pricing operations will revert for that Curve LP,\n     *         which means any Cellars using that Curve LP are effectively frozen until the virtual price bounds are updated\n     *         by Chainlink. If this is not happening in a timely manner( IE network is abnormally busy), the owner of this\n     *         contract can raise the `gasConstant` to a value that better reflects the floor gas price of the network.\n     *         Which will cause Chainlink nodes to update virtual price bounds faster.\n     */\n\n    /**\n     * @param datum the virtual price to base posDelta and negDelta off of, 8 decimals\n     * @param timeLastUpdated the timestamp this datum was updated\n     * @param posDelta multipler >= 1e8 defining the logical upper bound for this virtual price, 8 decimals\n     * @param negDelta multipler <= 1e8 defining the logical lower bound for this virtual price, 8 decimals\n     * @param rateLimit the minimum amount of time that must pass between updates\n     * @dev Curve virtual price values should update slowly, hence why this contract enforces a rate limit.\n     * @dev During datum updates, the max/min new datum corresponds to the current upper/lower bound.\n     */\n    struct VirtualPriceBound {\n        uint96 datum;\n        uint64 timeLastUpdated;\n        uint32 posDelta;\n        uint32 negDelta;\n        uint32 rateLimit;\n    }\n\n    /**\n     * @notice Returns a Curve asset virtual price bound\n     */\n    mapping(address => VirtualPriceBound) public getVirtualPriceBound;\n\n    /**\n     * @dev If ZERO is specified for an assets `rateLimit` this value is used instead.\n     */\n    uint32 public constant DEFAULT_RATE_LIMIT = 1 days;\n\n    /**\n     * @notice Chainlink Fast Gas Feed for ETH Mainnet.\n     */\n    address public ETH_FAST_GAS_FEED = 0x169E633A2D1E6c10dD91238Ba11c4A708dfEF37C;\n\n    /**\n     * @notice Allows owner to set a new gas feed.\n     * @notice Can be set to zero address to skip gas check.\n     */\n    function setGasFeed(address gasFeed) external onlyOwner {\n        ETH_FAST_GAS_FEED = gasFeed;\n    }\n\n    /**\n     * @notice Dictates how aggressive keepers are with updating Curve pool virtual price values.\n     * @dev A larger `gasConstant` will raise the `gasPriceLimit`, while a smaller `gasConstant`\n     *      will lower the `gasPriceLimit`.\n     */\n    uint256 public gasConstant = 200e9;\n\n    /**\n     * @notice Allows owner to set a new gas constant.\n     */\n    function setGasConstant(uint256 newConstant) external onlyOwner {\n        gasConstant = newConstant;\n    }\n\n    /**\n     * @notice Dictates the minimum delta required for an upkeep.\n     * @dev If the max delta found is less than this, then checkUpkeep returns false.\n     */\n    uint256 public minDelta = 0.05e18;\n\n    /**\n     * @notice Allows owner to set a new minimum delta.\n     */\n    function setMinDelta(uint256 newMinDelta) external onlyOwner {\n        minDelta = newMinDelta;\n    }\n\n    /**\n     * @notice Stores all Curve Assets this contract prices, so Automation can loop through it.\n     */\n    address[] public curveAssets;\n\n    /**\n     * @notice Allows owner to update a Curve asset's virtual price parameters..\n     */\n    function updateVirtualPriceBound(\n        address _asset,\n        uint32 _posDelta,\n        uint32 _negDelta,\n        uint32 _rateLimit\n    ) external onlyOwner {\n        VirtualPriceBound storage vpBound = getVirtualPriceBound[_asset];\n        vpBound.posDelta = _posDelta;\n        vpBound.negDelta = _negDelta;\n        vpBound.rateLimit = _rateLimit == 0 ? DEFAULT_RATE_LIMIT : _rateLimit;\n    }\n\n    /**\n     * @notice Logic ran by Chainlink Automation to determine if virtual price bounds need to be updated.\n     * @dev `checkData` should be a start and end value indicating where to start and end in the `curveAssets` array.\n     * @dev The end index can be zero, or greater than the current length of `curveAssets`.\n     *      Doing this makes end = curveAssets.length.\n     * @dev `performData` is the target index in `curveAssets` that needs its bounds updated.\n     */\n    function _checkVirtualPriceBound(\n        bytes memory checkData\n    ) internal view returns (bool upkeepNeeded, bytes memory performData) {\n        // Decode checkData to get start and end index.\n        (uint256 start, uint256 end) = abi.decode(checkData, (uint256, uint256));\n        if (end == 0 || end > curveAssets.length) end = curveAssets.length;\n\n        // Loop through all curve assets, and find the asset with the largest delta(the one that needs to be updated the most).\n        uint256 maxDelta;\n        uint256 targetIndex;\n        for (uint256 i = start; i < end; i++) {\n            address asset = curveAssets[i];\n            VirtualPriceBound memory vpBound = getVirtualPriceBound[asset];\n\n            // Check to see if this virtual price was updated recently.\n            if ((block.timestamp - vpBound.timeLastUpdated) < vpBound.rateLimit) continue;\n\n            // Check current virtual price against upper and lower bounds to find the delta.\n            uint256 currentVirtualPrice = ICurvePool(getAssetSettings[ERC20(asset)].source).get_virtual_price();\n            currentVirtualPrice = currentVirtualPrice.changeDecimals(18, 8);\n            uint256 delta;\n            if (currentVirtualPrice > vpBound.datum) {\n                uint256 upper = uint256(vpBound.datum).mulDivDown(vpBound.posDelta, 1e8);\n                uint256 ceiling = upper - vpBound.datum;\n                uint256 current = currentVirtualPrice - vpBound.datum;\n                delta = _getDelta(ceiling, current);\n            } else {\n                uint256 lower = uint256(vpBound.datum).mulDivDown(vpBound.negDelta, 1e8);\n                uint256 ceiling = vpBound.datum - lower;\n                uint256 current = vpBound.datum - currentVirtualPrice;\n                delta = _getDelta(ceiling, current);\n            }\n            // Save the largest delta for the upkeep.\n            if (delta > maxDelta) {\n                maxDelta = delta;\n                targetIndex = i;\n            }\n        }\n\n        // If the largest delta must be greater/equal to `minDelta` to continue.\n        if (maxDelta >= minDelta) {\n            // If gas feed is not set, skip the gas check.\n            if (ETH_FAST_GAS_FEED == address(0)) {\n                // No Gas Check needed.\n                upkeepNeeded = true;\n                performData = abi.encode(targetIndex);\n            } else {\n                // Run a gas check to determine if it makes sense to update the target curve asset.\n                uint256 gasPriceLimit = gasConstant.mulDivDown(maxDelta ** 3, 1e54); // 54 comes from 18 * 3.\n                uint256 currentGasPrice = uint256(IChainlinkAggregator(ETH_FAST_GAS_FEED).latestAnswer());\n                if (currentGasPrice <= gasPriceLimit) {\n                    upkeepNeeded = true;\n                    performData = abi.encode(targetIndex);\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Attempted to call a function only the Chainlink Registry can call.\n     */\n    error PriceRouter__OnlyAutomationRegistry();\n\n    /**\n     * @notice Attempted to update a virtual price too soon.\n     */\n    error PriceRouter__VirtualPriceRateLimiter();\n\n    /**\n     * @notice Attempted to update a virtual price bound that did not need to be updated.\n     */\n    error PriceRouter__NothingToUpdate();\n\n    /**\n     * @notice Chainlink's Automation Registry contract address.\n     */\n    address public automationRegistry = 0x02777053d6764996e594c3E88AF1D58D5363a2e6;\n\n    /**\n     * @notice Allows owner to update the Automation Registry.\n     * @dev In rare cases, Chainlink's registry CAN change.\n     */\n    function setAutomationRegistry(address newRegistry) external onlyOwner {\n        automationRegistry = newRegistry;\n    }\n\n    /**\n     * @notice Curve virtual price is susceptible to re-entrancy attacks, if the attacker adds/removes pool liquidity.\n     *         To stop this we check the virtual price against logical bounds.\n     * @dev Only the chainlink registry can call this function, so we know that Chainlink nodes will not be\n     *      re-entering into the Curve pool, so it is safe to use the current on chain virtual price.\n     * @notice Updating the virtual price is rate limited by `VirtualPriceBound.raetLimit` and can only be\n     *         updated at most to the lower or upper bound of the current datum.\n     *         This is intentional since curve pool price should not be volatile, and if they are, then\n     *         we WANT that Curve LP pools TX pricing to revert.\n     */\n    function _updateVirtualPriceBound(bytes memory performData) internal {\n        // Make sure only the Automation Registry can call this function.\n        if (msg.sender != automationRegistry) revert PriceRouter__OnlyAutomationRegistry();\n\n        // Grab the target index from performData.\n        uint256 index = abi.decode(performData, (uint256));\n        address asset = curveAssets[index];\n        VirtualPriceBound storage vpBound = getVirtualPriceBound[asset];\n\n        // Enfore rate limit check.\n        if ((block.timestamp - vpBound.timeLastUpdated) < vpBound.rateLimit)\n            revert PriceRouter__VirtualPriceRateLimiter();\n\n        // Determine what the new Datum should be.\n        uint256 currentVirtualPrice = ICurvePool(getAssetSettings[ERC20(asset)].source).get_virtual_price();\n        currentVirtualPrice = currentVirtualPrice.changeDecimals(18, 8);\n        if (currentVirtualPrice > vpBound.datum) {\n            uint256 upper = uint256(vpBound.datum).mulDivDown(vpBound.posDelta, 1e8);\n            vpBound.datum = uint96(currentVirtualPrice > upper ? upper : currentVirtualPrice);\n        } else if (currentVirtualPrice < vpBound.datum) {\n            uint256 lower = uint256(vpBound.datum).mulDivDown(vpBound.negDelta, 1e8);\n            vpBound.datum = uint96(currentVirtualPrice < lower ? lower : currentVirtualPrice);\n        } else {\n            revert PriceRouter__NothingToUpdate();\n        }\n\n        // Update the stored timestamp.\n        vpBound.timeLastUpdated = uint64(block.timestamp);\n    }\n\n    /**\n     * @notice Returns a percent delta representing where `current` is in reference to `ceiling`.\n     * Example, if current == 0, this would return a 0.\n     *          if current == ceiling, this would return a 1e18.\n     *          if current == (ceiling) / 2, this would return 0.5e18.\n     */\n    function _getDelta(uint256 ceiling, uint256 current) internal pure returns (uint256) {\n        return current.mulDivDown(1e18, ceiling);\n    }\n\n    /**\n     * @notice Attempted to price a curve asset that was below its logical minimum price.\n     */\n    error PriceRouter__CurrentBelowLowerBound(uint256 current, uint256 lower);\n\n    /**\n     * @notice Attempted to price a curve asset that was above its logical maximum price.\n     */\n    error PriceRouter__CurrentAboveUpperBound(uint256 current, uint256 upper);\n\n    /**\n     * @notice Enforces a logical price bound on Curve pool tokens.\n     */\n    function _checkBounds(uint256 lower, uint256 upper, uint256 current) internal pure {\n        if (current < lower) revert PriceRouter__CurrentBelowLowerBound(current, lower);\n        if (current > upper) revert PriceRouter__CurrentAboveUpperBound(current, upper);\n    }\n\n    // =========================================== CURVE PRICE DERIVATIVE ===========================================\n    /**\n     * @notice Curve Derivative Storage\n     * @dev Stores an array of the underlying token addresses in the curve pool.\n     */\n    mapping(ERC20 => address[]) public getCurveDerivativeStorage;\n\n    /**\n     * @notice Setup function for pricing Curve derivative assets.\n     * @dev _source The address of the Curve Pool.\n     * @dev _storage A VirtualPriceBound value for this asset.\n     * @dev Assumes that curve pools never add or remove tokens.\n     */\n    function _setupPriceForCurveDerivative(ERC20 _asset, address _source, bytes memory _storage) internal {\n        ICurvePool pool = ICurvePool(_source);\n        uint8 coinsLength = 0;\n        // Figure out how many tokens are in the curve pool.\n        while (true) {\n            try pool.coins(coinsLength) {\n                coinsLength++;\n            } catch {\n                break;\n            }\n        }\n\n        // Save the pools tokens to reduce gas for pricing calls.\n        address[] memory coins = new address[](coinsLength);\n        for (uint256 i = 0; i < coinsLength; i++) {\n            coins[i] = pool.coins(i);\n        }\n\n        getCurveDerivativeStorage[_asset] = coins;\n\n        curveAssets.push(address(_asset));\n\n        // Setup virtual price bound.\n        VirtualPriceBound memory vpBound = abi.decode(_storage, (VirtualPriceBound));\n        uint256 upper = uint256(vpBound.datum).mulDivDown(vpBound.posDelta, 1e8);\n        upper = upper.changeDecimals(8, 18);\n        uint256 lower = uint256(vpBound.datum).mulDivDown(vpBound.negDelta, 1e8);\n        lower = lower.changeDecimals(8, 18);\n        _checkBounds(lower, upper, pool.get_virtual_price());\n        if (vpBound.rateLimit == 0) vpBound.rateLimit = DEFAULT_RATE_LIMIT;\n        vpBound.timeLastUpdated = uint64(block.timestamp);\n        getVirtualPriceBound[address(_asset)] = vpBound;\n    }\n\n    /**\n     * @notice Get the price of a CurveV1 derivative in terms of USD.\n     */\n    function _getPriceForCurveDerivative(\n        ERC20 asset,\n        address _source,\n        PriceCache[PRICE_CACHE_SIZE] memory cache\n    ) internal view returns (uint256 price) {\n        ICurvePool pool = ICurvePool(_source);\n\n        address[] memory coins = getCurveDerivativeStorage[asset];\n\n        uint256 minPrice = type(uint256).max;\n        for (uint256 i = 0; i < coins.length; i++) {\n            ERC20 poolAsset = ERC20(coins[i]);\n            uint256 tokenPrice = _getPriceInUSD(poolAsset, getAssetSettings[poolAsset], cache);\n            if (tokenPrice < minPrice) minPrice = tokenPrice;\n        }\n\n        if (minPrice == type(uint256).max) revert(\"Min price not found.\");\n\n        // Check that virtual price is within bounds.\n        uint256 virtualPrice = pool.get_virtual_price();\n        VirtualPriceBound memory vpBound = getVirtualPriceBound[address(asset)];\n        uint256 upper = uint256(vpBound.datum).mulDivDown(vpBound.posDelta, 1e8);\n        upper = upper.changeDecimals(8, 18);\n        uint256 lower = uint256(vpBound.datum).mulDivDown(vpBound.negDelta, 1e8);\n        lower = lower.changeDecimals(8, 18);\n        _checkBounds(lower, upper, virtualPrice);\n\n        // Virtual price is based off the Curve Token decimals.\n        uint256 curveTokenDecimals = ERC20(asset).decimals();\n        price = minPrice.mulDivDown(virtualPrice, 10 ** curveTokenDecimals);\n    }\n\n    // =========================================== CURVEV2 PRICE DERIVATIVE ===========================================\n\n    /**\n     * @notice Setup function for pricing CurveV2 derivative assets.\n     * @dev _source The address of the CurveV2 Pool.\n     * @dev _storage A VirtualPriceBound value for this asset.\n     * @dev Assumes that curve pools never add or remove tokens.\n     */\n    function _setupPriceForCurveV2Derivative(ERC20 _asset, address _source, bytes memory _storage) internal {\n        ICurvePool pool = ICurvePool(_source);\n        uint8 coinsLength = 0;\n        // Figure out how many tokens are in the curve pool.\n        while (true) {\n            try pool.coins(coinsLength) {\n                coinsLength++;\n            } catch {\n                break;\n            }\n        }\n        address[] memory coins = new address[](coinsLength);\n        for (uint256 i = 0; i < coinsLength; i++) {\n            coins[i] = pool.coins(i);\n        }\n\n        getCurveDerivativeStorage[_asset] = coins;\n\n        curveAssets.push(address(_asset));\n\n        // Setup virtual price bound.\n        VirtualPriceBound memory vpBound = abi.decode(_storage, (VirtualPriceBound));\n        uint256 upper = uint256(vpBound.datum).mulDivDown(vpBound.posDelta, 1e8);\n        upper = upper.changeDecimals(8, 18);\n        uint256 lower = uint256(vpBound.datum).mulDivDown(vpBound.negDelta, 1e8);\n        lower = lower.changeDecimals(8, 18);\n        _checkBounds(lower, upper, pool.get_virtual_price());\n        if (vpBound.rateLimit == 0) vpBound.rateLimit = DEFAULT_RATE_LIMIT;\n        vpBound.timeLastUpdated = uint64(block.timestamp);\n        getVirtualPriceBound[address(_asset)] = vpBound;\n    }\n\n    uint256 private constant GAMMA0 = 28000000000000;\n    uint256 private constant A0 = 2 * 3 ** 3 * 10000;\n    uint256 private constant DISCOUNT0 = 1087460000000000;\n\n    // x has 36 decimals\n    // result has 18 decimals.\n    function _cubicRoot(uint256 x) internal pure returns (uint256) {\n        uint256 D = x / 1e18;\n        for (uint8 i; i < 256; i++) {\n            uint256 diff;\n            uint256 D_prev = D;\n            D = (D * (2 * 1e18 + ((((x / D) * 1e18) / D) * 1e18) / D)) / (3 * 1e18);\n            if (D > D_prev) diff = D - D_prev;\n            else diff = D_prev - D;\n            if (diff <= 1 || diff * 10 ** 18 < D) return D;\n        }\n        revert(\"Did not converge\");\n    }\n\n    /**\n     * Inspired by https://etherscan.io/address/0xE8b2989276E2Ca8FDEA2268E3551b2b4B2418950#code\n     * @notice Get the price of a CurveV1 derivative in terms of USD.\n     */\n    function _getPriceForCurveV2Derivative(\n        ERC20 asset,\n        address _source,\n        PriceCache[PRICE_CACHE_SIZE] memory cache\n    ) internal view returns (uint256) {\n        ICurvePool pool = ICurvePool(_source);\n\n        // Check that virtual price is within bounds.\n        uint256 virtualPrice = pool.get_virtual_price();\n        VirtualPriceBound memory vpBound = getVirtualPriceBound[address(asset)];\n        uint256 upper = uint256(vpBound.datum).mulDivDown(vpBound.posDelta, 1e8);\n        upper = upper.changeDecimals(8, 18);\n        uint256 lower = uint256(vpBound.datum).mulDivDown(vpBound.negDelta, 1e8);\n        lower = lower.changeDecimals(8, 18);\n        _checkBounds(lower, upper, virtualPrice);\n\n        address[] memory coins = getCurveDerivativeStorage[asset];\n        ERC20 token0 = ERC20(coins[0]);\n        if (coins.length == 2) {\n            return pool.lp_price().mulDivDown(_getPriceInUSD(token0, getAssetSettings[token0], cache), 1e18);\n        } else if (coins.length == 3) {\n            uint256 t1Price = pool.price_oracle(0);\n            uint256 t2Price = pool.price_oracle(1);\n\n            uint256 maxPrice = (3 * virtualPrice * _cubicRoot(t1Price * t2Price)) / 1e18;\n            {\n                uint256 g = pool.gamma().mulDivDown(1e18, GAMMA0);\n                uint256 a = pool.A().mulDivDown(1e18, A0);\n                uint256 coefficient = (g ** 2 / 1e18) * a;\n                uint256 discount = coefficient > 1e34 ? coefficient : 1e34;\n                discount = _cubicRoot(discount).mulDivDown(DISCOUNT0, 1e18);\n\n                maxPrice -= maxPrice.mulDivDown(discount, 1e18);\n            }\n            return maxPrice.mulDivDown(_getPriceInUSD(token0, getAssetSettings[token0], cache), 1e18);\n        } else revert(\"Unsupported Pool\");\n    }\n\n    // =========================================== AAVE PRICE DERIVATIVE ===========================================\n    /**\n     * @notice Aave Derivative Storage\n     */\n    mapping(ERC20 => ERC20) public getAaveDerivativeStorage;\n\n    /**\n     * @notice Setup function for pricing Aave derivative assets.\n     * @dev _source The address of the aToken.\n     * @dev _storage is not used.\n     */\n    function _setupPriceForAaveDerivative(ERC20 _asset, address _source, bytes memory) internal {\n        IAaveToken aToken = IAaveToken(_source);\n        getAaveDerivativeStorage[_asset] = ERC20(aToken.UNDERLYING_ASSET_ADDRESS());\n    }\n\n    /**\n     * @notice Get the price of an Aave derivative in terms of USD.\n     */\n    function _getPriceForAaveDerivative(\n        ERC20 asset,\n        address,\n        PriceCache[PRICE_CACHE_SIZE] memory cache\n    ) internal view returns (uint256) {\n        asset = getAaveDerivativeStorage[asset];\n        return _getPriceInUSD(asset, getAssetSettings[asset], cache);\n    }\n}\n"

    },

    "src/utils/Math.sol": {

      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.16;\n\nlibrary Math {\n    /**\n     * @notice Substract with a floor of 0 for the result.\n     */\n    function subMinZero(uint256 x, uint256 y) internal pure returns (uint256) {\n        return x > y ? x - y : 0;\n    }\n\n    /**\n     * @notice Used to change the decimals of precision used for an amount.\n     */\n    function changeDecimals(\n        uint256 amount,\n        uint8 fromDecimals,\n        uint8 toDecimals\n    ) internal pure returns (uint256) {\n        if (fromDecimals == toDecimals) {\n            return amount;\n        } else if (fromDecimals < toDecimals) {\n            return amount * 10**(toDecimals - fromDecimals);\n        } else {\n            return amount / 10**(fromDecimals - toDecimals);\n        }\n    }\n\n    // ===================================== OPENZEPPELIN'S MATH =====================================\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    // ================================= SOLMATE's FIXEDPOINTMATHLIB =================================\n\n    uint256 public constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // Divide z by the denominator.\n            z := div(z, denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // First, divide z - 1 by the denominator and add 1.\n            // We allow z - 1 to underflow if z is 0, because we multiply the\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n        }\n    }\n}\n"

    }

  },

  "settings": {

    "remappings": [

      "@balancer-labs/=lib/balancer-v2-monorepo/../../node_modules/@balancer-labs/",

      "@chainlink/=lib/chainlink/",

      "@ds-test/=lib/forge-std/lib/ds-test/src/",

      "@forge-std/=lib/forge-std/src/",

      "@openzeppelin/=lib/openzeppelin-contracts/",

      "@solmate/=lib/solmate/src/",

      "@uniswap/v3-core/=lib/v3-core/",

      "@uniswap/v3-periphery/=lib/v3-periphery/",

      "@uniswapV3C/=lib/v3-core.git/contracts/",

      "@uniswapV3P/=lib/v3-periphery.git/contracts/",

      "balancer-v2-monorepo/=lib/balancer-v2-monorepo/",

      "chainlink/=lib/chainlink/integration-tests/contracts/ethereum/src/",

      "ds-test/=lib/forge-std/lib/ds-test/src/",

      "forge-std/=lib/forge-std/src/",

      "openzeppelin-contracts/=lib/openzeppelin-contracts/",

      "solmate/=lib/solmate/src/",

      "v3-core.git/=lib/v3-core.git/contracts/",

      "v3-core/=lib/v3-core/contracts/",

      "v3-periphery.git/=lib/v3-periphery.git/contracts/",

      "v3-periphery/=lib/v3-periphery/contracts/"

    ],

    "optimizer": {

      "enabled": true,

      "runs": 200

    },

    "metadata": {

      "bytecodeHash": "ipfs"

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "evmVersion": "london",

    "libraries": {}

  }

}}