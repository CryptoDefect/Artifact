{{

  "language": "Solidity",

  "sources": {

    "ConvexStrategy.sol": {

      "content": "// SPDX-License-Identifier: AGPLv3\npragma solidity 0.8.10;\n\nimport \"ICurve3Pool.sol\";\nimport \"ICurveMeta.sol\";\nimport \"IStop.sol\";\nimport \"IStrategy.sol\";\nimport \"IGVault.sol\";\nimport {ERC20} from \"ERC20.sol\";\n\n// High level Responsibilities:\n// - Borrow funds from the vault (1)\n// - Invest borrowed funds into an underlying strategy (2)\n// - Correctly report PnL to the lender (GVault) (3)\n// - Responsibly handle 'borrowed' assets (4)\n\nlibrary StrategyErrors {\n    error NotOwner(); // 0x30cd7471\n    error NotVault(); // 0x62df0545\n    error NotKeeper(); // 0xf512b278\n    error ConvexShutdown(); // 0xdbd83f91\n    error RewardsTokenMax(); // 0x8f24ac29\n    error Stopped(); // 0x7acc84e3\n    error SamePid(); // 0x4eb5bc6d\n    error BaseAsset(); // 0xaeca768b\n    error LpToken(); // 0xaeca768b\n    error ConvexToken(); // 0xaeca768b\n    error LTMinAmountExpected(); // 0x3d93e699\n}\n\n/// Convex booster interface\ninterface Booster {\n    function poolInfo(uint256)\n        external\n        view\n        returns (\n            address,\n            address,\n            address,\n            address,\n            address,\n            bool\n        );\n\n    function deposit(\n        uint256 _pid,\n        uint256 _amount,\n        bool _stake\n    ) external returns (bool);\n}\n\n/// Convex rewards interface\ninterface Rewards {\n    function balanceOf(address account) external view returns (uint256);\n\n    function earned(address account) external view returns (uint256);\n\n    function withdrawAndUnwrap(uint256 amount, bool claim)\n        external\n        returns (bool);\n\n    function withdrawAllAndUnwrap(bool claim) external;\n\n    function getReward() external returns (bool);\n\n    function extraRewards(uint256 id) external view returns (address);\n\n    function extraRewardsLength() external view returns (uint256);\n}\n\n/// GVault Strategy parameters\nstruct StrategyParams {\n    bool active;\n    uint256 debtRatio;\n    uint256 lastReport;\n    uint256 totalDebt;\n    uint256 totalGain;\n    uint256 totalLoss;\n}\n\n/// CRV-ETH and CVX-ETH pool interface\ninterface ICurveRewards {\n    function exchange(\n        uint256 from,\n        uint256 to,\n        uint256 _from_amount,\n        uint256 _min_to_amount,\n        bool use_eth\n    ) external returns (uint256);\n\n    function get_dy(\n        uint256 i,\n        uint256 j,\n        uint256 dx\n    ) external view returns (uint256);\n}\n\n/// Uniswap v2 router interface\ninterface IUniV2 {\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n}\n\n/// Uniswap v3 router interface\ninterface IUniV3 {\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    function exactInput(ExactInputParams calldata params)\n        external\n        payable\n        returns (uint256 amountOut);\n}\n\n/// Uniswap v3 pool interface\ninterface IUniV3_POOL {\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n}\n\n/** @title StableConvexXPool\n *   @notice Convex strategy based of yearns convex contract that allows usage of one of the 3 pool\n *       stables as want, rather than a metapool lp token. This strategy can swap between meta pool\n *       and convex strategies to optimize yield/risk, and routes all assets through the following flow:\n *           3crv => metaLp => convex.\n */\ncontract ConvexStrategy {\n    /*//////////////////////////////////////////////////////////////\n                        CONSTANTS & IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant PERCENTAGE_DECIMAL_FACTOR = 1E4;\n    uint256 internal constant DEFAULT_DECIMALS_FACTOR = 1E18;\n\n    address internal constant BOOSTER =\n        address(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);\n\n    address internal constant CVX =\n        address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);\n    address internal constant CRV =\n        address(0xD533a949740bb3306d119CC777fa900bA034cd52);\n    address internal constant WETH =\n        address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    address internal constant USDC =\n        address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n\n    address internal constant CRV_3POOL =\n        address(0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7);\n    address internal constant CRV_ETH =\n        address(0x8301AE4fc9c624d1D396cbDAa1ed877821D7C511);\n    address internal constant CVX_ETH =\n        address(0xB576491F1E6e5E62f1d8F26062Ee822B40B0E0d4);\n\n    ERC20 internal constant CRV_3POOL_TOKEN =\n        ERC20(address(0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490));\n\n    address internal constant UNI_V2 =\n        address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n    address internal constant UNI_V3 =\n        address(0xE592427A0AEce92De3Edee1F18E0157C05861564);\n    address internal constant USDC_ETH_V3 =\n        address(0x88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640);\n    uint256 internal constant UNI_V3_FEE = 500;\n\n    // strategy accounting constant\n    uint256 internal constant MIN_REWARD_SELL_AMOUNT = 1E18;\n    uint256 internal constant MIN_WETH_SELL_AMOUNT = 1E16;\n    uint256 internal constant MAX_REPORT_DELAY = 604800;\n    uint256 internal constant MIN_REPORT_DELAY = 172800;\n    uint256 internal constant INVESTMENT_BUFFER = 10E18;\n\n    // meta pool token layout: [minor stable, 3Crv]\n    int128 internal constant CRV3_INDEX = 1;\n    uint256 internal constant CRV_ETH_INDEX = 1;\n\n    // Vault and core asset associated with strategy\n    IGVault internal immutable VAULT;\n    ERC20 internal immutable ASSET;\n\n    // CVX rewards calculation parameters\n    uint256 internal constant TOTAL_CLIFFS = 1000;\n    uint256 internal constant MAX_SUPPLY = 1E8 * DEFAULT_DECIMALS_FACTOR;\n    uint256 internal constant REDUCTION_PER_CLIFF =\n        1E5 * DEFAULT_DECIMALS_FACTOR;\n\n    // number of max rewardedTokens set by Curve\n    uint256 internal constant MAX_REWARDS = 8;\n\n    /*//////////////////////////////////////////////////////////////\n                    STORAGE VARIABLES & TYPES\n    //////////////////////////////////////////////////////////////*/\n\n    // Current strategy investment target\n    uint256 internal pid; // convex lp token pid\n    address internal metaPool; // meta pool\n    ERC20 internal lpToken; // meta pool lp token\n    address internal rewardContract; // convex reward contract for lp token\n\n    // Potential strategy investment target\n    uint256 internal newPid;\n    address internal newMetaPool;\n    ERC20 internal newLpToken;\n    address internal newRewardContract;\n\n    // Additional reward tokens provided by CRV\n    address[MAX_REWARDS] public rewardTokens;\n    uint256 numberOfRewards;\n\n    // Admin variables\n    address public owner; // contract owner\n    mapping(address => bool) public keepers;\n\n    uint256 public baseSlippage = 10;\n    uint256 public stopLossAttempts;\n    address public stopLossLogic;\n    bool public emergencyMode;\n    bool public stop;\n\n    // Strategy harvest thresholds\n    uint256 internal debtThreshold = 20_000 * DEFAULT_DECIMALS_FACTOR;\n    uint256 internal profitThreshold = 20_000 * DEFAULT_DECIMALS_FACTOR;\n    /*//////////////////////////////////////////////////////////////\n                                EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    event NewKeeper(address indexed keeper);\n    event RevokedKeeper(address indexed keeper);\n    event LogNewHarvestThresholds(\n        uint256 debtThreshold,\n        uint256 profitThreshold\n    );\n    event LogNewStopLoss(address newStopLoss);\n    event LogNewBaseSlippage(uint256 baseSlippage);\n\n    event Harvested(\n        uint256 profit,\n        uint256 loss,\n        uint256 debtRepayment,\n        uint256 excessDebt\n    );\n\n    event EmergencyModeSet(bool mode);\n\n    event LogChangePool(\n        uint256 pid,\n        address lpToken,\n        address reward,\n        address metaPool\n    );\n\n    event LogSetNewPool(\n        uint256 pid,\n        address lpToken,\n        address reward,\n        address metaPool\n    );\n    event LogAdditionalRewards(address[] rewardTokens);\n\n    event LogStopLossErrorString(uint256 stopLossAttempts, string reason);\n    event LogStopLossErrorBytes(uint256 stopLossAttempts, bytes data);\n\n    /*//////////////////////////////////////////////////////////////\n                            CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Strategy constructor\n    /// @param _vault Vault that holds the strategy\n    /// @param _pid PID of Convex reward pool\n    /// @param _metaPool Underlying meta pool\n    ///     - used when LP token and Meta pool dont match (older metapools)\n    constructor(\n        IGVault _vault,\n        address _owner,\n        uint256 _pid,\n        address _metaPool\n    ) {\n        owner = _owner;\n        VAULT = _vault;\n        ERC20 _asset = _vault.asset();\n        ASSET = _asset;\n        _asset.approve(address(_vault), type(uint256).max); // Max approve asset for Vault to save gas\n\n        ERC20(CRV).approve(CRV_ETH, type(uint256).max);\n        ERC20(CVX).approve(CVX_ETH, type(uint256).max);\n        ERC20(WETH).approve(UNI_V3, type(uint256).max);\n\n        (address lp, , , address reward, , bool shutdown) = Booster(BOOSTER)\n            .poolInfo(_pid);\n        if (shutdown) revert StrategyErrors.ConvexShutdown();\n        pid = _pid;\n        metaPool = _metaPool;\n        lpToken = ERC20(lp);\n        rewardContract = reward;\n        ERC20(CRV_3POOL_TOKEN).approve(_metaPool, type(uint256).max);\n        ERC20(USDC).approve(CRV_3POOL, type(uint256).max);\n        ERC20(lp).approve(BOOSTER, type(uint256).max);\n        emit LogChangePool(_pid, lp, reward, _metaPool);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            GETTERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Returns underlying vault\n    function vault() external view returns (address) {\n        return address(VAULT);\n    }\n\n    /// @notice Returns underlying asset\n    function asset() external view returns (address) {\n        return address(ASSET);\n    }\n\n    /// @notice Get current convex investment path including pid, meta pool, lp token and reward contract\n    function getCurrentInvestment()\n        external\n        view\n        returns (\n            uint256,\n            address,\n            address,\n            address\n        )\n    {\n        return (pid, metaPool, address(lpToken), rewardContract);\n    }\n\n    /// @notice Get current curve meta pool\n    function getMetaPool() external view returns (address) {\n        return metaPool;\n    }\n\n    /// @notice Get new convex investment path including pid, meta pool, lp token and reward contract\n    function getPlannedInvestment()\n        external\n        view\n        returns (\n            uint256,\n            address,\n            address,\n            address\n        )\n    {\n        return (newPid, newMetaPool, address(newLpToken), newRewardContract);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           SETTERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Change owner of the strategy\n    /// @param _owner new strategy owner\n    function setOwner(address _owner) external {\n        if (msg.sender != owner) revert StrategyErrors.NotOwner();\n        address previous_owner = msg.sender;\n        owner = _owner;\n\n        emit OwnershipTransferred(previous_owner, _owner);\n    }\n\n    /// @notice Add keeper from the strategy\n    /// @param _keeper keeper to add\n    function setKeeper(address _keeper) external {\n        if (msg.sender != owner) revert StrategyErrors.NotOwner();\n        keepers[_keeper] = true;\n\n        emit NewKeeper(_keeper);\n    }\n\n    /// @notice Remove keeper from the strategy\n    /// @param _keeper keeper to remove\n    function revokeKeeper(address _keeper) external {\n        if (msg.sender != owner) revert StrategyErrors.NotOwner();\n        keepers[_keeper] = false;\n\n        emit RevokedKeeper(_keeper);\n    }\n\n    /// @notice Add additional rewards provided by the curve pools\n    /// @param _tokens list of reward tokens\n    function setAdditionalRewards(address[] memory _tokens) external {\n        if (msg.sender != owner) revert StrategyErrors.NotOwner();\n        if (_tokens.length > MAX_REWARDS)\n            revert StrategyErrors.RewardsTokenMax();\n        for (uint256 i; i < rewardTokens.length; i++) {\n            ERC20(rewardTokens[i]).approve(UNI_V2, 0);\n        }\n        delete rewardTokens;\n        numberOfRewards = _tokens.length;\n        for (uint256 i; i < _tokens.length; ++i) {\n            address token = _tokens[i];\n            rewardTokens[i] = token;\n            ERC20(token).approve(UNI_V2, type(uint256).max);\n        }\n        emit LogAdditionalRewards(_tokens);\n    }\n\n    /// @notice Sets emergency mode to enable emergency exit of strategy\n    function setEmergencyMode() external {\n        if (!keepers[msg.sender]) revert StrategyErrors.NotKeeper();\n        emergencyMode = true;\n\n        emit EmergencyModeSet(true);\n    }\n\n    /// @notice Set thresholds for when harvest should occur due to profit/loss\n    /// @param _debtThreshold Amount of debt/loss the strategy can accumulate before reporting\n    /// @param _profitThreshold Amount of profit the strategy can accumulate before reporting\n    function setHarvestThresholds(\n        uint256 _debtThreshold,\n        uint256 _profitThreshold\n    ) external {\n        if (msg.sender != owner) revert StrategyErrors.NotOwner();\n        debtThreshold = _debtThreshold;\n        profitThreshold = _profitThreshold;\n        emit LogNewHarvestThresholds(_debtThreshold, _profitThreshold);\n    }\n\n    /// @notice Restarts strategy after stop-loss has been triggered\n    function resume() external {\n        if (msg.sender != owner) revert StrategyErrors.NotOwner();\n        stop = false;\n    }\n\n    /// @notice Set new stop loss logic\n    function setStopLossLogic(address _newStopLoss) external {\n        if (msg.sender != owner) revert StrategyErrors.NotOwner();\n        stopLossLogic = _newStopLoss;\n        emit LogNewStopLoss(_newStopLoss);\n    }\n\n    /// @notice Set a new base slippage\n    function setBaseSlippage(uint256 _baseSlippage) external {\n        if (msg.sender != owner) revert StrategyErrors.NotOwner();\n        baseSlippage = _baseSlippage;\n        emit LogNewBaseSlippage(_baseSlippage);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           STRATEGY ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Get strategies current assets\n    function estimatedTotalAssets() external view returns (uint256) {\n        (uint256 _assets, , ) = _estimatedTotalAssets(true);\n        return _assets;\n    }\n\n    /// @notice Internal call of function above\n    /// @param _rewards include rewards in return\n    function _estimatedTotalAssets(bool _rewards)\n        internal\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        uint256 _balance = ASSET.balanceOf(address(this));\n        uint256 _poolAssets = poolAssets();\n        uint256 _rewardAmounts;\n        if (_rewards) {\n            _rewardAmounts = rewards();\n        }\n        return (\n            _balance + _poolAssets + _rewardAmounts,\n            _balance,\n            _rewardAmounts\n        );\n    }\n\n    /// @notice Get value of strategy LP position\n    function poolAssets() internal view returns (uint256) {\n        if (rewardContract == address(0)) return 0;\n        uint256 lpAmount = Rewards(rewardContract).balanceOf(address(this));\n        if (lpAmount == 0) return 0;\n        return\n            ICurveMeta(metaPool).calc_withdraw_one_coin(lpAmount, CRV3_INDEX);\n    }\n\n    /// @notice Claim and sell off all reward tokens for underlying asset\n    function sellAllRewards() internal returns (uint256) {\n        Rewards(rewardContract).getReward();\n        return _sellRewards();\n    }\n\n    /// @notice Return combined value of all reward tokens in underlying asset\n    function rewards() public view returns (uint256) {\n        return _claimableRewards() + _additionalRewardTokens();\n    }\n\n    /// @notice Get price of cvx/crv in eth\n    /// @param _pool CVX/CRV pool\n    /// @param _amount Amount of rewards to swap\n    function getPriceCurve(address _pool, uint256 _amount)\n        public\n        view\n        returns (uint256 price)\n    {\n        return ICurveRewards(_pool).get_dy(CRV_ETH_INDEX, 0, _amount);\n    }\n\n    /// @notice Get Uniswap v2 price of token in base asset\n    /// @dev rather than going through the sell path of\n    ///     uni v2 => v3 => curve\n    ///     we just use univ2 to estimate the value\n    /// @param _token Token to swap\n    /// @param _amount Amount to swap\n    function getPriceV2(address _token, uint256 _amount)\n        internal\n        view\n        returns (uint256 price)\n    {\n        uint256[] memory crvSwap = IUniV2(UNI_V2).getAmountsOut(\n            _amount,\n            _getPath(_token, false)\n        );\n        return crvSwap[crvSwap.length - 1];\n    }\n\n    /// @notice Calculate the value of ETH in Base asset, taking the route:\n    ///     ETH => USDC => 3Crv\n    /// @param _amount Amount of token to swap\n    function getPriceV3(uint256 _amount) public view returns (uint256 price) {\n        (uint160 sqrtPriceX96, , , , , , ) = IUniV3_POOL(USDC_ETH_V3).slot0();\n        price = ((2**192 * DEFAULT_DECIMALS_FACTOR) / uint256(sqrtPriceX96)**2);\n        // we assume a dollar price of usdc and divide it by the 3pool\n        //  virtual price to get an estimate for the number of tokens we will get\n        return\n            _amount *\n            ((price * 1E12) / ICurve3Pool(CRV_3POOL).get_virtual_price());\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           REWARDS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Value of additional rewards tokens available to claim,\n    ///     denoted in base asset\n    function _additionalRewardTokens() internal view returns (uint256) {\n        uint256 _totalAmount;\n        uint256 _tokenAmount;\n        address _token;\n        for (uint256 i; i < numberOfRewards; ++i) {\n            _token = rewardTokens[i];\n            if (_token == address(0)) break;\n            _tokenAmount = ERC20(_token).balanceOf(address(this));\n            if (_tokenAmount > 0)\n                _totalAmount += getPriceV2(_token, _tokenAmount);\n        }\n        return _totalAmount;\n    }\n\n    /// @notice Value of CRV/CVX available to claim, denoted in base asset\n    function _claimableRewards() internal view returns (uint256) {\n        uint256 crv = Rewards(rewardContract).earned(address(this));\n\n        // calculations pulled directly from CVX's contract for minting CVX per CRV claimed\n        uint256 supply = ERC20(CVX).totalSupply();\n        uint256 cvx;\n\n        uint256 cliff = supply / REDUCTION_PER_CLIFF;\n        // mint if below total cliffs\n        if (cliff < TOTAL_CLIFFS) {\n            // for reduction% take inverse of current cliff\n            uint256 reduction = TOTAL_CLIFFS - cliff;\n            // reduce\n            cvx = (crv * reduction) / TOTAL_CLIFFS;\n\n            // supply cap check\n            uint256 amtTillMax = MAX_SUPPLY - supply;\n            if (cvx > amtTillMax) {\n                cvx = amtTillMax;\n            }\n        }\n\n        uint256 crvValue;\n        if (crv > MIN_REWARD_SELL_AMOUNT) {\n            crvValue = getPriceCurve(CRV_ETH, crv);\n        }\n\n        uint256 cvxValue;\n        if (cvx > MIN_REWARD_SELL_AMOUNT) {\n            cvxValue = getPriceCurve(CVX_ETH, cvx);\n        }\n\n        if (crvValue + cvxValue > MIN_WETH_SELL_AMOUNT) {\n            return getPriceV3(crvValue + cvxValue);\n        }\n    }\n\n    /// @notice Sell available reward tokens for underlying asset\n    /// @return Contracts total amount of base assets\n    /// @dev Sell path for CRV/CVX:\n    ///     Reward => ETH => USDC => Asset\n    ///     <CRV/CVX-ETH pool> => <UNI v3> => 3Pool\n    ///      Sell path for addition rewards\n    ///     Add. rewards => ETH => USDC => Asset\n    ///     <UNI v2> => <UNI v2>\n    function _sellRewards() internal returns (uint256) {\n        uint256 wethAmount = ERC20(WETH).balanceOf(address(this));\n        uint256 _numberOfRewards = numberOfRewards;\n\n        if (_numberOfRewards > 0) {\n            wethAmount += _sellAdditionalRewards(_numberOfRewards);\n        }\n\n        uint256 cvx = ERC20(CVX).balanceOf(address(this));\n        if (cvx > MIN_REWARD_SELL_AMOUNT) {\n            wethAmount += ICurveRewards(CVX_ETH).exchange(\n                CRV_ETH_INDEX,\n                0,\n                cvx,\n                0,\n                false\n            );\n        }\n\n        uint256 crv = ERC20(CRV).balanceOf(address(this));\n        if (crv > MIN_REWARD_SELL_AMOUNT) {\n            wethAmount += ICurveRewards(CRV_ETH).exchange(\n                CRV_ETH_INDEX,\n                0,\n                crv,\n                0,\n                false\n            );\n        }\n\n        if (wethAmount > MIN_WETH_SELL_AMOUNT) {\n            uint256[3] memory _amounts;\n            _amounts[1] = IUniV3(UNI_V3).exactInput(\n                IUniV3.ExactInputParams(\n                    abi.encodePacked(WETH, uint24(UNI_V3_FEE), USDC),\n                    address(this),\n                    block.timestamp,\n                    wethAmount,\n                    0\n                )\n            );\n            ICurve3Pool(CRV_3POOL).add_liquidity(_amounts, 0);\n            return CRV_3POOL_TOKEN.balanceOf(address(this));\n        }\n    }\n\n    /// @notice Sell additional rewards for WETH\n    /// @param _number_of_rewards number of reward tokens\n    function _sellAdditionalRewards(uint256 _number_of_rewards)\n        internal\n        returns (uint256)\n    {\n        uint256 wethAmount;\n        uint256 reward_amount;\n        address reward_token;\n        for (uint256 i; i < _number_of_rewards; ++i) {\n            reward_token = rewardTokens[i];\n            reward_amount = ERC20(reward_token).balanceOf(address(this));\n            if (reward_amount > MIN_REWARD_SELL_AMOUNT) {\n                uint256[] memory swap = IUniV2(UNI_V2).swapExactTokensForTokens(\n                    reward_amount,\n                    uint256(0),\n                    _getPath(rewardTokens[i], true),\n                    address(this),\n                    block.timestamp\n                );\n                wethAmount += swap[swap.length - 1];\n            }\n        }\n        return wethAmount;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           CORE LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Withdraw assets from the strategy to the Vault -\n    ///    If the strategy has a loss, this loss will be distributed\n    ///     proportionally on the user withdrawing\n    /// @param _amount asset quantity needed to be withdrawn by Vault\n    /// @return withdrawnAssets amount of assets that were withdrawn from the strategy\n    /// @return loss amount of loss that occurred during withdrawal\n    function withdraw(uint256 _amount)\n        external\n        returns (uint256 withdrawnAssets, uint256 loss)\n    {\n        if (msg.sender != address(VAULT)) revert StrategyErrors.NotVault();\n        (uint256 assets, uint256 balance, ) = _estimatedTotalAssets(false);\n        uint256 debt = VAULT.getStrategyDebt();\n        // not enough assets to withdraw\n        if (_amount >= assets && _amount == debt) {\n            balance = sellAllRewards();\n            balance += divestAll(false);\n            if (_amount > balance) {\n                loss = _amount - balance;\n                withdrawnAssets = balance;\n            } else {\n                withdrawnAssets = _amount;\n            }\n        } else {\n            // check if there is a loss, and distribute it proportionally\n            //  if it exists\n            if (debt > assets) {\n                loss = ((debt - assets) * _amount) / debt;\n                _amount = _amount - loss;\n            }\n            if (_amount <= balance) {\n                withdrawnAssets = _amount;\n            } else {\n                withdrawnAssets = divest(_amount - balance, false) + balance;\n                if (withdrawnAssets <= _amount) {\n                    loss += _amount - withdrawnAssets;\n                } else {\n                    if (loss > withdrawnAssets - _amount) {\n                        loss -= withdrawnAssets - _amount;\n                    } else {\n                        loss = 0;\n                    }\n                }\n            }\n        }\n        ASSET.transfer(msg.sender, withdrawnAssets);\n        return (withdrawnAssets, loss);\n    }\n\n    /// @notice Calculated the strategies current PnL and attempts to pay back any excess\n    ///     debt the strategy has to the vault.\n    /// @param _excessDebt Amount of debt that the strategy should pay back\n    /// @param _debtRatio ratio of total vault assets the strategy is entitled to\n    function realisePnl(uint256 _excessDebt, uint256 _debtRatio)\n        internal\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        uint256 profit;\n        uint256 loss;\n        uint256 debtRepayment;\n\n        uint256 debt = VAULT.getStrategyDebt();\n\n        (\n            uint256 assets,\n            uint256 balance,\n            uint256 _rewards\n        ) = _estimatedTotalAssets(true);\n\n        if (_rewards > MIN_REWARD_SELL_AMOUNT) balance = sellAllRewards();\n        if (_excessDebt > assets) {\n            debtRepayment = balance + divestAll(false);\n            loss = debt - debtRepayment;\n            balance = debtRepayment;\n        } else {\n            if (assets > debt) {\n                profit = assets - debt;\n                if (profit > profitThreshold) {\n                    uint256 profitToRepay = (profit *\n                        (PERCENTAGE_DECIMAL_FACTOR - _debtRatio)) /\n                        PERCENTAGE_DECIMAL_FACTOR;\n                    if (profitToRepay + _excessDebt > balance) {\n                        balance += divest(\n                            profitToRepay + _excessDebt - balance,\n                            true\n                        );\n                        debtRepayment = balance;\n                    } else {\n                        debtRepayment = profitToRepay + _excessDebt;\n                    }\n                }\n            } else if (assets < debt) {\n                loss = debt - assets;\n                // here for safety, but should really never be the case\n                //  that loss > _excessDebt\n                if (loss > _excessDebt) debtRepayment = 0;\n                else if (balance < _excessDebt - loss) {\n                    balance += divest(_excessDebt - loss - balance, true);\n                    debtRepayment = balance;\n                } else debtRepayment = _excessDebt - loss;\n            }\n        }\n        return (profit, loss, debtRepayment, balance);\n    }\n\n    /// @notice Attempts to remove assets from active Convex position\n    /// @param _debt Amount to divest from position\n    /// @param _slippage control for when harvest divests\n    /// @dev slippage control for users not necessary as they would check for\n    ///     user specified minAmount in the vault/zapper\n    function divest(uint256 _debt, bool _slippage) internal returns (uint256) {\n        uint256 meta_amount = ICurveMeta(metaPool).calc_token_amount(\n            [0, _debt],\n            false\n        );\n        if (_slippage) {\n            uint256 ratio = curveValue();\n            if (\n                (meta_amount * ratio) / PERCENTAGE_DECIMAL_FACTOR <\n                ((_debt * (PERCENTAGE_DECIMAL_FACTOR - baseSlippage)) /\n                    PERCENTAGE_DECIMAL_FACTOR)\n            ) {\n                revert StrategyErrors.LTMinAmountExpected();\n            }\n        }\n        Rewards(rewardContract).withdrawAndUnwrap(meta_amount, false);\n        return\n            ICurveMeta(metaPool).remove_liquidity_one_coin(\n                meta_amount,\n                CRV3_INDEX,\n                0\n            );\n    }\n\n    /// @notice Remove all assets from active Convex position\n    /// @param _slippage Slippage control for invest function\n    /// @dev slippage control only occurs when large amounts of credits are moved\n    ///     out of a meta vault\n    function divestAll(bool _slippage) internal returns (uint256) {\n        if (Rewards(rewardContract).balanceOf(address(this)) == 0) {\n            if (lpToken.balanceOf(address(this)) < 1E18) {\n                return 0;\n            }\n        } else {\n            Rewards(rewardContract).withdrawAllAndUnwrap(false);\n        }\n        uint256 minAmount;\n        if (_slippage) {\n            uint256 debt = VAULT.getStrategyDebt();\n            uint256 slippage = baseSlippage;\n            minAmount =\n                (debt *\n                    (PERCENTAGE_DECIMAL_FACTOR -\n                        slippage *\n                        (stopLossAttempts + 1))) /\n                PERCENTAGE_DECIMAL_FACTOR;\n            try\n                ICurveMeta(metaPool).remove_liquidity_one_coin(\n                    lpToken.balanceOf(address(this)),\n                    CRV3_INDEX,\n                    minAmount\n                )\n            returns (uint256 _amount) {\n                return _amount;\n            } catch Error(string memory reason) {\n                emit LogStopLossErrorString(stopLossAttempts, reason);\n                return 0;\n            } catch (bytes memory lowLevelData) {\n                emit LogStopLossErrorBytes(stopLossAttempts, lowLevelData);\n                return 0;\n            }\n        } else {\n            uint256 amount = ICurveMeta(metaPool).remove_liquidity_one_coin(\n                lpToken.balanceOf(address(this)),\n                CRV3_INDEX,\n                minAmount\n            );\n            return amount;\n        }\n    }\n\n    /// @notice Invest loose assets into current convex position\n    /// @param _credit Amount available to invest\n    function invest(uint256 _credit) internal returns (uint256) {\n        uint256 amount = ICurveMeta(metaPool).add_liquidity([0, _credit], 0);\n\n        uint256 ratio = curveValue();\n        if (\n            (amount * ratio) / PERCENTAGE_DECIMAL_FACTOR <\n            ((_credit * (PERCENTAGE_DECIMAL_FACTOR - baseSlippage)) /\n                PERCENTAGE_DECIMAL_FACTOR)\n        ) {\n            revert StrategyErrors.LTMinAmountExpected();\n        }\n\n        Booster(BOOSTER).deposit(pid, amount, true);\n        return amount;\n    }\n\n    /// @notice Reports back any gains/losses that the strategy has made to the vault\n    ///     and gets additional credit/pays back debt depending on credit availability\n    function runHarvest() external {\n        if (!keepers[msg.sender]) revert StrategyErrors.NotKeeper();\n        if (stop) revert StrategyErrors.Stopped();\n        (uint256 excessDebt, uint256 debtRatio) = VAULT.excessDebt(\n            address(this)\n        );\n        uint256 profit;\n        uint256 loss;\n        uint256 debtRepayment;\n\n        uint256 balance;\n        bool emergency;\n\n        // separate logic for emergency mode which needs implementation\n        if (emergencyMode) {\n            sellAllRewards();\n            divestAll(false);\n            emergency = true;\n            debtRepayment = ASSET.balanceOf(address(this));\n            uint256 debt = VAULT.getStrategyDebt();\n            if (debt > debtRepayment) loss = debt - debtRepayment;\n            else profit = debtRepayment - debt;\n        } else {\n            if (newMetaPool != address(0)) {\n                sellAllRewards();\n                divestAll(true);\n                migratePool();\n            }\n            (profit, loss, debtRepayment, balance) = realisePnl(\n                excessDebt,\n                debtRatio\n            );\n        }\n        uint256 credit = VAULT.report(profit, loss, debtRepayment, emergency);\n\n        // invest any free funds in the strategy\n        if (balance + credit > debtRepayment + INVESTMENT_BUFFER) {\n            invest(balance + credit - debtRepayment);\n        }\n\n        emit Harvested(profit, loss, debtRepayment, excessDebt);\n    }\n\n    /// @notice Pulls out all funds into strategies base asset and stops\n    ///     the strategy from being able to run harvest. Reports back\n    ///     any gains/losses from this action to the vault\n    function stopLoss() external returns (bool) {\n        if (!keepers[msg.sender]) revert StrategyErrors.NotKeeper();\n        if (stopLossAttempts == 0) sellAllRewards();\n        if (divestAll(true) == 0) {\n            stopLossAttempts += 1;\n            return false;\n        }\n        uint256 debt = VAULT.getStrategyDebt();\n        uint256 balance = ASSET.balanceOf(address(this));\n        uint256 loss;\n        uint256 profit;\n        // we expect losses, but should account for a situation that\n        //     produces gains\n        if (debt > balance) {\n            loss = debt - balance;\n        } else {\n            profit = balance - debt;\n        }\n        // We dont attempt to repay anything - follow up actions need\n        //  to be taken to withdraw any assets from the strategy\n        VAULT.report(profit, loss, 0, false);\n        stop = true;\n        stopLossAttempts = 0;\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           TRIGGERS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Checks if the strategy should be harvested\n    function canHarvest() external view returns (bool) {\n        (bool active, uint256 totalDebt, uint256 lastReport) = VAULT\n            .getStrategyData();\n\n        // Should not trigger if strategy is not activated\n        if (!active) return false;\n        if (stop) return false;\n\n        // Should trigger if hadn't been called in a while\n        uint256 timeSinceLastHarvest = block.timestamp - lastReport;\n        if (timeSinceLastHarvest > MAX_REPORT_DELAY) return true;\n\n        // Check for profits and losses\n        (uint256 assets, , ) = _estimatedTotalAssets(true);\n        uint256 debt = totalDebt;\n        (uint256 excessDebt, ) = VAULT.excessDebt(address(this));\n        uint256 profit;\n        if (assets > debt) {\n            profit = assets - debt;\n        } else {\n            excessDebt += debt - assets;\n        }\n        profit += VAULT.creditAvailable();\n        if (excessDebt > debtThreshold) return true;\n        if (profit > profitThreshold && timeSinceLastHarvest > MIN_REPORT_DELAY)\n            return true;\n\n        return false;\n    }\n\n    /// @notice Check if stop loss needs to be triggered\n    function canStopLoss() external view returns (bool) {\n        if (stop) return false;\n        IStop _stopLoss = IStop(stopLossLogic);\n        if (address(_stopLoss) == address(0)) return false;\n        return _stopLoss.stopLossCheck();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           POOL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Prepare the strategy for migration to a new convex pool\n    /// @param _newPid pid of the convex reward pool\n    /// @param _newMetaPool meta pool specified in cased where pool != lp token\n    function setPool(uint256 _newPid, address _newMetaPool) external {\n        if (msg.sender != owner) revert StrategyErrors.NotOwner();\n        if (_newPid == pid) revert StrategyErrors.SamePid();\n\n        // remove old approval\n        CRV_3POOL_TOKEN.approve(metaPool, 0);\n        lpToken.approve(BOOSTER, 0);\n\n        (address lp, , , address _reward, , bool shutdown) = Booster(BOOSTER)\n            .poolInfo(_newPid);\n        if (shutdown) revert StrategyErrors.ConvexShutdown();\n        ERC20 _newLpToken = ERC20(lp);\n        newLpToken = _newLpToken;\n        newRewardContract = _reward;\n        newPid = _newPid;\n        newMetaPool = _newMetaPool;\n\n        // add new approval\n        if (CRV_3POOL_TOKEN.allowance(address(this), _newMetaPool) == 0) {\n            CRV_3POOL_TOKEN.approve(_newMetaPool, type(uint256).max);\n        }\n        if (_newLpToken.allowance(address(this), BOOSTER) == 0) {\n            _newLpToken.approve(BOOSTER, type(uint256).max);\n        }\n        emit LogSetNewPool(_newPid, lp, _reward, _newMetaPool);\n    }\n\n    /// @notice Migrate investment to a new convex pool\n    function migratePool() internal {\n        uint256 _newPid = newPid;\n        address _newMetaPool = newMetaPool;\n        ERC20 _newLpToken = newLpToken;\n        address _newReward = newRewardContract;\n\n        pid = _newPid;\n        metaPool = _newMetaPool;\n        lpToken = _newLpToken;\n        rewardContract = _newReward;\n\n        newMetaPool = address(0);\n        newPid = 0;\n        newLpToken = ERC20(address(0));\n        newRewardContract = address(0);\n\n        emit LogChangePool(\n            _newPid,\n            address(_newLpToken),\n            _newReward,\n            _newMetaPool\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          HELPER FUNCTIONS \n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Generate paths for swaps\n    /// @param _from starting token\n    /// @param _base swapping for ETH\n    function _getPath(address _from, bool _base)\n        internal\n        view\n        returns (address[] memory)\n    {\n        address[] memory path;\n        if (_base) {\n            path = new address[](2);\n            path[0] = _from;\n            path[1] = WETH;\n        } else {\n            path = new address[](4);\n            path[0] = _from;\n            path[1] = WETH;\n            path[2] = USDC;\n            path[3] = address(ASSET);\n        }\n        return path;\n    }\n\n    /// @notice Get ratio between meta pool tokens\n    function curveValue() internal view returns (uint256) {\n        uint256 three_pool_vp = ICurve3Pool(CRV_3POOL).get_virtual_price();\n        uint256 meta_pool_vp = ICurveMeta(metaPool).get_virtual_price();\n        return (meta_pool_vp * PERCENTAGE_DECIMAL_FACTOR) / three_pool_vp;\n    }\n\n    /// @notice sweep unwanted tokens from the contract\n    /// @param _recipient of the token\n    /// @param _token address of\n    function sweep(address _recipient, address _token) external {\n        if (msg.sender != owner) revert StrategyErrors.NotOwner();\n        if (address(ASSET) == _token) revert StrategyErrors.BaseAsset();\n        if (address(lpToken) == _token) revert StrategyErrors.LpToken();\n        if (address(rewardContract) == _token)\n            revert StrategyErrors.ConvexToken();\n        uint256 _amount = ERC20(_token).balanceOf(address(this));\n        ERC20(_token).transfer(_recipient, _amount);\n    }\n}\n"

    },

    "ICurve3Pool.sol": {

      "content": "// SPDX-License-Identifier: AGPLv3\npragma solidity 0.8.10;\n\n/// Curve 3pool interface\ninterface ICurve3Pool {\n    function get_virtual_price() external view returns (uint256);\n\n    function add_liquidity(\n        uint256[3] calldata _deposit_amounts,\n        uint256 _min_mint_amount\n    ) external;\n\n    function remove_liquidity_one_coin(\n        uint256 _token_amount,\n        int128 i,\n        uint256 min_amount\n    ) external;\n\n    function balanceOf(address account) external view returns (uint256);\n}\n"

    },

    "ICurveMeta.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\n/// Curve metapool interface\ninterface ICurveMeta {\n    function get_virtual_price() external view returns (uint256);\n\n    function calc_withdraw_one_coin(uint256 _tokenAmount, int128 i)\n        external\n        view\n        returns (uint256);\n\n    function calc_token_amount(uint256[2] calldata inAmounts, bool deposit)\n        external\n        view\n        returns (uint256);\n\n    function add_liquidity(\n        uint256[2] calldata uamounts,\n        uint256 min_mint_amount\n    ) external returns (uint256);\n\n    function remove_liquidity_one_coin(\n        uint256 _tokenAmount,\n        int128 i,\n        uint256 min_uamount\n    ) external returns (uint256);\n\n    function get_dy(\n        int128 i,\n        int128 j,\n        uint256 dx\n    ) external view returns (uint256);\n}\n"

    },

    "IStop.sol": {

      "content": "// SPDX-License-Identifier: AGPLv3\npragma solidity 0.8.10;\n\n/// Stop loss logic interface\ninterface IStop {\n    function stopLossCheck() external view returns (bool);\n}\n"

    },

    "IStrategy.sol": {

      "content": "// SPDX-License-Identifier: AGPLv3\npragma solidity 0.8.10;\n\ninterface IStrategy {\n    function asset() external view returns (address);\n\n    function vault() external view returns (address);\n\n    function isActive() external view returns (bool);\n\n    function estimatedTotalAssets() external view returns (uint256);\n\n    function withdraw(uint256 _amount) external returns (uint256, uint256);\n\n    function canHarvest() external view returns (bool);\n\n    function runHarvest() external;\n\n    function canStopLoss() external view returns (bool);\n\n    function stopLoss() external returns (bool);\n\n    function getMetaPool() external view returns (address);\n}\n"

    },

    "IGVault.sol": {

      "content": "// SPDX-License-Identifier: AGPLv3\npragma solidity 0.8.10;\nimport {ERC20} from \"ERC20.sol\";\nimport {IStrategy} from \"IStrategy.sol\";\n\n/// GVault interface\ninterface IGVault {\n    function asset() external view returns (ERC20);\n\n    function excessDebt(address _strategy)\n        external\n        view\n        returns (uint256, uint256);\n\n    function getStrategyDebt() external view returns (uint256);\n\n    function creditAvailable() external view returns (uint256);\n\n    function report(\n        uint256 _gain,\n        uint256 _loss,\n        uint256 _debtRepayment,\n        bool _emergency\n    ) external returns (uint256);\n\n    function getStrategyData()\n        external\n        view\n        returns (\n            bool,\n            uint256,\n            uint256\n        );\n}\n"

    },

    "ERC20.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 amount\n    );\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                             EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    bytes32 public constant PERMIT_TYPEHASH =\n        keccak256(\n            \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n        );\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        returns (bool)\n    {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount)\n        public\n        virtual\n        returns (bool)\n    {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max)\n            allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            bytes32 digest = keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(\n                        abi.encode(\n                            PERMIT_TYPEHASH,\n                            owner,\n                            spender,\n                            value,\n                            nonces[owner]++,\n                            deadline\n                        )\n                    )\n                )\n            );\n\n            address recoveredAddress = ecrecover(digest, v, r, s);\n\n            require(\n                recoveredAddress != address(0) && recoveredAddress == owner,\n                \"INVALID_SIGNER\"\n            );\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return\n            block.chainid == INITIAL_CHAIN_ID\n                ? INITIAL_DOMAIN_SEPARATOR\n                : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                    ),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"

    }

  },

  "settings": {

    "evmVersion": "istanbul",

    "optimizer": {

      "enabled": true,

      "runs": 200

    },

    "libraries": {

      "ConvexStrategy.sol": {}

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    }

  }

}}