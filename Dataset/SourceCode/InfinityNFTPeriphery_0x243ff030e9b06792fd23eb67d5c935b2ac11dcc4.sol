{{

  "language": "Solidity",

  "sources": {

    "InfinityNFTPeriphery.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.19;\n\nimport \"TransferHelper.sol\";\nimport \"XfaiLibrary.sol\";\n\nimport \"IInfinityNFTPeriphery.sol\";\nimport \"IXfaiINFT.sol\";\nimport \"IXfaiV0Core.sol\";\nimport \"IXfaiFactory.sol\";\nimport \"IWETH.sol\";\n\ncontract InfinityNFTPeriphery is IInfinityNFTPeriphery {\n  /**\n   * @notice The factory address of xfai\n   */\n  address private immutable factory;\n\n  /**\n   * @notice The old factory address of xfai\n   */\n  address private immutable optionalOldFactory;\n\n  /**\n   * @notice The INFT address of xfai\n   */\n  address private immutable infinityNFT;\n\n  /**\n   * @notice The address of the underlying ERC20 token used for infinity staking / boosting within the INFT contract\n   */\n  address private immutable xfit;\n\n  /**\n   * @notice The address of the xfETH token\n   */\n  address private immutable xfETH;\n\n  /**\n   * @notice The weth address.\n   * @dev In the case of a chain ID other than Ethereum, the wrapped ERC20 token address of the chain's native coin\n   */\n  address private immutable weth;\n\n  /**\n   * @notice The XfaiV0Core address of Xfai\n   */\n  address private immutable core;\n\n  /**\n   * @notice The code hash od XfaiPool\n   * @dev keccak256(type(XfaiPool).creationCode)\n   */\n  bytes32 private immutable poolCodeHash;\n\n  modifier ensure(uint deadline) {\n    require(deadline >= block.timestamp, 'InfinityNFTPeriphery: EXPIRED');\n    _;\n  }\n\n  constructor(\n    address _factory,\n    address _optionalOldFactory,\n    address _xfETH,\n    address _infinityNFT,\n    address _xfit,\n    address _weth\n  ) {\n    factory = _factory;\n    optionalOldFactory = _optionalOldFactory;\n    core = IXfaiFactory(_factory).getXfaiCore();\n    xfETH = _xfETH;\n    infinityNFT = _infinityNFT;\n    xfit = _xfit;\n    weth = _weth;\n    poolCodeHash = IXfaiFactory(_factory).poolCodeHash();\n  }\n\n  /**\n   * @notice Performs one-sided infinity staking and mints in return an INFT. The share of the INFT depends on the amount of underlying tokens staked, and the existing underlying reserve within the INFT contract.\n   * @dev This low-level function should be called from a contract which performs important safety checks.\n   * This function locks the pool of _token0 and _token1 to prevent reentrancy attacks.\n   * This function cannot be called to stake underlying tokens directly. It only accepts ERC20 tokens as _token0 that are hosted on Dexfai and that are not xfit.\n   * To stake underlying tokens directly, use the mint function of the INFT contract.\n   * @param _token0 An ERC20 token address. Token must have already a pool\n   * @param _to The address of the recipient that receives the minted INFT\n   * @return share The share value of the minted INFT\n   */\n  function _infinityStake(address _token0, address _to) private returns (uint share) {\n    uint id;\n    (, uint amount1Out) = IXfaiV0Core(core).swap(_token0, xfit, optionalOldFactory);\n    (id, share) = IXfaiINFT(infinityNFT).mint(_to);\n    emit InfinityStake(msg.sender, amount1Out, share, id);\n  }\n\n  /**\n   * @notice Performs one-sided infinity boosting and increases the share of an already existing INFT. The new share of the INFT depends on the amount of underlying tokens staked, and the existing underlying reserve within the INFT contract.\n   * @dev This low-level function should be called from a contract which performs important safety checks.\n   * This function locks the pool of _token0 and _token1 to prevent reentrancy attacks.\n   * This function cannot be called to boost underlying tokens directly. It only accepts ERC20 tokens as _token0 that are hosted on Dexfai and that are not xfit.\n   * To boost an INFt via underlying tokens directly, use the boost function of the INFT contract.\n   * @param _id The token ID of the INFT\n   * @param _token0 An ERC20 token address. Token must have already a pool\n   * @return share The share value added to an INFT\n   */\n  function _infinityBoost(uint _id, address _token0) private returns (uint share) {\n    (, uint amount1Out) = IXfaiV0Core(core).swap(_token0, xfit, optionalOldFactory);\n    share = IXfaiINFT(infinityNFT).boost(_id);\n    emit InfinityBoost(msg.sender, amount1Out, share, _id);\n  }\n\n  // **** Permanent Staking ****\n  // requires the initial amount to have already been sent to the first pair\n\n  /**\n   * @notice Permanently stake liquidity within Xfai\n   * @dev Requires _token0 approval. At the end of the function call, an INFT is minted. The share of witch depends on the exchange value of _amount0In in terms of xfit and the INFT's reserve.\n   * @param _to The address of the recipient\n   * @param _token0 An ERC20 token address\n   * @param _amount0In The amount of _token0 to be permanently staked\n   * @param _shareMin The minimal amount of INFT shares that the user will accept for a given _amount0In\n   * @param _deadline The UTC timestamp that if reached, causes the transaction to fail automatically\n   * @return share The share of the minted INFT\n   */\n  function permanentStaking(\n    address _to,\n    address _token0,\n    uint _amount0In,\n    uint _shareMin,\n    uint _deadline\n  ) external override ensure(_deadline) returns (uint share) {\n    if (_token0 == xfit) {\n      TransferHelper.safeTransferFrom(_token0, msg.sender, optionalOldFactory, _amount0In);\n      (, share) = IXfaiINFT(infinityNFT).mint(_to);\n    } else {\n      address pool0 = _token0 == xfETH\n        ? XfaiLibrary.poolFor(xfit, factory, poolCodeHash)\n        : XfaiLibrary.poolFor(_token0, factory, poolCodeHash);\n      TransferHelper.safeTransferFrom(_token0, msg.sender, pool0, _amount0In);\n      share = _infinityStake(_token0, _to);\n    }\n    require(share >= _shareMin, 'InfinityNFTPeriphery: INSUFFICIENT_SHARE');\n  }\n\n  /**\n   * @notice Permanently stake ether within Xfai\n   * @dev At the end of the function call, an INFT is minted. The share of witch depends on the exchange value of _amount0In in terms of xfit and the INFT's reserve.\n   * @param _to The address of the recipient\n   * @param _shareMin The minimal amount of INFT shares that the user will accept for a given _amount0In\n   * @param _deadline The UTC timestamp that if reached, causes the swap transaction to fail automatically\n   * @return share The share of the minted INFT\n   */\n  function permanentStakingEth(\n    address _to,\n    uint _shareMin,\n    uint _deadline\n  ) external payable override ensure(_deadline) returns (uint share) {\n    address wrappedETH = weth; // gas savings\n    uint amount0In = msg.value;\n    address pool0 = XfaiLibrary.poolFor(wrappedETH, factory, poolCodeHash);\n    IWETH(wrappedETH).deposit{value: amount0In}();\n    assert(IWETH(wrappedETH).transfer(pool0, amount0In));\n    share = _infinityStake(wrappedETH, _to);\n    require(share >= _shareMin, 'InfinityNFTPeriphery: INSUFFICIENT_SHARE');\n  }\n\n  // **** Permanent Boosting ****\n  // requires the initial amount to have already been sent to the first pair\n\n  /**\n   * @notice Permanently stake liquidity within Xfai\n   * @dev Requires _token0 approval. At the end of the function call, the share value of an existing INFT is increased. The share of witch depends on the exchange value of _amount0In in terms of xfit and the INFT's reserve.\n   * @param _token0 An ERC20 token address\n   * @param _amount0In The amount of _token0 to be permanently staked\n   * @param _shareMin The minimal amount of INFT shares that the user will accept for a given _amount0In\n   * @param _id The token ID of the INFT\n   * @param _deadline The UTC timestamp that if reached, causes the swap transaction to fail automatically\n   * @return share The new share of the INFT\n   */\n  function permanentBoosting(\n    address _token0,\n    uint _amount0In,\n    uint _shareMin,\n    uint _id,\n    uint _deadline\n  ) external override ensure(_deadline) returns (uint share) {\n    if (_token0 == xfit) {\n      TransferHelper.safeTransferFrom(_token0, msg.sender, optionalOldFactory, _amount0In);\n      share = IXfaiINFT(infinityNFT).boost(_id);\n    } else {\n      address pool0 = _token0 == xfETH\n        ? XfaiLibrary.poolFor(xfit, factory, poolCodeHash)\n        : XfaiLibrary.poolFor(_token0, factory, poolCodeHash);\n      TransferHelper.safeTransferFrom(_token0, msg.sender, pool0, _amount0In);\n      share = _infinityBoost(_id, _token0);\n    }\n    require(share >= _shareMin, 'InfinityNFTPeriphery: INSUFFICIENT_SHARE');\n  }\n\n  /**\n   * @notice Permanently stake liquidity within Xfai\n   * @dev Requires _token0 approval. At the end of the function call, the share value of an existing INFT is increased. The share of witch depends on the exchange value of _amount0In in terms of xfit and the INFT's reserve.\n   * @param _shareMin The minimal amount of INFT shares that the user will accept for a given amount of ether\n   * @param _id The token ID of the INFT\n   * @param _deadline The UTC timestamp that if reached, causes the swap transaction to fail automatically\n   * @return share The new share of the INFT\n   */\n  function permanentBoostingEth(\n    uint _shareMin,\n    uint _id,\n    uint _deadline\n  ) external payable override ensure(_deadline) returns (uint share) {\n    address wrappedETH = weth; // gas savings\n    uint amount0In = msg.value;\n    address pool0 = XfaiLibrary.poolFor(wrappedETH, factory, poolCodeHash);\n    IWETH(wrappedETH).deposit{value: amount0In}();\n    assert(IWETH(wrappedETH).transfer(pool0, amount0In));\n    share = _infinityBoost(_id, wrappedETH);\n    require(share >= _shareMin, 'InfinityNFTPeriphery: INSUFFICIENT_SHARE');\n  }\n}\n"

    },

    "TransferHelper.sol": {

      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.19;\n\nimport \"IERC20.sol\";\n\nlibrary TransferHelper {\n  function safeTransferFrom(address _token, address _from, address _to, uint256 _value) internal {\n    require(_token.code.length > 0, 'Xfai: TRANSFERFROM_FAILED');\n    (bool success, bytes memory data) = _token.call(\n      abi.encodeWithSelector(IERC20.transferFrom.selector, _from, _to, _value)\n    );\n    require(success && (data.length == 0 || abi.decode(data, (bool))), 'Xfai: TRANSFERFROM_FAILED');\n  }\n\n  function safeTransferETH(address _to, uint _value) internal {\n    (bool success, ) = _to.call{value: _value}(new bytes(0));\n    require(success, 'Xfai: ETH_TRANSFER_FAILED');\n  }\n\n  function safeTransfer(address _token, address _to, uint256 _value) internal {\n    require(_token.code.length > 0, 'Xfai: TRANSFER_FAILED');\n    (bool success, bytes memory data) = _token.call(\n      abi.encodeWithSelector(IERC20.transfer.selector, _to, _value)\n    );\n    require(success && (data.length == 0 || abi.decode(data, (bool))), 'Xfai: TRANSFER_FAILED');\n  }\n}\n"

    },

    "IERC20.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `to`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address to, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `from` to `to` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"

    },

    "XfaiLibrary.sol": {

      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.19;\n\nimport \"IXfaiPool.sol\";\n\nlibrary XfaiLibrary {\n  /**\n   * @notice Calculates the CREATE2 address for a pool without making any external calls\n   * @param _token An ERC20 token address\n   * @param _factory The factory contract of Xfai\n   * @param _poolCodeHash The codehash of the Xfai pool contract\n   * @return pool The deterministic pool address for a given _token\n   */\n  function poolFor(\n    address _token,\n    address _factory,\n    bytes32 _poolCodeHash\n  ) internal pure returns (address pool) {\n    pool = address(\n      uint160(\n        uint256(\n          keccak256(\n            abi.encodePacked(\n              hex'ff',\n              _factory,\n              keccak256(abi.encodePacked(_token)),\n              _poolCodeHash // init code hash\n            )\n          )\n        )\n      )\n    );\n  }\n\n  function getAdjustedOutput(uint _amountIn, uint _r, uint _w) internal pure returns (uint out) {\n    out = (_amountIn * _w) / (_r + _amountIn);\n  }\n\n  function getAdjustedInput(uint _amountOut, uint _r, uint _w) internal pure returns (uint input) {\n    input = ((_amountOut * _r) / (_w - _amountOut)) + 1;\n  }\n\n  function quote(uint _amountIn, uint _a, uint _b) internal pure returns (uint out) {\n    out = (_amountIn * _a) / _b;\n  }\n\n  /**\n   * @notice Calculates the adjusted price of an _amountIn (of a token from _pool0) in terms of the token in _pool1\n   * @dev either token0 or token1 must be xfETH\n   * @param _reserve0 The reserve of _token0 (can be xfETH)\n   * @param _reserve1 The reserve of _token1 (can be xfETH)\n   * @param _amountIn The token input amount to _pool0\n   * @return output The token output between a token - xfETH interaction\n   */\n  function getAmountOut(\n    uint _reserve0,\n    uint _reserve1,\n    uint _amountIn,\n    uint _totalFee\n  ) public pure returns (uint output) {\n    require(_amountIn > 0, 'Xfai: INSUFFICIENT_AMOUNT');\n    require(_reserve0 > 0, 'Xfai: INSUFFICIENT_LIQUIDITY');\n    require(_reserve1 > 0, 'Xfai: INSUFFICIENT_LIQUIDITY');\n    uint amountInWithFee = _amountIn * (10000 - _totalFee);\n    uint numerator = amountInWithFee * _reserve1;\n    output = numerator / (_reserve0 * 10000 + amountInWithFee);\n  }\n\n  /**\n   * @notice Calculates the adjusted price of an _amountOut (of a token from _pool1) in terms of the token in _pool0\n   * @param _reserve0 The reserve of _token0 (can be xfETH)\n   * @param _reserve1 The reserve of _token1 (can be xfETH)\n   * @param _amountOut The token output amount from _pool0\n   * @return input The token input amount to _pool0\n   */\n  function getAmountIn(\n    uint _reserve0,\n    uint _reserve1,\n    uint _amountOut,\n    uint _totalFee\n  ) public pure returns (uint input) {\n    require(_amountOut > 0, 'Xfai: INSUFFICIENT_AMOUNT');\n    require(_reserve0 > 0, 'Xfai: INSUFFICIENT_LIQUIDITY');\n    require(_reserve1 > 0, 'Xfai: INSUFFICIENT_LIQUIDITY');\n    uint numerator = _amountOut * _reserve0 * 10000;\n    uint denominator = (_reserve1 - _amountOut) * (10000 - _totalFee);\n    input = (numerator / denominator) + 1;\n  }\n\n  /**\n   * @notice Calculates the adjusted price of an _amountIn (of a token from _pool0) in terms of the token in _pool1\n   * @param _pool0 A pool address\n   * @param _pool1 A pool address\n   * @param _amountIn The token input amount to _pool0\n   * @return out1 The token output amount from _pool1\n   */\n  function getAmountsOut(\n    address _pool0,\n    address _pool1,\n    uint _amountIn,\n    uint _totalFee\n  ) public view returns (uint out1) {\n    (uint r0, uint w0) = IXfaiPool(_pool0).getStates();\n    (uint r1, uint w1) = IXfaiPool(_pool1).getStates();\n    uint weight0Out = getAmountOut(r0, w0, _amountIn, _totalFee);\n    out1 = getAdjustedOutput(weight0Out, w1, r1);\n  }\n\n  /**\n   * @notice Calculates the adjusted price of an _amountOut (of a token from _pool1) in terms of the token in _pool0\n   * @param _pool0 A pool address\n   * @param _pool1 A pool address\n   * @param _amountOut The token output amount from _pool1\n   * @return inp0 The token input amount to _pool0\n   */\n  function getAmountsIn(\n    address _pool0,\n    address _pool1,\n    uint _amountOut,\n    uint _totalFee\n  ) public view returns (uint inp0) {\n    (uint r0, uint w0) = IXfaiPool(_pool0).getStates();\n    (uint r1, uint w1) = IXfaiPool(_pool1).getStates();\n    uint weight0Out = getAdjustedInput(_amountOut, w1, r1);\n    inp0 = getAmountIn(r0, w0, weight0Out, _totalFee);\n  }\n}\n"

    },

    "IXfaiPool.sol": {

      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.19;\n\nimport \"IERC20Metadata.sol\";\n\ninterface IXfaiPool is IERC20Metadata {\n  function getXfaiCore() external view returns (address);\n\n  function poolToken() external view returns (address);\n\n  function initialize(address _token, address _xfaiFactory) external;\n\n  function getStates() external view returns (uint, uint);\n\n  function update(uint _reserveBalance, uint _weightBalance) external;\n\n  function mint(address _to, uint _amount) external;\n\n  function burn(address _to, uint _amount) external;\n\n  function linkedTransfer(address _token, address _to, uint256 _value) external;\n\n  event Sync(uint _reserve, uint _weight);\n  event Write(uint _reserve, uint _weight, uint _blockTimestamp);\n}\n"

    },

    "IERC20Metadata.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n  /**\n   * @dev Returns the name of the token.\n   */\n  function name() external view returns (string memory);\n\n  /**\n   * @dev Returns the symbol of the token.\n   */\n  function symbol() external view returns (string memory);\n\n  /**\n   * @dev Returns the decimals places of the token.\n   */\n  function decimals() external view returns (uint8);\n}\n"

    },

    "IInfinityNFTPeriphery.sol": {

      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.19;\n\ninterface IInfinityNFTPeriphery {\n  event InfinityStake(address indexed sender, uint amount, uint share, uint id);\n  event InfinityBoost(address indexed sender, uint amount, uint share, uint id);\n\n  function permanentStaking(\n    address _to,\n    address _token0,\n    uint _amount0In,\n    uint _shareMin,\n    uint _deadline\n  ) external returns (uint share);\n\n  function permanentStakingEth(\n    address _to,\n    uint _shareMin,\n    uint _deadline\n  ) external payable returns (uint share);\n\n  function permanentBoosting(\n    address _token0,\n    uint _amount0In,\n    uint _shareMin,\n    uint _id,\n    uint _deadline\n  ) external returns (uint share);\n\n  function permanentBoostingEth(\n    uint _shareMin,\n    uint _id,\n    uint _deadline\n  ) external payable returns (uint share);\n}\n"

    },

    "IXfaiINFT.sol": {

      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.19;\nimport \"IERC721Enumerable.sol\";\n\ninterface IXfaiINFT is IERC721Enumerable {\n  function reserve() external view returns (uint);\n\n  function totalSharesIssued() external view returns (uint);\n\n  function initialReserve() external view returns (uint);\n\n  function harvestedBalance(address _token) external view returns (uint);\n\n  function INFTShares(uint _id) external view returns (uint);\n\n  function sharesHarvestedByPool(address _token, uint _id) external view returns (uint);\n\n  function totalSharesHarvestedByPool(address _token) external view returns (uint);\n\n  function setBaseURI(string memory _baseURI) external;\n\n  function getStates() external view returns (uint, uint, uint);\n\n  function shareToTokenAmount(\n    uint _tokenID,\n    address _token\n  ) external view returns (uint share2amount, uint inftShare, uint harvestedShares);\n\n  function premint(address[] memory _legacyLNFTHolders, uint[] memory _initialShares) external;\n\n  function mint(address _to) external returns (uint tokenID, uint share);\n\n  function boost(uint _tokenID) external returns (uint share);\n\n  function harvestToken(address _token, uint _tokenID, uint _amount) external returns (uint);\n\n  function harvestETH(uint _tokenID, uint _amount) external returns (uint);\n\n  event Mint(address indexed from, address indexed to, uint share, uint id);\n  event Boost(address indexed from, uint share, uint id);\n  event HarvestToken(address token, uint harvestedAmount, uint harvestedShare, uint id);\n  event HarvestETH(uint harvestedAmount, uint harvestedShare, uint id);\n}\n"

    },

    "IERC721Enumerable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.19;\n\nimport \"IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n  /**\n   * @dev Returns the total amount of tokens stored by the contract.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n   * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n   */\n  function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n  /**\n   * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n   * Use along with {totalSupply} to enumerate all tokens.\n   */\n  function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"

    },

    "IERC721.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.19;\n\nimport \"IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n  /**\n   * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n  /**\n   * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n   */\n  event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n  /**\n   * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n   */\n  event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n  /**\n   * @dev Returns the number of tokens in ``owner``'s account.\n   */\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  /**\n   * @dev Returns the owner of the `tokenId` token.\n   *\n   * Requirements:\n   *\n   * - `tokenId` must exist.\n   */\n  function ownerOf(uint256 tokenId) external view returns (address owner);\n\n  /**\n   * @dev Safely transfers `tokenId` token from `from` to `to`.\n   *\n   * Requirements:\n   *\n   * - `from` cannot be the zero address.\n   * - `to` cannot be the zero address.\n   * - `tokenId` token must exist and be owned by `from`.\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n   *\n   * Emits a {Transfer} event.\n   */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes calldata data\n  ) external;\n\n  /**\n   * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n   * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n   *\n   * Requirements:\n   *\n   * - `from` cannot be the zero address.\n   * - `to` cannot be the zero address.\n   * - `tokenId` token must exist and be owned by `from`.\n   * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n   *\n   * Emits a {Transfer} event.\n   */\n  function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n  /**\n   * @dev Transfers `tokenId` token from `from` to `to`.\n   *\n   * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n   * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n   * understand this adds an external call which potentially creates a reentrancy vulnerability.\n   *\n   * Requirements:\n   *\n   * - `from` cannot be the zero address.\n   * - `to` cannot be the zero address.\n   * - `tokenId` token must be owned by `from`.\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(address from, address to, uint256 tokenId) external;\n\n  /**\n   * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n   * The approval is cleared when the token is transferred.\n   *\n   * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n   *\n   * Requirements:\n   *\n   * - The caller must own the token or be an approved operator.\n   * - `tokenId` must exist.\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address to, uint256 tokenId) external;\n\n  /**\n   * @dev Approve or remove `operator` as an operator for the caller.\n   * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n   *\n   * Requirements:\n   *\n   * - The `operator` cannot be the caller.\n   *\n   * Emits an {ApprovalForAll} event.\n   */\n  function setApprovalForAll(address operator, bool _approved) external;\n\n  /**\n   * @dev Returns the account approved for `tokenId` token.\n   *\n   * Requirements:\n   *\n   * - `tokenId` must exist.\n   */\n  function getApproved(uint256 tokenId) external view returns (address operator);\n\n  /**\n   * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n   *\n   * See {setApprovalForAll}\n   */\n  function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"

    },

    "IERC165.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.19;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n  /**\n   * @dev Returns true if this contract implements the interface defined by\n   * `interfaceId`. See the corresponding\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n   * to learn more about how these ids are created.\n   *\n   * This function call must use less than 30 000 gas.\n   */\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"

    },

    "IXfaiV0Core.sol": {

      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.19;\n\ninterface IXfaiV0Core {\n  function lpFee() external view returns (uint);\n\n  function changeLpFee(uint _newFee) external;\n\n  function infinityNFTFee() external view returns (uint);\n\n  function changeInfinityNFTFee(uint _newFee) external;\n\n  function getTotalFee() external view returns (uint);\n\n  function pause(bool _p) external;\n\n  function swap(\n    address _token0,\n    address _token1,\n    address _to\n  ) external returns (uint input, uint output);\n\n  function flashLoan(address _token, uint _amount, address _to, bytes calldata _data) external;\n\n  function mint(address _token, address _to) external returns (uint liquidity);\n\n  function burn(\n    address _token0,\n    address _token1,\n    address _to\n  ) external returns (uint amount0, uint amount1);\n\n  function skim(address _token, address _to) external;\n\n  function sync(address _token) external;\n\n  event ChangedOwner(address indexed owner);\n  event Mint(address indexed sender, uint liquidity);\n  event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n  event Swap(address indexed sender, uint input, uint output, address indexed to);\n  event FlashLoan(address indexed sender, uint amount);\n  event LpFeeChange(uint newFee);\n  event InfinityNFTFeeChange(uint newFee);\n  event Paused(bool p);\n}\n"

    },

    "IXfaiFactory.sol": {

      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.19;\n\ninterface IXfaiFactory {\n  function getPool(address _token) external view returns (address pool);\n\n  function allPools(uint256) external view returns (address pool);\n\n  function poolCodeHash() external pure returns (bytes32);\n\n  function allPoolsLength() external view returns (uint);\n\n  function createPool(address _token) external returns (address pool);\n\n  function setXfaiCore(address _core) external;\n\n  function getXfaiCore() external view returns (address);\n\n  function setOwner(address _owner) external;\n\n  function getOwner() external view returns (address);\n\n  event ChangedOwner(address indexed owner);\n  event ChangedCore(address indexed core);\n  event Whitelisting(bool state);\n  event PoolCreated(address indexed token, address indexed pool, uint allPoolsSize);\n}\n"

    },

    "IWETH.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\npragma solidity ^0.8.19;\n\nimport \"IERC20Metadata.sol\";\n\ninterface IWETH is IERC20Metadata {\n  function deposit() external payable;\n\n  function transfer(address to, uint value) external returns (bool);\n\n  function withdraw(uint) external;\n}\n"

    }

  },

  "settings": {

    "evmVersion": "london",

    "optimizer": {

      "enabled": true,

      "runs": 1000000

    },

    "libraries": {

      "InfinityNFTPeriphery.sol": {}

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    }

  }

}}