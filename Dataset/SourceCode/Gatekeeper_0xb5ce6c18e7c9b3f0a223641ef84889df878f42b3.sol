{{

  "language": "Solidity",

  "sources": {

    "src/Gatekeeper.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {MerkleProofLib} from \"solmate/utils/MerkleProofLib.sol\";\n\nimport {IGatekeeper} from \"./IGatekeeper.sol\";\nimport {GameRegistryConsumer} from \"./GameRegistryConsumer.sol\";\nimport {Constants} from \"./Constants.sol\";\n\n/**\n * GateKeeper\n *  @notice state needs to be reset after each game.\n *  @notice tracks claims per player, and claims per gate.\n */\ncontract Gatekeeper is GameRegistryConsumer, IGatekeeper {\n    /**\n     * Errors\n     */\n\n    error TooMuchHoneyJarInGate(uint256 gateId);\n    error GatekeeperInvalidProof();\n    error NoGates();\n    error Gate_OutOfBounds(uint256 gateId);\n    error Gate_NotEnabled(uint256 gateId);\n    error Gate_NotActive(uint256 gateId, uint256 activeAt);\n    error Stage_OutOfBounds(uint256 stageId);\n    error ConsumedProof();\n\n    /**\n     * Events when business logic is affects\n     */\n    event GateAdded(uint256 bundleId, uint256 gateId);\n    event GateSetEnabled(uint256 bundleId, uint256 gateId, bool enabled);\n    event GateActivated(uint256 bundleId, uint256 gateId, uint256 activationTime);\n    event GetSetMaxClaimable(uint256 bundleId, uint256 gateId, uint256 maxClaimable);\n    event GateReset(uint256 bundleId, uint256 index);\n\n    /**\n     * Internal Storage\n     */\n    mapping(uint256 => Gate[]) public tokenToGates; // bundle -> Gates[]\n    mapping(uint256 => mapping(bytes32 => bool)) public consumedProofs; // gateId --> proof --> boolean\n    mapping(uint256 => bytes32[]) public consumedProofsList; // gateId --> consumed proofs (needed for resets)\n\n    /**\n     * Dependencies\n     */\n    /// @notice admin is the address that is set as the owner.\n    constructor(address gameRegistry_) GameRegistryConsumer(gameRegistry_) {}\n\n    /// @notice helper function for FE to\n    /// @dev if activeAt is 0 this method will also return true\n    function isGateOpen(uint256 bundleId, uint256 gateId) external view returns (bool) {\n        return block.timestamp > tokenToGates[bundleId][gateId].activeAt;\n    }\n\n    /// @inheritdoc IGatekeeper\n    function calculateClaimable(\n        uint256 bundleId,\n        uint256 index,\n        address player,\n        uint32 amount,\n        bytes32[] calldata proof\n    ) external view returns (uint32 claimAmount) {\n        // If proof was already used within the gate, there are 0 left to claim\n        bytes32 proofHash = keccak256(abi.encode(proof));\n        if (consumedProofs[index][proofHash]) return 0;\n\n        Gate storage gate = tokenToGates[bundleId][index];\n        uint32 claimedCount = gate.claimedCount;\n        if (claimedCount >= gate.maxClaimable) revert TooMuchHoneyJarInGate(index);\n\n        claimAmount = amount;\n        bool validProof = validateProof(bundleId, index, player, amount, proof);\n        if (!validProof) revert GatekeeperInvalidProof();\n\n        if (amount + claimedCount > gate.maxClaimable) {\n            claimAmount = gate.maxClaimable - claimedCount;\n        }\n    }\n\n    /// @inheritdoc IGatekeeper\n    function validateProof(uint256 bundleId, uint256 index, address player, uint32 amount, bytes32[] calldata proof)\n        public\n        view\n        returns (bool validProof)\n    {\n        Gate[] storage gates = tokenToGates[bundleId];\n        if (gates.length == 0) revert NoGates();\n        if (index >= gates.length) revert Gate_OutOfBounds(index);\n        if (proof.length == 0) revert GatekeeperInvalidProof();\n\n        Gate storage gate = gates[index];\n        if (!gate.enabled) revert Gate_NotEnabled(index);\n        if (gate.activeAt > block.timestamp) revert Gate_NotActive(index, gate.activeAt);\n\n        bytes32 leaf = keccak256(abi.encodePacked(player, amount));\n        validProof = MerkleProofLib.verify(proof, gate.gateRoot, leaf);\n    }\n\n    /**\n     * State modifiers\n     */\n\n    /// @inheritdoc IGatekeeper\n    function addClaimed(uint256 bundleId, uint256 gateId, uint32 numClaimed, bytes32[] calldata proof)\n        external\n        onlyRole(Constants.GAME_INSTANCE)\n    {\n        Gate storage gate = tokenToGates[bundleId][gateId];\n        bytes32 proofHash = keccak256(abi.encode(proof));\n\n        if (!gate.enabled) revert Gate_NotEnabled(gateId);\n        if (gate.activeAt > block.timestamp) revert Gate_NotActive(gateId, gate.activeAt);\n        if (consumedProofs[gateId][proofHash]) revert ConsumedProof();\n\n        gate.claimedCount += numClaimed;\n\n        consumedProofs[gateId][proofHash] = true;\n        consumedProofsList[gateId].push(proofHash);\n    }\n\n    /**\n     * Gate admin methods\n     */\n\n    /// @inheritdoc IGatekeeper\n    function addGate(uint256 bundleId, bytes32 root_, uint32 maxClaimable_, uint8 stageIndex_)\n        external\n        onlyRole(Constants.GAME_ADMIN)\n    {\n        if (stageIndex_ >= _getStages().length) revert Stage_OutOfBounds(stageIndex_);\n        // ClaimedCount = 0, activeAt = 0 (updated when gates are started)\n        tokenToGates[bundleId].push(Gate(false, stageIndex_, 0, maxClaimable_, root_, 0));\n\n        emit GateAdded(bundleId, tokenToGates[bundleId].length - 1);\n    }\n\n    /// @inheritdoc IGatekeeper\n    function startGatesForBundle(uint256 bundleId) external onlyRole(Constants.GAME_INSTANCE) {\n        Gate[] storage gates = tokenToGates[bundleId];\n        uint256[] memory stageTimes = _getStages(); // External Call\n        uint256 numGates = gates.length;\n\n        if (numGates == 0) revert NoGates(); // Require at least one gate\n\n        for (uint256 i = 0; i < numGates; i++) {\n            if (gates[i].enabled) continue;\n            gates[i].enabled = true;\n            gates[i].activeAt = block.timestamp + stageTimes[gates[i].stageIndex];\n            emit GateActivated(bundleId, i, gates[i].activeAt);\n        }\n    }\n\n    /// @notice Only to be used for emergency gate shutdown/start\n    /// @dev if the gate was never enabled by a call to startGatesForBundle, the gates will be enabled immediately.\n    function setGateEnabled(uint256 bundleId, uint256 index, bool enabled) external onlyRole(Constants.GAME_ADMIN) {\n        tokenToGates[bundleId][index].enabled = enabled;\n\n        emit GateSetEnabled(bundleId, index, enabled);\n    }\n\n    /// @notice admin function that can increase / decrease the amount of free claims available for a specific gate\n    function setGateMaxClaimable(uint256 bundleId, uint256 index, uint32 maxClaimable_)\n        external\n        onlyRole(Constants.GAME_ADMIN)\n    {\n        tokenToGates[bundleId][index].maxClaimable = maxClaimable_;\n        emit GetSetMaxClaimable(bundleId, index, maxClaimable_);\n    }\n\n    /// @notice helper function to reset gate state for a game\n    function resetGate(uint256 bundleId, uint256 index) external onlyRole(Constants.GAME_ADMIN) {\n        delete tokenToGates[bundleId][index];\n\n        uint256 numProofs = consumedProofsList[index].length;\n        for (uint256 i = 0; i < numProofs; ++i) {\n            delete consumedProofs[index][consumedProofsList[index][i]];\n        }\n\n        emit GateReset(bundleId, index);\n    }\n\n    /// @notice helper function to reset all gates for a particular token\n    function resetAllGates(uint256 bundleId) external onlyRole(Constants.GAME_ADMIN) {\n        uint256 numGates = tokenToGates[bundleId].length;\n        Gate[] storage tokenGates = tokenToGates[bundleId];\n        uint256 numProofs;\n\n        // Currently a hacky way but need to clear out if the proofs were used.\n        for (uint256 i = 0; i < numGates; i++) {\n            tokenGates[i].claimedCount = 0;\n            numProofs = consumedProofsList[i].length;\n            for (uint256 j = 0; j < numProofs; ++j) {\n                // Step through all proofs from a particular gate.\n                delete consumedProofs[i][consumedProofsList[i][j]];\n            }\n\n            emit GateReset(bundleId, i);\n        }\n    }\n}\n"

    },

    "lib/solmate/src/utils/MerkleProofLib.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Gas optimized merkle proof verification library.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/MerkleProofLib.sol)\n/// @author Modified from Solady (https://github.com/Vectorized/solady/blob/main/src/utils/MerkleProofLib.sol)\nlibrary MerkleProofLib {\n    function verify(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool isValid) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if proof.length {\n                // Left shifting by 5 is like multiplying by 32.\n                let end := add(proof.offset, shl(5, proof.length))\n\n                // Initialize offset to the offset of the proof in calldata.\n                let offset := proof.offset\n\n                // Iterate over proof elements to compute root hash.\n                // prettier-ignore\n                for {} 1 {} {\n                    // Slot where the leaf should be put in scratch space. If\n                    // leaf > calldataload(offset): slot 32, otherwise: slot 0.\n                    let leafSlot := shl(5, gt(leaf, calldataload(offset)))\n\n                    // Store elements to hash contiguously in scratch space.\n                    // The xor puts calldataload(offset) in whichever slot leaf\n                    // is not occupying, so 0 if leafSlot is 32, and 32 otherwise.\n                    mstore(leafSlot, leaf)\n                    mstore(xor(leafSlot, 32), calldataload(offset))\n\n                    // Reuse leaf to store the hash to reduce stack operations.\n                    leaf := keccak256(0, 64) // Hash both slots of scratch space.\n\n                    offset := add(offset, 32) // Shift 1 word per cycle.\n\n                    // prettier-ignore\n                    if iszero(lt(offset, end)) { break }\n                }\n            }\n\n            isValid := eq(leaf, root) // The proof is valid if the roots match.\n        }\n    }\n}\n"

    },

    "src/IGatekeeper.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IGatekeeper {\n    struct Gate {\n        bool enabled;\n        uint8 stageIndex; // stage from [0-3] (range defined within GameRegistry)\n        uint32 claimedCount; // # of claims already happened\n        uint32 maxClaimable; // # of claims per gate\n        bytes32 gateRoot;\n        uint256 activeAt; // timestamp when active.\n    }\n\n    /// @notice validate how much a player can claim for a particular token and gate.\n    /// @param bundleId the ID of the bundle in the game.\n    /// @param index the gate index the player is claiming\n    /// @param amount the exact number of tokens a player wants to claim\n    /// @param proof merkle proof associated with the amount\n    /// @return claimAmount the number of tokens available for claim\n    function calculateClaimable(\n        uint256 bundleId,\n        uint256 index,\n        address player,\n        uint32 amount,\n        bytes32[] calldata proof\n    ) external returns (uint32 claimAmount);\n\n    /// @notice Validates proof -- does not modify the state.\n    /// @param bundleId the ID of the bundle in the game.\n    /// @param index the gate index the player is claiming\n    /// @param amount the exact number of tokens a player wants to claim\n    /// @param proof merkle proof associated with the amount\n    /// @return validProof boolean representing the validity of the proof given\n    function validateProof(uint256 bundleId, uint256 index, address player, uint32 amount, bytes32[] calldata proof)\n        external\n        returns (bool validProof);\n\n    // Permissioned Methods -- Should not be open for everyone to call.\n\n    /// @notice Update internal accounting, can only be called by a game instance.\n    /// @param bundleId the ID of the bundle in the game.\n    /// @param numClaimed increases gate claimed count by this value\n    /// @param gateId the gate index the player is claiming\n    /// @param proof consumes the proof that is used by the claim\n    function addClaimed(uint256 bundleId, uint256 gateId, uint32 numClaimed, bytes32[] calldata proof) external;\n\n    /// @notice adds a gate to the gates array, should only be called by a gameAdmin\n    /// @param bundleId the id of bundle in the GameInstance\n    /// @param root_ merkle root associated with the gate\n    /// @param maxClaimable_ free claimable limit for the gate being added\n    /// @param stageIndex_ the corresponds to the stage array within the gameRegistry\n    function addGate(uint256 bundleId, bytes32 root_, uint32 maxClaimable_, uint8 stageIndex_) external;\n\n    /// @notice Called by a game when a game is started to set times of gates opening.\n    /// @dev Uses the stages array within GameRegistry to program gate openings. Will revert if there no gate associated with the bundle\n    function startGatesForBundle(uint256 bundleId) external;\n}\n"

    },

    "src/GameRegistryConsumer.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {GameRegistry} from \"./GameRegistry.sol\";\n\n/// @title GameRegistryConsumer\n/// @notice all contracts within the THJ universe should inherit from this contract.\nabstract contract GameRegistryConsumer {\n    GameRegistry public immutable gameRegistry;\n\n    error GameRegistry_NoPermissions(string role, address user);\n    error GameRegistry_StageOutOfBounds(uint8 index);\n\n    modifier onlyRole(bytes32 role_) {\n        if (!gameRegistry.hasRole(role_, msg.sender)) {\n            revert GameRegistry_NoPermissions(string(abi.encodePacked(role_)), msg.sender);\n        }\n        _;\n    }\n\n    constructor(address gameRegistry_) {\n        gameRegistry = GameRegistry(gameRegistry_);\n    }\n\n    function _isEnabled(address game_) internal view returns (bool enabled) {\n        enabled = gameRegistry.games(game_);\n    }\n\n    /// @dev the last stageTime is generalMint\n    function _getStages() internal view returns (uint256[] memory) {\n        return gameRegistry.getStageTimes();\n    }\n\n    /// @dev just a helper function. For access to all stages you should use _getStages()\n    function _getStage(uint8 stageIndex) internal view returns (uint256) {\n        uint256[] memory stageTimes = gameRegistry.getStageTimes();\n        if (stageIndex >= stageTimes.length) revert GameRegistry_StageOutOfBounds(stageIndex);\n\n        return stageTimes[stageIndex];\n    }\n\n    function _hasRole(bytes32 role_) internal view returns (bool) {\n        return gameRegistry.hasRole(role_, msg.sender);\n    }\n}\n"

    },

    "src/Constants.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nlibrary Constants {\n    /**\n     * Could use ENUM however existing contracts are already using these so opting to keep things consistent.\n     */\n    bytes32 internal constant GAME_ADMIN = \"GAME_ADMIN\";\n    bytes32 internal constant BEEKEEPER = \"BEEKEEPER\";\n    bytes32 internal constant JANI = \"JANI\";\n\n    // Contract instances\n    bytes32 internal constant GAME_INSTANCE = \"GAME_INSTANCE\";\n    bytes32 internal constant GATEKEEPER = \"GATEKEEPER\";\n\n    // Special ERC permissions\n    bytes32 internal constant MINTER = \"MINTER\";\n    bytes32 internal constant BURNER = \"BURNER\";\n}\n"

    },

    "src/GameRegistry.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {Constants} from \"./Constants.sol\";\n\n/// @title GameRegistry\n/// @notice Central repository that tracks games and permissions.\n/// @dev All game contracts should use extend `GameRegistryConsumer` to have consistent permissioning\ncontract GameRegistry is AccessControl {\n    uint256[] internal stageTimes;\n\n    // Events\n    event GameRegistered(address game);\n    event GameStarted(address game);\n    event GameStopped(address game);\n    event StageTimesSet(uint256[] stageTimes);\n\n    constructor() {\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(Constants.GAME_ADMIN, msg.sender);\n\n        // Initial 4 stages\n        stageTimes.push(0 hours);\n        stageTimes.push(2 hours);\n        stageTimes.push(4 hours);\n    }\n\n    mapping(address => bool) public games; // Address -> enabled\n\n    /// @notice registers the game with the GameRegistry\n    function registerGame(address game_) external onlyRole(Constants.GAME_ADMIN) {\n        _grantRole(Constants.GAME_INSTANCE, game_);\n        emit GameRegistered(game_);\n    }\n\n    /// @notice starts the game which grants it the minterRole within the THJ ecosystem and enables it.\n    /// @notice enabling the game means that the game is in \"progress\"\n    function startGame(address game_) external onlyRole(Constants.GAME_ADMIN) {\n        _grantRole(Constants.MINTER, game_);\n        games[game_] = true;\n        emit GameStarted(game_);\n    }\n\n    /// @notice stops the game which removes the mintor role and sets enable = false\n    function stopGame(address game_) external onlyRole(Constants.GAME_ADMIN) {\n        _revokeRole(Constants.MINTER, game_);\n        games[game_] = false;\n        emit GameStopped(game_);\n    }\n\n    /**\n     * Getters\n     */\n    function getStageTimes() external view returns (uint256[] memory) {\n        return stageTimes;\n    }\n\n    /**\n     * Bear Pouch setters (helper functions)\n     * Can check roles directly since this is an access control\n     */\n\n    /// @notice sets the JANI role in the THJ game registry.\n    function setJani(address jani_) external onlyRole(Constants.GAME_ADMIN) {\n        _grantRole(Constants.JANI, jani_);\n    }\n\n    /// @notice sets the beeKeeper role in the THJ game registry.\n    function setBeekeeper(address beeKeeper_) external onlyRole(Constants.GAME_ADMIN) {\n        _grantRole(Constants.BEEKEEPER, beeKeeper_);\n    }\n\n    /// @notice If the stages need to be modified after this contract is created.\n    function setStageTimes(uint256[] calldata _stageTimes) external onlyRole(Constants.GAME_ADMIN) {\n        stageTimes = _stageTimes;\n        emit StageTimesSet(stageTimes);\n    }\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/access/AccessControl.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(account),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/access/IAccessControl.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/utils/Context.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/utils/Strings.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/utils/math/Math.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"

    }

  },

  "settings": {

    "remappings": [

      "@chainlink/=lib/chainlink-brownie-contracts/contracts/src/v0.8/",

      "@layerzero/=lib/solidity-examples/contracts/",

      "@openzeppelin/=lib/openzeppelin-contracts/",

      "ERC721A/=lib/ERC721A/contracts/",

      "chainlink-brownie-contracts/=lib/chainlink-brownie-contracts/contracts/src/v0.8/",

      "ds-test/=lib/forge-std/lib/ds-test/src/",

      "dual-ownership-nft/=lib/dual-ownership-nft/contracts/",

      "forge-std/=lib/forge-std/src/",

      "murky/=lib/murky/src/",

      "openzeppelin-contracts/=lib/murky/lib/openzeppelin-contracts/",

      "solidity-examples/=lib/solidity-examples/contracts/",

      "solmate/=lib/solmate/src/"

    ],

    "optimizer": {

      "enabled": true,

      "runs": 10

    },

    "metadata": {

      "bytecodeHash": "ipfs"

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "evmVersion": "london",

    "libraries": {}

  }

}}