{{

  "language": "Solidity",

  "sources": {

    "contracts/uniswap-v3/FlashUniswapV3.sol": {

      "content": "// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.8.4;\n\nimport \"@prb/contracts/token/erc20/IErc20.sol\";\nimport \"@prb/contracts/token/erc20/SafeErc20.sol\";\nimport \"@hifi/protocol/contracts/core/balance-sheet/IBalanceSheetV2.sol\";\nimport \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\n\nimport \"./IFlashUniswapV3.sol\";\n\n/// @title FlashUniswapV3\n/// @author Hifi\ncontract FlashUniswapV3 is IFlashUniswapV3 {\n    using SafeErc20 for IErc20;\n\n    /// PUBLIC STORAGE ///\n\n    /// @inheritdoc IFlashUniswapV3\n    IBalanceSheetV2 public immutable override balanceSheet;\n\n    /// @inheritdoc IFlashUniswapV3\n    address public immutable override uniV3Factory;\n\n    /// @dev TickMath constants for computing the sqrt price limit.\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n    /// @dev The Uniswap V3 pool init code hash.\n    bytes32 internal constant POOL_INIT_CODE_HASH = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;\n\n    /// CONSTRUCTOR ///\n    constructor(IBalanceSheetV2 balanceSheet_, address uniV3Factory_) {\n        balanceSheet = balanceSheet_;\n        uniV3Factory = uniV3Factory_;\n    }\n\n    struct FlashLiquidateLocalVars {\n        PoolKey poolKey;\n        IErc20 underlying;\n        bool zeroForOne;\n    }\n\n    struct UniswapV3SwapCallbackParams {\n        IHToken bond;\n        address borrower;\n        IErc20 collateral;\n        PoolKey poolKey;\n        address sender;\n        int256 turnout;\n        uint256 underlyingAmount;\n    }\n\n    /// PUBLIC NON-CONSTANT FUNCTIONS ///\n\n    /// @inheritdoc IFlashUniswapV3\n    function flashLiquidate(FlashLiquidateParams memory params) external override {\n        FlashLiquidateLocalVars memory vars;\n\n        // This flash swap contract does not support liquidating vaults backed by underlying.\n        vars.underlying = params.bond.underlying();\n        if (params.collateral == vars.underlying) {\n            revert FlashUniswapV3__LiquidateUnderlyingBackedVault({\n                borrower: params.borrower,\n                underlying: address(vars.underlying)\n            });\n        }\n\n        // Compute the flash pool key and address.\n        vars.poolKey = getPoolKey({\n            tokenA: address(params.collateral),\n            tokenB: address(vars.underlying),\n            fee: params.poolFee\n        });\n\n        // The direction of the swap, true for token0 to token1, false for token1 to token0.\n        vars.zeroForOne = address(vars.underlying) == vars.poolKey.token1;\n\n        IUniswapV3Pool(poolFor(vars.poolKey)).swap({\n            recipient: address(this),\n            zeroForOne: vars.zeroForOne,\n            amountSpecified: int256(params.underlyingAmount) * -1,\n            sqrtPriceLimitX96: vars.zeroForOne ? MIN_SQRT_RATIO + 1 : MAX_SQRT_RATIO - 1,\n            data: abi.encode(\n                UniswapV3SwapCallbackParams({\n                    bond: params.bond,\n                    borrower: params.borrower,\n                    collateral: params.collateral,\n                    poolKey: vars.poolKey,\n                    sender: msg.sender,\n                    turnout: params.turnout,\n                    underlyingAmount: params.underlyingAmount\n                })\n            )\n        });\n    }\n\n    struct UniswapV3SwapCallbackLocalVars {\n        uint256 mintedHTokenAmount;\n        uint256 profitAmount;\n        uint256 repayAmount;\n        uint256 seizeAmount;\n        uint256 subsidyAmount;\n    }\n\n    /// @inheritdoc IUniswapV3SwapCallback\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external override {\n        UniswapV3SwapCallbackLocalVars memory vars;\n\n        // Unpack the ABI encoded data passed by the UniswapV3Pool contract.\n        UniswapV3SwapCallbackParams memory params = abi.decode(data, (UniswapV3SwapCallbackParams));\n\n        // Check that the caller is the Uniswap V3 flash pool contract.\n        if (msg.sender != poolFor(params.poolKey)) {\n            revert FlashUniswapV3__CallNotAuthorized(msg.sender);\n        }\n\n        // Mint hTokens and liquidate the borrower.\n        vars.mintedHTokenAmount = mintHTokens({ bond: params.bond, underlyingAmount: params.underlyingAmount });\n        vars.seizeAmount = liquidateBorrow({\n            borrower: params.borrower,\n            bond: params.bond,\n            collateral: params.collateral,\n            mintedHTokenAmount: vars.mintedHTokenAmount\n        });\n\n        // Calculate the amount of collateral required to repay.\n        vars.repayAmount = uint256(amount0Delta > 0 ? amount0Delta : amount1Delta);\n\n        // Note that \"turnout\" is a signed int. When it is negative, it acts as a maximum subsidy amount.\n        // When its value is positive, it acts as a minimum profit.\n        if (int256(vars.seizeAmount) < int256(vars.repayAmount) + params.turnout) {\n            revert FlashUniswapV3__TurnoutNotSatisfied({\n                seizeAmount: vars.seizeAmount,\n                repayAmount: vars.repayAmount,\n                turnout: params.turnout\n            });\n        }\n\n        // Transfer the subsidy amount.\n        if (vars.repayAmount > vars.seizeAmount) {\n            unchecked {\n                vars.subsidyAmount = vars.repayAmount - vars.seizeAmount;\n            }\n            params.collateral.safeTransferFrom(params.sender, address(this), vars.subsidyAmount);\n        }\n        // Or reap the profit.\n        else if (vars.seizeAmount > vars.repayAmount) {\n            unchecked {\n                vars.profitAmount = vars.seizeAmount - vars.repayAmount;\n            }\n            params.collateral.safeTransfer(params.sender, vars.profitAmount);\n        }\n\n        // Pay back the loan.\n        params.collateral.safeTransfer(msg.sender, vars.repayAmount);\n\n        // Emit an event.\n        emit FlashSwapAndLiquidateBorrow({\n            liquidator: params.sender,\n            borrower: params.borrower,\n            bond: address(params.bond),\n            collateral: address(params.collateral),\n            underlyingAmount: params.underlyingAmount,\n            seizeAmount: vars.seizeAmount,\n            repayAmount: vars.repayAmount,\n            subsidyAmount: vars.subsidyAmount,\n            profitAmount: vars.profitAmount\n        });\n    }\n\n    /// INTERNAL CONSTANT FUNCTIONS ///\n\n    /// @dev Returns the Uniswap V3 pool key for a given token pair and fee level.\n    function getPoolKey(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) internal pure returns (PoolKey memory) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        return PoolKey({ token0: tokenA, token1: tokenB, fee: fee });\n    }\n\n    /// @dev Calculates the CREATE2 address for a Uniswap V3 pool without making any external calls.\n    function poolFor(PoolKey memory key) internal view returns (address pool) {\n        // solhint-disable-next-line reason-string\n        require(key.token0 < key.token1);\n        pool = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex\"ff\",\n                            uniV3Factory,\n                            keccak256(abi.encode(key.token0, key.token1, key.fee)),\n                            POOL_INIT_CODE_HASH\n                        )\n                    )\n                )\n            )\n        );\n    }\n\n    /// INTERNAL NON-CONSTANT FUNCTIONS ///\n\n    /// @dev Liquidates the borrower, receiving collateral at a discount.\n    function liquidateBorrow(\n        address borrower,\n        IHToken bond,\n        IErc20 collateral,\n        uint256 mintedHTokenAmount\n    ) internal returns (uint256 seizeCollateralAmount) {\n        uint256 collateralAmount = balanceSheet.getCollateralAmount(borrower, collateral);\n        uint256 hypotheticalRepayAmount = balanceSheet.getRepayAmount(collateral, collateralAmount, bond);\n\n        // If the hypothetical repay amount is bigger than the debt amount, this could be a single-collateral multi-bond\n        // vault. Otherwise, it could be a multi-collateral single-bond vault. However, it is difficult to generalize\n        // for the multi-collateral and multi-bond situation. The repay amount could be greater, smaller, or equal\n        // to the debt amount depending on the collateral and debt amount distribution.\n        uint256 debtAmount = balanceSheet.getDebtAmount(borrower, bond);\n        uint256 repayAmount = hypotheticalRepayAmount > debtAmount ? debtAmount : hypotheticalRepayAmount;\n\n        // Truncate the repay amount such that we keep the dust in this contract rather than the BalanceSheet.\n        uint256 truncatedRepayAmount = mintedHTokenAmount > repayAmount ? repayAmount : mintedHTokenAmount;\n\n        // Liquidate borrow.\n        uint256 oldCollateralBalance = collateral.balanceOf(address(this));\n        balanceSheet.liquidateBorrow(borrower, bond, truncatedRepayAmount, collateral);\n        uint256 newCollateralBalance = collateral.balanceOf(address(this));\n        unchecked {\n            seizeCollateralAmount = newCollateralBalance - oldCollateralBalance;\n        }\n    }\n\n    /// @dev Deposits the underlying in the HToken contract to mint hTokens on a one-to-one basis.\n    function mintHTokens(IHToken bond, uint256 underlyingAmount) internal returns (uint256 mintedHTokenAmount) {\n        IErc20 underlying = bond.underlying();\n\n        // Allow the HToken contract to spend underlying if allowance not enough.\n        uint256 allowance = underlying.allowance(address(this), address(bond));\n        if (allowance < underlyingAmount) {\n            underlying.approve(address(bond), type(uint256).max);\n        }\n\n        // Deposit underlying to mint hTokens.\n        uint256 oldHTokenBalance = bond.balanceOf(address(this));\n        bond.depositUnderlying(underlyingAmount);\n        uint256 newHTokenBalance = bond.balanceOf(address(this));\n        unchecked {\n            mintedHTokenAmount = newHTokenBalance - oldHTokenBalance;\n        }\n    }\n}\n"

    },

    "@prb/contracts/token/erc20/IErc20.sol": {

      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\n/// @title IErc20\n/// @author Paul Razvan Berg\n/// @notice Implementation for the Erc20 standard.\n///\n/// We have followed general OpenZeppelin guidelines: functions revert instead of returning\n/// `false` on failure. This behavior is nonetheless conventional and does not conflict with\n/// the with the expectations of Erc20 applications.\n///\n/// Additionally, an {Approval} event is emitted on calls to {transferFrom}. This allows\n/// applications to reconstruct the allowance for all accounts just by listening to said\n/// events. Other implementations of the Erc may not emit these events, as it isn't\n/// required by the specification.\n///\n/// Finally, the non-standard {decreaseAllowance} and {increaseAllowance} functions have been\n/// added to mitigate the well-known issues around setting allowances.\n///\n/// @dev Forked from OpenZeppelin\n/// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/token/ERC20/ERC20.sol\ninterface IErc20 {\n    /// EVENTS ///\n\n    /// @notice Emitted when an approval happens.\n    /// @param owner The address of the owner of the tokens.\n    /// @param spender The address of the spender.\n    /// @param amount The maximum amount that can be spent.\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /// @notice Emitted when a transfer happens.\n    /// @param from The account sending the tokens.\n    /// @param to The account receiving the tokens.\n    /// @param amount The amount of tokens transferred.\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    /// CONSTANT FUNCTIONS ///\n\n    /// @notice Returns the remaining number of tokens that `spender` will be allowed to spend\n    /// on behalf of `owner` through {transferFrom}. This is zero by default.\n    ///\n    /// @dev This value changes when {approve} or {transferFrom} are called.\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /// @notice Returns the amount of tokens owned by `account`.\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Returns the number of decimals used to get its user representation.\n    function decimals() external view returns (uint8);\n\n    /// @notice Returns the name of the token.\n    function name() external view returns (string memory);\n\n    /// @notice Returns the symbol of the token, usually a shorter version of the name.\n    function symbol() external view returns (string memory);\n\n    /// @notice Returns the amount of tokens in existence.\n    function totalSupply() external view returns (uint256);\n\n    /// NON-CONSTANT FUNCTIONS ///\n\n    /// @notice Sets `amount` as the allowance of `spender` over the caller's tokens.\n    ///\n    /// @dev Emits an {Approval} event.\n    ///\n    /// IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may\n    /// use both the old and the new allowance by unfortunate transaction ordering. One possible solution\n    /// to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired\n    /// value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    ///\n    /// Requirements:\n    ///\n    /// - `spender` cannot be the zero address.\n    ///\n    /// @return a boolean value indicating whether the operation succeeded.\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /// @notice Atomically decreases the allowance granted to `spender` by the caller.\n    ///\n    /// @dev Emits an {Approval} event indicating the updated allowance.\n    ///\n    /// This is an alternative to {approve} that can be used as a mitigation for problems described\n    /// in {Erc20Interface-approve}.\n    ///\n    /// Requirements:\n    ///\n    /// - `spender` cannot be the zero address.\n    /// - `spender` must have allowance for the caller of at least `subtractedAmount`.\n    function decreaseAllowance(address spender, uint256 subtractedAmount) external returns (bool);\n\n    /// @notice Atomically increases the allowance granted to `spender` by the caller.\n    ///\n    /// @dev Emits an {Approval} event indicating the updated allowance.\n    ///\n    /// This is an alternative to {approve} that can be used as a mitigation for the problems described above.\n    ///\n    /// Requirements:\n    ///\n    /// - `spender` cannot be the zero address.\n    function increaseAllowance(address spender, uint256 addedAmount) external returns (bool);\n\n    /// @notice Moves `amount` tokens from the caller's account to `recipient`.\n    ///\n    /// @dev Emits a {Transfer} event.\n    ///\n    /// Requirements:\n    ///\n    /// - `recipient` cannot be the zero address.\n    /// - The caller must have a balance of at least `amount`.\n    ///\n    /// @return a boolean value indicating whether the operation succeeded.\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /// @notice Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism. `amount`\n    /// `is then deducted from the caller's allowance.\n    ///\n    /// @dev Emits a {Transfer} event and an {Approval} event indicating the updated allowance. This is\n    /// not required by the Erc. See the note at the beginning of {Erc20}.\n    ///\n    /// Requirements:\n    ///\n    /// - `sender` and `recipient` cannot be the zero address.\n    /// - `sender` must have a balance of at least `amount`.\n    /// - The caller must have approed `sender` to spent at least `amount` tokens.\n    ///\n    /// @return a boolean value indicating whether the operation succeeded.\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n}\n"

    },

    "@prb/contracts/token/erc20/SafeErc20.sol": {

      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\nimport \"./IErc20.sol\";\nimport \"../../utils/Address.sol\";\n\n/// @notice Emitted when the call is made to a non-contract.\nerror SafeErc20__CallToNonContract(address target);\n\n/// @notice Emitted when there is no return data.\nerror SafeErc20__NoReturnData();\n\n/// @title SafeErc20.sol\n/// @author Paul Razvan Berg\n/// @notice Wraps around Erc20 operations that throw on failure (when the token contract\n/// returns false). Tokens that return no value (and instead revert or throw\n/// on failure) are also supported, non-reverting calls are assumed to be successful.\n///\n/// To use this library you can add a `using SafeErc20 for IErc20;` statement to your contract,\n/// which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n///\n/// @dev Forked from OpenZeppelin\n/// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/utils/Address.sol\nlibrary SafeErc20 {\n    using Address for address;\n\n    /// INTERNAL FUNCTIONS ///\n\n    function safeTransfer(\n        IErc20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, amount));\n    }\n\n    function safeTransferFrom(\n        IErc20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, amount));\n    }\n\n    /// PRIVATE FUNCTIONS ///\n\n    /// @dev Imitates a Solidity high-level call (a regular function call to a contract), relaxing the requirement\n    /// on the return value: the return value is optional (but if data is returned, it cannot be false).\n    /// @param token The token targeted by the call.\n    /// @param data The call data (encoded using abi.encode or one of its variants).\n    function callOptionalReturn(IErc20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n        bytes memory returndata = functionCall(address(token), data, \"SafeErc20LowLevelCall\");\n        if (returndata.length > 0) {\n            // Return data is optional.\n            if (!abi.decode(returndata, (bool))) {\n                revert SafeErc20__NoReturnData();\n            }\n        }\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) private returns (bytes memory) {\n        if (!target.isContract()) {\n            revert SafeErc20__CallToNonContract(target);\n        }\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present.\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly.\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"

    },

    "@hifi/protocol/contracts/core/balance-sheet/IBalanceSheetV2.sol": {

      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.4;\n\nimport \"@prb/contracts/token/erc20/IErc20.sol\";\n\nimport \"../fintroller/IFintroller.sol\";\nimport \"../h-token/IHToken.sol\";\nimport \"../../access/IOwnableUpgradeable.sol\";\nimport \"../../oracles/IChainlinkOperator.sol\";\n\n/// @title IBalanceSheetV2\n/// @author Hifi\n/// @notice Manages the collaterals and the debts for all users.\ninterface IBalanceSheetV2 is IOwnableUpgradeable {\n    /// CUSTOM ERRORS ///\n\n    /// @notice Emitted when the bond matured.\n    error BalanceSheet__BondMatured(IHToken bond);\n\n    /// @notice Emitted when the account exceeds the maximum numbers of bonds permitted.\n    error BalanceSheet__BorrowMaxBonds(IHToken bond, uint256 newBondListLength, uint256 maxBonds);\n\n    /// @notice Emitted when the account exceeds the maximum numbers of collateral permitted.\n    error BalanceSheet__DepositMaxCollaterals(\n        IErc20 collateral,\n        uint256 newCollateralListLength,\n        uint256 maxCollaterals\n    );\n\n    /// @notice Emitted when borrows are not allowed by the Fintroller contract.\n    error BalanceSheet__BorrowNotAllowed(IHToken bond);\n\n    /// @notice Emitted when borrowing a zero amount of hTokens.\n    error BalanceSheet__BorrowZero();\n\n    /// @notice Emitted when the new collateral amount exceeds the collateral ceiling.\n    error BalanceSheet__CollateralCeilingOverflow(uint256 newTotalSupply, uint256 debtCeiling);\n\n    /// @notice Emitted when the new total amount of debt exceeds the debt ceiling.\n    error BalanceSheet__DebtCeilingOverflow(uint256 newCollateralAmount, uint256 debtCeiling);\n\n    /// @notice Emitted when collateral deposits are not allowed by the Fintroller contract.\n    error BalanceSheet__DepositCollateralNotAllowed(IErc20 collateral);\n\n    /// @notice Emitted when depositing a zero amount of collateral.\n    error BalanceSheet__DepositCollateralZero();\n\n    /// @notice Emitted when setting the Fintroller contract to the zero address.\n    error BalanceSheet__FintrollerZeroAddress();\n\n    /// @notice Emitted when there is not enough collateral to seize.\n    error BalanceSheet__LiquidateBorrowInsufficientCollateral(\n        address account,\n        uint256 vaultCollateralAmount,\n        uint256 seizableAmount\n    );\n\n    /// @notice Emitted when borrow liquidations are not allowed by the Fintroller contract.\n    error BalanceSheet__LiquidateBorrowNotAllowed(IHToken bond);\n\n    /// @notice Emitted when the borrower is liquidating themselves.\n    error BalanceSheet__LiquidateBorrowSelf(address account);\n\n    /// @notice Emitted when there is a liquidity shortfall.\n    error BalanceSheet__LiquidityShortfall(address account, uint256 shortfallLiquidity);\n\n    /// @notice Emitted when there is no liquidity shortfall.\n    error BalanceSheet__NoLiquidityShortfall(address account);\n\n    /// @notice Emitted when setting the oracle contract to the zero address.\n    error BalanceSheet__OracleZeroAddress();\n\n    /// @notice Emitted when the repayer does not have enough hTokens to repay the debt.\n    error BalanceSheet__RepayBorrowInsufficientBalance(IHToken bond, uint256 repayAmount, uint256 hTokenBalance);\n\n    /// @notice Emitted when repaying more debt than the borrower owes.\n    error BalanceSheet__RepayBorrowInsufficientDebt(IHToken bond, uint256 repayAmount, uint256 debtAmount);\n\n    /// @notice Emitted when borrow repays are not allowed by the Fintroller contract.\n    error BalanceSheet__RepayBorrowNotAllowed(IHToken bond);\n\n    /// @notice Emitted when repaying a borrow with a zero amount of hTokens.\n    error BalanceSheet__RepayBorrowZero();\n\n    /// @notice Emitted when withdrawing more collateral than there is in the vault.\n    error BalanceSheet__WithdrawCollateralUnderflow(\n        address account,\n        uint256 vaultCollateralAmount,\n        uint256 withdrawAmount\n    );\n\n    /// @notice Emitted when withdrawing a zero amount of collateral.\n    error BalanceSheet__WithdrawCollateralZero();\n\n    /// EVENTS ///\n\n    /// @notice Emitted when a borrow is made.\n    /// @param account The address of the borrower.\n    /// @param bond The address of the bond contract.\n    /// @param borrowAmount The amount of hTokens borrowed.\n    event Borrow(address indexed account, IHToken indexed bond, uint256 borrowAmount);\n\n    /// @notice Emitted when collateral is deposited.\n    /// @param account The address of the borrower.\n    /// @param collateral The related collateral.\n    /// @param collateralAmount The amount of deposited collateral.\n    event DepositCollateral(address indexed account, IErc20 indexed collateral, uint256 collateralAmount);\n\n    /// @notice Emitted when a borrow is liquidated.\n    /// @param liquidator The address of the liquidator.\n    /// @param borrower The address of the borrower.\n    /// @param bond The address of the bond contract.\n    /// @param repayAmount The amount of repaid funds.\n    /// @param collateral The address of the collateral contract.\n    /// @param seizedCollateralAmount The amount of seized collateral.\n    event LiquidateBorrow(\n        address indexed liquidator,\n        address indexed borrower,\n        IHToken indexed bond,\n        uint256 repayAmount,\n        IErc20 collateral,\n        uint256 seizedCollateralAmount\n    );\n\n    /// @notice Emitted when a borrow is repaid.\n    /// @param payer The address of the payer.\n    /// @param borrower The address of the borrower.\n    /// @param bond The address of the bond contract.\n    /// @param repayAmount The amount of repaid funds.\n    /// @param newDebtAmount The amount of the new debt.\n    event RepayBorrow(\n        address indexed payer,\n        address indexed borrower,\n        IHToken indexed bond,\n        uint256 repayAmount,\n        uint256 newDebtAmount\n    );\n\n    /// @notice Emitted when a new Fintroller contract is set.\n    /// @param owner The address of the owner.\n    /// @param oldFintroller The address of the old Fintroller contract.\n    /// @param newFintroller The address of the new Fintroller contract.\n    event SetFintroller(address indexed owner, address oldFintroller, address newFintroller);\n\n    /// @notice Emitted when a new oracle contract is set.\n    /// @param owner The address of the owner.\n    /// @param oldOracle The address of the old oracle contract.\n    /// @param newOracle The address of the new oracle contract.\n    event SetOracle(address indexed owner, address oldOracle, address newOracle);\n\n    /// @notice Emitted when collateral is withdrawn.\n    /// @param account The address of the borrower.\n    /// @param collateral The related collateral.\n    /// @param collateralAmount The amount of withdrawn collateral.\n    event WithdrawCollateral(address indexed account, IErc20 indexed collateral, uint256 collateralAmount);\n\n    /// CONSTANT FUNCTIONS ///\n\n    /// @notice Returns the list of bond markets the given account entered.\n    /// @dev It is not an error to provide an invalid address.\n    /// @param account The borrower account to make the query against.\n    function getBondList(address account) external view returns (IHToken[] memory);\n\n    /// @notice Returns the amount of collateral deposited by the given account for the given collateral type.\n    /// @dev It is not an error to provide an invalid address.\n    /// @param account The borrower account to make the query against.\n    /// @param collateral The collateral to make the query against.\n    function getCollateralAmount(address account, IErc20 collateral) external view returns (uint256 collateralAmount);\n\n    /// @notice Returns the list of collaterals the given account deposited.\n    /// @dev It is not an error to provide an invalid address.\n    /// @param account The borrower account to make the query against.\n    function getCollateralList(address account) external view returns (IErc20[] memory);\n\n    /// @notice Calculates the current account liquidity.\n    /// @param account The account to make the query against.\n    /// @return excessLiquidity account liquidity in excess of collateral requirements.\n    /// @return shortfallLiquidity account shortfall below collateral requirements\n    function getCurrentAccountLiquidity(address account)\n        external\n        view\n        returns (uint256 excessLiquidity, uint256 shortfallLiquidity);\n\n    /// @notice Returns the amount of debt accrued by the given account in the given bond market.\n    /// @dev It is not an error to provide an invalid address.\n    /// @param account The borrower account to make the query against.\n    /// @param bond The bond to make the query against.\n    function getDebtAmount(address account, IHToken bond) external view returns (uint256 debtAmount);\n\n    /// @notice Calculates the account liquidity given a modified collateral, collateral amount, bond and debt amount,\n    /// using the current prices provided by the oracle.\n    ///\n    /// @dev Works by summing up each collateral amount multiplied by the USD value of each unit and divided by its\n    /// respective collateral ratio, then dividing the sum by the total amount of debt drawn by the user.\n    ///\n    /// Caveats:\n    /// - This function expects that the \"collateralList\" and the \"bondList\" are each modified in advance to include\n    /// the collateral and bond due to be modified.\n    ///\n    /// @param account The account to make the query against.\n    /// @param collateralModify The collateral to make the check against.\n    /// @param collateralAmountModify The hypothetical normalized amount of collateral.\n    /// @param bondModify The bond to make the check against.\n    /// @param debtAmountModify The hypothetical amount of debt.\n    /// @return excessLiquidity hypothetical account liquidity in excess of collateral requirements.\n    /// @return shortfallLiquidity hypothetical account shortfall below collateral requirements\n    function getHypotheticalAccountLiquidity(\n        address account,\n        IErc20 collateralModify,\n        uint256 collateralAmountModify,\n        IHToken bondModify,\n        uint256 debtAmountModify\n    ) external view returns (uint256 excessLiquidity, uint256 shortfallLiquidity);\n\n    /// @notice Calculates the amount of hTokens that should be repaid in order to seize a given amount of collateral.\n    /// Note that this is for informational purposes only, it doesn't say anything about whether the user can be\n    /// liquidated.\n    /// @dev The formula used is:\n    /// repayAmount = (seizableCollateralAmount * collateralPriceUsd) / (liquidationIncentive * underlyingPriceUsd)\n    /// @param collateral The collateral to make the query against.\n    /// @param seizableCollateralAmount The amount of collateral to seize.\n    /// @param bond The bond to make the query against.\n    /// @return repayAmount The amount of hTokens that should be repaid.\n    function getRepayAmount(\n        IErc20 collateral,\n        uint256 seizableCollateralAmount,\n        IHToken bond\n    ) external view returns (uint256 repayAmount);\n\n    /// @notice Calculates the amount of collateral that can be seized when liquidating a borrow. Note that this\n    /// is for informational purposes only, it doesn't say anything about whether the user can be liquidated.\n    /// @dev The formula used is:\n    /// seizableCollateralAmount = repayAmount * liquidationIncentive * underlyingPriceUsd / collateralPriceUsd\n    /// @param bond The bond to make the query against.\n    /// @param repayAmount The amount of hTokens to repay.\n    /// @param collateral The collateral to make the query against.\n    /// @return seizableCollateralAmount The amount of seizable collateral.\n    function getSeizableCollateralAmount(\n        IHToken bond,\n        uint256 repayAmount,\n        IErc20 collateral\n    ) external view returns (uint256 seizableCollateralAmount);\n\n    /// NON-CONSTANT FUNCTIONS ///\n\n    /// @notice Increases the debt of the caller and mints new hTokens.\n    ///\n    /// @dev Emits a {Borrow} event.\n    ///\n    /// Requirements:\n    ///\n    /// - The Fintroller must allow this action to be performed.\n    /// - The maturity of the bond must be in the future.\n    /// - The amount to borrow cannot be zero.\n    /// - The new length of the bond list must be below the max bonds limit.\n    /// - The new total amount of debt cannot exceed the debt ceiling.\n    /// - The caller must not end up having a shortfall of liquidity.\n    ///\n    /// @param bond The address of the bond contract.\n    /// @param borrowAmount The amount of hTokens to borrow and print into existence.\n    function borrow(IHToken bond, uint256 borrowAmount) external;\n\n    /// @notice Deposits collateral in the caller's account.\n    ///\n    /// @dev Emits a {DepositCollateral} event.\n    ///\n    /// Requirements:\n    ///\n    /// - The Fintroller must allow this action to be performed.\n    /// - The amount to deposit cannot be zero.\n    /// - The caller must have allowed this contract to spend `collateralAmount` tokens.\n    /// - The new collateral amount cannot exceed the collateral ceiling.\n    ///\n    /// @param collateral The address of the collateral contract.\n    /// @param depositAmount The amount of collateral to deposit.\n    function depositCollateral(IErc20 collateral, uint256 depositAmount) external;\n\n    /// @notice Repays the debt of the borrower and rewards the caller with a surplus of collateral.\n    ///\n    /// @dev Emits a {LiquidateBorrow} event.\n    ///\n    /// Requirements:\n    ///\n    /// - All from \"repayBorrow\".\n    /// - The caller cannot be the same with the borrower.\n    /// - The Fintroller must allow this action to be performed.\n    /// - The borrower must have a shortfall of liquidity if the bond didn't mature.\n    /// - The amount of seized collateral cannot be more than what the borrower has in the vault.\n    ///\n    /// @param bond The address of the bond contract.\n    /// @param borrower The account to liquidate.\n    /// @param repayAmount The amount of hTokens to repay.\n    /// @param collateral The address of the collateral contract.\n    function liquidateBorrow(\n        address borrower,\n        IHToken bond,\n        uint256 repayAmount,\n        IErc20 collateral\n    ) external;\n\n    /// @notice Erases the borrower's debt and takes the hTokens out of circulation.\n    ///\n    /// @dev Emits a {RepayBorrow} event.\n    ///\n    /// Requirements:\n    ///\n    /// - The amount to repay cannot be zero.\n    /// - The Fintroller must allow this action to be performed.\n    /// - The caller must have at least `repayAmount` hTokens.\n    /// - The caller must have at least `repayAmount` debt.\n    ///\n    /// @param bond The address of the bond contract.\n    /// @param repayAmount The amount of hTokens to repay.\n    function repayBorrow(IHToken bond, uint256 repayAmount) external;\n\n    /// @notice Erases the borrower's debt and takes the hTokens out of circulation.\n    ///\n    /// @dev Emits a {RepayBorrow} event.\n    ///\n    /// Requirements:\n    /// - Same as the `repayBorrow` function, but here `borrower` is the account that must have at least\n    /// `repayAmount` hTokens to repay the borrow.\n    ///\n    /// @param borrower The borrower account for which to repay the borrow.\n    /// @param bond The address of the bond contract\n    /// @param repayAmount The amount of hTokens to repay.\n    function repayBorrowBehalf(\n        address borrower,\n        IHToken bond,\n        uint256 repayAmount\n    ) external;\n\n    /// @notice Updates the Fintroller contract this BalanceSheet is connected to.\n    ///\n    /// @dev Emits a {SetFintroller} event.\n    ///\n    /// Requirements:\n    ///\n    /// - The caller must be the owner.\n    /// - The new address cannot be the zero address.\n    ///\n    /// @param newFintroller The new Fintroller contract.\n    function setFintroller(IFintroller newFintroller) external;\n\n    /// @notice Updates the oracle contract.\n    ///\n    /// @dev Emits a {SetOracle} event.\n    ///\n    /// Requirements:\n    ///\n    /// - The caller must be the owner.\n    /// - The new address cannot be the zero address.\n    ///\n    /// @param newOracle The new oracle contract.\n    function setOracle(IChainlinkOperator newOracle) external;\n\n    /// @notice Withdraws a portion or all of the collateral.\n    ///\n    /// @dev Emits a {WithdrawCollateral} event.\n    ///\n    /// Requirements:\n    ///\n    /// - The amount to withdraw cannot be zero.\n    /// - There must be enough collateral in the vault.\n    /// - The caller's account cannot fall below the collateral ratio.\n    ///\n    /// @param collateral The address of the collateral contract.\n    /// @param withdrawAmount The amount of collateral to withdraw.\n    function withdrawCollateral(IErc20 collateral, uint256 withdrawAmount) external;\n}\n"

    },

    "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol": {

      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nimport './pool/IUniswapV3PoolImmutables.sol';\nimport './pool/IUniswapV3PoolState.sol';\nimport './pool/IUniswapV3PoolDerivedState.sol';\nimport './pool/IUniswapV3PoolActions.sol';\nimport './pool/IUniswapV3PoolOwnerActions.sol';\nimport './pool/IUniswapV3PoolEvents.sol';\n\n/// @title The interface for a Uniswap V3 Pool\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface IUniswapV3Pool is\n    IUniswapV3PoolImmutables,\n    IUniswapV3PoolState,\n    IUniswapV3PoolDerivedState,\n    IUniswapV3PoolActions,\n    IUniswapV3PoolOwnerActions,\n    IUniswapV3PoolEvents\n{\n\n}\n"

    },

    "contracts/uniswap-v3/IFlashUniswapV3.sol": {

      "content": "// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity >=0.8.4;\n\nimport \"@hifi/protocol/contracts/core/balance-sheet/IBalanceSheetV2.sol\";\nimport \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\";\n\n/// @title IFlashUniswapV3\n/// @author Hifi\n/// @notice Integration of Uniswap V3 flash swaps for liquidating underwater accounts in Hifi.\ninterface IFlashUniswapV3 is IUniswapV3SwapCallback {\n    /// CUSTOM ERRORS ///\n\n    /// @notice Emitted when the caller is not the Uniswap V3 pool contract.\n    error FlashUniswapV3__CallNotAuthorized(address caller);\n\n    /// @notice Emitted when liquidating a vault backed by underlying.\n    error FlashUniswapV3__LiquidateUnderlyingBackedVault(address borrower, address underlying);\n\n    /// @notice Emitted when the liquidation either does not yield a sufficient profit or it costs more\n    /// than what the subsidizer is willing to pay.\n    error FlashUniswapV3__TurnoutNotSatisfied(uint256 seizeAmount, uint256 repayAmount, int256 turnout);\n\n    /// EVENTS ///\n\n    /// @notice Emitted when a flash swap is made and an account is liquidated.\n    /// @param liquidator The address of the liquidator account.\n    /// @param borrower The address of the borrower account being liquidated.\n    /// @param bond The address of the hToken contract.\n    /// @param collateral The address of the collateral contract.\n    /// @param underlyingAmount The amount of underlying flash borrowed.\n    /// @param seizeAmount The amount of collateral seized.\n    /// @param repayAmount The amount of collateral that had to be repaid by the liquidator.\n    /// @param subsidyAmount The amount of collateral subsidized by the liquidator.\n    /// @param profitAmount The amount of collateral pocketed as profit by the liquidator.\n    event FlashSwapAndLiquidateBorrow(\n        address indexed liquidator,\n        address indexed borrower,\n        address indexed bond,\n        address collateral,\n        uint256 underlyingAmount,\n        uint256 seizeAmount,\n        uint256 repayAmount,\n        uint256 subsidyAmount,\n        uint256 profitAmount\n    );\n\n    /// STRUCTS ///\n\n    /// @dev The parameters for the flash liquidation.\n    struct FlashLiquidateParams {\n        address borrower;\n        IHToken bond;\n        IErc20 collateral;\n        uint24 poolFee;\n        int256 turnout;\n        uint256 underlyingAmount;\n    }\n\n    /// @dev The identifying key of the Uniswap V3 pool.\n    struct PoolKey {\n        address token0;\n        address token1;\n        uint24 fee;\n    }\n\n    /// CONSTANT FUNCTIONS ///\n\n    /// @notice The `BalanceSheet` contract.\n    function balanceSheet() external view returns (IBalanceSheetV2);\n\n    /// @notice The address of the UniswapV3Factory contract.\n    function uniV3Factory() external view returns (address);\n\n    /// NON-CONSTANT FUNCTIONS ///\n\n    /// @notice Flash borrows underlying from Uniswap V3, liquidates the underwater account, and repays the flash loan.\n    /// @param params The parameters for the liquidation.\n    function flashLiquidate(FlashLiquidateParams memory params) external;\n}\n"

    },

    "@prb/contracts/utils/Address.sol": {

      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\n/// @title Address\n/// @author Paul Razvan Berg\n/// @notice Collection of functions related to the address type.\n/// @dev Forked from OpenZeppelin\n/// https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-contracts/v3.4.0/contracts/utils/Address.sol\nlibrary Address {\n    /// @dev Returns true if `account` is a contract.\n    ///\n    /// IMPORTANT: It is unsafe to assume that an address for which this function returns false is an\n    /// externally-owned account (EOA) and not a contract.\n    ///\n    /// Among others, `isContract` will return false for the following types of addresses:\n    ///\n    /// - An externally-owned account\n    /// - A contract in construction\n    /// - An address where a contract will be created\n    /// - An address where a contract lived, but was destroyed\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`.\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            codehash := extcodehash(account)\n        }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n}\n"

    },

    "@hifi/protocol/contracts/core/fintroller/IFintroller.sol": {

      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.4;\n\nimport \"@prb/contracts/token/erc20/IErc20.sol\";\nimport \"@prb/contracts/access/IOwnable.sol\";\n\nimport \"../h-token/IHToken.sol\";\n\n/// @notice IFintroller\n/// @author Hifi\n/// @notice Controls the financial permissions and risk parameters for the Hifi protocol.\ninterface IFintroller is IOwnable {\n    /// CUSTOM ERRORS ///\n\n    /// @notice Emitted when interacting with a bond that is not listed.\n    error Fintroller__BondNotListed(IHToken bond);\n\n    /// @notice Emitted when allowing borrow for a bond when liquidate borrow is disallowed.\n    error Fintroller__BondBorrowAllowedWithLiquidateBorrowDisallowed();\n\n    /// @notice Emitted when allowing liquidate borrow for a bond when repay borrow is disallowed.\n    error Fintroller__BondLiquidateBorrowAllowedWithRepayBorrowDisallowed();\n\n    /// @notice Emitted when disallowing liquidate borrow for a bond when borrow is allowed.\n    error Fintroller__BondLiquidateBorrowDisallowedWithBorrowAllowed();\n\n    /// @notice Emitted when disallowing repay borrow for a bond when liquidate borrow is allowed.\n    error Fintroller__BondRepayBorrowDisallowedWithLiquidateBorrowAllowed();\n\n    /// @notice Emitted when listing a collateral that has more than 18 decimals.\n    error Fintroller__CollateralDecimalsOverflow(uint256 decimals);\n\n    /// @notice Emitted when listing a collateral that has zero decimals.\n    error Fintroller__CollateralDecimalsZero();\n\n    /// @notice Emitted when interacting with a collateral that is not listed.\n    error Fintroller__CollateralNotListed(IErc20 collateral);\n\n    /// @notice Emitted when setting a new collateral ratio that is below the liquidation incentive\n    error Fintroller__CollateralRatioBelowLiquidationIncentive(uint256 newCollateralRatio);\n\n    /// @notice Emitted when setting a new collateral ratio that is above the upper bound.\n    error Fintroller__CollateralRatioOverflow(uint256 newCollateralRatio);\n\n    /// @notice Emitted when setting a new collateral ratio that is below the lower bound.\n    error Fintroller__CollateralRatioUnderflow(uint256 newCollateralRatio);\n\n    /// @notice Emitted when setting a new debt ceiling that is below the total supply of hTokens.\n    error Fintroller__DebtCeilingUnderflow(uint256 newDebtCeiling, uint256 totalSupply);\n\n    /// @notice Emitted when setting a new liquidation incentive that is higher than the collateral ratio.\n    error Fintroller__LiquidationIncentiveAboveCollateralRatio(uint256 newLiquidationIncentive);\n\n    /// @notice Emitted when setting a new liquidation incentive that is above the upper bound.\n    error Fintroller__LiquidationIncentiveOverflow(uint256 newLiquidationIncentive);\n\n    /// @notice Emitted when setting a new liquidation incentive that is below the lower bound.\n    error Fintroller__LiquidationIncentiveUnderflow(uint256 newLiquidationIncentive);\n\n    /// EVENTS ///\n\n    /// @notice Emitted when a new bond is listed.\n    /// @param owner The address of the contract owner.\n    /// @param bond The newly listed bond.\n    event ListBond(address indexed owner, IHToken indexed bond);\n\n    /// @notice Emitted when a new collateral is listed.\n    /// @param owner The address of the contract owner.\n    /// @param collateral The newly listed collateral.\n    event ListCollateral(address indexed owner, IErc20 indexed collateral);\n\n    /// @notice Emitted when the borrow permission is updated.\n    /// @param owner The address of the contract owner.\n    /// @param bond The related HToken.\n    /// @param state True if borrowing is allowed.\n    event SetBorrowAllowed(address indexed owner, IHToken indexed bond, bool state);\n\n    /// @notice Emitted when the collateral ceiling is updated.\n    /// @param owner The address of the contract owner.\n    /// @param collateral The related collateral.\n    /// @param oldCollateralCeiling The old collateral ceiling.\n    /// @param newCollateralCeiling The new collateral ceiling.\n    event SetCollateralCeiling(\n        address indexed owner,\n        IErc20 indexed collateral,\n        uint256 oldCollateralCeiling,\n        uint256 newCollateralCeiling\n    );\n\n    /// @notice Emitted when the collateral ratio is updated.\n    /// @param owner The address of the contract owner.\n    /// @param collateral The related HToken.\n    /// @param oldCollateralRatio The old collateral ratio.\n    /// @param newCollateralRatio the new collateral ratio.\n    event SetCollateralRatio(\n        address indexed owner,\n        IErc20 indexed collateral,\n        uint256 oldCollateralRatio,\n        uint256 newCollateralRatio\n    );\n\n    /// @notice Emitted when the debt ceiling for a bond is updated.\n    /// @param owner The address of the contract owner.\n    /// @param bond The related HToken.\n    /// @param oldDebtCeiling The old debt ceiling.\n    /// @param newDebtCeiling The new debt ceiling.\n    event SetDebtCeiling(address indexed owner, IHToken indexed bond, uint256 oldDebtCeiling, uint256 newDebtCeiling);\n\n    /// @notice Emitted when the deposit collateral permission is updated.\n    /// @param owner The address of the contract owner.\n    /// @param state True if depositing collateral is allowed.\n    event SetDepositCollateralAllowed(address indexed owner, IErc20 indexed collateral, bool state);\n\n    /// @notice Emitted when the deposit underlying permission is set.\n    /// @param owner The address of the contract owner.\n    /// @param bond The related HToken.\n    /// @param state True if deposit underlying is allowed.\n    event SetDepositUnderlyingAllowed(address indexed owner, IHToken indexed bond, bool state);\n\n    /// @notice Emitted when the liquidate borrow permission is updated.\n    /// @param owner The address of the contract owner.\n    /// @param bond The related HToken.\n    /// @param state True if liquidating borrow is allowed.\n    event SetLiquidateBorrowAllowed(address indexed owner, IHToken indexed bond, bool state);\n\n    /// @notice Emitted when the collateral liquidation incentive is set.\n    /// @param owner The address of the contract owner.\n    /// @param collateral The related collateral.\n    /// @param oldLiquidationIncentive The old liquidation incentive.\n    /// @param newLiquidationIncentive The new liquidation incentive.\n    event SetLiquidationIncentive(\n        address indexed owner,\n        IErc20 collateral,\n        uint256 oldLiquidationIncentive,\n        uint256 newLiquidationIncentive\n    );\n\n    /// @notice Emitted when a new max bonds value is set.\n    /// @param owner The address indexed owner.\n    /// @param oldMaxBonds The address of the old max bonds value.\n    /// @param newMaxBonds The address of the new max bonds value.\n    event SetMaxBonds(address indexed owner, uint256 oldMaxBonds, uint256 newMaxBonds);\n\n    /// @notice Emitted when a new max collaterals value is set.\n    /// @param owner The address indexed owner.\n    /// @param oldMaxCollaterals The address of the old max collaterals value.\n    /// @param newMaxCollaterals The address of the new max collaterals value.\n    event SetMaxCollaterals(address indexed owner, uint256 oldMaxCollaterals, uint256 newMaxCollaterals);\n\n    /// @notice Emitted when the repay borrow permission is updated.\n    /// @param owner The address of the contract owner.\n    /// @param bond The related HToken.\n    /// @param state True if repaying borrow is allowed.\n    event SetRepayBorrowAllowed(address indexed owner, IHToken indexed bond, bool state);\n\n    /// STRUCTS ///\n\n    struct Bond {\n        uint256 debtCeiling;\n        bool isBorrowAllowed;\n        bool isDepositUnderlyingAllowed;\n        bool isLiquidateBorrowAllowed;\n        bool isListed;\n        bool isRepayBorrowAllowed;\n    }\n\n    struct Collateral {\n        uint256 ceiling;\n        uint256 ratio;\n        uint256 liquidationIncentive;\n        bool isDepositCollateralAllowed;\n        bool isListed;\n    }\n\n    /// CONSTANT FUNCTIONS ///\n\n    /// @notice Returns the Bond struct instance associated to the given address.\n    /// @dev It is not an error to provide an invalid address.\n    /// @param bond The address of the bond contract.\n    /// @return The bond object.\n    function getBond(IHToken bond) external view returns (Bond memory);\n\n    /// @notice Checks if the account should be allowed to borrow hTokens.\n    /// @dev The bond must be listed.\n    /// @param bond The bond to make the check against.\n    /// @return bool true = allowed, false = not allowed.\n    function getBorrowAllowed(IHToken bond) external view returns (bool);\n\n    /// @notice Returns the Collateral struct instance associated to the given address.\n    /// @dev It is not an error to provide an invalid address.\n    /// @param collateral The address of the collateral contract.\n    /// @return The collateral object.\n    function getCollateral(IErc20 collateral) external view returns (Collateral memory);\n\n    /// @notice Returns the collateral ceiling.\n    /// @dev It is not an error to provide an invalid address.\n    /// @param collateral The address of the collateral contract.\n    /// @return The collateral ceiling as a uint256, or zero if an invalid address was provided.\n    function getCollateralCeiling(IErc20 collateral) external view returns (uint256);\n\n    /// @notice Returns the collateral ratio.\n    /// @dev It is not an error to provide an invalid address.\n    /// @param collateral The address of the collateral contract.\n    /// @return The collateral ratio, or zero if an invalid address was provided.\n    function getCollateralRatio(IErc20 collateral) external view returns (uint256);\n\n    /// @notice Returns the debt ceiling for the given bond.\n    /// @dev It is not an error to provide an invalid address.\n    /// @param bond The address of the bond contract.\n    /// @return The debt ceiling as a uint256, or zero if an invalid address was provided.\n    function getDebtCeiling(IHToken bond) external view returns (uint256);\n\n    /// @notice Checks if collateral deposits are allowed.\n    /// @dev The collateral must be listed.\n    /// @param collateral The collateral to make the check against.\n    /// @return bool true = allowed, false = not allowed.\n    function getDepositCollateralAllowed(IErc20 collateral) external view returns (bool);\n\n    /// @notice Checks if underlying deposits are allowed.\n    /// @dev The bond must be listed.\n    /// @param bond The bond to make the check against.\n    /// @return bool true = allowed, false = not allowed.\n    function getDepositUnderlyingAllowed(IHToken bond) external view returns (bool);\n\n    /// @notice Returns the liquidation incentive of the given collateral.\n    /// @dev It is not an error to provide an invalid address.\n    /// @param collateral The address of the collateral contract.\n    /// @return The liquidation incentive, or zero if an invalid address was provided.\n    function getLiquidationIncentive(IErc20 collateral) external view returns (uint256);\n\n    /// @notice Checks if the account should be allowed to liquidate hToken borrows.\n    /// @dev The bond must be listed.\n    /// @param bond The bond to make the check against.\n    /// @return bool true = allowed, false = not allowed.\n    function getLiquidateBorrowAllowed(IHToken bond) external view returns (bool);\n\n    /// @notice Checks if the account should be allowed to repay borrows.\n    /// @dev The bond must be listed.\n    /// @param bond The bond to make the check against.\n    /// @return bool true = allowed, false = not allowed.\n    function getRepayBorrowAllowed(IHToken bond) external view returns (bool);\n\n    /// @notice Checks if the bond is listed.\n    /// @param bond The bond to make the check against.\n    /// @return bool true = listed, otherwise not.\n    function isBondListed(IHToken bond) external view returns (bool);\n\n    /// @notice Checks if the collateral is listed.\n    /// @param collateral The collateral to make the check against.\n    /// @return bool true = listed, otherwise not.\n    function isCollateralListed(IErc20 collateral) external view returns (bool);\n\n    /// @notice Returns the maximum number of bond markets a single account can enter.\n    function maxBonds() external view returns (uint256);\n\n    /// @notice Returns the maximum number of Collaterals a single account can deposit.\n    function maxCollaterals() external view returns (uint256);\n\n    /// NON-CONSTANT FUNCTIONS ///\n\n    /// @notice Marks the bond as listed in this registry.\n    ///\n    /// @dev It is not an error to list a bond twice. Emits a {ListBond} event.\n    ///\n    /// Requirements:\n    /// - The caller must be the owner.\n    ///\n    /// @param bond The hToken contract to list.\n    function listBond(IHToken bond) external;\n\n    /// @notice Marks the collateral as listed in this registry.\n    ///\n    /// @dev Emits a {ListCollateral} event. It is not an error to list a bond twice.\n    ///\n    /// Requirements:\n    ///\n    /// - The caller must be the owner.\n    /// - The collateral must have between 1 and 18 decimals.\n    ///\n    /// @param collateral The collateral contract to list.\n    function listCollateral(IErc20 collateral) external;\n\n    /// @notice Updates the state of the permission accessed by the hToken before a borrow.\n    ///\n    /// @dev Emits a {SetBorrowAllowed} event.\n    ///\n    /// Requirements:\n    ///\n    /// - The caller must be the owner.\n    /// - The bond must be listed.\n    ///\n    /// @param bond The bond to update the permission for.\n    /// @param state The new state to put in storage.\n    function setBorrowAllowed(IHToken bond, bool state) external;\n\n    /// @notice Updates the collateral ceiling.\n    ///\n    /// @dev Emits a {SetCollateralCeiling} event.\n    ///\n    /// Requirements:\n    ///\n    /// - The caller must be the owner.\n    /// - The collateral must be listed.\n    ///\n    /// @param collateral The collateral to update the ceiling for.\n    /// @param newCollateralCeiling The new collateral ceiling.\n    function setCollateralCeiling(IHToken collateral, uint256 newCollateralCeiling) external;\n\n    /// @notice Updates the collateral ratio.\n    ///\n    /// @dev Emits a {SetCollateralRatio} event.\n    ///\n    /// Requirements:\n    ///\n    /// - The caller must be the owner.\n    /// - The collateral must be listed.\n    /// - The new collateral ratio cannot be higher than the maximum collateral ratio.\n    /// - The new collateral ratio cannot be lower than the minimum collateral ratio.\n    ///\n    /// @param collateral The collateral to update the collateral ratio for.\n    /// @param newCollateralRatio The new collateral ratio.\n    function setCollateralRatio(IErc20 collateral, uint256 newCollateralRatio) external;\n\n    /// @notice Updates the debt ceiling for the given bond.\n    ///\n    /// @dev Emits a {SetDebtCeiling} event.\n    ///\n    /// Requirements:\n    ///\n    /// - The caller must be the owner.\n    /// - The bond must be listed.\n    /// - The debt ceiling cannot fall below the current total supply of hTokens.\n    ///\n    /// @param bond The bond to update the debt ceiling for.\n    /// @param newDebtCeiling The new debt ceiling.\n    function setDebtCeiling(IHToken bond, uint256 newDebtCeiling) external;\n\n    /// @notice Updates the state of the permission accessed by the BalanceSheet before a collateral deposit.\n    ///\n    /// @dev Emits a {SetDepositCollateralAllowed} event.\n    ///\n    /// Requirements:\n    /// - The caller must be the owner.\n    ///\n    /// @param collateral The collateral to update the permission for.\n    /// @param state The new state to put in storage.\n    function setDepositCollateralAllowed(IErc20 collateral, bool state) external;\n\n    /// @notice Updates the state of the permission accessed by the hToken before an underlying deposit.\n    ///\n    /// @dev Emits a {SetDepositUnderlyingAllowed} event.\n    ///\n    /// Requirements:\n    /// - The caller must be the owner.\n    ///\n    /// @param bond The bond to update the permission for.\n    /// @param state The new state to put in storage.\n    function setDepositUnderlyingAllowed(IHToken bond, bool state) external;\n\n    /// @notice Updates the collateral liquidation incentive.\n    ///\n    /// @dev Emits a {SetLiquidationIncentive} event.\n    ///\n    /// Requirements:\n    ///\n    /// - The caller must be the owner.\n    /// - The collateral must be listed.\n    /// - The new liquidation incentive cannot be higher than the maximum liquidation incentive.\n    /// - The new liquidation incentive cannot be lower than the minimum liquidation incentive.\n    ///\n    /// @param collateral The collateral to update the liquidation incentive for.\n    /// @param newLiquidationIncentive The new liquidation incentive.\n    function setLiquidationIncentive(IErc20 collateral, uint256 newLiquidationIncentive) external;\n\n    /// @notice Updates the state of the permission accessed by the hToken before a liquidate borrow.\n    ///\n    /// @dev Emits a {SetLiquidateBorrowAllowed} event.\n    ///\n    /// Requirements:\n    ///\n    /// - The caller must be the owner.\n    /// - The bond must be listed.\n    ///\n    /// @param bond The hToken contract to update the permission for.\n    /// @param state The new state to put in storage.\n    function setLiquidateBorrowAllowed(IHToken bond, bool state) external;\n\n    /// @notice Sets max bonds value, which controls how many bond markets a single account can enter.\n    ///\n    /// @dev Emits a {SetMaxBonds} event.\n    ///\n    /// Requirements:\n    /// - The caller must be the owner.\n    ///\n    /// @param newMaxBonds New max bonds value.\n    function setMaxBonds(uint256 newMaxBonds) external;\n\n    /// @notice Sets max collaterals value, which controls how many collaterals a single account can deposit.\n    ///\n    /// @dev Emits a {SetMaxCollaterals} event.\n    ///\n    /// Requirements:\n    /// - The caller must be the owner.\n    ///\n    /// @param newMaxCollaterals New max collaterals value.\n    function setMaxCollaterals(uint256 newMaxCollaterals) external;\n\n    /// @notice Updates the state of the permission accessed by the hToken before a repay borrow.\n    ///\n    /// @dev Emits a {SetRepayBorrowAllowed} event.\n    ///\n    /// Requirements:\n    ///\n    /// - The caller must be the owner.\n    /// - The bond must be listed.\n    ///\n    /// @param bond The hToken contract to update the permission for.\n    /// @param state The new state to put in storage.\n    function setRepayBorrowAllowed(IHToken bond, bool state) external;\n}\n"

    },

    "@hifi/protocol/contracts/core/h-token/IHToken.sol": {

      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.4;\n\nimport \"@prb/contracts/access/IOwnable.sol\";\nimport \"@prb/contracts/token/erc20/IErc20.sol\";\nimport \"@prb/contracts/token/erc20/IErc20Permit.sol\";\nimport \"@prb/contracts/token/erc20/IErc20Recover.sol\";\n\nimport \"../balance-sheet/IBalanceSheetV2.sol\";\nimport \"../fintroller/IFintroller.sol\";\n\n/// @title IHToken\n/// @author Hifi\n/// @notice Zero-coupon bond that tracks an Erc20 underlying asset.\ninterface IHToken is\n    IOwnable, // no dependency\n    IErc20Permit, // one dependency\n    IErc20Recover // one dependency\n{\n    /// CUSTOM ERRORS ///\n\n    /// @notice Emitted when the bond matured.\n    error HToken__BondMatured(uint256 now, uint256 maturity);\n\n    /// @notice Emitted when the bond did not mature.\n    error HToken__BondNotMatured(uint256 now, uint256 maturity);\n\n    /// @notice Emitted when burning hTokens and the caller is not the BalanceSheet contract.\n    error HToken__BurnNotAuthorized(address caller);\n\n    /// @notice Emitted when underlying deposits are not allowed by the Fintroller contract.\n    error HToken__DepositUnderlyingNotAllowed();\n\n    /// @notice Emitted when depositing a zero amount of underlying.\n    error HToken__DepositUnderlyingZero();\n\n    /// @notice Emitted when the maturity is in the past.\n    error HToken__MaturityPassed(uint256 now, uint256 maturity);\n\n    /// @notice Emitted when minting hTokens and the caller is not the BalanceSheet contract.\n    error HToken__MintNotAuthorized(address caller);\n\n    /// @notice Emitted when redeeming more underlying that there is in the reserve.\n    error HToken__RedeemInsufficientLiquidity(uint256 underlyingAmount, uint256 totalUnderlyingReserve);\n\n    /// @notice Emitted when redeeming a zero amount of underlying.\n    error HToken__RedeemZero();\n\n    /// @notice Emitted when constructing the contract and the underlying has more than 18 decimals.\n    error HToken__UnderlyingDecimalsOverflow(uint256 decimals);\n\n    /// @notice Emitted when constructing the contract and the underlying has zero decimals.\n    error HToken__UnderlyingDecimalsZero();\n\n    /// @notice Emitted when withdrawing more underlying than there is available.\n    error HToken__WithdrawUnderlyingUnderflow(address depositor, uint256 availableAmount, uint256 underlyingAmount);\n\n    /// @notice Emitted when withdrawing a zero amount of underlying.\n    error HToken__WithdrawUnderlyingZero();\n\n    /// EVENTS ///\n\n    /// @notice Emitted when tokens are burnt.\n    /// @param holder The address of the holder.\n    /// @param burnAmount The amount of burnt tokens.\n    event Burn(address indexed holder, uint256 burnAmount);\n\n    /// @notice Emitted when underlying is deposited in exchange for an equivalent amount of hTokens.\n    /// @param depositor The address of the depositor.\n    /// @param depositUnderlyingAmount The amount of deposited underlying.\n    /// @param hTokenAmount The amount of minted hTokens.\n    event DepositUnderlying(address indexed depositor, uint256 depositUnderlyingAmount, uint256 hTokenAmount);\n\n    /// @notice Emitted when tokens are minted.\n    /// @param beneficiary The address of the holder.\n    /// @param mintAmount The amount of minted tokens.\n    event Mint(address indexed beneficiary, uint256 mintAmount);\n\n    /// @notice Emitted when underlying is redeemed.\n    /// @param account The account redeeming the underlying.\n    /// @param underlyingAmount The amount of redeemed underlying.\n    /// @param hTokenAmount The amount of provided hTokens.\n    event Redeem(address indexed account, uint256 underlyingAmount, uint256 hTokenAmount);\n\n    /// @notice Emitted when the BalanceSheet is set.\n    /// @param owner The address of the owner.\n    /// @param oldBalanceSheet The address of the old BalanceSheet.\n    /// @param newBalanceSheet The address of the new BalanceSheet.\n    event SetBalanceSheet(address indexed owner, IBalanceSheetV2 oldBalanceSheet, IBalanceSheetV2 newBalanceSheet);\n\n    /// @notice Emitted when a depositor withdraws previously deposited underlying.\n    /// @param depositor The address of the depositor.\n    /// @param underlyingAmount The amount of withdrawn underlying.\n    /// @param hTokenAmount The amount of minted hTokens.\n    event WithdrawUnderlying(address indexed depositor, uint256 underlyingAmount, uint256 hTokenAmount);\n\n    /// PUBLIC CONSTANT FUNCTIONS ///\n\n    /// @notice Returns the BalanceSheet contract this HToken is connected to.\n    function balanceSheet() external view returns (IBalanceSheetV2);\n\n    /// @notice Returns the balance of the given depositor.\n    function getDepositorBalance(address depositor) external view returns (uint256 amount);\n\n    /// @notice Returns the Fintroller contract this HToken is connected to.\n    function fintroller() external view returns (IFintroller);\n\n    /// @notice Checks if the bond matured.\n    /// @return bool true = bond matured, otherwise it didn't.\n    function isMatured() external view returns (bool);\n\n    /// @notice Unix timestamp in seconds for when this HToken matures.\n    function maturity() external view returns (uint256);\n\n    /// @notice The amount of underlying redeemable after maturation.\n    function totalUnderlyingReserve() external view returns (uint256);\n\n    /// @notice The Erc20 underlying asset for this HToken.\n    function underlying() external view returns (IErc20);\n\n    /// @notice The ratio between normalized precision (1e18) and the underlying precision.\n    function underlyingPrecisionScalar() external view returns (uint256);\n\n    /// PUBLIC NON-CONSTANT FUNCTIONS ///\n\n    /// @notice Destroys `burnAmount` tokens from `holder`, reducing the token supply.\n    ///\n    /// @dev Emits a {Burn} and a {Transfer} event.\n    ///\n    /// Requirements:\n    /// - Can only be called by the BalanceSheet contract.\n    ///\n    /// @param holder The account whose hTokens to burn.\n    /// @param burnAmount The amount of hTokens to burn.\n    function burn(address holder, uint256 burnAmount) external;\n\n    /// @notice Deposits underlying in exchange for an equivalent amount of hTokens.\n    ///\n    /// @dev Emits a {DepositUnderlying} event.\n    ///\n    /// Requirements:\n    ///\n    /// - The Fintroller must allow this action to be performed.\n    /// - The underlying amount to deposit cannot be zero.\n    /// - The caller must have allowed this contract to spend `underlyingAmount` tokens.\n    ///\n    /// @param underlyingAmount The amount of underlying to deposit.\n    function depositUnderlying(uint256 underlyingAmount) external;\n\n    /// @notice Prints new tokens into existence and assigns them to `beneficiary`, increasing the total supply.\n    ///\n    /// @dev Emits a {Mint} and a {Transfer} event.\n    ///\n    /// Requirements:\n    /// - Can only be called by the BalanceSheet contract.\n    ///\n    /// @param beneficiary The account to mint the hTokens for.\n    /// @param mintAmount The amount of hTokens to print into existence.\n    function mint(address beneficiary, uint256 mintAmount) external;\n\n    /// @notice Pays the token holder the face value after maturation.\n    ///\n    /// @dev Emits a {Redeem} event.\n    ///\n    /// Requirements:\n    ///\n    /// - Can only be called after maturation.\n    /// - The amount of underlying to redeem cannot be zero.\n    /// - There must be enough liquidity in the contract.\n    ///\n    /// @param underlyingAmount The amount of underlying to redeem.\n    function redeem(uint256 underlyingAmount) external;\n\n    /// @notice Updates the BalanceSheet contract this HToken is connected to.\n    ///\n    /// @dev Throws a {SetBalanceSheet} event.\n    ///\n    /// Requirements:\n    /// - The caller must be the owner.\n    ///\n    /// @param newBalanceSheet The address of the new BalanceSheet contract.\n    function _setBalanceSheet(IBalanceSheetV2 newBalanceSheet) external;\n\n    /// @notice Withdraws underlying in exchange for hTokens.\n    ///\n    /// @dev Emits a {WithdrawUnderlying} event.\n    ///\n    /// Requirements:\n    ///\n    /// - The underlying amount to withdraw cannot be zero.\n    /// - Can only be called before maturation.\n    ///\n    /// @param underlyingAmount The amount of underlying to withdraw.\n    function withdrawUnderlying(uint256 underlyingAmount) external;\n}\n"

    },

    "@hifi/protocol/contracts/access/IOwnableUpgradeable.sol": {

      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.4;\n\n/// @title IOwnableUpgradeable\n/// @author Hifi\ninterface IOwnableUpgradeable {\n    /// CUSTOM ERRORS ///\n\n    /// @notice Emitted when the caller is not the owner.\n    error OwnableUpgradeable__NotOwner(address owner, address caller);\n\n    /// @notice Emitted when setting the owner to the zero address.\n    error OwnableUpgradeable__OwnerZeroAddress();\n\n    /// EVENTS ///\n\n    /// @notice Emitted when ownership is transferred.\n    /// @param oldOwner The address of the old owner.\n    /// @param newOwner The address of the new owner.\n    event TransferOwnership(address indexed oldOwner, address indexed newOwner);\n\n    /// CONSTANT FUNCTIONS ///\n\n    /// @notice The address of the owner account or contract.\n    /// @return The address of the owner.\n    function owner() external view returns (address);\n\n    /// NON-CONSTANT FUNCTIONS ///\n\n    /// @notice Leaves the contract without an owner, so it will not be possible to call `onlyOwner`\n    /// functions anymore.\n    ///\n    /// WARNING: Doing this will leave the contract without an owner, thereby removing any\n    /// functionality that is only available to the owner.\n    ///\n    /// Requirements:\n    ///\n    /// - The caller must be the owner.\n    function _renounceOwnership() external;\n\n    /// @notice Transfers the owner of the contract to a new account (`newOwner`). Can only be\n    /// called by the current owner.\n    /// @param newOwner The account of the new owner.\n    function _transferOwnership(address newOwner) external;\n}\n"

    },

    "@hifi/protocol/contracts/oracles/IChainlinkOperator.sol": {

      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.4;\n\nimport \"@prb/contracts/token/erc20/IErc20.sol\";\nimport \"@prb/contracts/access/IOwnable.sol\";\n\nimport \"../external/chainlink/IAggregatorV3.sol\";\n\n/// @title IChainlinkOperator\n/// @author Hifi\n/// @notice Aggregates the price feeds provided by Chainlink.\ninterface IChainlinkOperator {\n    /// CUSTOM ERRORS ///\n\n    /// @notice Emitted when the decimal precision of the feed is not the same as the expected number.\n    error ChainlinkOperator__DecimalsMismatch(string symbol, uint256 decimals);\n\n    /// @notice Emitted when trying to interact with a feed not set yet.\n    error ChainlinkOperator__FeedNotSet(string symbol);\n\n    /// @notice Emitted when the price returned by the oracle is less than or equal to zero.\n    error ChainlinkOperator__PriceLessThanOrEqualToZero(string symbol);\n\n    /// @notice Emitted when the latest price update timestamp returned by the oracle is too old.\n    error ChainlinkOperator__PriceStale(string symbol);\n\n    /// EVENTS ///\n\n    /// @notice Emitted when a feed is deleted.\n    /// @param asset The related asset.\n    /// @param feed The related feed.\n    event DeleteFeed(IErc20 indexed asset, IAggregatorV3 indexed feed);\n\n    /// @notice Emitted when a feed is set.\n    /// @param asset The related asset.\n    /// @param feed The related feed.\n    event SetFeed(IErc20 indexed asset, IAggregatorV3 indexed feed);\n\n    /// @notice Emitted when the Chainlink price staleness threshold is set.\n    /// @param oldPriceStalenessThreshold The old Chainlink price staleness threshold.\n    /// @param newPriceStalenessThreshold The new Chainlink price staleness threshold.\n    event SetPriceStalenessThreshold(uint256 oldPriceStalenessThreshold, uint256 newPriceStalenessThreshold);\n\n    /// STRUCTS ///\n\n    struct Feed {\n        IErc20 asset;\n        IAggregatorV3 id;\n        bool isSet;\n    }\n\n    /// CONSTANT FUNCTIONS ///\n\n    /// @notice Gets the official feed for a symbol.\n    /// @param symbol The symbol to return the feed for.\n    /// @return (address asset, address id, bool isSet).\n    function getFeed(string memory symbol)\n        external\n        view\n        returns (\n            IErc20,\n            IAggregatorV3,\n            bool\n        );\n\n    /// @notice Gets the official price for a symbol and adjusts it have 18 decimals instead of the\n    /// format used by Chainlink, which has 8 decimals.\n    ///\n    /// @dev Requirements:\n    /// - The normalized price cannot overflow.\n    ///\n    /// @param symbol The Erc20 symbol of the token for which to query the price.\n    /// @return The normalized price.\n    function getNormalizedPrice(string memory symbol) external view returns (uint256);\n\n    /// @notice Gets the official price for a symbol in the default format used by Chainlink, which\n    /// has 8 decimals.\n    ///\n    /// @dev Requirements:\n    ///\n    /// - The feed must be set.\n    /// - The price returned by the oracle cannot be zero.\n    ///\n    /// @param symbol The symbol to fetch the price for.\n    /// @return The price denominated in USD, with 8 decimals.\n    function getPrice(string memory symbol) external view returns (uint256);\n\n    /// @notice Chainlink price precision for USD-quoted data.\n    function pricePrecision() external view returns (uint256);\n\n    /// @notice The ratio between normalized precision (1e18) and the Chainlink price precision (1e8).\n    function pricePrecisionScalar() external view returns (uint256);\n\n    /// @notice The Chainlink price staleness threshold.\n    function priceStalenessThreshold() external view returns (uint256);\n\n    /// NON-CONSTANT FUNCTIONS ///\n\n    /// @notice Deletes a previously set Chainlink price feed.\n    ///\n    /// @dev Emits a {DeleteFeed} event.\n    ///\n    /// Requirements:\n    ///\n    /// - The caller must be the owner.\n    /// - The feed must be set already.\n    ///\n    /// @param symbol The Erc20 symbol of the asset to delete the feed for.\n    function deleteFeed(string memory symbol) external;\n\n    /// @notice Sets a Chainlink price feed.\n    ///\n    /// @dev It is not an error to set a feed twice. Emits a {SetFeed} event.\n    ///\n    /// Requirements:\n    ///\n    /// - The caller must be the owner.\n    /// - The number of decimals of the feed must be 8.\n    ///\n    /// @param asset The address of the Erc20 contract for which to get the price.\n    /// @param feed The address of the Chainlink price feed contract.\n    function setFeed(IErc20 asset, IAggregatorV3 feed) external;\n\n    /// @notice Sets the Chainlink price staleness threshold.\n    ///\n    /// @dev Emits a {SetPriceStalenessThreshold} event.\n    ///\n    /// Requirements:\n    ///\n    /// - The caller must be the owner.\n    ///\n    /// @param newPriceStalenessThreshold The new Chainlink price staleness threshold.\n    function setPriceStalenessThreshold(uint256 newPriceStalenessThreshold) external;\n}\n"

    },

    "@prb/contracts/access/IOwnable.sol": {

      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\n/// @title IOwnable\n/// @author Paul Razvan Berg\n/// @notice Contract module that provides a basic access control mechanism, where there is an\n/// account (an owner) that can be granted exclusive access to specific functions.\n///\n/// By default, the owner account will be the one that deploys the contract. This can later be\n/// changed with {transfer}.\n///\n/// This module is used through inheritance. It will make available the modifier `onlyOwner`,\n/// which can be applied to your functions to restrict their use to the owner.\n///\n/// @dev Forked from OpenZeppelin\n/// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/access/Ownable.sol\ninterface IOwnable {\n    /// EVENTS ///\n\n    /// @notice Emitted when ownership is transferred.\n    /// @param oldOwner The address of the old owner.\n    /// @param newOwner The address of the new owner.\n    event TransferOwnership(address indexed oldOwner, address indexed newOwner);\n\n    /// NON-CONSTANT FUNCTIONS ///\n\n    /// @notice Leaves the contract without owner, so it will not be possible to call `onlyOwner`\n    /// functions anymore.\n    ///\n    /// WARNING: Doing this will leave the contract without an owner, thereby removing any\n    /// functionality that is only available to the owner.\n    ///\n    /// Requirements:\n    ///\n    /// - The caller must be the owner.\n    function _renounceOwnership() external;\n\n    /// @notice Transfers the owner of the contract to a new account (`newOwner`). Can only be\n    /// called by the current owner.\n    /// @param newOwner The account of the new owner.\n    function _transferOwnership(address newOwner) external;\n\n    /// CONSTANT FUNCTIONS ///\n\n    /// @notice The address of the owner account or contract.\n    /// @return The address of the owner.\n    function owner() external view returns (address);\n}\n"

    },

    "@prb/contracts/token/erc20/IErc20Permit.sol": {

      "content": "// SPDX-License-Identifier: Unlicense\n// solhint-disable func-name-mixedcase\npragma solidity >=0.8.4;\n\nimport \"./IErc20.sol\";\n\n/// @title IErc20Permit\n/// @author Paul Razvan Berg\n/// @notice Extension of Erc20 that allows token holders to use their tokens without sending any\n/// transactions by setting the allowance with a signature using the `permit` method, and then spend\n/// them via `transferFrom`.\n/// @dev See https://eips.ethereum.org/EIPS/eip-2612.\ninterface IErc20Permit is IErc20 {\n    /// NON-CONSTANT FUNCTIONS ///\n\n    /// @notice Sets `value` as the allowance of `spender` over `owner`'s tokens, assuming the latter's\n    /// signed approval.\n    ///\n    /// @dev Emits an {Approval} event.\n    ///\n    /// IMPORTANT: The same issues Erc20 `approve` has related to transaction\n    /// ordering also apply here.\n    ///\n    /// Requirements:\n    ///\n    /// - `owner` cannot be the zero address.\n    /// - `spender` cannot be the zero address.\n    /// - `deadline` must be a timestamp in the future.\n    /// - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner` over the Eip712-formatted\n    /// function arguments.\n    /// - The signature must use `owner`'s current nonce.\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /// CONSTANT FUNCTIONS ///\n\n    /// @notice The Eip712 domain's keccak256 hash.\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    /// @notice Provides replay protection.\n    function nonces(address account) external view returns (uint256);\n\n    /// @notice keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    function PERMIT_TYPEHASH() external view returns (bytes32);\n\n    /// @notice Eip712 version of this implementation.\n    function version() external view returns (string memory);\n}\n"

    },

    "@prb/contracts/token/erc20/IErc20Recover.sol": {

      "content": "// SPDX-License-Identifier: Unlicense\n// solhint-disable var-name-mixedcase\npragma solidity >=0.8.4;\n\nimport \"./IErc20.sol\";\nimport \"../../access/IOwnable.sol\";\n\n/// @title IErc20Recover\n/// @author Paul Razvan Berg\n/// @notice Contract that gives the owner the ability to recover the Erc20 tokens that were sent\n/// (accidentally, or not) to the contract.\ninterface IErc20Recover is IOwnable {\n    /// EVENTS ///\n\n    /// @notice Emitted when tokens are recovered.\n    /// @param owner The address of the owner recoverring the tokens.\n    /// @param token The address of the recovered token.\n    /// @param recoverAmount The amount of recovered tokens.\n    event Recover(address indexed owner, IErc20 token, uint256 recoverAmount);\n\n    /// @notice Emitted when tokens are set as non-recoverable.\n    /// @param owner The address of the owner calling the function.\n    /// @param nonRecoverableTokens An array of token addresses.\n    event SetNonRecoverableTokens(address indexed owner, IErc20[] nonRecoverableTokens);\n\n    /// NON-CONSTANT FUNCTIONS ///\n\n    /// @notice Recover Erc20 tokens sent to this contract (by accident or otherwise).\n    /// @dev Emits a {RecoverToken} event.\n    ///\n    /// Requirements:\n    ///\n    /// - The caller must be the owner.\n    /// - The contract must be initialized.\n    /// - The amount to recover cannot be zero.\n    /// - The token to recover cannot be among the non-recoverable tokens.\n    ///\n    /// @param token The token to make the recover for.\n    /// @param recoverAmount The uint256 amount to recover, specified in the token's decimal system.\n    function _recover(IErc20 token, uint256 recoverAmount) external;\n\n    /// @notice Sets the tokens that this contract cannot recover.\n    ///\n    /// @dev Emits a {SetNonRecoverableTokens} event.\n    ///\n    /// Requirements:\n    ///\n    /// - The caller must be the owner.\n    /// - The contract cannot be already initialized.\n    ///\n    /// @param tokens The array of tokens to set as non-recoverable.\n    function _setNonRecoverableTokens(IErc20[] calldata tokens) external;\n\n    /// CONSTANT FUNCTIONS ///\n\n    /// @notice The tokens that can be recovered cannot be in this mapping.\n    function nonRecoverableTokens(uint256 index) external view returns (IErc20);\n}\n"

    },

    "@hifi/protocol/contracts/external/chainlink/IAggregatorV3.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\n/// @title IAggregatorV3\n/// @author Hifi\n/// @dev Forked from Chainlink\n/// github.com/smartcontractkit/chainlink/blob/v1.2.0/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\ninterface IAggregatorV3 {\n    function decimals() external view returns (uint8);\n\n    function description() external view returns (string memory);\n\n    function version() external view returns (uint256);\n\n    /// getRoundData and latestRoundData should both raise \"No data present\" if they do not have\n    /// data to report, instead of returning unset values which could be misinterpreted as\n    /// actual reported values.\n    function getRoundData(uint80 _roundId)\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n"

    },

    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolImmutables.sol": {

      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that never changes\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\ninterface IUniswapV3PoolImmutables {\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n    /// @return The contract address\n    function factory() external view returns (address);\n\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n    /// @return The fee\n    function fee() external view returns (uint24);\n\n    /// @notice The pool tick spacing\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n    /// This value is an int24 to avoid casting even though it is always positive.\n    /// @return The tick spacing\n    function tickSpacing() external view returns (int24);\n\n    /// @notice The maximum amount of position liquidity that can use any tick in the range\n    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n    /// @return The max amount of liquidity per tick\n    function maxLiquidityPerTick() external view returns (uint128);\n}\n"

    },

    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolState.sol": {

      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that can change\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\n/// per transaction\ninterface IUniswapV3PoolState {\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n    /// when accessed externally.\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n    /// boundary.\n    /// observationIndex The index of the last oracle observation that was written,\n    /// observationCardinality The current maximum number of observations stored in the pool,\n    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n    /// feeProtocol The protocol fee for both tokens of the pool.\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n    /// unlocked Whether the pool is currently locked to reentrancy\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal0X128() external view returns (uint256);\n\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal1X128() external view returns (uint256);\n\n    /// @notice The amounts of token0 and token1 that are owed to the protocol\n    /// @dev Protocol fees will never exceed uint128 max in either token\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n\n    /// @notice The currently in range liquidity available to the pool\n    /// @dev This value has no relationship to the total liquidity across all ticks\n    function liquidity() external view returns (uint128);\n\n    /// @notice Look up information about a specific tick in the pool\n    /// @param tick The tick to look up\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n    /// tick upper,\n    /// liquidityNet how much liquidity changes when the pool price crosses the tick,\n    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n    /// secondsOutside the seconds spent on the other side of the tick from the current tick,\n    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n    /// a specific position.\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n\n    /// @notice Returns the information about a position by the position's key\n    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\n    /// @return _liquidity The amount of liquidity in the position,\n    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\n    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\n    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\n    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    /// @notice Returns data about a specific observation index\n    /// @param index The element of the observations array to fetch\n    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n    /// ago, rather than at a specific index in the array.\n    /// @return blockTimestamp The timestamp of the observation,\n    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n    /// Returns initialized whether the observation has been initialized and the values are safe to use\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}\n"

    },

    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolDerivedState.sol": {

      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that is not stored\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n/// blockchain. The functions here may have variable gas costs.\ninterface IUniswapV3PoolDerivedState {\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n    /// you must call it with secondsAgos = [3600, 0].\n    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n    /// timestamp\n    function observe(uint32[] calldata secondsAgos)\n        external\n        view\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n\n    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n    /// snapshot is taken and the second snapshot is taken.\n    /// @param tickLower The lower tick of the range\n    /// @param tickUpper The upper tick of the range\n    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n    /// @return secondsInside The snapshot of seconds per liquidity for the range\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n        external\n        view\n        returns (\n            int56 tickCumulativeInside,\n            uint160 secondsPerLiquidityInsideX128,\n            uint32 secondsInside\n        );\n}\n"

    },

    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolActions.sol": {

      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissionless pool actions\n/// @notice Contains pool methods that can be called by anyone\ninterface IUniswapV3PoolActions {\n    /// @notice Sets the initial price for the pool\n    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\n    function initialize(uint160 sqrtPriceX96) external;\n\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n    /// @param recipient The address for which the liquidity will be created\n    /// @param tickLower The lower tick of the position in which to add liquidity\n    /// @param tickUpper The upper tick of the position in which to add liquidity\n    /// @param amount The amount of liquidity to mint\n    /// @param data Any data that should be passed through to the callback\n    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Collects tokens owed to a position\n    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n    /// @param recipient The address which should receive the fees collected\n    /// @param tickLower The lower tick of the position for which to collect fees\n    /// @param tickUpper The upper tick of the position for which to collect fees\n    /// @param amount0Requested How much token0 should be withdrawn from the fees owed\n    /// @param amount1Requested How much token1 should be withdrawn from the fees owed\n    /// @return amount0 The amount of fees collected in token0\n    /// @return amount1 The amount of fees collected in token1\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n\n    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n    /// @dev Fees must be collected separately via a call to #collect\n    /// @param tickLower The lower tick of the position for which to burn liquidity\n    /// @param tickUpper The upper tick of the position for which to burn liquidity\n    /// @param amount How much liquidity to burn\n    /// @return amount0 The amount of token0 sent to the recipient\n    /// @return amount1 The amount of token1 sent to the recipient\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Swap token0 for token1, or token1 for token0\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n    /// @param recipient The address to receive the output of the swap\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n    /// @param data Any data to be passed through to the callback\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n\n    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\n    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\n    /// with 0 amount{0,1} and sending the donation amount(s) from the callback\n    /// @param recipient The address which will receive the token0 and token1 amounts\n    /// @param amount0 The amount of token0 to send\n    /// @param amount1 The amount of token1 to send\n    /// @param data Any data to be passed through to the callback\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n\n    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\n    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n    /// the input observationCardinalityNext.\n    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}\n"

    },

    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolOwnerActions.sol": {

      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissioned pool actions\n/// @notice Contains pool methods that may only be called by the factory owner\ninterface IUniswapV3PoolOwnerActions {\n    /// @notice Set the denominator of the protocol's % share of the fees\n    /// @param feeProtocol0 new protocol fee for token0 of the pool\n    /// @param feeProtocol1 new protocol fee for token1 of the pool\n    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\n\n    /// @notice Collect the protocol fee accrued to the pool\n    /// @param recipient The address to which collected protocol fees should be sent\n    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\n    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\n    /// @return amount0 The protocol fee collected in token0\n    /// @return amount1 The protocol fee collected in token1\n    function collectProtocol(\n        address recipient,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n}\n"

    },

    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolEvents.sol": {

      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Events emitted by a pool\n/// @notice Contains all events emitted by the pool\ninterface IUniswapV3PoolEvents {\n    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\n    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\n    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\n    event Initialize(uint160 sqrtPriceX96, int24 tick);\n\n    /// @notice Emitted when liquidity is minted for a given position\n    /// @param sender The address that minted the liquidity\n    /// @param owner The owner of the position and recipient of any minted liquidity\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity minted to the position range\n    /// @param amount0 How much token0 was required for the minted liquidity\n    /// @param amount1 How much token1 was required for the minted liquidity\n    event Mint(\n        address sender,\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted when fees are collected by the owner of a position\n    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\n    /// @param owner The owner of the position for which fees are collected\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount0 The amount of token0 fees collected\n    /// @param amount1 The amount of token1 fees collected\n    event Collect(\n        address indexed owner,\n        address recipient,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount0,\n        uint128 amount1\n    );\n\n    /// @notice Emitted when a position's liquidity is removed\n    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\n    /// @param owner The owner of the position for which liquidity is removed\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity to remove\n    /// @param amount0 The amount of token0 withdrawn\n    /// @param amount1 The amount of token1 withdrawn\n    event Burn(\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted by the pool for any swaps between token0 and token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the output of the swap\n    /// @param amount0 The delta of the token0 balance of the pool\n    /// @param amount1 The delta of the token1 balance of the pool\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n    /// @param liquidity The liquidity of the pool after the swap\n    /// @param tick The log base 1.0001 of price of the pool after the swap\n    event Swap(\n        address indexed sender,\n        address indexed recipient,\n        int256 amount0,\n        int256 amount1,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        int24 tick\n    );\n\n    /// @notice Emitted by the pool for any flashes of token0/token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the tokens from flash\n    /// @param amount0 The amount of token0 that was flashed\n    /// @param amount1 The amount of token1 that was flashed\n    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\n    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\n    event Flash(\n        address indexed sender,\n        address indexed recipient,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 paid0,\n        uint256 paid1\n    );\n\n    /// @notice Emitted by the pool for increases to the number of observations that can be stored\n    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n    /// just before a mint/swap/burn.\n    /// @param observationCardinalityNextOld The previous value of the next observation cardinality\n    /// @param observationCardinalityNextNew The updated value of the next observation cardinality\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld,\n        uint16 observationCardinalityNextNew\n    );\n\n    /// @notice Emitted when the protocol fee is changed by the pool\n    /// @param feeProtocol0Old The previous value of the token0 protocol fee\n    /// @param feeProtocol1Old The previous value of the token1 protocol fee\n    /// @param feeProtocol0New The updated value of the token0 protocol fee\n    /// @param feeProtocol1New The updated value of the token1 protocol fee\n    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\n\n    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\n    /// @param sender The address that collects the protocol fees\n    /// @param recipient The address that receives the collected protocol fees\n    /// @param amount0 The amount of token0 protocol fees that is withdrawn\n    /// @param amount0 The amount of token1 protocol fees that is withdrawn\n    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\n}\n"

    },

    "@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol": {

      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n"

    }

  },

  "settings": {

    "metadata": {

      "bytecodeHash": "none"

    },

    "optimizer": {

      "enabled": true,

      "runs": 800

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "libraries": {}

  }

}}