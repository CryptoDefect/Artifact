{{

  "language": "Solidity",

  "sources": {

    "contracts/potted_data.sol": {

      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.7;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\nimport \"./SSTORE2Map.sol\";\r\nimport \"./potted_types.sol\";\r\n\r\ncontract PPData is Ownable {\r\n  PottedTypes.Potted[] private potteds;\r\n  PottedTypes.Branch[] private branches;\r\n  PottedTypes.Blossom[] private blossoms;\r\n  PottedTypes.Bg[] private bgs;\r\n\r\n  string constant bg = \"bg\";\r\n  string constant pottedA = \"PottedA\";\r\n  string constant pottedB = \"PottedB\";\r\n  string constant pottedC = \"PottedC\";\r\n  string constant branchA = \"branchA\";\r\n  string constant branchB = \"branchB\";\r\n  string constant branchC = \"branchC\";\r\n  string constant blossomA = \"blossomA\";\r\n  string constant blossomB = \"blossomB\";\r\n  string constant blossomC = \"blossomC\";\r\n  string constant unreveal = \"unreveal\";\r\n\r\n  function getAllPotted() external view returns (PottedTypes.Potted[] memory) {\r\n    return potteds;\r\n  }\r\n\r\n  function getAllBranch() external view returns (PottedTypes.Branch[] memory) {\r\n    return branches;\r\n  }\r\n\r\n  function getAllBlossom() external view returns (PottedTypes.Blossom[] memory) {\r\n    return blossoms;\r\n  }\r\n\r\n  function getAllBg() external view returns (PottedTypes.Bg[] memory) {\r\n    return bgs;\r\n  }\r\n\r\n  function updatePotted(uint index, PottedTypes.Potted memory newData) external onlyOwner {\r\n    potteds[index] = newData;\r\n  }\r\n\r\n  function updateBranch(uint index, PottedTypes.Branch memory newData) external onlyOwner {\r\n    branches[index] = newData;\r\n  }\r\n\r\n  function updateBlossom(uint index, PottedTypes.Blossom memory newData) external onlyOwner {\r\n    blossoms[index] = newData;\r\n  }\r\n\r\n  function setPotteds(PottedTypes.Potted[] calldata _potted) external onlyOwner {\r\n    for (uint i; i < _potted.length; i++) {\r\n      potteds.push(_potted[i]);\r\n    } \r\n  }\r\n\r\n  function setBranches(PottedTypes.Branch[] calldata _branch) external onlyOwner {\r\n    for (uint i; i < _branch.length; i++) {\r\n      branches.push(_branch[i]);\r\n    } \r\n  }\r\n\r\n  function setBlossoms(PottedTypes.Blossom[] calldata _blossom) external onlyOwner {\r\n    for (uint i; i < _blossom.length; i++) {\r\n      blossoms.push(_blossom[i]);\r\n    } \r\n  }\r\n\r\n  function setBgs(PottedTypes.Bg[] calldata _bg) external onlyOwner {\r\n    for (uint i; i < _bg.length; i++) {\r\n      bgs.push(_bg[i]);\r\n    } \r\n  }\r\n\r\n  ///IMAGES\r\n  //Potted\r\n  function setPottedAImages(bytes[] calldata _hashes) external onlyOwner {\r\n    SSTORE2Map.write(pottedA, abi.encode(_hashes));\r\n  }\r\n  function setPottedBImages(bytes[] calldata _hashes) external onlyOwner {\r\n    SSTORE2Map.write(pottedB, abi.encode(_hashes));\r\n  }\r\n  function setPottedCImages(bytes[] calldata _hashes) external onlyOwner {\r\n    SSTORE2Map.write(pottedC, abi.encode(_hashes));\r\n  }\r\n  function getPottedImages() external view returns (bytes[] memory) {\r\n    bytes[] memory dataA = abi.decode(SSTORE2Map.read(pottedA), (bytes[]));\r\n    bytes[] memory dataB = abi.decode(SSTORE2Map.read(pottedB), (bytes[]));\r\n    bytes[] memory dataC = abi.decode(SSTORE2Map.read(pottedC), (bytes[]));\r\n\r\n    bytes[] memory hashes = new bytes[](dataA.length + dataB.length + dataC.length);\r\n\r\n    for (uint i = 0; i < dataA.length; i++) {\r\n      hashes[i] = dataA[i];\r\n    }\r\n    \r\n    for (uint i = 0; i < dataB.length; i++) {\r\n      hashes[i + dataA.length] = dataB[i];\r\n    }\r\n    \r\n    for (uint i = 0; i < dataC.length; i++) {\r\n      hashes[i + dataA.length + dataB.length] = dataC[i];\r\n    }\r\n\r\n    return hashes;\r\n  }\r\n\r\n  //Branch\r\n  function setBranchAImages(bytes[] calldata _hashes) external onlyOwner {\r\n    SSTORE2Map.write(branchA, abi.encode(_hashes));\r\n  }\r\n  function setBranchBImages(bytes[] calldata _hashes) external onlyOwner {\r\n    SSTORE2Map.write(branchB, abi.encode(_hashes));\r\n  }\r\n  function setBranchCImages(bytes[] calldata _hashes) external onlyOwner {\r\n    SSTORE2Map.write(branchC, abi.encode(_hashes));\r\n  }\r\n  function getBranchImages() external view returns (bytes[] memory) {\r\n    bytes[] memory dataA = abi.decode(SSTORE2Map.read(branchA), (bytes[]));\r\n    bytes[] memory dataB = abi.decode(SSTORE2Map.read(branchB), (bytes[]));\r\n    bytes[] memory dataC = abi.decode(SSTORE2Map.read(branchC), (bytes[]));\r\n\r\n    bytes[] memory hashes = new bytes[](dataA.length + dataB.length + dataC.length);\r\n\r\n    for (uint i = 0; i < dataA.length; i++) {\r\n      hashes[i] = dataA[i];\r\n    }\r\n    \r\n    for (uint i = 0; i < dataB.length; i++) {\r\n      hashes[i + dataA.length] = dataB[i];\r\n    }\r\n    \r\n    for (uint i = 0; i < dataC.length; i++) {\r\n      hashes[i + dataA.length + dataB.length] = dataC[i];\r\n    }\r\n\r\n    return hashes;\r\n  }\r\n\r\n  //Blossom\r\n  function setBlossomAImages(bytes[] calldata _hashes) external onlyOwner {\r\n    SSTORE2Map.write(blossomA, abi.encode(_hashes));\r\n  }\r\n  function setBlossomBImages(bytes[] calldata _hashes) external onlyOwner {\r\n    SSTORE2Map.write(blossomB, abi.encode(_hashes));\r\n  }\r\n  function setBlossomCImages(bytes[] calldata _hashes) external onlyOwner {\r\n    SSTORE2Map.write(blossomC, abi.encode(_hashes));\r\n  }\r\n  function getBlossomImages() external view returns (bytes[] memory) {\r\n    bytes[] memory dataA = abi.decode(SSTORE2Map.read(blossomA), (bytes[]));\r\n    bytes[] memory dataB = abi.decode(SSTORE2Map.read(blossomB), (bytes[]));\r\n    bytes[] memory dataC = abi.decode(SSTORE2Map.read(blossomC), (bytes[]));\r\n\r\n    bytes[] memory hashes = new bytes[](dataA.length + dataB.length + dataC.length);\r\n\r\n    for (uint i = 0; i < dataA.length; i++) {\r\n      hashes[i] = dataA[i];\r\n    }\r\n    \r\n    for (uint i = 0; i < dataB.length; i++) {\r\n      hashes[i + dataA.length] = dataB[i];\r\n    }\r\n    for (uint i = 0; i < dataC.length; i++) {\r\n      hashes[i + dataA.length + dataB.length] = dataC[i];\r\n    }\r\n\r\n    return hashes;\r\n  }\r\n\r\n  //Background\r\n  function setBgImages(bytes[] calldata _hashes) external onlyOwner {\r\n    SSTORE2Map.write(bg, abi.encode(_hashes));\r\n  }\r\n  function getBgImages() external view returns (bytes[] memory) {\r\n    return abi.decode(SSTORE2Map.read(bg), (bytes[]));\r\n  }\r\n\r\n  //Unreveal\r\n  function setUnreveal(bytes[] calldata _hashes) external onlyOwner {\r\n    SSTORE2Map.write(unreveal, abi.encode(_hashes));\r\n  }\r\n  function getUnreveal() external view returns (bytes[] memory) {\r\n    return abi.decode(SSTORE2Map.read(unreveal), (bytes[]));\r\n  }\r\n\r\n}"

    },

    "contracts/potted_types.sol": {

      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.7;\r\n\r\ninterface PottedTypes {\r\n    struct Gene {\r\n        uint dna;\r\n        uint revealNum;\r\n        bool isReroll;\r\n    }\r\n\r\n    struct MyPotted {\r\n      Potted potted;\r\n      Branch branch;\r\n      Blossom blossom;\r\n      Bg bg;\r\n    }\r\n\r\n    struct Potted {\r\n      string traitName;\r\n      uint width;\r\n      uint height;\r\n      uint x;\r\n      uint y;\r\n      uint id;\r\n    }\r\n\r\n    struct Branch {\r\n      string traitName;\r\n      uint width;\r\n      uint height;\r\n      uint unique;\r\n      uint x;\r\n      uint y;\r\n      uint[] pointX;\r\n      uint[] pointY;\r\n      uint id;\r\n    }\r\n\r\n    // Each blossom max count <= branchPointX.length\r\n    struct Blossom {\r\n      string traitName;\r\n      uint[] width;\r\n      uint[] height;\r\n      uint[] childs;\r\n      uint id;\r\n    }\r\n\r\n    struct Bg {\r\n      string traitName;\r\n      uint id;\r\n    }\r\n}"

    },

    "contracts/SSTORE2Map.sol": {

      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./Create3.sol\";\r\nimport \"./Bytecode.sol\";\r\n\r\n\r\n/**\r\n  @title A write-once key-value storage for storing chunks of data with a lower write & read cost.\r\n  @author Agustin Aguilar <aa@horizon.io>\r\n\r\n  Readme: https://github.com/0xsequence/sstore2#readme\r\n*/\r\nlibrary SSTORE2Map {\r\n  error WriteError();\r\n\r\n  //                                         keccak256(bytes('@0xSequence.SSTORE2Map.slot'))\r\n  bytes32 private constant SLOT_KEY_PREFIX = 0xd351a9253491dfef66f53115e9e3afda3b5fdef08a1de6937da91188ec553be5;\r\n\r\n  function internalKey(bytes32 _key) internal pure returns (bytes32) {\r\n    // Mutate the key so it doesn't collide\r\n    // if the contract is also using CREATE3 for other things\r\n    return keccak256(abi.encode(SLOT_KEY_PREFIX, _key));\r\n  }\r\n\r\n  /**\r\n    @notice Stores `_data` and returns `pointer` as key for later retrieval\r\n    @dev The pointer is a contract address with `_data` as code\r\n    @param _data To be written\r\n    @param _key unique string key for accessing the written data (can only be used once)\r\n    @return pointer Pointer to the written `_data`\r\n  */\r\n  function write(string memory _key, bytes memory _data) internal returns (address pointer) {\r\n    return write(keccak256(bytes(_key)), _data);\r\n  }\r\n\r\n  /**\r\n    @notice Stores `_data` and returns `pointer` as key for later retrieval\r\n    @dev The pointer is a contract address with `_data` as code\r\n    @param _data to be written\r\n    @param _key unique bytes32 key for accessing the written data (can only be used once)\r\n    @return pointer Pointer to the written `_data`\r\n  */\r\n  function write(bytes32 _key, bytes memory _data) internal returns (address pointer) {\r\n    // Append 00 to _data so contract can't be called\r\n    // Build init code\r\n    bytes memory code = Bytecode.creationCodeFor(\r\n      abi.encodePacked(\r\n        hex'00',\r\n        _data\r\n      )\r\n    );\r\n\r\n    // Deploy contract using create3\r\n    pointer = Create3.create3(internalKey(_key), code);\r\n  }\r\n\r\n  /**\r\n    @notice Reads the contents for a given `_key`, it maps to a contract code as data, skips the first byte\r\n    @dev The function is intended for reading pointers first written by `write`\r\n    @param _key string key that constains the data\r\n    @return data read from contract associated with `_key`\r\n  */\r\n  function read(string memory _key) internal view returns (bytes memory) {\r\n    return read(keccak256(bytes(_key)));\r\n  }\r\n\r\n  /**\r\n    @notice Reads the contents for a given `_key`, it maps to a contract code as data, skips the first byte\r\n    @dev The function is intended for reading pointers first written by `write`\r\n    @param _key string key that constains the data\r\n    @param _start number of bytes to skip\r\n    @return data read from contract associated with `_key`\r\n  */\r\n  function read(string memory _key, uint256 _start) internal view returns (bytes memory) {\r\n    return read(keccak256(bytes(_key)), _start);\r\n  }\r\n\r\n  /**\r\n    @notice Reads the contents for a given `_key`, it maps to a contract code as data, skips the first byte\r\n    @dev The function is intended for reading pointers first written by `write`\r\n    @param _key string key that constains the data\r\n    @param _start number of bytes to skip\r\n    @param _end index before which to end extraction\r\n    @return data read from contract associated with `_key`\r\n  */\r\n  function read(string memory _key, uint256 _start, uint256 _end) internal view returns (bytes memory) {\r\n    return read(keccak256(bytes(_key)), _start, _end);\r\n  }\r\n\r\n  /**\r\n    @notice Reads the contents for a given `_key`, it maps to a contract code as data, skips the first byte\r\n    @dev The function is intended for reading pointers first written by `write`\r\n    @param _key bytes32 key that constains the data\r\n    @return data read from contract associated with `_key`\r\n  */\r\n  function read(bytes32 _key) internal view returns (bytes memory) {\r\n    return Bytecode.codeAt(Create3.addressOf(internalKey(_key)), 1, type(uint256).max);\r\n  }\r\n\r\n  /**\r\n    @notice Reads the contents for a given `_key`, it maps to a contract code as data, skips the first byte\r\n    @dev The function is intended for reading pointers first written by `write`\r\n    @param _key bytes32 key that constains the data\r\n    @param _start number of bytes to skip\r\n    @return data read from contract associated with `_key`\r\n  */\r\n  function read(bytes32 _key, uint256 _start) internal view returns (bytes memory) {\r\n    return Bytecode.codeAt(Create3.addressOf(internalKey(_key)), _start + 1, type(uint256).max);\r\n  }\r\n\r\n  /**\r\n    @notice Reads the contents for a given `_key`, it maps to a contract code as data, skips the first byte\r\n    @dev The function is intended for reading pointers first written by `write`\r\n    @param _key bytes32 key that constains the data\r\n    @param _start number of bytes to skip\r\n    @param _end index before which to end extraction\r\n    @return data read from contract associated with `_key`\r\n  */\r\n  function read(bytes32 _key, uint256 _start, uint256 _end) internal view returns (bytes memory) {\r\n    return Bytecode.codeAt(Create3.addressOf(internalKey(_key)), _start + 1, _end + 1);\r\n  }\r\n}"

    },

    "@openzeppelin/contracts/access/Ownable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"

    },

    "contracts/Bytecode.sol": {

      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n\r\nlibrary Bytecode {\r\n  error InvalidCodeAtRange(uint256 _size, uint256 _start, uint256 _end);\r\n\r\n  /**\r\n    @notice Generate a creation code that results on a contract with `_code` as bytecode\r\n    @param _code The returning value of the resulting `creationCode`\r\n    @return creationCode (constructor) for new contract\r\n  */\r\n  function creationCodeFor(bytes memory _code) internal pure returns (bytes memory) {\r\n    /*\r\n      0x00    0x63         0x63XXXXXX  PUSH4 _code.length  size\r\n      0x01    0x80         0x80        DUP1                size size\r\n      0x02    0x60         0x600e      PUSH1 14            14 size size\r\n      0x03    0x60         0x6000      PUSH1 00            0 14 size size\r\n      0x04    0x39         0x39        CODECOPY            size\r\n      0x05    0x60         0x6000      PUSH1 00            0 size\r\n      0x06    0xf3         0xf3        RETURN\r\n      <CODE>\r\n    */\r\n\r\n    return abi.encodePacked(\r\n      hex\"63\",\r\n      uint32(_code.length),\r\n      hex\"80_60_0E_60_00_39_60_00_F3\",\r\n      _code\r\n    );\r\n  }\r\n\r\n  /**\r\n    @notice Returns the size of the code on a given address\r\n    @param _addr Address that may or may not contain code\r\n    @return size of the code on the given `_addr`\r\n  */\r\n  function codeSize(address _addr) internal view returns (uint256 size) {\r\n    assembly { size := extcodesize(_addr) }\r\n  }\r\n\r\n  /**\r\n    @notice Returns the code of a given address\r\n    @dev It will fail if `_end < _start`\r\n    @param _addr Address that may or may not contain code\r\n    @param _start number of bytes of code to skip on read\r\n    @param _end index before which to end extraction\r\n    @return oCode read from `_addr` deployed bytecode\r\n\r\n    Forked from: https://gist.github.com/KardanovIR/fe98661df9338c842b4a30306d507fbd\r\n  */\r\n  function codeAt(address _addr, uint256 _start, uint256 _end) internal view returns (bytes memory oCode) {\r\n    uint256 csize = codeSize(_addr);\r\n    if (csize == 0) return bytes(\"\");\r\n\r\n    if (_start > csize) return bytes(\"\");\r\n    if (_end < _start) revert InvalidCodeAtRange(csize, _start, _end); \r\n\r\n    unchecked {\r\n      uint256 reqSize = _end - _start;\r\n      uint256 maxSize = csize - _start;\r\n\r\n      uint256 size = maxSize < reqSize ? maxSize : reqSize;\r\n\r\n      assembly {\r\n        // allocate output byte array - this could also be done without assembly\r\n        // by using o_code = new bytes(size)\r\n        oCode := mload(0x40)\r\n        // new \"memory end\" including padding\r\n        mstore(0x40, add(oCode, and(add(add(size, 0x20), 0x1f), not(0x1f))))\r\n        // store length in memory\r\n        mstore(oCode, size)\r\n        // actually retrieve the code, this needs assembly\r\n        extcodecopy(_addr, add(oCode, 0x20), _start, size)\r\n      }\r\n    }\r\n  }\r\n}"

    },

    "contracts/Create3.sol": {

      "content": "//SPDX-License-Identifier: Unlicense\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n  @title A library for deploying contracts EIP-3171 style.\r\n  @author Agustin Aguilar <aa@horizon.io>\r\n*/\r\nlibrary Create3 {\r\n  error ErrorCreatingProxy();\r\n  error ErrorCreatingContract();\r\n  error TargetAlreadyExists();\r\n\r\n  /**\r\n    @notice The bytecode for a contract that proxies the creation of another contract\r\n    @dev If this code is deployed using CREATE2 it can be used to decouple `creationCode` from the child contract address\r\n\r\n  0x67363d3d37363d34f03d5260086018f3:\r\n      0x00  0x67  0x67XXXXXXXXXXXXXXXX  PUSH8 bytecode  0x363d3d37363d34f0\r\n      0x01  0x3d  0x3d                  RETURNDATASIZE  0 0x363d3d37363d34f0\r\n      0x02  0x52  0x52                  MSTORE\r\n      0x03  0x60  0x6008                PUSH1 08        8\r\n      0x04  0x60  0x6018                PUSH1 18        24 8\r\n      0x05  0xf3  0xf3                  RETURN\r\n\r\n  0x363d3d37363d34f0:\r\n      0x00  0x36  0x36                  CALLDATASIZE    cds\r\n      0x01  0x3d  0x3d                  RETURNDATASIZE  0 cds\r\n      0x02  0x3d  0x3d                  RETURNDATASIZE  0 0 cds\r\n      0x03  0x37  0x37                  CALLDATACOPY\r\n      0x04  0x36  0x36                  CALLDATASIZE    cds\r\n      0x05  0x3d  0x3d                  RETURNDATASIZE  0 cds\r\n      0x06  0x34  0x34                  CALLVALUE       val 0 cds\r\n      0x07  0xf0  0xf0                  CREATE          addr\r\n  */\r\n  \r\n  bytes internal constant PROXY_CHILD_BYTECODE = hex\"67_36_3d_3d_37_36_3d_34_f0_3d_52_60_08_60_18_f3\";\r\n\r\n  //                        KECCAK256_PROXY_CHILD_BYTECODE = keccak256(PROXY_CHILD_BYTECODE);\r\n  bytes32 internal constant KECCAK256_PROXY_CHILD_BYTECODE = 0x21c35dbe1b344a2488cf3321d6ce542f8e9f305544ff09e4993a62319a497c1f;\r\n\r\n  /**\r\n    @notice Returns the size of the code on a given address\r\n    @param _addr Address that may or may not contain code\r\n    @return size of the code on the given `_addr`\r\n  */\r\n  function codeSize(address _addr) internal view returns (uint256 size) {\r\n    assembly { size := extcodesize(_addr) }\r\n  }\r\n\r\n  /**\r\n    @notice Creates a new contract with given `_creationCode` and `_salt`\r\n    @param _salt Salt of the contract creation, resulting address will be derivated from this value only\r\n    @param _creationCode Creation code (constructor) of the contract to be deployed, this value doesn't affect the resulting address\r\n    @return addr of the deployed contract, reverts on error\r\n  */\r\n  function create3(bytes32 _salt, bytes memory _creationCode) internal returns (address addr) {\r\n    return create3(_salt, _creationCode, 0);\r\n  }\r\n\r\n  /**\r\n    @notice Creates a new contract with given `_creationCode` and `_salt`\r\n    @param _salt Salt of the contract creation, resulting address will be derivated from this value only\r\n    @param _creationCode Creation code (constructor) of the contract to be deployed, this value doesn't affect the resulting address\r\n    @param _value In WEI of ETH to be forwarded to child contract\r\n    @return addr of the deployed contract, reverts on error\r\n  */\r\n  function create3(bytes32 _salt, bytes memory _creationCode, uint256 _value) internal returns (address addr) {\r\n    // Creation code\r\n    bytes memory creationCode = PROXY_CHILD_BYTECODE;\r\n\r\n    // Get target final address\r\n    addr = addressOf(_salt);\r\n    if (codeSize(addr) != 0) revert TargetAlreadyExists();\r\n\r\n    // Create CREATE2 proxy\r\n    address proxy; assembly { proxy := create2(0, add(creationCode, 32), mload(creationCode), _salt)}\r\n    if (proxy == address(0)) revert ErrorCreatingProxy();\r\n\r\n    // Call proxy with final init code\r\n    (bool success,) = proxy.call{ value: _value }(_creationCode);\r\n    if (!success || codeSize(addr) == 0) revert ErrorCreatingContract();\r\n  }\r\n\r\n  /**\r\n    @notice Computes the resulting address of a contract deployed using address(this) and the given `_salt`\r\n    @param _salt Salt of the contract creation, resulting address will be derivated from this value only\r\n    @return addr of the deployed contract, reverts on error\r\n\r\n    @dev The address creation formula is: keccak256(rlp([keccak256(0xff ++ address(this) ++ _salt ++ keccak256(childBytecode))[12:], 0x01]))\r\n  */\r\n  function addressOf(bytes32 _salt) internal view returns (address) {\r\n    address proxy = address(\r\n      uint160(\r\n        uint256(\r\n          keccak256(\r\n            abi.encodePacked(\r\n              hex'ff',\r\n              address(this),\r\n              _salt,\r\n              KECCAK256_PROXY_CHILD_BYTECODE\r\n            )\r\n          )\r\n        )\r\n      )\r\n    );\r\n\r\n    return address(\r\n      uint160(\r\n        uint256(\r\n          keccak256(\r\n            abi.encodePacked(\r\n              hex\"d6_94\",\r\n              proxy,\r\n              hex\"01\"\r\n            )\r\n          )\r\n        )\r\n      )\r\n    );\r\n  }\r\n}"

    },

    "@openzeppelin/contracts/utils/Context.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"

    }

  },

  "settings": {

    "optimizer": {

      "enabled": true,

      "runs": 200

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    }

  }

}}