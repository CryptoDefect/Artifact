{{

  "language": "Solidity",

  "sources": {

    "packages/contracts/lib/openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     *\n     * _Available since v4.7._\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     *\n     * _Available since v4.7._\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"

    },

    "packages/contracts/src/DefinitelyClaimable.sol": {

      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.17;\n\n/**\n                                                      ...:--==***#@%%-\n                                             ..:  -*@@@@@@@@@@@@@#*:  \n                               -:::-=+*#%@@@@@@*-=@@@@@@@@@@@#+=:     \n           .::---:.         +#@@@@@@@@@@@@@%*+-. -@@@@@@+..           \n    .-+*%@@@@@@@@@@@#-     -@@@@@@@@@@%#*=:.    :@@@@@@@#%@@@@@%:     \n =#@@@@@@@@@@@@@@@@@@@%.   %@@@@@@-..           *@@@@@@@@@@@@%*.      \n-@@@@@@@@@#*+=--=#@@@@@%  +@@@@@@%*#%@@@%*=-.. .@@@@@@@%%*+=:         \n :*@@@@@@*       .@@@@@@.*@@@@@@@@@@@@*+-      =%@@@@%                \n  =@@@@@@.       *@@@@@%:@@@@@@*==-:.          =@@@@@:                \n .@@@@@@=      =@@@@@@%.*@@@@@=   ..::--=+*=+*+=@@@@=                 \n #@@@@@*    .+@@@@@@@* .+@@@@@#%%@@@@@@@@#+:.  =#@@=                  \n @@@@@%   :*@@@@@@@*:  .#@@@@@@@@@@@@@%#:       ---                   \n:@@@@%. -%@@@@@@@+.     +@@@@@%#*+=:.                                 \n+@@@%=*@@@@@@@*:        =*:                                           \n:*#+%@@@@%*=.                                                         \n :+##*=:.\n\n*/\n\nimport {Auth} from \"./lib/Auth.sol\";\nimport {MerkleProof} from \"openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport {IDefinitelyMemberships} from \"./interfaces/IDefinitelyMemberships.sol\";\nimport {IDelegationRegistry} from \"./interfaces/IDelegationRegistry.sol\";\n\n/**\n * @title\n * Definitely Claimable\n *\n * @author\n * DEF DAO\n *\n * @notice\n * A membership issuing contract that uses EIP-712 signatures to allow membership claiming\n */\ncontract DefinitelyClaimable is Auth {\n    /* ------------------------------------------------------------------------\n       S T O R A G E    \n    ------------------------------------------------------------------------ */\n\n    /// @notice The main membership contract\n    address public memberships;\n\n    /// @notice The address of the delegate.cash delegation registry\n    address public delegationRegistry = 0x00000000000076A84feF008CDAbe6409d2FE638B;\n\n    /// @notice The merkle root used for claiming memberships\n    bytes32 public claimableRoot;\n\n    /* ------------------------------------------------------------------------\n       E V E N T S    \n    ------------------------------------------------------------------------ */\n\n    /// @dev Whenever a membership is claimed for an existing DEF member\n    event MembershipClaimed(address indexed member);\n\n    /// @dev Whenever the claimable merkle root is updated\n    event ClaimableRootUpdated(bytes32 indexed root);\n\n    /// @dev Whenever the delegation registry address is updated\n    event DelegationRegistryUpdated(address indexed registry);\n\n    /* ------------------------------------------------------------------------\n       E R R O R S    \n    ------------------------------------------------------------------------ */\n\n    error InvalidProof();\n    error NotDelegatedToClaim();\n\n    /* ------------------------------------------------------------------------\n       I N I T\n    ------------------------------------------------------------------------ */\n\n    /**\n     * @param owner_ Contract owner address\n     * @param memberships_ The main membership contract\n     * @param initialRoot_ An initial merkle root for claiming memberships\n     */\n    constructor(\n        address owner_,\n        address memberships_,\n        bytes32 initialRoot_\n    ) Auth(owner_) {\n        memberships = memberships_;\n        claimableRoot = initialRoot_;\n        emit ClaimableRootUpdated(initialRoot_);\n    }\n\n    /* ------------------------------------------------------------------------\n       C L A I M I N G\n    ------------------------------------------------------------------------ */\n\n    /**\n     * @notice\n     * Allows someone to claim a DEF membership with a valid merkle proof\n     *\n     * @param proof A merkle proof for claiming\n     */\n    function claimMembership(bytes32[] calldata proof) external {\n        if (!_verifyProof(msg.sender, proof)) revert InvalidProof();\n\n        IDefinitelyMemberships(memberships).issueMembership(msg.sender);\n        emit MembershipClaimed(msg.sender);\n    }\n\n    /**\n     * @notice\n     * Allows someone to claim a DEF membership with a valid merkle proof to a vault address\n     * from delegate.cash.\n     *\n     * @dev\n     * The caller must be a delegate of `vault` for the main membership contract. The vault\n     * address should be in the proof, not the caller address.\n     *\n     * @param vault Cold wallet that delegated `msg.sender` on https://delegate.cash\n     * @param proof A merkle proof for claiming\n     */\n    function claimMembership(address vault, bytes32[] calldata proof) external {\n        if (\n            !IDelegationRegistry(delegationRegistry).checkDelegateForContract(\n                msg.sender,\n                vault,\n                memberships\n            )\n        ) revert NotDelegatedToClaim();\n        if (!_verifyProof(vault, proof)) revert InvalidProof();\n\n        IDefinitelyMemberships(memberships).issueMembership(vault);\n        emit MembershipClaimed(vault);\n    }\n\n    /**\n     * @notice\n     * Checks if an account can claim a membership with a given proof\n     *\n     * @param account The account to check\n     * @param proof The merkle proof to validate\n     */\n    function canClaimMembership(address account, bytes32[] calldata proof)\n        external\n        view\n        returns (bool)\n    {\n        return _verifyProof(account, proof);\n    }\n\n    /**\n     * @notice\n     * Internal function to verify a merkle proof for claiming\n     *\n     * @param account The account to verify the proof for\n     * @param proof The merkle proof to verify\n     */\n    function _verifyProof(address account, bytes32[] calldata proof) internal view returns (bool) {\n        return MerkleProof.verify(proof, claimableRoot, keccak256(abi.encodePacked(account)));\n    }\n\n    /* ------------------------------------------------------------------------\n       A D M I N\n    ------------------------------------------------------------------------ */\n\n    /**\n     * @notice\n     * Admin function to set the claimable merkle root\n     *\n     * @dev\n     * Emits the ClaimableRootUpdated event\n     *\n     * @param root The new claimable merkle root\n     */\n    function setClaimableRoot(bytes32 root) external onlyOwnerOrAdmin {\n        claimableRoot = root;\n        emit ClaimableRootUpdated(root);\n    }\n\n    /**\n     * @notice\n     * Admin function to set the delegate.cash registry address\n     *\n     * @dev\n     * Emits the ClaimableRootUpdated event\n     *\n     * @param registry The new registry address\n     */\n    function setDelegationRegistry(address registry) external onlyOwnerOrAdmin {\n        delegationRegistry = registry;\n        emit DelegationRegistryUpdated(registry);\n    }\n}\n"

    },

    "packages/contracts/src/interfaces/IDefinitelyMemberships.sol": {

      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.17;\n\ninterface IDefinitelyMemberships {\n    function issueMembership(address to) external;\n\n    function revokeMembership(uint256 id, bool addToDenyList) external;\n\n    function addAddressToDenyList(address account) external;\n\n    function removeAddressFromDenyList(address account) external;\n\n    function transferMembership(uint256 id, address to) external;\n\n    function overrideMetadataForToken(uint256 id, address metadata) external;\n\n    function resetMetadataForToken(uint256 id) external;\n\n    function isDefMember(address account) external view returns (bool);\n\n    function isOnDenyList(address account) external view returns (bool);\n\n    function memberSinceBlock(uint256 id) external view returns (uint256);\n\n    function defaultMetadataAddress() external view returns (address);\n\n    function metadataAddressForToken(uint256 id) external view returns (address);\n\n    function allowedMembershipIssuingContract(address addr) external view returns (bool);\n\n    function allowedMembershipRevokingContract(address addr) external view returns (bool);\n\n    function allowedMembershipTransferContract(address addr) external view returns (bool);\n}\n"

    },

    "packages/contracts/src/interfaces/IDelegationRegistry.sol": {

      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.17;\n\n/**\n * @title An immutable registry contract to be deployed as a standalone primitive\n * @dev See EIP-5639, new project launches can read previous cold wallet -> hot wallet delegations\n * from here and integrate those permissions into their flow\n */\ninterface IDelegationRegistry {\n    /// @notice Delegation type\n    enum DelegationType {\n        NONE,\n        ALL,\n        CONTRACT,\n        TOKEN\n    }\n\n    /// @notice Info about a single delegation, used for onchain enumeration\n    struct DelegationInfo {\n        DelegationType type_;\n        address vault;\n        address delegate;\n        address contract_;\n        uint256 tokenId;\n    }\n\n    /// @notice Info about a single contract-level delegation\n    struct ContractDelegation {\n        address contract_;\n        address delegate;\n    }\n\n    /// @notice Info about a single token-level delegation\n    struct TokenDelegation {\n        address contract_;\n        uint256 tokenId;\n        address delegate;\n    }\n\n    /// @notice Emitted when a user delegates their entire wallet\n    event DelegateForAll(address vault, address delegate, bool value);\n\n    /// @notice Emitted when a user delegates a specific contract\n    event DelegateForContract(address vault, address delegate, address contract_, bool value);\n\n    /// @notice Emitted when a user delegates a specific token\n    event DelegateForToken(\n        address vault,\n        address delegate,\n        address contract_,\n        uint256 tokenId,\n        bool value\n    );\n\n    /// @notice Emitted when a user revokes all delegations\n    event RevokeAllDelegates(address vault);\n\n    /// @notice Emitted when a user revoes all delegations for a given delegate\n    event RevokeDelegate(address vault, address delegate);\n\n    /**\n     * -----------  WRITE -----------\n     */\n\n    /**\n     * @notice Allow the delegate to act on your behalf for all contracts\n     * @param delegate The hotwallet to act on your behalf\n     * @param value Whether to enable or disable delegation for this address, true for setting and false for revoking\n     */\n    function delegateForAll(address delegate, bool value) external;\n\n    /**\n     * @notice Allow the delegate to act on your behalf for a specific contract\n     * @param delegate The hotwallet to act on your behalf\n     * @param contract_ The address for the contract you're delegating\n     * @param value Whether to enable or disable delegation for this address, true for setting and false for revoking\n     */\n    function delegateForContract(\n        address delegate,\n        address contract_,\n        bool value\n    ) external;\n\n    /**\n     * @notice Allow the delegate to act on your behalf for a specific token\n     * @param delegate The hotwallet to act on your behalf\n     * @param contract_ The address for the contract you're delegating\n     * @param tokenId The token id for the token you're delegating\n     * @param value Whether to enable or disable delegation for this address, true for setting and false for revoking\n     */\n    function delegateForToken(\n        address delegate,\n        address contract_,\n        uint256 tokenId,\n        bool value\n    ) external;\n\n    /**\n     * @notice Revoke all delegates\n     */\n    function revokeAllDelegates() external;\n\n    /**\n     * @notice Revoke a specific delegate for all their permissions\n     * @param delegate The hotwallet to revoke\n     */\n    function revokeDelegate(address delegate) external;\n\n    /**\n     * @notice Remove yourself as a delegate for a specific vault\n     * @param vault The vault which delegated to the msg.sender, and should be removed\n     */\n    function revokeSelf(address vault) external;\n\n    /**\n     * -----------  READ -----------\n     */\n\n    /**\n     * @notice Returns all active delegations a given delegate is able to claim on behalf of\n     * @param delegate The delegate that you would like to retrieve delegations for\n     * @return info Array of DelegationInfo structs\n     */\n    function getDelegationsByDelegate(address delegate)\n        external\n        view\n        returns (DelegationInfo[] memory);\n\n    /**\n     * @notice Returns an array of wallet-level delegates for a given vault\n     * @param vault The cold wallet who issued the delegation\n     * @return addresses Array of wallet-level delegates for a given vault\n     */\n    function getDelegatesForAll(address vault) external view returns (address[] memory);\n\n    /**\n     * @notice Returns an array of contract-level delegates for a given vault and contract\n     * @param vault The cold wallet who issued the delegation\n     * @param contract_ The address for the contract you're delegating\n     * @return addresses Array of contract-level delegates for a given vault and contract\n     */\n    function getDelegatesForContract(address vault, address contract_)\n        external\n        view\n        returns (address[] memory);\n\n    /**\n     * @notice Returns an array of contract-level delegates for a given vault's token\n     * @param vault The cold wallet who issued the delegation\n     * @param contract_ The address for the contract holding the token\n     * @param tokenId The token id for the token you're delegating\n     * @return addresses Array of contract-level delegates for a given vault's token\n     */\n    function getDelegatesForToken(\n        address vault,\n        address contract_,\n        uint256 tokenId\n    ) external view returns (address[] memory);\n\n    /**\n     * @notice Returns all contract-level delegations for a given vault\n     * @param vault The cold wallet who issued the delegations\n     * @return delegations Array of ContractDelegation structs\n     */\n    function getContractLevelDelegations(address vault)\n        external\n        view\n        returns (ContractDelegation[] memory delegations);\n\n    /**\n     * @notice Returns all token-level delegations for a given vault\n     * @param vault The cold wallet who issued the delegations\n     * @return delegations Array of TokenDelegation structs\n     */\n    function getTokenLevelDelegations(address vault)\n        external\n        view\n        returns (TokenDelegation[] memory delegations);\n\n    /**\n     * @notice Returns true if the address is delegated to act on the entire vault\n     * @param delegate The hotwallet to act on your behalf\n     * @param vault The cold wallet who issued the delegation\n     */\n    function checkDelegateForAll(address delegate, address vault) external view returns (bool);\n\n    /**\n     * @notice Returns true if the address is delegated to act on your behalf for a token contract or an entire vault\n     * @param delegate The hotwallet to act on your behalf\n     * @param contract_ The address for the contract you're delegating\n     * @param vault The cold wallet who issued the delegation\n     */\n    function checkDelegateForContract(\n        address delegate,\n        address vault,\n        address contract_\n    ) external view returns (bool);\n\n    /**\n     * @notice Returns true if the address is delegated to act on your behalf for a specific token, the token's contract or an entire vault\n     * @param delegate The hotwallet to act on your behalf\n     * @param contract_ The address for the contract you're delegating\n     * @param tokenId The token id for the token you're delegating\n     * @param vault The cold wallet who issued the delegation\n     */\n    function checkDelegateForToken(\n        address delegate,\n        address vault,\n        address contract_,\n        uint256 tokenId\n    ) external view returns (bool);\n}\n"

    },

    "packages/contracts/src/lib/Auth.sol": {

      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.17;\n\n/**\n * @author DEF DAO\n * @title  Simple owner and admin authentication\n * @notice Allows the management of a contract by using simple ownership and admin modifiers.\n */\nabstract contract Auth {\n    /* ------------------------------------------------------------------------\n       S T O R A G E\n    ------------------------------------------------------------------------ */\n\n    /// @notice Current owner of the contract\n    address public owner;\n\n    /// @notice Current admins of the contract\n    mapping(address => bool) public admins;\n\n    /* ------------------------------------------------------------------------\n       E V E N T S\n    ------------------------------------------------------------------------ */\n\n    /**\n     * @notice When the contract owner is updated\n     * @param user The account that updated the new owner\n     * @param newOwner The new owner of the contract\n     */\n    event OwnerUpdated(address indexed user, address indexed newOwner);\n\n    /**\n     * @notice When an admin is added to the contract\n     * @param user The account that added the new admin\n     * @param newAdmin The admin that was added\n     */\n    event AdminAdded(address indexed user, address indexed newAdmin);\n\n    /**\n     * @notice When an admin is removed from the contract\n     * @param user The account that removed an admin\n     * @param prevAdmin The admin that got removed\n     */\n    event AdminRemoved(address indexed user, address indexed prevAdmin);\n\n    /* ------------------------------------------------------------------------\n       M O D I F I E R S\n    ------------------------------------------------------------------------ */\n\n    /**\n     * @dev Only the owner can call\n     */\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n        _;\n    }\n\n    /**\n     * @dev Only an admin can call\n     */\n    modifier onlyAdmin() {\n        require(admins[msg.sender], \"UNAUTHORIZED\");\n        _;\n    }\n\n    /**\n     * @dev Only the owner or an admin can call\n     */\n    modifier onlyOwnerOrAdmin() {\n        require((msg.sender == owner || admins[msg.sender]), \"UNAUTHORIZED\");\n        _;\n    }\n\n    /* ------------------------------------------------------------------------\n       I N I T\n    ------------------------------------------------------------------------ */\n\n    /**\n     * @dev Sets the initial owner and a first admin upon creation.\n     * @param owner_ The initial owner of the contract\n     */\n    constructor(address owner_) {\n        owner = owner_;\n        emit OwnerUpdated(address(0), owner_);\n    }\n\n    /* ------------------------------------------------------------------------\n       A D M I N\n    ------------------------------------------------------------------------ */\n\n    /**\n     * @notice Transfers ownership of the contract to `newOwner`\n     * @dev Can only be called by the current owner or an admin\n     * @param newOwner The new owner of the contract\n     */\n    function setOwner(address newOwner) public virtual onlyOwnerOrAdmin {\n        owner = newOwner;\n        emit OwnerUpdated(msg.sender, newOwner);\n    }\n\n    /**\n     * @notice Adds `newAdmin` as an admin of the contract\n     * @dev Can only be called by the current owner or an admin\n     * @param newAdmin A new admin of the contract\n     */\n    function addAdmin(address newAdmin) public virtual onlyOwnerOrAdmin {\n        admins[newAdmin] = true;\n        emit AdminAdded(msg.sender, newAdmin);\n    }\n\n    /**\n     * @notice Removes `prevAdmin` as an admin of the contract\n     * @dev Can only be called by the current owner or an admin\n     * @param prevAdmin The admin to remove\n     */\n    function removeAdmin(address prevAdmin) public virtual onlyOwnerOrAdmin {\n        admins[prevAdmin] = false;\n        emit AdminRemoved(msg.sender, prevAdmin);\n    }\n}\n"

    }

  },

  "settings": {

    "remappings": [

      "def/=packages/contracts/src/",

      "ds-test/=packages/contracts/lib/ds-test/src/",

      "forge-std/=packages/contracts/lib/forge-std/src/",

      "murky/=packages/contracts/lib/murky/src/",

      "openzeppelin-contracts/=packages/contracts/lib/openzeppelin-contracts/",

      "openzeppelin/=packages/contracts/lib/openzeppelin-contracts/",

      "solmate/=packages/contracts/lib/solmate/src/"

    ],

    "optimizer": {

      "enabled": true,

      "runs": 200

    },

    "metadata": {

      "bytecodeHash": "none"

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "evmVersion": "london",

    "libraries": {}

  }

}}