// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.20;



import "@openzeppelin/contracts/access/Ownable.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "@openzeppelin/contracts/utils/Context.sol";

import "@openzeppelin/contracts/utils/math/SafeMath.sol";

import "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol";

import "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol";

import "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";



bytes32 constant INIT_CODE_HASH = hex"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f";

address constant FACTORY = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;



library UniswapV2Library {

    function pairFor(

        address tokenA,

        address tokenB

    ) internal pure returns (address pair) {

        (address token0, address token1) = sortTokens(tokenA, tokenB);

        pair = address(

            uint160(

                uint256(

                    keccak256(

                        abi.encodePacked(

                            hex"ff",

                            FACTORY,

                            keccak256(abi.encodePacked(token0, token1)),

                            INIT_CODE_HASH

                        )

                    )

                )

            )

        );

    }



    function sortTokens(

        address tokenA,

        address tokenB

    ) internal pure returns (address token0, address token1) {

        (token0, token1) = tokenA < tokenB

            ? (tokenA, tokenB)

            : (tokenB, tokenA);

    }

}



contract BarcodeToken is Context, IERC20, Ownable {

    using SafeMath for uint256;

    mapping(address => uint256) private _balances;

    mapping(address => mapping(address => uint256)) private _allowances;

    mapping(address => bool) private _isExcludedFromFee;

    mapping(address => bool) private bots;

    mapping(address => uint256) private _holderLastTransferTimestamp;

    bool public transferDelayEnabled = true;

    address payable private _taxWallet;



    uint256 private _initialBuyTax;

    uint256 private _initialSellTax;

    uint256 private _finalBuyTax;

    uint256 private _finalSellTax;

    uint256 private _reduceBuyTaxAt = 25;

    uint256 private _reduceSellTaxAt = 25;

    uint256 private _preventSwapBefore = 25;

    uint256 private _buyCount;



    uint8 private constant _decimals = 18;

    uint256 private constant _tTotal = 10_000_000 * 10 ** _decimals;

    string private constant _name = unicode"II|I|IIIIII|IIIII|I|IIIIII|III";

    string private constant _symbol = unicode"BARCODE";

    uint256 public _maxTxAmount = 200_000 * 10 ** _decimals;

    uint256 public _maxWalletSize = 200_000 * 10 ** _decimals;

    uint256 public _taxSwapThreshold = 20_000 * 10 ** _decimals;

    uint256 public _maxTaxSwap = 50_000 * 10 ** _decimals;



    IUniswapV2Router02 private constant UNISWAP_V2_ROUTER =

        IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);



    address private immutable UNISWAP_V2_PAIR;

    bool private tradingOpen;

    bool private inSwap = false;

    bool private swapEnabled = false;



    event MaxTxAmountUpdated(uint256 _maxTxAmount);



    modifier lockTheSwap() {

        inSwap = true;

        _;

        inSwap = false;

    }



    constructor() {

        _taxWallet = payable(msg.sender);

        _isExcludedFromFee[owner()] = true;

        _isExcludedFromFee[address(this)] = true;

        _isExcludedFromFee[_taxWallet] = true;



        UNISWAP_V2_PAIR = UniswapV2Library.pairFor(

            address(this),

            UNISWAP_V2_ROUTER.WETH()

        );



        _balances[_msgSender()] = _tTotal;

        emit Transfer(address(0), _msgSender(), _tTotal);

    }



    function name() public pure returns (string memory) {

        return _name;

    }



    function symbol() public pure returns (string memory) {

        return _symbol;

    }



    function decimals() public pure returns (uint8) {

        return _decimals;

    }



    function totalSupply() public pure override returns (uint256) {

        return _tTotal;

    }



    function balanceOf(address account) public view override returns (uint256) {

        return _balances[account];

    }



    function transfer(

        address recipient,

        uint256 amount

    ) public override returns (bool) {

        _transfer(_msgSender(), recipient, amount);

        return true;

    }



    function allowance(

        address owner,

        address spender

    ) public view override returns (uint256) {

        return _allowances[owner][spender];

    }



    function approve(

        address spender,

        uint256 amount

    ) public override returns (bool) {

        _approve(_msgSender(), spender, amount);

        return true;

    }



    function transferFrom(

        address sender,

        address recipient,

        uint256 amount

    ) public override returns (bool) {

        _transfer(sender, recipient, amount);

        _approve(

            sender,

            _msgSender(),

            _allowances[sender][_msgSender()].sub(

                amount,

                "ERC20: transfer amount exceeds allowance"

            )

        );

        return true;

    }



    function _approve(address owner, address spender, uint256 amount) private {

        require(owner != address(0), "ERC20: approve from the zero address");

        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;

        emit Approval(owner, spender, amount);

    }



    function _transfer(address from, address to, uint256 amount) private {

        require(from != address(0), "ERC20: transfer from the zero address");

        require(to != address(0), "ERC20: transfer to the zero address");

        require(amount > 0, "Transfer amount must be greater than zero");

        uint256 taxAmount = 0;

        if (from != owner() && to != owner()) {

            taxAmount = amount

                .mul(

                    (_buyCount > _reduceBuyTaxAt)

                        ? _finalBuyTax

                        : _initialBuyTax

                )

                .div(100);



            if (transferDelayEnabled) {

                if (to != address(UNISWAP_V2_ROUTER) && to != UNISWAP_V2_PAIR) {

                    require(

                        _holderLastTransferTimestamp[tx.origin] < block.number,

                        "_transfer:: Transfer Delay enabled.  Only one purchase per block allowed."

                    );

                    _holderLastTransferTimestamp[tx.origin] = block.number;

                }

            }



            if (

                from == UNISWAP_V2_PAIR &&

                to != address(UNISWAP_V2_ROUTER) &&

                !_isExcludedFromFee[to]

            ) {

                require(amount <= _maxTxAmount, "Exceeds the _maxTxAmount.");

                require(

                    balanceOf(to) + amount <= _maxWalletSize,

                    "Exceeds the maxWalletSize."

                );

                if (_buyCount <= 100) {

                    _buyCount++;

                }

            }



            if (to == UNISWAP_V2_PAIR && from != address(this)) {

                taxAmount = amount

                    .mul(

                        (_buyCount > _reduceSellTaxAt)

                            ? _finalSellTax

                            : _initialSellTax

                    )

                    .div(100);

            }



            uint256 contractTokenBalance = balanceOf(address(this));

            if (

                !inSwap &&

                to == UNISWAP_V2_PAIR &&

                swapEnabled &&

                contractTokenBalance > _taxSwapThreshold &&

                _buyCount > _preventSwapBefore

            ) {

                swapTokensForEth(

                    min(amount, min(contractTokenBalance, _maxTaxSwap))

                );

                uint256 contractETHBalance = address(this).balance;

                if (contractETHBalance > 50000000000000000) {

                    sendETHToFee(address(this).balance);

                }

            }

        }



        if (taxAmount > 0) {

            _balances[address(this)] = _balances[address(this)].add(taxAmount);

            emit Transfer(from, address(this), taxAmount);

        }

        _balances[from] = _balances[from].sub(amount);

        _balances[to] = _balances[to].add(amount.sub(taxAmount));

        emit Transfer(from, to, amount.sub(taxAmount));

    }



    function min(uint256 a, uint256 b) private pure returns (uint256) {

        return (a > b) ? b : a;

    }



    function swapTokensForEth(uint256 tokenAmount) private lockTheSwap {

        address[] memory path = new address[](2);

        path[0] = address(this);

        path[1] = UNISWAP_V2_ROUTER.WETH();

        UNISWAP_V2_ROUTER.swapExactTokensForETHSupportingFeeOnTransferTokens(

            tokenAmount,

            0,

            path,

            _taxWallet,

            block.timestamp

        );

    }



    function removeLimits() external onlyOwner {

        _maxTxAmount = _tTotal;

        _maxWalletSize = _tTotal;

        transferDelayEnabled = false;

        emit MaxTxAmountUpdated(_tTotal);

    }



    function sendETHToFee(uint256 amount) private {

        _taxWallet.transfer(amount);

    }



    function openTrading() external payable onlyOwner {

        require(!tradingOpen, "trading is already open");

        _approve(address(this), address(UNISWAP_V2_ROUTER), type(uint256).max);

        UNISWAP_V2_ROUTER.addLiquidityETH{value: address(this).balance}(

            address(this),

            balanceOf(address(this)),

            0,

            0,

            owner(),

            block.timestamp

        );



        _initialBuyTax = 25;

        _initialSellTax = 25;

        _finalBuyTax = 2;

        _finalSellTax = 2;

        swapEnabled = true;

        tradingOpen = true;

    }



    receive() external payable {}



    function manualSwap() external {

        require(_msgSender() == _taxWallet);

        uint256 tokenBalance = balanceOf(address(this));

        if (tokenBalance > 0) {

            swapTokensForEth(tokenBalance);

        }

        uint256 ethBalance = address(this).balance;

        if (ethBalance > 0) {

            sendETHToFee(ethBalance);

        }

    }

}