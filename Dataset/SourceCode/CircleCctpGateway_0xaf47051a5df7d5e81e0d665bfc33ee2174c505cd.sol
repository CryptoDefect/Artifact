{{

  "language": "Solidity",

  "sources": {

    "@openzeppelin/contracts/access/Ownable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"

    },

    "@openzeppelin/contracts/security/Pausable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"

    },

    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/Context.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"

    },

    "contracts/BalanceManagement.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.19;\n\nimport { ITokenBalance } from './interfaces/ITokenBalance.sol';\nimport { ManagerRole } from './roles/ManagerRole.sol';\nimport './helpers/TransferHelper.sol' as TransferHelper;\nimport './Constants.sol' as Constants;\n\n/**\n * @title BalanceManagement\n * @notice Base contract for the withdrawal of tokens, except for reserved ones\n */\nabstract contract BalanceManagement is ManagerRole {\n    /**\n     * @notice Emitted when the specified token is reserved\n     */\n    error ReservedTokenError();\n\n    /**\n     * @notice Performs the withdrawal of tokens, except for reserved ones\n     * @dev Use the \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\" address for the native token\n     * @param _tokenAddress The address of the token\n     * @param _tokenAmount The amount of the token\n     */\n    function cleanup(address _tokenAddress, uint256 _tokenAmount) external onlyManager {\n        if (isReservedToken(_tokenAddress)) {\n            revert ReservedTokenError();\n        }\n\n        if (_tokenAddress == Constants.NATIVE_TOKEN_ADDRESS) {\n            TransferHelper.safeTransferNative(msg.sender, _tokenAmount);\n        } else {\n            TransferHelper.safeTransfer(_tokenAddress, msg.sender, _tokenAmount);\n        }\n    }\n\n    /**\n     * @notice Getter of the token balance of the current contract\n     * @dev Use the \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\" address for the native token\n     * @param _tokenAddress The address of the token\n     * @return The token balance of the current contract\n     */\n    function tokenBalance(address _tokenAddress) public view returns (uint256) {\n        if (_tokenAddress == Constants.NATIVE_TOKEN_ADDRESS) {\n            return address(this).balance;\n        } else {\n            return ITokenBalance(_tokenAddress).balanceOf(address(this));\n        }\n    }\n\n    /**\n     * @notice Getter of the reserved token flag\n     * @dev Override to add reserved token addresses\n     * @param _tokenAddress The address of the token\n     * @return The reserved token flag\n     */\n    function isReservedToken(address _tokenAddress) public view virtual returns (bool) {\n        // The function returns false by default.\n        // The explicit return statement is omitted to avoid the unused parameter warning.\n        // See https://github.com/ethereum/solidity/issues/5295\n    }\n}\n"

    },

    "contracts/CallerGuard.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.19;\n\nimport { ManagerRole } from './roles/ManagerRole.sol';\nimport './helpers/AddressHelper.sol' as AddressHelper;\nimport './Constants.sol' as Constants;\nimport './DataStructures.sol' as DataStructures;\n\n/**\n * @title CallerGuard\n * @notice Base contract to control access from other contracts\n */\nabstract contract CallerGuard is ManagerRole {\n    /**\n     * @dev Caller guard mode enumeration\n     */\n    enum CallerGuardMode {\n        ContractForbidden,\n        ContractList,\n        ContractAllowed\n    }\n\n    /**\n     * @dev Caller guard mode value\n     */\n    CallerGuardMode public callerGuardMode = CallerGuardMode.ContractForbidden;\n\n    /**\n     * @dev Registered contract list for \"ContractList\" mode\n     */\n    address[] public listedCallerGuardContractList;\n\n    /**\n     * @dev Registered contract list indices for \"ContractList\" mode\n     */\n    mapping(address /*account*/ => DataStructures.OptionalValue /*index*/)\n        public listedCallerGuardContractIndexMap;\n\n    /**\n     * @notice Emitted when the caller guard mode is set\n     * @param callerGuardMode The caller guard mode\n     */\n    event SetCallerGuardMode(CallerGuardMode indexed callerGuardMode);\n\n    /**\n     * @notice Emitted when a registered contract for \"ContractList\" mode is added or removed\n     * @param contractAddress The contract address\n     * @param isListed The registered contract list inclusion flag\n     */\n    event SetListedCallerGuardContract(address indexed contractAddress, bool indexed isListed);\n\n    /**\n     * @notice Emitted when the caller is not allowed to perform the intended action\n     */\n    error CallerGuardError(address caller);\n\n    /**\n     * @dev Modifier to check if the caller is allowed to perform the intended action\n     */\n    modifier checkCaller() {\n        if (msg.sender != tx.origin) {\n            bool condition = (callerGuardMode == CallerGuardMode.ContractAllowed ||\n                (callerGuardMode == CallerGuardMode.ContractList &&\n                    isListedCallerGuardContract(msg.sender)));\n\n            if (!condition) {\n                revert CallerGuardError(msg.sender);\n            }\n        }\n\n        _;\n    }\n\n    /**\n     * @notice Sets the caller guard mode\n     * @param _callerGuardMode The caller guard mode\n     */\n    function setCallerGuardMode(CallerGuardMode _callerGuardMode) external onlyManager {\n        callerGuardMode = _callerGuardMode;\n\n        emit SetCallerGuardMode(_callerGuardMode);\n    }\n\n    /**\n     * @notice Updates the list of registered contracts for the \"ContractList\" mode\n     * @param _items The addresses and flags for the contracts\n     */\n    function setListedCallerGuardContracts(\n        DataStructures.AccountToFlag[] calldata _items\n    ) external onlyManager {\n        for (uint256 index; index < _items.length; index++) {\n            DataStructures.AccountToFlag calldata item = _items[index];\n\n            if (item.flag) {\n                AddressHelper.requireContract(item.account);\n            }\n\n            DataStructures.uniqueAddressListUpdate(\n                listedCallerGuardContractList,\n                listedCallerGuardContractIndexMap,\n                item.account,\n                item.flag,\n                Constants.LIST_SIZE_LIMIT_DEFAULT\n            );\n\n            emit SetListedCallerGuardContract(item.account, item.flag);\n        }\n    }\n\n    /**\n     * @notice Getter of the registered contract count\n     * @return The registered contract count\n     */\n    function listedCallerGuardContractCount() external view returns (uint256) {\n        return listedCallerGuardContractList.length;\n    }\n\n    /**\n     * @notice Getter of the complete list of registered contracts\n     * @return The complete list of registered contracts\n     */\n    function fullListedCallerGuardContractList() external view returns (address[] memory) {\n        return listedCallerGuardContractList;\n    }\n\n    /**\n     * @notice Getter of a listed contract flag\n     * @param _account The contract address\n     * @return The listed contract flag\n     */\n    function isListedCallerGuardContract(address _account) public view returns (bool) {\n        return listedCallerGuardContractIndexMap[_account].isSet;\n    }\n}\n"

    },

    "contracts/Constants.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.19;\n\n/**\n * @dev The default token decimals value\n */\nuint256 constant DECIMALS_DEFAULT = 18;\n\n/**\n * @dev The maximum uint256 value for swap amount limit settings\n */\nuint256 constant INFINITY = type(uint256).max;\n\n/**\n * @dev The default limit of account list size\n */\nuint256 constant LIST_SIZE_LIMIT_DEFAULT = 100;\n\n/**\n * @dev The limit of swap router list size\n */\nuint256 constant LIST_SIZE_LIMIT_ROUTERS = 200;\n\n/**\n * @dev The factor for percentage settings. Example: 100 is 0.1%\n */\nuint256 constant MILLIPERCENT_FACTOR = 100_000;\n\n/**\n * @dev The de facto standard address to denote the native token\n */\naddress constant NATIVE_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n"

    },

    "contracts/crosschain/circle-cctp/CircleCctpGateway.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.19;\n\nimport { IActionDataStructures } from '../../interfaces/IActionDataStructures.sol';\nimport { IMessageHandler } from './interfaces/IMessageHandler.sol';\nimport { IMessageTransmitter } from './interfaces/IMessageTransmitter.sol';\nimport { ITokenBalance } from '../../interfaces/ITokenBalance.sol';\nimport { ITokenMessenger } from './interfaces/ITokenMessenger.sol';\nimport { IVault } from '../../interfaces/IVault.sol';\nimport { AssetSpenderRole } from '../../roles/AssetSpenderRole.sol';\nimport { CallerGuard } from '../../CallerGuard.sol';\nimport { GatewayBase } from '../GatewayBase.sol';\nimport { SystemVersionId } from '../../SystemVersionId.sol';\nimport '../../helpers/GasReserveHelper.sol' as GasReserveHelper;\nimport '../../helpers/TransferHelper.sol' as TransferHelper;\nimport '../../DataStructures.sol' as DataStructures;\n\n/**\n * @title CircleCctpGateway\n * @notice The contract implementing the cross-chain messaging logic specific to Circle CCTP\n */\ncontract CircleCctpGateway is\n    SystemVersionId,\n    GatewayBase,\n    CallerGuard,\n    AssetSpenderRole,\n    IActionDataStructures,\n    IVault,\n    IMessageHandler\n{\n    /**\n     * @notice Chain domain structure\n     * @dev See https://developers.circle.com/stablecoin/docs/cctp-technical-reference#domain\n     * @param chainId The EVM chain ID\n     * @param domain The CCTP domain\n     */\n    struct ChainDomain {\n        uint256 chainId;\n        uint32 domain;\n    }\n\n    /**\n     * @notice Variables for the sendMessage function\n     * @param peerAddressBytes32 The peer address as bytes32\n     * @param targetDomain The target domain\n     * @param assetMessageNonce The asset message nonce\n     * @param dataMessageNonce The data message nonce\n     */\n    struct SendMessageVariables {\n        bytes32 peerAddressBytes32;\n        uint32 targetDomain;\n        uint64 assetMessageNonce;\n        uint64 dataMessageNonce;\n        bool useTargetExecutor;\n    }\n\n    /**\n     * @notice Target data message context structure\n     * @param sourceDomain Source domain\n     * @param sender Sender\n     * @param messageBody Message body\n     */\n    struct TargetDataMessageContext {\n        uint32 sourceDomain;\n        bytes32 sender;\n        bytes messageBody;\n    }\n\n    /**\n     * @dev cctpTokenMessenger The CCTP token messenger address\n     */\n    ITokenMessenger public immutable cctpTokenMessenger;\n\n    /**\n     * @dev cctpMessageTransmitter The CCTP message transmitter address\n     */\n    IMessageTransmitter public immutable cctpMessageTransmitter;\n\n    /**\n     * @dev asset The USDC token address\n     */\n    address public immutable asset;\n\n    /**\n     * @dev Chain id to CCTP domain\n     */\n    mapping(uint256 /*chainId*/ => DataStructures.OptionalValue /*domain*/) public chainIdToDomain;\n\n    /**\n     * @dev CCTP domain to chain id\n     */\n    mapping(uint32 /*domain*/ => uint256 /*chainId*/) public domainToChainId;\n\n    /**\n     * @dev The state of variable token and balance actions\n     */\n    bool public variableRepaymentEnabled;\n\n    /**\n     * @dev The address of the processing fee collector\n     */\n    address public processingFeeCollector;\n\n    /**\n     * @dev The address of the target executor\n     */\n    address public targetExecutor;\n\n    TargetDataMessageContext private targetDataMessageContext;\n\n    /**\n     * @notice Emitted when a chain ID and CCTP domain pair is added or updated\n     * @param chainId The chain ID\n     * @param domain The CCTP domain\n     */\n    event SetChainDomain(uint256 indexed chainId, uint32 indexed domain);\n\n    /**\n     * @notice Emitted when a chain ID and CCTP domain pair is removed\n     * @param chainId The chain ID\n     * @param domain The CCTP domain\n     */\n    event RemoveChainDomain(uint256 indexed chainId, uint32 indexed domain);\n\n    /**\n     * @notice Emitted when the state of variable token and balance actions is updated\n     * @param variableRepaymentEnabled The state of variable token and balance actions\n     */\n    event SetVariableRepaymentEnabled(bool indexed variableRepaymentEnabled);\n\n    /**\n     * @notice Emitted when the address of the processing fee collector is set\n     * @param processingFeeCollector The address of the processing fee collector\n     */\n    event SetProcessingFeeCollector(address indexed processingFeeCollector);\n\n    /**\n     * @notice Emitted when the address of the target executor is set\n     * @param targetExecutor The address of the target executor\n     */\n    event SetTargetExecutor(address indexed targetExecutor);\n\n    /**\n     * @notice Emitted when the call to the CCTP receiveMessage fails\n     * @param sourceChainId The ID of the message source chain\n     */\n    event TargetCctpMessageFailure(uint256 indexed sourceChainId);\n\n    /**\n     * @notice Emitted when a gateway action is performed on the source chain\n     * @param actionId The ID of the action\n     * @param targetChainId The ID of the target chain\n     * @param useTargetExecutor The flag to use the target executor\n     * @param assetMessageNonce The nonce of the CCTP asset message\n     * @param dataMessageNonce The nonce of the CCTP data message\n     * @param assetAmount The amount of the asset used for the action\n     * @param processingFee The amount of the processing fee\n     * @param processingGas The amount of the processing gas\n     * @param timestamp The timestamp of the action (in seconds)\n     */\n    event GatewayActionSource(\n        uint256 indexed actionId,\n        uint256 indexed targetChainId,\n        bool indexed useTargetExecutor,\n        uint64 assetMessageNonce,\n        uint64 dataMessageNonce,\n        uint256 assetAmount,\n        uint256 processingFee,\n        uint256 processingGas,\n        uint256 timestamp\n    );\n\n    /**\n     * @notice Emitted when the domain for the specified chain is not set\n     */\n    error DomainNotSetError();\n\n    /**\n     * @notice Emitted when the caller is not an allowed executor\n     */\n    error ExecutorError();\n\n    /**\n     * @notice Emitted when the provided call value is not sufficient for the message processing\n     */\n    error ProcessingFeeError();\n\n    /**\n     * @notice Emitted when a variable token or balance action is not allowed\n     */\n    error VariableRepaymentNotEnabledError();\n\n    /**\n     * @notice Emitted when a variable token action is attempted while the token address is not set\n     */\n    error VariableTokenNotSetError();\n\n    /**\n     * @notice Emitted when the context vault is not the current contract\n     */\n    error OnlyCurrentVaultError();\n\n    /**\n     * @notice Emitted when the caller is not the CCTP message transmitter\n     */\n    error OnlyMessageTransmitterError();\n\n    /**\n     * @notice Emitted when the target chain gateway client contract is not set\n     */\n    error TargetClientNotSetError();\n\n    /**\n     * @notice Emitted when the asset message receiving fails\n     */\n    error AssetMessageError();\n\n    /**\n     * @notice Emitted when the data message receiving fails\n     */\n    error DataMessageError();\n\n    /**\n     * @notice Emitted when the message source address does not match the registered peer gateway on the target chain\n     * @param sourceChainId The ID of the message source chain\n     * @param fromAddress The address of the message source\n     */\n    error TargetFromAddressError(uint256 sourceChainId, address fromAddress);\n\n    /**\n     * @notice Emitted when the caller is not allowed to perform the action on the target chain\n     */\n    error TargetCallerError();\n\n    /**\n     * @notice Emitted when the swap amount does not match the received asset amount\n     */\n    error TargetAssetAmountMismatchError();\n\n    /**\n     * @notice Emitted when the gas reserve on the target chain does not allow further action processing\n     */\n    error TargetGasReserveError();\n\n    /**\n     * @dev Modifier to check if the caller is the CCTP message transmitter\n     */\n    modifier onlyMessageTransmitter() {\n        if (msg.sender != address(cctpMessageTransmitter)) {\n            revert OnlyMessageTransmitterError();\n        }\n\n        _;\n    }\n\n    /**\n     * @notice Deploys the CircleCctpGateway contract\n     * @param _cctpTokenMessenger The CCTP token messenger address\n     * @param _cctpMessageTransmitter The CCTP message transmitter address\n     * @param _chainDomains The list of registered chain domains\n     * @param _asset The USDC token address\n     * @param _variableRepaymentEnabled The state of variable token and balance actions\n     * @param _targetGasReserve The initial gas reserve value for target chain action processing\n     * @param _processingFeeCollector The initial address of the processing fee collector\n     * @param _targetExecutor The address of the target executor\n     * @param _owner The address of the initial owner of the contract\n     * @param _managers The addresses of initial managers of the contract\n     * @param _addOwnerToManagers The flag to optionally add the owner to the list of managers\n     */\n    constructor(\n        ITokenMessenger _cctpTokenMessenger,\n        IMessageTransmitter _cctpMessageTransmitter,\n        ChainDomain[] memory _chainDomains,\n        address _asset,\n        bool _variableRepaymentEnabled,\n        uint256 _targetGasReserve,\n        address _processingFeeCollector,\n        address _targetExecutor,\n        address _owner,\n        address[] memory _managers,\n        bool _addOwnerToManagers\n    ) {\n        cctpTokenMessenger = _cctpTokenMessenger;\n        cctpMessageTransmitter = _cctpMessageTransmitter;\n\n        for (uint256 index; index < _chainDomains.length; index++) {\n            ChainDomain memory chainDomain = _chainDomains[index];\n\n            _setChainDomain(chainDomain.chainId, chainDomain.domain);\n        }\n\n        asset = _asset;\n\n        _setVariableRepaymentEnabled(_variableRepaymentEnabled);\n\n        _setTargetGasReserve(_targetGasReserve);\n\n        _setProcessingFeeCollector(_processingFeeCollector);\n        _setTargetExecutor(_targetExecutor);\n\n        _initRoles(_owner, _managers, _addOwnerToManagers);\n    }\n\n    /**\n     * @notice The standard \"receive\" function\n     * @dev Is payable to allow receiving native token funds from the cross-chain endpoint\n     */\n    receive() external payable {}\n\n    /**\n     * @notice Updates the Asset Spender role status for the account\n     * @param _account The account address\n     * @param _value The Asset Spender role status flag\n     */\n    function setAssetSpender(address _account, bool _value) external onlyManager {\n        _setAssetSpender(_account, _value);\n    }\n\n    /**\n     * @notice Adds or updates registered chain domains (CCTP-specific)\n     * @param _chainDomains The list of registered chain domains\n     */\n    function setChainDomains(ChainDomain[] calldata _chainDomains) external onlyManager {\n        for (uint256 index; index < _chainDomains.length; index++) {\n            ChainDomain calldata chainDomain = _chainDomains[index];\n\n            _setChainDomain(chainDomain.chainId, chainDomain.domain);\n        }\n    }\n\n    /**\n     * @notice Removes registered chain domains (CCTP-specific)\n     * @param _chainIds The list of EVM chain IDs\n     */\n    function removeChainDomains(uint256[] calldata _chainIds) external onlyManager {\n        for (uint256 index; index < _chainIds.length; index++) {\n            uint256 chainId = _chainIds[index];\n\n            _removeChainDomain(chainId);\n        }\n    }\n\n    /**\n     * @notice Sets the address of the processing fee collector\n     * @param _processingFeeCollector The address of the processing fee collector\n     */\n    function setProcessingFeeCollector(address _processingFeeCollector) external onlyManager {\n        _setProcessingFeeCollector(_processingFeeCollector);\n    }\n\n    /**\n     * @notice Sets the address of the target executor\n     * @param _targetExecutor The address of the target executor\n     */\n    function setTargetExecutor(address _targetExecutor) external onlyManager {\n        _setTargetExecutor(_targetExecutor);\n    }\n\n    /**\n     * @notice Send a cross-chain message\n     * @param _targetChainId The message target chain ID\n     * @param _message The message content\n     * @param _settings The gateway-specific settings\n     */\n    function sendMessage(\n        uint256 _targetChainId,\n        bytes calldata _message,\n        bytes calldata _settings\n    ) external payable onlyClient whenNotPaused {\n        (IVault vault, uint256 assetAmount) = client.getSourceGatewayContext();\n\n        if (address(vault) != address(this)) {\n            revert OnlyCurrentVaultError();\n        }\n\n        SendMessageVariables memory variables = _prepareSendMessageVariables();\n\n        variables.peerAddressBytes32 = _addressToBytes32(_checkPeerAddress(_targetChainId));\n        variables.targetDomain = _checkTargetDomain(_targetChainId);\n\n        uint256 processingFee;\n        uint256 processingGas;\n        (variables.useTargetExecutor, processingFee, processingGas) = _decodeSettings(_settings);\n\n        // - - - Processing fee transfer - - -\n\n        if (msg.value < processingFee) {\n            revert ProcessingFeeError();\n        }\n\n        if (processingFee > 0 && processingFeeCollector != address(0)) {\n            TransferHelper.safeTransferNative(processingFeeCollector, processingFee);\n        }\n\n        // - - -\n\n        TargetMessage memory targetMessage = abi.decode(_message, (TargetMessage));\n\n        // - - - CCTP - Burn USDC on the source chain - - -\n\n        TransferHelper.safeApprove(asset, address(cctpTokenMessenger), assetAmount);\n\n        variables.assetMessageNonce = cctpTokenMessenger.depositForBurnWithCaller(\n            assetAmount,\n            variables.targetDomain,\n            variables.peerAddressBytes32, // _mintRecipient\n            asset,\n            variables.peerAddressBytes32 // _destinationCaller\n        );\n\n        TransferHelper.safeApprove(asset, address(cctpTokenMessenger), 0);\n\n        // - - -\n\n        // - - - CCTP - Send the message - - -\n\n        variables.dataMessageNonce = cctpMessageTransmitter.sendMessageWithCaller(\n            variables.targetDomain,\n            variables.peerAddressBytes32, // recipient\n            variables.peerAddressBytes32, // destinationCaller\n            _message\n        );\n\n        // - - -\n\n        emit GatewayActionSource(\n            targetMessage.actionId,\n            _targetChainId,\n            variables.useTargetExecutor,\n            variables.assetMessageNonce,\n            variables.dataMessageNonce,\n            assetAmount,\n            processingFee,\n            processingGas,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @notice Executes the target actions\n     */\n    function executeTarget(\n        bytes calldata _assetMessage,\n        bytes calldata _assetAttestation,\n        bytes calldata _dataMessage,\n        bytes calldata _dataAttestation\n    ) external whenNotPaused nonReentrant checkCaller {\n        _executeTarget(\n            _assetMessage,\n            _assetAttestation,\n            _dataMessage,\n            _dataAttestation,\n            false,\n            address(0),\n            _blankSwapInfo()\n        );\n    }\n\n    /**\n     * @notice Executes the target actions for the asset\n     */\n    function executeTargetForAsset(\n        bytes calldata _assetMessage,\n        bytes calldata _assetAttestation,\n        bytes calldata _dataMessage,\n        bytes calldata _dataAttestation\n    ) external whenNotPaused nonReentrant checkCaller {\n        _executeTarget(\n            _assetMessage,\n            _assetAttestation,\n            _dataMessage,\n            _dataAttestation,\n            true,\n            asset,\n            _blankSwapInfo()\n        );\n    }\n\n    /**\n     * @notice Executes the target actions for the asset\n     */\n    function executeTargetWithCustomSwap(\n        bytes calldata _assetMessage,\n        bytes calldata _assetAttestation,\n        bytes calldata _dataMessage,\n        bytes calldata _dataAttestation,\n        address _targetTokenAddress,\n        SwapInfo memory _targetSwapInfo\n    ) external whenNotPaused nonReentrant checkCaller {\n        _executeTarget(\n            _assetMessage,\n            _assetAttestation,\n            _dataMessage,\n            _dataAttestation,\n            true,\n            _targetTokenAddress,\n            _targetSwapInfo\n        );\n    }\n\n    /**\n     * @notice handles an incoming message from a Receiver\n     * @dev IMessageHandler interface\n     * @param _sourceDomain the source domain of the message\n     * @param _sender the sender of the message\n     * @param _messageBody The message raw bytes\n     * @return success bool, true if successful\n     */\n    function handleReceiveMessage(\n        uint32 _sourceDomain,\n        bytes32 _sender,\n        bytes calldata _messageBody\n    ) external whenNotPaused onlyMessageTransmitter returns (bool) {\n        targetDataMessageContext = TargetDataMessageContext({\n            sourceDomain: _sourceDomain,\n            sender: _sender,\n            messageBody: _messageBody\n        });\n\n        return true;\n    }\n\n    /**\n     * @notice Receives the asset tokens from CCTP and transfers them to the specified account\n     * @param _assetMessage The CCTP asset message\n     * @param _assetAttestation The CCTP asset attestation\n     * @param _to The address of the asset tokens receiver\n     */\n    function extractCctpAsset(\n        bytes calldata _assetMessage,\n        bytes calldata _assetAttestation,\n        address _to\n    ) external onlyManager {\n        uint256 tokenBalanceBefore = ITokenBalance(asset).balanceOf(address(this));\n\n        cctpMessageTransmitter.receiveMessage(_assetMessage, _assetAttestation);\n\n        uint256 tokenAmount = ITokenBalance(asset).balanceOf(address(this)) - tokenBalanceBefore;\n\n        if (tokenAmount > 0 && _to != address(this)) {\n            TransferHelper.safeTransfer(asset, _to, tokenAmount);\n        }\n    }\n\n    /**\n     * @notice Requests the vault asset tokens\n     * @param _amount The amount of the vault asset tokens\n     * @param _to The address of the vault asset tokens receiver\n     * @param _forVariableBalance True if the request is made for a variable balance repayment, otherwise false\n     * @return assetAddress The address of the vault asset token\n     */\n    function requestAsset(\n        uint256 _amount,\n        address _to,\n        bool _forVariableBalance\n    ) external whenNotPaused onlyAssetSpender returns (address assetAddress) {\n        if (_forVariableBalance && !variableRepaymentEnabled) {\n            revert VariableRepaymentNotEnabledError();\n        }\n\n        TransferHelper.safeTransfer(asset, _to, _amount);\n\n        return asset;\n    }\n\n    /**\n     * @notice Cross-chain message fee estimation\n     * @param _settings The gateway-specific settings\n     */\n    function messageFee(\n        uint256 /*_targetChainId*/,\n        bytes calldata /*_message*/,\n        bytes calldata _settings\n    ) external pure returns (uint256) {\n        (, uint256 processingFee, ) = _decodeSettings(_settings);\n\n        return processingFee;\n    }\n\n    /**\n     * @notice Checks the status of the variable token and balance actions and the variable token address\n     * @return The address of the variable token\n     */\n    function checkVariableTokenState() external view returns (address) {\n        if (!variableRepaymentEnabled) {\n            revert VariableRepaymentNotEnabledError();\n        }\n\n        revert VariableTokenNotSetError();\n    }\n\n    function _setChainDomain(uint256 _chainId, uint32 _domain) private {\n        DataStructures.OptionalValue storage previousDomainEntry = chainIdToDomain[_chainId];\n\n        if (previousDomainEntry.isSet) {\n            delete domainToChainId[uint32(previousDomainEntry.value)];\n        }\n\n        chainIdToDomain[_chainId] = DataStructures.OptionalValue({ isSet: true, value: _domain });\n        domainToChainId[_domain] = _chainId;\n\n        emit SetChainDomain(_chainId, _domain);\n    }\n\n    function _removeChainDomain(uint256 _chainId) private {\n        DataStructures.OptionalValue storage domainEntry = chainIdToDomain[_chainId];\n\n        uint32 domain;\n\n        if (domainEntry.isSet) {\n            domain = uint32(domainEntry.value);\n\n            delete domainToChainId[uint32(domainEntry.value)];\n        }\n\n        delete chainIdToDomain[_chainId];\n\n        emit RemoveChainDomain(_chainId, domain);\n    }\n\n    function _setVariableRepaymentEnabled(bool _variableRepaymentEnabled) private {\n        variableRepaymentEnabled = _variableRepaymentEnabled;\n\n        emit SetVariableRepaymentEnabled(_variableRepaymentEnabled);\n    }\n\n    function _setProcessingFeeCollector(address _processingFeeCollector) private {\n        processingFeeCollector = _processingFeeCollector;\n\n        emit SetProcessingFeeCollector(_processingFeeCollector);\n    }\n\n    function _setTargetExecutor(address _targetExecutor) private {\n        targetExecutor = _targetExecutor;\n\n        emit SetTargetExecutor(_targetExecutor);\n    }\n\n    function _executeTarget(\n        bytes calldata _assetMessage,\n        bytes calldata _assetAttestation,\n        bytes calldata _dataMessage,\n        bytes calldata _dataAttestation,\n        bool _replaceSwapData,\n        address _targetTokenAddress,\n        SwapInfo memory _targetSwapInfo\n    ) private {\n        if (address(client) == address(0)) {\n            revert TargetClientNotSetError();\n        }\n\n        uint256 assetBalanceBefore = tokenBalance(asset);\n\n        bool assetMessageSuccess = cctpMessageTransmitter.receiveMessage(\n            _assetMessage,\n            _assetAttestation\n        );\n\n        if (!assetMessageSuccess) {\n            revert AssetMessageError();\n        }\n\n        uint256 assetReceived = tokenBalance(asset) - assetBalanceBefore;\n\n        bool dataMessageSuccess = cctpMessageTransmitter.receiveMessage(\n            _dataMessage,\n            _dataAttestation\n        );\n\n        if (!dataMessageSuccess) {\n            revert DataMessageError();\n        }\n\n        (\n            uint256 sourceChainId,\n            address fromAddress,\n            TargetMessage memory targetMessage\n        ) = _consumeTargetDataMessageContext();\n\n        {\n            bool fromAddressCondition = sourceChainId != 0 &&\n                fromAddress != address(0) &&\n                fromAddress == peerMap[sourceChainId];\n\n            if (!fromAddressCondition) {\n                revert TargetFromAddressError(sourceChainId, fromAddress);\n            }\n        }\n\n        {\n            bool targetCallerCondition = (msg.sender == targetExecutor && !_replaceSwapData) ||\n                msg.sender == targetMessage.sourceSender ||\n                msg.sender == targetMessage.targetRecipient;\n\n            if (!targetCallerCondition) {\n                revert TargetCallerError();\n            }\n        }\n\n        if (targetMessage.targetSwapInfo.fromAmount != assetReceived) {\n            revert TargetAssetAmountMismatchError();\n        }\n\n        if (_replaceSwapData) {\n            targetMessage.targetTokenAddress = _targetTokenAddress;\n            targetMessage.targetSwapInfo = _targetSwapInfo;\n        }\n\n        bytes memory payloadData = abi.encode(targetMessage);\n\n        (bool hasGasReserve, uint256 gasAllowed) = GasReserveHelper.checkGasReserve(\n            targetGasReserve\n        );\n\n        if (!hasGasReserve) {\n            revert TargetGasReserveError();\n        }\n\n        client.handleExecutionPayload{ gas: gasAllowed }(sourceChainId, payloadData);\n    }\n\n    function _consumeTargetDataMessageContext()\n        private\n        returns (uint256 sourceChainId, address fromAddress, TargetMessage memory targetMessage)\n    {\n        sourceChainId = domainToChainId[targetDataMessageContext.sourceDomain];\n\n        fromAddress = _bytes32ToAddress(targetDataMessageContext.sender);\n\n        targetMessage = abi.decode(targetDataMessageContext.messageBody, (TargetMessage));\n\n        delete targetDataMessageContext;\n    }\n\n    function _checkTargetDomain(uint256 _targetChainId) private view returns (uint32) {\n        DataStructures.OptionalValue storage domainEntry = chainIdToDomain[_targetChainId];\n\n        if (!domainEntry.isSet) {\n            revert DomainNotSetError();\n        }\n\n        return uint32(domainEntry.value);\n    }\n\n    function _prepareSendMessageVariables() private pure returns (SendMessageVariables memory) {\n        return\n            SendMessageVariables({\n                peerAddressBytes32: bytes32(0),\n                targetDomain: 0,\n                assetMessageNonce: 0,\n                dataMessageNonce: 0,\n                useTargetExecutor: false\n            });\n    }\n\n    function _decodeSettings(\n        bytes calldata _settings\n    ) private pure returns (bool useTargetExecutor, uint256 processingFee, uint256 processingGas) {\n        return abi.decode(_settings, (bool, uint256, uint256));\n    }\n\n    function _blankSwapInfo() private pure returns (SwapInfo memory) {\n        return SwapInfo({ fromAmount: 0, routerType: 0, routerData: '' });\n    }\n\n    function _addressToBytes32(address _address) private pure returns (bytes32) {\n        return bytes32(uint256(uint160(_address)));\n    }\n\n    function _bytes32ToAddress(bytes32 _buffer) private pure returns (address) {\n        return address(uint160(uint256(_buffer)));\n    }\n}\n"

    },

    "contracts/crosschain/circle-cctp/interfaces/IMessageHandler.sol": {

      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright (c) 2022, Circle Internet Financial Limited.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npragma solidity 0.8.19;\n\n/**\n * @title IMessageHandler\n * @notice Handles messages on destination domain forwarded from\n * an IReceiver\n */\ninterface IMessageHandler {\n    /**\n     * @notice handles an incoming message from a Receiver\n     * @param _sourceDomain the source domain of the message\n     * @param _sender the sender of the message\n     * @param _messageBody The message raw bytes\n     * @return success bool, true if successful\n     */\n    function handleReceiveMessage(\n        uint32 _sourceDomain,\n        bytes32 _sender,\n        bytes calldata _messageBody\n    ) external returns (bool);\n}\n"

    },

    "contracts/crosschain/circle-cctp/interfaces/IMessageTransmitter.sol": {

      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright (c) 2022, Circle Internet Financial Limited.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npragma solidity 0.8.19;\n\nimport './IRelayer.sol';\nimport './IReceiver.sol';\n\n/**\n * @title IMessageTransmitter\n * @notice Interface for message transmitters, which both relay and receive messages.\n */\ninterface IMessageTransmitter is IRelayer, IReceiver {\n\n}\n"

    },

    "contracts/crosschain/circle-cctp/interfaces/IReceiver.sol": {

      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright (c) 2022, Circle Internet Financial Limited.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npragma solidity 0.8.19;\n\n/**\n * @title IReceiver\n * @notice Receives messages on destination chain and forwards them to IMessageDestinationHandler\n */\ninterface IReceiver {\n    /**\n     * @notice Receives an incoming message, validating the header and passing\n     * the body to application-specific handler.\n     * @param message The message raw bytes\n     * @param signature The message signature\n     * @return success bool, true if successful\n     */\n    function receiveMessage(\n        bytes calldata message,\n        bytes calldata signature\n    ) external returns (bool success);\n}\n"

    },

    "contracts/crosschain/circle-cctp/interfaces/IRelayer.sol": {

      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright (c) 2022, Circle Internet Financial Limited.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npragma solidity 0.8.19;\n\n/**\n * @title IRelayer\n * @notice Sends messages from source domain to destination domain\n */\ninterface IRelayer {\n    /**\n     * @notice Sends an outgoing message from the source domain.\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination domain as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessage(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes calldata messageBody\n    ) external returns (uint64);\n\n    /**\n     * @notice Sends an outgoing message from the source domain, with a specified caller on the\n     * destination domain.\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * sendMessage() should be preferred for use cases where a specific destination caller is not required.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination domain as bytes32\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessageWithCaller(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external returns (uint64);\n\n    /**\n     * @notice Replace a message with a new message body and/or destination caller.\n     * @dev The `originalAttestation` must be a valid attestation of `originalMessage`.\n     * @param originalMessage original message to replace\n     * @param originalAttestation attestation of `originalMessage`\n     * @param newMessageBody new message body of replaced message\n     * @param newDestinationCaller the new destination caller\n     */\n    function replaceMessage(\n        bytes calldata originalMessage,\n        bytes calldata originalAttestation,\n        bytes calldata newMessageBody,\n        bytes32 newDestinationCaller\n    ) external;\n}\n"

    },

    "contracts/crosschain/circle-cctp/interfaces/ITokenMessenger.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.19;\n\n/**\n * @title ITokenMessenger\n * @notice Sends messages to MessageTransmitters and to TokenMinters\n */\ninterface ITokenMessenger {\n    function depositForBurnWithCaller(\n        uint256 _amount,\n        uint32 _destinationDomain,\n        bytes32 _mintRecipient,\n        address _burnToken,\n        bytes32 _destinationCaller\n    ) external returns (uint64 _nonce);\n}\n"

    },

    "contracts/crosschain/GatewayBase.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.19;\n\nimport { ReentrancyGuard } from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\nimport { IGateway } from './interfaces/IGateway.sol';\nimport { IGatewayClient } from './interfaces/IGatewayClient.sol';\nimport { BalanceManagement } from '../BalanceManagement.sol';\nimport { Pausable } from '../Pausable.sol';\nimport { TargetGasReserve } from './TargetGasReserve.sol';\nimport { ZeroAddressError } from '../Errors.sol';\nimport '../helpers/AddressHelper.sol' as AddressHelper;\nimport '../Constants.sol' as Constants;\nimport '../DataStructures.sol' as DataStructures;\n\n/**\n * @title GatewayBase\n * @notice Base contract that implements the cross-chain gateway logic\n */\nabstract contract GatewayBase is\n    Pausable,\n    ReentrancyGuard,\n    TargetGasReserve,\n    BalanceManagement,\n    IGateway\n{\n    /**\n     * @dev Gateway client contract reference\n     */\n    IGatewayClient public client;\n\n    /**\n     * @dev Registered peer gateway addresses by the chain ID\n     */\n    mapping(uint256 /*peerChainId*/ => address /*peerAddress*/) public peerMap;\n\n    /**\n     * @dev Registered peer gateway chain IDs\n     */\n    uint256[] public peerChainIdList;\n\n    /**\n     * @dev Registered peer gateway chain ID indices\n     */\n    mapping(uint256 /*peerChainId*/ => DataStructures.OptionalValue /*peerChainIdIndex*/)\n        public peerChainIdIndexMap;\n\n    /**\n     * @notice Emitted when the gateway client contract reference is set\n     * @param clientAddress The gateway client contract address\n     */\n    event SetClient(address indexed clientAddress);\n\n    /**\n     * @notice Emitted when a registered peer gateway contract address is added or updated\n     * @param chainId The chain ID of the registered peer gateway\n     * @param peerAddress The address of the registered peer gateway contract\n     */\n    event SetPeer(uint256 indexed chainId, address indexed peerAddress);\n\n    /**\n     * @notice Emitted when a registered peer gateway contract address is removed\n     * @param chainId The chain ID of the registered peer gateway\n     */\n    event RemovePeer(uint256 indexed chainId);\n\n    /**\n     * @notice Emitted when the target chain gateway is paused\n     */\n    event TargetPausedFailure();\n\n    /**\n     * @notice Emitted when the target chain gateway client contract is not set\n     */\n    event TargetClientNotSetFailure();\n\n    /**\n     * @notice Emitted when the message source address does not match the registered peer gateway on the target chain\n     * @param sourceChainId The ID of the message source chain\n     * @param fromAddress The address of the message source\n     */\n    event TargetFromAddressFailure(uint256 indexed sourceChainId, address indexed fromAddress);\n\n    /**\n     * @notice Emitted when the gas reserve on the target chain does not allow further action processing\n     * @param sourceChainId The ID of the message source chain\n     */\n    event TargetGasReserveFailure(uint256 indexed sourceChainId);\n\n    /**\n     * @notice Emitted when the gateway client execution on the target chain fails\n     */\n    event TargetExecutionFailure();\n\n    /**\n     * @notice Emitted when the caller is not the gateway client contract\n     */\n    error OnlyClientError();\n\n    /**\n     * @notice Emitted when the peer config address for the current chain does not match the current contract\n     */\n    error PeerAddressMismatchError();\n\n    /**\n     * @notice Emitted when the peer gateway address for the specified chain is not set\n     */\n    error PeerNotSetError();\n\n    /**\n     * @notice Emitted when the chain ID is not set\n     */\n    error ZeroChainIdError();\n\n    /**\n     * @dev Modifier to check if the caller is the gateway client contract\n     */\n    modifier onlyClient() {\n        if (msg.sender != address(client)) {\n            revert OnlyClientError();\n        }\n\n        _;\n    }\n\n    /**\n     * @notice Sets the gateway client contract reference\n     * @param _clientAddress The gateway client contract address\n     */\n    function setClient(address payable _clientAddress) external virtual onlyManager {\n        AddressHelper.requireContract(_clientAddress);\n\n        client = IGatewayClient(_clientAddress);\n\n        emit SetClient(_clientAddress);\n    }\n\n    /**\n     * @notice Adds or updates registered peer gateways\n     * @param _peers Chain IDs and addresses of peer gateways\n     */\n    function setPeers(\n        DataStructures.KeyToAddressValue[] calldata _peers\n    ) external virtual onlyManager {\n        for (uint256 index; index < _peers.length; index++) {\n            DataStructures.KeyToAddressValue calldata item = _peers[index];\n\n            uint256 chainId = item.key;\n            address peerAddress = item.value;\n\n            // Allow the same configuration on multiple chains\n            if (chainId == block.chainid) {\n                if (peerAddress != address(this)) {\n                    revert PeerAddressMismatchError();\n                }\n            } else {\n                _setPeer(chainId, peerAddress);\n            }\n        }\n    }\n\n    /**\n     * @notice Removes registered peer gateways\n     * @param _chainIds Peer gateway chain IDs\n     */\n    function removePeers(uint256[] calldata _chainIds) external virtual onlyManager {\n        for (uint256 index; index < _chainIds.length; index++) {\n            uint256 chainId = _chainIds[index];\n\n            // Allow the same configuration on multiple chains\n            if (chainId != block.chainid) {\n                _removePeer(chainId);\n            }\n        }\n    }\n\n    /**\n     * @notice Getter of the peer gateway count\n     * @return The peer gateway count\n     */\n    function peerCount() external view virtual returns (uint256) {\n        return peerChainIdList.length;\n    }\n\n    /**\n     * @notice Getter of the complete list of the peer gateway chain IDs\n     * @return The complete list of the peer gateway chain IDs\n     */\n    function fullPeerChainIdList() external view virtual returns (uint256[] memory) {\n        return peerChainIdList;\n    }\n\n    function _setPeer(uint256 _chainId, address _peerAddress) internal virtual {\n        if (_chainId == 0) {\n            revert ZeroChainIdError();\n        }\n\n        if (_peerAddress == address(0)) {\n            revert ZeroAddressError();\n        }\n\n        DataStructures.combinedMapSet(\n            peerMap,\n            peerChainIdList,\n            peerChainIdIndexMap,\n            _chainId,\n            _peerAddress,\n            Constants.LIST_SIZE_LIMIT_DEFAULT\n        );\n\n        emit SetPeer(_chainId, _peerAddress);\n    }\n\n    function _removePeer(uint256 _chainId) internal virtual {\n        if (_chainId == 0) {\n            revert ZeroChainIdError();\n        }\n\n        DataStructures.combinedMapRemove(peerMap, peerChainIdList, peerChainIdIndexMap, _chainId);\n\n        emit RemovePeer(_chainId);\n    }\n\n    function _checkPeerAddress(uint256 _chainId) internal virtual returns (address) {\n        address peerAddress = peerMap[_chainId];\n\n        if (peerAddress == address(0)) {\n            revert PeerNotSetError();\n        }\n\n        return peerAddress;\n    }\n}\n"

    },

    "contracts/crosschain/interfaces/IGateway.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.19;\n\n/**\n * @title IGateway\n * @notice Cross-chain gateway interface\n */\ninterface IGateway {\n    /**\n     * @notice Send a cross-chain message\n     * @param _targetChainId The message target chain ID\n     * @param _message The message content\n     * @param _settings The gateway-specific settings\n     */\n    function sendMessage(\n        uint256 _targetChainId,\n        bytes calldata _message,\n        bytes calldata _settings\n    ) external payable;\n\n    /**\n     * @notice Cross-chain message fee estimation\n     * @param _targetChainId The ID of the target chain\n     * @param _message The message content\n     * @param _settings The gateway-specific settings\n     */\n    function messageFee(\n        uint256 _targetChainId,\n        bytes calldata _message,\n        bytes calldata _settings\n    ) external view returns (uint256);\n}\n"

    },

    "contracts/crosschain/interfaces/IGatewayClient.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.19;\n\nimport { IVault } from '../../interfaces/IVault.sol';\n\n/**\n * @title IGatewayClient\n * @notice Cross-chain gateway client interface\n */\ninterface IGatewayClient {\n    /**\n     * @notice The standard \"receive\" function\n     */\n    receive() external payable;\n\n    /**\n     * @notice Cross-chain message handler on the target chain\n     * @dev The function is called by cross-chain gateways\n     * @param _messageSourceChainId The ID of the message source chain\n     * @param _payloadData The content of the cross-chain message\n     */\n    function handleExecutionPayload(\n        uint256 _messageSourceChainId,\n        bytes calldata _payloadData\n    ) external;\n\n    /**\n     * @notice Getter of the source gateway context\n     * @return vault The source vault\n     * @return assetAmount The source vault asset amount\n     */\n    function getSourceGatewayContext() external view returns (IVault vault, uint256 assetAmount);\n}\n"

    },

    "contracts/crosschain/TargetGasReserve.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.19;\n\nimport { ManagerRole } from '../roles/ManagerRole.sol';\n\n/**\n * @title TargetGasReserve\n * @notice Base contract that implements the gas reserve logic for the target chain actions\n */\nabstract contract TargetGasReserve is ManagerRole {\n    /**\n     * @dev The target chain gas reserve value\n     */\n    uint256 public targetGasReserve;\n\n    /**\n     * @notice Emitted when the target chain gas reserve value is set\n     * @param gasReserve The target chain gas reserve value\n     */\n    event SetTargetGasReserve(uint256 gasReserve);\n\n    /**\n     * @notice Sets the target chain gas reserve value\n     * @param _gasReserve The target chain gas reserve value\n     */\n    function setTargetGasReserve(uint256 _gasReserve) external onlyManager {\n        _setTargetGasReserve(_gasReserve);\n    }\n\n    function _setTargetGasReserve(uint256 _gasReserve) internal virtual {\n        targetGasReserve = _gasReserve;\n\n        emit SetTargetGasReserve(_gasReserve);\n    }\n}\n"

    },

    "contracts/DataStructures.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.19;\n\n/**\n * @notice Optional value structure\n * @dev Is used in mappings to allow zero values\n * @param isSet Value presence flag\n * @param value Numeric value\n */\nstruct OptionalValue {\n    bool isSet;\n    uint256 value;\n}\n\n/**\n * @notice Key-to-value structure\n * @dev Is used as an array parameter item to perform multiple key-value settings\n * @param key Numeric key\n * @param value Numeric value\n */\nstruct KeyToValue {\n    uint256 key;\n    uint256 value;\n}\n\n/**\n * @notice Key-to-value structure for address values\n * @dev Is used as an array parameter item to perform multiple key-value settings with address values\n * @param key Numeric key\n * @param value Address value\n */\nstruct KeyToAddressValue {\n    uint256 key;\n    address value;\n}\n\n/**\n * @notice Address-to-flag structure\n * @dev Is used as an array parameter item to perform multiple settings\n * @param account Account address\n * @param flag Flag value\n */\nstruct AccountToFlag {\n    address account;\n    bool flag;\n}\n\n/**\n * @notice Emitted when a list exceeds the size limit\n */\nerror ListSizeLimitError();\n\n/**\n * @notice Sets or updates a value in a combined map (a mapping with a key list and key index mapping)\n * @param _map The mapping reference\n * @param _keyList The key list reference\n * @param _keyIndexMap The key list index mapping reference\n * @param _key The numeric key\n * @param _value The address value\n * @param _sizeLimit The map and list size limit\n * @return isNewKey True if the key was just added, otherwise false\n */\nfunction combinedMapSet(\n    mapping(uint256 => address) storage _map,\n    uint256[] storage _keyList,\n    mapping(uint256 => OptionalValue) storage _keyIndexMap,\n    uint256 _key,\n    address _value,\n    uint256 _sizeLimit\n) returns (bool isNewKey) {\n    isNewKey = !_keyIndexMap[_key].isSet;\n\n    if (isNewKey) {\n        uniqueListAdd(_keyList, _keyIndexMap, _key, _sizeLimit);\n    }\n\n    _map[_key] = _value;\n}\n\n/**\n * @notice Removes a value from a combined map (a mapping with a key list and key index mapping)\n * @param _map The mapping reference\n * @param _keyList The key list reference\n * @param _keyIndexMap The key list index mapping reference\n * @param _key The numeric key\n * @return isChanged True if the combined map was changed, otherwise false\n */\nfunction combinedMapRemove(\n    mapping(uint256 => address) storage _map,\n    uint256[] storage _keyList,\n    mapping(uint256 => OptionalValue) storage _keyIndexMap,\n    uint256 _key\n) returns (bool isChanged) {\n    isChanged = _keyIndexMap[_key].isSet;\n\n    if (isChanged) {\n        delete _map[_key];\n        uniqueListRemove(_keyList, _keyIndexMap, _key);\n    }\n}\n\n/**\n * @notice Adds a value to a unique value list (a list with value index mapping)\n * @param _list The list reference\n * @param _indexMap The value index mapping reference\n * @param _value The numeric value\n * @param _sizeLimit The list size limit\n * @return isChanged True if the list was changed, otherwise false\n */\nfunction uniqueListAdd(\n    uint256[] storage _list,\n    mapping(uint256 => OptionalValue) storage _indexMap,\n    uint256 _value,\n    uint256 _sizeLimit\n) returns (bool isChanged) {\n    isChanged = !_indexMap[_value].isSet;\n\n    if (isChanged) {\n        if (_list.length >= _sizeLimit) {\n            revert ListSizeLimitError();\n        }\n\n        _indexMap[_value] = OptionalValue(true, _list.length);\n        _list.push(_value);\n    }\n}\n\n/**\n * @notice Removes a value from a unique value list (a list with value index mapping)\n * @param _list The list reference\n * @param _indexMap The value index mapping reference\n * @param _value The numeric value\n * @return isChanged True if the list was changed, otherwise false\n */\nfunction uniqueListRemove(\n    uint256[] storage _list,\n    mapping(uint256 => OptionalValue) storage _indexMap,\n    uint256 _value\n) returns (bool isChanged) {\n    OptionalValue storage indexItem = _indexMap[_value];\n\n    isChanged = indexItem.isSet;\n\n    if (isChanged) {\n        uint256 itemIndex = indexItem.value;\n        uint256 lastIndex = _list.length - 1;\n\n        if (itemIndex != lastIndex) {\n            uint256 lastValue = _list[lastIndex];\n            _list[itemIndex] = lastValue;\n            _indexMap[lastValue].value = itemIndex;\n        }\n\n        _list.pop();\n        delete _indexMap[_value];\n    }\n}\n\n/**\n * @notice Adds a value to a unique address value list (a list with value index mapping)\n * @param _list The list reference\n * @param _indexMap The value index mapping reference\n * @param _value The address value\n * @param _sizeLimit The list size limit\n * @return isChanged True if the list was changed, otherwise false\n */\nfunction uniqueAddressListAdd(\n    address[] storage _list,\n    mapping(address => OptionalValue) storage _indexMap,\n    address _value,\n    uint256 _sizeLimit\n) returns (bool isChanged) {\n    isChanged = !_indexMap[_value].isSet;\n\n    if (isChanged) {\n        if (_list.length >= _sizeLimit) {\n            revert ListSizeLimitError();\n        }\n\n        _indexMap[_value] = OptionalValue(true, _list.length);\n        _list.push(_value);\n    }\n}\n\n/**\n * @notice Removes a value from a unique address value list (a list with value index mapping)\n * @param _list The list reference\n * @param _indexMap The value index mapping reference\n * @param _value The address value\n * @return isChanged True if the list was changed, otherwise false\n */\nfunction uniqueAddressListRemove(\n    address[] storage _list,\n    mapping(address => OptionalValue) storage _indexMap,\n    address _value\n) returns (bool isChanged) {\n    OptionalValue storage indexItem = _indexMap[_value];\n\n    isChanged = indexItem.isSet;\n\n    if (isChanged) {\n        uint256 itemIndex = indexItem.value;\n        uint256 lastIndex = _list.length - 1;\n\n        if (itemIndex != lastIndex) {\n            address lastValue = _list[lastIndex];\n            _list[itemIndex] = lastValue;\n            _indexMap[lastValue].value = itemIndex;\n        }\n\n        _list.pop();\n        delete _indexMap[_value];\n    }\n}\n\n/**\n * @notice Adds or removes a value to/from a unique address value list (a list with value index mapping)\n * @dev The list size limit is checked on items adding only\n * @param _list The list reference\n * @param _indexMap The value index mapping reference\n * @param _value The address value\n * @param _flag The value inclusion flag\n * @param _sizeLimit The list size limit\n * @return isChanged True if the list was changed, otherwise false\n */\nfunction uniqueAddressListUpdate(\n    address[] storage _list,\n    mapping(address => OptionalValue) storage _indexMap,\n    address _value,\n    bool _flag,\n    uint256 _sizeLimit\n) returns (bool isChanged) {\n    return\n        _flag\n            ? uniqueAddressListAdd(_list, _indexMap, _value, _sizeLimit)\n            : uniqueAddressListRemove(_list, _indexMap, _value);\n}\n"

    },

    "contracts/Errors.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.19;\n\n/**\n * @notice Emitted when an attempt to burn a token fails\n */\nerror TokenBurnError();\n\n/**\n * @notice Emitted when an attempt to mint a token fails\n */\nerror TokenMintError();\n\n/**\n * @notice Emitted when a zero address is specified where it is not allowed\n */\nerror ZeroAddressError();\n"

    },

    "contracts/helpers/AddressHelper.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.19;\n\n/**\n * @notice Emitted when the account is not a contract\n * @param account The account address\n */\nerror NonContractAddressError(address account);\n\n/**\n * @notice Function to check if the account is a contract\n * @return The account contract status flag\n */\nfunction isContract(address _account) view returns (bool) {\n    return _account.code.length > 0;\n}\n\n/**\n * @notice Function to require an account to be a contract\n */\nfunction requireContract(address _account) view {\n    if (!isContract(_account)) {\n        revert NonContractAddressError(_account);\n    }\n}\n\n/**\n * @notice Function to require an account to be a contract or a zero address\n */\nfunction requireContractOrZeroAddress(address _account) view {\n    if (_account != address(0)) {\n        requireContract(_account);\n    }\n}\n"

    },

    "contracts/helpers/GasReserveHelper.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.19;\n\n/**\n * @notice Function to check if the available gas matches the specified gas reserve value\n * @param _gasReserve Gas reserve value\n * @return hasGasReserve Flag of gas reserve availability\n * @return gasAllowed The remaining gas quantity taking the reserve into account\n */\nfunction checkGasReserve(\n    uint256 _gasReserve\n) view returns (bool hasGasReserve, uint256 gasAllowed) {\n    uint256 gasLeft = gasleft();\n\n    hasGasReserve = gasLeft >= _gasReserve;\n    gasAllowed = hasGasReserve ? gasLeft - _gasReserve : 0;\n}\n"

    },

    "contracts/helpers/TransferHelper.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.19;\n\n/**\n * @notice Emitted when an approval action fails\n */\nerror SafeApproveError();\n\n/**\n * @notice Emitted when a transfer action fails\n */\nerror SafeTransferError();\n\n/**\n * @notice Emitted when a transferFrom action fails\n */\nerror SafeTransferFromError();\n\n/**\n * @notice Emitted when a transfer of the native token fails\n */\nerror SafeTransferNativeError();\n\n/**\n * @notice Safely approve the token to the account\n * @param _token The token address\n * @param _to The token approval recipient address\n * @param _value The token approval amount\n */\nfunction safeApprove(address _token, address _to, uint256 _value) {\n    // 0x095ea7b3 is the selector for \"approve(address,uint256)\"\n    (bool success, bytes memory data) = _token.call(\n        abi.encodeWithSelector(0x095ea7b3, _to, _value)\n    );\n\n    bool condition = success && (data.length == 0 || abi.decode(data, (bool)));\n\n    if (!condition) {\n        revert SafeApproveError();\n    }\n}\n\n/**\n * @notice Safely transfer the token to the account\n * @param _token The token address\n * @param _to The token transfer recipient address\n * @param _value The token transfer amount\n */\nfunction safeTransfer(address _token, address _to, uint256 _value) {\n    // 0xa9059cbb is the selector for \"transfer(address,uint256)\"\n    (bool success, bytes memory data) = _token.call(\n        abi.encodeWithSelector(0xa9059cbb, _to, _value)\n    );\n\n    bool condition = success && (data.length == 0 || abi.decode(data, (bool)));\n\n    if (!condition) {\n        revert SafeTransferError();\n    }\n}\n\n/**\n * @notice Safely transfer the token between the accounts\n * @param _token The token address\n * @param _from The token transfer source address\n * @param _to The token transfer recipient address\n * @param _value The token transfer amount\n */\nfunction safeTransferFrom(address _token, address _from, address _to, uint256 _value) {\n    // 0x23b872dd is the selector for \"transferFrom(address,address,uint256)\"\n    (bool success, bytes memory data) = _token.call(\n        abi.encodeWithSelector(0x23b872dd, _from, _to, _value)\n    );\n\n    bool condition = success && (data.length == 0 || abi.decode(data, (bool)));\n\n    if (!condition) {\n        revert SafeTransferFromError();\n    }\n}\n\n/**\n * @notice Safely transfer the native token to the account\n * @param _to The native token transfer recipient address\n * @param _value The native token transfer amount\n */\nfunction safeTransferNative(address _to, uint256 _value) {\n    (bool success, ) = _to.call{ value: _value }(new bytes(0));\n\n    if (!success) {\n        revert SafeTransferNativeError();\n    }\n}\n"

    },

    "contracts/interfaces/IActionDataStructures.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.19;\n\n/**\n * @title IActionDataStructures\n * @notice Action data structure declarations\n */\ninterface IActionDataStructures {\n    /**\n     * @notice Single-chain action data structure\n     * @param fromTokenAddress The address of the input token\n     * @param toTokenAddress The address of the output token\n     * @param swapInfo The data for the single-chain swap\n     * @param recipient The address of the recipient\n     */\n    struct LocalAction {\n        address fromTokenAddress;\n        address toTokenAddress;\n        SwapInfo swapInfo;\n        address recipient;\n    }\n\n    /**\n     * @notice Cross-chain action data structure\n     * @param gatewayType The numeric type of the cross-chain gateway\n     * @param vaultType The numeric type of the vault\n     * @param sourceTokenAddress The address of the input token on the source chain\n     * @param sourceSwapInfo The data for the source chain swap\n     * @param targetChainId The action target chain ID\n     * @param targetTokenAddress The address of the output token on the destination chain\n     * @param targetSwapInfoOptions The list of data options for the target chain swap\n     * @param targetRecipient The address of the recipient on the target chain\n     * @param gatewaySettings The gateway-specific settings data\n     */\n    struct Action {\n        uint256 gatewayType;\n        uint256 vaultType;\n        address sourceTokenAddress;\n        SwapInfo sourceSwapInfo;\n        uint256 targetChainId;\n        address targetTokenAddress;\n        SwapInfo[] targetSwapInfoOptions;\n        address targetRecipient;\n        bytes gatewaySettings;\n    }\n\n    /**\n     * @notice Token swap data structure\n     * @param fromAmount The quantity of the token\n     * @param routerType The numeric type of the swap router\n     * @param routerData The data for the swap router call\n     */\n    struct SwapInfo {\n        uint256 fromAmount;\n        uint256 routerType;\n        bytes routerData;\n    }\n\n    /**\n     * @notice Cross-chain message data structure\n     * @param actionId The unique identifier of the cross-chain action\n     * @param sourceSender The address of the sender on the source chain\n     * @param vaultType The numeric type of the vault\n     * @param targetTokenAddress The address of the output token on the target chain\n     * @param targetSwapInfo The data for the target chain swap\n     * @param targetRecipient The address of the recipient on the target chain\n     */\n    struct TargetMessage {\n        uint256 actionId;\n        address sourceSender;\n        uint256 vaultType;\n        address targetTokenAddress;\n        SwapInfo targetSwapInfo;\n        address targetRecipient;\n    }\n}\n"

    },

    "contracts/interfaces/ITokenBalance.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.19;\n\n/**\n * @title ITokenBalance\n * @notice Token balance interface\n */\ninterface ITokenBalance {\n    /**\n     * @notice Getter of the token balance by the account\n     * @param _account The account address\n     * @return Token balance\n     */\n    function balanceOf(address _account) external view returns (uint256);\n}\n"

    },

    "contracts/interfaces/IVault.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.19;\n\n/**\n * @title IVault\n * @notice Vault interface\n */\ninterface IVault {\n    /**\n     * @notice The getter of the vault asset address\n     */\n    function asset() external view returns (address);\n\n    /**\n     * @notice Checks the status of the variable token and balance actions and the variable token address\n     * @return The address of the variable token\n     */\n    function checkVariableTokenState() external view returns (address);\n\n    /**\n     * @notice Requests the vault asset tokens\n     * @param _amount The amount of the vault asset tokens\n     * @param _to The address of the vault asset tokens receiver\n     * @param _forVariableBalance True if the request is made for a variable balance repayment, otherwise false\n     * @return assetAddress The address of the vault asset token\n     */\n    function requestAsset(\n        uint256 _amount,\n        address _to,\n        bool _forVariableBalance\n    ) external returns (address assetAddress);\n}\n"

    },

    "contracts/Pausable.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.19;\n\nimport { Pausable as PausableBase } from '@openzeppelin/contracts/security/Pausable.sol';\nimport { ManagerRole } from './roles/ManagerRole.sol';\n\n/**\n * @title Pausable\n * @notice Base contract that implements the emergency pause mechanism\n */\nabstract contract Pausable is PausableBase, ManagerRole {\n    /**\n     * @notice Enter pause state\n     */\n    function pause() external onlyManager whenNotPaused {\n        _pause();\n    }\n\n    /**\n     * @notice Exit pause state\n     */\n    function unpause() external onlyManager whenPaused {\n        _unpause();\n    }\n}\n"

    },

    "contracts/roles/AssetSpenderRole.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.19;\n\nimport { RoleBearers } from './RoleBearers.sol';\n\n/**\n * @title AssetSpenderRole\n * @notice Base contract that implements the Asset Spender role\n */\nabstract contract AssetSpenderRole is RoleBearers {\n    bytes32 private constant ROLE_KEY = keccak256('AssetSpender');\n\n    /**\n     * @notice Emitted when the Asset Spender role status for the account is updated\n     * @param account The account address\n     * @param value The Asset Spender role status flag\n     */\n    event SetAssetSpender(address indexed account, bool indexed value);\n\n    /**\n     * @notice Emitted when the caller is not an Asset Spender role bearer\n     */\n    error OnlyAssetSpenderError();\n\n    /**\n     * @dev Modifier to check if the caller is an Asset Spender role bearer\n     */\n    modifier onlyAssetSpender() {\n        if (!isAssetSpender(msg.sender)) {\n            revert OnlyAssetSpenderError();\n        }\n\n        _;\n    }\n\n    /**\n     * @notice Getter of the Asset Spender role bearer count\n     * @return The Asset Spender role bearer count\n     */\n    function assetSpenderCount() external view returns (uint256) {\n        return _roleBearerCount(ROLE_KEY);\n    }\n\n    /**\n     * @notice Getter of the complete list of the Asset Spender role bearers\n     * @return The complete list of the Asset Spender role bearers\n     */\n    function fullAssetSpenderList() external view returns (address[] memory) {\n        return _fullRoleBearerList(ROLE_KEY);\n    }\n\n    /**\n     * @notice Getter of the Asset Spender role bearer status\n     * @param _account The account address\n     */\n    function isAssetSpender(address _account) public view returns (bool) {\n        return _isRoleBearer(ROLE_KEY, _account);\n    }\n\n    function _setAssetSpender(address _account, bool _value) internal {\n        _setRoleBearer(ROLE_KEY, _account, _value);\n\n        emit SetAssetSpender(_account, _value);\n    }\n}\n"

    },

    "contracts/roles/ManagerRole.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.19;\n\nimport { Ownable } from '@openzeppelin/contracts/access/Ownable.sol';\nimport { RoleBearers } from './RoleBearers.sol';\n\n/**\n * @title ManagerRole\n * @notice Base contract that implements the Manager role.\n * The manager role is a high-permission role for core team members only.\n * Managers can set vaults and routers addresses, fees, cross-chain protocols,\n * and other parameters for Interchain (cross-chain) swaps and single-network swaps.\n * Please note, the manager role is unique for every contract,\n * hence different addresses may be assigned as managers for different contracts.\n */\nabstract contract ManagerRole is Ownable, RoleBearers {\n    bytes32 private constant ROLE_KEY = keccak256('Manager');\n\n    /**\n     * @notice Emitted when the Manager role status for the account is updated\n     * @param account The account address\n     * @param value The Manager role status flag\n     */\n    event SetManager(address indexed account, bool indexed value);\n\n    /**\n     * @notice Emitted when the Manager role status for the account is renounced\n     * @param account The account address\n     */\n    event RenounceManagerRole(address indexed account);\n\n    /**\n     * @notice Emitted when the caller is not a Manager role bearer\n     */\n    error OnlyManagerError();\n\n    /**\n     * @dev Modifier to check if the caller is a Manager role bearer\n     */\n    modifier onlyManager() {\n        if (!isManager(msg.sender)) {\n            revert OnlyManagerError();\n        }\n\n        _;\n    }\n\n    /**\n     * @notice Updates the Manager role status for the account\n     * @param _account The account address\n     * @param _value The Manager role status flag\n     */\n    function setManager(address _account, bool _value) public onlyOwner {\n        _setRoleBearer(ROLE_KEY, _account, _value);\n\n        emit SetManager(_account, _value);\n    }\n\n    /**\n     * @notice Renounces the Manager role\n     */\n    function renounceManagerRole() external onlyManager {\n        _setRoleBearer(ROLE_KEY, msg.sender, false);\n\n        emit RenounceManagerRole(msg.sender);\n    }\n\n    /**\n     * @notice Getter of the Manager role bearer count\n     * @return The Manager role bearer count\n     */\n    function managerCount() external view returns (uint256) {\n        return _roleBearerCount(ROLE_KEY);\n    }\n\n    /**\n     * @notice Getter of the complete list of the Manager role bearers\n     * @return The complete list of the Manager role bearers\n     */\n    function fullManagerList() external view returns (address[] memory) {\n        return _fullRoleBearerList(ROLE_KEY);\n    }\n\n    /**\n     * @notice Getter of the Manager role bearer status\n     * @param _account The account address\n     */\n    function isManager(address _account) public view returns (bool) {\n        return _isRoleBearer(ROLE_KEY, _account);\n    }\n\n    function _initRoles(\n        address _owner,\n        address[] memory _managers,\n        bool _addOwnerToManagers\n    ) internal {\n        address ownerAddress = _owner == address(0) ? msg.sender : _owner;\n\n        for (uint256 index; index < _managers.length; index++) {\n            setManager(_managers[index], true);\n        }\n\n        if (_addOwnerToManagers && !isManager(ownerAddress)) {\n            setManager(ownerAddress, true);\n        }\n\n        if (ownerAddress != msg.sender) {\n            transferOwnership(ownerAddress);\n        }\n    }\n}\n"

    },

    "contracts/roles/RoleBearers.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.19;\n\nimport '../Constants.sol' as Constants;\nimport '../DataStructures.sol' as DataStructures;\n\n/**\n * @title RoleBearers\n * @notice Base contract that implements role-based access control\n * @dev A custom implementation providing full role bearer lists\n */\nabstract contract RoleBearers {\n    mapping(bytes32 /*roleKey*/ => address[] /*roleBearers*/) private roleBearerTable;\n    mapping(bytes32 /*roleKey*/ => mapping(address /*account*/ => DataStructures.OptionalValue /*status*/))\n        private roleBearerIndexTable;\n\n    function _setRoleBearer(bytes32 _roleKey, address _account, bool _value) internal {\n        DataStructures.uniqueAddressListUpdate(\n            roleBearerTable[_roleKey],\n            roleBearerIndexTable[_roleKey],\n            _account,\n            _value,\n            Constants.LIST_SIZE_LIMIT_DEFAULT\n        );\n    }\n\n    function _isRoleBearer(bytes32 _roleKey, address _account) internal view returns (bool) {\n        return roleBearerIndexTable[_roleKey][_account].isSet;\n    }\n\n    function _roleBearerCount(bytes32 _roleKey) internal view returns (uint256) {\n        return roleBearerTable[_roleKey].length;\n    }\n\n    function _fullRoleBearerList(bytes32 _roleKey) internal view returns (address[] memory) {\n        return roleBearerTable[_roleKey];\n    }\n}\n"

    },

    "contracts/SystemVersionId.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.19;\n\n/**\n * @title SystemVersionId\n * @notice Base contract providing the system version identifier\n */\nabstract contract SystemVersionId {\n    /**\n     * @dev The system version identifier\n     */\n    uint256 public constant SYSTEM_VERSION_ID = uint256(keccak256('Circle CCTP - 2023-06-24'));\n}\n"

    }

  },

  "settings": {

    "optimizer": {

      "enabled": true,

      "runs": 200

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "libraries": {}

  }

}}