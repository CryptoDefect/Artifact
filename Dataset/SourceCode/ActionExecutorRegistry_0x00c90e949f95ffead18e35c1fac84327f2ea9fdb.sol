{{

  "language": "Solidity",

  "sources": {

    "@openzeppelin/contracts/access/Ownable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/Context.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"

    },

    "contracts/ActionExecutorRegistry.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.19;\n\nimport { IRegistry } from './interfaces/IRegistry.sol';\nimport { BalanceManagement } from './BalanceManagement.sol';\nimport { SystemVersionId } from './SystemVersionId.sol';\nimport { TargetGasReserve } from './crosschain/TargetGasReserve.sol';\nimport './helpers/AddressHelper.sol' as AddressHelper;\nimport './helpers/DecimalsHelper.sol' as DecimalsHelper;\nimport './Constants.sol' as Constants;\nimport './DataStructures.sol' as DataStructures;\n\n/**\n * @title ActionExecutorRegistry\n * @notice The contract for action settings\n */\ncontract ActionExecutorRegistry is SystemVersionId, TargetGasReserve, BalanceManagement, IRegistry {\n    /**\n     * @dev Registered cross-chain gateway addresses by type\n     */\n    mapping(uint256 /*gatewayType*/ => address /*gatewayAddress*/) public gatewayMap;\n\n    /**\n     * @dev Registered cross-chain gateway types\n     */\n    uint256[] public gatewayTypeList;\n\n    /**\n     * @dev Registered cross-chain gateway type indices\n     */\n    mapping(uint256 /*gatewayType*/ => DataStructures.OptionalValue /*gatewayTypeIndex*/)\n        public gatewayTypeIndexMap;\n\n    /**\n     * @dev Registered cross-chain gateway flags by address\n     */\n    mapping(address /*account*/ => bool /*isGateway*/) public isGatewayAddress;\n\n    /**\n     * @dev Registered swap router addresses by type\n     */\n    mapping(uint256 /*routerType*/ => address /*routerAddress*/) public routerMap;\n\n    /**\n     * @dev Registered swap router types\n     */\n    uint256[] public routerTypeList;\n\n    /**\n     * @dev Registered swap router type indices\n     */\n    mapping(uint256 /*routerType*/ => DataStructures.OptionalValue /*routerTypeIndex*/)\n        public routerTypeIndexMap;\n\n    /**\n     * @dev Registered swap router transfer addresses by router type\n     */\n    mapping(uint256 /*routerType*/ => address /*routerTransferAddress*/) public routerTransferMap;\n\n    /**\n     * @dev Registered vault addresses by type\n     */\n    mapping(uint256 /*vaultType*/ => address /*vaultAddress*/) public vaultMap;\n\n    /**\n     * @dev Registered vault types\n     */\n    uint256[] public vaultTypeList;\n\n    /**\n     * @dev Registered vault-type indices\n     */\n    mapping(uint256 /*vaultType*/ => DataStructures.OptionalValue /*vaultTypeIndex*/)\n        public vaultTypeIndexMap;\n\n    /**\n     * @dev Registered non-default decimal values by vault type\n     */\n    mapping(uint256 /*vaultType*/ => mapping(uint256 /*chainId*/ => DataStructures.OptionalValue /*vaultDecimals*/))\n        public vaultDecimalsTable;\n\n    /**\n     * @dev Chain IDs of registered vault decimal values\n     */\n    uint256[] public vaultDecimalsChainIdList;\n\n    /**\n     * @dev Chain ID indices of registered vault decimal values\n     */\n    mapping(uint256 /*chainId*/ => DataStructures.OptionalValue /*chainIdIndex*/)\n        public vaultDecimalsChainIdIndexMap;\n\n    /**\n     * @dev The system fee value (cross-chain swaps) in milli-percent, e.g., 100 is 0.1%\n     */\n    uint256 public systemFee;\n\n    /**\n     * @dev The system fee value (single-chain swaps) in milli-percent, e.g., 100 is 0.1%\n     */\n    uint256 public systemFeeLocal;\n\n    /**\n     * @dev The address of the cross-chain action fee collector\n     */\n    address public feeCollector;\n\n    /**\n     * @dev The address of the single-chain action fee collector\n     */\n    address public feeCollectorLocal;\n\n    /**\n     * @dev The list of accounts that can perform actions without fees and amount restrictions\n     */\n    address[] public whitelist;\n\n    /**\n     * @dev The whitelist account indices\n     */\n    mapping(address /*account*/ => DataStructures.OptionalValue /*whitelistIndex*/)\n        public whitelistIndexMap;\n\n    /**\n     * @dev The minimum cross-chain swap amount in USD, with decimals = 18\n     */\n    uint256 public swapAmountMin = 0;\n\n    /**\n     * @dev The maximum cross-chain swap amount in USD, with decimals = 18. Is type(uint256).max for unlimited amount\n     */\n    uint256 public swapAmountMax = Constants.INFINITY;\n\n    uint256 private constant VAULT_DECIMALS_CHAIN_ID_WILDCARD = 0;\n    uint256 private constant SYSTEM_FEE_LIMIT = 10_000; // Maximum system fee in milli-percent = 10%\n    uint256 private constant SYSTEM_FEE_INITIAL = 100; // Initial system fee in milli-percent = 0.1%\n\n    /**\n     * @notice Emitted when a registered cross-chain gateway contract address is added or updated\n     * @param gatewayType The type of the registered cross-chain gateway\n     * @param gatewayAddress The address of the registered cross-chain gateway contract\n     */\n    event SetGateway(uint256 indexed gatewayType, address indexed gatewayAddress);\n\n    /**\n     * @notice Emitted when a registered cross-chain gateway contract address is removed\n     * @param gatewayType The type of the removed cross-chain gateway\n     */\n    event RemoveGateway(uint256 indexed gatewayType);\n\n    /**\n     * @notice Emitted when a registered vault contract address is added or updated\n     * @param vaultType The type of the registered vault\n     * @param vaultAddress The address of the registered vault contract\n     */\n    event SetVault(uint256 indexed vaultType, address indexed vaultAddress);\n\n    /**\n     * @notice Emitted when a registered vault contract address is removed\n     * @param vaultType The type of the removed vault\n     */\n    event RemoveVault(uint256 indexed vaultType);\n\n    /**\n     * @notice Emitted when vault decimal values are set\n     * @param vaultType The type of the vault\n     * @param decimalsData The vault decimal values\n     */\n    event SetVaultDecimals(uint256 indexed vaultType, DataStructures.KeyToValue[] decimalsData);\n\n    /**\n     * @notice Emitted when vault decimal values are unset\n     * @param vaultType The type of the vault\n     */\n    event UnsetVaultDecimals(uint256 indexed vaultType, uint256[] chainIds);\n\n    /**\n     * @notice Emitted when a registered swap router contract address is added or updated\n     * @param routerType The type of the registered swap router\n     * @param routerAddress The address of the registered swap router contract\n     */\n    event SetRouter(uint256 indexed routerType, address indexed routerAddress);\n\n    /**\n     * @notice Emitted when a registered swap router contract address is removed\n     * @param routerType The type of the removed swap router\n     */\n    event RemoveRouter(uint256 indexed routerType);\n\n    /**\n     * @notice Emitted when a registered swap router transfer contract address is set\n     * @param routerType The type of the swap router\n     * @param routerTransfer The address of the swap router transfer contract\n     */\n    event SetRouterTransfer(uint256 indexed routerType, address indexed routerTransfer);\n\n    /**\n     * @notice Emitted when the system fee value (cross-chain swaps) is set\n     * @param systemFee The system fee value in milli-percent, e.g., 100 is 0.1%\n     */\n    event SetSystemFee(uint256 systemFee);\n\n    /**\n     * @notice Emitted when the system fee value (single-chain swaps) is set\n     * @param systemFeeLocal The system fee value in milli-percent, e.g., 100 is 0.1%\n     */\n    event SetSystemFeeLocal(uint256 systemFeeLocal);\n\n    /**\n     * @notice Emitted when the address of the cross-chain action fee collector is set\n     * @param feeCollector The address of the cross-chain action fee collector\n     */\n    event SetFeeCollector(address indexed feeCollector);\n\n    /**\n     * @notice Emitted when the address of the single-chain action fee collector is set\n     * @param feeCollector The address of the single-chain action fee collector\n     */\n    event SetFeeCollectorLocal(address indexed feeCollector);\n\n    /**\n     * @notice Emitted when the whitelist is updated\n     * @param whitelistAddress The added or removed account address\n     * @param value The flag of account inclusion\n     */\n    event SetWhitelist(address indexed whitelistAddress, bool indexed value);\n\n    /**\n     * @notice Emitted when the minimum cross-chain swap amount is set\n     * @param value The minimum swap amount in USD, with decimals = 18\n     */\n    event SetSwapAmountMin(uint256 value);\n\n    /**\n     * @notice Emitted when the maximum cross-chain swap amount is set\n     * @dev Is type(uint256).max for unlimited amount\n     * @param value The maximum swap amount in USD, with decimals = 18\n     */\n    event SetSwapAmountMax(uint256 value);\n\n    /**\n     * @notice Emitted when the specified cross-chain gateway address is duplicate\n     */\n    error DuplicateGatewayAddressError();\n\n    /**\n     * @notice Emitted when the requested cross-chain gateway type is not set\n     */\n    error GatewayNotSetError();\n\n    /**\n     * @notice Emitted when the requested swap router type is not set\n     */\n    error RouterNotSetError();\n\n    /**\n     * @notice Emitted when the specified swap amount maximum is less than the current minimum\n     */\n    error SwapAmountMaxLessThanMinError();\n\n    /**\n     * @notice Emitted when the specified swap amount minimum is greater than the current maximum\n     */\n    error SwapAmountMinGreaterThanMaxError();\n\n    /**\n     * @notice Emitted when the specified system fee percentage value is greater than the allowed maximum\n     */\n    error SystemFeeValueError();\n\n    /**\n     * @notice Emitted when the requested vault type is not set\n     */\n    error VaultNotSetError();\n\n    /**\n     * @notice Deploys the ActionExecutorRegistry contract\n     * @param _gateways Initial values of cross-chain gateway types and addresses\n     * @param _feeCollector The initial address of the cross-chain action fee collector\n     * @param _feeCollectorLocal The initial address of the single-chain action fee collector\n     * @param _targetGasReserve The initial gas reserve value for target chain action processing\n     * @param _owner The address of the initial owner of the contract\n     * @param _managers The addresses of initial managers of the contract\n     * @param _addOwnerToManagers The flag to optionally add the owner to the list of managers\n     */\n    constructor(\n        DataStructures.KeyToAddressValue[] memory _gateways,\n        address _feeCollector,\n        address _feeCollectorLocal,\n        uint256 _targetGasReserve,\n        address _owner,\n        address[] memory _managers,\n        bool _addOwnerToManagers\n    ) {\n        for (uint256 index; index < _gateways.length; index++) {\n            DataStructures.KeyToAddressValue memory item = _gateways[index];\n\n            _setGateway(item.key, item.value);\n        }\n\n        _setSystemFee(SYSTEM_FEE_INITIAL);\n        _setSystemFeeLocal(SYSTEM_FEE_INITIAL);\n\n        _setFeeCollector(_feeCollector);\n        _setFeeCollectorLocal(_feeCollectorLocal);\n\n        _setTargetGasReserve(_targetGasReserve);\n\n        _initRoles(_owner, _managers, _addOwnerToManagers);\n    }\n\n    /**\n     * @notice Adds or updates a registered cross-chain gateway contract address\n     * @param _gatewayType The type of the registered cross-chain gateway\n     * @param _gatewayAddress The address of the registered cross-chain gateway contract\n     */\n    function setGateway(uint256 _gatewayType, address _gatewayAddress) external onlyManager {\n        _setGateway(_gatewayType, _gatewayAddress);\n    }\n\n    /**\n     * @notice Removes a registered cross-chain gateway contract address\n     * @param _gatewayType The type of the removed cross-chain gateway\n     */\n    function removeGateway(uint256 _gatewayType) external onlyManager {\n        address gatewayAddress = gatewayMap[_gatewayType];\n\n        if (gatewayAddress == address(0)) {\n            revert GatewayNotSetError();\n        }\n\n        DataStructures.combinedMapRemove(\n            gatewayMap,\n            gatewayTypeList,\n            gatewayTypeIndexMap,\n            _gatewayType\n        );\n\n        delete isGatewayAddress[gatewayAddress];\n\n        emit RemoveGateway(_gatewayType);\n    }\n\n    /**\n     * @notice Adds or updates registered swap router contract addresses\n     * @param _routers Types and addresses of swap routers\n     */\n    function setRouters(DataStructures.KeyToAddressValue[] calldata _routers) external onlyManager {\n        for (uint256 index; index < _routers.length; index++) {\n            DataStructures.KeyToAddressValue calldata item = _routers[index];\n\n            _setRouter(item.key, item.value);\n        }\n    }\n\n    /**\n     * @notice Removes registered swap router contract addresses\n     * @param _routerTypes Types of swap routers\n     */\n    function removeRouters(uint256[] calldata _routerTypes) external onlyManager {\n        for (uint256 index; index < _routerTypes.length; index++) {\n            uint256 routerType = _routerTypes[index];\n\n            _removeRouter(routerType);\n        }\n    }\n\n    /**\n     * @notice Adds or updates a registered swap router transfer contract address\n     * @dev Zero address can be used to remove a router transfer contract\n     * @param _routerType The type of the swap router\n     * @param _routerTransfer The address of the swap router transfer contract\n     */\n    function setRouterTransfer(uint256 _routerType, address _routerTransfer) external onlyManager {\n        if (routerMap[_routerType] == address(0)) {\n            revert RouterNotSetError();\n        }\n\n        AddressHelper.requireContractOrZeroAddress(_routerTransfer);\n\n        routerTransferMap[_routerType] = _routerTransfer;\n\n        emit SetRouterTransfer(_routerType, _routerTransfer);\n    }\n\n    /**\n     * @notice Adds or updates a registered vault contract address\n     * @param _vaultType The type of the registered vault\n     * @param _vaultAddress The address of the registered vault contract\n     */\n    function setVault(uint256 _vaultType, address _vaultAddress) external onlyManager {\n        AddressHelper.requireContract(_vaultAddress);\n\n        DataStructures.combinedMapSet(\n            vaultMap,\n            vaultTypeList,\n            vaultTypeIndexMap,\n            _vaultType,\n            _vaultAddress,\n            Constants.LIST_SIZE_LIMIT_DEFAULT\n        );\n\n        emit SetVault(_vaultType, _vaultAddress);\n    }\n\n    /**\n     * @notice Removes a registered vault contract address\n     * @param _vaultType The type of the registered vault\n     */\n    function removeVault(uint256 _vaultType) external onlyManager {\n        DataStructures.combinedMapRemove(vaultMap, vaultTypeList, vaultTypeIndexMap, _vaultType);\n\n        // - - - Vault decimals table cleanup - - -\n\n        delete vaultDecimalsTable[_vaultType][VAULT_DECIMALS_CHAIN_ID_WILDCARD];\n\n        uint256 chainIdListLength = vaultDecimalsChainIdList.length;\n\n        for (uint256 index; index < chainIdListLength; index++) {\n            uint256 chainId = vaultDecimalsChainIdList[index];\n\n            delete vaultDecimalsTable[_vaultType][chainId];\n        }\n\n        // - - -\n\n        emit RemoveVault(_vaultType);\n    }\n\n    /**\n     * @notice Sets vault decimal values\n     * @param _vaultType The type of the vault\n     * @param _decimalsData The vault decimal values\n     */\n    function setVaultDecimals(\n        uint256 _vaultType,\n        DataStructures.KeyToValue[] calldata _decimalsData\n    ) external onlyManager {\n        if (vaultMap[_vaultType] == address(0)) {\n            revert VaultNotSetError();\n        }\n\n        for (uint256 index; index < _decimalsData.length; index++) {\n            DataStructures.KeyToValue calldata decimalsDataItem = _decimalsData[index];\n\n            uint256 chainId = decimalsDataItem.key;\n\n            if (chainId != VAULT_DECIMALS_CHAIN_ID_WILDCARD) {\n                DataStructures.uniqueListAdd(\n                    vaultDecimalsChainIdList,\n                    vaultDecimalsChainIdIndexMap,\n                    chainId,\n                    Constants.LIST_SIZE_LIMIT_DEFAULT\n                );\n            }\n\n            vaultDecimalsTable[_vaultType][chainId] = DataStructures.OptionalValue(\n                true,\n                decimalsDataItem.value\n            );\n        }\n\n        emit SetVaultDecimals(_vaultType, _decimalsData);\n    }\n\n    /**\n     * @notice Unsets vault decimal values\n     * @param _vaultType The type of the vault\n     * @param _chainIds Chain IDs of registered vault decimal values\n     */\n    function unsetVaultDecimals(\n        uint256 _vaultType,\n        uint256[] calldata _chainIds\n    ) external onlyManager {\n        if (vaultMap[_vaultType] == address(0)) {\n            revert VaultNotSetError();\n        }\n\n        for (uint256 index; index < _chainIds.length; index++) {\n            uint256 chainId = _chainIds[index];\n            delete vaultDecimalsTable[_vaultType][chainId];\n        }\n\n        emit UnsetVaultDecimals(_vaultType, _chainIds);\n    }\n\n    /**\n     * @notice Sets the system fee value (cross-chain swaps)\n     * @param _systemFee The system fee value in milli-percent, e.g., 100 is 0.1%\n     */\n    function setSystemFee(uint256 _systemFee) external onlyManager {\n        _setSystemFee(_systemFee);\n    }\n\n    /**\n     * @notice Sets the system fee value (single-chain swaps)\n     * @param _systemFeeLocal The system fee value in milli-percent, e.g., 100 is 0.1%\n     */\n    function setSystemFeeLocal(uint256 _systemFeeLocal) external onlyManager {\n        _setSystemFeeLocal(_systemFeeLocal);\n    }\n\n    /**\n     * @notice Sets the address of the cross-chain action fee collector\n     * @param _feeCollector The address of the cross-chain action fee collector\n     */\n    function setFeeCollector(address _feeCollector) external onlyManager {\n        _setFeeCollector(_feeCollector);\n    }\n\n    /**\n     * @notice Sets the address of the single-chain action fee collector\n     * @param _feeCollector The address of the single-chain action fee collector\n     */\n    function setFeeCollectorLocal(address _feeCollector) external onlyManager {\n        _setFeeCollectorLocal(_feeCollector);\n    }\n\n    /**\n     * @notice Updates the whitelist\n     * @param _whitelistAddress The added or removed account address\n     * @param _value The flag of account inclusion\n     */\n    function setWhitelist(address _whitelistAddress, bool _value) external onlyManager {\n        DataStructures.uniqueAddressListUpdate(\n            whitelist,\n            whitelistIndexMap,\n            _whitelistAddress,\n            _value,\n            Constants.LIST_SIZE_LIMIT_DEFAULT\n        );\n\n        emit SetWhitelist(_whitelistAddress, _value);\n    }\n\n    /**\n     * @notice Sets the minimum cross-chain swap amount\n     * @param _value The minimum swap amount in USD, with decimals = 18\n     */\n    function setSwapAmountMin(uint256 _value) external onlyManager {\n        if (_value > swapAmountMax) {\n            revert SwapAmountMinGreaterThanMaxError();\n        }\n\n        swapAmountMin = _value;\n\n        emit SetSwapAmountMin(_value);\n    }\n\n    /**\n     * @notice Sets the maximum cross-chain swap amount\n     * @dev Use type(uint256).max value for unlimited amount\n     * @param _value The maximum swap amount in USD, with decimals = 18\n     */\n    function setSwapAmountMax(uint256 _value) external onlyManager {\n        if (_value < swapAmountMin) {\n            revert SwapAmountMaxLessThanMinError();\n        }\n\n        swapAmountMax = _value;\n\n        emit SetSwapAmountMax(_value);\n    }\n\n    /**\n     * @notice Settings for a single-chain swap\n     * @param _caller The user's account address\n     * @param _routerType The type of the swap router\n     * @return Settings for a single-chain swap\n     */\n    function localSettings(\n        address _caller,\n        uint256 _routerType\n    ) external view returns (LocalSettings memory) {\n        (address router, address routerTransfer) = _routerAddresses(_routerType);\n\n        return\n            LocalSettings({\n                router: router,\n                routerTransfer: routerTransfer,\n                systemFeeLocal: systemFeeLocal,\n                feeCollectorLocal: feeCollectorLocal,\n                isWhitelist: isWhitelist(_caller)\n            });\n    }\n\n    /**\n     * @notice Getter of source chain settings for a cross-chain swap\n     * @param _caller The user's account address\n     * @param _targetChainId The target chain ID\n     * @param _gatewayType The type of the cross-chain gateway\n     * @param _routerType The type of the swap router\n     * @param _vaultType The type of the vault\n     * @return Source chain settings for a cross-chain swap\n     */\n    function sourceSettings(\n        address _caller,\n        uint256 _targetChainId,\n        uint256 _gatewayType,\n        uint256 _routerType,\n        uint256 _vaultType\n    ) external view returns (SourceSettings memory) {\n        (address router, address routerTransfer) = _routerAddresses(_routerType);\n\n        return\n            SourceSettings({\n                gateway: gatewayMap[_gatewayType],\n                router: router,\n                routerTransfer: routerTransfer,\n                vault: vaultMap[_vaultType],\n                sourceVaultDecimals: vaultDecimals(_vaultType, block.chainid),\n                targetVaultDecimals: vaultDecimals(_vaultType, _targetChainId),\n                systemFee: systemFee,\n                feeCollector: feeCollector,\n                isWhitelist: isWhitelist(_caller),\n                swapAmountMin: swapAmountMin,\n                swapAmountMax: swapAmountMax\n            });\n    }\n\n    /**\n     * @notice Getter of target chain settings for a cross-chain swap\n     * @param _vaultType The type of the vault\n     * @param _routerType The type of the swap router\n     * @return Target chain settings for a cross-chain swap\n     */\n    function targetSettings(\n        uint256 _vaultType,\n        uint256 _routerType\n    ) external view returns (TargetSettings memory) {\n        (address router, address routerTransfer) = _routerAddresses(_routerType);\n\n        return\n            TargetSettings({\n                router: router,\n                routerTransfer: routerTransfer,\n                vault: vaultMap[_vaultType],\n                gasReserve: targetGasReserve\n            });\n    }\n\n    /**\n     * @notice Getter of variable balance repayment settings\n     * @param _vaultType The type of the vault\n     * @return Variable balance repayment settings\n     */\n    function variableBalanceRepaymentSettings(\n        uint256 _vaultType\n    ) external view returns (VariableBalanceRepaymentSettings memory) {\n        return VariableBalanceRepaymentSettings({ vault: vaultMap[_vaultType] });\n    }\n\n    /**\n     * @notice Getter of cross-chain message fee estimation settings\n     * @param _gatewayType The type of the cross-chain gateway\n     * @return Cross-chain message fee estimation settings\n     */\n    function messageFeeEstimateSettings(\n        uint256 _gatewayType\n    ) external view returns (MessageFeeEstimateSettings memory) {\n        return MessageFeeEstimateSettings({ gateway: gatewayMap[_gatewayType] });\n    }\n\n    /**\n     * @notice Getter of swap result calculation settings for a single-chain swap\n     * @param _caller The user's account address\n     * @return Swap result calculation settings for a single-chain swap\n     */\n    function localAmountCalculationSettings(\n        address _caller\n    ) external view returns (LocalAmountCalculationSettings memory) {\n        return\n            LocalAmountCalculationSettings({\n                systemFeeLocal: systemFeeLocal,\n                isWhitelist: isWhitelist(_caller)\n            });\n    }\n\n    /**\n     * @notice Getter of swap result calculation settings for a cross-chain swap\n     * @param _caller The user's account address\n     * @param _vaultType The type of the vault\n     * @param _fromChainId The ID of the swap source chain\n     * @param _toChainId The ID of the swap target chain\n     * @return Swap result calculation settings for a cross-chain swap\n     */\n    function vaultAmountCalculationSettings(\n        address _caller,\n        uint256 _vaultType,\n        uint256 _fromChainId,\n        uint256 _toChainId\n    ) external view returns (VaultAmountCalculationSettings memory) {\n        return\n            VaultAmountCalculationSettings({\n                fromDecimals: vaultDecimals(_vaultType, _fromChainId),\n                toDecimals: vaultDecimals(_vaultType, _toChainId),\n                systemFee: systemFee,\n                isWhitelist: isWhitelist(_caller)\n            });\n    }\n\n    /**\n     * @notice Getter of amount limits in USD for cross-chain swaps\n     * @param _vaultType The type of the vault\n     * @return min Minimum cross-chain swap amount in USD, with decimals = 18\n     * @return max Maximum cross-chain swap amount in USD, with decimals = 18\n     */\n    function swapAmountLimits(uint256 _vaultType) external view returns (uint256 min, uint256 max) {\n        if (swapAmountMin == 0 && swapAmountMax == Constants.INFINITY) {\n            min = 0;\n            max = Constants.INFINITY;\n        } else {\n            uint256 toDecimals = vaultDecimals(_vaultType, block.chainid);\n\n            min = (swapAmountMin == 0)\n                ? 0\n                : DecimalsHelper.convertDecimals(\n                    Constants.DECIMALS_DEFAULT,\n                    toDecimals,\n                    swapAmountMin\n                );\n\n            max = (swapAmountMax == Constants.INFINITY)\n                ? Constants.INFINITY\n                : DecimalsHelper.convertDecimals(\n                    Constants.DECIMALS_DEFAULT,\n                    toDecimals,\n                    swapAmountMax\n                );\n        }\n    }\n\n    /**\n     * @notice Getter of registered cross-chain gateway type count\n     * @return Registered cross-chain gateway type count\n     */\n    function gatewayTypeCount() external view returns (uint256) {\n        return gatewayTypeList.length;\n    }\n\n    /**\n     * @notice Getter of the complete list of registered cross-chain gateway types\n     * @return The complete list of registered cross-chain gateway types\n     */\n    function fullGatewayTypeList() external view returns (uint256[] memory) {\n        return gatewayTypeList;\n    }\n\n    /**\n     * @notice Getter of registered swap router type count\n     * @return Registered swap router type count\n     */\n    function routerTypeCount() external view returns (uint256) {\n        return routerTypeList.length;\n    }\n\n    /**\n     * @notice Getter of the complete list of registered swap router types\n     * @return The complete list of registered swap router types\n     */\n    function fullRouterTypeList() external view returns (uint256[] memory) {\n        return routerTypeList;\n    }\n\n    /**\n     * @notice Getter of registered vault type count\n     * @return Registered vault type count\n     */\n    function vaultTypeCount() external view returns (uint256) {\n        return vaultTypeList.length;\n    }\n\n    /**\n     * @notice Getter of the complete list of registered vault types\n     * @return The complete list of registered vault types\n     */\n    function fullVaultTypeList() external view returns (uint256[] memory) {\n        return vaultTypeList;\n    }\n\n    /**\n     * @notice Getter of registered vault decimals chain ID count\n     * @return Registered vault decimals chain ID count\n     */\n    function vaultDecimalsChainIdCount() external view returns (uint256) {\n        return vaultDecimalsChainIdList.length;\n    }\n\n    /**\n     * @notice Getter of the complete list of registered vault decimals chain IDs\n     * @return The complete list of registered vault decimals chain IDs\n     */\n    function fullVaultDecimalsChainIdList() external view returns (uint256[] memory) {\n        return vaultDecimalsChainIdList;\n    }\n\n    /**\n     * @notice Getter of registered whitelist entry count\n     * @return Registered whitelist entry count\n     */\n    function whitelistCount() external view returns (uint256) {\n        return whitelist.length;\n    }\n\n    /**\n     * @notice Getter of the full whitelist content\n     * @return Full whitelist content\n     */\n    function fullWhitelist() external view returns (address[] memory) {\n        return whitelist;\n    }\n\n    /**\n     * @notice Getter of a whitelist flag\n     * @param _account The account address\n     * @return The whitelist flag\n     */\n    function isWhitelist(address _account) public view returns (bool) {\n        return whitelistIndexMap[_account].isSet;\n    }\n\n    /**\n     * @notice Getter of vault decimals value\n     * @param _vaultType The type of the vault\n     * @param _chainId The vault chain ID\n     * @return Vault decimals value\n     */\n    function vaultDecimals(uint256 _vaultType, uint256 _chainId) public view returns (uint256) {\n        DataStructures.OptionalValue storage optionalValue = vaultDecimalsTable[_vaultType][\n            _chainId\n        ];\n\n        if (optionalValue.isSet) {\n            return optionalValue.value;\n        }\n\n        DataStructures.OptionalValue storage wildcardOptionalValue = vaultDecimalsTable[_vaultType][\n            VAULT_DECIMALS_CHAIN_ID_WILDCARD\n        ];\n\n        if (wildcardOptionalValue.isSet) {\n            return wildcardOptionalValue.value;\n        }\n\n        return Constants.DECIMALS_DEFAULT;\n    }\n\n    function _setGateway(uint256 _gatewayType, address _gatewayAddress) private {\n        address previousGatewayAddress = gatewayMap[_gatewayType];\n\n        if (_gatewayAddress != previousGatewayAddress) {\n            if (isGatewayAddress[_gatewayAddress]) {\n                revert DuplicateGatewayAddressError(); // The address is set for another gateway type\n            }\n\n            AddressHelper.requireContract(_gatewayAddress);\n\n            DataStructures.combinedMapSet(\n                gatewayMap,\n                gatewayTypeList,\n                gatewayTypeIndexMap,\n                _gatewayType,\n                _gatewayAddress,\n                Constants.LIST_SIZE_LIMIT_DEFAULT\n            );\n\n            if (previousGatewayAddress != address(0)) {\n                delete isGatewayAddress[previousGatewayAddress];\n            }\n\n            isGatewayAddress[_gatewayAddress] = true;\n        }\n\n        emit SetGateway(_gatewayType, _gatewayAddress);\n    }\n\n    function _setRouter(uint256 _routerType, address _routerAddress) private {\n        AddressHelper.requireContract(_routerAddress);\n\n        DataStructures.combinedMapSet(\n            routerMap,\n            routerTypeList,\n            routerTypeIndexMap,\n            _routerType,\n            _routerAddress,\n            Constants.LIST_SIZE_LIMIT_ROUTERS\n        );\n\n        emit SetRouter(_routerType, _routerAddress);\n    }\n\n    function _removeRouter(uint256 _routerType) private {\n        DataStructures.combinedMapRemove(\n            routerMap,\n            routerTypeList,\n            routerTypeIndexMap,\n            _routerType\n        );\n\n        delete routerTransferMap[_routerType];\n\n        emit RemoveRouter(_routerType);\n    }\n\n    function _setSystemFee(uint256 _systemFee) private {\n        if (_systemFee > SYSTEM_FEE_LIMIT) {\n            revert SystemFeeValueError();\n        }\n\n        systemFee = _systemFee;\n\n        emit SetSystemFee(_systemFee);\n    }\n\n    function _setSystemFeeLocal(uint256 _systemFeeLocal) private {\n        if (_systemFeeLocal > SYSTEM_FEE_LIMIT) {\n            revert SystemFeeValueError();\n        }\n\n        systemFeeLocal = _systemFeeLocal;\n\n        emit SetSystemFeeLocal(_systemFeeLocal);\n    }\n\n    function _setFeeCollector(address _feeCollector) private {\n        feeCollector = _feeCollector;\n\n        emit SetFeeCollector(_feeCollector);\n    }\n\n    function _setFeeCollectorLocal(address _feeCollector) private {\n        feeCollectorLocal = _feeCollector;\n\n        emit SetFeeCollectorLocal(_feeCollector);\n    }\n\n    function _routerAddresses(\n        uint256 _routerType\n    ) private view returns (address router, address routerTransfer) {\n        router = routerMap[_routerType];\n        routerTransfer = routerTransferMap[_routerType];\n\n        if (routerTransfer == address(0)) {\n            routerTransfer = router;\n        }\n    }\n}\n"

    },

    "contracts/BalanceManagement.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.19;\n\nimport { ITokenBalance } from './interfaces/ITokenBalance.sol';\nimport { ManagerRole } from './roles/ManagerRole.sol';\nimport './helpers/TransferHelper.sol' as TransferHelper;\nimport './Constants.sol' as Constants;\n\n/**\n * @title BalanceManagement\n * @notice Base contract for the withdrawal of tokens, except for reserved ones\n */\nabstract contract BalanceManagement is ManagerRole {\n    /**\n     * @notice Emitted when the specified token is reserved\n     */\n    error ReservedTokenError();\n\n    /**\n     * @notice Performs the withdrawal of tokens, except for reserved ones\n     * @dev Use the \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\" address for the native token\n     * @param _tokenAddress The address of the token\n     * @param _tokenAmount The amount of the token\n     */\n    function cleanup(address _tokenAddress, uint256 _tokenAmount) external onlyManager {\n        if (isReservedToken(_tokenAddress)) {\n            revert ReservedTokenError();\n        }\n\n        if (_tokenAddress == Constants.NATIVE_TOKEN_ADDRESS) {\n            TransferHelper.safeTransferNative(msg.sender, _tokenAmount);\n        } else {\n            TransferHelper.safeTransfer(_tokenAddress, msg.sender, _tokenAmount);\n        }\n    }\n\n    /**\n     * @notice Getter of the token balance of the current contract\n     * @dev Use the \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\" address for the native token\n     * @param _tokenAddress The address of the token\n     * @return The token balance of the current contract\n     */\n    function tokenBalance(address _tokenAddress) public view returns (uint256) {\n        if (_tokenAddress == Constants.NATIVE_TOKEN_ADDRESS) {\n            return address(this).balance;\n        } else {\n            return ITokenBalance(_tokenAddress).balanceOf(address(this));\n        }\n    }\n\n    /**\n     * @notice Getter of the reserved token flag\n     * @dev Override to add reserved token addresses\n     * @param _tokenAddress The address of the token\n     * @return The reserved token flag\n     */\n    function isReservedToken(address _tokenAddress) public view virtual returns (bool) {\n        // The function returns false by default.\n        // The explicit return statement is omitted to avoid the unused parameter warning.\n        // See https://github.com/ethereum/solidity/issues/5295\n    }\n}\n"

    },

    "contracts/Constants.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.19;\n\n/**\n * @dev The default token decimals value\n */\nuint256 constant DECIMALS_DEFAULT = 18;\n\n/**\n * @dev The maximum uint256 value for swap amount limit settings\n */\nuint256 constant INFINITY = type(uint256).max;\n\n/**\n * @dev The default limit of account list size\n */\nuint256 constant LIST_SIZE_LIMIT_DEFAULT = 100;\n\n/**\n * @dev The limit of swap router list size\n */\nuint256 constant LIST_SIZE_LIMIT_ROUTERS = 200;\n\n/**\n * @dev The factor for percentage settings. Example: 100 is 0.1%\n */\nuint256 constant MILLIPERCENT_FACTOR = 100_000;\n\n/**\n * @dev The de facto standard address to denote the native token\n */\naddress constant NATIVE_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n"

    },

    "contracts/crosschain/TargetGasReserve.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.19;\n\nimport { ManagerRole } from '../roles/ManagerRole.sol';\n\n/**\n * @title TargetGasReserve\n * @notice Base contract that implements the gas reserve logic for the target chain actions\n */\nabstract contract TargetGasReserve is ManagerRole {\n    /**\n     * @dev The target chain gas reserve value\n     */\n    uint256 public targetGasReserve;\n\n    /**\n     * @notice Emitted when the target chain gas reserve value is set\n     * @param gasReserve The target chain gas reserve value\n     */\n    event SetTargetGasReserve(uint256 gasReserve);\n\n    /**\n     * @notice Sets the target chain gas reserve value\n     * @param _gasReserve The target chain gas reserve value\n     */\n    function setTargetGasReserve(uint256 _gasReserve) external onlyManager {\n        _setTargetGasReserve(_gasReserve);\n    }\n\n    function _setTargetGasReserve(uint256 _gasReserve) internal virtual {\n        targetGasReserve = _gasReserve;\n\n        emit SetTargetGasReserve(_gasReserve);\n    }\n}\n"

    },

    "contracts/DataStructures.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.19;\n\n/**\n * @notice Optional value structure\n * @dev Is used in mappings to allow zero values\n * @param isSet Value presence flag\n * @param value Numeric value\n */\nstruct OptionalValue {\n    bool isSet;\n    uint256 value;\n}\n\n/**\n * @notice Key-to-value structure\n * @dev Is used as an array parameter item to perform multiple key-value settings\n * @param key Numeric key\n * @param value Numeric value\n */\nstruct KeyToValue {\n    uint256 key;\n    uint256 value;\n}\n\n/**\n * @notice Key-to-value structure for address values\n * @dev Is used as an array parameter item to perform multiple key-value settings with address values\n * @param key Numeric key\n * @param value Address value\n */\nstruct KeyToAddressValue {\n    uint256 key;\n    address value;\n}\n\n/**\n * @notice Address-to-flag structure\n * @dev Is used as an array parameter item to perform multiple settings\n * @param account Account address\n * @param flag Flag value\n */\nstruct AccountToFlag {\n    address account;\n    bool flag;\n}\n\n/**\n * @notice Emitted when a list exceeds the size limit\n */\nerror ListSizeLimitError();\n\n/**\n * @notice Sets or updates a value in a combined map (a mapping with a key list and key index mapping)\n * @param _map The mapping reference\n * @param _keyList The key list reference\n * @param _keyIndexMap The key list index mapping reference\n * @param _key The numeric key\n * @param _value The address value\n * @param _sizeLimit The map and list size limit\n * @return isNewKey True if the key was just added, otherwise false\n */\nfunction combinedMapSet(\n    mapping(uint256 => address) storage _map,\n    uint256[] storage _keyList,\n    mapping(uint256 => OptionalValue) storage _keyIndexMap,\n    uint256 _key,\n    address _value,\n    uint256 _sizeLimit\n) returns (bool isNewKey) {\n    isNewKey = !_keyIndexMap[_key].isSet;\n\n    if (isNewKey) {\n        uniqueListAdd(_keyList, _keyIndexMap, _key, _sizeLimit);\n    }\n\n    _map[_key] = _value;\n}\n\n/**\n * @notice Removes a value from a combined map (a mapping with a key list and key index mapping)\n * @param _map The mapping reference\n * @param _keyList The key list reference\n * @param _keyIndexMap The key list index mapping reference\n * @param _key The numeric key\n * @return isChanged True if the combined map was changed, otherwise false\n */\nfunction combinedMapRemove(\n    mapping(uint256 => address) storage _map,\n    uint256[] storage _keyList,\n    mapping(uint256 => OptionalValue) storage _keyIndexMap,\n    uint256 _key\n) returns (bool isChanged) {\n    isChanged = _keyIndexMap[_key].isSet;\n\n    if (isChanged) {\n        delete _map[_key];\n        uniqueListRemove(_keyList, _keyIndexMap, _key);\n    }\n}\n\n/**\n * @notice Adds a value to a unique value list (a list with value index mapping)\n * @param _list The list reference\n * @param _indexMap The value index mapping reference\n * @param _value The numeric value\n * @param _sizeLimit The list size limit\n * @return isChanged True if the list was changed, otherwise false\n */\nfunction uniqueListAdd(\n    uint256[] storage _list,\n    mapping(uint256 => OptionalValue) storage _indexMap,\n    uint256 _value,\n    uint256 _sizeLimit\n) returns (bool isChanged) {\n    isChanged = !_indexMap[_value].isSet;\n\n    if (isChanged) {\n        if (_list.length >= _sizeLimit) {\n            revert ListSizeLimitError();\n        }\n\n        _indexMap[_value] = OptionalValue(true, _list.length);\n        _list.push(_value);\n    }\n}\n\n/**\n * @notice Removes a value from a unique value list (a list with value index mapping)\n * @param _list The list reference\n * @param _indexMap The value index mapping reference\n * @param _value The numeric value\n * @return isChanged True if the list was changed, otherwise false\n */\nfunction uniqueListRemove(\n    uint256[] storage _list,\n    mapping(uint256 => OptionalValue) storage _indexMap,\n    uint256 _value\n) returns (bool isChanged) {\n    OptionalValue storage indexItem = _indexMap[_value];\n\n    isChanged = indexItem.isSet;\n\n    if (isChanged) {\n        uint256 itemIndex = indexItem.value;\n        uint256 lastIndex = _list.length - 1;\n\n        if (itemIndex != lastIndex) {\n            uint256 lastValue = _list[lastIndex];\n            _list[itemIndex] = lastValue;\n            _indexMap[lastValue].value = itemIndex;\n        }\n\n        _list.pop();\n        delete _indexMap[_value];\n    }\n}\n\n/**\n * @notice Adds a value to a unique address value list (a list with value index mapping)\n * @param _list The list reference\n * @param _indexMap The value index mapping reference\n * @param _value The address value\n * @param _sizeLimit The list size limit\n * @return isChanged True if the list was changed, otherwise false\n */\nfunction uniqueAddressListAdd(\n    address[] storage _list,\n    mapping(address => OptionalValue) storage _indexMap,\n    address _value,\n    uint256 _sizeLimit\n) returns (bool isChanged) {\n    isChanged = !_indexMap[_value].isSet;\n\n    if (isChanged) {\n        if (_list.length >= _sizeLimit) {\n            revert ListSizeLimitError();\n        }\n\n        _indexMap[_value] = OptionalValue(true, _list.length);\n        _list.push(_value);\n    }\n}\n\n/**\n * @notice Removes a value from a unique address value list (a list with value index mapping)\n * @param _list The list reference\n * @param _indexMap The value index mapping reference\n * @param _value The address value\n * @return isChanged True if the list was changed, otherwise false\n */\nfunction uniqueAddressListRemove(\n    address[] storage _list,\n    mapping(address => OptionalValue) storage _indexMap,\n    address _value\n) returns (bool isChanged) {\n    OptionalValue storage indexItem = _indexMap[_value];\n\n    isChanged = indexItem.isSet;\n\n    if (isChanged) {\n        uint256 itemIndex = indexItem.value;\n        uint256 lastIndex = _list.length - 1;\n\n        if (itemIndex != lastIndex) {\n            address lastValue = _list[lastIndex];\n            _list[itemIndex] = lastValue;\n            _indexMap[lastValue].value = itemIndex;\n        }\n\n        _list.pop();\n        delete _indexMap[_value];\n    }\n}\n\n/**\n * @notice Adds or removes a value to/from a unique address value list (a list with value index mapping)\n * @dev The list size limit is checked on items adding only\n * @param _list The list reference\n * @param _indexMap The value index mapping reference\n * @param _value The address value\n * @param _flag The value inclusion flag\n * @param _sizeLimit The list size limit\n * @return isChanged True if the list was changed, otherwise false\n */\nfunction uniqueAddressListUpdate(\n    address[] storage _list,\n    mapping(address => OptionalValue) storage _indexMap,\n    address _value,\n    bool _flag,\n    uint256 _sizeLimit\n) returns (bool isChanged) {\n    return\n        _flag\n            ? uniqueAddressListAdd(_list, _indexMap, _value, _sizeLimit)\n            : uniqueAddressListRemove(_list, _indexMap, _value);\n}\n"

    },

    "contracts/helpers/AddressHelper.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.19;\n\n/**\n * @notice Emitted when the account is not a contract\n * @param account The account address\n */\nerror NonContractAddressError(address account);\n\n/**\n * @notice Function to check if the account is a contract\n * @return The account contract status flag\n */\nfunction isContract(address _account) view returns (bool) {\n    return _account.code.length > 0;\n}\n\n/**\n * @notice Function to require an account to be a contract\n */\nfunction requireContract(address _account) view {\n    if (!isContract(_account)) {\n        revert NonContractAddressError(_account);\n    }\n}\n\n/**\n * @notice Function to require an account to be a contract or a zero address\n */\nfunction requireContractOrZeroAddress(address _account) view {\n    if (_account != address(0)) {\n        requireContract(_account);\n    }\n}\n"

    },

    "contracts/helpers/DecimalsHelper.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.19;\n\n/**\n * @notice Function to perform decimals conversion\n * @param _fromDecimals Source value decimals\n * @param _toDecimals Target value decimals\n * @param _fromAmount Source value\n * @return Target value\n */\nfunction convertDecimals(\n    uint256 _fromDecimals,\n    uint256 _toDecimals,\n    uint256 _fromAmount\n) pure returns (uint256) {\n    if (_toDecimals == _fromDecimals) {\n        return _fromAmount;\n    } else if (_toDecimals > _fromDecimals) {\n        return _fromAmount * 10 ** (_toDecimals - _fromDecimals);\n    } else {\n        return _fromAmount / 10 ** (_fromDecimals - _toDecimals);\n    }\n}\n"

    },

    "contracts/helpers/TransferHelper.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.19;\n\n/**\n * @notice Emitted when an approval action fails\n */\nerror SafeApproveError();\n\n/**\n * @notice Emitted when a transfer action fails\n */\nerror SafeTransferError();\n\n/**\n * @notice Emitted when a transferFrom action fails\n */\nerror SafeTransferFromError();\n\n/**\n * @notice Emitted when a transfer of the native token fails\n */\nerror SafeTransferNativeError();\n\n/**\n * @notice Safely approve the token to the account\n * @param _token The token address\n * @param _to The token approval recipient address\n * @param _value The token approval amount\n */\nfunction safeApprove(address _token, address _to, uint256 _value) {\n    // 0x095ea7b3 is the selector for \"approve(address,uint256)\"\n    (bool success, bytes memory data) = _token.call(\n        abi.encodeWithSelector(0x095ea7b3, _to, _value)\n    );\n\n    bool condition = success && (data.length == 0 || abi.decode(data, (bool)));\n\n    if (!condition) {\n        revert SafeApproveError();\n    }\n}\n\n/**\n * @notice Safely transfer the token to the account\n * @param _token The token address\n * @param _to The token transfer recipient address\n * @param _value The token transfer amount\n */\nfunction safeTransfer(address _token, address _to, uint256 _value) {\n    // 0xa9059cbb is the selector for \"transfer(address,uint256)\"\n    (bool success, bytes memory data) = _token.call(\n        abi.encodeWithSelector(0xa9059cbb, _to, _value)\n    );\n\n    bool condition = success && (data.length == 0 || abi.decode(data, (bool)));\n\n    if (!condition) {\n        revert SafeTransferError();\n    }\n}\n\n/**\n * @notice Safely transfer the token between the accounts\n * @param _token The token address\n * @param _from The token transfer source address\n * @param _to The token transfer recipient address\n * @param _value The token transfer amount\n */\nfunction safeTransferFrom(address _token, address _from, address _to, uint256 _value) {\n    // 0x23b872dd is the selector for \"transferFrom(address,address,uint256)\"\n    (bool success, bytes memory data) = _token.call(\n        abi.encodeWithSelector(0x23b872dd, _from, _to, _value)\n    );\n\n    bool condition = success && (data.length == 0 || abi.decode(data, (bool)));\n\n    if (!condition) {\n        revert SafeTransferFromError();\n    }\n}\n\n/**\n * @notice Safely transfer the native token to the account\n * @param _to The native token transfer recipient address\n * @param _value The native token transfer amount\n */\nfunction safeTransferNative(address _to, uint256 _value) {\n    (bool success, ) = _to.call{ value: _value }(new bytes(0));\n\n    if (!success) {\n        revert SafeTransferNativeError();\n    }\n}\n"

    },

    "contracts/interfaces/IRegistry.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.19;\n\nimport { ISettings } from './ISettings.sol';\n\ninterface IRegistry is ISettings {\n    /**\n     * @notice Getter of the registered gateway flag by the account address\n     * @param _account The account address\n     * @return The registered gateway flag\n     */\n    function isGatewayAddress(address _account) external view returns (bool);\n\n    /**\n     * @notice Settings for a single-chain swap\n     * @param _caller The user's account address\n     * @param _routerType The type of the swap router\n     * @return Settings for a single-chain swap\n     */\n    function localSettings(\n        address _caller,\n        uint256 _routerType\n    ) external view returns (LocalSettings memory);\n\n    /**\n     * @notice Getter of source chain settings for a cross-chain swap\n     * @param _caller The user's account address\n     * @param _targetChainId The target chain ID\n     * @param _gatewayType The type of the cross-chain gateway\n     * @param _routerType The type of the swap router\n     * @param _vaultType The type of the vault\n     * @return Source chain settings for a cross-chain swap\n     */\n    function sourceSettings(\n        address _caller,\n        uint256 _targetChainId,\n        uint256 _gatewayType,\n        uint256 _routerType,\n        uint256 _vaultType\n    ) external view returns (SourceSettings memory);\n\n    /**\n     * @notice Getter of target chain settings for a cross-chain swap\n     * @param _vaultType The type of the vault\n     * @param _routerType The type of the swap router\n     * @return Target chain settings for a cross-chain swap\n     */\n    function targetSettings(\n        uint256 _vaultType,\n        uint256 _routerType\n    ) external view returns (TargetSettings memory);\n\n    /**\n     * @notice Getter of variable balance repayment settings\n     * @param _vaultType The type of the vault\n     * @return Variable balance repayment settings\n     */\n    function variableBalanceRepaymentSettings(\n        uint256 _vaultType\n    ) external view returns (VariableBalanceRepaymentSettings memory);\n\n    /**\n     * @notice Getter of cross-chain message fee estimation settings\n     * @param _gatewayType The type of the cross-chain gateway\n     * @return Cross-chain message fee estimation settings\n     */\n    function messageFeeEstimateSettings(\n        uint256 _gatewayType\n    ) external view returns (MessageFeeEstimateSettings memory);\n\n    /**\n     * @notice Getter of swap result calculation settings for a single-chain swap\n     * @param _caller The user's account address\n     * @return Swap result calculation settings for a single-chain swap\n     */\n    function localAmountCalculationSettings(\n        address _caller\n    ) external view returns (LocalAmountCalculationSettings memory);\n\n    /**\n     * @notice Getter of swap result calculation settings for a cross-chain swap\n     * @param _caller The user's account address\n     * @param _vaultType The type of the vault\n     * @param _fromChainId The ID of the swap source chain\n     * @param _toChainId The ID of the swap target chain\n     * @return Swap result calculation settings for a cross-chain swap\n     */\n    function vaultAmountCalculationSettings(\n        address _caller,\n        uint256 _vaultType,\n        uint256 _fromChainId,\n        uint256 _toChainId\n    ) external view returns (VaultAmountCalculationSettings memory);\n\n    /**\n     * @notice Getter of amount limits in USD for cross-chain swaps\n     * @param _vaultType The type of the vault\n     * @return min Minimum cross-chain swap amount in USD, with decimals = 18\n     * @return max Maximum cross-chain swap amount in USD, with decimals = 18\n     */\n    function swapAmountLimits(uint256 _vaultType) external view returns (uint256 min, uint256 max);\n}\n"

    },

    "contracts/interfaces/ISettings.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.19;\n\n/**\n * @title ISettings\n * @notice Settings data structure declarations\n */\ninterface ISettings {\n    /**\n     * @notice Settings for a single-chain swap\n     * @param router The swap router contract address\n     * @param routerTransfer The swap router transfer contract address\n     * @param systemFeeLocal The system fee value in milli-percent, e.g., 100 is 0.1%\n     * @param feeCollectorLocal The address of the single-chain action fee collector\n     * @param isWhitelist The whitelist flag\n     */\n    struct LocalSettings {\n        address router;\n        address routerTransfer;\n        uint256 systemFeeLocal;\n        address feeCollectorLocal;\n        bool isWhitelist;\n    }\n\n    /**\n     * @notice Source chain settings for a cross-chain swap\n     * @param gateway The cross-chain gateway contract address\n     * @param router The swap router contract address\n     * @param routerTransfer The swap router transfer contract address\n     * @param vault The vault contract address\n     * @param sourceVaultDecimals The value of the vault decimals on the source chain\n     * @param targetVaultDecimals The value of the vault decimals on the target chain\n     * @param systemFee The system fee value in milli-percent, e.g., 100 is 0.1%\n     * @param feeCollector The address of the cross-chain action fee collector\n     * @param isWhitelist The whitelist flag\n     * @param swapAmountMin The minimum cross-chain swap amount in USD, with decimals = 18\n     * @param swapAmountMax The maximum cross-chain swap amount in USD, with decimals = 18\n     */\n    struct SourceSettings {\n        address gateway;\n        address router;\n        address routerTransfer;\n        address vault;\n        uint256 sourceVaultDecimals;\n        uint256 targetVaultDecimals;\n        uint256 systemFee;\n        address feeCollector;\n        bool isWhitelist;\n        uint256 swapAmountMin;\n        uint256 swapAmountMax;\n    }\n\n    /**\n     * @notice Target chain settings for a cross-chain swap\n     * @param router The swap router contract address\n     * @param routerTransfer The swap router transfer contract address\n     * @param vault The vault contract address\n     * @param gasReserve The target chain gas reserve value\n     */\n    struct TargetSettings {\n        address router;\n        address routerTransfer;\n        address vault;\n        uint256 gasReserve;\n    }\n\n    /**\n     * @notice Variable balance repayment settings\n     * @param vault The vault contract address\n     */\n    struct VariableBalanceRepaymentSettings {\n        address vault;\n    }\n\n    /**\n     * @notice Cross-chain message fee estimation settings\n     * @param gateway The cross-chain gateway contract address\n     */\n    struct MessageFeeEstimateSettings {\n        address gateway;\n    }\n\n    /**\n     * @notice Swap result calculation settings for a single-chain swap\n     * @param systemFee The system fee value in milli-percent, e.g., 100 is 0.1%\n     * @param isWhitelist The whitelist flag\n     */\n    struct LocalAmountCalculationSettings {\n        uint256 systemFeeLocal;\n        bool isWhitelist;\n    }\n\n    /**\n     * @notice Swap result calculation settings for a cross-chain swap\n     * @param fromDecimals The value of the vault decimals on the source chain\n     * @param toDecimals The value of the vault decimals on the target chain\n     * @param systemFee The system fee value in milli-percent, e.g., 100 is 0.1%\n     * @param isWhitelist The whitelist flag\n     */\n    struct VaultAmountCalculationSettings {\n        uint256 fromDecimals;\n        uint256 toDecimals;\n        uint256 systemFee;\n        bool isWhitelist;\n    }\n}\n"

    },

    "contracts/interfaces/ITokenBalance.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.19;\n\n/**\n * @title ITokenBalance\n * @notice Token balance interface\n */\ninterface ITokenBalance {\n    /**\n     * @notice Getter of the token balance by the account\n     * @param _account The account address\n     * @return Token balance\n     */\n    function balanceOf(address _account) external view returns (uint256);\n}\n"

    },

    "contracts/roles/ManagerRole.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.19;\n\nimport { Ownable } from '@openzeppelin/contracts/access/Ownable.sol';\nimport { RoleBearers } from './RoleBearers.sol';\n\n/**\n * @title ManagerRole\n * @notice Base contract that implements the Manager role.\n * The manager role is a high-permission role for core team members only.\n * Managers can set vaults and routers addresses, fees, cross-chain protocols,\n * and other parameters for Interchain (cross-chain) swaps and single-network swaps.\n * Please note, the manager role is unique for every contract,\n * hence different addresses may be assigned as managers for different contracts.\n */\nabstract contract ManagerRole is Ownable, RoleBearers {\n    bytes32 private constant ROLE_KEY = keccak256('Manager');\n\n    /**\n     * @notice Emitted when the Manager role status for the account is updated\n     * @param account The account address\n     * @param value The Manager role status flag\n     */\n    event SetManager(address indexed account, bool indexed value);\n\n    /**\n     * @notice Emitted when the Manager role status for the account is renounced\n     * @param account The account address\n     */\n    event RenounceManagerRole(address indexed account);\n\n    /**\n     * @notice Emitted when the caller is not a Manager role bearer\n     */\n    error OnlyManagerError();\n\n    /**\n     * @dev Modifier to check if the caller is a Manager role bearer\n     */\n    modifier onlyManager() {\n        if (!isManager(msg.sender)) {\n            revert OnlyManagerError();\n        }\n\n        _;\n    }\n\n    /**\n     * @notice Updates the Manager role status for the account\n     * @param _account The account address\n     * @param _value The Manager role status flag\n     */\n    function setManager(address _account, bool _value) public onlyOwner {\n        _setRoleBearer(ROLE_KEY, _account, _value);\n\n        emit SetManager(_account, _value);\n    }\n\n    /**\n     * @notice Renounces the Manager role\n     */\n    function renounceManagerRole() external onlyManager {\n        _setRoleBearer(ROLE_KEY, msg.sender, false);\n\n        emit RenounceManagerRole(msg.sender);\n    }\n\n    /**\n     * @notice Getter of the Manager role bearer count\n     * @return The Manager role bearer count\n     */\n    function managerCount() external view returns (uint256) {\n        return _roleBearerCount(ROLE_KEY);\n    }\n\n    /**\n     * @notice Getter of the complete list of the Manager role bearers\n     * @return The complete list of the Manager role bearers\n     */\n    function fullManagerList() external view returns (address[] memory) {\n        return _fullRoleBearerList(ROLE_KEY);\n    }\n\n    /**\n     * @notice Getter of the Manager role bearer status\n     * @param _account The account address\n     */\n    function isManager(address _account) public view returns (bool) {\n        return _isRoleBearer(ROLE_KEY, _account);\n    }\n\n    function _initRoles(\n        address _owner,\n        address[] memory _managers,\n        bool _addOwnerToManagers\n    ) internal {\n        address ownerAddress = _owner == address(0) ? msg.sender : _owner;\n\n        for (uint256 index; index < _managers.length; index++) {\n            setManager(_managers[index], true);\n        }\n\n        if (_addOwnerToManagers && !isManager(ownerAddress)) {\n            setManager(ownerAddress, true);\n        }\n\n        if (ownerAddress != msg.sender) {\n            transferOwnership(ownerAddress);\n        }\n    }\n}\n"

    },

    "contracts/roles/RoleBearers.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.19;\n\nimport '../Constants.sol' as Constants;\nimport '../DataStructures.sol' as DataStructures;\n\n/**\n * @title RoleBearers\n * @notice Base contract that implements role-based access control\n * @dev A custom implementation providing full role bearer lists\n */\nabstract contract RoleBearers {\n    mapping(bytes32 /*roleKey*/ => address[] /*roleBearers*/) private roleBearerTable;\n    mapping(bytes32 /*roleKey*/ => mapping(address /*account*/ => DataStructures.OptionalValue /*status*/))\n        private roleBearerIndexTable;\n\n    function _setRoleBearer(bytes32 _roleKey, address _account, bool _value) internal {\n        DataStructures.uniqueAddressListUpdate(\n            roleBearerTable[_roleKey],\n            roleBearerIndexTable[_roleKey],\n            _account,\n            _value,\n            Constants.LIST_SIZE_LIMIT_DEFAULT\n        );\n    }\n\n    function _isRoleBearer(bytes32 _roleKey, address _account) internal view returns (bool) {\n        return roleBearerIndexTable[_roleKey][_account].isSet;\n    }\n\n    function _roleBearerCount(bytes32 _roleKey) internal view returns (uint256) {\n        return roleBearerTable[_roleKey].length;\n    }\n\n    function _fullRoleBearerList(bytes32 _roleKey) internal view returns (address[] memory) {\n        return roleBearerTable[_roleKey];\n    }\n}\n"

    },

    "contracts/SystemVersionId.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity 0.8.19;\n\n/**\n * @title SystemVersionId\n * @notice Base contract providing the system version identifier\n */\nabstract contract SystemVersionId {\n    /**\n     * @dev The system version identifier\n     */\n    uint256 public constant SYSTEM_VERSION_ID = uint256(keccak256('Circle CCTP - 2023-06-24'));\n}\n"

    }

  },

  "settings": {

    "optimizer": {

      "enabled": true,

      "runs": 200

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "libraries": {}

  }

}}