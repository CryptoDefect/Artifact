/**

 *Submitted for verification at Etherscan.io on 2023-07-25

*/



// SPDX-License-Identifier: MIT

pragma solidity ^0.8.4;





interface IExtendedResolver {

    function resolve(bytes memory name, bytes memory data) external view returns(bytes memory);

}



interface IResolverService {

    function resolve(bytes calldata name, bytes calldata data) external view returns(bytes memory result, uint64 expires, bytes memory sig);

}



interface SupplementalResolver {

    function namehash(string memory name) external view returns(bytes32);

}



interface IENS {

    function setRecord(bytes32 node, address owner, address resolver, uint64 ttl) external;

    function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external;

    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external returns(bytes32);

    function setResolver(bytes32 node, address resolver) external;

    function setOwner(bytes32 node, address owner) external;

    function setTTL(bytes32 node, uint64 ttl) external;

    function setApprovalForAll(address operator, bool approved) external;

    function owner(bytes32 node) external view returns (address);

    function resolver(bytes32 node) external view returns (address);

    function ttl(bytes32 node) external view returns (uint64);

    function recordExists(bytes32 node) external view returns (bool);

    function isApprovedForAll(address owner, address operator) external view returns (bool);

}



interface IResolver {

    function setABI(bytes32 node, uint256 contentType, bytes calldata data) external;

    function setAddr(bytes32 node, address addr) external;

    function setAddr(bytes32 node, uint coinType, bytes calldata a) external;

    function setContenthash(bytes32 node, bytes calldata hash) external;

    function setDnsrr(bytes32 node, bytes calldata data) external;

    function setName(bytes32 node, string calldata _name) external;

    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external;

    function setText(bytes32 node, string calldata key, string calldata value) external;

    function setInterface(bytes32 node, bytes4 interfaceID, address implementer) external;

    function multicall(bytes[] calldata data) external returns(bytes[] memory results);

}





interface ISupportsInterface {

    function supportsInterface(bytes4 interfaceID) external pure returns(bool);

}



interface IERC165 {

    /**

     * @dev Returns true if this contract implements the interface defined by

     * `interfaceId`. See the corresponding

     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]

     * to learn more about how these ids are created.

     *

     * This function call must use less than 30 000 gas.

     */

    function supportsInterface(bytes4 interfaceId) external view returns (bool);

}



abstract contract ERC165 is IERC165 {

    /**

     * @dev See {IERC165-supportsInterface}.

     */

    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {

        return interfaceId == type(IERC165).interfaceId;

    }

}



interface IERC1155Receiver is IERC165 {

    /**

     * @dev Handles the receipt of a single ERC1155 token type. This function is

     * called at the end of a `safeTransferFrom` after the balance has been updated.

     *

     * NOTE: To accept the transfer, this must return

     * `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`

     * (i.e. 0xf23a6e61, or its own function selector).

     *

     * @param operator The address which initiated the transfer (i.e. msg.sender)

     * @param from The address which previously owned the token

     * @param id The ID of the token being transferred

     * @param value The amount of tokens being transferred

     * @param data Additional data with no specified format

     * @return `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` if transfer is allowed

     */

    function onERC1155Received(

        address operator,

        address from,

        uint256 id,

        uint256 value,

        bytes calldata data

    ) external returns (bytes4);



    /**

     * @dev Handles the receipt of a multiple ERC1155 token types. This function

     * is called at the end of a `safeBatchTransferFrom` after the balances have

     * been updated.

     *

     * NOTE: To accept the transfer(s), this must return

     * `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`

     * (i.e. 0xbc197c81, or its own function selector).

     *

     * @param operator The address which initiated the batch transfer (i.e. msg.sender)

     * @param from The address which previously owned the token

     * @param ids An array containing ids of each token being transferred (order and length must match values array)

     * @param values An array containing amounts of each token being transferred (order and length must match ids array)

     * @param data Additional data with no specified format

     * @return `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))` if transfer is allowed

     */

    function onERC1155BatchReceived(

        address operator,

        address from,

        uint256[] calldata ids,

        uint256[] calldata values,

        bytes calldata data

    ) external returns (bytes4);

}



abstract contract ERC1155Receiver is ERC165, IERC1155Receiver {

    /**

     * @dev See {IERC165-supportsInterface}.

     */

    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {

        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);

    }

}



contract ERC1155Holder is ERC1155Receiver {

    function onERC1155Received(

        address,

        address,

        uint256,

        uint256,

        bytes memory

    ) public virtual override returns (bytes4) {

        return this.onERC1155Received.selector;

    }



    function onERC1155BatchReceived(

        address,

        address,

        uint256[] memory,

        uint256[] memory,

        bytes memory

    ) public virtual override returns (bytes4) {

        return this.onERC1155BatchReceived.selector;

    }

}

interface ICreatorCore is IERC165 {

    event ExtensionRegistered(address indexed extension, address indexed sender);

    event ExtensionUnregistered(address indexed extension, address indexed sender);

    event ExtensionBlacklisted(address indexed extension, address indexed sender);

    event MintPermissionsUpdated(address indexed extension, address indexed permissions, address indexed sender);

    event RoyaltiesUpdated(uint256 indexed tokenId, address payable[] receivers, uint256[] basisPoints);

    event DefaultRoyaltiesUpdated(address payable[] receivers, uint256[] basisPoints);

    event ApproveTransferUpdated(address extension);

    event ExtensionRoyaltiesUpdated(address indexed extension, address payable[] receivers, uint256[] basisPoints);

    event ExtensionApproveTransferUpdated(address indexed extension, bool enabled);

    /**

     * @dev gets address of all extensions

     */

    function getExtensions() external view returns (address[] memory);

    /**

     * @dev add an extension.  Can only be called by contract owner or admin.

     * extension address must point to a contract implementing ICreatorExtension.

     * Returns True if newly added, False if already added.

     */

    function registerExtension(address extension, string calldata baseURI) external;

    /**

     * @dev add an extension.  Can only be called by contract owner or admin.

     * extension address must point to a contract implementing ICreatorExtension.

     * Returns True if newly added, False if already added.

     */

    function registerExtension(address extension, string calldata baseURI, bool baseURIIdentical) external;

    /**

     * @dev add an extension.  Can only be called by contract owner or admin.

     * Returns True if removed, False if already removed.

     */

    function unregisterExtension(address extension) external;

    /**

     * @dev blacklist an extension.  Can only be called by contract owner or admin.

     * This function will destroy all ability to reference the metadata of any tokens created

     * by the specified extension. It will also unregister the extension if needed.

     * Returns True if removed, False if already removed.

     */

    function blacklistExtension(address extension) external;

    /**

     * @dev set the baseTokenURI of an extension.  Can only be called by extension.

     */

    function setBaseTokenURIExtension(string calldata uri) external;

    /**

     * @dev set the baseTokenURI of an extension.  Can only be called by extension.

     * For tokens with no uri configured, tokenURI will return "uri+tokenId"

     */

    function setBaseTokenURIExtension(string calldata uri, bool identical) external;

    /**

     * @dev set the common prefix of an extension.  Can only be called by extension.

     * If configured, and a token has a uri set, tokenURI will return "prefixURI+tokenURI"

     * Useful if you want to use ipfs/arweave

     */

    function setTokenURIPrefixExtension(string calldata prefix) external;

    /**

     * @dev set the tokenURI of a token extension.  Can only be called by extension that minted token.

     */

    function setTokenURIExtension(uint256 tokenId, string calldata uri) external;

    /**

     * @dev set the tokenURI of a token extension for multiple tokens.  Can only be called by extension that minted token.

     */

    function setTokenURIExtension(uint256[] memory tokenId, string[] calldata uri) external;

    /**

     * @dev set the baseTokenURI for tokens with no extension.  Can only be called by owner/admin.

     * For tokens with no uri configured, tokenURI will return "uri+tokenId"

     */

    function setBaseTokenURI(string calldata uri) external;

    /**

     * @dev set the common prefix for tokens with no extension.  Can only be called by owner/admin.

     * If configured, and a token has a uri set, tokenURI will return "prefixURI+tokenURI"

     * Useful if you want to use ipfs/arweave

     */

    function setTokenURIPrefix(string calldata prefix) external;

    /**

     * @dev set the tokenURI of a token with no extension.  Can only be called by owner/admin.

     */

    function setTokenURI(uint256 tokenId, string calldata uri) external;

    /**

     * @dev set the tokenURI of multiple tokens with no extension.  Can only be called by owner/admin.

     */

    function setTokenURI(uint256[] memory tokenIds, string[] calldata uris) external;

    /**

     * @dev set a permissions contract for an extension.  Used to control minting.

     */

    function setMintPermissions(address extension, address permissions) external;

    /**

     * @dev Configure so transfers of tokens created by the caller (must be extension) gets approval

     * from the extension before transferring

     */

    function setApproveTransferExtension(bool enabled) external;

    /**

     * @dev get the extension of a given token

     */

    function tokenExtension(uint256 tokenId) external view returns (address);

    /**

     * @dev Set default royalties

     */

    function setRoyalties(address payable[] calldata receivers, uint256[] calldata basisPoints) external;

    /**

     * @dev Set royalties of a token

     */

    function setRoyalties(uint256 tokenId, address payable[] calldata receivers, uint256[] calldata basisPoints) external;

    /**

     * @dev Set royalties of an extension

     */

    function setRoyaltiesExtension(address extension, address payable[] calldata receivers, uint256[] calldata basisPoints) external;

    /**

     * @dev Get royalites of a token.  Returns list of receivers and basisPoints

     */

    function getRoyalties(uint256 tokenId) external view returns (address payable[] memory, uint256[] memory);

    // Royalty support for various other standards

    function getFeeRecipients(uint256 tokenId) external view returns (address payable[] memory);

    function getFeeBps(uint256 tokenId) external view returns (uint[] memory);

    function getFees(uint256 tokenId) external view returns (address payable[] memory, uint256[] memory);

    function royaltyInfo(uint256 tokenId, uint256 value) external view returns (address, uint256);

    /**

     * @dev Set the default approve transfer contract location.

     */

    function setApproveTransfer(address extension) external;

    /**

     * @dev Get the default approve transfer contract location.

     */

    function getApproveTransfer() external view returns (address);

}



interface IERC721CreatorCore is ICreatorCore {

    /**

     * @dev mint a token with no extension. Can only be called by an admin.

     * Returns tokenId minted

     */

    function mintBase(address to) external returns (uint256);

    /**

     * @dev mint a token with no extension. Can only be called by an admin.

     * Returns tokenId minted

     */

    function mintBase(address to, string calldata uri) external returns (uint256);

    /**

     * @dev batch mint a token with no extension. Can only be called by an admin.

     * Returns tokenId minted

     */

    function mintBaseBatch(address to, uint16 count) external returns (uint256[] memory);

    /**

     * @dev batch mint a token with no extension. Can only be called by an admin.

     * Returns tokenId minted

     */

    function mintBaseBatch(address to, string[] calldata uris) external returns (uint256[] memory);

    /**

     * @dev mint a token. Can only be called by a registered extension.

     * Returns tokenId minted

     */

    function mintExtension(address to) external returns (uint256);

    /**

     * @dev mint a token. Can only be called by a registered extension.

     * Returns tokenId minted

     */

    function mintExtension(address to, string calldata uri) external returns (uint256);

    /**

     * @dev mint a token. Can only be called by a registered extension.

     * Returns tokenId minted

     */

    function mintExtension(address to, uint80 data) external returns (uint256);

    /**

     * @dev batch mint a token. Can only be called by a registered extension.

     * Returns tokenIds minted

     */

    function mintExtensionBatch(address to, uint16 count) external returns (uint256[] memory);

    /**

     * @dev batch mint a token. Can only be called by a registered extension.

     * Returns tokenId minted

     */

    function mintExtensionBatch(address to, string[] calldata uris) external returns (uint256[] memory);

    /**

     * @dev batch mint a token. Can only be called by a registered extension.

     * Returns tokenId minted

     */

    function mintExtensionBatch(address to, uint80[] calldata data) external returns (uint256[] memory);

    /**

     * @dev burn a token. Can only be called by token owner or approved address.

     * On burn, calls back to the registered extension's onBurn method

     */

    function burn(uint256 tokenId) external;

    /**

     * @dev get token data

     */

    function tokenData(uint256 tokenId) external view returns (uint80);

}



interface IAdminControl is IERC165 {

    event AdminApproved(address indexed account, address indexed sender);

    event AdminRevoked(address indexed account, address indexed sender);

    /**

     * @dev gets address of all admins

     */

    function getAdmins() external view returns (address[] memory);

    /**

     * @dev add an admin.  Can only be called by contract owner.

     */

    function approveAdmin(address admin) external;

    /**

     * @dev remove an admin.  Can only be called by contract owner.

     */

    function revokeAdmin(address admin) external;

    /**

     * @dev checks whether or not given address is an admin

     * Returns True if they are

     */

    function isAdmin(address admin) external view returns (bool);

}



library ERC165Checker {

    // As per the EIP-165 spec, no interface should ever match 0xffffffff

    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;

    /**

     * @dev Returns true if `account` supports the {IERC165} interface,

     */

    function supportsERC165(address account) internal view returns (bool) {

        // Any contract that implements ERC165 must explicitly indicate support of

        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid

        return

            _supportsERC165Interface(account, type(IERC165).interfaceId) &&

            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);

    }

    /**

     * @dev Returns true if `account` supports the interface defined by

     * `interfaceId`. Support for {IERC165} itself is queried automatically.

     *

     * See {IERC165-supportsInterface}.

     */

    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {

        // query support of both ERC165 as per the spec and support of _interfaceId

        return supportsERC165(account) && _supportsERC165Interface(account, interfaceId);

    }

    /**

     * @dev Returns a boolean array where each value corresponds to the

     * interfaces passed in and whether they're supported or not. This allows

     * you to batch check interfaces for a contract where your expectation

     * is that some interfaces may not be supported.

     *

     * See {IERC165-supportsInterface}.

     *

     * _Available since v3.4._

     */

    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)

        internal

        view

        returns (bool[] memory)

    {

        // an array of booleans corresponding to interfaceIds and whether they're supported or not

        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);

        // query support of ERC165 itself

        if (supportsERC165(account)) {

            // query support of each interface in interfaceIds

            for (uint256 i = 0; i < interfaceIds.length; i++) {

                interfaceIdsSupported[i] = _supportsERC165Interface(account, interfaceIds[i]);

            }

        }

        return interfaceIdsSupported;

    }

    /**

     * @dev Returns true if `account` supports all the interfaces defined in

     * `interfaceIds`. Support for {IERC165} itself is queried automatically.

     *

     * Batch-querying can lead to gas savings by skipping repeated checks for

     * {IERC165} support.

     *

     * See {IERC165-supportsInterface}.

     */

    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {

        // query support of ERC165 itself

        if (!supportsERC165(account)) {

            return false;

        }

        // query support of each interface in _interfaceIds

        for (uint256 i = 0; i < interfaceIds.length; i++) {

            if (!_supportsERC165Interface(account, interfaceIds[i])) {

                return false;

            }

        }

        // all interfaces supported

        return true;

    }

    /**

     * @notice Query if a contract implements an interface, does not check ERC165 support

     * @param account The address of the contract to query for support of an interface

     * @param interfaceId The interface identifier, as specified in ERC-165

     * @return true if the contract at account indicates support of the interface with

     * identifier interfaceId, false otherwise

     * @dev Assumes that account contains a contract that supports ERC165, otherwise

     * the behavior of this method is undefined. This precondition can be checked

     * with {supportsERC165}.

     * Interface identification is specified in ERC-165.

     */

    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {

        // prepare call

        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);

        // perform static call

        bool success;

        uint256 returnSize;

        uint256 returnValue;

        assembly {

            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)

            returnSize := returndatasize()

            returnValue := mload(0x00)

        }

        return success && returnSize >= 0x20 && returnValue > 0;

    }

}



interface IERC721 is IERC165 {

    /**

     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.

     */

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);



    /**

     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.

     */

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);



    /**

     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.

     */

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);



    /**

     * @dev Returns the number of tokens in ``owner``'s account.

     */

    function balanceOf(address owner) external view returns (uint256 balance);



    /**

     * @dev Returns the owner of the `tokenId` token.

     *

     * Requirements:

     *

     * - `tokenId` must exist.

     */

    function ownerOf(uint256 tokenId) external view returns (address owner);



    /**

     * @dev Safely transfers `tokenId` token from `from` to `to`.

     *

     * Requirements:

     *

     * - `from` cannot be the zero address.

     * - `to` cannot be the zero address.

     * - `tokenId` token must exist and be owned by `from`.

     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.

     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.

     *

     * Emits a {Transfer} event.

     */

    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;



    /**

     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients

     * are aware of the ERC721 protocol to prevent tokens from being forever locked.

     *

     * Requirements:

     *

     * - `from` cannot be the zero address.

     * - `to` cannot be the zero address.

     * - `tokenId` token must exist and be owned by `from`.

     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.

     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.

     *

     * Emits a {Transfer} event.

     */

    function safeTransferFrom(address from, address to, uint256 tokenId) external;



    /**

     * @dev Transfers `tokenId` token from `from` to `to`.

     *

     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721

     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must

     * understand this adds an external call which potentially creates a reentrancy vulnerability.

     *

     * Requirements:

     *

     * - `from` cannot be the zero address.

     * - `to` cannot be the zero address.

     * - `tokenId` token must be owned by `from`.

     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.

     *

     * Emits a {Transfer} event.

     */

    function transferFrom(address from, address to, uint256 tokenId) external;



    /**

     * @dev Gives permission to `to` to transfer `tokenId` token to another account.

     * The approval is cleared when the token is transferred.

     *

     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.

     *

     * Requirements:

     *

     * - The caller must own the token or be an approved operator.

     * - `tokenId` must exist.

     *

     * Emits an {Approval} event.

     */

    function approve(address to, uint256 tokenId) external;



    /**

     * @dev Approve or remove `operator` as an operator for the caller.

     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.

     *

     * Requirements:

     *

     * - The `operator` cannot be the caller.

     *

     * Emits an {ApprovalForAll} event.

     */

    function setApprovalForAll(address operator, bool approved) external;



    /**

     * @dev Returns the account approved for `tokenId` token.

     *

     * Requirements:

     *

     * - `tokenId` must exist.

     */

    function getApproved(uint256 tokenId) external view returns (address operator);



    /**

     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.

     *

     * See {setApprovalForAll}

     */

    function isApprovedForAll(address owner, address operator) external view returns (bool);

}



interface IERC1155 is IERC165 {

    /**

     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.

     */

    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);



    /**

     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all

     * transfers.

     */

    event TransferBatch(

        address indexed operator,

        address indexed from,

        address indexed to,

        uint256[] ids,

        uint256[] values

    );



    /**

     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to

     * `approved`.

     */

    event ApprovalForAll(address indexed account, address indexed operator, bool approved);



    /**

     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.

     *

     * If an {URI} event was emitted for `id`, the standard

     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value

     * returned by {IERC1155MetadataURI-uri}.

     */

    event URI(string value, uint256 indexed id);



    /**

     * @dev Returns the amount of tokens of token type `id` owned by `account`.

     *

     * Requirements:

     *

     * - `account` cannot be the zero address.

     */

    function balanceOf(address account, uint256 id) external view returns (uint256);



    /**

     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.

     *

     * Requirements:

     *

     * - `accounts` and `ids` must have the same length.

     */

    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)

        external

        view

        returns (uint256[] memory);



    /**

     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,

     *

     * Emits an {ApprovalForAll} event.

     *

     * Requirements:

     *

     * - `operator` cannot be the caller.

     */

    function setApprovalForAll(address operator, bool approved) external;



    /**

     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.

     *

     * See {setApprovalForAll}.

     */

    function isApprovedForAll(address account, address operator) external view returns (bool);



    /**

     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.

     *

     * Emits a {TransferSingle} event.

     *

     * Requirements:

     *

     * - `to` cannot be the zero address.

     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.

     * - `from` must have a balance of tokens of type `id` of at least `amount`.

     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the

     * acceptance magic value.

     */

    function safeTransferFrom(

        address from,

        address to,

        uint256 id,

        uint256 amount,

        bytes calldata data

    ) external;



    /**

     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.

     *

     * Emits a {TransferBatch} event.

     *

     * Requirements:

     *

     * - `ids` and `amounts` must have the same length.

     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the

     * acceptance magic value.

     */

    function safeBatchTransferFrom(

        address from,

        address to,

        uint256[] calldata ids,

        uint256[] calldata amounts,

        bytes calldata data

    ) external;

}



interface INameWrapper is IERC1155 {

    event NameWrapped(

        bytes32 indexed node,

        bytes name,

        address owner,

        uint32 fuses,

        uint64 expiry

    );



    event NameUnwrapped(bytes32 indexed node, address owner);



    event FusesSet(bytes32 indexed node, uint32 fuses);

    event ExpiryExtended(bytes32 indexed node, uint64 expiry);



    function ens() external view returns (address);



    function supportsInterface(bytes4 interfaceID) external view returns (bool);



    function wrap(

        bytes calldata name,

        address wrappedOwner,

        address resolver

    ) external;



    function wrapETH2LD(

        string calldata label,

        address wrappedOwner,

        uint16 ownerControlledFuses,

        address resolver

    ) external returns (uint64 expires);



    function registerAndWrapETH2LD(

        string calldata label,

        address wrappedOwner,

        uint256 duration,

        address resolver,

        uint16 ownerControlledFuses

    ) external returns (uint256 registrarExpiry);



    function renew(

        uint256 labelHash,

        uint256 duration

    ) external returns (uint256 expires);



    function unwrap(bytes32 node, bytes32 label, address owner) external;



    function unwrapETH2LD(

        bytes32 label,

        address newRegistrant,

        address newController

    ) external;



    function upgrade(bytes calldata name, bytes calldata extraData) external;



    function setSubnodeRecord(

        bytes32 node,

        string calldata label,

        address owner,

        address resolver,

        uint64 ttl,

        uint32 fuses,

        uint64 expiry

    ) external returns (bytes32);



    function setRecord(

        bytes32 node,

        address owner,

        address resolver,

        uint64 ttl

    ) external;



    function setSubnodeOwner(

        bytes32 node,

        string calldata label,

        address newOwner,

        uint32 fuses,

        uint64 expiry

    ) external returns (bytes32);



    function extendExpiry(

        bytes32 node,

        bytes32 labelhash,

        uint64 expiry

    ) external returns (uint64);



    function canModifyName(

        bytes32 node,

        address addr

    ) external view returns (bool);



    function setResolver(bytes32 node, address resolver) external;



    function setTTL(bytes32 node, uint64 ttl) external;



    function ownerOf(uint256 id) external view returns (address owner);



    function approve(address to, uint256 tokenId) external;



    function getApproved(uint256 tokenId) external view returns (address);



    function getData(

        uint256 id

    ) external view returns (address, uint32, uint64);



    function uri(uint256 tokenId) external view returns (string memory);



    function isWrapped(bytes32) external view returns (bool);



    function isWrapped(bytes32, bytes32) external view returns (bool);

}





/// @notice Contract for EIP-712 typed structured data hashing and signing.

/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/EIP712.sol)

/// @author Modified from Solbase (https://github.com/Sol-DAO/solbase/blob/main/src/utils/EIP712.sol)

/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/EIP712.sol)

/// Note, this implementation:

/// - Uses `address(this)` for the `verifyingContract` field.

/// - Does NOT use the optional EIP-712 salt.

/// - Does NOT use any EIP-712 extensions.

/// This is for simplicity and to save gas.

/// If you need to customize, please fork / modify accordingly.

abstract contract EIP712 {

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                  CONSTANTS AND IMMUTABLES                  */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev `keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)")`.

    bytes32 internal constant _DOMAIN_TYPEHASH =

        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;



    address private immutable _cachedThis;

    uint256 private immutable _cachedChainId;

    bytes32 private immutable _cachedNameHash;

    bytes32 private immutable _cachedVersionHash;

    bytes32 private immutable _cachedDomainSeparator;



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                        CONSTRUCTOR                         */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Cache the hashes for cheaper runtime gas costs.

    /// In the case of upgradeable contracts (i.e. proxies),

    /// or if the chain id changes due to a hard fork,

    /// the domain separator will be seamlessly calculated on-the-fly.

    constructor() {

        _cachedThis = address(this);

        _cachedChainId = block.chainid;



        (string memory name, string memory version) = _domainNameAndVersion();

        bytes32 nameHash = keccak256(bytes(name));

        bytes32 versionHash = keccak256(bytes(version));

        _cachedNameHash = nameHash;

        _cachedVersionHash = versionHash;



        bytes32 separator;

        /// @solidity memory-safe-assembly

        assembly {

            let m := mload(0x40) // Load the free memory pointer.

            mstore(m, _DOMAIN_TYPEHASH)

            mstore(add(m, 0x20), nameHash)

            mstore(add(m, 0x40), versionHash)

            mstore(add(m, 0x60), chainid())

            mstore(add(m, 0x80), address())

            separator := keccak256(m, 0xa0)

        }

        _cachedDomainSeparator = separator;

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                   FUNCTIONS TO OVERRIDE                    */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Please override this function to return the domain name and version.

    /// ```

    ///     function _domainNameAndVersion()

    ///         internal

    ///         pure

    ///         virtual

    ///         returns (string memory name, string memory version)

    ///     {

    ///         name = "Solady";

    ///         version = "1";

    ///     }

    /// ```

    function _domainNameAndVersion()

        internal

        pure

        virtual

        returns (string memory name, string memory version);



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                     HASHING OPERATIONS                     */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Returns the EIP-712 domain separator.

    function _domainSeparator() internal view virtual returns (bytes32 separator) {

        separator = _cachedDomainSeparator;

        if (_cachedDomainSeparatorInvalidated()) {

            separator = _buildDomainSeparator();

        }

    }



    /// @dev Returns the hash of the fully encoded EIP-712 message for this domain,

    /// given `structHash`, as defined in

    /// https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct.

    ///

    /// The hash can be used together with {ECDSA-recover} to obtain the signer of a message:

    /// ```

    ///     bytes32 digest = _hashTypedData(keccak256(abi.encode(

    ///         keccak256("Mail(address to,string contents)"),

    ///         mailTo,

    ///         keccak256(bytes(mailContents))

    ///     )));

    ///     address signer = ECDSA.recover(digest, signature);

    /// ```

    function _hashTypedData(bytes32 structHash) internal view virtual returns (bytes32 digest) {

        bytes32 separator = _cachedDomainSeparator;

        if (_cachedDomainSeparatorInvalidated()) {

            separator = _buildDomainSeparator();

        }

        /// @solidity memory-safe-assembly

        assembly {

            // Compute the digest.

            mstore(0x00, 0x1901000000000000) // Store "\x19\x01".

            mstore(0x1a, separator) // Store the domain separator.

            mstore(0x3a, structHash) // Store the struct hash.

            digest := keccak256(0x18, 0x42)

            // Restore the part of the free memory slot that was overwritten.

            mstore(0x3a, 0)

        }

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                    EIP-5267 OPERATIONS                     */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev See: https://eips.ethereum.org/EIPS/eip-5267

    function eip712Domain()

        public

        view

        virtual

        returns (

            bytes1 fields,

            string memory name,

            string memory version,

            uint256 chainId,

            address verifyingContract,

            bytes32 salt,

            uint256[] memory extensions

        )

    {

        fields = hex"0f"; // `0b01111`.

        (name, version) = _domainNameAndVersion();

        chainId = block.chainid;

        verifyingContract = address(this);

        salt = salt; // `bytes32(0)`.

        extensions = extensions; // `new uint256[](0)`.

    }



    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/

    /*                      PRIVATE HELPERS                       */

    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/



    /// @dev Returns the EIP-712 domain separator.

    function _buildDomainSeparator() private view returns (bytes32 separator) {

        bytes32 nameHash = _cachedNameHash;

        bytes32 versionHash = _cachedVersionHash;

        /// @solidity memory-safe-assembly

        assembly {

            let m := mload(0x40) // Load the free memory pointer.

            mstore(m, _DOMAIN_TYPEHASH)

            mstore(add(m, 0x20), nameHash)

            mstore(add(m, 0x40), versionHash)

            mstore(add(m, 0x60), chainid())

            mstore(add(m, 0x80), address())

            separator := keccak256(m, 0xa0)

        }

    }



    /// @dev Returns if the cached domain separator has been invalidated.

    function _cachedDomainSeparatorInvalidated() private view returns (bool result) {

        uint256 cachedChainId = _cachedChainId;

        address cachedThis = _cachedThis;

        /// @solidity memory-safe-assembly

        assembly {

            result := iszero(and(eq(chainid(), cachedChainId), eq(address(), cachedThis)))

        }

    }

}





library Strings {

    bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";



    /**

     * @dev Converts a `uint256` to its ASCII `string` decimal representation.

     */

    function toString(uint256 value) internal pure returns (string memory) {

        // Inspired by OraclizeAPI's implementation - MIT licence

        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol



        if (value == 0) {

            return "0";

        }

        uint256 temp = value;

        uint256 digits;

        while (temp != 0) {

            digits++;

            temp /= 10;

        }

        bytes memory buffer = new bytes(digits);

        while (value != 0) {

            digits -= 1;

            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));

            value /= 10;

        }

        return string(buffer);

    }



    /**

     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.

     */

    function toHexString(uint256 value) internal pure returns (string memory) {

        if (value == 0) {

            return "0x00";

        }

        uint256 temp = value;

        uint256 length = 0;

        while (temp != 0) {

            length++;

            temp >>= 8;

        }

        return toHexString(value, length);

    }



    /**

     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.

     */

    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {

        bytes memory buffer = new bytes(2 * length + 2);

        buffer[0] = "0";

        buffer[1] = "x";

        for (uint256 i = 2 * length + 1; i > 1; --i) {

            buffer[i] = _HEX_SYMBOLS[value & 0xf];

            value >>= 4;

        }

        require(value == 0, "Strings: hex length insufficient");

        return string(buffer);

    }

}



library ECDSA {

    enum RecoverError {

        NoError,

        InvalidSignature,

        InvalidSignatureLength,

        InvalidSignatureS,

        InvalidSignatureV

    }



    function _throwError(RecoverError error) private pure {

        if (error == RecoverError.NoError) {

            return; // no error: do nothing

        } else if (error == RecoverError.InvalidSignature) {

            revert("ECDSA: invalid signature");

        } else if (error == RecoverError.InvalidSignatureLength) {

            revert("ECDSA: invalid signature length");

        } else if (error == RecoverError.InvalidSignatureS) {

            revert("ECDSA: invalid signature 's' value");

        } else if (error == RecoverError.InvalidSignatureV) {

            revert("ECDSA: invalid signature 'v' value");

        }

    }



    /**

     * @dev Returns the address that signed a hashed message (`hash`) with

     * `signature` or error string. This address can then be used for verification purposes.

     *

     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:

     * this function rejects them by requiring the `s` value to be in the lower

     * half order, and the `v` value to be either 27 or 28.

     *

     * IMPORTANT: `hash` _must_ be the result of a hash operation for the

     * verification to be secure: it is possible to craft signatures that

     * recover to arbitrary addresses for non-hashed data. A safe way to ensure

     * this is by receiving a hash of the original message (which may otherwise

     * be too long), and then calling {toEthSignedMessageHash} on it.

     *

     * Documentation for signature generation:

     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]

     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]

     *

     * _Available since v4.3._

     */

    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {

        // Check the signature length

        // - case 65: r,s,v signature (standard)

        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._

        if (signature.length == 65) {

            bytes32 r;

            bytes32 s;

            uint8 v;

            // ecrecover takes the signature parameters, and the only way to get them

            // currently is to use assembly.

            assembly {

                r := mload(add(signature, 0x20))

                s := mload(add(signature, 0x40))

                v := byte(0, mload(add(signature, 0x60)))

            }

            return tryRecover(hash, v, r, s);

        } else if (signature.length == 64) {

            bytes32 r;

            bytes32 vs;

            // ecrecover takes the signature parameters, and the only way to get them

            // currently is to use assembly.

            assembly {

                r := mload(add(signature, 0x20))

                vs := mload(add(signature, 0x40))

            }

            return tryRecover(hash, r, vs);

        } else {

            return (address(0), RecoverError.InvalidSignatureLength);

        }

    }



    /**

     * @dev Returns the address that signed a hashed message (`hash`) with

     * `signature`. This address can then be used for verification purposes.

     *

     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:

     * this function rejects them by requiring the `s` value to be in the lower

     * half order, and the `v` value to be either 27 or 28.

     *

     * IMPORTANT: `hash` _must_ be the result of a hash operation for the

     * verification to be secure: it is possible to craft signatures that

     * recover to arbitrary addresses for non-hashed data. A safe way to ensure

     * this is by receiving a hash of the original message (which may otherwise

     * be too long), and then calling {toEthSignedMessageHash} on it.

     */

    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {

        (address recovered, RecoverError error) = tryRecover(hash, signature);

        _throwError(error);

        return recovered;

    }



    /**

     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.

     *

     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]

     *

     * _Available since v4.3._

     */

    function tryRecover(

        bytes32 hash,

        bytes32 r,

        bytes32 vs

    ) internal pure returns (address, RecoverError) {

        bytes32 s;

        uint8 v;

        assembly {

            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)

            v := add(shr(255, vs), 27)

        }

        return tryRecover(hash, v, r, s);

    }



    /**

     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.

     *

     * _Available since v4.2._

     */

    function recover(

        bytes32 hash,

        bytes32 r,

        bytes32 vs

    ) internal pure returns (address) {

        (address recovered, RecoverError error) = tryRecover(hash, r, vs);

        _throwError(error);

        return recovered;

    }



    /**

     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,

     * `r` and `s` signature fields separately.

     *

     * _Available since v4.3._

     */

    function tryRecover(

        bytes32 hash,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) internal pure returns (address, RecoverError) {

        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature

        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines

        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most

        // signatures from current libraries generate a unique signature with an s-value in the lower half order.

        //

        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value

        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or

        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept

        // these malleable signatures as well.

        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {

            return (address(0), RecoverError.InvalidSignatureS);

        }

        if (v != 27 && v != 28) {

            return (address(0), RecoverError.InvalidSignatureV);

        }



        // If the signature is valid (and not malleable), return the signer address

        address signer = ecrecover(hash, v, r, s);

        if (signer == address(0)) {

            return (address(0), RecoverError.InvalidSignature);

        }



        return (signer, RecoverError.NoError);

    }



    /**

     * @dev Overload of {ECDSA-recover} that receives the `v`,

     * `r` and `s` signature fields separately.

     */

    function recover(

        bytes32 hash,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) internal pure returns (address) {

        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);

        _throwError(error);

        return recovered;

    }



    /**

     * @dev Returns an Ethereum Signed Message, created from a `hash`. This

     * produces hash corresponding to the one signed with the

     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]

     * JSON-RPC method as part of EIP-191.

     *

     * See {recover}.

     */

    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {

        // 32 is the length in bytes of hash,

        // enforced by the type signature above

        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));

    }



    /**

     * @dev Returns an Ethereum Signed Message, created from `s`. This

     * produces hash corresponding to the one signed with the

     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]

     * JSON-RPC method as part of EIP-191.

     *

     * See {recover}.

     */

    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {

        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n", Strings.toString(s.length), s));

    }



    /**

     * @dev Returns an Ethereum Signed Typed Data, created from a

     * `domainSeparator` and a `structHash`. This produces hash corresponding

     * to the one signed with the

     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]

     * JSON-RPC method as part of EIP-712.

     *

     * See {recover}.

     */

    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {

        return keccak256(abi.encodePacked("\x19\x01", domainSeparator, structHash));

    }

}



library SignatureVerifier {

    /**

     * @dev Generates a hash for signing/verifying.

     * @param target: The address the signature is for.

     * @param request: The original request that was sent.

     * @param result: The `result` field of the response (not including the signature part).

     */

    function makeSignatureHash(address target, uint64 expires, bytes memory request, bytes memory result) internal pure returns(bytes32) {

        return keccak256(abi.encodePacked(hex"1900", target, expires, keccak256(request), keccak256(result)));

    }



    /**

     * @dev Verifies a signed message returned from a callback.

     * @param request: The original request that was sent.

     * @param response: An ABI encoded tuple of `(bytes result, uint64 expires, bytes sig)`, where `result` is the data to return

     *        to the caller, and `sig` is the (r,s,v) encoded message signature.

     * @return signer: The address that signed this message.

     * @return result: The `result` decoded from `response`.

     */

    function verify(bytes calldata request, bytes calldata response) internal view returns(address, bytes memory) {

        (bytes memory result, uint64 expires, bytes memory sig) = abi.decode(response, (bytes, uint64, bytes));

        address signer = ECDSA.recover(makeSignatureHash(address(this), expires, request, result), sig);

        require(

            expires >= block.timestamp,

            "SignatureVerifier: Signature expired");

        return (signer, result);

    }

}



contract NFTMinter is ERC1155Holder, EIP712 {



    address collection;



    bytes4 constant internal LEGACY_EXTENSION_INTERFACE = 0x7005caad;



    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {

        return interfaceId == LEGACY_EXTENSION_INTERFACE

            || super.supportsInterface(interfaceId);

    }



    using ECDSA for bytes32;



    address ens;

    address publicResolver;



    event NameMigrated(bytes32 indexed node, address indexed owner, uint256 tokenId);

    event OwnershipReturned(bytes32 indexed node, address indexed owner);



    mapping (bytes32 => bool) public migratedNames;



    constructor(address _collection, address _publicResolver, address _ens) EIP712() {

        collection = _collection;

        publicResolver = _publicResolver;

        ens = _ens;

    }



    struct ENSName {

        bytes32 rootNode;

        bytes32 label;

        bytes32 namehash;

        address owner;

        string uri;

    }



    bytes32 constant ENSNAME_TYPEHASH = keccak256("ENSName(bytes32 rootNode,bytes32 label,bytes32 namehash,address owner,string uri)");



    function hashStruct(ENSName memory ensName) public pure returns (bytes32) {

        return keccak256(abi.encode(ENSNAME_TYPEHASH,

                                    ensName.rootNode,

                                    ensName.label,

                                    ensName.namehash,

                                    ensName.owner,

                                    keccak256(bytes(ensName.uri))

                                   ));

    }



    function registerENSNameOnChain(ENSName memory ensNameStruct, bytes calldata signature) external {

        bytes32 digest = _hashTypedData(hashStruct(ensNameStruct));

        address signer = ECDSA.recover(digest, signature);



        require(!migratedNames[ensNameStruct.namehash], "Name already migrated");

        require(IAdminControl(collection).isAdmin(signer), "Not admin");



        migratedNames[ensNameStruct.namehash] = true;



        IENS(ens).setSubnodeRecord(ensNameStruct.rootNode, ensNameStruct.label, address(this), publicResolver, 10);

        IResolver(publicResolver).setAddr(ensNameStruct.namehash, ensNameStruct.owner);

        IENS(ens).setSubnodeOwner(ensNameStruct.rootNode, ensNameStruct.label, ensNameStruct.owner);



        uint256 tokenId = IERC721CreatorCore(collection).mintExtension(ensNameStruct.owner, ensNameStruct.uri);



        emit NameMigrated(ensNameStruct.namehash, ensNameStruct.owner, tokenId);

    }



    function reallowENSNameMigration(bytes32 node) external {

        require(IAdminControl(collection).isAdmin(msg.sender), "Not admin");

        migratedNames[node] = false;

    }



    function returnENSNameToAdmin(bytes32 node, address recipient) external {

        require(IAdminControl(collection).isAdmin(msg.sender), "Not admin");

        IENS(ens).setOwner(node, recipient);

        emit OwnershipReturned(node, recipient);

    }



    /*//////////////////////////////////////////////////////////////

                                 EIP712

    //////////////////////////////////////////////////////////////*/



    function _domainNameAndVersion() internal pure override returns (string memory, string memory) {

        return ("ETHIDNFTMinter", "1");

    }



}