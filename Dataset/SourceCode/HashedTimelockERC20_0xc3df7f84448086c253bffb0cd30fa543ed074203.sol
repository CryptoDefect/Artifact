// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.12;



/**

 * @dev Interface of the ERC20 standard as defined in the EIP. Does not include

 * the optional functions; to access them see {ERC20Detailed}.

 */

interface IERC20 {

    /**

     * @dev Returns the amount of tokens in existence.

     */

    function totalSupply() external view returns (uint256);



    /**

     * @dev Returns the amount of tokens owned by `account`.

     */

    function balanceOf(address account) external view returns (uint256);



    /**

     * @dev Moves `amount` tokens from the caller's account to `recipient`.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transfer(address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Returns the remaining number of tokens that `spender` will be

     * allowed to spend on behalf of `owner` through {transferFrom}. This is

     * zero by default.

     *

     * This value changes when {approve} or {transferFrom} are called.

     */

    function allowance(address owner, address spender) external view returns (uint256);



    /**

     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * IMPORTANT: Beware that changing an allowance with this method brings the risk

     * that someone may use both the old and the new allowance by unfortunate

     * transaction ordering. One possible solution to mitigate this race

     * condition is to first reduce the spender's allowance to 0 and set the

     * desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     *

     * Emits an {Approval} event.

     */

    function approve(address spender, uint256 amount) external returns (bool);



    /**

     * @dev Moves `amount` tokens from `sender` to `recipient` using the

     * allowance mechanism. `amount` is then deducted from the caller's

     * allowance.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Emitted when `value` tokens are moved from one account (`from`) to

     * another (`to`).

     *

     * Note that `value` may be zero.

     */

    event Transfer(address indexed from, address indexed to, uint256 value);



    /**

     * @dev Emitted when the allowance of a `spender` for an `owner` is set by

     * a call to {approve}. `value` is the new allowance.

     */

    event Approval(address indexed owner, address indexed spender, uint256 value);

}





/**

* @title Hashed Timelock Contracts (HTLCs) on Ethereum ERC20 tokens.

*

* This contract provides a way to create and keep HTLCs for ERC20 tokens.

*

* See HashedTimelock.sol for a contract that provides the same functions

* for the native ETH token.

*

* Protocol:

*

*  1) newContract(receiver, hashlock, timelock, tokenContract, amount) - a

*      sender calls this to create a new HTLC on a given token (tokenContract)

*       for a given amount. A 32 byte contract id is returned

*  2) withdraw(contractId, preimage) - once the receiver knows the preimage of

*      the hashlock hash they can claim the tokens with this function

*  3) refund() - after timelock has expired and if the receiver did not

*      withdraw the tokens the sender / creator of the HTLC can get their tokens

*      back with this function.

 */

contract HashedTimelockERC20 {

    event HTLCERC20New(

        bytes32 indexed contractId,

        address indexed sender,

        address indexed receiver,

        address tokenContract,

        uint256 amount,

        bytes32 hashlock,

        uint256 timelock,

        bool allowLateWithdrawal

    );

    event HTLCERC20Withdraw(bytes32 indexed contractId);

    event HTLCERC20Refund(bytes32 indexed contractId);



    struct LockContract {

        bool allowLateWithdrawal;

        bool withdrawn;

        bool refunded;

        address sender;

        address receiver;

        address tokenContract;

        uint256 amount;

        bytes32 hashlock;

        // locked UNTIL this time. Unit depends on consensus algorithm.

        // PoA, PoA and IBFT all use seconds. But Quorum Raft uses nano-seconds

        uint256 timelock;

        bytes32 preimage;

    }



    modifier tokensTransferable(address _token, address _sender, uint256 _amount) {

        require(_amount > 0, "token amount must be > 0");

        require(

            IERC20(_token).allowance(_sender, address(this)) >= _amount,

            "token allowance must be >= amount"

        );

        _;

    }

    modifier futureTimelock(uint256 _time) {

        // only requirement is the timelock time is after the last blocktime (now).

        // probably want something a bit further in the future then this.

        // but this is still a useful sanity check:

        require(_time > block.timestamp, "timelock time must be in the future");

        _;

    }

    modifier contractExists(bytes32 _contractId) {

        require(haveContract(_contractId), "contractId does not exist");

        _;

    }

    modifier hashlockMatches(bytes32 _contractId, bytes32 _x) {

        require(

            contracts[_contractId].hashlock == sha256(abi.encodePacked(_x)),

            "hashlock hash does not match"

        );

        _;

    }

    modifier withdrawable(bytes32 _contractId) {

        require(contracts[_contractId].receiver == msg.sender, "withdrawable: not receiver");

        require(contracts[_contractId].withdrawn == false, "withdrawable: already withdrawn");

        require(contracts[_contractId].refunded == false, "withdrawable: already refunded");



        if (contracts[_contractId].allowLateWithdrawal == false) {

            // if we want to disallow claim to be made after the timeout, uncomment the following line

            require(contracts[_contractId].timelock > block.timestamp, "withdrawable: timelock time must be in the future");

        }



        _;

    }

    modifier refundable(bytes32 _contractId) {

        require(contracts[_contractId].sender == msg.sender, "refundable: not sender");

        require(contracts[_contractId].refunded == false, "refundable: already refunded");

        require(contracts[_contractId].withdrawn == false, "refundable: already withdrawn");

        require(contracts[_contractId].timelock <= block.timestamp, "refundable: timelock not yet passed");

        _;

    }



    mapping (bytes32 => LockContract) contracts;



    /**

     * @dev Sender / Payer sets up a new hash time lock contract depositing the

     * funds and providing the reciever and terms.

     *

     * NOTE: _receiver must first call approve() on the token contract.

     *       See allowance check in tokensTransferable modifier.



     * @param _receiver Receiver of the tokens.

     * @param _hashlock A sha-2 sha256 hash hashlock.

     * @param _timelock UNIX epoch seconds time that the lock expires at.

     *                  Refunds can be made after this time.

     * @param _tokenContract ERC20 Token contract address.

     * @param _amount Amount of the token to lock up.

     * @return contractId Id of the new HTLC. This is needed for subsequent

     *                    calls.

     */

    function newContract(

        address _receiver,

        bytes32 _hashlock,

        uint256 _timelock,

        bool _allowLateWithdrawal,

        address _tokenContract,

        uint256 _amount

    )

        external

        tokensTransferable(_tokenContract, msg.sender, _amount)

        futureTimelock(_timelock)

        returns (bytes32 contractId)

    {

        contractId = sha256(

            abi.encodePacked(

                msg.sender,

                _receiver,

                _tokenContract,

                _amount,

                _hashlock,

                _timelock,

                _allowLateWithdrawal

            )

        );



        // Reject if a contract already exists with the same parameters. The

        // sender must change one of these parameters (ideally providing a

        // different _hashlock).

        if (haveContract(contractId))

            revert("Contract already exists");



        // This contract becomes the temporary owner of the tokens

        if (!IERC20(_tokenContract).transferFrom(msg.sender, address(this), _amount))

            revert("transferFrom sender to this failed");



        contracts[contractId] = LockContract(

            _allowLateWithdrawal,

            false,

            false,

            msg.sender,

            _receiver,

            _tokenContract,

            _amount,

            _hashlock,

            _timelock,

            0x0

        );



        emit HTLCERC20New(

            contractId,

            msg.sender,

            _receiver,

            _tokenContract,

            _amount,

            _hashlock,

            _timelock,

            _allowLateWithdrawal

        );

    }



    /**

    * @dev Called by the receiver once they know the preimage of the hashlock.

    * This will transfer ownership of the locked tokens to their address.

    *

    * @param _contractId Id of the HTLC.

    * @param _preimage sha256(_preimage) should equal the contract hashlock.

     */

    function withdraw(bytes32 _contractId, bytes32 _preimage)

        external

        contractExists(_contractId)

        hashlockMatches(_contractId, _preimage)

        withdrawable(_contractId)

    {

        LockContract storage c = contracts[_contractId];

        c.preimage = _preimage;

        c.withdrawn = true;



        if (!IERC20(c.tokenContract).transfer(c.receiver, c.amount))

            revert("transfer from this to receiver failed");



        emit HTLCERC20Withdraw(_contractId);

    }



    /**

     * @dev Called by the sender if there was no withdraw AND the time lock has

     * expired. This will restore ownership of the tokens to the sender.

     *

     * @param _contractId Id of HTLC to refund from.

     */

    function refund(bytes32 _contractId)

        external

        contractExists(_contractId)

        refundable(_contractId)

    {

        LockContract storage c = contracts[_contractId];

        c.refunded = true;



        if (!IERC20(c.tokenContract).transfer(c.sender, c.amount))

            revert("transfer from this to sender failed");



        emit HTLCERC20Refund(_contractId);



    }



    /**

     * @dev Get contract details.

     * @param _contractId HTLC contract id

     * @return sender All parameters in struct LockContract for _contractId HTLC

     */

    function getContract(bytes32 _contractId)

        public

        view

        returns (

            address sender,

            address receiver,

            address tokenContract,

            uint256 amount,

            bytes32 hashlock,

            uint256 timelock,

            bool allowLateWithdrawal,

            bool withdrawn,

            bool refunded,

            bytes32 preimage

        )

    {

        if (!haveContract(_contractId))

            return (address(0), address(0), address(0), 0, 0, 0, false, false, false, 0);

        LockContract storage c = contracts[_contractId];

        return (

            c.sender,

            c.receiver,

            c.tokenContract,

            c.amount,

            c.hashlock,

            c.timelock,

            c.allowLateWithdrawal,

            c.withdrawn,

            c.refunded,

            c.preimage

        );

    }



    /**

     * @dev Is there a contract with id _contractId.

     * @param _contractId Id into contracts mapping.

     */

    function haveContract(bytes32 _contractId)

        internal

        view

        returns (bool exists)

    {

        exists = (contracts[_contractId].sender != address(0));

    }



}