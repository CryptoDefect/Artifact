// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.4;



import "@openzeppelin/contracts/access/AccessControl.sol";

import "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol";

import "@openzeppelin/contracts/utils/math/Math.sol";



/// @title Raffles manager (lean, single winner and a fixed amount of ETH as prize)

/// @author Luis Pando

/// @notice It consumes VRF v1 from Chainlink. It has the role

/// "operator" that is the one used by a backend app to make some calls

/// @dev It saves in an ordered array the player wallet and the current

/// entries count. So buying entries has a complexity of O(1)

/// For calculating the winner, from the huge random number generated by Chainlink

/// a normalized random is generated by using the module method, adding 1 to have

/// a random from 1 to entriesCount.

/// So next step is to perform a binary search on the ordered array to get the

/// player O(log n)

/// Example:

/// 0 -> { 1, player1} as player1 buys 1 entry

/// 1 -> {51, player2} as player2 buys 50 entries

/// 2 -> {52, player3} as player3 buys 1 entry

/// 3 -> {53, player4} as player4 buys 1 entry

/// 4 -> {153, player5} as player5 buys 100 entries

/// So the setWinner method performs a binary search on that sorted array to get the upper bound.

/// If the random number generated is 150, the winner is player5. If the random number is 20, winner is player2



contract ETHFixedLean is AccessControl, VRFConsumerBase {

    ////////// CHAINLINK VRF v1 /////////////////

    bytes32 internal keyHash; // chainlink

    uint256 internal fee; // fee paid in LINK to chainlink. 0.1 in Rinkeby, 2 in mainnet



    struct RandomResult {

        uint256 randomNumber; // random number generated by chainlink.

        uint256 nomalizedRandomNumber; // random number % entriesLength + 1. So between 1 and entries.length

    }



    // event sent when the random number is generated by the VRF

    event RandomNumberCreated(

        uint256 indexed idFromMetawin,

        uint256 randomNumber,

        uint256 normalizedRandomNumber

    );



    struct RaffleInfo {

        uint256 id; // raffleId

        uint256 size; // length of the entries array of that raffle

    }



    mapping(uint256 => RandomResult) public requests;

    // map the requestId created by chainlink with the raffle info passed as param when calling getRandomNumber()

    mapping(bytes32 => RaffleInfo) public chainlinkRaffleInfo;



    /////////////// END CHAINKINK VRF V1 //////////////



    error EntryNotAllowed(string errorType);



    // Event sent when the raffle is created by the operator

    event RaffleCreated(uint256 indexed raffleId, uint256 indexed nftId);

    // Event sent when the owner of the nft stakes it for the raffle

    event RaffleStarted(uint256 indexed raffleId, address indexed seller);

    // Event sent when the raffle is finished (either early cashout or successful completion)

    event RaffleEnded(

        uint256 indexed raffleId,

        address indexed winner,

        uint256 amountRaised,

        uint256 randomNumber

    );

    // Event sent when one or more entries are sold (info from the price structure)

    event EntrySold(

        uint256 indexed raffleId,

        address indexed buyer,

        uint256 currentSize,

        uint256 priceStructureId

    );

    // Event sent when a free entry is added by the operator

    event FreeEntry(

        uint256 indexed raffleId,

        address[] buyer,

        uint256 amount,

        uint256 currentSize

    );

    // Event sent when a raffle is asked to cancel by the operator

    event RaffleCancelled(uint256 indexed raffleId, uint256 amountRaised);

    // The raffle is closed successfully and the platform receives the fee

    event FeeTransferredToPlatform(

        uint256 indexed raffleId,

        uint256 amountTransferred

    );

    // When the raffle is asked to be cancelled and 30 days have passed, the operator can call a method

    // to transfer the remaining funds and this event is emitted

    event RemainingFundsTransferred(

        uint256 indexed raffleId,

        uint256 amountInWeis

    );

    // When the raffle is asked to be cancelled and 30 days have not passed yet, the players can call a

    // method to refund the amount spent on the raffle and this event is emitted

    event Refund(

        uint256 indexed raffleId,

        uint256 amountInWeis,

        address indexed player

    );

    event EarlyCashoutTriggered(uint256 indexed raffleId, uint256 amountRaised);

    event SetWinnerTriggered(uint256 indexed raffleId, uint256 amountRaised);

    event StatusChangedInEmergency(uint256 indexed raffleId, uint256 newStatus);

    // Emitted when an entry is cancelled

    event EntryCancelled(

        uint256 indexed raffleId,

        uint256 amountOfEntriesCanceled,

        address player

    );

   

    struct PriceStructure {

        uint256 id;

        uint48 numEntries;

        uint256 price;

    }

    mapping(uint256 => PriceStructure) public pricesList;



    // Every raffle has a funding structure.

    struct FundingStructure {

        uint128 minimumFundsInWeis;

        uint128 desiredFundsInWeis;

    }

    mapping(uint256 => FundingStructure) public fundingList;



    // In order to calculate the winner, in this struct is saved for each bought the data

    struct EntriesBought {

        uint48 currentEntriesLength; // current amount of entries bought in the raffle

        address player; // wallet address of the player

    }

    // every raffle has a sorted array of EntriesBought. Each element is created when calling

    // either buyEntry or giveBatchEntriesForFree

    mapping(uint256 => EntriesBought[]) public entriesList;



    // Main raffle data struct

    struct RaffleStruct {

        uint48 platformPercentage; // percentage of the funds raised that goes to the platform

        uint256 prizeNumber; // number (can be a percentage, an id, an amount, etc. depending on the competition)

        address winner; // address of thed winner of the raffle. Address(0) if no winner yet

        address seller; // address of the seller of the NFT

        uint256 randomNumber; // normalized (0-Entries array size) random number generated by the VRF

    }

    // The main structure is an array of raffles

    RaffleStruct[] public raffles;



    struct EntryInfoStruct {

        STATUS status; // status of the raffle. Can be created, accepted, ended, etc

        ENTRY_TYPE entryType;

        uint48 entriesLength; // to easy frontend, the length of the entries array is saved here

        uint128 amountRaised; // funds raised so far in wei

    }

    // The main structure is an array of raffles

    EntryInfoStruct[] public rafflesEntryInfo;



    // All the different status a rafVRFCoordinatorfle can have

    enum STATUS {

        CREATED, // the operator creates the raffle

        ACCEPTED, // the seller stakes the nft for the raffle

        EARLY_CASHOUT, // the seller wants to cashout early

        CANCELLED, // the operator cancels the raffle and transfer the remaining funds after 30 days passes

        CLOSING_REQUESTED, // the operator sets a winner

        ENDED, // the raffle is finished, and NFT and funds were transferred

        CANCEL_REQUESTED // operator asks to cancel the raffle. Players has 30 days to ask for a refund

    }



    enum ENTRY_TYPE {

        ONLY_DIRECTLY,

        ONLY_EXTERNAL_CONTRACT,

        MIXED

    }



    // The operator role is operated by a backend application

    bytes32 public constant OPERATOR_ROLE = keccak256("OPERATOR");

    // requested by Hamburger. Role for the buy method of the hamburger (only that contract)

    bytes32 public constant MINTERCONTRACT_ROLE = keccak256("MINTERCONTRACT");



    // address of the wallet controlled by the platform that will receive the platform fee

    address payable public destinationWallet =

        payable(0x52a032cF59eA274f9D745f29b6D514fe95Ba192D);



    constructor(

        address _vrfCoordinator,

        address _linkToken,

        bytes32 _keyHash,

        bool _mainetFee

    )

        VRFConsumerBase(

            _vrfCoordinator, // VRF Coordinator

            _linkToken // LINK Token

        )

    {

        _setupRole(OPERATOR_ROLE, 0x13503B622abC0bD30A7e9687057DF6E8c42Fb928);

        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);



        keyHash = _keyHash;

        if (_mainetFee == true)

            fee = 2 * 10 ** 18; // in mainnet, the fee must be 2 LINK

        else fee = 0.1 * 10 ** 18; // 0.1 LINK In Rinkeby and Goerli

    }



    function callVRFAndGetRequestId() internal returns (bytes32 requestId) {

        require(

            LINK.balanceOf(address(this)) >= fee,

            "Not enough LINK - fill contract with faucet"

        );

        bytes32 result = requestRandomness(keyHash, fee);

        return result;

    }



    /// @dev this is the method that will be called by the smart contract to get a random number

    /// @param _id Id of the raffle

    /// @param _entriesSize length of the entries array of that raffle

    /// @param _requestId id generated by Chainlink

    function getRandomNumber(

        uint256 _id,

        uint256 _entriesSize,

        bytes32 _requestId

    ) internal {

        chainlinkRaffleInfo[_requestId] = RaffleInfo({

            id: _id,

            size: _entriesSize

        });

    }



    /// @dev Callback function used by VRF Coordinator. Is called by chainlink

    /// the random number generated is normalized to the size of the entries array, and an event is

    /// generated, that will be listened by the platform backend to be checked if corresponds to a

    /// member of the MW community, and if true will call transferNFTAndFunds

    /// @param requestId id generated previously (on method getRandomNumber by chainlink)

    /// @param randomness random number (huge) generated by chainlink

    function fulfillRandomness(

        bytes32 requestId,

        uint256 randomness

    ) internal override {

        // randomness is the actual random number. Now extract from the aux map the original param id of the call

        RaffleInfo memory raffleInfo = chainlinkRaffleInfo[requestId];

        // save the random number on the map with the original id as key

        uint256 normalizedRandomNumber = (randomness % raffleInfo.size) + 1;



        RandomResult memory result = RandomResult({

            randomNumber: randomness,

            nomalizedRandomNumber: normalizedRandomNumber

        });



        requests[raffleInfo.id] = result;



        // send the event with the original id and the random number

        emit RandomNumberCreated(

            raffleInfo.id,

            randomness,

            normalizedRandomNumber

        );



        transferPrizesAndFunds(raffleInfo.id, normalizedRandomNumber);

    }



    //////////////////////////////////////////////



    /// @param _desiredFundsInWeis the amount the seller would like to get from the raffle

    /// @param _collateralAddress The address of the NFT of the raffle

    /// @param _collateralId The id of the NFT (ERC721)

    /// @param _minimumFundsInWeis The mininum amount required for the raffle to set a winner

    /// @param _prices Array of prices and amount of entries the customer could purchase

    //   /// @param _commissionInBasicPoints commission for the platform, in basic points

    /// @notice Creates a raffle

    /// @dev creates a raffle struct and push it to the raffles array. Some data is stored in the funding data structure

    /// sends an event when finished

    /// @return raffleId

    function createRaffle(

        uint128 _desiredFundsInWeis,

        uint256 _prizeNumber,

        uint128 _minimumFundsInWeis,

        PriceStructure[] calldata _prices,

        uint48 _commissionInBasicPoints,

        ENTRY_TYPE _entryType

    ) external onlyRole(OPERATOR_ROLE) returns (uint256) {

        require(_commissionInBasicPoints <= 5000, "commission too high");



        RaffleStruct memory raffle = RaffleStruct({

            prizeNumber: _prizeNumber,

            winner: address(0),

            randomNumber: 0,

            seller: address(0),

            platformPercentage: _commissionInBasicPoints

        });

        raffles.push(raffle);



        saveEntryInfo(_entryType);



        uint256 idRaffle = raffles.length - 1;



        require(_prices.length > 0, "No prices");

        for (uint256 i = 0; i < _prices.length; i++) {

            require(_prices[i].numEntries > 0, "numEntries is 0");



            PriceStructure memory p = PriceStructure({

                id: idRaffle,

                numEntries: _prices[i].numEntries,

                price: _prices[i].price

            });

            pricesList[_prices[i].id] = p;

        }



        fundingList[idRaffle] = FundingStructure({

            minimumFundsInWeis: _minimumFundsInWeis,

            desiredFundsInWeis: _desiredFundsInWeis

        });



        emit RaffleCreated(idRaffle, _prizeNumber);



        // Initialize the entries list array, by adding a player and removing it

        EntriesBought memory entryBought = EntriesBought({

            player: msg.sender,

            currentEntriesLength: uint48(1)

        });

        entriesList[idRaffle].push(entryBought);

        delete entriesList[idRaffle][0];



        return idRaffle;

    }



    function saveEntryInfo(ENTRY_TYPE _entryType) internal {

        EntryInfoStruct memory entryInfo = EntryInfoStruct({

            status: STATUS.CREATED,

            amountRaised: 0,

            entriesLength: 0,

            entryType: _entryType

        });

        rafflesEntryInfo.push(entryInfo);

    }



    /// @param _raffleId Id of the raffle

    function stakeETH(uint256 _raffleId) external payable {

        EntryInfoStruct storage entryInfo = rafflesEntryInfo[_raffleId];

        RaffleStruct storage raffle = raffles[_raffleId];

        // Check if the raffle is already created

        require(entryInfo.status == STATUS.CREATED, "Raffle not CREATED");

        // check the amount staked is the correct

        require(raffle.prizeNumber == msg.value, "Prize not staked");



        entryInfo.status = STATUS.ACCEPTED;

        raffle.seller = msg.sender;

        emit RaffleStarted(_raffleId, msg.sender);

    }



    /// @dev callable by players. Depending on the number of entries assigned to the price structure the player buys (_id parameter)

    /// one or more entries will be assigned to the player.

    /// Also it is checked the maximum number of entries per user is not reached

    /// As the method is payable, in msg.value there will be the amount paid by the user

    /// @notice If the operator set requiredNFTs when creating the raffle, only the owners of nft on that collection can make a call to this method. This will be

    /// used for special raffles

    /// @param _raffleId: id of the raffle

    /// @param _id: id of the price structure

    function buyEntry(

        uint256 _raffleId,

        uint256 _id

    ) external payable /*nonReentrant*/ {

        EntryInfoStruct storage entryInfo = rafflesEntryInfo[_raffleId];

        // Not callable if the contract is only using hamburgers (150 gas)

        if (entryInfo.entryType == ENTRY_TYPE.ONLY_EXTERNAL_CONTRACT)

            revert EntryNotAllowed("Entry type not allowed");

        // Price checks

        if (_id == 0) revert EntryNotAllowed("howMany is 0");

        PriceStructure memory priceStruct = pricesList[_id];

        if (priceStruct.id != _raffleId) revert EntryNotAllowed("Id not in raffleId");

        uint48 numEntries = priceStruct.numEntries;

        if (numEntries == 0) revert EntryNotAllowed("Id not supported");

        if (msg.value != priceStruct.price)

            revert EntryNotAllowed("msg.value must be equal to the price");

        // save the entries onchain

        uint48 entriesLength = entryInfo.entriesLength;

        EntriesBought memory entryBought = EntriesBought({

            player: msg.sender,

            currentEntriesLength: uint48(entriesLength + numEntries)

        });

        entriesList[_raffleId].push(entryBought);

        // update raffle variables

        entryInfo.amountRaised += uint128(msg.value);

        entryInfo.entriesLength = entriesLength + numEntries;



        emit EntrySold(_raffleId, msg.sender, entryInfo.entriesLength, _id);

    }



    // The operator can add free entries to the raffle

    /// @param _raffleId Id of the raffle

    /// @param _freePlayers array of addresses corresponding to the wallet of the users that won a free entrie

    /// @dev only operator can make this call. Assigns a single entry per user, except if that user already reached the max limit of entries per user

    function giveBatchEntriesForFree(

        uint256 _raffleId,

        address[] memory _freePlayers

    ) external onlyRole(OPERATOR_ROLE) {

        EntryInfoStruct storage entryInfo = rafflesEntryInfo[_raffleId];

        require(

            entryInfo.status == STATUS.ACCEPTED,

            "Raffle is not in accepted"

        );



        uint256 freePlayersLength = _freePlayers.length;

        uint48 validPlayersCount = 0;

        for (uint256 i = 0; i < freePlayersLength; i++) {

            address entry = _freePlayers[i];

            // add a new element to the entriesBought array.

            // as this method only adds 1 entry per call, the amountbought is always 1

            EntriesBought memory entryBought = EntriesBought({

                player: entry,

                currentEntriesLength: uint48(entryInfo.entriesLength + i + 1)

            });

            entriesList[_raffleId].push(entryBought);

            ++validPlayersCount;

        }



        entryInfo.entriesLength = entryInfo.entriesLength + validPlayersCount;



        emit FreeEntry(

            _raffleId,

            _freePlayers,

            freePlayersLength,

            entryInfo.entriesLength

        );

    }



    // helper method to get the winner address of a raffle

    /// @param _raffleId Id of the raffle

    /// @param _normalizedRandomNumber Generated by chainlink

    /// @return the wallet that won the raffle

    /// @dev Uses a binary search on the sorted array to retreive the winner

    /// but if the winner candidate is blacklisted, loop through the left looking for

    /// a candidate not blacklisted

    function getWinnerAddressFromRandom(

        uint256 _raffleId,

        uint256 _normalizedRandomNumber

    ) public view returns (address) {

        uint256 position = findUpperBound(

            entriesList[_raffleId],

            _normalizedRandomNumber

        );



        address candidate = entriesList[_raffleId][position].player;

        // general case

        if (candidate != address(0)) return candidate;

        // special case. The user is blacklisted, so try next on the left until find a non-blacklisted

        else {

            bool ended = false;

            uint256 i = position;

            while (

                ended == false && entriesList[_raffleId][i].player == address(0)

            ) {

                if (i == 0) i = entriesList[_raffleId].length - 1;

                else i = i - 1;

                // we came to the beginning without finding a non blacklisted player

                if (i == position) ended == true;

            }

            require(!ended, "All users blacklisted");

            return entriesList[_raffleId][i].player;

        }

    }



    /// @param array sorted array of EntriesBought. CurrentEntriesLength is the numeric field used to sort

    /// @param element uint256 to find. Goes from 1 to entriesLength

    /// @dev based on openzeppelin code (v4.0), modified to use an array of EntriesBought

    /// Searches a sorted array and returns the first index that contains a value greater or equal to element.

    /// If no such index exists (i.e. all values in the array are strictly less than element), the array length is returned. Time complexity O(log n).

    /// array is expected to be sorted in ascending order, and to contain no repeated elements.

    /// https://docs.openzeppelin.com/contracts/3.x/api/utils#Arrays-findUpperBound-uint256---uint256-

    function findUpperBound(

        EntriesBought[] storage array,

        uint256 element

    ) internal view returns (uint256) {

        if (array.length == 0) {

            return 0;

        }



        uint256 low = 0;

        uint256 high = array.length;



        while (low < high) {

            uint256 mid = Math.average(low, high);



            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)

            // because Math.average rounds down (it does integer division with truncation).

            if (array[mid].currentEntriesLength > element) {

                high = mid;

            } else {

                low = mid + 1;

            }

        }



        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.

        if (low > 0 && array[low - 1].currentEntriesLength == element) {

            return low - 1;

        } else {

            return low;

        }

    }



    // The operator can call this method once they receive the event "RandomNumberCreated"

    // triggered by the VRF v1 consumer contract (RandomNumber.sol)

    /// @param _raffleId Id of the raffle

    /// @param _normalizedRandomNumber index of the array that contains the winner of the raffle. Generated by chainlink

    /// @notice it is the method that sets the winner and transfers funds and nft

    /// @dev called by Chainlink callback

    function transferPrizesAndFunds(

        uint256 _raffleId,

        uint256 _normalizedRandomNumber

    ) internal {

        RaffleStruct storage raffle = raffles[_raffleId];

        EntryInfoStruct storage entryInfo = rafflesEntryInfo[_raffleId];

        // Only when the raffle has been asked to be closed and the platform

        require(

            entryInfo.status == STATUS.EARLY_CASHOUT ||

                entryInfo.status == STATUS.CLOSING_REQUESTED,

            "Raffle in wrong status"

        );



        raffle.randomNumber = _normalizedRandomNumber;

        raffle.winner = getWinnerAddressFromRandom(

            _raffleId,

            _normalizedRandomNumber

        );

        entryInfo.status = STATUS.ENDED;



        // send the ETH to the winner

        (bool sentPrize, ) = raffle.winner.call{value: raffle.prizeNumber}("");

        require(sentPrize, "Failed to send Ether");



        uint256 amountForPlatform = (entryInfo.amountRaised *

            raffle.platformPercentage) / 10000;

        uint256 amountForSeller = entryInfo.amountRaised - amountForPlatform;

        // transfer amount (75%) to the seller.

        (bool sent, ) = raffle.seller.call{value: amountForSeller}("");

        require(sent, "Failed to send Ether");

        // transfer the amount to the platform

        (bool sent2, ) = destinationWallet.call{value: amountForPlatform}("");

        require(sent2, "Failed send Eth to MW");

        emit FeeTransferredToPlatform(_raffleId, amountForPlatform);



        emit RaffleEnded(

            _raffleId,

            raffle.winner,

            entryInfo.amountRaised,

            _normalizedRandomNumber

        );

    }



    function setCashOutActions(

        uint256 _raffleId

    ) internal returns (EntryInfoStruct memory) {

        RaffleStruct memory raffle = raffles[_raffleId];

        EntryInfoStruct storage entryInfo = rafflesEntryInfo[_raffleId];

        FundingStructure memory funding = fundingList[_raffleId];



        require(raffle.seller == msg.sender, "Not the seller");

        // Check if the raffle is already accepted

        require(

            entryInfo.status == STATUS.ACCEPTED,

            "Raffle not in accepted status"

        );

        require(

            entryInfo.amountRaised >= funding.minimumFundsInWeis,

            "Not enough funds raised"

        );



        entryInfo.status = STATUS.EARLY_CASHOUT;



        emit EarlyCashoutTriggered(_raffleId, entryInfo.amountRaised);



        return entryInfo;

    }



    // can be called by the seller at every moment once enough funds has been raised

    /// @param _raffleId Id of the raffle

    /// @notice the seller of the nft, if the minimum amount has been reached, can call an early cashout, finishing the raffle

    /// @dev it triggers Chainlink VRF1 consumer, and generates a random number that is normalized and checked that corresponds to a MW player

    function earlyCashOut(uint256 _raffleId) external {

        EntryInfoStruct memory raffle = setWinnerActions(_raffleId);

        bytes32 requestId = callVRFAndGetRequestId();

        getRandomNumber(_raffleId, raffle.entriesLength, requestId);

    }



    function setWinnerActions(

        uint256 _raffleId

    ) internal returns (EntryInfoStruct memory) {

        EntryInfoStruct storage entryInfo = rafflesEntryInfo[_raffleId];

        // RaffleStruct storage raffle = raffles[_raffleId];

        FundingStructure storage funding = fundingList[_raffleId];

        // Check if the raffle is already accepted or is called again because early cashout failed

        require(entryInfo.status == STATUS.ACCEPTED, "Raffle in wrong status");

        require(

            entryInfo.amountRaised >= funding.minimumFundsInWeis,

            "Not enough funds raised"

        );



        require(

            funding.desiredFundsInWeis <= entryInfo.amountRaised,

            "Desired funds not raised"

        );

        entryInfo.status = STATUS.CLOSING_REQUESTED;



        emit SetWinnerTriggered(_raffleId, entryInfo.amountRaised);

        return entryInfo;

    }



    /// @param _raffleId Id of the raffle

    /// @notice the operator finish the raffle, if the desired funds has been reached

    /// @dev it triggers Chainlink VRF1 consumer, and generates a random number that is normalized and checked that corresponds to a MW player

    function setWinner(uint256 _raffleId) external onlyRole(OPERATOR_ROLE) {

        EntryInfoStruct memory raffle = setWinnerActions(_raffleId);

        // this call trigers the VRF v1 process from Chainlink



        bytes32 requestId = callVRFAndGetRequestId();

        getRandomNumber(_raffleId, raffle.entriesLength, requestId);

    }



    /// @param _newAddress new address of the platform

    /// @dev Change the wallet of the platform. The one that will receive the platform fee when the raffle is closed.

    /// Only the admin can change this

    function setDestinationAddress(

        address payable _newAddress

    ) external onlyRole(DEFAULT_ADMIN_ROLE) {

        destinationWallet = _newAddress;

    }



    /// @param _raffleId Id of the raffle

    /// @dev The operator can cancel the raffle. The NFT is sent back to the seller

    /// The raised funds are send to the destination wallet. The buyers will

    /// be refunded offchain in the metawin wallet

    function cancelRaffle(uint256 _raffleId) external onlyRole(OPERATOR_ROLE) {

        RaffleStruct storage raffle = raffles[_raffleId];

        EntryInfoStruct storage entryInfo = rafflesEntryInfo[_raffleId];

        // Dont cancel twice, or cancel an already ended raffle

        require(

            entryInfo.status != STATUS.ENDED &&

                entryInfo.status != STATUS.CANCELLED &&

                entryInfo.status != STATUS.EARLY_CASHOUT &&

                entryInfo.status != STATUS.CLOSING_REQUESTED &&

                entryInfo.status != STATUS.CANCEL_REQUESTED,

            "Wrong status"

        );



        // only if the raffle is in accepted status the ETH is staked and could have entries sold

        if (entryInfo.status == STATUS.ACCEPTED) {

            // transfer ETH to the owner

            (bool sentPrize, ) = raffle.seller.call{value: raffle.prizeNumber}(

                ""

            );

            require(sentPrize, "Failed to send Ether");

        }

        entryInfo.status = STATUS.CANCEL_REQUESTED;



        emit RaffleCancelled(_raffleId, entryInfo.amountRaised);

    }



    /// @param _raffleId Id of the raffle

    function transferRemainingFunds(

        uint256 _raffleId

    ) external onlyRole(OPERATOR_ROLE) {

        EntryInfoStruct storage entryInfo = rafflesEntryInfo[_raffleId];

        require(

            entryInfo.status == STATUS.CANCEL_REQUESTED ||

                entryInfo.status == STATUS.CANCELLED,

            "Wrong status"

        );



        entryInfo.status = STATUS.CANCELLED;



        (bool sent, ) = destinationWallet.call{value: entryInfo.amountRaised}(

            ""

        );

        require(sent, "Fail send Eth to MW");



        emit RemainingFundsTransferred(_raffleId, entryInfo.amountRaised);



        entryInfo.amountRaised = 0;

    }



    /// @param _raffleId Id of the raffle

    /// @return array of entries bougth of that particular raffle

    function getEntriesBought(

        uint256 _raffleId

    ) external view returns (EntriesBought[] memory) {

        return entriesList[_raffleId];

    }



    /// @dev for different reasons player entries should be void

    /// this has a cost in gas, but this makes cheaper in gas the callback from chainlink

    /// This method has to be called for every raffle of the blacklisted player

    /// @param _raffleId Id of the raffle

    /// @param entriesToCancel array that contains the index of the entries to cancel. 0 based

    /// @param _player player who owns the entry to be voided

    function cancelEntry(

        uint256 _raffleId,

        uint256[] calldata entriesToCancel,

        address _player

    ) external onlyRole(OPERATOR_ROLE) {

        uint256 totalEntriesBoughtCancelled = 0;

        for (uint256 i = 0; i < entriesToCancel.length; i++) {

            EntriesBought storage entry = entriesList[_raffleId][

                entriesToCancel[i] + 1

            ];



            require(entry.player == _player, "Entry did not belong to player");



            entry.player = address(0);



            uint256 previousTotalEntriesLength;

            if (entriesToCancel[i] == 0) previousTotalEntriesLength = 0;

            else

                previousTotalEntriesLength = entriesList[_raffleId][

                    entriesToCancel[i] /* - 1*/

                ].currentEntriesLength;

            totalEntriesBoughtCancelled +=

                entry.currentEntriesLength -

                previousTotalEntriesLength;

        }

        emit EntryCancelled(_raffleId, totalEntriesBoughtCancelled, _player);

    }



    // Requested by Valerio Di Napoli.

    /// @param _raffleId id of the raffle

    /// @param _amountOfEntries amount of entries. Must be lower than maxEntriesPerUser

    /// @param _player The address of the player

    /// @notice Called by other contract created by Valerio, that minted an NFT and after that call this method

    /// @dev add entries but they are free so no payable

    function createFreeEntriesFromExternalContract(

        uint256 _raffleId,

        uint48 _amountOfEntries,

        address _player

    ) external onlyRole(MINTERCONTRACT_ROLE) {

        // if can buy run this code.

        EntryInfoStruct storage entryInfo = rafflesEntryInfo[_raffleId];



        require(

            entryInfo.entryType == ENTRY_TYPE.ONLY_EXTERNAL_CONTRACT ||

                entryInfo.entryType == ENTRY_TYPE.MIXED,

            "Entry type not allowed"

        );



        EntriesBought memory entryBought = EntriesBought({

            player: _player,

            currentEntriesLength: entryInfo.entriesLength + _amountOfEntries

        });

        entriesList[_raffleId].push(entryBought);



        // update the field entriesLength.

        entryInfo.entriesLength += _amountOfEntries;



        address[] memory players = new address[](1);

        players[0] = _player;

        emit FreeEntry(

            _raffleId,

            players,

            _amountOfEntries,

            entryInfo.entriesLength

        );

    }



    function getRafflesEntryInfo(

        uint256 _raffleId

    ) public view returns (EntryInfoStruct memory) {

        return rafflesEntryInfo[_raffleId];

    }



    function playerIsBlacklisted(address _player) external pure returns (bool) {

        //  return blackListManager.isBlackListed(_player);

        return false;

    }



    function raffleNotInAcceptedState(

        uint256 _raffleId

    ) external view returns (bool) {

        EntryInfoStruct memory entryInfo = rafflesEntryInfo[_raffleId];

        return (entryInfo.status != STATUS.ACCEPTED);

    }



    function playerIsSeller(

        address _player,

        uint256 _raffleId

    ) external view returns (bool) {

        RaffleStruct memory raffle = raffles[_raffleId];

        return (raffle.seller == _player);

    }



    function playerReachedMaxEntries(

        address _player,

        uint256 _raffleId,

        uint256 _amountOfEntries

    ) external pure returns (bool) {

        return false;

    }



    /* Requested by Valerio Di Napoli.

    @param _player The address of the player    

    @param _raffleId id of the raffle

    @param _colection Address of the required collection, if any

    @param _tokenIdUsed Id of the token of the required collection the player says he has and want to use in the raffle

    @returns bool if the player can buy or not, and string with the cause of the rejection. "" if can buy

    @notice Method that returns if the user can or cannot buy entries because the player owns an nft in the case or required collections.

    */

    function playerHasRequiredNFTs(

        address _player,

        uint256 _raffleId,

        address _collection,

        uint256 _tokenIdUsed

    ) external pure returns (bool canBuy, string memory cause) {

        return (true, "");

    }

}