{{

  "language": "Solidity",

  "sources": {

    "src/PSYCHOLimited.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity ^0.8.4;\n\nimport \"./IPSYCHOLimited.sol\";\nimport \"./PSYCHOSetup.sol\";\n\n/// @title See {IPSYCHOLimited}\n/// @notice See {IPSYCHOLimited}\ncontract PSYCHOLimited is IPSYCHOLimited, PSYCHOSetup {\n    uint256 private _countMaster = 0;\n    uint256 private _count = 0;\n\n    /// @dev See {IPSYCHOLimited-metadata}\n    function metadata(uint256 _avatarId, string memory _json)\n        public\n        payable\n        override(IPSYCHOLimited)\n    {\n        if (!_isApprovedOrOwner(msg.sender, _avatarId)) {\n            revert NonApprovedNonOwner(\n                isApprovedForAll(ownerOf(_avatarId), msg.sender),\n                getApproved(_avatarId),\n                ownerOf(_avatarId),\n                msg.sender\n            );\n        }\n        if (!_isApprovedOwnerOrOwnership(msg.sender)) {\n            if (msg.value < _fee(1)) {\n                revert FundAccountWith(_fee(1) - msg.value);\n            }\n        }\n        _setCustomExtension(_json, _avatarId);\n    }\n\n    /// @dev See {IPSYCHOLimited-fee}\n    function fee(uint256 _multiplier)\n        public\n        view\n        override(IPSYCHOLimited)\n        returns (uint256)\n    {\n        return _fee(_multiplier);\n    }\n\n    /// @dev See {IPSYCHOLimited-stock}\n    function stock() public view override(IPSYCHOLimited) returns (uint256) {\n        if (_generative()) {\n            return 1001 - _count;\n        } else {\n            return 0;\n        }\n    }\n\n    /// @dev See {IPSYCHOLimited-mint}\n    function mint(uint256 _quantity) public payable override(IPSYCHOLimited) {\n        if (!_isApprovedOwnerOrOwnership(msg.sender)) {\n            if (stock() == 0) {\n                revert StockRemainingIs(stock());\n            }\n            if (msg.value < _fee(_quantity)) {\n                revert FundAccountWith(_fee(_quantity) - msg.value);\n            }\n            if (_count + _quantity > 1001) {\n                revert ExceedsGenerationLimitBy((_count + _quantity) - 1001);\n            }\n            if (_quantity > 20) {\n                revert ExceedsGenerationLimitBy(_quantity - 20);\n            }\n            _count += _quantity;\n        } else {\n            if (_countMaster + _quantity > 99) {\n                revert ExceedsGenerationLimitBy(\n                    (_countMaster + _quantity) - 99\n                );\n            }\n            _countMaster += _quantity;\n        }\n        _eoaMint(msg.sender, _quantity);\n    }\n\n    /// @dev See {IPSYCHOLimited-burn}\n    function burn(uint256 _avatarId) public override(IPSYCHOLimited) {\n        if (tx.origin != msg.sender) {\n            revert TxOriginNonSender(tx.origin, msg.sender);\n        }\n        _burn(msg.sender, _avatarId);\n        if (!_isApprovedOwnerOrOwnership(msg.sender)) {\n            _count -= 1;\n        } else {\n            if (_count > 0) {\n                _count -= 1;\n            } else {\n                _countMaster -= 1;\n            }\n        }\n    }\n}\n"

    },

    "src/PSYCHOSetup.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity ^0.8.4;\n\nimport \"@0xver/solver/supports/ERC721Supports.sol\";\nimport \"./IPSYCHOLimitedErrors.sol\";\n\ncontract PSYCHOSetup is IPSCYHOLimitedErrors, ERC721Supports {\n    error InitiateStatusIs(bool _status);\n\n    bool private _initiated = false;\n    bool private _locked = false;\n\n    uint256 private _weiFee = 200000000000000000;\n\n    mapping(uint256 => uint256) private _block;\n\n    event Withdraw(address operator, address receiver, uint256 value);\n\n    constructor() ERC721Metadata(\"PSYCHO Limited\", \"PSYCHO\") Owner(msg.sender) {\n        _setDefaultExtension(\n            '\"image\":\"ipfs://bafybeidob7iaynjg6h6c3igqnac2qnprlzsfatybuqkxhcizcgpfowwgm4\",\"animation_url\":\"ipfs://bafybeihmygiurvygn7oaruaz66njkvlicbfg7lnsc64ttxbc3o3x4fezfi\"'\n        );\n        _mint(msg.sender, 1);\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n\n    function withdraw(address _to) public ownership {\n        _withdraw(_to);\n    }\n\n    function initialize() public ownership {\n        if (_initiated == false) {\n            _initiated = true;\n        } else {\n            revert InitiateStatusIs(_initiated);\n        }\n    }\n\n    function setFee(uint256 _wei) public ownership {\n        _weiFee = _wei;\n    }\n\n    function resign(bool _bool) public ownership {\n        require(_bool == true);\n        _weiFee = 0;\n        _withdraw(msg.sender);\n        _transferOwnership(address(0));\n        _locked = true;\n    }\n\n    function resigned() public view returns (bool) {\n        return _locked;\n    }\n\n    function _generative() internal view returns (bool) {\n        if (totalSupply() != 1101) {\n            return _initiated;\n        } else {\n            return false;\n        }\n    }\n\n    function _fee(uint256 _multiplier) internal view returns (uint256) {\n        return _weiFee * _multiplier;\n    }\n\n    function _mintHook(uint256 _avatarId) internal override(ERC721) {\n        _block[_avatarId] = block.number;\n    }\n\n    function _defaultExtensionTokenURI(uint256 _avatarId)\n        internal\n        view\n        override(ERC721Metadata)\n        returns (bytes memory)\n    {\n        return\n            abi.encodePacked(\n                _coreTokenURI(_avatarId),\n                \",\",\n                _description(_avatarId),\n                \",\",\n                _defaultExtensionString(),\n                \",\",\n                _attributes(_avatarId)\n            );\n    }\n\n    function _customExtensionTokenURI(uint256 _avatarId)\n        internal\n        view\n        override(ERC721Metadata)\n        returns (bytes memory)\n    {\n        return\n            abi.encodePacked(\n                _description(_avatarId),\n                \",\",\n                _customExtensionString(_avatarId),\n                \",\",\n                _attributes(_avatarId)\n            );\n    }\n\n    function _description(uint256 _avatarId)\n        internal\n        view\n        returns (bytes memory)\n    {\n        return\n            abi.encodePacked(\n                '\"description\":\"',\n                Encode.toString(_block[_avatarId]),\n                '\"'\n            );\n    }\n\n    function _attributes(uint256 _avatarId)\n        internal\n        view\n        returns (bytes memory)\n    {\n        return\n            abi.encodePacked(\n                '\"attributes\":[{\"trait_type\":\"Block\",\"value\":\"',\n                Encode.toHexString(_block[_avatarId]),\n                '\"}]'\n            );\n    }\n\n    function _withdraw(address _to) private {\n        uint256 balance = address(this).balance;\n        (bool success, ) = payable(_to).call{value: address(this).balance}(\"\");\n        require(success, \"ETH_TRANSFER_FAILED\");\n        emit Withdraw(msg.sender, _to, balance);\n    }\n}\n"

    },

    "src/IPSYCHOLimited.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity ^0.8.4;\n\n/// @title PSYCHO Limited\n/// @notice A network of fashionable (limited) avatars\ninterface IPSYCHOLimited {\n    /// @notice Set custom metadata for an avatar\n    /// @param _avatarId to customize must be owner or approved owner\n    /// @param _json should not have {}\n    /// @dev Requires minimum `fee(1)`\n    function metadata(uint256 _avatarId, string memory _json) external payable;\n\n    /// @notice Mint and metadata fee\n    /// @param _quantity multiplied by mint quantity or 1 for metadata\n    /// @return Wei fee\n    function fee(uint256 _quantity) external view returns (uint256);\n\n    /// @notice Available avatars to mint\n    /// @return Avatar stock\n    function stock() external view returns (uint256);\n\n    /// @notice Mints up to 1001 avatars\n    /// @param _quantity max 20 per transaction\n    /// @dev Requires `fee(_quantity)` and `stock() != 0`\n    function mint(uint256 _quantity) external payable;\n\n    /// @notice Burn an avatar\n    /// @param _avatarId to burn must be owner or approved owner\n    /// @dev Subtracts the avatar mint counter by 1\n    function burn(uint256 _avatarId) external;\n}\n"

    },

    "src/IPSYCHOLimitedErrors.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity ^0.8.4;\n\ninterface IPSCYHOLimitedErrors {\n    error ExceedsGenerationLimitBy(uint256 _exceeds);\n\n    error FundAccountWith(uint256 _amount);\n\n    error StockRemainingIs(uint256 _stock);\n}\n"

    },

    "@0xver/solver/supports/ERC721Supports.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity ^0.8.4;\n\nimport \"../interface/IERC165.sol\";\nimport \"../auth/Owner.sol\";\nimport \"../token/metadata/ERC721Metadata.sol\";\n\nabstract contract ERC721Supports is IERC165, Owner, ERC721Metadata {\n    function supportsInterface(bytes4 interfaceId)\n        public\n        pure\n        virtual\n        override(IERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IERC165).interfaceId ||\n            interfaceId == type(IERC173).interfaceId ||\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            interfaceId == type(IERC721Receiver).interfaceId;\n    }\n}\n"

    },

    "@0xver/solver/interface/IERC165.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity ^0.8.4;\n\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"

    },

    "@0xver/solver/auth/Owner.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity ^0.8.4;\n\nimport \"../interface/IERC173.sol\";\nimport \"../interface/errors/IERC173Errors.sol\";\n\ncontract Owner is IERC173, IERC173Errors {\n    address private _owner;\n    address private _getApprovedOwner;\n\n    constructor(address owner_) {\n        _transferOwnership(owner_);\n    }\n\n    modifier ownership() {\n        if (owner() != msg.sender) {\n            revert NonOwnership(owner(), msg.sender);\n        }\n        _;\n    }\n\n    function owner() public view virtual override(IERC173) returns (address) {\n        return _owner;\n    }\n\n    function transferOwnership(address _to)\n        public\n        virtual\n        override(IERC173)\n        ownership\n    {\n        if (_to == address(0)) {\n            revert TransferOwnershipToZeroAddress(owner(), _to);\n        }\n        _transferOwnership(_to);\n    }\n\n    function approveOwnership(address _approved) public virtual ownership {\n        _getApprovedOwner = _approved;\n    }\n\n    function getApprovedOwner() public view virtual returns (address) {\n        return _getApprovedOwner;\n    }\n\n    function _isApprovedOwnerOrOwnership(address _address)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return _getApprovedOwner == _address || _owner == _address;\n    }\n\n    function _transferOwnership(address _to) internal virtual {\n        address _from = _owner;\n        _owner = _to;\n        emit OwnershipTransferred(_from, _to);\n    }\n}\n"

    },

    "@0xver/solver/token/metadata/ERC721Metadata.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity ^0.8.4;\n\nimport \"../ERC721.sol\";\nimport \"../../interface/metadata/IERC721Metadata.sol\";\nimport \"../../library/Encode.sol\";\n\ncontract ERC721Metadata is ERC721, IERC721Metadata {\n    string private _name;\n    string private _symbol;\n    string private _defaultExtension;\n    mapping(uint256 => string) private _customExtension;\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n        _defaultExtension = \"\";\n    }\n\n    function name()\n        public\n        view\n        virtual\n        override(IERC721Metadata)\n        returns (string memory)\n    {\n        return _name;\n    }\n\n    function symbol()\n        public\n        view\n        virtual\n        override(IERC721Metadata)\n        returns (string memory)\n    {\n        return _symbol;\n    }\n\n    function tokenURI(uint256 _tokenId)\n        public\n        view\n        virtual\n        override(IERC721Metadata)\n        returns (string memory)\n    {\n        bytes memory core = _coreTokenURI(_tokenId);\n        bytes memory extension;\n        if (\n            Encode.toBytes32(_customExtension[_tokenId]) == Encode.toBytes32(\"\")\n        ) {\n            if (Encode.toBytes32(_defaultExtension) == Encode.toBytes32(\"\")) {\n                delete extension;\n            } else {\n                delete extension;\n                core = _defaultExtensionTokenURI(_tokenId);\n            }\n        } else {\n            extension = abi.encodePacked(\n                \",\",\n                _customExtensionTokenURI(_tokenId)\n            );\n        }\n        bytes memory data = abi.encodePacked(\"{\", core, extension, \"}\");\n        if (ownerOf(_tokenId) == address(0)) {\n            return \"INVALID_ID\";\n        } else {\n            return\n                string(\n                    abi.encodePacked(\n                        \"data:application/json;base64,\",\n                        Encode.toBase64(data)\n                    )\n                );\n        }\n    }\n\n    function _coreTokenURI(uint256 _tokenId)\n        internal\n        view\n        virtual\n        returns (bytes memory)\n    {\n        return\n            abi.encodePacked(\n                '\"name\":\"',\n                name(),\n                \" #\",\n                Encode.toString(_tokenId),\n                '\"'\n            );\n    }\n\n    function _defaultExtensionTokenURI(uint256 _tokenId)\n        internal\n        view\n        virtual\n        returns (bytes memory)\n    {\n        return\n            abi.encodePacked(\n                _coreTokenURI(_tokenId),\n                \",\",\n                _defaultExtensionString()\n            );\n    }\n\n    function _customExtensionTokenURI(uint256 _tokenId)\n        internal\n        view\n        virtual\n        returns (bytes memory)\n    {\n        return abi.encodePacked(_customExtensionString(_tokenId));\n    }\n\n    function _defaultExtensionString()\n        internal\n        view\n        virtual\n        returns (string memory)\n    {\n        return _defaultExtension;\n    }\n\n    function _customExtensionString(uint256 _tokenId)\n        internal\n        view\n        virtual\n        returns (string memory)\n    {\n        return _customExtension[_tokenId];\n    }\n\n    function _setDefaultExtension(string memory _extension) internal virtual {\n        _defaultExtension = _extension;\n    }\n\n    function _setCustomExtension(string memory _extension, uint256 _tokenId)\n        internal\n        virtual\n    {\n        _customExtension[_tokenId] = _extension;\n    }\n}\n"

    },

    "@0xver/solver/interface/IERC173.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity ^0.8.4;\n\ninterface IERC173 {\n    event OwnershipTransferred(address indexed _from, address indexed _to);\n\n    function owner() external view returns (address);\n\n    function transferOwnership(address _to) external;\n}\n"

    },

    "@0xver/solver/interface/errors/IERC173Errors.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity ^0.8.4;\n\ninterface IERC173Errors {\n    error NonOwnership(address _owner, address _sender);\n\n    error TransferOwnershipToZeroAddress(address _from, address _to);\n}\n"

    },

    "@0xver/solver/token/ERC721.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity ^0.8.4;\n\nimport \"../interface/IERC721.sol\";\nimport \"../interface/errors/IERC721Errors.sol\";\nimport \"../interface/receiver/IERC721Receiver.sol\";\n\ncontract ERC721 is IERC721, IERC721Errors {\n    uint256 private _currentId;\n    uint256 private _subtractId;\n    mapping(address => uint256) private _balanceOf;\n    mapping(uint256 => address) private _ownerOf;\n    mapping(uint256 => address) private _getApproved;\n    mapping(address => mapping(address => bool)) private _isApprovedForAll;\n\n    function balanceOf(address _owner)\n        public\n        view\n        virtual\n        override(IERC721)\n        returns (uint256)\n    {\n        return _balanceOf[_owner];\n    }\n\n    function ownerOf(uint256 _tokenId)\n        public\n        view\n        virtual\n        override(IERC721)\n        returns (address)\n    {\n        return _ownerOf[_tokenId];\n    }\n\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) public virtual override(IERC721) {\n        safeTransferFrom(_from, _to, _tokenId, \"\");\n    }\n\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes memory _data\n    ) public virtual override(IERC721) {\n        if (!_isApprovedOrOwner(msg.sender, _tokenId)) {\n            revert NonApprovedNonOwner(\n                _isApprovedForAll[_ownerOf[_tokenId]][msg.sender],\n                _getApproved[_tokenId],\n                _ownerOf[_tokenId],\n                msg.sender\n            );\n        }\n        _transfer(_from, _to, _tokenId);\n        _onERC721Received(_from, _to, _tokenId, _data);\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) public virtual override(IERC721) {\n        _transfer(_from, _to, _tokenId);\n    }\n\n    function approve(address _approved, uint256 _tokenId)\n        public\n        virtual\n        override(IERC721)\n    {\n        if (_ownerOf[_tokenId] != msg.sender) {\n            revert NonOwnerApproval(_ownerOf[_tokenId], msg.sender);\n        }\n        _getApproved[_tokenId] = _approved;\n        emit Approval(msg.sender, _approved, _tokenId);\n    }\n\n    function setApprovalForAll(address _operator, bool _approved)\n        public\n        virtual\n        override(IERC721)\n    {\n        _isApprovedForAll[msg.sender][_operator] = _approved;\n        emit ApprovalForAll(msg.sender, _operator, _approved);\n    }\n\n    function getApproved(uint256 _tokenId)\n        public\n        view\n        virtual\n        override(IERC721)\n        returns (address)\n    {\n        return _getApproved[_tokenId];\n    }\n\n    function isApprovedForAll(address _owner, address _operator)\n        public\n        view\n        virtual\n        override(IERC721)\n        returns (bool)\n    {\n        return _isApprovedForAll[_owner][_operator];\n    }\n\n    function totalSupply() public view virtual returns (uint256) {\n        return _currentId - _subtractId;\n    }\n\n    function _mintHook(uint256 _tokenId) internal virtual {}\n\n    function _burnHook(uint256 _tokenId) internal virtual {}\n\n    function _transferHook(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) internal virtual {}\n\n    function _isApprovedOrOwner(address _address, uint256 _tokenId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        return\n            _ownerOf[_tokenId] == _address ||\n            _isApprovedForAll[_ownerOf[_tokenId]][_address] ||\n            _getApproved[_tokenId] == _address;\n    }\n\n    function _transfer(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) internal virtual {\n        if (!_isApprovedOrOwner(msg.sender, _tokenId)) {\n            revert NonApprovedNonOwner(\n                _isApprovedForAll[_ownerOf[_tokenId]][msg.sender],\n                _getApproved[_tokenId],\n                _ownerOf[_tokenId],\n                msg.sender\n            );\n        }\n        if (_to == address(0)) {\n            revert TransferTokenToZeroAddress(_from, _to, _tokenId);\n        }\n        _transferHook(_from, _to, _tokenId);\n        delete _getApproved[_tokenId];\n        unchecked {\n            _balanceOf[_from] -= 1;\n            _balanceOf[_to] += 1;\n        }\n        _ownerOf[_tokenId] = _to;\n        emit Transfer(_from, _to, _tokenId);\n    }\n\n    function _totalMinted() internal view virtual returns (uint256) {\n        return _currentId;\n    }\n\n    function _totalBurned() internal view virtual returns (uint256) {\n        return _subtractId;\n    }\n\n    function _safeMint(address _to) internal virtual {\n        _safeMint(_to, \"\");\n    }\n\n    function _safeMint(address _to, bytes memory _data) internal virtual {\n        _mint(_to, 1);\n        if (!_onERC721Received(address(0), _to, _currentId, _data)) {\n            revert TransferToNonERC721Receiver(_to);\n        }\n    }\n\n    function _eoaMint(address _to, uint256 _quantity) internal virtual {\n        if (tx.origin != msg.sender) {\n            revert TxOriginNonSender(tx.origin, msg.sender);\n        }\n        _mint(_to, _quantity);\n    }\n\n    function _mint(address _to, uint256 _quantity) internal virtual {\n        unchecked {\n            for (uint256 i = 0; i < _quantity; i++) {\n                uint256 _tokenId = _currentId + i + 1;\n                _mintHook(_tokenId);\n                _ownerOf[_tokenId] = _to;\n                emit Transfer(address(0), _to, _tokenId);\n            }\n            _balanceOf[_to] += _quantity;\n            _currentId += _quantity;\n        }\n    }\n\n    function _burn(address _from, uint256 _tokenId) internal virtual {\n        if (!_isApprovedOrOwner(msg.sender, _tokenId)) {\n            revert NonApprovedNonOwner(\n                _isApprovedForAll[_ownerOf[_tokenId]][msg.sender],\n                _getApproved[_tokenId],\n                _ownerOf[_tokenId],\n                msg.sender\n            );\n        }\n        delete _getApproved[_tokenId];\n        _ownerOf[_tokenId] = address(0);\n        unchecked {\n            _balanceOf[_from] -= 1;\n            _subtractId += 1;\n        }\n        _burnHook(_tokenId);\n        emit Transfer(_from, address(0), _tokenId);\n    }\n\n    function _onERC721Received(\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (_to.code.length > 0) {\n            try\n                IERC721Receiver(_to).onERC721Received(\n                    msg.sender,\n                    _from,\n                    _tokenId,\n                    _data\n                )\n            returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert TransferToNonERC721Receiver(_to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n}\n"

    },

    "@0xver/solver/interface/metadata/IERC721Metadata.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity ^0.8.4;\n\ninterface IERC721Metadata {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\n}\n"

    },

    "@0xver/solver/library/Encode.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity ^0.8.4;\n\nimport \"./Log.sol\";\n\nlibrary Encode {\n    string internal constant _TABLE =\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    function toBase64(bytes memory _data)\n        internal\n        pure\n        returns (string memory)\n    {\n        if (_data.length == 0) return \"\";\n        string memory table = _TABLE;\n        string memory result = new string(4 * ((_data.length + 2) / 3));\n        assembly {\n            let tablePtr := add(table, 1)\n            let resultPtr := add(result, 32)\n            for {\n                let dataPtr := _data\n                let endPtr := add(_data, mload(_data))\n            } lt(dataPtr, endPtr) {\n\n            } {\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n                mstore8(\n                    resultPtr,\n                    mload(add(tablePtr, and(shr(18, input), 0x3F)))\n                )\n                resultPtr := add(resultPtr, 1)\n                mstore8(\n                    resultPtr,\n                    mload(add(tablePtr, and(shr(12, input), 0x3F)))\n                )\n                resultPtr := add(resultPtr, 1)\n                mstore8(\n                    resultPtr,\n                    mload(add(tablePtr, and(shr(6, input), 0x3F)))\n                )\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\n                resultPtr := add(resultPtr, 1)\n            }\n            switch mod(mload(_data), 3)\n            case 1 {\n                mstore8(sub(resultPtr, 1), 0x3d)\n                mstore8(sub(resultPtr, 2), 0x3d)\n            }\n            case 2 {\n                mstore8(sub(resultPtr, 1), 0x3d)\n            }\n        }\n        return result;\n    }\n\n    function toBytes32(string memory _string) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_string));\n    }\n\n    function toString(uint256 _value) internal pure returns (string memory) {\n        unchecked {\n            uint256 _ptr;\n            uint256 _length = Log.log10(_value) + 1;\n            string memory buffer = new string(_length);\n            assembly {\n                _ptr := add(buffer, add(32, _length))\n            }\n            while (true) {\n                _ptr--;\n                assembly {\n                    mstore8(_ptr, byte(mod(_value, 10), _SYMBOLS))\n                }\n                _value /= 10;\n                if (_value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    function toHexString(uint256 _value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(_value, Log.log256(_value) + 1);\n        }\n    }\n\n    function toHexString(address _addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(_addr)), _ADDRESS_LENGTH);\n    }\n\n    function toHexString(uint256 _value, uint256 _length)\n        internal\n        pure\n        returns (string memory)\n    {\n        bytes memory buffer = new bytes(2 * _length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * _length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[_value & 0xf];\n            _value >>= 4;\n        }\n        require(_value == 0);\n        return string(buffer);\n    }\n}\n"

    },

    "@0xver/solver/interface/IERC721.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity ^0.8.4;\n\ninterface IERC721 {\n    event Transfer(\n        address indexed _from,\n        address indexed _to,\n        uint256 indexed _tokenId\n    );\n\n    event Approval(\n        address indexed _owner,\n        address indexed _approved,\n        uint256 indexed _tokenId\n    );\n\n    event ApprovalForAll(\n        address indexed _owner,\n        address indexed _operator,\n        bool _approved\n    );\n\n    function balanceOf(address _owner) external view returns (uint256);\n\n    function ownerOf(uint256 _tokenId) external view returns (address);\n\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes calldata _data\n    ) external;\n\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) external;\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    ) external;\n\n    function approve(address _approved, uint256 _tokenId) external;\n\n    function setApprovalForAll(address _operator, bool _approved) external;\n\n    function getApproved(uint256 _tokenId) external view returns (address);\n\n    function isApprovedForAll(address _owner, address _operator)\n        external\n        view\n        returns (bool);\n}\n"

    },

    "@0xver/solver/interface/receiver/IERC721Receiver.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity ^0.8.4;\n\ninterface IERC721Receiver {\n    function onERC721Received(\n        address _operator,\n        address _from,\n        uint256 _tokenId,\n        bytes calldata _data\n    ) external returns (bytes4);\n}\n"

    },

    "@0xver/solver/interface/errors/IERC721Errors.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity ^0.8.4;\n\ninterface IERC721Errors {\n    error NonApprovedNonOwner(\n        bool _isApprovedForAll,\n        address _getApproved,\n        address _ownerOf,\n        address _sender\n    );\n\n    error NonOwnerApproval(address _ownerOf, address _sender);\n\n    error TransferTokenToZeroAddress(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    );\n\n    error TransferToNonERC721Receiver(address _contract);\n\n    error TxOriginNonSender(address _origin, address _sender);\n}\n"

    },

    "@0xver/solver/library/Log.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity ^0.8.4;\n\nlibrary Log {\n    function log2(uint256 _value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (_value >> 128 > 0) {\n                _value >>= 128;\n                result += 128;\n            }\n            if (_value >> 64 > 0) {\n                _value >>= 64;\n                result += 64;\n            }\n            if (_value >> 32 > 0) {\n                _value >>= 32;\n                result += 32;\n            }\n            if (_value >> 16 > 0) {\n                _value >>= 16;\n                result += 16;\n            }\n            if (_value >> 8 > 0) {\n                _value >>= 8;\n                result += 8;\n            }\n            if (_value >> 4 > 0) {\n                _value >>= 4;\n                result += 4;\n            }\n            if (_value >> 2 > 0) {\n                _value >>= 2;\n                result += 2;\n            }\n            if (_value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    function log10(uint256 _value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (_value >= 10**64) {\n                _value /= 10**64;\n                result += 64;\n            }\n            if (_value >= 10**32) {\n                _value /= 10**32;\n                result += 32;\n            }\n            if (_value >= 10**16) {\n                _value /= 10**16;\n                result += 16;\n            }\n            if (_value >= 10**8) {\n                _value /= 10**8;\n                result += 8;\n            }\n            if (_value >= 10**4) {\n                _value /= 10**4;\n                result += 4;\n            }\n            if (_value >= 10**2) {\n                _value /= 10**2;\n                result += 2;\n            }\n            if (_value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    function log256(uint256 _value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (_value >> 128 > 0) {\n                _value >>= 128;\n                result += 16;\n            }\n            if (_value >> 64 > 0) {\n                _value >>= 64;\n                result += 8;\n            }\n            if (_value >> 32 > 0) {\n                _value >>= 32;\n                result += 4;\n            }\n            if (_value >> 16 > 0) {\n                _value >>= 16;\n                result += 2;\n            }\n            if (_value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n}\n"

    }

  },

  "settings": {

    "optimizer": {

      "enabled": true,

      "runs": 200

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "libraries": {}

  }

}}