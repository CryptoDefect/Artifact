{{

  "language": "Solidity",

  "sources": {

    "contracts/MerkleDropMinter.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.16;\n\nimport { MerkleProofLib } from \"./MerkleProofLib.sol\";\nimport { IERC165 } from \"./IERC165.sol\";\nimport { ISoundFeeRegistry } from \"./ISoundFeeRegistry.sol\";\nimport { BaseMinter } from \"./BaseMinter.sol\";\nimport { IMerkleDropMinter, EditionMintData, MintInfo } from \"./IMerkleDropMinter.sol\";\nimport { IMinterModule } from \"./IMinterModule.sol\";\nimport { ISoundEditionV1 } from \"./ISoundEditionV1.sol\";\n\n/**\n * @title MerkleDropMinter\n * @dev Module for minting Sound editions using a merkle tree of approved accounts.\n * @author Sound.xyz\n */\ncontract MerkleDropMinter is IMerkleDropMinter, BaseMinter {\n    // =============================================================\n    //                            STORAGE\n    // =============================================================\n\n    /**\n     * @dev Edition mint data.\n     *      Maps `edition` => `mintId` => value.\n     */\n    mapping(address => mapping(uint128 => EditionMintData)) internal _editionMintData;\n\n    // =============================================================\n    //                          CONSTRUCTOR\n    // =============================================================\n\n    constructor(ISoundFeeRegistry feeRegistry_) BaseMinter(feeRegistry_) {}\n\n    // =============================================================\n    //               PUBLIC / EXTERNAL WRITE FUNCTIONS\n    // =============================================================\n\n    /**\n     * @inheritdoc IMerkleDropMinter\n     */\n    function createEditionMint(\n        address edition,\n        bytes32 merkleRootHash,\n        uint96 price,\n        uint32 startTime,\n        uint32 endTime,\n        uint16 affiliateFeeBPS,\n        uint32 maxMintable,\n        uint32 maxMintablePerAccount\n    ) public returns (uint128 mintId) {\n        if (merkleRootHash == bytes32(0)) revert MerkleRootHashIsEmpty();\n        if (maxMintablePerAccount == 0) revert MaxMintablePerAccountIsZero();\n\n        mintId = _createEditionMint(edition, startTime, endTime, affiliateFeeBPS);\n\n        EditionMintData storage data = _editionMintData[edition][mintId];\n        data.merkleRootHash = merkleRootHash;\n        data.price = price;\n        data.maxMintable = maxMintable;\n        data.maxMintablePerAccount = maxMintablePerAccount;\n        // prettier-ignore\n        emit MerkleDropMintCreated(\n            edition,\n            mintId,\n            merkleRootHash,\n            price,\n            startTime,\n            endTime,\n            affiliateFeeBPS,\n            maxMintable,\n            maxMintablePerAccount\n        );\n    }\n\n    /**\n     * @inheritdoc IMerkleDropMinter\n     */\n    function mint(\n        address edition,\n        uint128 mintId,\n        uint32 requestedQuantity,\n        bytes32[] calldata merkleProof,\n        address affiliate\n    ) public payable {\n        EditionMintData storage data = _editionMintData[edition][mintId];\n\n        // Increase `totalMinted` by `requestedQuantity`.\n        // Require that the increased value does not exceed `maxMintable`.\n        data.totalMinted = _incrementTotalMinted(data.totalMinted, requestedQuantity, data.maxMintable);\n\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n        bool valid = MerkleProofLib.verify(merkleProof, data.merkleRootHash, leaf);\n        if (!valid) revert InvalidMerkleProof();\n\n        unchecked {\n            // Check the additional `requestedQuantity` does not exceed the maximum mintable per account.\n            uint256 numberMinted = ISoundEditionV1(edition).numberMinted(msg.sender);\n            // Won't overflow. The total number of tokens minted in `edition` won't exceed `type(uint32).max`,\n            // and `quantity` has 32 bits.\n            if (numberMinted + requestedQuantity > data.maxMintablePerAccount) revert ExceedsMaxPerAccount();\n        }\n\n        _mint(edition, mintId, requestedQuantity, affiliate);\n\n        emit DropClaimed(msg.sender, requestedQuantity);\n    }\n\n    /**\n     * @inheritdoc IMerkleDropMinter\n     */\n    function setPrice(\n        address edition,\n        uint128 mintId,\n        uint96 price\n    ) public onlyEditionOwnerOrAdmin(edition) {\n        _editionMintData[edition][mintId].price = price;\n        emit PriceSet(edition, mintId, price);\n    }\n\n    /**\n     * @inheritdoc IMerkleDropMinter\n     */\n    function setMaxMintablePerAccount(\n        address edition,\n        uint128 mintId,\n        uint32 maxMintablePerAccount\n    ) public onlyEditionOwnerOrAdmin(edition) {\n        if (maxMintablePerAccount == 0) revert MaxMintablePerAccountIsZero();\n        _editionMintData[edition][mintId].maxMintablePerAccount = maxMintablePerAccount;\n        emit MaxMintablePerAccountSet(edition, mintId, maxMintablePerAccount);\n    }\n\n    /**\n     * @inheritdoc IMerkleDropMinter\n     */\n    function setMaxMintable(\n        address edition,\n        uint128 mintId,\n        uint32 maxMintable\n    ) public onlyEditionOwnerOrAdmin(edition) {\n        _editionMintData[edition][mintId].maxMintable = maxMintable;\n        emit MaxMintableSet(edition, mintId, maxMintable);\n    }\n\n    /*\n     * @inheritdoc IMerkleDropMinter\n     */\n    function setMerkleRootHash(\n        address edition,\n        uint128 mintId,\n        bytes32 merkleRootHash\n    ) public onlyEditionOwnerOrAdmin(edition) {\n        if (merkleRootHash == bytes32(0)) revert MerkleRootHashIsEmpty();\n\n        _editionMintData[edition][mintId].merkleRootHash = merkleRootHash;\n        emit MerkleRootHashSet(edition, mintId, merkleRootHash);\n    }\n\n    // =============================================================\n    //               PUBLIC / EXTERNAL VIEW FUNCTIONS\n    // =============================================================\n\n    /**\n     * @inheritdoc IMinterModule\n     */\n    function totalPrice(\n        address edition,\n        uint128 mintId,\n        address, /* minter */\n        uint32 quantity\n    ) public view virtual override(BaseMinter, IMinterModule) returns (uint128) {\n        unchecked {\n            // Will not overflow, as `price` is 96 bits, and `quantity` is 32 bits. 96 + 32 = 128.\n            return uint128(uint256(_editionMintData[edition][mintId].price) * uint256(quantity));\n        }\n    }\n\n    /**\n     * @inheritdoc IMerkleDropMinter\n     */\n    function mintInfo(address edition, uint128 mintId) external view returns (MintInfo memory) {\n        BaseData memory baseData = _baseData[edition][mintId];\n        EditionMintData storage mintData = _editionMintData[edition][mintId];\n\n        MintInfo memory combinedMintData = MintInfo(\n            baseData.startTime,\n            baseData.endTime,\n            baseData.affiliateFeeBPS,\n            baseData.mintPaused,\n            mintData.price,\n            mintData.maxMintable,\n            mintData.maxMintablePerAccount,\n            mintData.totalMinted,\n            mintData.merkleRootHash\n        );\n\n        return combinedMintData;\n    }\n\n    /**\n     * @inheritdoc IERC165\n     */\n    function supportsInterface(bytes4 interfaceId) public view override(IERC165, BaseMinter) returns (bool) {\n        return BaseMinter.supportsInterface(interfaceId) || interfaceId == type(IMerkleDropMinter).interfaceId;\n    }\n\n    /**\n     * @inheritdoc IMinterModule\n     */\n    function moduleInterfaceId() public pure returns (bytes4) {\n        return type(IMerkleDropMinter).interfaceId;\n    }\n}"

    },

    "contracts/ISoundEditionV1.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.16;\n\nimport { IERC721AUpgradeable } from \"./IERC721AUpgradeable.sol\";\nimport { IERC2981Upgradeable } from \"./IERC2981Upgradeable.sol\";\nimport { IERC165Upgradeable } from \"./IERC165Upgradeable.sol\";\n\nimport { IMetadataModule } from \"./IMetadataModule.sol\";\n\n/**\n * @dev The information pertaining to this edition.\n */\nstruct EditionInfo {\n    // Base URI for the tokenId.\n    string baseURI;\n    // Contract URI for OpenSea storefront.\n    string contractURI;\n    // Name of the collection.\n    string name;\n    // Symbol of the collection.\n    string symbol;\n    // Address that receives primary and secondary royalties.\n    address fundingRecipient;\n    // The current max mintable amount;\n    uint32 editionMaxMintable;\n    // The lower limit of the maximum number of tokens that can be minted.\n    uint32 editionMaxMintableUpper;\n    // The upper limit of the maximum number of tokens that can be minted.\n    uint32 editionMaxMintableLower;\n    // The timestamp (in seconds since unix epoch) after which the\n    // max amount of tokens mintable will drop from\n    // `maxMintableUpper` to `maxMintableLower`.\n    uint32 editionCutoffTime;\n    // Address of metadata module, address(0x00) if not used.\n    address metadataModule;\n    // The current mint randomness value.\n    uint256 mintRandomness;\n    // The royalty BPS (basis points).\n    uint16 royaltyBPS;\n    // Whether the mint randomness is enabled.\n    bool mintRandomnessEnabled;\n    // Whether the mint has concluded.\n    bool mintConcluded;\n    // Whether the metadata has been frozen.\n    bool isMetadataFrozen;\n    // Next token ID to be minted.\n    uint256 nextTokenId;\n    // Total number of tokens burned.\n    uint256 totalBurned;\n    // Total number of tokens minted.\n    uint256 totalMinted;\n    // Total number of tokens currently in existence.\n    uint256 totalSupply;\n}\n\n/**\n * @title ISoundEditionV1\n * @notice The interface for Sound edition contracts.\n */\ninterface ISoundEditionV1 is IERC721AUpgradeable, IERC2981Upgradeable {\n    // =============================================================\n    //                            EVENTS\n    // =============================================================\n\n    /**\n     * @dev Emitted when the metadata module is set.\n     * @param metadataModule the address of the metadata module.\n     */\n    event MetadataModuleSet(address metadataModule);\n\n    /**\n     * @dev Emitted when the `baseURI` is set.\n     * @param baseURI the base URI of the edition.\n     */\n    event BaseURISet(string baseURI);\n\n    /**\n     * @dev Emitted when the `contractURI` is set.\n     * @param contractURI The contract URI of the edition.\n     */\n    event ContractURISet(string contractURI);\n\n    /**\n     * @dev Emitted when the metadata is frozen (e.g.: `baseURI` can no longer be changed).\n     * @param metadataModule The address of the metadata module.\n     * @param baseURI        The base URI of the edition.\n     * @param contractURI    The contract URI of the edition.\n     */\n    event MetadataFrozen(address metadataModule, string baseURI, string contractURI);\n\n    /**\n     * @dev Emitted when the `fundingRecipient` is set.\n     * @param fundingRecipient The address of the funding recipient.\n     */\n    event FundingRecipientSet(address fundingRecipient);\n\n    /**\n     * @dev Emitted when the `royaltyBPS` is set.\n     * @param bps The new royalty, measured in basis points.\n     */\n    event RoyaltySet(uint16 bps);\n\n    /**\n     * @dev Emitted when the edition's maximum mintable token quantity range is set.\n     * @param editionMaxMintableLower_ The lower limit of the maximum number of tokens that can be minted.\n     * @param editionMaxMintableUpper_ The upper limit of the maximum number of tokens that can be minted.\n     */\n    event EditionMaxMintableRangeSet(uint32 editionMaxMintableLower_, uint32 editionMaxMintableUpper_);\n\n    /**\n     * @dev Emitted when the edition's cutoff time set.\n     * @param editionCutoffTime_ The timestamp.\n     */\n    event EditionCutoffTimeSet(uint32 editionCutoffTime_);\n\n    /**\n     * @dev Emitted when the `mintRandomnessEnabled` is set.\n     * @param mintRandomnessEnabled_ The boolean value.\n     */\n    event MintRandomnessEnabledSet(bool mintRandomnessEnabled_);\n\n    /**\n     * @dev Emitted upon initialization.\n     * @param edition_                 The address of the edition.\n     * @param name_                    Name of the collection.\n     * @param symbol_                  Symbol of the collection.\n     * @param metadataModule_          Address of metadata module, address(0x00) if not used.\n     * @param baseURI_                 Base URI.\n     * @param contractURI_             Contract URI for OpenSea storefront.\n     * @param fundingRecipient_        Address that receives primary and secondary royalties.\n     * @param royaltyBPS_              Royalty amount in bps (basis points).\n     * @param editionMaxMintableLower_ The lower bound of the max mintable quantity for the edition.\n     * @param editionMaxMintableUpper_ The upper bound of the max mintable quantity for the edition.\n     * @param editionCutoffTime_       The timestamp after which `editionMaxMintable` drops from\n     *                                 `editionMaxMintableUpper` to\n     *                                 `max(_totalMinted(), editionMaxMintableLower)`.\n     * @param flags_                   The bitwise OR result of the initialization flags.\n     *                                 See: {METADATA_IS_FROZEN_FLAG}\n     *                                 See: {MINT_RANDOMNESS_ENABLED_FLAG}\n     */\n    event SoundEditionInitialized(\n        address indexed edition_,\n        string name_,\n        string symbol_,\n        address metadataModule_,\n        string baseURI_,\n        string contractURI_,\n        address fundingRecipient_,\n        uint16 royaltyBPS_,\n        uint32 editionMaxMintableLower_,\n        uint32 editionMaxMintableUpper_,\n        uint32 editionCutoffTime_,\n        uint8 flags_\n    );\n\n    // =============================================================\n    //                            ERRORS\n    // =============================================================\n\n    /**\n     * @dev The edition's metadata is frozen (e.g.: `baseURI` can no longer be changed).\n     */\n    error MetadataIsFrozen();\n\n    /**\n     * @dev The given `royaltyBPS` is invalid.\n     */\n    error InvalidRoyaltyBPS();\n\n    /**\n     * @dev The given `randomnessLockedAfterMinted` value is invalid.\n     */\n    error InvalidRandomnessLock();\n\n    /**\n     * @dev The requested quantity exceeds the edition's remaining mintable token quantity.\n     * @param available The number of tokens remaining available for mint.\n     */\n    error ExceedsEditionAvailableSupply(uint32 available);\n\n    /**\n     * @dev The given amount is invalid.\n     */\n    error InvalidAmount();\n\n    /**\n     * @dev The given `fundingRecipient` address is invalid.\n     */\n    error InvalidFundingRecipient();\n\n    /**\n     * @dev The `editionMaxMintableLower` must not be greater than `editionMaxMintableUpper`.\n     */\n    error InvalidEditionMaxMintableRange();\n\n    /**\n     * @dev The `editionMaxMintable` has already been reached.\n     */\n    error MaximumHasAlreadyBeenReached();\n\n    /**\n     * @dev The mint `quantity` cannot exceed `ADDRESS_BATCH_MINT_LIMIT` tokens.\n     */\n    error ExceedsAddressBatchMintLimit();\n\n    /**\n     * @dev The mint randomness has already been revealed.\n     */\n    error MintRandomnessAlreadyRevealed();\n\n    /**\n     * @dev No addresses to airdrop.\n     */\n    error NoAddressesToAirdrop();\n\n    /**\n     * @dev The mint has already concluded.\n     */\n    error MintHasConcluded();\n\n    /**\n     * @dev Cannot perform the operation after a token has been minted.\n     */\n    error MintsAlreadyExist();\n\n    // =============================================================\n    //               PUBLIC / EXTERNAL WRITE FUNCTIONS\n    // =============================================================\n\n    /**\n     * @dev Initializes the contract.\n     * @param name_                    Name of the collection.\n     * @param symbol_                  Symbol of the collection.\n     * @param metadataModule_          Address of metadata module, address(0x00) if not used.\n     * @param baseURI_                 Base URI.\n     * @param contractURI_             Contract URI for OpenSea storefront.\n     * @param fundingRecipient_        Address that receives primary and secondary royalties.\n     * @param royaltyBPS_              Royalty amount in bps (basis points).\n     * @param editionMaxMintableLower_ The lower bound of the max mintable quantity for the edition.\n     * @param editionMaxMintableUpper_ The upper bound of the max mintable quantity for the edition.\n     * @param editionCutoffTime_       The timestamp after which `editionMaxMintable` drops from\n     *                                 `editionMaxMintableUpper` to\n     *                                 `max(_totalMinted(), editionMaxMintableLower)`.\n     * @param flags_                   The bitwise OR result of the initialization flags.\n     *                                 See: {METADATA_IS_FROZEN_FLAG}\n     *                                 See: {MINT_RANDOMNESS_ENABLED_FLAG}\n     */\n    function initialize(\n        string memory name_,\n        string memory symbol_,\n        address metadataModule_,\n        string memory baseURI_,\n        string memory contractURI_,\n        address fundingRecipient_,\n        uint16 royaltyBPS_,\n        uint32 editionMaxMintableLower_,\n        uint32 editionMaxMintableUpper_,\n        uint32 editionCutoffTime_,\n        uint8 flags_\n    ) external;\n\n    /**\n     * @dev Mints `quantity` tokens to addrress `to`\n     *      Each token will be assigned a token ID that is consecutively increasing.\n     *\n     * Calling conditions:\n     * - The caller must be the owner of the contract, or have either the\n     *   `ADMIN_ROLE`, `MINTER_ROLE`, which can be granted via {grantRole}.\n     *   Multiple minters, such as different minter contracts,\n     *   can be authorized simultaneously.\n     *\n     * @param to       Address to mint to.\n     * @param quantity Number of tokens to mint.\n     * @return fromTokenId The first token ID minted.\n     */\n    function mint(address to, uint256 quantity) external payable returns (uint256 fromTokenId);\n\n    /**\n     * @dev Mints `quantity` tokens to each of the addresses in `to`.\n     *\n     * Calling conditions:\n     * - The caller must be the owner of the contract, or have the\n     *   `ADMIN_ROLE`, which can be granted via {grantRole}.\n     *\n     * @param to           Address to mint to.\n     * @param quantity     Number of tokens to mint.\n     * @return fromTokenId The first token ID minted.\n     */\n    function airdrop(address[] calldata to, uint256 quantity) external returns (uint256 fromTokenId);\n\n    /**\n     * @dev Withdraws collected ETH royalties to the fundingRecipient.\n     */\n    function withdrawETH() external;\n\n    /**\n     * @dev Withdraws collected ERC20 royalties to the fundingRecipient.\n     * @param tokens array of ERC20 tokens to withdraw\n     */\n    function withdrawERC20(address[] calldata tokens) external;\n\n    /**\n     * @dev Sets metadata module.\n     *\n     * Calling conditions:\n     * - The caller must be the owner of the contract, or have the `ADMIN_ROLE`.\n     *\n     * @param metadataModule Address of metadata module.\n     */\n    function setMetadataModule(address metadataModule) external;\n\n    /**\n     * @dev Sets global base URI.\n     *\n     * Calling conditions:\n     * - The caller must be the owner of the contract, or have the `ADMIN_ROLE`.\n     *\n     * @param baseURI The base URI to be set.\n     */\n    function setBaseURI(string memory baseURI) external;\n\n    /**\n     * @dev Sets contract URI.\n     *\n     * Calling conditions:\n     * - The caller must be the owner of the contract, or have the `ADMIN_ROLE`.\n     *\n     * @param contractURI The contract URI to be set.\n     */\n    function setContractURI(string memory contractURI) external;\n\n    /**\n     * @dev Freezes metadata by preventing any more changes to base URI.\n     *\n     * Calling conditions:\n     * - The caller must be the owner of the contract, or have the `ADMIN_ROLE`.\n     */\n    function freezeMetadata() external;\n\n    /**\n     * @dev Sets funding recipient address.\n     *\n     * Calling conditions:\n     * - The caller must be the owner of the contract, or have the `ADMIN_ROLE`.\n     *\n     * @param fundingRecipient Address to be set as the new funding recipient.\n     */\n    function setFundingRecipient(address fundingRecipient) external;\n\n    /**\n     * @dev Sets royalty amount in bps (basis points).\n     *\n     * Calling conditions:\n     * - The caller must be the owner of the contract, or have the `ADMIN_ROLE`.\n     *\n     * @param bps The new royalty basis points to be set.\n     */\n    function setRoyalty(uint16 bps) external;\n\n    /**\n     * @dev Sets the edition max mintable range.\n     *\n     * Calling conditions:\n     * - The caller must be the owner of the contract, or have the `ADMIN_ROLE`.\n     *\n     * @param editionMaxMintableLower_ The lower limit of the maximum number of tokens that can be minted.\n     * @param editionMaxMintableUpper_ The upper limit of the maximum number of tokens that can be minted.\n     */\n    function setEditionMaxMintableRange(uint32 editionMaxMintableLower_, uint32 editionMaxMintableUpper_) external;\n\n    /**\n     * @dev Sets the timestamp after which, the `editionMaxMintable` drops\n     *      from `editionMaxMintableUpper` to `editionMaxMintableLower.\n     *\n     * Calling conditions:\n     * - The caller must be the owner of the contract, or have the `ADMIN_ROLE`.\n     *\n     * @param editionCutoffTime_ The timestamp.\n     */\n    function setEditionCutoffTime(uint32 editionCutoffTime_) external;\n\n    /**\n     * @dev Sets whether the `mintRandomness` is enabled.\n     *\n     * Calling conditions:\n     * - The caller must be the owner of the contract, or have the `ADMIN_ROLE`.\n     *\n     * @param mintRandomnessEnabled_ The boolean value.\n     */\n    function setMintRandomnessEnabled(bool mintRandomnessEnabled_) external;\n\n    // =============================================================\n    //               PUBLIC / EXTERNAL VIEW FUNCTIONS\n    // =============================================================\n\n    /**\n     * @dev Returns the edition info.\n     * @return editionInfo The latest value.\n     */\n    function editionInfo() external view returns (EditionInfo memory editionInfo);\n\n    /**\n     * @dev Returns the minter role flag.\n     * @return The constant value.\n     */\n    function MINTER_ROLE() external view returns (uint256);\n\n    /**\n     * @dev Returns the admin role flag.\n     * @return The constant value.\n     */\n    function ADMIN_ROLE() external view returns (uint256);\n\n    /**\n     * @dev Returns the maximum limit for the mint or airdrop `quantity`.\n     *      Prevents the first-time transfer costs for tokens near the end of large mint batches\n     *      via ERC721A from becoming too expensive due to the need to scan many storage slots.\n     *      See: https://chiru-labs.github.io/ERC721A/#/tips?id=batch-size\n     * @return The constant value.\n     */\n    function ADDRESS_BATCH_MINT_LIMIT() external pure returns (uint256);\n\n    /**\n     * @dev Returns the bit flag to freeze the metadata on initialization.\n     * @return The constant value.\n     */\n    function METADATA_IS_FROZEN_FLAG() external pure returns (uint8);\n\n    /**\n     * @dev Returns the bit flag to enable the mint randomness feature on initialization.\n     * @return The constant value.\n     */\n    function MINT_RANDOMNESS_ENABLED_FLAG() external pure returns (uint8);\n\n    /**\n     * @dev Returns the base token URI for the collection.\n     * @return The configured value.\n     */\n    function baseURI() external view returns (string memory);\n\n    /**\n     * @dev Returns the contract URI to be used by Opensea.\n     *      See: https://docs.opensea.io/docs/contract-level-metadata\n     * @return The configured value.\n     */\n    function contractURI() external view returns (string memory);\n\n    /**\n     * @dev Returns the address of the funding recipient.\n     * @return The configured value.\n     */\n    function fundingRecipient() external view returns (address);\n\n    /**\n     * @dev Returns the maximum amount of tokens mintable for this edition.\n     * @return The configured value.\n     */\n    function editionMaxMintable() external view returns (uint32);\n\n    /**\n     * @dev Returns the upper bound for the maximum tokens that can be minted for this edition.\n     * @return The configured value.\n     */\n    function editionMaxMintableUpper() external view returns (uint32);\n\n    /**\n     * @dev Returns the lower bound for the maximum tokens that can be minted for this edition.\n     * @return The configured value.\n     */\n    function editionMaxMintableLower() external view returns (uint32);\n\n    /**\n     * @dev Returns the timestamp after which `editionMaxMintable` drops from\n     *      `editionMaxMintableUpper` to `editionMaxMintableLower`.\n     * @return The configured value.\n     */\n    function editionCutoffTime() external view returns (uint32);\n\n    /**\n     * @dev Returns the address of the metadata module.\n     * @return The configured value.\n     */\n    function metadataModule() external view returns (address);\n\n    /**\n     * @dev Returns the randomness based on latest block hash, which is stored upon each mint.\n     *      unless {mintConcluded} is true.\n     *      Used for game mechanics like the Sound Golden Egg.\n     *      Returns 0 before revealed.\n     *      WARNING: This value should NOT be used for any reward of significant monetary\n     *      value, due to it being computed via a purely on-chain psuedorandom mechanism.\n     * @return The latest value.\n     */\n    function mintRandomness() external view returns (uint256);\n\n    /**\n     * @dev Returns whether the `mintRandomness` has been enabled.\n     * @return The configured value.\n     */\n    function mintRandomnessEnabled() external view returns (bool);\n\n    /**\n     * @dev Returns whether the mint has been concluded.\n     * @return The latest value.\n     */\n    function mintConcluded() external view returns (bool);\n\n    /**\n     * @dev Returns the royalty basis points.\n     * @return The configured value.\n     */\n    function royaltyBPS() external view returns (uint16);\n\n    /**\n     * @dev Returns whether the metadata module is frozen.\n     * @return The configured value.\n     */\n    function isMetadataFrozen() external view returns (bool);\n\n    /**\n     * @dev Returns the next token ID to be minted.\n     * @return The latest value.\n     */\n    function nextTokenId() external view returns (uint256);\n\n    /**\n     * @dev Returns the number of tokens minted by `owner`.\n     * @param owner Address to query for number minted.\n     * @return The latest value.\n     */\n    function numberMinted(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the number of tokens burned by `owner`.\n     * @param owner Address to query for number burned.\n     * @return The latest value.\n     */\n    function numberBurned(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the total amount of tokens minted.\n     * @return The latest value.\n     */\n    function totalMinted() external view returns (uint256);\n\n    /**\n     * @dev Returns the total amount of tokens burned.\n     * @return The latest value.\n     */\n    function totalBurned() external view returns (uint256);\n\n    /**\n     * @dev Informs other contracts which interfaces this contract supports.\n     *      Required by https://eips.ethereum.org/EIPS/eip-165\n     * @param interfaceId The interface id to check.\n     * @return Whether the `interfaceId` is supported.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        external\n        view\n        override(IERC721AUpgradeable, IERC165Upgradeable)\n        returns (bool);\n}"

    },

    "contracts/IMinterModule.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.16;\n\nimport { IERC165 } from \"./IERC165.sol\";\nimport { ISoundFeeRegistry } from \"./ISoundFeeRegistry.sol\";\n\n/**\n * @title IMinterModule\n * @notice The interface for Sound protocol minter modules.\n */\ninterface IMinterModule is IERC165 {\n    // =============================================================\n    //                            STRUCTS\n    // =============================================================\n\n    struct BaseData {\n        // The start unix timestamp of the mint.\n        uint32 startTime;\n        // The end unix timestamp of the mint.\n        uint32 endTime;\n        // The affiliate fee in basis points.\n        uint16 affiliateFeeBPS;\n        // Whether the mint is paused.\n        bool mintPaused;\n    }\n\n    // =============================================================\n    //                            EVENTS\n    // =============================================================\n\n    /**\n     * @dev Emitted when the mint instance for an `edition` is created.\n     * @param edition The edition address.\n     * @param mintId The mint ID, a global incrementing identifier used within the minter\n     * @param startTime The start time of the mint.\n     * @param endTime The end time of the mint.\n     * @param affiliateFeeBPS The affiliate fee in basis points.\n     */\n    event MintConfigCreated(\n        address indexed edition,\n        address indexed creator,\n        uint128 mintId,\n        uint32 startTime,\n        uint32 endTime,\n        uint16 affiliateFeeBPS\n    );\n\n    /**\n     * @dev Emitted when the `paused` status of `edition` is updated.\n     * @param edition The edition address.\n     * @param mintId  The mint ID, to distinguish between multiple mints for the same edition.\n     * @param paused  The new paused status.\n     */\n    event MintPausedSet(address indexed edition, uint128 mintId, bool paused);\n\n    /**\n     * @dev Emitted when the `paused` status of `edition` is updated.\n     * @param edition   The edition address.\n     * @param mintId    The mint ID, to distinguish between multiple mints for the same edition.\n     * @param startTime The start time of the mint.\n     * @param endTime   The end time of the mint.\n     */\n    event TimeRangeSet(address indexed edition, uint128 indexed mintId, uint32 startTime, uint32 endTime);\n\n    /**\n     * @notice Emitted when the `affiliateFeeBPS` is updated.\n     * @param edition The edition address.\n     * @param mintId  The mint ID, to distinguish between multiple mints for the same edition.\n     * @param bps     The affiliate fee basis points.\n     */\n    event AffiliateFeeSet(address indexed edition, uint128 indexed mintId, uint16 bps);\n\n    /**\n     * @notice Emitted when a mint happens.\n     * @param edition            The edition address.\n     * @param mintId             The mint ID, to distinguish between multiple mints for\n     *                           the same edition.\n     * @param buyer              The buyer address.\n     * @param fromTokenId        The first token ID of the batch.\n     * @param quantity           The size of the batch.\n     * @param requiredEtherValue Total amount of Ether required for payment.\n     * @param platformFee        The cut paid to the platform.\n     * @param affiliateFee       The cut paid to the affiliate.\n     * @param affiliate          The affiliate's address.\n     * @param affiliated         Whether the affiliate is affiliated.\n     */\n    event Minted(\n        address indexed edition,\n        uint128 indexed mintId,\n        address indexed buyer,\n        uint32 fromTokenId,\n        uint32 quantity,\n        uint128 requiredEtherValue,\n        uint128 platformFee,\n        uint128 affiliateFee,\n        address affiliate,\n        bool affiliated\n    );\n\n    // =============================================================\n    //                            ERRORS\n    // =============================================================\n\n    /**\n     * @dev The Ether value paid is below the value required.\n     * @param paid The amount sent to the contract.\n     * @param required The amount required to mint.\n     */\n    error Underpaid(uint256 paid, uint256 required);\n\n    /**\n     * @dev The number minted has exceeded the max mintable amount.\n     * @param available The number of tokens remaining available for mint.\n     */\n    error ExceedsAvailableSupply(uint32 available);\n\n    /**\n     * @dev The mint is not opened.\n     * @param blockTimestamp The current block timestamp.\n     * @param startTime The start time of the mint.\n     * @param endTime The end time of the mint.\n     */\n    error MintNotOpen(uint256 blockTimestamp, uint32 startTime, uint32 endTime);\n\n    /**\n     * @dev The mint is paused.\n     */\n    error MintPaused();\n\n    /**\n     * @dev The `startTime` is not less than the `endTime`.\n     */\n    error InvalidTimeRange();\n\n    /**\n     * @dev Unauthorized caller\n     */\n    error Unauthorized();\n\n    /**\n     * @dev The affiliate fee numerator must not exceed `MAX_BPS`.\n     */\n    error InvalidAffiliateFeeBPS();\n\n    /**\n     * @dev Fee registry cannot be the zero address.\n     */\n    error FeeRegistryIsZeroAddress();\n\n    // =============================================================\n    //               PUBLIC / EXTERNAL WRITE FUNCTIONS\n    // =============================================================\n\n    /**\n     * @dev Sets the paused status for (`edition`, `mintId`).\n     *\n     * Calling conditions:\n     * - The caller must be the edition's owner or admin.\n     */\n    function setEditionMintPaused(\n        address edition,\n        uint128 mintId,\n        bool paused\n    ) external;\n\n    /**\n     * @dev Sets the time range for an edition mint.\n     *\n     * Calling conditions:\n     * - The caller must be the edition's owner or admin.\n     *\n     * @param edition The edition address.\n     * @param mintId The mint ID, a global incrementing identifier used within the minter\n     * @param startTime The start time of the mint.\n     * @param endTime The end time of the mint.\n     */\n    function setTimeRange(\n        address edition,\n        uint128 mintId,\n        uint32 startTime,\n        uint32 endTime\n    ) external;\n\n    /**\n     * @dev Sets the affiliate fee for (`edition`, `mintId`).\n     *\n     * Calling conditions:\n     * - The caller must be the edition's owner or admin.\n     */\n    function setAffiliateFee(\n        address edition,\n        uint128 mintId,\n        uint16 affiliateFeeBPS\n    ) external;\n\n    /**\n     * @dev Withdraws all the accrued fees for `affiliate`.\n     */\n    function withdrawForAffiliate(address affiliate) external;\n\n    /**\n     * @dev Withdraws all the accrued fees for the platform.\n     */\n    function withdrawForPlatform() external;\n\n    // =============================================================\n    //               PUBLIC / EXTERNAL VIEW FUNCTIONS\n    // =============================================================\n\n    /**\n     * @dev The total fees accrued for `affiliate`.\n     * @param affiliate The affiliate's address.\n     * @return The latest value.\n     */\n    function affiliateFeesAccrued(address affiliate) external view returns (uint128);\n\n    /**\n     * @dev The total fees accrued for the platform.\n     * @return The latest value.\n     */\n    function platformFeesAccrued() external view returns (uint128);\n\n    /**\n     * @dev Whether `affiliate` is affiliated for (`edition`, `mintId`).\n     * @param edition   The edition's address.\n     * @param mintId    The mint ID.\n     * @param affiliate The affiliate's address.\n     * @return The computed value.\n     */\n    function isAffiliated(\n        address edition,\n        uint128 mintId,\n        address affiliate\n    ) external view returns (bool);\n\n    /**\n     * @dev The total price for `quantity` tokens for (`edition`, `mintId`).\n     * @param edition   The edition's address.\n     * @param mintId    The mint ID.\n     * @param mintId    The minter's address.\n     * @param quantity  The number of tokens to mint.\n     * @return The computed value.\n     */\n    function totalPrice(\n        address edition,\n        uint128 mintId,\n        address minter,\n        uint32 quantity\n    ) external view returns (uint128);\n\n    /**\n     * @dev The next mint ID.\n     *      A mint ID is assigned sequentially starting from (0, 1, 2, ...),\n     *      and is shared amongst all editions connected to the minter contract.\n     * @return The latest value.\n     */\n    function nextMintId() external view returns (uint128);\n\n    /**\n     * @dev The interface ID of the minter.\n     * @return The constant value.\n     */\n    function moduleInterfaceId() external view returns (bytes4);\n\n    /**\n     * @dev The fee registry. Used for handling platform fees.\n     * @return The immutable value.\n     */\n    function feeRegistry() external view returns (ISoundFeeRegistry);\n}"

    },

    "contracts/IMerkleDropMinter.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.16;\n\nimport { IMinterModule } from \"./IMinterModule.sol\";\n\n/**\n * @dev Data unique to a merkle drop mint.\n */\nstruct EditionMintData {\n    // Hash of the root node for the merkle tree drop\n    bytes32 merkleRootHash;\n    // The price at which each token will be sold, in ETH.\n    uint96 price;\n    // The maximum number of tokens that can can be minted for this sale.\n    uint32 maxMintable;\n    // The maximum number of tokens that a wallet can mint.\n    uint32 maxMintablePerAccount;\n    // The total number of tokens minted so far for this sale.\n    uint32 totalMinted;\n}\n\n/**\n * @dev All the information about a merkle drop mint (combines EditionMintData with BaseData).\n */\nstruct MintInfo {\n    uint32 startTime;\n    uint32 endTime;\n    uint16 affiliateFeeBPS;\n    bool mintPaused;\n    uint96 price;\n    uint32 maxMintable;\n    uint32 maxMintablePerAccount;\n    uint32 totalMinted;\n    bytes32 merkleRootHash;\n}\n\n/**\n * @title IMerkleDropMinter\n * @dev Interface for the `MerkleDropMinter` module.\n * @author Sound.xyz\n */\ninterface IMerkleDropMinter is IMinterModule {\n    // =============================================================\n    //                            EVENTS\n    // =============================================================\n\n    /**\n     * @dev Emitted when a new merkle drop mint is created.\n     * @param edition               The edition address.\n     * @param mintId                The mint ID.\n     * @param merkleRootHash        The root of the merkle tree of the approved addresses.\n     * @param price                 The price at which each token will be sold, in ETH.\n     * @param startTime             The time minting can begin.\n     * @param endTime               The time minting will end.\n     * @param affiliateFeeBPS       The affiliate fee in basis points.\n     * @param maxMintable           The maximum number of tokens that can be minted.\n     * @param maxMintablePerAccount The maximum number of tokens that an account can mint.\n     */\n    event MerkleDropMintCreated(\n        address indexed edition,\n        uint128 indexed mintId,\n        bytes32 merkleRootHash,\n        uint96 price,\n        uint32 startTime,\n        uint32 endTime,\n        uint16 affiliateFeeBPS,\n        uint32 maxMintable,\n        uint32 maxMintablePerAccount\n    );\n\n    /**\n     * @dev Emitted when tokens are claimed by an account.\n     * @param recipient The address of the account that claimed the tokens.\n     * @param quantity  The quantity of tokens claimed.\n     */\n    event DropClaimed(address recipient, uint32 quantity);\n\n    /**\n     * @dev Emitted when the `price` is changed for (`edition`, `mintId`).\n     * @param edition Address of the song edition contract we are minting for.\n     * @param mintId  The mint ID.\n     * @param price   Sale price in ETH for minting a single token in `edition`.\n     */\n    event PriceSet(address indexed edition, uint128 indexed mintId, uint96 price);\n\n    /**\n     * @dev Emitted when the `maxMintable` is changed for (`edition`, `mintId`).\n     * @param edition               Address of the song edition contract we are minting for.\n     * @param mintId                The mint ID.\n     * @param maxMintable The maximum number of tokens that can be minted on this schedule.\n     */\n    event MaxMintableSet(address indexed edition, uint128 indexed mintId, uint32 maxMintable);\n\n    /**\n     * @dev Emitted when the `maxMintablePerAccount` is changed for (`edition`, `mintId`).\n     * @param edition               Address of the song edition contract we are minting for.\n     * @param mintId                The mint ID.\n     * @param maxMintablePerAccount The maximum number of tokens that can be minted per account.\n     */\n    event MaxMintablePerAccountSet(address indexed edition, uint128 indexed mintId, uint32 maxMintablePerAccount);\n\n    /**\n     * @dev Emitted when the `merkleRootHash` is changed for (`edition`, `mintId`).\n     * @param edition        Address of the song edition contract we are minting for.\n     * @param mintId         The mint ID.\n     * @param merkleRootHash The merkle root hash of the entries.\n     */\n    event MerkleRootHashSet(address indexed edition, uint128 indexed mintId, bytes32 merkleRootHash);\n\n    // =============================================================\n    //                            ERRORS\n    // =============================================================\n\n    /**\n     * @dev The merkle proof is invalid.\n     */\n    error InvalidMerkleProof();\n\n    /**\n     * @dev The number of tokens minted has exceeded the number allowed for each account.\n     */\n    error ExceedsMaxPerAccount();\n\n    /**\n     * @dev The merkle root hash is empty.\n     */\n    error MerkleRootHashIsEmpty();\n\n    /**\n     * @dev The max mintable per account cannot be zero.\n     */\n    error MaxMintablePerAccountIsZero();\n\n    // =============================================================\n    //               PUBLIC / EXTERNAL WRITE FUNCTIONS\n    // =============================================================\n\n    /**\n     * @dev Initializes merkle drop mint instance.\n     * @param edition                Address of the song edition contract we are minting for.\n     * @param merkleRootHash         bytes32 hash of the Merkle tree representing eligible mints.\n     * @param price                  Sale price in ETH for minting a single token in `edition`.\n     * @param startTime              Start timestamp of sale (in seconds since unix epoch).\n     * @param endTime                End timestamp of sale (in seconds since unix epoch).\n     * @param affiliateFeeBPS        The affiliate fee in basis points.\n     * @param maxMintable_           The maximum number of tokens that can can be minted for this sale.\n     * @param maxMintablePerAccount_ The maximum number of tokens that a single account can mint.\n     * @return mintId The ID of the new mint instance.\n     */\n    function createEditionMint(\n        address edition,\n        bytes32 merkleRootHash,\n        uint96 price,\n        uint32 startTime,\n        uint32 endTime,\n        uint16 affiliateFeeBPS,\n        uint32 maxMintable_,\n        uint32 maxMintablePerAccount_\n    ) external returns (uint128 mintId);\n\n    /**\n     * @dev Mints a token for a particular mint instance.\n     * @param mintId            The ID of the mint instance.\n     * @param requestedQuantity The quantity of tokens to mint.\n     */\n    function mint(\n        address edition,\n        uint128 mintId,\n        uint32 requestedQuantity,\n        bytes32[] calldata merkleProof,\n        address affiliate\n    ) external payable;\n\n    /*\n     * @dev Sets the `price` for (`edition`, `mintId`).\n     * @param edition Address of the song edition contract we are minting for.\n     * @param mintId  The mint ID.\n     * @param price   Sale price in ETH for minting a single token in `edition`.\n     */\n    function setPrice(\n        address edition,\n        uint128 mintId,\n        uint96 price\n    ) external;\n\n    /*\n     * @dev Sets the `maxMintablePerAccount` for (`edition`, `mintId`).\n     * @param edition               Address of the song edition contract we are minting for.\n     * @param mintId                The mint ID.\n     * @param maxMintablePerAccount The maximum number of tokens that can be minted by an account.\n     */\n    function setMaxMintablePerAccount(\n        address edition,\n        uint128 mintId,\n        uint32 maxMintablePerAccount\n    ) external;\n\n    /*\n     * @dev Sets the `maxMintable` for (`edition`, `mintId`).\n     * @param edition               Address of the song edition contract we are minting for.\n     * @param mintId                The mint ID.\n     * @param maxMintable The maximum number of tokens that can be minted on this schedule.\n     */\n    function setMaxMintable(\n        address edition,\n        uint128 mintId,\n        uint32 maxMintable\n    ) external;\n\n    /*\n     * @dev Sets the `merkleRootHash` for (`edition`, `mintId`).\n     * @param edition        Address of the song edition contract we are minting for.\n     * @param mintId         The mint ID.\n     * @param merkleRootHash The merkle root hash of the entries.\n     */\n    function setMerkleRootHash(\n        address edition,\n        uint128 mintId,\n        bytes32 merkleRootHash\n    ) external;\n\n    // =============================================================\n    //               PUBLIC / EXTERNAL VIEW FUNCTIONS\n    // =============================================================\n\n    /**\n     * @dev Returns IMerkleDropMinter.MintInfo instance containing the full minter parameter set.\n     * @param edition The edition to get the mint instance for.\n     * @param mintId The ID of the mint instance.\n     * @return mintInfo Information about this mint.\n     */\n    function mintInfo(address edition, uint128 mintId) external view returns (MintInfo memory);\n}"

    },

    "contracts/BaseMinter.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.16;\n\nimport { OwnableRoles } from \"./OwnableRoles.sol\";\nimport { ISoundEditionV1 } from \"./ISoundEditionV1.sol\";\nimport { IMinterModule } from \"./IMinterModule.sol\";\nimport { ISoundFeeRegistry } from \"./ISoundFeeRegistry.sol\";\nimport { IERC165 } from \"./IERC165.sol\";\nimport { SafeTransferLib } from \"./SafeTransferLib.sol\";\nimport { FixedPointMathLib } from \"./FixedPointMathLib.sol\";\n\n/**\n * @title Minter Base\n * @dev The `BaseMinter` class maintains a central storage record of edition mint instances.\n */\nabstract contract BaseMinter is IMinterModule {\n    // =============================================================\n    //                           CONSTANTS\n    // =============================================================\n\n    /**\n     * @dev This is the denominator, in basis points (BPS), for:\n     * - platform fees\n     * - affiliate fees\n     */\n    uint16 private constant _MAX_BPS = 10_000;\n\n    // =============================================================\n    //                            STORAGE\n    // =============================================================\n\n    /**\n     * @dev The next mint ID. Shared amongst all editions connected.\n     */\n    uint128 private _nextMintId;\n\n    /**\n     * @dev How much platform fees have been accrued.\n     */\n    uint128 private _platformFeesAccrued;\n\n    /**\n     * @dev Maps an edition and the mint ID to a mint instance.\n     */\n    mapping(address => mapping(uint256 => BaseData)) internal _baseData;\n\n    /**\n     * @dev Maps an address to how much affiliate fees have they accrued.\n     */\n    mapping(address => uint128) private _affiliateFeesAccrued;\n\n    /**\n     * @dev The fee registry. Used for handling platform fees.\n     */\n    ISoundFeeRegistry public immutable feeRegistry;\n\n    // =============================================================\n    //                          CONSTRUCTOR\n    // =============================================================\n\n    constructor(ISoundFeeRegistry feeRegistry_) {\n        if (address(feeRegistry_) == address(0)) revert FeeRegistryIsZeroAddress();\n        feeRegistry = feeRegistry_;\n    }\n\n    // =============================================================\n    //               PUBLIC / EXTERNAL WRITE FUNCTIONS\n    // =============================================================\n\n    /**\n     * @inheritdoc IMinterModule\n     */\n    function setEditionMintPaused(\n        address edition,\n        uint128 mintId,\n        bool paused\n    ) public virtual onlyEditionOwnerOrAdmin(edition) {\n        _baseData[edition][mintId].mintPaused = paused;\n        emit MintPausedSet(edition, mintId, paused);\n    }\n\n    /**\n     * @inheritdoc IMinterModule\n     */\n    function setTimeRange(\n        address edition,\n        uint128 mintId,\n        uint32 startTime,\n        uint32 endTime\n    ) public virtual onlyEditionOwnerOrAdmin(edition) onlyValidTimeRange(startTime, endTime) {\n        _baseData[edition][mintId].startTime = startTime;\n        _baseData[edition][mintId].endTime = endTime;\n\n        emit TimeRangeSet(edition, mintId, startTime, endTime);\n    }\n\n    /**\n     * @inheritdoc IMinterModule\n     */\n    function setAffiliateFee(\n        address edition,\n        uint128 mintId,\n        uint16 feeBPS\n    ) public virtual override onlyEditionOwnerOrAdmin(edition) onlyValidAffiliateFeeBPS(feeBPS) {\n        _baseData[edition][mintId].affiliateFeeBPS = feeBPS;\n        emit AffiliateFeeSet(edition, mintId, feeBPS);\n    }\n\n    /**\n     * @inheritdoc IMinterModule\n     */\n    function withdrawForAffiliate(address affiliate) public override {\n        uint256 accrued = _affiliateFeesAccrued[affiliate];\n        if (accrued != 0) {\n            _affiliateFeesAccrued[affiliate] = 0;\n            SafeTransferLib.safeTransferETH(affiliate, accrued);\n        }\n    }\n\n    /**\n     * @inheritdoc IMinterModule\n     */\n    function withdrawForPlatform() public override {\n        uint256 accrued = _platformFeesAccrued;\n        if (accrued != 0) {\n            _platformFeesAccrued = 0;\n            SafeTransferLib.safeTransferETH(feeRegistry.soundFeeAddress(), accrued);\n        }\n    }\n\n    // =============================================================\n    //               PUBLIC / EXTERNAL VIEW FUNCTIONS\n    // =============================================================\n\n    /**\n     * @dev Getter for the max basis points.\n     */\n    function MAX_BPS() external pure returns (uint16) {\n        return _MAX_BPS;\n    }\n\n    /**\n     * @inheritdoc IMinterModule\n     */\n    function affiliateFeesAccrued(address affiliate) external view returns (uint128) {\n        return _affiliateFeesAccrued[affiliate];\n    }\n\n    /**\n     * @inheritdoc IMinterModule\n     */\n    function platformFeesAccrued() external view returns (uint128) {\n        return _platformFeesAccrued;\n    }\n\n    /**\n     * @inheritdoc IMinterModule\n     */\n    function isAffiliated(\n        address, /* edition */\n        uint128, /* mintId */\n        address affiliate\n    ) public view virtual override returns (bool) {\n        return affiliate != address(0);\n    }\n\n    /**\n     * @inheritdoc IMinterModule\n     */\n    function nextMintId() public view returns (uint128) {\n        return _nextMintId;\n    }\n\n    /**\n     * @inheritdoc IERC165\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IMinterModule).interfaceId || interfaceId == this.supportsInterface.selector;\n    }\n\n    /**\n     * @inheritdoc IMinterModule\n     */\n    function totalPrice(\n        address edition,\n        uint128 mintId,\n        address minter,\n        uint32 quantity\n    ) public view virtual override returns (uint128);\n\n    // =============================================================\n    //                  INTERNAL / PRIVATE HELPERS\n    // =============================================================\n\n    /**\n     * @dev Restricts the function to be only callable by the owner or admin of `edition`.\n     * @param edition The edition address.\n     */\n    modifier onlyEditionOwnerOrAdmin(address edition) virtual {\n        if (\n            msg.sender != OwnableRoles(edition).owner() &&\n            !OwnableRoles(edition).hasAnyRole(msg.sender, ISoundEditionV1(edition).ADMIN_ROLE())\n        ) revert Unauthorized();\n\n        _;\n    }\n\n    /**\n     * @dev Restricts the start time to be less than the end time.\n     * @param startTime The start time of the mint.\n     * @param endTime The end time of the mint.\n     */\n    modifier onlyValidTimeRange(uint32 startTime, uint32 endTime) virtual {\n        if (startTime >= endTime) revert InvalidTimeRange();\n        _;\n    }\n\n    /**\n     * @dev Restricts the affiliate fee numerator to not exceed the `MAX_BPS`.\n     */\n    modifier onlyValidAffiliateFeeBPS(uint16 affiliateFeeBPS) virtual {\n        if (affiliateFeeBPS > _MAX_BPS) revert InvalidAffiliateFeeBPS();\n        _;\n    }\n\n    /**\n     * @dev Creates an edition mint instance.\n     * @param edition The edition address.\n     * @param startTime The start time of the mint.\n     * @param endTime The end time of the mint.\n     * @param affiliateFeeBPS The affiliate fee in basis points.\n     * @return mintId The ID for the mint instance.\n     * Calling conditions:\n     * - Must be owner or admin of the edition.\n     */\n    function _createEditionMint(\n        address edition,\n        uint32 startTime,\n        uint32 endTime,\n        uint16 affiliateFeeBPS\n    )\n        internal\n        onlyEditionOwnerOrAdmin(edition)\n        onlyValidTimeRange(startTime, endTime)\n        onlyValidAffiliateFeeBPS(affiliateFeeBPS)\n        returns (uint128 mintId)\n    {\n        mintId = _nextMintId;\n\n        BaseData storage data = _baseData[edition][mintId];\n        data.startTime = startTime;\n        data.endTime = endTime;\n        data.affiliateFeeBPS = affiliateFeeBPS;\n\n        _nextMintId = mintId + 1;\n\n        emit MintConfigCreated(edition, msg.sender, mintId, startTime, endTime, affiliateFeeBPS);\n    }\n\n    /**\n     * @dev Mints `quantity` of `edition` to `to` with a required payment of `requiredEtherValue`.\n     * Note: this function should be called at the end of a function due to it refunding any\n     * excess ether paid, to adhere to the checks-effects-interactions pattern.\n     * Otherwise, a reentrancy guard must be used.\n     * @param edition The edition address.\n     * @param mintId The ID for the mint instance.\n     * @param quantity The quantity of tokens to mint.\n     * @param affiliate The affiliate (referral) address.\n     */\n    function _mint(\n        address edition,\n        uint128 mintId,\n        uint32 quantity,\n        address affiliate\n    ) internal {\n        BaseData storage baseData = _baseData[edition][mintId];\n\n        /* --------------------- GENERAL CHECKS --------------------- */\n        {\n            uint32 startTime = baseData.startTime;\n            uint32 endTime = baseData.endTime;\n            if (block.timestamp < startTime) revert MintNotOpen(block.timestamp, startTime, endTime);\n            if (block.timestamp > endTime) revert MintNotOpen(block.timestamp, startTime, endTime);\n            if (baseData.mintPaused) revert MintPaused();\n        }\n\n        /* ----------- AFFILIATE AND PLATFORM FEES LOGIC ------------ */\n\n        uint128 requiredEtherValue = totalPrice(edition, mintId, msg.sender, quantity);\n\n        // Reverts if the payment is not exact.\n        if (msg.value < requiredEtherValue) revert Underpaid(msg.value, requiredEtherValue);\n\n        (uint128 remainingPayment, uint128 platformFee) = _deductPlatformFee(requiredEtherValue);\n\n        // Check if the mint is an affiliated mint.\n        bool affiliated = isAffiliated(edition, mintId, affiliate);\n        uint128 affiliateFee;\n        unchecked {\n            if (affiliated) {\n                // Compute the affiliate fee.\n                // Won't overflow, as `remainingPayment` is 128 bits, and `affiliateFeeBPS` is 16 bits.\n                affiliateFee = uint128(\n                    (uint256(remainingPayment) * uint256(baseData.affiliateFeeBPS)) / uint256(_MAX_BPS)\n                );\n                // Deduct the affiliate fee from the remaining payment.\n                // Won't underflow as `affiliateFee <= remainingPayment`.\n                remainingPayment -= affiliateFee;\n                // Increment the affiliate fees accrued.\n                // Overflow is incredibly unrealistic.\n                _affiliateFeesAccrued[affiliate] += affiliateFee;\n            }\n        }\n\n        /* ------------------------- MINT --------------------------- */\n\n        // Emit the event.\n        emit Minted(\n            edition,\n            mintId,\n            msg.sender,\n            // Need to put this call here to avoid stack-too-deep error (it returns fromTokenId)\n            uint32(ISoundEditionV1(edition).mint{ value: remainingPayment }(msg.sender, quantity)),\n            quantity,\n            requiredEtherValue,\n            platformFee,\n            affiliateFee,\n            affiliate,\n            affiliated\n        );\n\n        /* ------------------------- REFUND ------------------------- */\n\n        unchecked {\n            // Note: We do this at the end to avoid creating a reentrancy vector.\n            // Refund the user any ETH they spent over the current total price of the NFTs.\n            if (msg.value > requiredEtherValue) {\n                SafeTransferLib.safeTransferETH(msg.sender, msg.value - requiredEtherValue);\n            }\n        }\n    }\n\n    /**\n     * @dev Deducts the platform fee from `requiredEtherValue`.\n     * @param requiredEtherValue The amount of Ether required.\n     * @return remainingPayment  The remaining payment Ether amount.\n     * @return platformFee       The platform fee.\n     */\n    function _deductPlatformFee(uint128 requiredEtherValue)\n        internal\n        returns (uint128 remainingPayment, uint128 platformFee)\n    {\n        unchecked {\n            // Compute the platform fee.\n            platformFee = feeRegistry.platformFee(requiredEtherValue);\n            // Increment the platform fees accrued.\n            // Overflow is incredibly unrealistic.\n            _platformFeesAccrued += platformFee;\n            // Deduct the platform fee.\n            // Won't underflow as `platformFee <= requiredEtherValue`;\n            remainingPayment = requiredEtherValue - platformFee;\n        }\n    }\n\n    /**\n     * @dev Increments `totalMinted` with `quantity`, reverting if `totalMinted + quantity > maxMintable`.\n     * @param totalMinted The current total number of minted tokens.\n     * @param maxMintable The maximum number of mintable tokens.\n     * @return `totalMinted` + `quantity`.\n     */\n    function _incrementTotalMinted(\n        uint32 totalMinted,\n        uint32 quantity,\n        uint32 maxMintable\n    ) internal pure returns (uint32) {\n        unchecked {\n            // Won't overflow as both are 32 bits.\n            uint256 sum = uint256(totalMinted) + uint256(quantity);\n            if (sum > maxMintable) {\n                // Note that the `maxMintable` may vary and drop over time\n                // and cause `totalMinted` to be greater than `maxMintable`.\n                // The `zeroFloorSub` is equivalent to `max(0, x - y)`.\n                uint32 available = uint32(FixedPointMathLib.zeroFloorSub(maxMintable, totalMinted));\n                revert ExceedsAvailableSupply(available);\n            }\n            return uint32(sum);\n        }\n    }\n}"

    },

    "contracts/ISoundFeeRegistry.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.16;\n\n/**\n * @title ISoundFeeRegistry\n * @author Sound.xyz\n */\ninterface ISoundFeeRegistry {\n    // =============================================================\n    //                            EVENTS\n    // =============================================================\n\n    /**\n     * @dev Emitted when the `soundFeeAddress` is changed.\n     */\n    event SoundFeeAddressSet(address soundFeeAddress);\n\n    /**\n     * @dev Emitted when the `platformFeeBPS` is changed.\n     */\n    event PlatformFeeSet(uint16 platformFeeBPS);\n\n    // =============================================================\n    //                             ERRORS\n    // =============================================================\n\n    /**\n     * @dev The new `soundFeeAddress` must not be address(0).\n     */\n    error InvalidSoundFeeAddress();\n\n    /**\n     * @dev The platform fee numerator must not exceed `_MAX_BPS`.\n     */\n    error InvalidPlatformFeeBPS();\n\n    // =============================================================\n    //               PUBLIC / EXTERNAL WRITE FUNCTIONS\n    // =============================================================\n\n    /**\n     * @dev Sets the `soundFeeAddress`.\n     *\n     * Calling conditions:\n     * - The caller must be the owner of the contract.\n     *\n     * @param soundFeeAddress_ The sound fee address.\n     */\n    function setSoundFeeAddress(address soundFeeAddress_) external;\n\n    /**\n     * @dev Sets the `platformFeePBS`.\n     *\n     * Calling conditions:\n     * - The caller must be the owner of the contract.\n     *\n     * @param platformFeeBPS_ Platform fee amount in bps (basis points).\n     */\n    function setPlatformFeeBPS(uint16 platformFeeBPS_) external;\n\n    // =============================================================\n    //               PUBLIC / EXTERNAL VIEW FUNCTIONS\n    // =============================================================\n\n    /**\n     * @dev The sound protocol's address that receives platform fees.\n     * @return The configured value.\n     */\n    function soundFeeAddress() external view returns (address);\n\n    /**\n     * @dev The numerator of the platform fee.\n     * @return The configured value.\n     */\n    function platformFeeBPS() external view returns (uint16);\n\n    /**\n     * @dev The platform fee for `requiredEtherValue`.\n     * @param requiredEtherValue The required Ether value for payment.\n     * @return fee The computed value.\n     */\n    function platformFee(uint128 requiredEtherValue) external view returns (uint128 fee);\n}"

    },

    "contracts/IERC165.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}"

    },

    "contracts/MerkleProofLib.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Gas optimized verification of proof of inclusion for a leaf in a Merkle tree.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/MerkleProofLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/MerkleProofLib.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/MerkleProof.sol)\nlibrary MerkleProofLib {\n    function verify(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool isValid) {\n        assembly {\n            if proof.length {\n                // Left shift by 5 is equivalent to multiplying by 0x20.\n                let end := add(proof.offset, shl(5, proof.length))\n                // Initialize `offset` to the offset of `proof` in the calldata.\n                let offset := proof.offset\n                // Iterate over proof elements to compute root hash.\n                // prettier-ignore\n                for {} 1 {} {\n                    // Slot of `leaf` in scratch space.\n                    // If the condition is true: 0x20, otherwise: 0x00.\n                    let scratch := shl(5, gt(leaf, calldataload(offset)))\n                    // Store elements to hash contiguously in scratch space.\n                    // Scratch space is 64 bytes (0x00 - 0x3f) and both elements are 32 bytes.\n                    mstore(scratch, leaf)\n                    mstore(xor(scratch, 0x20), calldataload(offset))\n                    // Reuse `leaf` to store the hash to reduce stack operations.\n                    leaf := keccak256(0x00, 0x40)\n                    offset := add(offset, 0x20)\n                    // prettier-ignore\n                    if iszero(lt(offset, end)) { break }\n                }\n            }\n            isValid := eq(leaf, root)\n        }\n    }\n\n    function verifyMultiProof(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32[] calldata leafs,\n        bool[] calldata flags\n    ) internal pure returns (bool isValid) {\n        // Rebuilds the root by consuming and producing values on a queue.\n        // The queue starts with the `leafs` array, and goes into a `hashes` array.\n        // After the process, the last element on the queue is verified\n        // to be equal to the `root`.\n        //\n        // The `flags` array denotes whether the sibling\n        // should be popped from the queue (`flag == true`), or\n        // should be popped from the `proof` (`flag == false`).\n        assembly {\n            // If the number of flags is correct.\n            // prettier-ignore\n            for {} eq(add(leafs.length, proof.length), add(flags.length, 1)) {} {\n\n                // For the case where `proof.length + leafs.length == 1`.\n                if iszero(flags.length) {\n                    // `isValid = (proof.length == 1 ? proof[0] : leafs[0]) == root`.\n                    isValid := eq(\n                        calldataload(\n                            xor(leafs.offset, mul(xor(proof.offset, leafs.offset), proof.length))\n                        ),\n                        root\n                    )\n                    break\n                }\n\n                // We can use the free memory space for the queue.\n                // We don't need to allocate, since the queue is temporary.\n                let hashesFront := mload(0x40)\n                // Copy the leafs into the hashes.\n                // Sometimes, a little memory expansion costs less than branching.\n                // Should cost less, even with a high free memory offset of 0x7d00.\n                // Left shift by 5 is equivalent to multiplying by 0x20.\n                calldatacopy(hashesFront, leafs.offset, shl(5, leafs.length))\n                // Compute the back of the hashes.\n                let hashesBack := add(hashesFront, shl(5, leafs.length))\n                // This is the end of the memory for the queue.\n                let end := add(hashesBack, shl(5, flags.length))\n\n                let flagsOffset := flags.offset\n                let proofOffset := proof.offset\n\n                // prettier-ignore\n                for {} 1 {} {\n                    // Pop from `hashes`.\n                    let a := mload(hashesFront)\n                    // Pop from `hashes`.\n                    let b := mload(add(hashesFront, 0x20))\n                    hashesFront := add(hashesFront, 0x40)\n\n                    // If the flag is false, load the next proof,\n                    // else, pops from the queue.\n                    if iszero(calldataload(flagsOffset)) {\n                        // Loads the next proof.\n                        b := calldataload(proofOffset)\n                        proofOffset := add(proofOffset, 0x20)\n                        // Unpop from `hashes`.\n                        hashesFront := sub(hashesFront, 0x20)\n                    }\n                    \n                    // Advance to the next flag offset.\n                    flagsOffset := add(flagsOffset, 0x20)\n\n                    // Slot of `a` in scratch space.\n                    // If the condition is true: 0x20, otherwise: 0x00.\n                    let scratch := shl(5, gt(a, b))\n                    // Hash the scratch space and push the result onto the queue.\n                    mstore(scratch, a)\n                    mstore(xor(scratch, 0x20), b)\n                    mstore(hashesBack, keccak256(0x00, 0x40))\n                    hashesBack := add(hashesBack, 0x20)\n                    // prettier-ignore\n                    if iszero(lt(hashesBack, end)) { break }\n                }\n                // Checks if the last value in the queue is same as the root.\n                isValid := eq(mload(sub(hashesBack, 0x20)), root)\n                break\n            }\n        }\n    }\n}"

    },

    "contracts/IMetadataModule.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.16;\n\n/**\n * @title IMetadataModule\n * @notice The interface for custom metadata modules.\n */\ninterface IMetadataModule {\n    /**\n     * @dev When implemented, SoundEdition's `tokenURI` redirects execution to this `tokenURI`.\n     * @param tokenId The token ID to retrieve the token URI for.\n     * @return The token URI string.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}"

    },

    "contracts/IERC165Upgradeable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}"

    },

    "contracts/IERC2981Upgradeable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (interfaces/IERC2981.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\n\n/**\n * @dev Interface for the NFT Royalty Standard.\n *\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\n *\n * _Available since v4.5._\n */\ninterface IERC2981Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\n     */\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount);\n}"

    },

    "contracts/IERC721AUpgradeable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// ERC721A Contracts v4.2.2\n// Creator: Chiru Labs\n\npragma solidity ^0.8.4;\n\n/**\n * @dev Interface of ERC721A.\n */\ninterface IERC721AUpgradeable {\n    /**\n     * The caller must own the token or be an approved operator.\n     */\n    error ApprovalCallerNotOwnerNorApproved();\n\n    /**\n     * The token does not exist.\n     */\n    error ApprovalQueryForNonexistentToken();\n\n    /**\n     * Cannot query the balance for the zero address.\n     */\n    error BalanceQueryForZeroAddress();\n\n    /**\n     * Cannot mint to the zero address.\n     */\n    error MintToZeroAddress();\n\n    /**\n     * The quantity of tokens minted must be more than zero.\n     */\n    error MintZeroQuantity();\n\n    /**\n     * The token does not exist.\n     */\n    error OwnerQueryForNonexistentToken();\n\n    /**\n     * The caller must own the token or be an approved operator.\n     */\n    error TransferCallerNotOwnerNorApproved();\n\n    /**\n     * The token must be owned by `from`.\n     */\n    error TransferFromIncorrectOwner();\n\n    /**\n     * Cannot safely transfer to a contract that does not implement the\n     * ERC721Receiver interface.\n     */\n    error TransferToNonERC721ReceiverImplementer();\n\n    /**\n     * Cannot transfer to the zero address.\n     */\n    error TransferToZeroAddress();\n\n    /**\n     * The token does not exist.\n     */\n    error URIQueryForNonexistentToken();\n\n    /**\n     * The `quantity` minted with ERC2309 exceeds the safety limit.\n     */\n    error MintERC2309QuantityExceedsLimit();\n\n    /**\n     * The `extraData` cannot be set on an unintialized ownership slot.\n     */\n    error OwnershipNotInitializedForExtraData();\n\n    // =============================================================\n    //                            STRUCTS\n    // =============================================================\n\n    struct TokenOwnership {\n        // The address of the owner.\n        address addr;\n        // Stores the start time of ownership with minimal overhead for tokenomics.\n        uint64 startTimestamp;\n        // Whether the token has been burned.\n        bool burned;\n        // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\n        uint24 extraData;\n    }\n\n    // =============================================================\n    //                         TOKEN COUNTERS\n    // =============================================================\n\n    /**\n     * @dev Returns the total number of tokens in existence.\n     * Burned tokens will reduce the count.\n     * To get the total number of tokens minted, please see {_totalMinted}.\n     */\n    function totalSupply() external view returns (uint256);\n\n    // =============================================================\n    //                            IERC165\n    // =============================================================\n\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n    // =============================================================\n    //                            IERC721\n    // =============================================================\n\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables\n     * (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in `owner`'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`,\n     * checking first that contract recipients are aware of the ERC721 protocol\n     * to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move\n     * this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\n     * whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token\n     * by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the\n     * zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom}\n     * for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    // =============================================================\n    //                        IERC721Metadata\n    // =============================================================\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n\n    // =============================================================\n    //                           IERC2309\n    // =============================================================\n\n    /**\n     * @dev Emitted when tokens in `fromTokenId` to `toTokenId`\n     * (inclusive) is transferred from `from` to `to`, as defined in the\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.\n     *\n     * See {_mintERC2309} for more details.\n     */\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\n}"

    },

    "contracts/FixedPointMathLib.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\nlibrary FixedPointMathLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\n    error ExpOverflow();\n\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\n    error FactorialOverflow();\n\n    /// @dev The operation failed, due to an multiplication overflow.\n    error MulWadFailed();\n\n    /// @dev The operation failed, either due to a\n    /// multiplication overflow, or a division by a zero.\n    error DivWadFailed();\n\n    /// @dev The multiply-divide operation failed, either due to a\n    /// multiplication overflow, or a division by a zero.\n    error MulDivFailed();\n\n    /// @dev The division failed, as the denominator is zero.\n    error DivFailed();\n\n    /// @dev The output is undefined, as the input is less-than-or-equal to zero.\n    error LnWadUndefined();\n\n    /// @dev The output is undefined, as the input is zero.\n    error Log2Undefined();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The scalar of ETH and most ERC20s.\n    uint256 internal constant WAD = 1e18;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*              SIMPLIFIED FIXED POINT OPERATIONS             */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assembly {\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if mul(y, gt(x, div(not(0), y))) {\n                // Store the function selector of `MulWadFailed()`.\n                mstore(0x00, 0xbac65e5b)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            z := div(mul(x, y), WAD)\n        }\n    }\n\n    /// @dev Equivalent to `(x * y) / WAD` rounded up.\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assembly {\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if mul(y, gt(x, div(not(0), y))) {\n                // Store the function selector of `MulWadFailed()`.\n                mstore(0x00, 0xbac65e5b)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assembly {\n            // Equivalent to `require(y != 0 && (WAD == 0 || x <= type(uint256).max / WAD))`.\n            if iszero(mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD)))))) {\n                // Store the function selector of `DivWadFailed()`.\n                mstore(0x00, 0x7c5f487d)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            z := div(mul(x, WAD), y)\n        }\n    }\n\n    /// @dev Equivalent to `(x * WAD) / y` rounded up.\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assembly {\n            // Equivalent to `require(y != 0 && (WAD == 0 || x <= type(uint256).max / WAD))`.\n            if iszero(mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD)))))) {\n                // Store the function selector of `DivWadFailed()`.\n                mstore(0x00, 0x7c5f487d)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\n        }\n    }\n\n    /// @dev Equivalent to `x` to the power of `y`.\n    /// because `x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)`.\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\n        // Using `ln(x)` means `x` must be greater than 0.\n        return expWad((lnWad(x) * y) / int256(WAD));\n    }\n\n    /// @dev Returns `exp(x)`, denominated in `WAD`.\n    function expWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            // When the result is < 0.5 we return zero. This happens when\n            // x <= floor(log(0.5e18) * 1e18) ~ -42e18\n            if (x <= -42139678854452767551) return 0;\n\n            // When the result is > (2**255 - 1) / 1e18 we can not represent it as an\n            // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.\n            if (x >= 135305999368893231589) revert ExpOverflow();\n\n            // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\n            // for more intermediate precision and a binary basis. This base conversion\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\n            x = (x << 78) / 5**18;\n\n            // Reduce range of x to (-½ ln 2, ½ ln 2) * 2**96 by factoring out powers\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2**95) >> 96;\n            x = x - k * 54916777467707473351141471128;\n\n            // k is in the range [-61, 195].\n\n            // Evaluate using a (6, 7)-term rational approximation.\n            // p is made monic, we'll multiply by a scale factor later.\n            int256 y = x + 1346386616545796478920950773328;\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\n            int256 p = y + x - 94201549194550492254356042504812;\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\n            p = p * x + (4385272521454847904659076985693276 << 96);\n\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\n            int256 q = x - 2855989394907223263936484059900;\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\n\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\n                // No scaling is necessary because p is already 2**96 too large.\n                r := sdiv(p, q)\n            }\n\n            // r should be in the range (0.09, 0.25) * 2**96.\n\n            // We now need to multiply r by:\n            // * the scale factor s = ~6.031367120.\n            // * the 2**k factor from the range reduction.\n            // * the 1e18 / 2**96 factor for base conversion.\n            // We do this all at once, with an intermediate result in 2**213\n            // basis, so the final right shift is always by a positive amount.\n            r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));\n        }\n    }\n\n    /// @dev Returns `ln(x)`, denominated in `WAD`.\n    function lnWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            if (x <= 0) revert LnWadUndefined();\n\n            // We want to convert x from 10**18 fixed point to 2**96 fixed point.\n            // We do this by multiplying by 2**96 / 10**18. But since\n            // ln(x * C) = ln(x) + ln(C), we can simply do nothing here\n            // and add ln(2**96 / 10**18) at the end.\n\n            // Compute k = log2(x) - 96.\n            int256 k;\n            assembly {\n                let v := x\n                k := shl(7, lt(0xffffffffffffffffffffffffffffffff, v))\n                k := or(k, shl(6, lt(0xffffffffffffffff, shr(k, v))))\n                k := or(k, shl(5, lt(0xffffffff, shr(k, v))))\n\n                // For the remaining 32 bits, use a De Bruijn lookup.\n                // See: https://graphics.stanford.edu/~seander/bithacks.html\n                v := shr(k, v)\n                v := or(v, shr(1, v))\n                v := or(v, shr(2, v))\n                v := or(v, shr(4, v))\n                v := or(v, shr(8, v))\n                v := or(v, shr(16, v))\n\n                // prettier-ignore\n                k := sub(or(k, byte(shr(251, mul(v, shl(224, 0x07c4acdd))),\n                    0x0009010a0d15021d0b0e10121619031e080c141c0f111807131b17061a05041f)), 96)\n            }\n\n            // Reduce range of x to (1, 2) * 2**96\n            // ln(2^k * x) = k * ln(2) + ln(x)\n            x <<= uint256(159 - k);\n            x = int256(uint256(x) >> 159);\n\n            // Evaluate using a (8, 8)-term rational approximation.\n            // p is made monic, we will multiply by a scale factor later.\n            int256 p = x + 3273285459638523848632254066296;\n            p = ((p * x) >> 96) + 24828157081833163892658089445524;\n            p = ((p * x) >> 96) + 43456485725739037958740375743393;\n            p = ((p * x) >> 96) - 11111509109440967052023855526967;\n            p = ((p * x) >> 96) - 45023709667254063763336534515857;\n            p = ((p * x) >> 96) - 14706773417378608786704636184526;\n            p = p * x - (795164235651350426258249787498 << 96);\n\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\n            // q is monic by convention.\n            int256 q = x + 5573035233440673466300451813936;\n            q = ((q * x) >> 96) + 71694874799317883764090561454958;\n            q = ((q * x) >> 96) + 283447036172924575727196451306956;\n            q = ((q * x) >> 96) + 401686690394027663651624208769553;\n            q = ((q * x) >> 96) + 204048457590392012362485061816622;\n            q = ((q * x) >> 96) + 31853899698501571402653359427138;\n            q = ((q * x) >> 96) + 909429971244387300277376558375;\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial is known not to have zeros in the domain.\n                // No scaling required because p is already 2**96 too large.\n                r := sdiv(p, q)\n            }\n\n            // r is in the range (0, 0.125) * 2**96\n\n            // Finalization, we need to:\n            // * multiply by the scale factor s = 5.549…\n            // * add ln(2**96 / 10**18)\n            // * add k * ln(2)\n            // * multiply by 10**18 / 2**96 = 5**18 >> 78\n\n            // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\n            r *= 1677202110996718588342820967067443963516166;\n            // add ln(2) * k * 5e18 * 2**192\n            r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\n            // add ln(2**96 / 10**18) * 5e18 * 2**192\n            r += 600920179829731861736702779321621459595472258049074101567377883020018308;\n            // base conversion: mul 2**18 / 2**192\n            r >>= 174;\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  GENERAL NUMBER UTILITIES                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns `floor(x * y / denominator)`.\n    /// Reverts if `x * y` overflows, or `denominator` is zero.\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(not(0), y)))))) {\n                // Store the function selector of `MulDivFailed()`.\n                mstore(0x00, 0xad251c27)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            z := div(mul(x, y), denominator)\n        }\n    }\n\n    /// @dev Returns `ceil(x * y / denominator)`.\n    /// Reverts if `x * y` overflows, or `denominator` is zero.\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(not(0), y)))))) {\n                // Store the function selector of `MulDivFailed()`.\n                mstore(0x00, 0xad251c27)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(mul(x, y), denominator))), div(mul(x, y), denominator))\n        }\n    }\n\n    /// @dev Returns `ceil(x / denominator)`.\n    /// Reverts if `denominator` is zero.\n    function divUp(uint256 x, uint256 denominator) internal pure returns (uint256 z) {\n        assembly {\n            if iszero(denominator) {\n                // Store the function selector of `DivFailed()`.\n                mstore(0x00, 0x65244e4e)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(x, denominator))), div(x, denominator))\n        }\n    }\n\n    /// @dev Returns `max(0, x - y)`.\n    function zeroFloorSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assembly {\n            z := mul(gt(x, y), sub(x, y))\n        }\n    }\n\n    /// @dev Returns the square root of `x`.\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        assembly {\n            // `floor(sqrt(2**15)) = 181`. `sqrt(2**15) - 181 = 2.84`.\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // Let `y = x / 2**r`.\n            // We check `y >= 2**(k + 8)` but shift right by `k` bits\n            // each branch to ensure that if `x >= 256`, then `y >= 256`.\n            let r := shl(7, gt(x, 0xffffffffffffffffffffffffffffffffff))\n            r := or(r, shl(6, gt(shr(r, x), 0xffffffffffffffffff)))\n            r := or(r, shl(5, gt(shr(r, x), 0xffffffffff)))\n            r := or(r, shl(4, gt(shr(r, x), 0xffffff)))\n            z := shl(shr(1, r), z)\n\n            // Goal was to get `z*z*y` within a small factor of `x`. More iterations could\n            // get y in a tighter range. Currently, we will have y in `[256, 256*(2**16))`.\n            // We ensured `y >= 256` so that the relative difference between `y` and `y+1` is small.\n            // That's not possible if `x < 256` but we can just verify those cases exhaustively.\n\n            // Now, `z*z*y <= x < z*z*(y+1)`, and `y <= 2**(16+8)`, and either `y >= 256`, or `x < 256`.\n            // Correctness can be checked exhaustively for `x < 256`, so we assume `y >= 256`.\n            // Then `z*sqrt(y)` is within `sqrt(257)/sqrt(256)` of `sqrt(x)`, or about 20bps.\n\n            // For `s` in the range `[1/256, 256]`, the estimate `f(s) = (181/1024) * (s+1)`\n            // is in the range `(1/2.84 * sqrt(s), 2.84 * sqrt(s))`,\n            // with largest error when `s = 1` and when `s = 256` or `1/256`.\n\n            // Since `y` is in `[256, 256*(2**16))`, let `a = y/65536`, so that `a` is in `[1/256, 256)`.\n            // Then we can estimate `sqrt(y)` using\n            // `sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2**18`.\n\n            // There is no overflow risk here since `y < 2**136` after the first branch above.\n            z := shr(18, mul(z, add(shr(r, x), 65536))) // A `mul()` is saved from starting `z` at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If `x+1` is a perfect square, the Babylonian method cycles between\n            // `floor(sqrt(x))` and `ceil(sqrt(x))`. This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    /// @dev Returns the factorial of `x`.\n    function factorial(uint256 x) public pure returns (uint256 result) {\n        unchecked {\n            if (x < 11) {\n                // prettier-ignore\n                result = (0x375f0016260009d80004ec0002d00001e0000180000180000200000400001 >> (x * 22)) & 0x3fffff;\n            } else if (x < 32) {\n                result = 3628800;\n                do {\n                    result = result * x;\n                    x = x - 1;\n                } while (x != 10);\n            } else if (x < 58) {\n                // Just cheat lol.\n                result = 8222838654177922817725562880000000;\n                do {\n                    result = result * x;\n                    x = x - 1;\n                } while (x != 31);\n            } else {\n                revert FactorialOverflow();\n            }\n        }\n    }\n\n    /// @dev Returns the log2 of `x`.\n    /// Equivalent to computing the index of the most significant bit (MSB) of `x`.\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        assembly {\n            if iszero(x) {\n                // Store the function selector of `Log2Undefined()`.\n                mstore(0x00, 0x5be3aa5c)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n\n            // For the remaining 32 bits, use a De Bruijn lookup.\n            // See: https://graphics.stanford.edu/~seander/bithacks.html\n            x := shr(r, x)\n            x := or(x, shr(1, x))\n            x := or(x, shr(2, x))\n            x := or(x, shr(4, x))\n            x := or(x, shr(8, x))\n            x := or(x, shr(16, x))\n\n            // prettier-ignore\n            r := or(r, byte(shr(251, mul(x, shl(224, 0x07c4acdd))),\n                0x0009010a0d15021d0b0e10121619031e080c141c0f111807131b17061a05041f))\n        }\n    }\n\n    /// @dev Returns the averege of `x` and `y`.\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assembly {\n            z := add(and(x, y), shr(1, xor(x, y)))\n        }\n    }\n\n    /// @dev Returns the absolute value of `x`.\n    function abs(int256 x) internal pure returns (uint256 z) {\n        assembly {\n            let mask := mul(shr(255, x), not(0))\n            z := xor(mask, add(mask, x))\n        }\n    }\n\n    /// @dev Returns the absolute distance between `x` and `y`.\n    function dist(int256 x, int256 y) internal pure returns (uint256 z) {\n        assembly {\n            let a := sub(y, x)\n            z := xor(a, mul(xor(a, sub(x, y)), sgt(x, y)))\n        }\n    }\n\n    /// @dev Returns the minimum of `x` and `y`.\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assembly {\n            z := xor(x, mul(xor(x, y), lt(y, x)))\n        }\n    }\n\n    /// @dev Returns the maximum of `x` and `y`.\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assembly {\n            z := xor(x, mul(xor(x, y), gt(y, x)))\n        }\n    }\n\n    /// @dev Returns gcd of `x` and `y`.\n    function gcd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assembly {\n            // prettier-ignore\n            for { z := x } y {} {\n                let t := y\n                y := mod(z, y)\n                z := t\n            }\n        }\n    }\n\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\n    function clamp(\n        uint256 x,\n        uint256 minValue,\n        uint256 maxValue\n    ) internal pure returns (uint256 z) {\n        return min(max(x, minValue), maxValue);\n    }\n}"

    },

    "contracts/SafeTransferLib.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Caution! This library won't check that a token has code, responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    error ETHTransferFailed();\n\n    error TransferFromFailed();\n\n    error TransferFailed();\n\n    error ApproveFailed();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       ETH OPERATIONS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        assembly {\n            // Transfer the ETH and check if it succeeded or not.\n            if iszero(call(gas(), to, amount, 0, 0, 0, 0)) {\n                // Store the function selector of `ETHTransferFailed()`.\n                mstore(0x00, 0xb12d13eb)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      ERC20 OPERATIONS                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        assembly {\n            // We'll write our calldata to this slot below, but restore it later.\n            let memPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(0x00, 0x23b872dd)\n            mstore(0x20, from) // Append the \"from\" argument.\n            mstore(0x40, to) // Append the \"to\" argument.\n            mstore(0x60, amount) // Append the \"amount\" argument.\n\n            if iszero(\n                and(\n                    // Set success to whether the call reverted, if not we check it either\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\n                    // We use 0x64 because that's the total length of our calldata (0x04 + 0x20 * 3)\n                    // Counterintuitively, this call() must be positioned after the or() in the\n                    // surrounding and() because and() evaluates its arguments from right to left.\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n                )\n            ) {\n                // Store the function selector of `TransferFromFailed()`.\n                mstore(0x00, 0x7939f424)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, memPointer) // Restore the memPointer.\n        }\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 amount\n    ) internal {\n        assembly {\n            // We'll write our calldata to this slot below, but restore it later.\n            let memPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(0x00, 0xa9059cbb)\n            mstore(0x20, to) // Append the \"to\" argument.\n            mstore(0x40, amount) // Append the \"amount\" argument.\n\n            if iszero(\n                and(\n                    // Set success to whether the call reverted, if not we check it either\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\n                    // We use 0x44 because that's the total length of our calldata (0x04 + 0x20 * 2)\n                    // Counterintuitively, this call() must be positioned after the or() in the\n                    // surrounding and() because and() evaluates its arguments from right to left.\n                    call(gas(), token, 0, 0x1c, 0x44, 0x00, 0x20)\n                )\n            ) {\n                // Store the function selector of `TransferFailed()`.\n                mstore(0x00, 0x90b8ec18)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            mstore(0x40, memPointer) // Restore the memPointer.\n        }\n    }\n\n    function safeApprove(\n        address token,\n        address to,\n        uint256 amount\n    ) internal {\n        assembly {\n            // We'll write our calldata to this slot below, but restore it later.\n            let memPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(0x00, 0x095ea7b3)\n            mstore(0x20, to) // Append the \"to\" argument.\n            mstore(0x40, amount) // Append the \"amount\" argument.\n\n            if iszero(\n                and(\n                    // Set success to whether the call reverted, if not we check it either\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\n                    // We use 0x44 because that's the total length of our calldata (0x04 + 0x20 * 2)\n                    // Counterintuitively, this call() must be positioned after the or() in the\n                    // surrounding and() because and() evaluates its arguments from right to left.\n                    call(gas(), token, 0, 0x1c, 0x44, 0x00, 0x20)\n                )\n            ) {\n                // Store the function selector of `ApproveFailed()`.\n                mstore(0x00, 0x3e3f8f73)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            mstore(0x40, memPointer) // Restore the memPointer.\n        }\n    }\n}"

    },

    "contracts/OwnableRoles.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Simple single owner and multiroles authorization mixin.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/OwnableRoles.sol)\n/// @dev While the ownable portion follows [EIP-173](https://eips.ethereum.org/EIPS/eip-173)\n/// for compatibility, the nomenclature for the 2-step ownership handover and roles\n/// may be unique to this codebase.\nabstract contract OwnableRoles {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The caller is not authorized to call the function.\n    error Unauthorized();\n\n    /// @dev The `newOwner` cannot be the zero address.\n    error NewOwnerIsZeroAddress();\n\n    /// @dev The `pendingOwner` does not have a valid handover request.\n    error NoHandoverRequest();\n\n    /// @dev `bytes4(keccak256(bytes(\"Unauthorized()\")))`.\n    uint256 private constant _UNAUTHORIZED_ERROR_SELECTOR = 0x82b42900;\n\n    /// @dev `bytes4(keccak256(bytes(\"NewOwnerIsZeroAddress()\")))`.\n    uint256 private constant _NEW_OWNER_IS_ZERO_ADDRESS_ERROR_SELECTOR = 0x7448fbae;\n\n    /// @dev `bytes4(keccak256(bytes(\"NoHandoverRequest()\")))`.\n    uint256 private constant _NO_HANDOVER_REQUEST_ERROR_SELECTOR = 0x6f5e8818;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           EVENTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\n    /// despite it not being as lightweight as a single argument event.\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\n\n    /// @dev An ownership handover to `pendingOwner` has been requested.\n    event OwnershipHandoverRequested(address indexed pendingOwner);\n\n    /// @dev The ownership handover to `pendingOwner` has been cancelled.\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\n\n    /// @dev The `user`'s roles is updated to `roles`.\n    /// Each bit of `roles` represents whether the role is set.\n    event RolesUpdated(address indexed user, uint256 indexed roles);\n\n    /// @dev `keccak256(bytes(\"OwnershipTransferred(address,address)\"))`.\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverRequested(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverCanceled(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\n\n    /// @dev `keccak256(bytes(\"RolesUpdated(address,uint256)\"))`.\n    uint256 private constant _ROLES_UPDATED_EVENT_SIGNATURE =\n        0x715ad5ce61fc9595c7b415289d59cf203f23a94fa06f04af7e489a0a76e1fe26;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STORAGE                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The owner slot is given by: `not(_OWNER_SLOT_NOT)`.\n    /// It is intentionally choosen to be a high value\n    /// to avoid collision with lower slots.\n    /// The choice of manual storage layout is to enable compatibility\n    /// with both regular and upgradeable contracts.\n    ///\n    /// The role slot of `user` is given by:\n    /// ```\n    ///     mstore(0x00, or(shl(96, user), _OWNER_SLOT_NOT))\n    ///     let roleSlot := keccak256(0x00, 0x20)\n    /// ```\n    /// This automatically ignores the upper bits of the `user` in case\n    /// they are not clean, as well as keep the `keccak256` under 32-bytes.\n    uint256 private constant _OWNER_SLOT_NOT = 0x8b78c6d8;\n\n    /// The ownership handover slot of `newOwner` is given by:\n    /// ```\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\n    ///     let handoverSlot := keccak256(0x00, 0x20)\n    /// ```\n    /// It stores the expiry timestamp of the two-step ownership handover.\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     INTERNAL FUNCTIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Initializes the owner directly without authorization guard.\n    /// This function must be called upon initialization,\n    /// regardless of whether the contract is upgradeable or not.\n    /// This is to enable generalization to both regular and upgradeable contracts,\n    /// and to save gas in case the initial owner is not the caller.\n    /// For performance reasons, this function will not check if there\n    /// is an existing owner.\n    function _initializeOwner(address newOwner) internal virtual {\n        assembly {\n            // Clean the upper 96 bits.\n            newOwner := shr(96, shl(96, newOwner))\n            // Store the new value.\n            sstore(not(_OWNER_SLOT_NOT), newOwner)\n            // Emit the {OwnershipTransferred} event.\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\n        }\n    }\n\n    /// @dev Sets the owner directly without authorization guard.\n    function _setOwner(address newOwner) internal virtual {\n        assembly {\n            let ownerSlot := not(_OWNER_SLOT_NOT)\n            // Clean the upper 96 bits.\n            newOwner := shr(96, shl(96, newOwner))\n            // Emit the {OwnershipTransferred} event.\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\n            // Store the new value.\n            sstore(ownerSlot, newOwner)\n        }\n    }\n\n    /// @dev Grants the roles directly without authorization guard.\n    /// Each bit of `roles` represents the role to turn on.\n    function _grantRoles(address user, uint256 roles) internal virtual {\n        assembly {\n            // Compute the role slot.\n            mstore(0x00, or(shl(96, user), _OWNER_SLOT_NOT))\n            let roleSlot := keccak256(0x00, 0x20)\n            // Load the current value and `or` it with `roles`.\n            let newRoles := or(sload(roleSlot), roles)\n            // Store the new value.\n            sstore(roleSlot, newRoles)\n            // Emit the {RolesUpdated} event.\n            log3(0, 0, _ROLES_UPDATED_EVENT_SIGNATURE, shr(96, shl(96, user)), newRoles)\n        }\n    }\n\n    /// @dev Removes the roles directly without authorization guard.\n    /// Each bit of `roles` represents the role to turn off.\n    function _removeRoles(address user, uint256 roles) internal virtual {\n        assembly {\n            // Compute the role slot.\n            mstore(0x00, or(shl(96, user), _OWNER_SLOT_NOT))\n            let roleSlot := keccak256(0x00, 0x20)\n            // Load the current value.\n            let currentRoles := sload(roleSlot)\n            // Use `and` to compute the intersection of `currentRoles` and `roles`,\n            // `xor` it with `currentRoles` to flip the bits in the intersection.\n            let newRoles := xor(currentRoles, and(currentRoles, roles))\n            // Then, store the new value.\n            sstore(roleSlot, newRoles)\n            // Emit the {RolesUpdated} event.\n            log3(0, 0, _ROLES_UPDATED_EVENT_SIGNATURE, shr(96, shl(96, user)), newRoles)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        assembly {\n            // Clean the upper 96 bits.\n            newOwner := shr(96, shl(96, newOwner))\n            // Reverts if the `newOwner` is the zero address.\n            if iszero(newOwner) {\n                mstore(0x00, _NEW_OWNER_IS_ZERO_ADDRESS_ERROR_SELECTOR)\n                revert(0x1c, 0x04)\n            }\n            // Emit the {OwnershipTransferred} event.\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, caller(), newOwner)\n            // Store the new value.\n            sstore(not(_OWNER_SLOT_NOT), newOwner)\n        }\n    }\n\n    /// @dev Allows the owner to renounce their ownership.\n    function renounceOwnership() public virtual onlyOwner {\n        assembly {\n            // Emit the {OwnershipTransferred} event.\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, caller(), 0)\n            // Store the new value.\n            sstore(not(_OWNER_SLOT_NOT), 0)\n        }\n    }\n\n    /// @dev Request a two-step ownership handover to the caller.\n    /// The request will be automatically expire in 48 hours (172800 seconds) by default.\n    function requestOwnershipHandover() public virtual {\n        unchecked {\n            uint256 expires = block.timestamp + ownershipHandoverValidFor();\n            assembly {\n                // Compute and set the handover slot to 1.\n                mstore(0x00, or(shl(96, caller()), _HANDOVER_SLOT_SEED))\n                sstore(keccak256(0x00, 0x20), expires)\n                // Emit the {OwnershipHandoverRequested} event.\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\n            }\n        }\n    }\n\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\n    function cancelOwnershipHandover() public virtual {\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x00, or(shl(96, caller()), _HANDOVER_SLOT_SEED))\n            sstore(keccak256(0x00, 0x20), 0)\n            // Emit the {OwnershipHandoverCanceled} event.\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\n        }\n    }\n\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\n    function completeOwnershipHandover(address pendingOwner) public virtual onlyOwner {\n        assembly {\n            // Clean the upper 96 bits.\n            pendingOwner := shr(96, shl(96, pendingOwner))\n            // Compute and set the handover slot to 0.\n            mstore(0x00, or(shl(96, pendingOwner), _HANDOVER_SLOT_SEED))\n            let handoverSlot := keccak256(0x00, 0x20)\n            // If the handover does not exist, or has expired.\n            if gt(timestamp(), sload(handoverSlot)) {\n                mstore(0x00, _NO_HANDOVER_REQUEST_ERROR_SELECTOR)\n                revert(0x1c, 0x04)\n            }\n            // Set the handover slot to 0.\n            sstore(handoverSlot, 0)\n            // Emit the {OwnershipTransferred} event.\n            log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, caller(), pendingOwner)\n            // Store the new value.\n            sstore(not(_OWNER_SLOT_NOT), pendingOwner)\n        }\n    }\n\n    /// @dev Allows the owner to grant `user` `roles`.\n    /// If the `user` already has a role, then it will be an no-op for the role.\n    function grantRoles(address user, uint256 roles) public virtual onlyOwner {\n        _grantRoles(user, roles);\n    }\n\n    /// @dev Allows the owner to remove `user` `roles`.\n    /// If the `user` does not have a role, then it will be an no-op for the role.\n    function revokeRoles(address user, uint256 roles) public virtual onlyOwner {\n        _removeRoles(user, roles);\n    }\n\n    /// @dev Allow the caller to remove their own roles.\n    /// If the caller does not have a role, then it will be an no-op for the role.\n    function renounceRoles(uint256 roles) public virtual {\n        _removeRoles(msg.sender, roles);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   PUBLIC READ FUNCTIONS                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the owner of the contract.\n    function owner() public view virtual returns (address result) {\n        assembly {\n            result := sload(not(_OWNER_SLOT_NOT))\n        }\n    }\n\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\n    function ownershipHandoverExpiresAt(address pendingOwner) public view virtual returns (uint256 result) {\n        assembly {\n            // Compute the handover slot.\n            mstore(0x00, or(shl(96, pendingOwner), _HANDOVER_SLOT_SEED))\n            // Load the handover slot.\n            result := sload(keccak256(0x00, 0x20))\n        }\n    }\n\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\n    function ownershipHandoverValidFor() public view virtual returns (uint64) {\n        return 48 * 3600;\n    }\n\n    /// @dev Returns whether `user` has any of `roles`.\n    function hasAnyRole(address user, uint256 roles) public view virtual returns (bool result) {\n        assembly {\n            // Compute the role slot.\n            mstore(0x00, or(shl(96, user), _OWNER_SLOT_NOT))\n            // Load the stored value, and set the result to whether the\n            // `and` intersection of the value and `roles` is not zero.\n            result := iszero(iszero(and(sload(keccak256(0x00, 0x20)), roles)))\n        }\n    }\n\n    /// @dev Returns whether `user` has all of `roles`.\n    function hasAllRoles(address user, uint256 roles) public view virtual returns (bool result) {\n        assembly {\n            // Compute the role slot.\n            mstore(0x00, or(shl(96, user), _OWNER_SLOT_NOT))\n            // Whether the stored value is contains all the set bits in `roles`.\n            result := eq(and(sload(keccak256(0x00, 0x20)), roles), roles)\n        }\n    }\n\n    /// @dev Returns the roles of `user`.\n    function rolesOf(address user) public view virtual returns (uint256 roles) {\n        assembly {\n            // Compute the role slot.\n            mstore(0x00, or(shl(96, user), _OWNER_SLOT_NOT))\n            // Load the stored value.\n            roles := sload(keccak256(0x00, 0x20))\n        }\n    }\n\n    /// @dev Convenience function to return a `roles` bitmap from the `ordinals`.\n    /// This is meant for frontends like Etherscan, and is therefore not fully optimized.\n    /// Not recommended to be called on-chain.\n    function rolesFromOrdinals(uint8[] memory ordinals) public pure returns (uint256 roles) {\n        assembly {\n            // Skip the length slot.\n            let o := add(ordinals, 0x20)\n            // `shl` 5 is equivalent to multiplying by 0x20.\n            let end := add(o, shl(5, mload(ordinals)))\n            // prettier-ignore\n            for {} iszero(eq(o, end)) { o := add(o, 0x20) } {\n                roles := or(roles, shl(and(mload(o), 0xff), 1))\n            }\n        }\n    }\n\n    /// @dev Convenience function to return a `roles` bitmap from the `ordinals`.\n    /// This is meant for frontends like Etherscan, and is therefore not fully optimized.\n    /// Not recommended to be called on-chain.\n    function ordinalsFromRoles(uint256 roles) public pure returns (uint8[] memory ordinals) {\n        assembly {\n            // Grab the pointer to the free memory.\n            let ptr := add(mload(0x40), 0x20)\n            // The absence of lookup tables, De Bruijn, etc., here is intentional for\n            // smaller bytecode, as this function is not meant to be called on-chain.\n            // prettier-ignore\n            for { let i := 0 } 1 { i := add(i, 1) } {\n                mstore(ptr, i)\n                // `shr` 5 is equivalent to multiplying by 0x20.\n                // Push back into the ordinals array if the bit is set.\n                ptr := add(ptr, shl(5, and(roles, 1)))\n                roles := shr(1, roles)\n                // prettier-ignore\n                if iszero(roles) { break }\n            }\n            // Set `ordinals` to the start of the free memory.\n            ordinals := mload(0x40)\n            // Allocate the memory.\n            mstore(0x40, ptr)\n            // Store the length of `ordinals`.\n            mstore(ordinals, shr(5, sub(ptr, add(ordinals, 0x20))))\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         MODIFIERS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Marks a function as only callable by the owner.\n    modifier onlyOwner() virtual {\n        assembly {\n            // If the caller is not the stored owner, revert.\n            if iszero(eq(caller(), sload(not(_OWNER_SLOT_NOT)))) {\n                mstore(0x00, _UNAUTHORIZED_ERROR_SELECTOR)\n                revert(0x1c, 0x04)\n            }\n        }\n        _;\n    }\n\n    /// @dev Marks a function as only callable by an account with `roles`.\n    modifier onlyRoles(uint256 roles) virtual {\n        assembly {\n            // Compute the role slot.\n            mstore(0x00, or(shl(96, caller()), _OWNER_SLOT_NOT))\n            // Load the stored value, and if the `and` intersection\n            // of the value and `roles` is zero, revert.\n            if iszero(and(sload(keccak256(0x00, 0x20)), roles)) {\n                mstore(0x00, _UNAUTHORIZED_ERROR_SELECTOR)\n                revert(0x1c, 0x04)\n            }\n        }\n        _;\n    }\n\n    /// @dev Marks a function as only callable by the owner or by an account\n    /// with `roles`. Checks for ownership first, then lazily checks for roles.\n    modifier onlyOwnerOrRoles(uint256 roles) virtual {\n        assembly {\n            // If the caller is not the stored owner.\n            if iszero(eq(caller(), sload(not(_OWNER_SLOT_NOT)))) {\n                // Compute the role slot.\n                mstore(0x00, or(shl(96, caller()), _OWNER_SLOT_NOT))\n                // Load the stored value, and if the `and` intersection\n                // of the value and `roles` is zero, revert.\n                if iszero(and(sload(keccak256(0x00, 0x20)), roles)) {\n                    mstore(0x00, _UNAUTHORIZED_ERROR_SELECTOR)\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n        _;\n    }\n\n    /// @dev Marks a function as only callable by an account with `roles`\n    /// or the owner. Checks for roles first, then lazily checks for ownership.\n    modifier onlyRolesOrOwner(uint256 roles) virtual {\n        assembly {\n            // Compute the role slot.\n            mstore(0x00, or(shl(96, caller()), _OWNER_SLOT_NOT))\n            // Load the stored value, and if the `and` intersection\n            // of the value and `roles` is zero, revert.\n            if iszero(and(sload(keccak256(0x00, 0x20)), roles)) {\n                // If the caller is not the stored owner.\n                if iszero(eq(caller(), sload(not(_OWNER_SLOT_NOT)))) {\n                    mstore(0x00, _UNAUTHORIZED_ERROR_SELECTOR)\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n        _;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       ROLE CONSTANTS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // IYKYK\n\n    uint256 internal constant _ROLE_0 = 1 << 0;\n    uint256 internal constant _ROLE_1 = 1 << 1;\n    uint256 internal constant _ROLE_2 = 1 << 2;\n    uint256 internal constant _ROLE_3 = 1 << 3;\n    uint256 internal constant _ROLE_4 = 1 << 4;\n    uint256 internal constant _ROLE_5 = 1 << 5;\n    uint256 internal constant _ROLE_6 = 1 << 6;\n    uint256 internal constant _ROLE_7 = 1 << 7;\n    uint256 internal constant _ROLE_8 = 1 << 8;\n    uint256 internal constant _ROLE_9 = 1 << 9;\n    uint256 internal constant _ROLE_10 = 1 << 10;\n    uint256 internal constant _ROLE_11 = 1 << 11;\n    uint256 internal constant _ROLE_12 = 1 << 12;\n    uint256 internal constant _ROLE_13 = 1 << 13;\n    uint256 internal constant _ROLE_14 = 1 << 14;\n    uint256 internal constant _ROLE_15 = 1 << 15;\n    uint256 internal constant _ROLE_16 = 1 << 16;\n    uint256 internal constant _ROLE_17 = 1 << 17;\n    uint256 internal constant _ROLE_18 = 1 << 18;\n    uint256 internal constant _ROLE_19 = 1 << 19;\n    uint256 internal constant _ROLE_20 = 1 << 20;\n    uint256 internal constant _ROLE_21 = 1 << 21;\n    uint256 internal constant _ROLE_22 = 1 << 22;\n    uint256 internal constant _ROLE_23 = 1 << 23;\n    uint256 internal constant _ROLE_24 = 1 << 24;\n    uint256 internal constant _ROLE_25 = 1 << 25;\n    uint256 internal constant _ROLE_26 = 1 << 26;\n    uint256 internal constant _ROLE_27 = 1 << 27;\n    uint256 internal constant _ROLE_28 = 1 << 28;\n    uint256 internal constant _ROLE_29 = 1 << 29;\n    uint256 internal constant _ROLE_30 = 1 << 30;\n    uint256 internal constant _ROLE_31 = 1 << 31;\n    uint256 internal constant _ROLE_32 = 1 << 32;\n    uint256 internal constant _ROLE_33 = 1 << 33;\n    uint256 internal constant _ROLE_34 = 1 << 34;\n    uint256 internal constant _ROLE_35 = 1 << 35;\n    uint256 internal constant _ROLE_36 = 1 << 36;\n    uint256 internal constant _ROLE_37 = 1 << 37;\n    uint256 internal constant _ROLE_38 = 1 << 38;\n    uint256 internal constant _ROLE_39 = 1 << 39;\n    uint256 internal constant _ROLE_40 = 1 << 40;\n    uint256 internal constant _ROLE_41 = 1 << 41;\n    uint256 internal constant _ROLE_42 = 1 << 42;\n    uint256 internal constant _ROLE_43 = 1 << 43;\n    uint256 internal constant _ROLE_44 = 1 << 44;\n    uint256 internal constant _ROLE_45 = 1 << 45;\n    uint256 internal constant _ROLE_46 = 1 << 46;\n    uint256 internal constant _ROLE_47 = 1 << 47;\n    uint256 internal constant _ROLE_48 = 1 << 48;\n    uint256 internal constant _ROLE_49 = 1 << 49;\n    uint256 internal constant _ROLE_50 = 1 << 50;\n    uint256 internal constant _ROLE_51 = 1 << 51;\n    uint256 internal constant _ROLE_52 = 1 << 52;\n    uint256 internal constant _ROLE_53 = 1 << 53;\n    uint256 internal constant _ROLE_54 = 1 << 54;\n    uint256 internal constant _ROLE_55 = 1 << 55;\n    uint256 internal constant _ROLE_56 = 1 << 56;\n    uint256 internal constant _ROLE_57 = 1 << 57;\n    uint256 internal constant _ROLE_58 = 1 << 58;\n    uint256 internal constant _ROLE_59 = 1 << 59;\n    uint256 internal constant _ROLE_60 = 1 << 60;\n    uint256 internal constant _ROLE_61 = 1 << 61;\n    uint256 internal constant _ROLE_62 = 1 << 62;\n    uint256 internal constant _ROLE_63 = 1 << 63;\n    uint256 internal constant _ROLE_64 = 1 << 64;\n    uint256 internal constant _ROLE_65 = 1 << 65;\n    uint256 internal constant _ROLE_66 = 1 << 66;\n    uint256 internal constant _ROLE_67 = 1 << 67;\n    uint256 internal constant _ROLE_68 = 1 << 68;\n    uint256 internal constant _ROLE_69 = 1 << 69;\n    uint256 internal constant _ROLE_70 = 1 << 70;\n    uint256 internal constant _ROLE_71 = 1 << 71;\n    uint256 internal constant _ROLE_72 = 1 << 72;\n    uint256 internal constant _ROLE_73 = 1 << 73;\n    uint256 internal constant _ROLE_74 = 1 << 74;\n    uint256 internal constant _ROLE_75 = 1 << 75;\n    uint256 internal constant _ROLE_76 = 1 << 76;\n    uint256 internal constant _ROLE_77 = 1 << 77;\n    uint256 internal constant _ROLE_78 = 1 << 78;\n    uint256 internal constant _ROLE_79 = 1 << 79;\n    uint256 internal constant _ROLE_80 = 1 << 80;\n    uint256 internal constant _ROLE_81 = 1 << 81;\n    uint256 internal constant _ROLE_82 = 1 << 82;\n    uint256 internal constant _ROLE_83 = 1 << 83;\n    uint256 internal constant _ROLE_84 = 1 << 84;\n    uint256 internal constant _ROLE_85 = 1 << 85;\n    uint256 internal constant _ROLE_86 = 1 << 86;\n    uint256 internal constant _ROLE_87 = 1 << 87;\n    uint256 internal constant _ROLE_88 = 1 << 88;\n    uint256 internal constant _ROLE_89 = 1 << 89;\n    uint256 internal constant _ROLE_90 = 1 << 90;\n    uint256 internal constant _ROLE_91 = 1 << 91;\n    uint256 internal constant _ROLE_92 = 1 << 92;\n    uint256 internal constant _ROLE_93 = 1 << 93;\n    uint256 internal constant _ROLE_94 = 1 << 94;\n    uint256 internal constant _ROLE_95 = 1 << 95;\n    uint256 internal constant _ROLE_96 = 1 << 96;\n    uint256 internal constant _ROLE_97 = 1 << 97;\n    uint256 internal constant _ROLE_98 = 1 << 98;\n    uint256 internal constant _ROLE_99 = 1 << 99;\n    uint256 internal constant _ROLE_100 = 1 << 100;\n    uint256 internal constant _ROLE_101 = 1 << 101;\n    uint256 internal constant _ROLE_102 = 1 << 102;\n    uint256 internal constant _ROLE_103 = 1 << 103;\n    uint256 internal constant _ROLE_104 = 1 << 104;\n    uint256 internal constant _ROLE_105 = 1 << 105;\n    uint256 internal constant _ROLE_106 = 1 << 106;\n    uint256 internal constant _ROLE_107 = 1 << 107;\n    uint256 internal constant _ROLE_108 = 1 << 108;\n    uint256 internal constant _ROLE_109 = 1 << 109;\n    uint256 internal constant _ROLE_110 = 1 << 110;\n    uint256 internal constant _ROLE_111 = 1 << 111;\n    uint256 internal constant _ROLE_112 = 1 << 112;\n    uint256 internal constant _ROLE_113 = 1 << 113;\n    uint256 internal constant _ROLE_114 = 1 << 114;\n    uint256 internal constant _ROLE_115 = 1 << 115;\n    uint256 internal constant _ROLE_116 = 1 << 116;\n    uint256 internal constant _ROLE_117 = 1 << 117;\n    uint256 internal constant _ROLE_118 = 1 << 118;\n    uint256 internal constant _ROLE_119 = 1 << 119;\n    uint256 internal constant _ROLE_120 = 1 << 120;\n    uint256 internal constant _ROLE_121 = 1 << 121;\n    uint256 internal constant _ROLE_122 = 1 << 122;\n    uint256 internal constant _ROLE_123 = 1 << 123;\n    uint256 internal constant _ROLE_124 = 1 << 124;\n    uint256 internal constant _ROLE_125 = 1 << 125;\n    uint256 internal constant _ROLE_126 = 1 << 126;\n    uint256 internal constant _ROLE_127 = 1 << 127;\n    uint256 internal constant _ROLE_128 = 1 << 128;\n    uint256 internal constant _ROLE_129 = 1 << 129;\n    uint256 internal constant _ROLE_130 = 1 << 130;\n    uint256 internal constant _ROLE_131 = 1 << 131;\n    uint256 internal constant _ROLE_132 = 1 << 132;\n    uint256 internal constant _ROLE_133 = 1 << 133;\n    uint256 internal constant _ROLE_134 = 1 << 134;\n    uint256 internal constant _ROLE_135 = 1 << 135;\n    uint256 internal constant _ROLE_136 = 1 << 136;\n    uint256 internal constant _ROLE_137 = 1 << 137;\n    uint256 internal constant _ROLE_138 = 1 << 138;\n    uint256 internal constant _ROLE_139 = 1 << 139;\n    uint256 internal constant _ROLE_140 = 1 << 140;\n    uint256 internal constant _ROLE_141 = 1 << 141;\n    uint256 internal constant _ROLE_142 = 1 << 142;\n    uint256 internal constant _ROLE_143 = 1 << 143;\n    uint256 internal constant _ROLE_144 = 1 << 144;\n    uint256 internal constant _ROLE_145 = 1 << 145;\n    uint256 internal constant _ROLE_146 = 1 << 146;\n    uint256 internal constant _ROLE_147 = 1 << 147;\n    uint256 internal constant _ROLE_148 = 1 << 148;\n    uint256 internal constant _ROLE_149 = 1 << 149;\n    uint256 internal constant _ROLE_150 = 1 << 150;\n    uint256 internal constant _ROLE_151 = 1 << 151;\n    uint256 internal constant _ROLE_152 = 1 << 152;\n    uint256 internal constant _ROLE_153 = 1 << 153;\n    uint256 internal constant _ROLE_154 = 1 << 154;\n    uint256 internal constant _ROLE_155 = 1 << 155;\n    uint256 internal constant _ROLE_156 = 1 << 156;\n    uint256 internal constant _ROLE_157 = 1 << 157;\n    uint256 internal constant _ROLE_158 = 1 << 158;\n    uint256 internal constant _ROLE_159 = 1 << 159;\n    uint256 internal constant _ROLE_160 = 1 << 160;\n    uint256 internal constant _ROLE_161 = 1 << 161;\n    uint256 internal constant _ROLE_162 = 1 << 162;\n    uint256 internal constant _ROLE_163 = 1 << 163;\n    uint256 internal constant _ROLE_164 = 1 << 164;\n    uint256 internal constant _ROLE_165 = 1 << 165;\n    uint256 internal constant _ROLE_166 = 1 << 166;\n    uint256 internal constant _ROLE_167 = 1 << 167;\n    uint256 internal constant _ROLE_168 = 1 << 168;\n    uint256 internal constant _ROLE_169 = 1 << 169;\n    uint256 internal constant _ROLE_170 = 1 << 170;\n    uint256 internal constant _ROLE_171 = 1 << 171;\n    uint256 internal constant _ROLE_172 = 1 << 172;\n    uint256 internal constant _ROLE_173 = 1 << 173;\n    uint256 internal constant _ROLE_174 = 1 << 174;\n    uint256 internal constant _ROLE_175 = 1 << 175;\n    uint256 internal constant _ROLE_176 = 1 << 176;\n    uint256 internal constant _ROLE_177 = 1 << 177;\n    uint256 internal constant _ROLE_178 = 1 << 178;\n    uint256 internal constant _ROLE_179 = 1 << 179;\n    uint256 internal constant _ROLE_180 = 1 << 180;\n    uint256 internal constant _ROLE_181 = 1 << 181;\n    uint256 internal constant _ROLE_182 = 1 << 182;\n    uint256 internal constant _ROLE_183 = 1 << 183;\n    uint256 internal constant _ROLE_184 = 1 << 184;\n    uint256 internal constant _ROLE_185 = 1 << 185;\n    uint256 internal constant _ROLE_186 = 1 << 186;\n    uint256 internal constant _ROLE_187 = 1 << 187;\n    uint256 internal constant _ROLE_188 = 1 << 188;\n    uint256 internal constant _ROLE_189 = 1 << 189;\n    uint256 internal constant _ROLE_190 = 1 << 190;\n    uint256 internal constant _ROLE_191 = 1 << 191;\n    uint256 internal constant _ROLE_192 = 1 << 192;\n    uint256 internal constant _ROLE_193 = 1 << 193;\n    uint256 internal constant _ROLE_194 = 1 << 194;\n    uint256 internal constant _ROLE_195 = 1 << 195;\n    uint256 internal constant _ROLE_196 = 1 << 196;\n    uint256 internal constant _ROLE_197 = 1 << 197;\n    uint256 internal constant _ROLE_198 = 1 << 198;\n    uint256 internal constant _ROLE_199 = 1 << 199;\n    uint256 internal constant _ROLE_200 = 1 << 200;\n    uint256 internal constant _ROLE_201 = 1 << 201;\n    uint256 internal constant _ROLE_202 = 1 << 202;\n    uint256 internal constant _ROLE_203 = 1 << 203;\n    uint256 internal constant _ROLE_204 = 1 << 204;\n    uint256 internal constant _ROLE_205 = 1 << 205;\n    uint256 internal constant _ROLE_206 = 1 << 206;\n    uint256 internal constant _ROLE_207 = 1 << 207;\n    uint256 internal constant _ROLE_208 = 1 << 208;\n    uint256 internal constant _ROLE_209 = 1 << 209;\n    uint256 internal constant _ROLE_210 = 1 << 210;\n    uint256 internal constant _ROLE_211 = 1 << 211;\n    uint256 internal constant _ROLE_212 = 1 << 212;\n    uint256 internal constant _ROLE_213 = 1 << 213;\n    uint256 internal constant _ROLE_214 = 1 << 214;\n    uint256 internal constant _ROLE_215 = 1 << 215;\n    uint256 internal constant _ROLE_216 = 1 << 216;\n    uint256 internal constant _ROLE_217 = 1 << 217;\n    uint256 internal constant _ROLE_218 = 1 << 218;\n    uint256 internal constant _ROLE_219 = 1 << 219;\n    uint256 internal constant _ROLE_220 = 1 << 220;\n    uint256 internal constant _ROLE_221 = 1 << 221;\n    uint256 internal constant _ROLE_222 = 1 << 222;\n    uint256 internal constant _ROLE_223 = 1 << 223;\n    uint256 internal constant _ROLE_224 = 1 << 224;\n    uint256 internal constant _ROLE_225 = 1 << 225;\n    uint256 internal constant _ROLE_226 = 1 << 226;\n    uint256 internal constant _ROLE_227 = 1 << 227;\n    uint256 internal constant _ROLE_228 = 1 << 228;\n    uint256 internal constant _ROLE_229 = 1 << 229;\n    uint256 internal constant _ROLE_230 = 1 << 230;\n    uint256 internal constant _ROLE_231 = 1 << 231;\n    uint256 internal constant _ROLE_232 = 1 << 232;\n    uint256 internal constant _ROLE_233 = 1 << 233;\n    uint256 internal constant _ROLE_234 = 1 << 234;\n    uint256 internal constant _ROLE_235 = 1 << 235;\n    uint256 internal constant _ROLE_236 = 1 << 236;\n    uint256 internal constant _ROLE_237 = 1 << 237;\n    uint256 internal constant _ROLE_238 = 1 << 238;\n    uint256 internal constant _ROLE_239 = 1 << 239;\n    uint256 internal constant _ROLE_240 = 1 << 240;\n    uint256 internal constant _ROLE_241 = 1 << 241;\n    uint256 internal constant _ROLE_242 = 1 << 242;\n    uint256 internal constant _ROLE_243 = 1 << 243;\n    uint256 internal constant _ROLE_244 = 1 << 244;\n    uint256 internal constant _ROLE_245 = 1 << 245;\n    uint256 internal constant _ROLE_246 = 1 << 246;\n    uint256 internal constant _ROLE_247 = 1 << 247;\n    uint256 internal constant _ROLE_248 = 1 << 248;\n    uint256 internal constant _ROLE_249 = 1 << 249;\n    uint256 internal constant _ROLE_250 = 1 << 250;\n    uint256 internal constant _ROLE_251 = 1 << 251;\n    uint256 internal constant _ROLE_252 = 1 << 252;\n    uint256 internal constant _ROLE_253 = 1 << 253;\n    uint256 internal constant _ROLE_254 = 1 << 254;\n    uint256 internal constant _ROLE_255 = 1 << 255;\n}"

    }

  },

  "settings": {

    "optimizer": {

      "enabled": false,

      "runs": 200

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    }

  }

}}