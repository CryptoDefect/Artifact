{{

  "language": "Solidity",

  "sources": {

    "lib/fiveoutofnine/src/Chess.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport { Engine } from \"./Engine.sol\";\n\n/// @title Utils library for fiveoutofnine (a 100% on-chain 6x6 chess engine)\n/// @author fiveoutofnine\n/// @dev Understand the representations of the chess pieces, board, and moves very carefully before\n/// using this library:\n/// ======================================Piece Representation======================================\n/// Each chess piece is defined with 4 bits as follows:\n///     * The first bit denotes the color (0 means black; 1 means white).\n///     * The last 3 bits denote the type:\n///         | Bits | # | Type   |\n///         | ---- | - | ------ |\n///         | 000  | 0 | Empty  |\n///         | 001  | 1 | Pawn   |\n///         | 010  | 2 | Bishop |\n///         | 011  | 3 | Rook   |\n///         | 100  | 4 | Knight |\n///         | 101  | 5 | Queen  |\n///         | 110  | 6 | King   |\n/// ======================================Board Representation======================================\n/// The board is an 8x8 representation of a 6x6 chess board. For efficiency, all information is\n/// bitpacked into a single uint256. Thus, unlike typical implementations, board positions are\n/// accessed via bit shifts and bit masks, as opposed to array accesses. Since each piece is 4 bits,\n/// there are 64 ``indices'' to access:\n///                                     63 62 61 60 59 58 57 56\n///                                     55 54 53 52 51 50 49 48\n///                                     47 46 45 44 43 42 41 40\n///                                     39 38 37 36 35 34 33 32\n///                                     31 30 29 28 27 26 25 24\n///                                     23 22 21 20 19 18 17 16\n///                                     15 14 13 12 11 10 09 08\n///                                     07 06 05 04 03 02 01 00\n/// All numbers in the figure above are in decimal representation.\n/// For example, the piece at index 27 is accessed with ``(board >> (27 << 2)) & 0xF''.\n///\n/// The top/bottom rows and left/right columns are treated as sentinel rows/columns for efficient\n/// boundary validation (see {Chess-generateMoves} and {Chess-isValid}). i.e., (63, ..., 56),\n/// (07, ..., 00), (63, ..., 07), and (56, ..., 00) never contain pieces. Every bit in those rows\n/// and columns should be ignored, except for the last bit. The last bit denotes whose turn it is to\n/// play (0 means black's turn; 1 means white's turn). e.g. a potential starting position:\n///                                Black\n///                       00 00 00 00 00 00 00 00                    Black\n///                       00 03 02 05 06 02 03 00                 ♜ ♝ ♛ ♚ ♝ ♜\n///                       00 01 01 01 01 01 01 00                 ♟ ♟ ♟ ♟ ♟ ♟\n///                       00 00 00 00 00 00 00 00     denotes\n///                       00 00 00 00 00 00 00 00    the board\n///                       00 09 09 09 09 09 09 00                 ♙ ♙ ♙ ♙ ♙ ♙\n///                       00 11 12 13 14 12 11 00                 ♖ ♘ ♕ ♔ ♘ ♖\n///                       00 00 00 00 00 00 00 01                    White\n///                                White\n/// All numbers in the example above are in decimal representation.\n/// ======================================Move Representation=======================================\n/// Each move is allocated 12 bits. The first 6 bits are the index the piece is moving from, and the\n/// last 6 bits are the index the piece is moving to. Since the index representing a square is at\n/// most 54, 6 bits sufficiently represents any index (0b111111 = 63 > 54). e.g. 1243 denotes a move\n/// from index 19 to 27 (1243 = (19 << 6) | 27).\n///\n/// Since the board is represented by a uint256, consider including ``using Chess for uint256''.\nlibrary Chess {\n    using Chess for uint256;\n    using Chess for Chess.MovesArray;\n\n    /// The depth, white's move, and black's move are bitpacked in that order as `metadata` for\n    /// efficiency. As explained above, 12 bits sufficiently describe a move, so both white's and\n    /// black's moves are allocated 12 bits each.\n    struct Move {\n        uint256 board;\n        uint256 metadata;\n    }\n\n    /// ``moves'' are bitpacked into uint256s for efficiency. Since every move is defined by at most\n    /// 12 bits, a uint256 can contain up to 21 moves via bitpacking (21 * 12 = 252 < 256).\n    /// Therefore, `items` can contain up to 21 * 5 = 105 moves. 105 is a safe upper bound for the\n    /// number of possible moves a given side may have during a real game, but be wary because there\n    /// is no formal proof of the upper bound being less than or equal to 105.\n    struct MovesArray {\n        uint256 index;\n        uint256[5] items;\n    }\n\n    /// @notice Takes in a board position, and applies the move `_move` to it.\n    /// @dev After applying the move, the board's perspective is updated (see {rotate}). Thus,\n    /// engines with symmterical search algorithms -- like negamax search -- probably work best.\n    /// @param _board The board to apply the move to.\n    /// @param _move The move to apply.\n    /// @return The reversed board after applying `_move` to `_board`.\n    function applyMove(uint256 _board, uint256 _move) internal pure returns (uint256) {\n        unchecked {\n            // Get piece at the from index\n            uint256 piece = (_board >> ((_move >> 6) << 2)) & 0xF;\n            // Replace 4 bits at the from index with 0000\n            _board &= type(uint256).max ^ (0xF << ((_move >> 6) << 2));\n            // Replace 4 bits at the to index with 0000\n            _board &= type(uint256).max ^ (0xF << ((_move & 0x3F) << 2));\n            // Place the piece at the to index\n            _board |= (piece << ((_move & 0x3F) << 2));\n\n            return _board.rotate();\n        }\n    }\n\n    /// @notice Switches the perspective of the board by reversing its 4-bit subdivisions (e.g.\n    /// 1100-0011 would become 0011-1100).\n    /// @dev Since the last bit exchanges positions with the 4th bit, the turn identifier is updated\n    /// as well.\n    /// @param _board The board to reverse the perspective on.\n    /// @return `_board` reversed.\n    function rotate(uint256 _board) internal pure returns (uint256) {\n        uint256 rotatedBoard;\n\n        unchecked {\n            for (uint256 i; i < 64; ++i) {\n                rotatedBoard = (rotatedBoard << 4) | (_board & 0xF);\n                _board >>= 4;\n            }\n        }\n\n        return rotatedBoard;\n    }\n\n    /// @notice Generates all possible pseudolegal moves for a given position and color.\n    /// @dev The last bit denotes which color to generate the moves for (see {Chess}). Also, the\n    /// function errors if more than 105 moves are found (see {Chess-MovesArray}). All moves are\n    /// expressed in code as shifts respective to the board's 8x8 representation (see {Chess}).\n    /// @param _board The board position to generate moves for.\n    /// @return Bitpacked uint256(s) containing moves.\n    function generateMoves(uint256 _board) internal pure returns (uint256[5] memory) {\n        Chess.MovesArray memory movesArray;\n        uint256 move;\n        uint256 moveTo;\n\n        unchecked {\n            // `0xDB5D33CB1BADB2BAA99A59238A179D71B69959551349138D30B289` is a mapping of indices\n            // relative to the 6x6 board to indices relative to the 8x8 representation (see\n            // {Chess-getAdjustedIndex}).\n            for (\n                uint256 index = 0xDB5D33CB1BADB2BAA99A59238A179D71B69959551349138D30B289;\n                index != 0;\n                index >>= 6\n            ) {\n                uint256 adjustedIndex = index & 0x3F;\n                uint256 adjustedBoard = _board >> (adjustedIndex << 2);\n                uint256 piece = adjustedBoard & 0xF;\n                // Skip if square is empty or not the color of the board the function call is\n                // analyzing.\n                if (piece == 0 || piece >> 3 != _board & 1) continue;\n                // The first bit can be discarded because the if statement above catches all\n                // redundant squares.\n                piece &= 7;\n\n                if (piece == 1) { // Piece is a pawn.\n                    // 1 square in front of the pawn is empty.\n                    if ((adjustedBoard >> 0x20) & 0xF == 0) {\n                        movesArray.append(adjustedIndex, adjustedIndex + 8);\n                        // The pawn is in its starting row and 2 squares in front is empty. This\n                        // must be nested because moving 2 squares would not be valid if there was\n                        // an obstruction 1 square in front (i.e. pawns can not jump over pieces).\n                        if (adjustedIndex >> 3 == 2 && (adjustedBoard >> 0x40) & 0xF == 0) {\n                            movesArray.append(adjustedIndex, adjustedIndex + 0x10);\n                        }\n                    }\n                    // Moving to the right diagonal by 1 captures a piece.\n                    if (_board.isCapture(adjustedBoard >> 0x1C)) {\n                        movesArray.append(adjustedIndex, adjustedIndex + 7); \n                    }\n                    // Moving to the left diagonal by 1 captures a piece.\n                    if (_board.isCapture(adjustedBoard >> 0x24)) {\n                        movesArray.append(adjustedIndex, adjustedIndex + 9);\n                    }\n                } else if (piece > 3 && piece & 1 == 0) { // Piece is a knight or a king.\n                    // Knights and kings always only have 8 positions to check relative to their\n                    // current position, and the relative distances are always the same. For\n                    // knights, positions to check are ±{6, 10, 15, 17}. This is bitpacked into\n                    // `0x060A0F11` to reduce code redundancy. Similarly, the positions to check for\n                    // kings are ±{1, 7, 8, 9}, which is `0x01070809` when bitpacked.\n                    for (move = piece == 4 ? 0x060A0F11 : 0x01070809; move != 0; move >>= 8) {\n                        if (_board.isValid(moveTo = adjustedIndex + (move & 0xFF))) {\n                            movesArray.append(adjustedIndex, moveTo);\n                        }\n                        if (move <= adjustedIndex\n                            && _board.isValid(moveTo = adjustedIndex - (move & 0xFF)))\n                        {\n                            movesArray.append(adjustedIndex, moveTo);\n                        }\n                    }\n                } else {\n                    // This else block generates moves for all sliding pieces. All of the 8 for\n                    // loops terminate\n                    //     * before a sliding piece makes an illegal move\n                    //     * or after a sliding piece captures a piece.\n                    if (piece != 2) { // Ortholinear pieces (i.e. rook and queen)\n                        for (move = adjustedIndex + 1; _board.isValid(move); move += 1) {\n                            movesArray.append(adjustedIndex, move);\n                            if (_board.isCapture(_board >> (move << 2))) break;\n                        }\n                        for (move = adjustedIndex - 1; _board.isValid(move); move -= 1) {\n                            movesArray.append(adjustedIndex, move);\n                            if (_board.isCapture(_board >> (move << 2))) break;\n                        }\n                        for (move = adjustedIndex + 8; _board.isValid(move); move += 8) {\n                            movesArray.append(adjustedIndex, move);\n                            if (_board.isCapture(_board >> (move << 2))) break;\n                        }\n                        for (move = adjustedIndex - 8; _board.isValid(move); move -= 8) {\n                            movesArray.append(adjustedIndex, move);\n                            if (_board.isCapture(_board >> (move << 2))) break;\n                        }\n                    }\n                    if (piece != 3) { // Diagonal pieces (i.e. bishop and queen)\n                        for (move = adjustedIndex + 7; _board.isValid(move); move += 7) {\n                            movesArray.append(adjustedIndex, move);\n                            if (_board.isCapture(_board >> (move << 2))) break;\n                        }\n                        for (move = adjustedIndex - 7; _board.isValid(move); move -= 7) {\n                            movesArray.append(adjustedIndex, move);\n                            if (_board.isCapture(_board >> (move << 2))) break;\n                        }\n                        for (move = adjustedIndex + 9; _board.isValid(move); move += 9) {\n                            movesArray.append(adjustedIndex, move);\n                            if (_board.isCapture(_board >> (move << 2))) break;\n                        }\n                        for (move = adjustedIndex - 9; _board.isValid(move); move -= 9) {\n                            // Handles the edge case where a white bishop believes it can capture\n                            // the ``piece'' at index 0, when it is actually the turn identifier It\n                            // would mistakenly believe it is valid move via capturing a black pawn.\n                            if (move == 0) break;\n                            movesArray.append(adjustedIndex, move);\n                            if (_board.isCapture(_board >> (move << 2))) break;\n                        }\n                    }\n                }\n            }\n        }\n\n        return movesArray.items;\n    }\n\n    /// @notice Determines whether a move is a legal move or not (includes checking whether king is\n    /// checked or not after the move).\n    /// @param _board The board to analyze.\n    /// @param _move The move to check.\n    /// @return Whether the move is legal or not.\n    function isLegalMove(uint256 _board, uint256 _move) internal pure returns (bool) {\n        unchecked {\n            uint256 fromIndex = _move >> 6;\n            uint256 toIndex = _move & 0x3F;\n            if ((0x7E7E7E7E7E7E00 >> fromIndex) & 1 == 0) return false;\n            if ((0x7E7E7E7E7E7E00 >> toIndex) & 1 == 0) return false;\n\n            uint256 pieceAtFromIndex = (_board >> (fromIndex << 2)) & 0xF;\n            if (pieceAtFromIndex == 0) return false;\n            if (pieceAtFromIndex >> 3 != _board & 1) return false;\n            pieceAtFromIndex &= 7;\n\n            uint256 adjustedBoard = _board >> (toIndex << 2);\n            uint256 indexChange = toIndex < fromIndex\n                    ? fromIndex - toIndex\n                    : toIndex - fromIndex;\n            if (pieceAtFromIndex == 1) {\n                if (toIndex <= fromIndex) return false;\n                indexChange = toIndex - fromIndex;\n                if ((indexChange == 7 || indexChange == 9)) {\n                    if (!_board.isCapture(adjustedBoard)) return false;\n                } else if (indexChange == 8) {\n                    if (!isValid(_board, toIndex)) return false;\n                } else if (indexChange == 0x10) {\n                    if (!isValid(_board, toIndex - 8) || !isValid(_board, toIndex)) return false;\n                } else {\n                    return false;\n                }\n            } else if (pieceAtFromIndex == 4 || pieceAtFromIndex == 6) {\n                if (((pieceAtFromIndex == 4 ? 0x28440 : 0x382) >> indexChange) & 1 == 0) {\n                    return false;\n                }\n                if (!isValid(_board, toIndex)) return false;\n            } else {\n                bool rayFound;\n                if (pieceAtFromIndex != 2) {\n                    rayFound = searchRay(_board, fromIndex, toIndex, 1)\n                        || searchRay(_board, fromIndex, toIndex, 8);\n                }\n                if (pieceAtFromIndex != 3) {\n                    rayFound = rayFound\n                        || searchRay(_board, fromIndex, toIndex, 7)\n                        || searchRay(_board, fromIndex, toIndex, 9);\n                }\n                if (!rayFound) return false;\n            }\n\n            if (Engine.negaMax(_board.applyMove(_move), 1) < -1_260) return false;\n\n            return true;\n        }\n    }\n\n    /// @notice Determines whether there is a clear path along a direction vector from one index to\n    /// another index on the board.\n    /// @dev The board's representation essentially flattens it from 2D to 1D, so `_directionVector`\n    /// should be the change in index that represents the direction vector.\n    /// @param _board The board to analyze.\n    /// @param _fromIndex The index of the starting piece.\n    /// @param _toIndex The index of the ending piece.\n    /// @param _directionVector The direction vector of the ray.\n    /// @return Whether there is a clear path between `_fromIndex` and `_toIndex` or not.\n    function searchRay(\n        uint256 _board,\n        uint256 _fromIndex,\n        uint256 _toIndex,\n        uint256 _directionVector\n    )\n        internal pure\n        returns (bool)\n    {\n        unchecked {\n            uint256 indexChange;\n            uint256 rayStart;\n            uint256 rayEnd;\n            if (_fromIndex < _toIndex) {\n                indexChange = _toIndex - _fromIndex;\n                rayStart = _fromIndex + _directionVector;\n                rayEnd = _toIndex;\n            } else {\n                indexChange = _fromIndex - _toIndex;\n                rayStart = _toIndex;\n                rayEnd = _fromIndex - _directionVector;\n            }\n            if (indexChange % _directionVector != 0) return false;\n\n            for (\n                rayStart = rayStart;\n                rayStart < rayEnd;\n                rayStart += _directionVector\n            ) {\n                if (!isValid(_board, rayStart)) return false;\n                if (isCapture(_board, _board >> (rayStart << 2))) return false;\n            }\n\n            if (!isValid(_board, rayStart)) return false;\n\n            return rayStart == rayEnd;\n        }\n    }\n\n    /// @notice Determines whether a move results in a capture or not.\n    /// @param _board The board prior to the potential capture.\n    /// @param _indexAdjustedBoard The board bitshifted to the to index to consider.\n    /// @return Whether the move is a capture or not.\n    function isCapture(uint256 _board, uint256 _indexAdjustedBoard) internal pure returns (bool) {\n        unchecked {\n            return (_indexAdjustedBoard & 0xF) != 0 // The square is not empty.\n                && (_indexAdjustedBoard & 0xF) >> 3 != _board & 1; // The piece is opposite color.\n        }\n    }\n\n    /// @notice Determines whether a move is valid or not (i.e. within bounds and not capturing\n    /// same colored piece).\n    /// @dev As mentioned above, the board representation has 2 sentinel rows and columns for\n    /// efficient boundary validation as follows:\n    ///                                           0 0 0 0 0 0 0 0\n    ///                                           0 1 1 1 1 1 1 0\n    ///                                           0 1 1 1 1 1 1 0\n    ///                                           0 1 1 1 1 1 1 0\n    ///                                           0 1 1 1 1 1 1 0\n    ///                                           0 1 1 1 1 1 1 0\n    ///                                           0 1 1 1 1 1 1 0\n    ///                                           0 0 0 0 0 0 0 0,\n    /// where 1 means a piece is within the board, and 0 means the piece is out of bounds. The bits\n    /// are bitpacked into a uint256 (i.e. ``0x7E7E7E7E7E7E00 = 0 << 63 | ... | 0 << 0'') for\n    /// efficiency.\n    ///\n    /// Moves that overflow the uint256 are computed correctly because bitshifting more than bits\n    /// available results in 0. However, moves that underflow the uint256 (i.e. applying the move\n    /// results in a negative index) must be checked beforehand.\n    /// @param _board The board on which to consider whether the move is valid.\n    /// @param _toIndex The to index of the move.\n    /// @return Whether the move is valid or not.\n    function isValid(uint256 _board, uint256 _toIndex) internal pure returns (bool) {\n        unchecked {\n            return (0x7E7E7E7E7E7E00 >> _toIndex) & 1 == 1 // Move is within bounds.\n                && ((_board >> (_toIndex << 2)) & 0xF == 0 // Square is empty.\n                    || (((_board >> (_toIndex << 2)) & 0xF) >> 3) != _board & 1); // Piece captured.\n        }\n    }\n\n    /// @notice Maps an index relative to the 6x6 board to the index relative to the 8x8\n    /// representation.\n    /// @dev The indices are mapped as follows:\n    ///                           35 34 33 32 31 30              54 53 52 51 50 49\n    ///                           29 28 27 26 25 24              46 45 44 43 42 41\n    ///                           23 22 21 20 19 18    mapped    38 37 36 35 34 33\n    ///                           17 16 15 14 13 12      to      30 29 28 27 26 25\n    ///                           11 10 09 08 07 06              22 21 20 19 18 17\n    ///                           05 04 03 02 01 00              14 13 12 11 10 09\n    /// All numbers in the figure above are in decimal representation. The bits are bitpacked into a\n    /// uint256 (i.e. ``0xDB5D33CB1BADB2BAA99A59238A179D71B69959551349138D30B289 = 54 << (6 * 35) |\n    /// ... | 9 << (6 * 0)'') for efficiency.\n    /// @param _index Index relative to the 6x6 board.\n    /// @return Index relative to the 8x8 representation.\n    function getAdjustedIndex(uint256 _index) internal pure returns (uint256) {\n        unchecked {\n            return (\n                (0xDB5D33CB1BADB2BAA99A59238A179D71B69959551349138D30B289 >> (_index * 6)) & 0x3F\n            );\n        }\n    }\n\n    /// @notice Appends a move to a {Chess-MovesArray} object.\n    /// @dev Since each uint256 fits at most 21 moves (see {Chess-MovesArray}), {Chess-append}\n    /// bitpacks 21 moves per uint256 before moving on to the next uint256.\n    /// @param _movesArray {Chess-MovesArray} object to append the new move to.\n    /// @param _fromMoveIndex Index the piece moves from.\n    /// @param _toMoveIndex Index the piece moves to.\n    function append(MovesArray memory _movesArray, uint256 _fromMoveIndex, uint256 _toMoveIndex)\n        internal pure\n    {\n        unchecked {\n            uint256 currentIndex = _movesArray.index;\n            uint256 currentPartition = _movesArray.items[currentIndex];\n\n            if (currentPartition > (1 << 0xF6)) {\n                _movesArray.items[++_movesArray.index] = (_fromMoveIndex << 6) | _toMoveIndex;\n            } else {\n                _movesArray.items[currentIndex] = (currentPartition << 0xC)\n                    | (_fromMoveIndex << 6)\n                    | _toMoveIndex;\n            }\n        }\n    }\n}\n"

    },

    "lib/fiveoutofnine/src/Engine.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport { Chess } from \"./Chess.sol\";\n\n/// @title A 6x6 chess engine with negamax search\n/// @author fiveoutofnine\n/// @notice Docstrings below are written from the perspective of black (i.e. written as if the\n/// engine is always black). However, due to negamax's symmetric nature, the engine may be used for\n/// white as well.\nlibrary Engine {\n    using Chess for uint256;\n    using Engine for uint256;\n\n    /// @notice Searches for the ``best'' move.\n    /// @dev The ply depth must be at least 3 because game ending scenarios are determined lazily.\n    /// This is because {generateMoves} generates pseudolegal moves. Consider the following:\n    ///     1. In the case of white checkmates black, depth 2 is necessary:\n    ///         * Depth 1: This is the move black plays after considering depth 2.\n    ///         * Depth 2: Check whether white captures black's king within 1 turn for every such\n    ///           move. If so, white has checkmated black.\n    ///     2. In the case of black checkmates white, depth 3 is necessary:\n    ///         * Depth 1: This is the move black plays after considering depths 2 and 3.\n    ///         * Depth 2: Generate all pseudolegal moves for white in response to black's move.\n    ///         * Depth 3: Check whether black captures white's king within 1 turn for every such\n    ///         * move. If so, black has checkmated white.\n    /// The minimum depth required to cover all the cases above is 3. For simplicity, stalemates\n    /// are treated as checkmates.\n    ///\n    /// The function returns 0 if the game is over after white's move (no collision with any\n    /// potentially real moves because 0 is not a valid index), and returns true if the game is over\n    /// after black's move.\n    /// @param _board The board position to analyze.\n    /// @param _depth The ply depth to analyze to. Must be at least 3.\n    /// @return The best move for the player (denoted by the last bit in `_board`).\n    /// @return Whether white is checkmated or not.\n    function searchMove(uint256 _board, uint256 _depth) internal pure returns (uint256, bool) {\n        uint256[5] memory moves = _board.generateMoves();\n        if (moves[0] == 0) return (0, false);\n        // See {Engine-negaMax} for explanation on why `bestScore` is set to -4_196.\n        int256 bestScore = -4_196;\n        int256 currentScore;\n        uint256 bestMove;\n\n        unchecked {\n            for (uint256 i; moves[i] != 0; ++i) {\n                for (uint256 movePartition = moves[i]; movePartition != 0; movePartition >>= 0xC) {\n                    currentScore = _board.evaluateMove(movePartition & 0xFFF)\n                        + negaMax(_board.applyMove(movePartition & 0xFFF), _depth - 1);\n                    if (currentScore > bestScore) {\n                        bestScore = currentScore;\n                        bestMove = movePartition & 0xFFF;\n                    }\n                }\n            }\n        }\n\n        // 1_260 is equivalent to 7 queens (7 * 180 = 1260). Since a king's capture is equivalent to\n        // an evaluation of 4_000, ±1_260 catches all lines that include the capture of a king.\n        if (bestScore < -1_260) return (0, false);\n        return (bestMove, bestScore > 1_260);\n    }\n\n    /// @notice Searches and evaluates moves using a variant of the negamax search algorithm.\n    /// @dev For efficiency, the function evaluates how good moves are and sums them up, rather than\n    /// evaluating entire board positions. Thus, the only pruning the algorithm performs is when a\n    /// king is captured. If a king is captured, it always returns -4,000, which is the king's value\n    /// (see {Chess}) because there is nothing more to consider.\n    /// @param _board The board position to analyze.\n    /// @param _depth The ply depth to analyze to.\n    /// @return The cumulative score searched to a ply depth of `_depth`, assuming each side picks\n    /// their ``best'' (as decided by {Engine-evaluateMove}) moves.\n    function negaMax(uint256 _board, uint256 _depth) internal pure returns (int256) {\n        // Base case for the recursion.\n        if (_depth == 0) return 0;\n        uint256[5] memory moves = _board.generateMoves();\n        // There is no ``best'' score if there are no moves to play.\n        if (moves[0] == 0) return 0;\n        // `bestScore` is initially set to -4_196 because no line will result in a cumulative\n        // evaluation of <-4_195. -4_195 occurs, for example. when the engine's king is captured\n        // (-4000), and the player captures an engine's queen on index 35 (-181) with knight from\n        // index 52 (-14).\n        int256 bestScore = -4_196;\n        int256 currentScore;\n        uint256 bestMove;\n\n        unchecked {\n            for (uint256 i; moves[i] != 0; ++i) {\n                for (uint256 movePartition = moves[i]; movePartition != 0; movePartition >>= 0xC) {\n                    currentScore = _board.evaluateMove(movePartition & 0xFFF);\n                    if (currentScore > bestScore) {\n                        bestScore = currentScore;\n                        bestMove = movePartition & 0xFFF;\n                    }\n                }\n            }\n\n            // If a king is captured, stop the recursive call stack and return a score of 4_000.\n            // There is nothing more to consider.\n            if (((_board >> ((bestMove & 0x3F) << 2)) & 7) == 6) return 4_000;\n            return _board & 1 == 0\n                ? bestScore + negaMax(_board.applyMove(bestMove), _depth - 1)\n                : -bestScore + negaMax(_board.applyMove(bestMove), _depth - 1);\n        }\n    }\n\n    /// @notice Uses piece-square tables (PSTs) to evaluate how ``good'' a move is.\n    /// @dev The PSTs were selected semi-arbitrarily with chess strategies in mind (e.g. pawns are\n    /// good in the center). Updating them changes the way the engine ``thinks.'' Each piece's PST\n    /// is bitpacked into as few uint256s as possible for efficiency (see {Engine-getPst} and\n    /// {Engine-getPstTwo}):\n    ///          Pawn                Bishop               Knight                   Rook\n    ///    20 20 20 20 20 20    62 64 64 64 64 62    54 56 54 54 56 58    100 100 100 100 100 100\n    ///    30 30 30 30 30 30    64 66 66 66 66 64    56 60 64 64 60 56    101 102 102 102 102 101\n    ///    20 22 24 24 22 20    64 67 68 68 67 64    58 64 68 68 64 58     99 100 100 100 100  99\n    ///    21 20 26 26 20 21    64 68 68 68 68 64    58 65 68 68 65 58     99 100 100 100 100  99\n    ///    21 30 16 16 30 21    64 67 66 66 67 64    56 60 65 65 60 56     99 100 100 100 100  99\n    ///    20 20 20 20 20 20    62 64 64 64 64 62    54 56 58 58 56 54    100 100 101 101 100 100\n    ///                            Queen                         King\n    ///                   176 178 179 179 178 176    3994 3992 3990 3990 3992 3994\n    ///                   178 180 180 180 180 178    3994 3992 3990 3990 3992 3994\n    ///                   179 180 181 181 180 179    3996 3994 3992 3992 3994 3995\n    ///                   179 181 181 181 180 179    3998 3996 3996 3996 3996 3998\n    ///                   178 180 181 180 180 178    4001 4001 4000 4000 4001 4001\n    ///                   176 178 179 179 178 176    4004 4006 4002 4002 4006 4004\n    /// All entries in the figure above are in decimal representation.\n    ///\n    /// Each entry in the pawn's, bishop's, knight's, and rook's PSTs uses 7 bits, and each entry in\n    /// the queen's and king's PSTs uses 12 bits. Additionally, each piece is valued as following:\n    ///                                      | Type   | Value |\n    ///                                      | ------ | ----- |\n    ///                                      | Pawn   | 20    |\n    ///                                      | Bishop | 66    |\n    ///                                      | Knight | 64    |\n    ///                                      | Rook   | 100   |\n    ///                                      | Queen  | 180   |\n    ///                                      | King   | 4000  |\n    /// The king's value just has to be sufficiently larger than 180 * 7 = 1260 (i.e. equivalent to\n    /// 7 queens) because check/checkmates are detected lazily (see {Engine-generateMoves}).\n    ///\n    /// The evaluation of a move is given by\n    ///                Δ(PST value of the moved piece) + (PST value of any captured pieces).\n    /// @param _board The board to apply the move to.\n    /// @param _move The move to evaluate.\n    /// @return The evaluation of the move applied to the given position.\n    function evaluateMove(uint256 _board, uint256 _move) internal pure returns (int256) {\n        unchecked {\n            uint256 fromIndex = 6 * (_move >> 9) + ((_move >> 6) & 7) - 7;\n            uint256 toIndex = 6 * ((_move & 0x3F) >> 3) + ((_move & 0x3F) & 7) - 7;\n            uint256 pieceAtFromIndex = (_board >> ((_move >> 6) << 2)) & 7;\n            uint256 pieceAtToIndex = (_board >> ((_move & 0x3F) << 2)) & 7;\n            uint256 oldPst;\n            uint256 newPst;\n            uint256 captureValue;\n\n            if (pieceAtToIndex != 0) {\n                if (pieceAtToIndex < 5) { // Piece is not a queen or king\n                    captureValue = (getPst(pieceAtToIndex) >> (7 * (0x23 - toIndex))) & 0x7F;\n                } else\n                if (toIndex < 0x12) { // Piece is queen or king and in the closer half\n                    captureValue = (getPst(pieceAtToIndex) >> (0xC * (0x11 - toIndex))) & 0xFFF;\n                } else { // Piece is queen or king and in the further half\n                    captureValue = (getPstTwo(pieceAtToIndex) >> (0xC * (0x23 - toIndex))) & 0xFFF;\n                }\n            }\n            if (pieceAtFromIndex < 5) { // Piece is not a queen or king\n                oldPst = (getPst(pieceAtFromIndex) >> (7 * fromIndex)) & 0x7F;\n                newPst = (getPst(pieceAtFromIndex) >> (7 * toIndex)) & 0x7F;\n            } else\n            if (fromIndex < 0x12) { // Piece is queen or king and in the closer half\n                oldPst = (getPstTwo(pieceAtFromIndex) >> (0xC * fromIndex)) & 0xFFF;\n                newPst = (getPstTwo(pieceAtFromIndex) >> (0xC * toIndex)) & 0xFFF;\n            } else { // Piece is queen or king and in the further half\n                oldPst = (getPst(pieceAtFromIndex) >> (0xC * (fromIndex - 0x12))) & 0xFFF;\n                newPst = (getPst(pieceAtFromIndex) >> (0xC * (toIndex - 0x12))) & 0xFFF;\n            }\n\n            return int256(captureValue + newPst) - int256(oldPst);\n        }\n    }\n\n    /// @notice Maps a given piece type to its PST (see {Engine-evaluateMove} for details on the\n    /// PSTs and {Chess} for piece representation).\n    /// @dev The queen's and king's PSTs do not fit in 1 uint256, so their PSTs are split into 2\n    /// uint256s each. {Chess-getPst} contains the first half, and {Chess-getPstTwo} contains the\n    /// second half.\n    /// @param _type A piece type defined in {Chess}.\n    /// @return The PST corresponding to `_type`.\n    function getPst(uint256 _type) internal pure returns (uint256) {\n        if (_type == 1) return 0x2850A142850F1E3C78F1E2858C182C50A943468A152A788103C54A142850A14;\n        if (_type == 2) return 0x7D0204080FA042850A140810E24487020448912240810E1428701F40810203E;\n        if (_type == 3) return 0xC993264C9932E6CD9B365C793264C98F1E4C993263C793264C98F264CB97264;\n        if (_type == 4) return 0x6CE1B3670E9C3C8101E38750224480E9D4189120BA70F20C178E1B3874E9C36;\n        if (_type == 5) return 0xB00B20B30B30B20B00B20B40B40B40B40B20B30B40B50B50B40B3;\n        return 0xF9AF98F96F96F98F9AF9AF98F96F96F98F9AF9CF9AF98F98F9AF9B;\n    }\n\n    /// @notice Maps a queen or king to the second half of its PST (see {Engine-getPst}).\n    /// @param _type A piece type defined in {Chess}. Must be a queen or a king (see\n    /// {Engine-getPst}).\n    /// @return The PST corresponding to `_type`.\n    function getPstTwo(uint256 _type) internal pure returns (uint256) {\n        return _type == 5\n            ? 0xB30B50B50B50B40B30B20B40B50B40B40B20B00B20B30B30B20B0\n            : 0xF9EF9CF9CF9CF9CF9EFA1FA1FA0FA0FA1FA1FA4FA6FA2FA2FA6FA4;\n    }\n}\n"

    },

    "lib/solmate/src/tokens/ERC721.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*//////////////////////////////////////////////////////////////\n                         METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) internal _ownerOf;\n\n    mapping(address => uint256) internal _balanceOf;\n\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\n    }\n\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), \"ZERO_ADDRESS\");\n\n        return _balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            _balanceOf[from]--;\n\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n\n        require(owner != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            _balanceOf[owner]--;\n        }\n\n        delete _ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721TokenReceiver {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n"

    },

    "solidity/contracts/NeimannPlug.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.4 <0.9.0;\n\nimport {IChessOlympiads} from 'interfaces/IChessOlympiads.sol';\nimport {IButtPlug} from 'interfaces/IGame.sol';\nimport {Engine} from 'fiveoutofnine/Engine.sol';\nimport {ERC721} from 'solmate/tokens/ERC721.sol';\n\ncontract NeimannPlug is IButtPlug {\n    address constant CHESS_OLYMPIADS = 0x220d6F53444FB9205083E810344a3a3989527a34;\n    uint256 public immutable BADGE_ID;\n\n    uint256 depth = 7;\n    address public owner;\n    mapping(uint256 => uint256) knownMoves;\n\n    constructor(address _owner) {\n        owner = _owner;\n        BADGE_ID = _calcButtPlugBadge(address(this));\n    }\n\n    /**\n     * @notice Allows owner to set a move for a given board (hiding the given board)\n     * @param _boardKeccak Kecckak256 hash of the board representation\n     * @param _move Uint256 representation of the move\n     */\n    function setMove(uint256 _boardKeccak, uint256 _move) external onlyBadgeOwner {\n        knownMoves[_boardKeccak] = _move;\n    }\n\n    /**\n     * @notice Allows owner to set a batch of moves for a given board (hiding the given board)\n     * @param _boardKeccaks Kecckak256 hashes of the board representations\n     * @param _moves Uint256 representation of the moves\n     */\n    function setMoves(uint256[] memory _boardKeccaks, uint256[] memory _moves) external onlyBadgeOwner {\n        for (uint256 _i; _i < _boardKeccaks.length; _i++) {\n            knownMoves[_boardKeccaks[_i]] = _moves[_i];\n        }\n    }\n\n    /**\n     * @notice Allows owner to select the depth of the fallback method\n     * @param _depth Depth to search for the move in the fallback method\n     */\n    function setDepth(uint256 _depth) external onlyBadgeOwner {\n        depth = _depth;\n    }\n\n    /**\n     * @notice Method called by the Chess Olympiads contract to get the move for a given board\n     * @param _board Uint256 representation of the board\n     */\n    function readMove(uint256 _board) external view returns (uint256 _move) {\n        _move = knownMoves[uint256(keccak256(abi.encode(_board)))];\n        if (_move == 0) (_move,) = Engine.searchMove(_board, depth);\n    }\n\n    error OnlyOwner();\n\n    modifier onlyBadgeOwner() {\n        if (msg.sender != ERC721(CHESS_OLYMPIADS).ownerOf(BADGE_ID)) revert OnlyOwner();\n        _;\n    }\n\n    function _calcButtPlugBadge(address _buttPlug) internal pure returns (uint256 _badgeId) {\n        return (uint256(uint160(_buttPlug)) << 96) + 2;\n    }\n}\n"

    },

    "solidity/interfaces/IChessOlympiads.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\ninterface IChessOlympiads {\n    function mintPlayerBadge(uint256 _tokenId) external payable returns (uint256 _badgeId);\n    function mintButtPlugBadge(address _buttPlug) external returns (uint256 _badgeId);\n    function mintMedal(uint256[] memory _badgeIds) external returns (uint256 _badgeId);\n    function withdrawRewards(uint256 _badgeId) external;\n    function withdrawStakedNft(uint256 _badgeId) external;\n    function startEvent() external;\n    function pushLiquidity() external;\n    function unbondLiquidity() external;\n    function withdrawLiquidity() external;\n    function updateSpotPrice() external;\n    function workable() external view returns (bool _workable);\n    function executeMove() external;\n    function voteButtPlug(address _buttPlug, uint256 _badgeId) external;\n    function voteButtPlug(address _buttPlug, uint256[] memory _badgeIds) external;\n    function isWhitelistedToken(uint256 _id) external view returns (bool _isWhitelisted);\n}\n"

    },

    "solidity/interfaces/IGame.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\ninterface IButtPlug {\n    function readMove(uint256 _board) external view returns (uint256 _move);\n\n    function owner() external view returns (address _owner);\n}\n\ninterface IChess {\n    function mintMove(uint256 _move, uint256 _depth) external payable;\n\n    function board() external view returns (uint256 _board);\n}\n"

    }

  },

  "settings": {

    "remappings": [

      "@openzeppelin/=lib/openzeppelin-contracts/",

      "contracts/=solidity/contracts/",

      "ds-test/=lib/ds-test/src/",

      "fiveoutofnine/=lib/fiveoutofnine/src/",

      "forge-std/=lib/forge-std/src/",

      "interfaces/=solidity/interfaces/",

      "isolmate/=lib/isolmate/src/",

      "openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/",

      "prb-test/=lib/prb-test/src/",

      "prb/test/=lib/prb-test/src/",

      "solmate/=lib/solmate/src/",

      "test/=solidity/test/"

    ],

    "optimizer": {

      "enabled": true,

      "runs": 10000

    },

    "metadata": {

      "bytecodeHash": "ipfs"

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "evmVersion": "london",

    "libraries": {}

  }

}}