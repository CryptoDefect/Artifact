{{

  "language": "Solidity",

  "sources": {

    "contracts/interface/RocketStorageInterface.sol": {

      "content": "/**\r\n  *       .\r\n  *      / \\\r\n  *     |.'.|\r\n  *     |'.'|\r\n  *   ,'|   |`.\r\n  *  |,-'-|-'-.|\r\n  *   __|_| |         _        _      _____           _\r\n  *  | ___ \\|        | |      | |    | ___ \\         | |\r\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n  *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n  *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n  *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n  * +---------------------------------------------------+\r\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\r\n  * +---------------------------------------------------+\r\n  *\r\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\r\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\r\n  *\r\n  *  For more information about Rocket Pool, visit https://rocketpool.net\r\n  *\r\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\r\n  *\r\n  */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface RocketStorageInterface {\n\n    // Deploy status\n    function getDeployedStatus() external view returns (bool);\n\n    // Guardian\n    function getGuardian() external view returns(address);\n    function setGuardian(address _newAddress) external;\n    function confirmGuardian() external;\n\n    // Getters\n    function getAddress(bytes32 _key) external view returns (address);\n    function getUint(bytes32 _key) external view returns (uint);\n    function getString(bytes32 _key) external view returns (string memory);\n    function getBytes(bytes32 _key) external view returns (bytes memory);\n    function getBool(bytes32 _key) external view returns (bool);\n    function getInt(bytes32 _key) external view returns (int);\n    function getBytes32(bytes32 _key) external view returns (bytes32);\n\n    // Setters\n    function setAddress(bytes32 _key, address _value) external;\n    function setUint(bytes32 _key, uint _value) external;\n    function setString(bytes32 _key, string calldata _value) external;\n    function setBytes(bytes32 _key, bytes calldata _value) external;\n    function setBool(bytes32 _key, bool _value) external;\n    function setInt(bytes32 _key, int _value) external;\n    function setBytes32(bytes32 _key, bytes32 _value) external;\n\n    // Deleters\n    function deleteAddress(bytes32 _key) external;\n    function deleteUint(bytes32 _key) external;\n    function deleteString(bytes32 _key) external;\n    function deleteBytes(bytes32 _key) external;\n    function deleteBool(bytes32 _key) external;\n    function deleteInt(bytes32 _key) external;\n    function deleteBytes32(bytes32 _key) external;\n\n    // Arithmetic\n    function addUint(bytes32 _key, uint256 _amount) external;\n    function subUint(bytes32 _key, uint256 _amount) external;\n\n    // Protected storage\n    function getNodeWithdrawalAddress(address _nodeAddress) external view returns (address);\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external view returns (address);\n    function setWithdrawalAddress(address _nodeAddress, address _newWithdrawalAddress, bool _confirm) external;\n    function confirmWithdrawalAddress(address _nodeAddress) external;\n}\n"

    },

    "contracts/contract/RocketBase.sol": {

      "content": "/**\r\n  *       .\r\n  *      / \\\r\n  *     |.'.|\r\n  *     |'.'|\r\n  *   ,'|   |`.\r\n  *  |,-'-|-'-.|\r\n  *   __|_| |         _        _      _____           _\r\n  *  | ___ \\|        | |      | |    | ___ \\         | |\r\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n  *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n  *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n  *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n  * +---------------------------------------------------+\r\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\r\n  * +---------------------------------------------------+\r\n  *\r\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\r\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\r\n  *\r\n  *  For more information about Rocket Pool, visit https://rocketpool.net\r\n  *\r\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\r\n  *\r\n  */\r\n\r\npragma solidity 0.7.6;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"../interface/RocketStorageInterface.sol\";\n\n/// @title Base settings / modifiers for each contract in Rocket Pool\n/// @author David Rugendyke\n\nabstract contract RocketBase {\n\n    // Calculate using this as the base\n    uint256 constant calcBase = 1 ether;\n\n    // Version of the contract\n    uint8 public version;\n\n    // The main storage contract where primary persistant storage is maintained\n    RocketStorageInterface rocketStorage = RocketStorageInterface(0);\n\n\n    /*** Modifiers **********************************************************/\n\n    /**\n    * @dev Throws if called by any sender that doesn't match a Rocket Pool network contract\n    */\n    modifier onlyLatestNetworkContract() {\n        require(getBool(keccak256(abi.encodePacked(\"contract.exists\", msg.sender))), \"Invalid or outdated network contract\");\n        _;\n    }\n\n    /**\n    * @dev Throws if called by any sender that doesn't match one of the supplied contract or is the latest version of that contract\n    */\n    modifier onlyLatestContract(string memory _contractName, address _contractAddress) {\n        require(_contractAddress == getAddress(keccak256(abi.encodePacked(\"contract.address\", _contractName))), \"Invalid or outdated contract\");\n        _;\n    }\n\n    /**\n    * @dev Throws if called by any sender that isn't a registered node\n    */\n    modifier onlyRegisteredNode(address _nodeAddress) {\n        require(getBool(keccak256(abi.encodePacked(\"node.exists\", _nodeAddress))), \"Invalid node\");\n        _;\n    }\n\n    /**\n    * @dev Throws if called by any sender that isn't a trusted node DAO member\n    */\n    modifier onlyTrustedNode(address _nodeAddress) {\n        require(getBool(keccak256(abi.encodePacked(\"dao.trustednodes.\", \"member\", _nodeAddress))), \"Invalid trusted node\");\n        _;\n    }\n\n    /**\n    * @dev Throws if called by any sender that isn't a registered minipool\n    */\n    modifier onlyRegisteredMinipool(address _minipoolAddress) {\n        require(getBool(keccak256(abi.encodePacked(\"minipool.exists\", _minipoolAddress))), \"Invalid minipool\");\n        _;\n    }\n    \n\n    /**\n    * @dev Throws if called by any account other than a guardian account (temporary account allowed access to settings before DAO is fully enabled)\n    */\n    modifier onlyGuardian() {\n        require(msg.sender == rocketStorage.getGuardian(), \"Account is not a temporary guardian\");\n        _;\n    }\n\n\n\n\n    /*** Methods **********************************************************/\n\n    /// @dev Set the main Rocket Storage address\n    constructor(RocketStorageInterface _rocketStorageAddress) {\n        // Update the contract address\n        rocketStorage = RocketStorageInterface(_rocketStorageAddress);\n    }\n\n\n    /// @dev Get the address of a network contract by name\n    function getContractAddress(string memory _contractName) internal view returns (address) {\n        // Get the current contract address\n        address contractAddress = getAddress(keccak256(abi.encodePacked(\"contract.address\", _contractName)));\n        // Check it\n        require(contractAddress != address(0x0), \"Contract not found\");\n        // Return\n        return contractAddress;\n    }\n\n\n    /// @dev Get the address of a network contract by name (returns address(0x0) instead of reverting if contract does not exist)\n    function getContractAddressUnsafe(string memory _contractName) internal view returns (address) {\n        // Get the current contract address\n        address contractAddress = getAddress(keccak256(abi.encodePacked(\"contract.address\", _contractName)));\n        // Return\n        return contractAddress;\n    }\n\n\n    /// @dev Get the name of a network contract by address\n    function getContractName(address _contractAddress) internal view returns (string memory) {\n        // Get the contract name\n        string memory contractName = getString(keccak256(abi.encodePacked(\"contract.name\", _contractAddress)));\n        // Check it\n        require(bytes(contractName).length > 0, \"Contract not found\");\n        // Return\n        return contractName;\n    }\n\n    /// @dev Get revert error message from a .call method\n    function getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_returnData.length < 68) return \"Transaction reverted silently\";\n        assembly {\n            // Slice the sighash.\n            _returnData := add(_returnData, 0x04)\n        }\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\n    }\n\n\n\n    /*** Rocket Storage Methods ****************************************/\n\n    // Note: Unused helpers have been removed to keep contract sizes down\n\n    /// @dev Storage get methods\n    function getAddress(bytes32 _key) internal view returns (address) { return rocketStorage.getAddress(_key); }\n    function getUint(bytes32 _key) internal view returns (uint) { return rocketStorage.getUint(_key); }\n    function getString(bytes32 _key) internal view returns (string memory) { return rocketStorage.getString(_key); }\n    function getBytes(bytes32 _key) internal view returns (bytes memory) { return rocketStorage.getBytes(_key); }\n    function getBool(bytes32 _key) internal view returns (bool) { return rocketStorage.getBool(_key); }\n    function getInt(bytes32 _key) internal view returns (int) { return rocketStorage.getInt(_key); }\n    function getBytes32(bytes32 _key) internal view returns (bytes32) { return rocketStorage.getBytes32(_key); }\n\n    /// @dev Storage set methods\n    function setAddress(bytes32 _key, address _value) internal { rocketStorage.setAddress(_key, _value); }\n    function setUint(bytes32 _key, uint _value) internal { rocketStorage.setUint(_key, _value); }\n    function setString(bytes32 _key, string memory _value) internal { rocketStorage.setString(_key, _value); }\n    function setBytes(bytes32 _key, bytes memory _value) internal { rocketStorage.setBytes(_key, _value); }\n    function setBool(bytes32 _key, bool _value) internal { rocketStorage.setBool(_key, _value); }\n    function setInt(bytes32 _key, int _value) internal { rocketStorage.setInt(_key, _value); }\n    function setBytes32(bytes32 _key, bytes32 _value) internal { rocketStorage.setBytes32(_key, _value); }\n\n    /// @dev Storage delete methods\n    function deleteAddress(bytes32 _key) internal { rocketStorage.deleteAddress(_key); }\n    function deleteUint(bytes32 _key) internal { rocketStorage.deleteUint(_key); }\n    function deleteString(bytes32 _key) internal { rocketStorage.deleteString(_key); }\n    function deleteBytes(bytes32 _key) internal { rocketStorage.deleteBytes(_key); }\n    function deleteBool(bytes32 _key) internal { rocketStorage.deleteBool(_key); }\n    function deleteInt(bytes32 _key) internal { rocketStorage.deleteInt(_key); }\n    function deleteBytes32(bytes32 _key) internal { rocketStorage.deleteBytes32(_key); }\n\n    /// @dev Storage arithmetic methods\n    function addUint(bytes32 _key, uint256 _amount) internal { rocketStorage.addUint(_key, _amount); }\n    function subUint(bytes32 _key, uint256 _amount) internal { rocketStorage.subUint(_key, _amount); }\n}\n"

    },

    "@openzeppelin/contracts/math/SafeMath.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"

    },

    "contracts/types/MinipoolDeposit.sol": {

      "content": "/**\r\n  *       .\r\n  *      / \\\r\n  *     |.'.|\r\n  *     |'.'|\r\n  *   ,'|   |`.\r\n  *  |,-'-|-'-.|\r\n  *   __|_| |         _        _      _____           _\r\n  *  | ___ \\|        | |      | |    | ___ \\         | |\r\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n  *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n  *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n  *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n  * +---------------------------------------------------+\r\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\r\n  * +---------------------------------------------------+\r\n  *\r\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\r\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\r\n  *\r\n  *  For more information about Rocket Pool, visit https://rocketpool.net\r\n  *\r\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\r\n  *\r\n  */\r\n\r\npragma solidity 0.7.6;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\n// Represents the type of deposits required by a minipool\n\nenum MinipoolDeposit {\n    None,       // Marks an invalid deposit type\n    Full,       // The minipool requires 32 ETH from the node operator, 16 ETH of which will be refinanced from user deposits\n    Half,       // The minipool required 16 ETH from the node operator to be matched with 16 ETH from user deposits\n    Empty,      // The minipool requires 0 ETH from the node operator to be matched with 32 ETH from user deposits (trusted nodes only)\n    Variable    // Indicates this minipool is of the new generation that supports a variable deposit amount\n}\n"

    },

    "contracts/types/MinipoolStatus.sol": {

      "content": "/**\r\n  *       .\r\n  *      / \\\r\n  *     |.'.|\r\n  *     |'.'|\r\n  *   ,'|   |`.\r\n  *  |,-'-|-'-.|\r\n  *   __|_| |         _        _      _____           _\r\n  *  | ___ \\|        | |      | |    | ___ \\         | |\r\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n  *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n  *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n  *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n  * +---------------------------------------------------+\r\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\r\n  * +---------------------------------------------------+\r\n  *\r\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\r\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\r\n  *\r\n  *  For more information about Rocket Pool, visit https://rocketpool.net\r\n  *\r\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\r\n  *\r\n  */\r\n\r\npragma solidity 0.7.6;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\n// Represents a minipool's status within the network\n\nenum MinipoolStatus {\n    Initialised,    // The minipool has been initialised and is awaiting a deposit of user ETH\n    Prelaunch,      // The minipool has enough ETH to begin staking and is awaiting launch by the node operator\n    Staking,        // The minipool is currently staking\n    Withdrawable,   // NO LONGER USED\n    Dissolved       // The minipool has been dissolved and its user deposited ETH has been returned to the deposit pool\n}\n"

    },

    "contracts/contract/minipool/RocketMinipoolStorageLayout.sol": {

      "content": "/**\r\n  *       .\r\n  *      / \\\r\n  *     |.'.|\r\n  *     |'.'|\r\n  *   ,'|   |`.\r\n  *  |,-'-|-'-.|\r\n  *   __|_| |         _        _      _____           _\r\n  *  | ___ \\|        | |      | |    | ___ \\         | |\r\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n  *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n  *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n  *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n  * +---------------------------------------------------+\r\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\r\n  * +---------------------------------------------------+\r\n  *\r\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\r\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\r\n  *\r\n  *  For more information about Rocket Pool, visit https://rocketpool.net\r\n  *\r\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\r\n  *\r\n  */\r\n\r\npragma solidity 0.7.6;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"../../interface/RocketStorageInterface.sol\";\nimport \"../../types/MinipoolDeposit.sol\";\nimport \"../../types/MinipoolStatus.sol\";\n\n// The RocketMinipool contract storage layout, shared by RocketMinipoolDelegate\n\n// ******************************************************\n// Note: This contract MUST NOT BE UPDATED after launch.\n// All deployed minipool contracts must maintain a\n// Consistent storage layout with RocketMinipoolDelegate.\n// ******************************************************\n\nabstract contract RocketMinipoolStorageLayout {\n    // Storage state enum\n    enum StorageState {\n        Undefined,\n        Uninitialised,\n        Initialised\n    }\n\n\t// Main Rocket Pool storage contract\n    RocketStorageInterface internal rocketStorage = RocketStorageInterface(0);\n\n    // Status\n    MinipoolStatus internal status;\n    uint256 internal statusBlock;\n    uint256 internal statusTime;\n    uint256 internal withdrawalBlock;\n\n    // Deposit type\n    MinipoolDeposit internal depositType;\n\n    // Node details\n    address internal nodeAddress;\n    uint256 internal nodeFee;\n    uint256 internal nodeDepositBalance;\n    bool internal nodeDepositAssigned;          // NO LONGER IN USE\n    uint256 internal nodeRefundBalance;\n    uint256 internal nodeSlashBalance;\n\n    // User deposit details\n    uint256 internal userDepositBalanceLegacy;\n    uint256 internal userDepositAssignedTime;\n\n    // Upgrade options\n    bool internal useLatestDelegate = false;\n    address internal rocketMinipoolDelegate;\n    address internal rocketMinipoolDelegatePrev;\n\n    // Local copy of RETH address\n    address internal rocketTokenRETH;\n\n    // Local copy of penalty contract\n    address internal rocketMinipoolPenalty;\n\n    // Used to prevent direct access to delegate and prevent calling initialise more than once\n    StorageState internal storageState = StorageState.Undefined;\n\n    // Whether node operator has finalised the pool\n    bool internal finalised;\n\n    // Trusted member scrub votes\n    mapping(address => bool) internal memberScrubVotes;\n    uint256 internal totalScrubVotes;\n\n    // Variable minipool\n    uint256 internal preLaunchValue;\n    uint256 internal userDepositBalance;\n\n    // Vacant minipool\n    bool internal vacant;\n    uint256 internal preMigrationBalance;\n\n    // User distribution\n    bool internal userDistributed;\n    uint256 internal userDistributeTime;\n}\n"

    },

    "contracts/interface/minipool/RocketMinipoolBaseInterface.sol": {

      "content": "/**\r\n  *       .\r\n  *      / \\\r\n  *     |.'.|\r\n  *     |'.'|\r\n  *   ,'|   |`.\r\n  *  |,-'-|-'-.|\r\n  *   __|_| |         _        _      _____           _\r\n  *  | ___ \\|        | |      | |    | ___ \\         | |\r\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n  *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n  *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n  *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n  * +---------------------------------------------------+\r\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\r\n  * +---------------------------------------------------+\r\n  *\r\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\r\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\r\n  *\r\n  *  For more information about Rocket Pool, visit https://rocketpool.net\r\n  *\r\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\r\n  *\r\n  */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface RocketMinipoolBaseInterface {\n    function initialise(address _rocketStorage, address _nodeAddress) external;\n    function delegateUpgrade() external;\n    function delegateRollback() external;\n    function setUseLatestDelegate(bool _setting) external;\n    function getUseLatestDelegate() external view returns (bool);\n    function getDelegate() external view returns (address);\n    function getPreviousDelegate() external view returns (address);\n    function getEffectiveDelegate() external view returns (address);\n}\n"

    },

    "contracts/contract/minipool/RocketMinipoolBase.sol": {

      "content": "/**\r\n  *       .\r\n  *      / \\\r\n  *     |.'.|\r\n  *     |'.'|\r\n  *   ,'|   |`.\r\n  *  |,-'-|-'-.|\r\n  *   __|_| |         _        _      _____           _\r\n  *  | ___ \\|        | |      | |    | ___ \\         | |\r\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n  *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n  *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n  *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n  * +---------------------------------------------------+\r\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\r\n  * +---------------------------------------------------+\r\n  *\r\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\r\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\r\n  *\r\n  *  For more information about Rocket Pool, visit https://rocketpool.net\r\n  *\r\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\r\n  *\r\n  */\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.7.6;\n\nimport \"./RocketMinipoolStorageLayout.sol\";\nimport \"../../interface/RocketStorageInterface.sol\";\nimport \"../../interface/minipool/RocketMinipoolBaseInterface.sol\";\n\n/// @notice Contains the initialisation and delegate upgrade logic for minipools\ncontract RocketMinipoolBase is RocketMinipoolBaseInterface, RocketMinipoolStorageLayout {\n\n    // Events\n    event EtherReceived(address indexed from, uint256 amount, uint256 time);\n    event DelegateUpgraded(address oldDelegate, address newDelegate, uint256 time);\n    event DelegateRolledBack(address oldDelegate, address newDelegate, uint256 time);\n\n    // Store a reference to the address of RocketMinipoolBase itself to prevent direct calls to this contract\n    address immutable self;\n\n    constructor () {\n        self = address(this);\n    }\n\n    /// @dev Prevent direct calls to this contract\n    modifier notSelf() {\n        require(address(this) != self);\n        _;\n    }\n\n    /// @dev Only allow access from the owning node address\n    modifier onlyMinipoolOwner() {\n        // Only the node operator can upgrade\n        address withdrawalAddress = rocketStorage.getNodeWithdrawalAddress(nodeAddress);\n        require(msg.sender == nodeAddress || msg.sender == withdrawalAddress, \"Only the node operator can access this method\");\n        _;\n    }\n\n    /// @notice Sets up starting delegate contract and then delegates initialisation to it\n    function initialise(address _rocketStorage, address _nodeAddress) external override notSelf {\n        // Check input\n        require(_nodeAddress != address(0), \"Invalid node address\");\n        require(storageState == StorageState.Undefined, \"Already initialised\");\n        // Set storage state to uninitialised\n        storageState = StorageState.Uninitialised;\n        // Set rocketStorage\n        rocketStorage = RocketStorageInterface(_rocketStorage);\n        // Set the current delegate\n        address delegateAddress = getContractAddress(\"rocketMinipoolDelegate\");\n        rocketMinipoolDelegate = delegateAddress;\n        // Check for contract existence\n        require(contractExists(delegateAddress), \"Delegate contract does not exist\");\n        // Call initialise on delegate\n        (bool success, bytes memory data) = delegateAddress.delegatecall(abi.encodeWithSignature('initialise(address)', _nodeAddress));\n        if (!success) { revert(getRevertMessage(data)); }\n    }\n\n    /// @notice Receive an ETH deposit\n    receive() external payable notSelf {\n        // Emit ether received event\n        emit EtherReceived(msg.sender, msg.value, block.timestamp);\n    }\n\n    /// @notice Upgrade this minipool to the latest network delegate contract\n    function delegateUpgrade() external override onlyMinipoolOwner notSelf {\n        // Set previous address\n        rocketMinipoolDelegatePrev = rocketMinipoolDelegate;\n        // Set new delegate\n        rocketMinipoolDelegate = getContractAddress(\"rocketMinipoolDelegate\");\n        // Verify\n        require(rocketMinipoolDelegate != rocketMinipoolDelegatePrev, \"New delegate is the same as the existing one\");\n        // Log event\n        emit DelegateUpgraded(rocketMinipoolDelegatePrev, rocketMinipoolDelegate, block.timestamp);\n    }\n\n    /// @notice Rollback to previous delegate contract\n    function delegateRollback() external override onlyMinipoolOwner notSelf {\n        // Make sure they have upgraded before\n        require(rocketMinipoolDelegatePrev != address(0x0), \"Previous delegate contract is not set\");\n        // Store original\n        address originalDelegate = rocketMinipoolDelegate;\n        // Update delegate to previous and zero out previous\n        rocketMinipoolDelegate = rocketMinipoolDelegatePrev;\n        rocketMinipoolDelegatePrev = address(0x0);\n        // Log event\n        emit DelegateRolledBack(originalDelegate, rocketMinipoolDelegate, block.timestamp);\n    }\n\n    /// @notice Sets the flag to automatically use the latest delegate contract or not\n    /// @param _setting If true, will always use the latest delegate contract\n    function setUseLatestDelegate(bool _setting) external override onlyMinipoolOwner notSelf {\n        useLatestDelegate = _setting;\n    }\n\n    /// @notice Returns true if this minipool always uses the latest delegate contract\n    function getUseLatestDelegate() external override view returns (bool) {\n        return useLatestDelegate;\n    }\n\n    /// @notice Returns the address of the minipool's stored delegate\n    function getDelegate() external override view returns (address) {\n        return rocketMinipoolDelegate;\n    }\n\n    /// @notice Returns the address of the minipool's previous delegate (or address(0) if not set)\n    function getPreviousDelegate() external override view returns (address) {\n        return rocketMinipoolDelegatePrev;\n    }\n\n    /// @notice Returns the delegate which will be used when calling this minipool taking into account useLatestDelegate setting\n    function getEffectiveDelegate() external override view returns (address) {\n        return useLatestDelegate ? getContractAddress(\"rocketMinipoolDelegate\") : rocketMinipoolDelegate;\n    }\n\n    /// @notice Delegates all calls to minipool delegate contract (or latest if flag is set)\n    fallback(bytes calldata _input) external payable notSelf returns (bytes memory) {\n        // If useLatestDelegate is set, use the latest delegate contract\n        address delegateContract = useLatestDelegate ? getContractAddress(\"rocketMinipoolDelegate\") : rocketMinipoolDelegate;\n        // Check for contract existence\n        require(contractExists(delegateContract), \"Delegate contract does not exist\");\n        // Execute delegatecall\n        (bool success, bytes memory data) = delegateContract.delegatecall(_input);\n        if (!success) { revert(getRevertMessage(data)); }\n        return data;\n    }\n\n    /// @dev Get the address of a Rocket Pool network contract\n    function getContractAddress(string memory _contractName) private view returns (address) {\n        address contractAddress = rocketStorage.getAddress(keccak256(abi.encodePacked(\"contract.address\", _contractName)));\n        require(contractAddress != address(0x0), \"Contract not found\");\n        return contractAddress;\n    }\n\n    /// @dev Get a revert message from delegatecall return data\n    function getRevertMessage(bytes memory _returnData) private pure returns (string memory) {\n        if (_returnData.length < 68) { return \"Transaction reverted silently\"; }\n        assembly {\n            _returnData := add(_returnData, 0x04)\n        }\n        return abi.decode(_returnData, (string));\n    }\n\n    /// @dev Returns true if contract exists at _contractAddress (if called during that contract's construction it will return a false negative)\n    function contractExists(address _contractAddress) private view returns (bool) {\n        uint32 codeSize;\n        assembly {\n            codeSize := extcodesize(_contractAddress)\n        }\n        return codeSize > 0;\n    }\n}\n"

    },

    "contracts/types/MinipoolDetails.sol": {

      "content": "/**\r\n  *       .\r\n  *      / \\\r\n  *     |.'.|\r\n  *     |'.'|\r\n  *   ,'|   |`.\r\n  *  |,-'-|-'-.|\r\n  *   __|_| |         _        _      _____           _\r\n  *  | ___ \\|        | |      | |    | ___ \\         | |\r\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n  *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n  *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n  *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n  * +---------------------------------------------------+\r\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\r\n  * +---------------------------------------------------+\r\n  *\r\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\r\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\r\n  *\r\n  *  For more information about Rocket Pool, visit https://rocketpool.net\r\n  *\r\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\r\n  *\r\n  */\r\n\r\npragma solidity 0.7.6;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"./MinipoolDeposit.sol\";\nimport \"./MinipoolStatus.sol\";\n\n// A struct containing all the information on-chain about a specific minipool\n\nstruct MinipoolDetails {\n    bool exists;\n    address minipoolAddress;\n    bytes pubkey;\n    MinipoolStatus status;\n    uint256 statusBlock;\n    uint256 statusTime;\n    bool finalised;\n    MinipoolDeposit depositType;\n    uint256 nodeFee;\n    uint256 nodeDepositBalance;\n    bool nodeDepositAssigned;\n    uint256 userDepositBalance;\n    bool userDepositAssigned;\n    uint256 userDepositAssignedTime;\n    bool useLatestDelegate;\n    address delegate;\n    address previousDelegate;\n    address effectiveDelegate;\n    uint256 penaltyCount;\n    uint256 penaltyRate;\n    address nodeAddress;\n}\n"

    },

    "contracts/interface/dao/node/RocketDAONodeTrustedInterface.sol": {

      "content": "/**\r\n  *       .\r\n  *      / \\\r\n  *     |.'.|\r\n  *     |'.'|\r\n  *   ,'|   |`.\r\n  *  |,-'-|-'-.|\r\n  *   __|_| |         _        _      _____           _\r\n  *  | ___ \\|        | |      | |    | ___ \\         | |\r\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n  *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n  *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n  *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n  * +---------------------------------------------------+\r\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\r\n  * +---------------------------------------------------+\r\n  *\r\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\r\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\r\n  *\r\n  *  For more information about Rocket Pool, visit https://rocketpool.net\r\n  *\r\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\r\n  *\r\n  */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface RocketDAONodeTrustedInterface {\n    function getBootstrapModeDisabled() external view returns (bool);\n    function getMemberQuorumVotesRequired() external view returns (uint256);\n    function getMemberAt(uint256 _index) external view returns (address);\n    function getMemberCount() external view returns (uint256);\n    function getMemberMinRequired() external view returns (uint256);\n    function getMemberIsValid(address _nodeAddress) external view returns (bool);\n    function getMemberLastProposalTime(address _nodeAddress) external view returns (uint256);\n    function getMemberID(address _nodeAddress) external view returns (string memory);\n    function getMemberUrl(address _nodeAddress) external view returns (string memory);\n    function getMemberJoinedTime(address _nodeAddress) external view returns (uint256);\n    function getMemberProposalExecutedTime(string memory _proposalType, address _nodeAddress) external view returns (uint256);\n    function getMemberRPLBondAmount(address _nodeAddress) external view returns (uint256);\n    function getMemberIsChallenged(address _nodeAddress) external view returns (bool);\n    function getMemberUnbondedValidatorCount(address _nodeAddress) external view returns (uint256);\n    function incrementMemberUnbondedValidatorCount(address _nodeAddress) external;\n    function decrementMemberUnbondedValidatorCount(address _nodeAddress) external;\n    function bootstrapMember(string memory _id, string memory _url, address _nodeAddress) external;\n    function bootstrapSettingUint(string memory _settingContractName, string memory _settingPath, uint256 _value) external;\n    function bootstrapSettingBool(string memory _settingContractName, string memory _settingPath, bool _value) external;\n    function bootstrapUpgrade(string memory _type, string memory _name, string memory _contractAbi, address _contractAddress) external;\n    function bootstrapDisable(bool _confirmDisableBootstrapMode) external;\n    function memberJoinRequired(string memory _id, string memory _url) external;\n}\n"

    },

    "contracts/interface/minipool/RocketMinipoolInterface.sol": {

      "content": "/**\r\n  *       .\r\n  *      / \\\r\n  *     |.'.|\r\n  *     |'.'|\r\n  *   ,'|   |`.\r\n  *  |,-'-|-'-.|\r\n  *   __|_| |         _        _      _____           _\r\n  *  | ___ \\|        | |      | |    | ___ \\         | |\r\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n  *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n  *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n  *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n  * +---------------------------------------------------+\r\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\r\n  * +---------------------------------------------------+\r\n  *\r\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\r\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\r\n  *\r\n  *  For more information about Rocket Pool, visit https://rocketpool.net\r\n  *\r\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\r\n  *\r\n  */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"../../types/MinipoolDeposit.sol\";\nimport \"../../types/MinipoolStatus.sol\";\nimport \"../RocketStorageInterface.sol\";\n\ninterface RocketMinipoolInterface {\n    function version() external view returns (uint8);\n    function initialise(address _nodeAddress) external;\n    function getStatus() external view returns (MinipoolStatus);\n    function getFinalised() external view returns (bool);\n    function getStatusBlock() external view returns (uint256);\n    function getStatusTime() external view returns (uint256);\n    function getScrubVoted(address _member) external view returns (bool);\n    function getDepositType() external view returns (MinipoolDeposit);\n    function getNodeAddress() external view returns (address);\n    function getNodeFee() external view returns (uint256);\n    function getNodeDepositBalance() external view returns (uint256);\n    function getNodeRefundBalance() external view returns (uint256);\n    function getNodeDepositAssigned() external view returns (bool);\n    function getPreLaunchValue() external view returns (uint256);\n    function getNodeTopUpValue() external view returns (uint256);\n    function getVacant() external view returns (bool);\n    function getPreMigrationBalance() external view returns (uint256);\n    function getUserDistributed() external view returns (bool);\n    function getUserDepositBalance() external view returns (uint256);\n    function getUserDepositAssigned() external view returns (bool);\n    function getUserDepositAssignedTime() external view returns (uint256);\n    function getTotalScrubVotes() external view returns (uint256);\n    function calculateNodeShare(uint256 _balance) external view returns (uint256);\n    function calculateUserShare(uint256 _balance) external view returns (uint256);\n    function preDeposit(uint256 _bondingValue, bytes calldata _validatorPubkey, bytes calldata _validatorSignature, bytes32 _depositDataRoot) external payable;\n    function deposit() external payable;\n    function userDeposit() external payable;\n    function distributeBalance(bool _rewardsOnly) external;\n    function beginUserDistribute() external;\n    function userDistributeAllowed() external view returns (bool);\n    function refund() external;\n    function slash() external;\n    function finalise() external;\n    function canStake() external view returns (bool);\n    function canPromote() external view returns (bool);\n    function stake(bytes calldata _validatorSignature, bytes32 _depositDataRoot) external;\n    function prepareVacancy(uint256 _bondAmount, uint256 _currentBalance) external;\n    function promote() external;\n    function dissolve() external;\n    function close() external;\n    function voteScrub() external;\n    function reduceBondAmount() external;\n}\n"

    },

    "contracts/interface/minipool/RocketMinipoolManagerInterface.sol": {

      "content": "/**\r\n  *       .\r\n  *      / \\\r\n  *     |.'.|\r\n  *     |'.'|\r\n  *   ,'|   |`.\r\n  *  |,-'-|-'-.|\r\n  *   __|_| |         _        _      _____           _\r\n  *  | ___ \\|        | |      | |    | ___ \\         | |\r\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n  *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n  *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n  *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n  * +---------------------------------------------------+\r\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\r\n  * +---------------------------------------------------+\r\n  *\r\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\r\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\r\n  *\r\n  *  For more information about Rocket Pool, visit https://rocketpool.net\r\n  *\r\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\r\n  *\r\n  */\r\n\r\npragma solidity >0.5.0 <0.9.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"../../types/MinipoolDeposit.sol\";\nimport \"../../types/MinipoolDetails.sol\";\nimport \"./RocketMinipoolInterface.sol\";\n\ninterface RocketMinipoolManagerInterface {\n    function getMinipoolCount() external view returns (uint256);\n    function getStakingMinipoolCount() external view returns (uint256);\n    function getFinalisedMinipoolCount() external view returns (uint256);\n    function getActiveMinipoolCount() external view returns (uint256);\n    function getMinipoolRPLSlashed(address _minipoolAddress) external view returns (bool);\n    function getMinipoolCountPerStatus(uint256 offset, uint256 limit) external view returns (uint256, uint256, uint256, uint256, uint256);\n    function getPrelaunchMinipools(uint256 offset, uint256 limit) external view returns (address[] memory);\n    function getMinipoolAt(uint256 _index) external view returns (address);\n    function getNodeMinipoolCount(address _nodeAddress) external view returns (uint256);\n    function getNodeActiveMinipoolCount(address _nodeAddress) external view returns (uint256);\n    function getNodeFinalisedMinipoolCount(address _nodeAddress) external view returns (uint256);\n    function getNodeStakingMinipoolCount(address _nodeAddress) external view returns (uint256);\n    function getNodeStakingMinipoolCountBySize(address _nodeAddress, uint256 _depositSize) external view returns (uint256);\n    function getNodeMinipoolAt(address _nodeAddress, uint256 _index) external view returns (address);\n    function getNodeValidatingMinipoolCount(address _nodeAddress) external view returns (uint256);\n    function getNodeValidatingMinipoolAt(address _nodeAddress, uint256 _index) external view returns (address);\n    function getMinipoolByPubkey(bytes calldata _pubkey) external view returns (address);\n    function getMinipoolExists(address _minipoolAddress) external view returns (bool);\n    function getMinipoolDestroyed(address _minipoolAddress) external view returns (bool);\n    function getMinipoolPubkey(address _minipoolAddress) external view returns (bytes memory);\n    function updateNodeStakingMinipoolCount(uint256 _previousBond, uint256 _newBond, uint256 _previousFee, uint256 _newFee) external;\n    function getMinipoolWithdrawalCredentials(address _minipoolAddress) external pure returns (bytes memory);\n    function createMinipool(address _nodeAddress, uint256 _salt) external returns (RocketMinipoolInterface);\n    function createVacantMinipool(address _nodeAddress, uint256 _salt, bytes calldata _validatorPubkey, uint256 _bondAmount, uint256 _currentBalance) external returns (RocketMinipoolInterface);\n    function removeVacantMinipool() external;\n    function getVacantMinipoolCount() external view returns (uint256);\n    function getVacantMinipoolAt(uint256 _index) external view returns (address);\n    function destroyMinipool() external;\n    function incrementNodeStakingMinipoolCount(address _nodeAddress) external;\n    function decrementNodeStakingMinipoolCount(address _nodeAddress) external;\n    function incrementNodeFinalisedMinipoolCount(address _nodeAddress) external;\n    function setMinipoolPubkey(bytes calldata _pubkey) external;\n    function getMinipoolDepositType(address _minipoolAddress) external view returns (MinipoolDeposit);\n}\n"

    },

    "contracts/interface/node/RocketNodeStakingInterface.sol": {

      "content": "/**\r\n  *       .\r\n  *      / \\\r\n  *     |.'.|\r\n  *     |'.'|\r\n  *   ,'|   |`.\r\n  *  |,-'-|-'-.|\r\n  *   __|_| |         _        _      _____           _\r\n  *  | ___ \\|        | |      | |    | ___ \\         | |\r\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n  *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n  *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n  *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n  * +---------------------------------------------------+\r\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\r\n  * +---------------------------------------------------+\r\n  *\r\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\r\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\r\n  *\r\n  *  For more information about Rocket Pool, visit https://rocketpool.net\r\n  *\r\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\r\n  *\r\n  */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface RocketNodeStakingInterface {\n    function getTotalRPLStake() external view returns (uint256);\n    function getNodeRPLStake(address _nodeAddress) external view returns (uint256);\n    function getNodeETHMatched(address _nodeAddress) external view returns (uint256);\n    function getNodeETHProvided(address _nodeAddress) external view returns (uint256);\n    function getNodeETHCollateralisationRatio(address _nodeAddress) external view returns (uint256);\n    function getNodeRPLStakedTime(address _nodeAddress) external view returns (uint256);\n    function getNodeEffectiveRPLStake(address _nodeAddress) external view returns (uint256);\n    function getNodeMinimumRPLStake(address _nodeAddress) external view returns (uint256);\n    function getNodeMaximumRPLStake(address _nodeAddress) external view returns (uint256);\n    function getNodeETHMatchedLimit(address _nodeAddress) external view returns (uint256);\n    function stakeRPL(uint256 _amount) external;\n    function stakeRPLFor(address _nodeAddress, uint256 _amount) external;\n    function setStakeRPLForAllowed(address _caller, bool _allowed) external;\n    function withdrawRPL(uint256 _amount) external;\n    function slashRPL(address _nodeAddress, uint256 _ethSlashAmount) external;\n}\n"

    },

    "contracts/interface/util/AddressSetStorageInterface.sol": {

      "content": "/**\r\n  *       .\r\n  *      / \\\r\n  *     |.'.|\r\n  *     |'.'|\r\n  *   ,'|   |`.\r\n  *  |,-'-|-'-.|\r\n  *   __|_| |         _        _      _____           _\r\n  *  | ___ \\|        | |      | |    | ___ \\         | |\r\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n  *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n  *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n  *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n  * +---------------------------------------------------+\r\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\r\n  * +---------------------------------------------------+\r\n  *\r\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\r\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\r\n  *\r\n  *  For more information about Rocket Pool, visit https://rocketpool.net\r\n  *\r\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\r\n  *\r\n  */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface AddressSetStorageInterface {\n    function getCount(bytes32 _key) external view returns (uint);\n    function getItem(bytes32 _key, uint _index) external view returns (address);\n    function getIndexOf(bytes32 _key, address _value) external view returns (int);\n    function addItem(bytes32 _key, address _value) external;\n    function removeItem(bytes32 _key, address _value) external;\n}\n"

    },

    "contracts/types/NodeDetails.sol": {

      "content": "/**\r\n  *       .\r\n  *      / \\\r\n  *     |.'.|\r\n  *     |'.'|\r\n  *   ,'|   |`.\r\n  *  |,-'-|-'-.|\r\n  *   __|_| |         _        _      _____           _\r\n  *  | ___ \\|        | |      | |    | ___ \\         | |\r\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n  *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n  *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n  *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n  * +---------------------------------------------------+\r\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\r\n  * +---------------------------------------------------+\r\n  *\r\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\r\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\r\n  *\r\n  *  For more information about Rocket Pool, visit https://rocketpool.net\r\n  *\r\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\r\n  *\r\n  */\r\n\r\npragma solidity 0.7.6;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\n// A struct containing all the information on-chain about a specific node\n\nstruct NodeDetails {\n    bool exists;\n    uint256 registrationTime;\n    string timezoneLocation;\n    bool feeDistributorInitialised;\n    address feeDistributorAddress;\n    uint256 rewardNetwork;\n    uint256 rplStake;\n    uint256 effectiveRPLStake;\n    uint256 minimumRPLStake;\n    uint256 maximumRPLStake;\n    uint256 ethMatched;\n    uint256 ethMatchedLimit;\n    uint256 minipoolCount;\n    uint256 balanceETH;\n    uint256 balanceRETH;\n    uint256 balanceRPL;\n    uint256 balanceOldRPL;\n    uint256 depositCreditBalance;\n    uint256 distributorBalanceUserETH;\n    uint256 distributorBalanceNodeETH;\n    address withdrawalAddress;\n    address pendingWithdrawalAddress;\n    bool smoothingPoolRegistrationState;\n    uint256 smoothingPoolRegistrationChanged;\n    address nodeAddress;\n}\n"

    },

    "contracts/interface/node/RocketNodeManagerInterface.sol": {

      "content": "/**\r\n  *       .\r\n  *      / \\\r\n  *     |.'.|\r\n  *     |'.'|\r\n  *   ,'|   |`.\r\n  *  |,-'-|-'-.|\r\n  *   __|_| |         _        _      _____           _\r\n  *  | ___ \\|        | |      | |    | ___ \\         | |\r\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n  *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n  *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n  *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n  * +---------------------------------------------------+\r\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\r\n  * +---------------------------------------------------+\r\n  *\r\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\r\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\r\n  *\r\n  *  For more information about Rocket Pool, visit https://rocketpool.net\r\n  *\r\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\r\n  *\r\n  */\r\n\r\npragma solidity >0.5.0 <0.9.0;\npragma abicoder v2;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"../../types/NodeDetails.sol\";\n\ninterface RocketNodeManagerInterface {\n\n    // Structs\n    struct TimezoneCount {\n        string timezone;\n        uint256 count;\n    }\n\n    function getNodeCount() external view returns (uint256);\n    function getNodeCountPerTimezone(uint256 offset, uint256 limit) external view returns (TimezoneCount[] memory);\n    function getNodeAt(uint256 _index) external view returns (address);\n    function getNodeExists(address _nodeAddress) external view returns (bool);\n    function getNodeWithdrawalAddress(address _nodeAddress) external view returns (address);\n    function getNodePendingWithdrawalAddress(address _nodeAddress) external view returns (address);\n    function getNodeTimezoneLocation(address _nodeAddress) external view returns (string memory);\n    function registerNode(string calldata _timezoneLocation) external;\n    function getNodeRegistrationTime(address _nodeAddress) external view returns (uint256);\n    function setTimezoneLocation(string calldata _timezoneLocation) external;\n    function setRewardNetwork(address _nodeAddress, uint256 network) external;\n    function getRewardNetwork(address _nodeAddress) external view returns (uint256);\n    function getFeeDistributorInitialised(address _nodeAddress) external view returns (bool);\n    function initialiseFeeDistributor() external;\n    function getAverageNodeFee(address _nodeAddress) external view returns (uint256);\n    function setSmoothingPoolRegistrationState(bool _state) external;\n    function getSmoothingPoolRegistrationState(address _nodeAddress) external returns (bool);\n    function getSmoothingPoolRegistrationChanged(address _nodeAddress) external returns (uint256);\n    function getSmoothingPoolRegisteredNodeCount(uint256 _offset, uint256 _limit) external view returns (uint256);\n    function getNodeDetails(address _nodeAddress) external view returns (NodeDetails memory);\n    function getNodeAddresses(uint256 _offset, uint256 _limit) external view returns (address[] memory);\n}\n"

    },

    "contracts/interface/network/RocketNetworkPricesInterface.sol": {

      "content": "/**\r\n  *       .\r\n  *      / \\\r\n  *     |.'.|\r\n  *     |'.'|\r\n  *   ,'|   |`.\r\n  *  |,-'-|-'-.|\r\n  *   __|_| |         _        _      _____           _\r\n  *  | ___ \\|        | |      | |    | ___ \\         | |\r\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n  *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n  *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n  *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n  * +---------------------------------------------------+\r\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\r\n  * +---------------------------------------------------+\r\n  *\r\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\r\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\r\n  *\r\n  *  For more information about Rocket Pool, visit https://rocketpool.net\r\n  *\r\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\r\n  *\r\n  */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface RocketNetworkPricesInterface {\n    function getPricesBlock() external view returns (uint256);\n    function getRPLPrice() external view returns (uint256);\n    function getLatestReportableBlock() external view returns (uint256);\n    function submitPrices(uint256 _block, uint256 _rplPrice) external;\n    function executeUpdatePrices(uint256 _block, uint256 _rplPrice) external;\n}\n"

    },

    "contracts/interface/dao/protocol/settings/RocketDAOProtocolSettingsMinipoolInterface.sol": {

      "content": "/**\r\n  *       .\r\n  *      / \\\r\n  *     |.'.|\r\n  *     |'.'|\r\n  *   ,'|   |`.\r\n  *  |,-'-|-'-.|\r\n  *   __|_| |         _        _      _____           _\r\n  *  | ___ \\|        | |      | |    | ___ \\         | |\r\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n  *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n  *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n  *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n  * +---------------------------------------------------+\r\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\r\n  * +---------------------------------------------------+\r\n  *\r\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\r\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\r\n  *\r\n  *  For more information about Rocket Pool, visit https://rocketpool.net\r\n  *\r\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\r\n  *\r\n  */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"../../../../types/MinipoolDeposit.sol\";\n\ninterface RocketDAOProtocolSettingsMinipoolInterface {\n    function getLaunchBalance() external view returns (uint256);\n    function getPreLaunchValue() external pure returns (uint256);\n    function getDepositUserAmount(MinipoolDeposit _depositType) external view returns (uint256);\n    function getFullDepositUserAmount() external view returns (uint256);\n    function getHalfDepositUserAmount() external view returns (uint256);\n    function getVariableDepositAmount() external view returns (uint256);\n    function getSubmitWithdrawableEnabled() external view returns (bool);\n    function getBondReductionEnabled() external view returns (bool);\n    function getLaunchTimeout() external view returns (uint256);\n    function getMaximumCount() external view returns (uint256);\n    function isWithinUserDistributeWindow(uint256 _time) external view returns (bool);\n    function hasUserDistributeWindowPassed(uint256 _time) external view returns (bool);\n    function getUserDistributeWindowStart() external view returns (uint256);\n    function getUserDistributeWindowLength() external view returns (uint256);\n}\n"

    },

    "contracts/interface/dao/protocol/settings/RocketDAOProtocolSettingsNodeInterface.sol": {

      "content": "/**\r\n  *       .\r\n  *      / \\\r\n  *     |.'.|\r\n  *     |'.'|\r\n  *   ,'|   |`.\r\n  *  |,-'-|-'-.|\r\n  *   __|_| |         _        _      _____           _\r\n  *  | ___ \\|        | |      | |    | ___ \\         | |\r\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n  *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n  *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n  *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n  * +---------------------------------------------------+\r\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\r\n  * +---------------------------------------------------+\r\n  *\r\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\r\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\r\n  *\r\n  *  For more information about Rocket Pool, visit https://rocketpool.net\r\n  *\r\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\r\n  *\r\n  */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface RocketDAOProtocolSettingsNodeInterface {\n    function getRegistrationEnabled() external view returns (bool);\n    function getSmoothingPoolRegistrationEnabled() external view returns (bool);\n    function getDepositEnabled() external view returns (bool);\n    function getVacantMinipoolsEnabled() external view returns (bool);\n    function getMinimumPerMinipoolStake() external view returns (uint256);\n    function getMaximumPerMinipoolStake() external view returns (uint256);\n}\n"

    },

    "contracts/interface/minipool/RocketMinipoolFactoryInterface.sol": {

      "content": "/**\r\n  *       .\r\n  *      / \\\r\n  *     |.'.|\r\n  *     |'.'|\r\n  *   ,'|   |`.\r\n  *  |,-'-|-'-.|\r\n  *   __|_| |         _        _      _____           _\r\n  *  | ___ \\|        | |      | |    | ___ \\         | |\r\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n  *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n  *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n  *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n  * +---------------------------------------------------+\r\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\r\n  * +---------------------------------------------------+\r\n  *\r\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\r\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\r\n  *\r\n  *  For more information about Rocket Pool, visit https://rocketpool.net\r\n  *\r\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\r\n  *\r\n  */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"../../types/MinipoolDeposit.sol\";\n\ninterface RocketMinipoolFactoryInterface {\n    function getExpectedAddress(address _nodeAddress, uint256 _salt) external view returns (address);\n    function deployContract(address _nodeAddress, uint256 _salt) external returns (address);\n}\n"

    },

    "contracts/interface/node/RocketNodeDistributorFactoryInterface.sol": {

      "content": "/**\r\n  *       .\r\n  *      / \\\r\n  *     |.'.|\r\n  *     |'.'|\r\n  *   ,'|   |`.\r\n  *  |,-'-|-'-.|\r\n  *   __|_| |         _        _      _____           _\r\n  *  | ___ \\|        | |      | |    | ___ \\         | |\r\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n  *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n  *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n  *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n  * +---------------------------------------------------+\r\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\r\n  * +---------------------------------------------------+\r\n  *\r\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\r\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\r\n  *\r\n  *  For more information about Rocket Pool, visit https://rocketpool.net\r\n  *\r\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\r\n  *\r\n  */\r\n\r\npragma solidity 0.7.6;\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only\r\n\r\ninterface RocketNodeDistributorFactoryInterface {\r\n    function getProxyBytecode() external pure returns (bytes memory);\r\n    function getProxyAddress(address _nodeAddress) external view returns(address);\r\n    function createProxy(address _nodeAddress) external;\r\n}\r\n"

    },

    "contracts/interface/node/RocketNodeDistributorInterface.sol": {

      "content": "/**\r\n  *       .\r\n  *      / \\\r\n  *     |.'.|\r\n  *     |'.'|\r\n  *   ,'|   |`.\r\n  *  |,-'-|-'-.|\r\n  *   __|_| |         _        _      _____           _\r\n  *  | ___ \\|        | |      | |    | ___ \\         | |\r\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n  *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n  *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n  *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n  * +---------------------------------------------------+\r\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\r\n  * +---------------------------------------------------+\r\n  *\r\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\r\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\r\n  *\r\n  *  For more information about Rocket Pool, visit https://rocketpool.net\r\n  *\r\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\r\n  *\r\n  */\r\n\r\npragma solidity 0.7.6;\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only\r\n\r\ninterface RocketNodeDistributorInterface {\r\n    function getNodeShare() external view returns (uint256);\r\n    function getUserShare() external view returns (uint256);\r\n    function distribute() external;\r\n}\r\n"

    },

    "contracts/interface/network/RocketNetworkPenaltiesInterface.sol": {

      "content": "/**\r\n  *       .\r\n  *      / \\\r\n  *     |.'.|\r\n  *     |'.'|\r\n  *   ,'|   |`.\r\n  *  |,-'-|-'-.|\r\n  *   __|_| |         _        _      _____           _\r\n  *  | ___ \\|        | |      | |    | ___ \\         | |\r\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n  *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n  *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n  *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n  * +---------------------------------------------------+\r\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\r\n  * +---------------------------------------------------+\r\n  *\r\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\r\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\r\n  *\r\n  *  For more information about Rocket Pool, visit https://rocketpool.net\r\n  *\r\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\r\n  *\r\n  */\r\n\r\npragma solidity 0.7.6;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface RocketNetworkPenaltiesInterface {\n    function submitPenalty(address _minipoolAddress, uint256 _block) external;\n    function executeUpdatePenalty(address _minipoolAddress, uint256 _block) external;\n    function getPenaltyCount(address _minipoolAddress) external view returns (uint256);\n}\n"

    },

    "contracts/interface/minipool/RocketMinipoolPenaltyInterface.sol": {

      "content": "/**\r\n  *       .\r\n  *      / \\\r\n  *     |.'.|\r\n  *     |'.'|\r\n  *   ,'|   |`.\r\n  *  |,-'-|-'-.|\r\n  *   __|_| |         _        _      _____           _\r\n  *  | ___ \\|        | |      | |    | ___ \\         | |\r\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n  *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n  *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n  *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n  * +---------------------------------------------------+\r\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\r\n  * +---------------------------------------------------+\r\n  *\r\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\r\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\r\n  *\r\n  *  For more information about Rocket Pool, visit https://rocketpool.net\r\n  *\r\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\r\n  *\r\n  */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface RocketMinipoolPenaltyInterface {\n    // Max penalty rate\n    function setMaxPenaltyRate(uint256 _rate) external;\n    function getMaxPenaltyRate() external view returns (uint256);\n\n    // Penalty rate\n    function setPenaltyRate(address _minipoolAddress, uint256 _rate) external;\n    function getPenaltyRate(address _minipoolAddress) external view returns(uint256);\n}\n"

    },

    "contracts/interface/node/RocketNodeDepositInterface.sol": {

      "content": "/**\r\n  *       .\r\n  *      / \\\r\n  *     |.'.|\r\n  *     |'.'|\r\n  *   ,'|   |`.\r\n  *  |,-'-|-'-.|\r\n  *   __|_| |         _        _      _____           _\r\n  *  | ___ \\|        | |      | |    | ___ \\         | |\r\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n  *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n  *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n  *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n  * +---------------------------------------------------+\r\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\r\n  * +---------------------------------------------------+\r\n  *\r\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\r\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\r\n  *\r\n  *  For more information about Rocket Pool, visit https://rocketpool.net\r\n  *\r\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\r\n  *\r\n  */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"../../types/MinipoolDeposit.sol\";\n\ninterface RocketNodeDepositInterface {\n    function getNodeDepositCredit(address _nodeOperator) external view returns (uint256);\n    function increaseDepositCreditBalance(address _nodeOperator, uint256 _amount) external;\n    function deposit(uint256 _depositAmount, uint256 _minimumNodeFee, bytes calldata _validatorPubkey, bytes calldata _validatorSignature, bytes32 _depositDataRoot, uint256 _salt, address _expectedMinipoolAddress) external payable;\n    function depositWithCredit(uint256 _depositAmount, uint256 _minimumNodeFee, bytes calldata _validatorPubkey, bytes calldata _validatorSignature, bytes32 _depositDataRoot, uint256 _salt, address _expectedMinipoolAddress) external payable;\n    function isValidDepositAmount(uint256 _amount) external pure returns (bool);\n    function getDepositAmounts() external pure returns (uint256[] memory);\n    function createVacantMinipool(uint256 _bondAmount, uint256 _minimumNodeFee, bytes calldata _validatorPubkey, uint256 _salt, address _expectedMinipoolAddress, uint256 _currentBalance) external;\n    function increaseEthMatched(address _nodeAddress, uint256 _amount) external;\n}\n"

    },

    "contracts/interface/casper/DepositInterface.sol": {

      "content": "/**\r\n  *       .\r\n  *      / \\\r\n  *     |.'.|\r\n  *     |'.'|\r\n  *   ,'|   |`.\r\n  *  |,-'-|-'-.|\r\n  *   __|_| |         _        _      _____           _\r\n  *  | ___ \\|        | |      | |    | ___ \\         | |\r\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n  *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n  *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n  *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n  * +---------------------------------------------------+\r\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\r\n  * +---------------------------------------------------+\r\n  *\r\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\r\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\r\n  *\r\n  *  For more information about Rocket Pool, visit https://rocketpool.net\r\n  *\r\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\r\n  *\r\n  */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface DepositInterface {\n    function deposit(bytes calldata _pubkey, bytes calldata _withdrawalCredentials, bytes calldata _signature, bytes32 _depositDataRoot) external payable;\n}\n"

    },

    "contracts/interface/deposit/RocketDepositPoolInterface.sol": {

      "content": "/**\r\n  *       .\r\n  *      / \\\r\n  *     |.'.|\r\n  *     |'.'|\r\n  *   ,'|   |`.\r\n  *  |,-'-|-'-.|\r\n  *   __|_| |         _        _      _____           _\r\n  *  | ___ \\|        | |      | |    | ___ \\         | |\r\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n  *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n  *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n  *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n  * +---------------------------------------------------+\r\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\r\n  * +---------------------------------------------------+\r\n  *\r\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\r\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\r\n  *\r\n  *  For more information about Rocket Pool, visit https://rocketpool.net\r\n  *\r\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\r\n  *\r\n  */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface RocketDepositPoolInterface {\n    function getBalance() external view returns (uint256);\n    function getNodeBalance() external view returns (uint256);\n    function getUserBalance() external view returns (int256);\n    function getExcessBalance() external view returns (uint256);\n    function deposit() external payable;\n    function getMaximumDepositAmount() external view returns (uint256);\n    function nodeDeposit(uint256 _totalAmount) external payable;\n    function nodeCreditWithdrawal(uint256 _amount) external;\n    function recycleDissolvedDeposit() external payable;\n    function recycleExcessCollateral() external payable;\n    function recycleLiquidatedStake() external payable;\n    function assignDeposits() external;\n    function maybeAssignDeposits() external returns (bool);\n    function withdrawExcessBalance(uint256 _amount) external;\n}\n"

    },

    "contracts/interface/minipool/RocketMinipoolQueueInterface.sol": {

      "content": "/**\r\n  *       .\r\n  *      / \\\r\n  *     |.'.|\r\n  *     |'.'|\r\n  *   ,'|   |`.\r\n  *  |,-'-|-'-.|\r\n  *   __|_| |         _        _      _____           _\r\n  *  | ___ \\|        | |      | |    | ___ \\         | |\r\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n  *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n  *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n  *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n  * +---------------------------------------------------+\r\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\r\n  * +---------------------------------------------------+\r\n  *\r\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\r\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\r\n  *\r\n  *  For more information about Rocket Pool, visit https://rocketpool.net\r\n  *\r\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\r\n  *\r\n  */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"../../types/MinipoolDeposit.sol\";\n\ninterface RocketMinipoolQueueInterface {\n    function getTotalLength() external view returns (uint256);\n    function getContainsLegacy() external view returns (bool);\n    function getLengthLegacy(MinipoolDeposit _depositType) external view returns (uint256);\n    function getLength() external view returns (uint256);\n    function getTotalCapacity() external view returns (uint256);\n    function getEffectiveCapacity() external view returns (uint256);\n    function getNextCapacityLegacy() external view returns (uint256);\n    function getNextDepositLegacy() external view returns (MinipoolDeposit, uint256);\n    function enqueueMinipool(address _minipool) external;\n    function dequeueMinipoolByDepositLegacy(MinipoolDeposit _depositType) external returns (address minipoolAddress);\n    function dequeueMinipools(uint256 _maxToDequeue) external returns (address[] memory minipoolAddress);\n    function removeMinipool(MinipoolDeposit _depositType) external;\n    function getMinipoolAt(uint256 _index) external view returns(address);\n    function getMinipoolPosition(address _minipool) external view returns (int256);\n}\n"

    },

    "contracts/interface/dao/node/settings/RocketDAONodeTrustedSettingsMinipoolInterface.sol": {

      "content": "/**\r\n  *       .\r\n  *      / \\\r\n  *     |.'.|\r\n  *     |'.'|\r\n  *   ,'|   |`.\r\n  *  |,-'-|-'-.|\r\n  *   __|_| |         _        _      _____           _\r\n  *  | ___ \\|        | |      | |    | ___ \\         | |\r\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n  *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n  *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n  *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n  * +---------------------------------------------------+\r\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\r\n  * +---------------------------------------------------+\r\n  *\r\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\r\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\r\n  *\r\n  *  For more information about Rocket Pool, visit https://rocketpool.net\r\n  *\r\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\r\n  *\r\n  */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface RocketDAONodeTrustedSettingsMinipoolInterface {\n    function getScrubPeriod() external view returns(uint256);\n    function getPromotionScrubPeriod() external view returns(uint256);\n    function getScrubQuorum() external view returns(uint256);\n    function getCancelBondReductionQuorum() external view returns(uint256);\n    function getScrubPenaltyEnabled() external view returns(bool);\n    function isWithinBondReductionWindow(uint256 _time) external view returns (bool);\n    function getBondReductionWindowStart() external view returns (uint256);\n    function getBondReductionWindowLength() external view returns (uint256);\n}\n"

    },

    "contracts/interface/network/RocketNetworkFeesInterface.sol": {

      "content": "/**\r\n  *       .\r\n  *      / \\\r\n  *     |.'.|\r\n  *     |'.'|\r\n  *   ,'|   |`.\r\n  *  |,-'-|-'-.|\r\n  *   __|_| |         _        _      _____           _\r\n  *  | ___ \\|        | |      | |    | ___ \\         | |\r\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n  *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n  *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n  *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n  * +---------------------------------------------------+\r\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\r\n  * +---------------------------------------------------+\r\n  *\r\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\r\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\r\n  *\r\n  *  For more information about Rocket Pool, visit https://rocketpool.net\r\n  *\r\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\r\n  *\r\n  */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface RocketNetworkFeesInterface {\n    function getNodeDemand() external view returns (int256);\n    function getNodeFee() external view returns (uint256);\n    function getNodeFeeByDemand(int256 _nodeDemand) external view returns (uint256);\n}\n"

    },

    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"

    },

    "contracts/interface/token/RocketTokenRETHInterface.sol": {

      "content": "/**\r\n  *       .\r\n  *      / \\\r\n  *     |.'.|\r\n  *     |'.'|\r\n  *   ,'|   |`.\r\n  *  |,-'-|-'-.|\r\n  *   __|_| |         _        _      _____           _\r\n  *  | ___ \\|        | |      | |    | ___ \\         | |\r\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n  *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n  *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n  *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n  * +---------------------------------------------------+\r\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\r\n  * +---------------------------------------------------+\r\n  *\r\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\r\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\r\n  *\r\n  *  For more information about Rocket Pool, visit https://rocketpool.net\r\n  *\r\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\r\n  *\r\n  */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface RocketTokenRETHInterface is IERC20 {\n    function getEthValue(uint256 _rethAmount) external view returns (uint256);\n    function getRethValue(uint256 _ethAmount) external view returns (uint256);\n    function getExchangeRate() external view returns (uint256);\n    function getTotalCollateral() external view returns (uint256);\n    function getCollateralRate() external view returns (uint256);\n    function depositExcess() external payable;\n    function depositExcessCollateral() external;\n    function mint(uint256 _ethAmount, address _to) external;\n    function burn(uint256 _rethAmount) external;\n}\n"

    },

    "contracts/interface/minipool/RocketMinipoolBondReducerInterface.sol": {

      "content": "/**\r\n  *       .\r\n  *      / \\\r\n  *     |.'.|\r\n  *     |'.'|\r\n  *   ,'|   |`.\r\n  *  |,-'-|-'-.|\r\n  *   __|_| |         _        _      _____           _\r\n  *  | ___ \\|        | |      | |    | ___ \\         | |\r\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n  *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n  *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n  *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n  * +---------------------------------------------------+\r\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\r\n  * +---------------------------------------------------+\r\n  *\r\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\r\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\r\n  *\r\n  *  For more information about Rocket Pool, visit https://rocketpool.net\r\n  *\r\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\r\n  *\r\n  */\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >0.5.0 <0.9.0;\npragma abicoder v2;\n\ninterface RocketMinipoolBondReducerInterface {\n    function beginReduceBondAmount(address _minipoolAddress, uint256 _newBondAmount) external;\n    function getReduceBondTime(address _minipoolAddress) external view returns (uint256);\n    function getReduceBondValue(address _minipoolAddress) external view returns (uint256);\n    function getReduceBondCancelled(address _minipoolAddress) external view returns (bool);\n    function canReduceBondAmount(address _minipoolAddress) external view returns (bool);\n    function voteCancelReduction(address _minipoolAddress) external;\n    function reduceBondAmount() external returns (uint256);\n    function getLastBondReductionTime(address _minipoolAddress) external view returns (uint256);\n    function getLastBondReductionPrevValue(address _minipoolAddress) external view returns (uint256);\n    function getLastBondReductionPrevNodeFee(address _minipoolAddress) external view returns (uint256);\n}\n"

    },

    "contracts/contract/minipool/RocketMinipoolDelegate.sol": {

      "content": "/**\r\n  *       .\r\n  *      / \\\r\n  *     |.'.|\r\n  *     |'.'|\r\n  *   ,'|   |`.\r\n  *  |,-'-|-'-.|\r\n  *   __|_| |         _        _      _____           _\r\n  *  | ___ \\|        | |      | |    | ___ \\         | |\r\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n  *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n  *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n  *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n  * +---------------------------------------------------+\r\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\r\n  * +---------------------------------------------------+\r\n  *\r\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\r\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\r\n  *\r\n  *  For more information about Rocket Pool, visit https://rocketpool.net\r\n  *\r\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\r\n  *\r\n  */\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./RocketMinipoolStorageLayout.sol\";\nimport \"../../interface/casper/DepositInterface.sol\";\nimport \"../../interface/deposit/RocketDepositPoolInterface.sol\";\nimport \"../../interface/minipool/RocketMinipoolInterface.sol\";\nimport \"../../interface/minipool/RocketMinipoolManagerInterface.sol\";\nimport \"../../interface/minipool/RocketMinipoolQueueInterface.sol\";\nimport \"../../interface/minipool/RocketMinipoolPenaltyInterface.sol\";\nimport \"../../interface/node/RocketNodeStakingInterface.sol\";\nimport \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsMinipoolInterface.sol\";\nimport \"../../interface/dao/node/settings/RocketDAONodeTrustedSettingsMinipoolInterface.sol\";\nimport \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsNodeInterface.sol\";\nimport \"../../interface/dao/node/RocketDAONodeTrustedInterface.sol\";\nimport \"../../interface/network/RocketNetworkFeesInterface.sol\";\nimport \"../../interface/token/RocketTokenRETHInterface.sol\";\nimport \"../../types/MinipoolDeposit.sol\";\nimport \"../../types/MinipoolStatus.sol\";\nimport \"../../interface/node/RocketNodeDepositInterface.sol\";\nimport \"../../interface/minipool/RocketMinipoolBondReducerInterface.sol\";\n\n/// @notice Provides the logic for each individual minipool in the Rocket Pool network\n/// @dev Minipools exclusively DELEGATECALL into this contract it is never called directly\ncontract RocketMinipoolDelegate is RocketMinipoolStorageLayout, RocketMinipoolInterface {\n\n    // Constants\n    uint8 public constant override version = 3;                   // Used to identify which delegate contract each minipool is using\n    uint256 constant calcBase = 1 ether;                          // Fixed point arithmetic uses this for value for precision\n    uint256 constant legacyPrelaunchAmount = 16 ether;            // The amount of ETH initially deposited when minipool is created (for legacy minipools)\n\n    // Libs\n    using SafeMath for uint;\n\n    // Events\n    event StatusUpdated(uint8 indexed status, uint256 time);\n    event ScrubVoted(address indexed member, uint256 time);\n    event BondReduced(uint256 previousBondAmount, uint256 newBondAmount, uint256 time);\n    event MinipoolScrubbed(uint256 time);\n    event MinipoolPrestaked(bytes validatorPubkey, bytes validatorSignature, bytes32 depositDataRoot, uint256 amount, bytes withdrawalCredentials, uint256 time);\n    event MinipoolPromoted(uint256 time);\n    event MinipoolVacancyPrepared(uint256 bondAmount, uint256 currentBalance, uint256 time);\n    event EtherDeposited(address indexed from, uint256 amount, uint256 time);\n    event EtherWithdrawn(address indexed to, uint256 amount, uint256 time);\n    event EtherWithdrawalProcessed(address indexed executed, uint256 nodeAmount, uint256 userAmount, uint256 totalBalance, uint256 time);\n\n    // Status getters\n    function getStatus() override external view returns (MinipoolStatus) { return status; }\n    function getFinalised() override external view returns (bool) { return finalised; }\n    function getStatusBlock() override external view returns (uint256) { return statusBlock; }\n    function getStatusTime() override external view returns (uint256) { return statusTime; }\n    function getScrubVoted(address _member) override external view returns (bool) { return memberScrubVotes[_member]; }\n\n    // Deposit type getter\n    function getDepositType() override external view returns (MinipoolDeposit) { return depositType; }\n\n    // Node detail getters\n    function getNodeAddress() override external view returns (address) { return nodeAddress; }\n    function getNodeFee() override external view returns (uint256) { return nodeFee; }\n    function getNodeDepositBalance() override external view returns (uint256) { return nodeDepositBalance; }\n    function getNodeRefundBalance() override external view returns (uint256) { return nodeRefundBalance; }\n    function getNodeDepositAssigned() override external view returns (bool) { return userDepositAssignedTime != 0; }\n    function getPreLaunchValue() override external view returns (uint256) { return preLaunchValue; }\n    function getNodeTopUpValue() override external view returns (uint256) { return nodeDepositBalance.sub(preLaunchValue); }\n    function getVacant() override external view returns (bool) { return vacant; }\n    function getPreMigrationBalance() override external view returns (uint256) { return preMigrationBalance; }\n    function getUserDistributed() override external view returns (bool) { return userDistributed; }\n\n    // User deposit detail getters\n    function getUserDepositBalance() override public view returns (uint256) {\n        if (depositType == MinipoolDeposit.Variable) {\n            return userDepositBalance;\n        } else {\n            return userDepositBalanceLegacy;\n        }\n    }\n    function getUserDepositAssigned() override external view returns (bool) { return userDepositAssignedTime != 0; }\n    function getUserDepositAssignedTime() override external view returns (uint256) { return userDepositAssignedTime; }\n    function getTotalScrubVotes() override external view returns (uint256) { return totalScrubVotes; }\n\n    /// @dev Prevent direct calls to this contract\n    modifier onlyInitialised() {\n        require(storageState == StorageState.Initialised, \"Storage state not initialised\");\n        _;\n    }\n\n    /// @dev Prevent multiple calls to initialise\n    modifier onlyUninitialised() {\n        require(storageState == StorageState.Uninitialised, \"Storage state already initialised\");\n        _;\n    }\n\n    /// @dev Only allow access from the owning node address\n    modifier onlyMinipoolOwner(address _nodeAddress) {\n        require(_nodeAddress == nodeAddress, \"Invalid minipool owner\");\n        _;\n    }\n\n    /// @dev Only allow access from the owning node address or their withdrawal address\n    modifier onlyMinipoolOwnerOrWithdrawalAddress(address _nodeAddress) {\n        require(_nodeAddress == nodeAddress || _nodeAddress == rocketStorage.getNodeWithdrawalAddress(nodeAddress), \"Invalid minipool owner\");\n        _;\n    }\n\n    /// @dev Only allow access from the latest version of the specified Rocket Pool contract\n    modifier onlyLatestContract(string memory _contractName, address _contractAddress) {\n        require(_contractAddress == getContractAddress(_contractName), \"Invalid or outdated contract\");\n        _;\n    }\n\n    /// @dev Get the address of a Rocket Pool network contract\n    /// @param _contractName The internal name of the contract to retrieve the address for\n    function getContractAddress(string memory _contractName) private view returns (address) {\n        address contractAddress = rocketStorage.getAddress(keccak256(abi.encodePacked(\"contract.address\", _contractName)));\n        require(contractAddress != address(0x0), \"Contract not found\");\n        return contractAddress;\n    }\n\n    /// @dev Called once on creation to initialise starting state\n    /// @param _nodeAddress The address of the node operator who will own this minipool\n    function initialise(address _nodeAddress) override external onlyUninitialised {\n        // Check parameters\n        require(_nodeAddress != address(0x0), \"Invalid node address\");\n        // Load contracts\n        RocketNetworkFeesInterface rocketNetworkFees = RocketNetworkFeesInterface(getContractAddress(\"rocketNetworkFees\"));\n        // Set initial status\n        status = MinipoolStatus.Initialised;\n        statusBlock = block.number;\n        statusTime = block.timestamp;\n        // Set details\n        depositType = MinipoolDeposit.Variable;\n        nodeAddress = _nodeAddress;\n        nodeFee = rocketNetworkFees.getNodeFee();\n        // Set the rETH address\n        rocketTokenRETH = getContractAddress(\"rocketTokenRETH\");\n        // Set local copy of penalty contract\n        rocketMinipoolPenalty = getContractAddress(\"rocketMinipoolPenalty\");\n        // Intialise storage state\n        storageState = StorageState.Initialised;\n    }\n\n    /// @notice Performs the initial pre-stake on the beacon chain to set the withdrawal credentials\n    /// @param _bondValue The amount of the stake which will be provided by the node operator\n    /// @param _validatorPubkey The public key of the validator\n    /// @param _validatorSignature A signature over the deposit message object\n    /// @param _depositDataRoot The hash tree root of the deposit data object\n    function preDeposit(uint256 _bondValue, bytes calldata _validatorPubkey, bytes calldata _validatorSignature, bytes32 _depositDataRoot) override external payable onlyLatestContract(\"rocketNodeDeposit\", msg.sender) onlyInitialised {\n        // Check current status & node deposit status\n        require(status == MinipoolStatus.Initialised, \"The pre-deposit can only be made while initialised\");\n        require(preLaunchValue == 0, \"Pre-deposit already performed\");\n        // Update node deposit details\n        nodeDepositBalance = _bondValue;\n        preLaunchValue = msg.value;\n        // Emit ether deposited event\n        emit EtherDeposited(msg.sender, preLaunchValue, block.timestamp);\n        // Perform the pre-stake to lock in withdrawal credentials on beacon chain\n        preStake(_validatorPubkey, _validatorSignature, _depositDataRoot);\n    }\n\n    /// @notice Performs the second deposit which provides the validator with the remaining balance to become active\n    function deposit() override external payable onlyLatestContract(\"rocketDepositPool\", msg.sender) onlyInitialised {\n        // Check current status & node deposit status\n        require(status == MinipoolStatus.Initialised, \"The node deposit can only be assigned while initialised\");\n        require(userDepositAssignedTime == 0, \"The user deposit has already been assigned\");\n        // Set the minipool status to prelaunch (ready for node to call `stake()`)\n        setStatus(MinipoolStatus.Prelaunch);\n        // Update deposit details\n        userDepositBalance = msg.value.add(preLaunchValue).sub(nodeDepositBalance);\n        userDepositAssignedTime = block.timestamp;\n        // Emit ether deposited event\n        emit EtherDeposited(msg.sender, msg.value, block.timestamp);\n    }\n\n    /// @notice Assign user deposited ETH to the minipool and mark it as prelaunch\n    /// @dev No longer used in \"Variable\" type minipools (only retained for legacy minipools still in queue)\n    function userDeposit() override external payable onlyLatestContract(\"rocketDepositPool\", msg.sender) onlyInitialised {\n        // Check current status & user deposit status\n        require(status >= MinipoolStatus.Initialised && status <= MinipoolStatus.Staking, \"The user deposit can only be assigned while initialised, in prelaunch, or staking\");\n        require(userDepositAssignedTime == 0, \"The user deposit has already been assigned\");\n        // Progress initialised minipool to prelaunch\n        if (status == MinipoolStatus.Initialised) { setStatus(MinipoolStatus.Prelaunch); }\n        // Update user deposit details\n        userDepositBalance = msg.value;\n        userDepositAssignedTime = block.timestamp;\n        // Refinance full minipool\n        if (depositType == MinipoolDeposit.Full) {\n            // Update node balances\n            nodeDepositBalance = nodeDepositBalance.sub(msg.value);\n            nodeRefundBalance = nodeRefundBalance.add(msg.value);\n        }\n        // Emit ether deposited event\n        emit EtherDeposited(msg.sender, msg.value, block.timestamp);\n    }\n\n    /// @notice Refund node ETH refinanced from user deposited ETH\n    function refund() override external onlyMinipoolOwnerOrWithdrawalAddress(msg.sender) onlyInitialised {\n        // Check refund balance\n        require(nodeRefundBalance > 0, \"No amount of the node deposit is available for refund\");\n        // If this minipool was distributed by a user, force finalisation on the node operator\n        if (!finalised && userDistributed) {\n            // Note: _refund is called inside _finalise\n            _finalise();\n        } else {\n            // Refund node\n            _refund();\n        }\n    }\n\n    /// @notice Called to slash node operator's RPL balance if withdrawal balance was less than user deposit\n    function slash() external override onlyInitialised {\n        // Check there is a slash balance\n        require(nodeSlashBalance > 0, \"No balance to slash\");\n        // Perform slash\n        _slash();\n    }\n\n    /// @notice Returns true when `stake()` can be called by node operator taking into consideration the scrub period\n    function canStake() override external view onlyInitialised returns (bool) {\n        // Check status\n        if (status != MinipoolStatus.Prelaunch) {\n            return false;\n        }\n        // Get contracts\n        RocketDAONodeTrustedSettingsMinipoolInterface rocketDAONodeTrustedSettingsMinipool = RocketDAONodeTrustedSettingsMinipoolInterface(getContractAddress(\"rocketDAONodeTrustedSettingsMinipool\"));\n        // Get scrub period\n        uint256 scrubPeriod = rocketDAONodeTrustedSettingsMinipool.getScrubPeriod();\n        // Check if we have been in prelaunch status for long enough\n        return block.timestamp > statusTime + scrubPeriod;\n    }\n\n    /// @notice Returns true when `promote()` can be called by node operator taking into consideration the scrub period\n    function canPromote() override external view onlyInitialised returns (bool) {\n        // Check status\n        if (status != MinipoolStatus.Prelaunch) {\n            return false;\n        }\n        // Get contracts\n        RocketDAONodeTrustedSettingsMinipoolInterface rocketDAONodeTrustedSettingsMinipool = RocketDAONodeTrustedSettingsMinipoolInterface(getContractAddress(\"rocketDAONodeTrustedSettingsMinipool\"));\n        // Get scrub period\n        uint256 scrubPeriod = rocketDAONodeTrustedSettingsMinipool.getPromotionScrubPeriod();\n        // Check if we have been in prelaunch status for long enough\n        return block.timestamp > statusTime + scrubPeriod;\n    }\n\n    /// @notice Progress the minipool to staking, sending its ETH deposit to the deposit contract. Only accepts calls from the minipool owner (node) while in prelaunch and once scrub period has ended\n    /// @param _validatorSignature A signature over the deposit message object\n    /// @param _depositDataRoot The hash tree root of the deposit data object\n    function stake(bytes calldata _validatorSignature, bytes32 _depositDataRoot) override external onlyMinipoolOwner(msg.sender) onlyInitialised {\n        // Get contracts\n        RocketDAOProtocolSettingsMinipoolInterface rocketDAOProtocolSettingsMinipool = RocketDAOProtocolSettingsMinipoolInterface(getContractAddress(\"rocketDAOProtocolSettingsMinipool\"));\n        {\n            // Get scrub period\n            RocketDAONodeTrustedSettingsMinipoolInterface rocketDAONodeTrustedSettingsMinipool = RocketDAONodeTrustedSettingsMinipoolInterface(getContractAddress(\"rocketDAONodeTrustedSettingsMinipool\"));\n            uint256 scrubPeriod = rocketDAONodeTrustedSettingsMinipool.getScrubPeriod();\n            // Check current status\n            require(status == MinipoolStatus.Prelaunch, \"The minipool can only begin staking while in prelaunch\");\n            require(block.timestamp > statusTime + scrubPeriod, \"Not enough time has passed to stake\");\n            require(!vacant, \"Cannot stake a vacant minipool\");\n        }\n        // Progress to staking\n        setStatus(MinipoolStatus.Staking);\n        // Load contracts\n        DepositInterface casperDeposit = DepositInterface(getContractAddress(\"casperDeposit\"));\n        RocketMinipoolManagerInterface rocketMinipoolManager = RocketMinipoolManagerInterface(getContractAddress(\"rocketMinipoolManager\"));\n        // Get launch amount\n        uint256 launchAmount = rocketDAOProtocolSettingsMinipool.getLaunchBalance();\n        uint256 depositAmount;\n        // Legacy minipools had a prestake equal to the bond amount\n        if (depositType == MinipoolDeposit.Variable) {\n            depositAmount = launchAmount.sub(preLaunchValue);\n        } else {\n            depositAmount = launchAmount.sub(legacyPrelaunchAmount);\n        }\n        // Check minipool balance\n        require(address(this).balance >= depositAmount, \"Insufficient balance to begin staking\");\n        // Retrieve validator pubkey from storage\n        bytes memory validatorPubkey = rocketMinipoolManager.getMinipoolPubkey(address(this));\n        // Send staking deposit to casper\n        casperDeposit.deposit{value : depositAmount}(validatorPubkey, rocketMinipoolManager.getMinipoolWithdrawalCredentials(address(this)), _validatorSignature, _depositDataRoot);\n        // Increment node's number of staking minipools\n        rocketMinipoolManager.incrementNodeStakingMinipoolCount(nodeAddress);\n    }\n\n    /// @dev Sets the bond value and vacancy flag on this minipool\n    /// @param _bondAmount The bond amount selected by the node operator\n    /// @param _currentBalance The current balance of the validator on the beaconchain (will be checked by oDAO and scrubbed if not correct)\n    function prepareVacancy(uint256 _bondAmount, uint256 _currentBalance) override external onlyLatestContract(\"rocketMinipoolManager\", msg.sender) onlyInitialised {\n        // Check status\n        require(status == MinipoolStatus.Initialised, \"Must be in initialised status\");\n        // Sanity check that refund balance is zero\n        require(nodeRefundBalance == 0, \"Refund balance not zero\");\n        // Check balance\n        RocketDAOProtocolSettingsMinipoolInterface rocketDAOProtocolSettingsMinipool = RocketDAOProtocolSettingsMinipoolInterface(getContractAddress(\"rocketDAOProtocolSettingsMinipool\"));\n        uint256 launchAmount = rocketDAOProtocolSettingsMinipool.getLaunchBalance();\n        require(_currentBalance >= launchAmount, \"Balance is too low\");\n        // Store bond amount\n        nodeDepositBalance = _bondAmount;\n        // Calculate user amount from launch amount\n        userDepositBalance = launchAmount.sub(nodeDepositBalance);\n        // Flag as vacant\n        vacant = true;\n        preMigrationBalance = _currentBalance;\n        // Refund the node whatever rewards they have accrued prior to becoming a RP validator\n        nodeRefundBalance = _currentBalance.sub(launchAmount);\n        // Set status to preLaunch\n        setStatus(MinipoolStatus.Prelaunch);\n        // Emit event\n        emit MinipoolVacancyPrepared(_bondAmount, _currentBalance, block.timestamp);\n    }\n\n    /// @dev Promotes this minipool to a complete minipool\n    function promote() override external onlyMinipoolOwner(msg.sender) onlyInitialised {\n        // Check status\n        require(status == MinipoolStatus.Prelaunch, \"The minipool can only promote while in prelaunch\");\n        require(vacant, \"Cannot promote a non-vacant minipool\");\n        // Get contracts\n        RocketDAONodeTrustedSettingsMinipoolInterface rocketDAONodeTrustedSettingsMinipool = RocketDAONodeTrustedSettingsMinipoolInterface(getContractAddress(\"rocketDAONodeTrustedSettingsMinipool\"));\n        // Clear vacant flag\n        vacant = false;\n        // Check scrub period\n        uint256 scrubPeriod = rocketDAONodeTrustedSettingsMinipool.getPromotionScrubPeriod();\n        require(block.timestamp > statusTime + scrubPeriod, \"Not enough time has passed to promote\");\n        // Progress to staking\n        setStatus(MinipoolStatus.Staking);\n        // Increment node's number of staking minipools\n        RocketMinipoolManagerInterface rocketMinipoolManager = RocketMinipoolManagerInterface(getContractAddress(\"rocketMinipoolManager\"));\n        rocketMinipoolManager.incrementNodeStakingMinipoolCount(nodeAddress);\n        // Set deposit assigned time\n        userDepositAssignedTime = block.timestamp;\n        // Increase node operator's deposit credit\n        RocketNodeDepositInterface rocketNodeDepositInterface = RocketNodeDepositInterface(getContractAddress(\"rocketNodeDeposit\"));\n        rocketNodeDepositInterface.increaseDepositCreditBalance(nodeAddress, userDepositBalance);\n        // Remove from vacant set\n        rocketMinipoolManager.removeVacantMinipool();\n        // Emit event\n        emit MinipoolPromoted(block.timestamp);\n    }\n\n    /// @dev Stakes the balance of this minipool into the deposit contract to set withdrawal credentials to this contract\n    /// @param _validatorSignature A signature over the deposit message object\n    /// @param _depositDataRoot The hash tree root of the deposit data object\n    function preStake(bytes calldata _validatorPubkey, bytes calldata _validatorSignature, bytes32 _depositDataRoot) internal {\n        // Load contracts\n        DepositInterface casperDeposit = DepositInterface(getContractAddress(\"casperDeposit\"));\n        RocketMinipoolManagerInterface rocketMinipoolManager = RocketMinipoolManagerInterface(getContractAddress(\"rocketMinipoolManager\"));\n        // Set minipool pubkey\n        rocketMinipoolManager.setMinipoolPubkey(_validatorPubkey);\n        // Get withdrawal credentials\n        bytes memory withdrawalCredentials = rocketMinipoolManager.getMinipoolWithdrawalCredentials(address(this));\n        // Send staking deposit to casper\n        casperDeposit.deposit{value : preLaunchValue}(_validatorPubkey, withdrawalCredentials, _validatorSignature, _depositDataRoot);\n        // Emit event\n        emit MinipoolPrestaked(_validatorPubkey, _validatorSignature, _depositDataRoot, preLaunchValue, withdrawalCredentials, block.timestamp);\n    }\n\n    /// @notice Distributes the contract's balance.\n    ///         If balance is greater or equal to 8 ETH, the NO can call to distribute capital and finalise the minipool.\n    ///         If balance is greater or equal to 8 ETH, users who have called `beginUserDistribute` and waited the required\n    ///         amount of time can call to distribute capital.\n    ///         If balance is lower than 8 ETH, can be called by anyone and is considered a partial withdrawal and funds are\n    ///         split as rewards.\n    /// @param _rewardsOnly If set to true, will revert if balance is not being treated as rewards\n    function distributeBalance(bool _rewardsOnly) override external onlyInitialised {\n        // Get node withdrawal address\n        address nodeWithdrawalAddress = rocketStorage.getNodeWithdrawalAddress(nodeAddress);\n        bool ownerCalling = msg.sender == nodeAddress || msg.sender == nodeWithdrawalAddress;\n        // If dissolved, distribute everything to the owner\n        if (status == MinipoolStatus.Dissolved) {\n            require(ownerCalling, \"Only owner can distribute dissolved minipool\");\n            distributeToOwner();\n            return;\n        }\n        // Can only be called while in staking status\n        require(status == MinipoolStatus.Staking, \"Minipool must be staking\");\n        // Get withdrawal amount, we must also account for a possible node refund balance on the contract\n        uint256 totalBalance = address(this).balance.sub(nodeRefundBalance);\n        if (totalBalance >= 8 ether) {\n            // Prevent funding front runs of distribute balance\n            require(!_rewardsOnly, \"Balance exceeds 8 ether\");\n            // Consider this a full withdrawal\n            _distributeBalance(totalBalance);\n            if (ownerCalling) {\n                // Finalise the minipool if the owner is calling\n                _finalise();\n            } else {\n                // Require user wait period to pass before allowing user to distribute\n                require(userDistributeAllowed(), \"Only owner can distribute right now\");\n                // Mark this minipool as having been distributed by a user\n                userDistributed = true;\n            }\n        } else {\n            // Just a partial withdraw\n            distributeSkimmedRewards();\n            // If node operator is calling, save a tx by calling refund immediately\n            if (ownerCalling && nodeRefundBalance > 0) {\n                _refund();\n            }\n        }\n        // Reset distribute waiting period\n        userDistributeTime = 0;\n    }\n\n    /// @dev Distribute the entire balance to the minipool owner\n    function distributeToOwner() internal {\n        // Get balance\n        uint256 balance = address(this).balance;\n        // Get node withdrawal address\n        address nodeWithdrawalAddress = rocketStorage.getNodeWithdrawalAddress(nodeAddress);\n        // Transfer balance\n        (bool success,) = nodeWithdrawalAddress.call{value : balance}(\"\");\n        require(success, \"Node ETH balance was not successfully transferred to node operator\");\n        // Emit ether withdrawn event\n        emit EtherWithdrawn(nodeWithdrawalAddress, balance, block.timestamp);\n    }\n\n    /// @notice Allows a user (other than the owner of this minipool) to signal they want to call distribute.\n    ///         After waiting the required period, anyone may then call `distributeBalance()`.\n    function beginUserDistribute() override external onlyInitialised {\n        require(status == MinipoolStatus.Staking, \"Minipool must be staking\");\n        uint256 totalBalance = address(this).balance.sub(nodeRefundBalance);\n        require (totalBalance >= 8 ether, \"Balance too low\");\n        // Prevent calls resetting distribute time before window has passed\n        RocketDAOProtocolSettingsMinipoolInterface rocketDAOProtocolSettingsMinipool = RocketDAOProtocolSettingsMinipoolInterface(getContractAddress(\"rocketDAOProtocolSettingsMinipool\"));\n        uint256 timeElapsed = block.timestamp.sub(userDistributeTime);\n        require(rocketDAOProtocolSettingsMinipool.hasUserDistributeWindowPassed(timeElapsed), \"User distribution already pending\");\n        // Store current time\n        userDistributeTime = block.timestamp;\n    }\n\n    /// @notice Returns true if enough time has passed for a user to distribute\n    function userDistributeAllowed() override public view returns (bool) {\n        // Get contracts\n        RocketDAOProtocolSettingsMinipoolInterface rocketDAOProtocolSettingsMinipool = RocketDAOProtocolSettingsMinipoolInterface(getContractAddress(\"rocketDAOProtocolSettingsMinipool\"));\n        // Calculate if time elapsed since call to `beginUserDistribute` is within the allowed window\n        uint256 timeElapsed = block.timestamp.sub(userDistributeTime);\n        return(rocketDAOProtocolSettingsMinipool.isWithinUserDistributeWindow(timeElapsed));\n    }\n\n    /// @notice Allows the owner of this minipool to finalise it after a user has manually distributed the balance\n    function finalise() override external onlyMinipoolOwnerOrWithdrawalAddress(msg.sender) onlyInitialised {\n        require(userDistributed, \"Can only manually finalise after user distribution\");\n        _finalise();\n    }\n\n    /// @dev Perform any slashings, refunds, and unlock NO's stake\n    function _finalise() private {\n        // Get contracts\n        RocketMinipoolManagerInterface rocketMinipoolManager = RocketMinipoolManagerInterface(getContractAddress(\"rocketMinipoolManager\"));\n        // Can only finalise the pool once\n        require(!finalised, \"Minipool has already been finalised\");\n        // Set finalised flag\n        finalised = true;\n        // If slash is required then perform it\n        if (nodeSlashBalance > 0) {\n            _slash();\n        }\n        // Refund node operator if required\n        if (nodeRefundBalance > 0) {\n            _refund();\n        }\n        // Send any left over ETH to rETH contract\n        if (address(this).balance > 0) {\n            // Send user amount to rETH contract\n            payable(rocketTokenRETH).transfer(address(this).balance);\n        }\n        // Trigger a deposit of excess collateral from rETH contract to deposit pool\n        RocketTokenRETHInterface(rocketTokenRETH).depositExcessCollateral();\n        // Unlock node operator's RPL\n        rocketMinipoolManager.incrementNodeFinalisedMinipoolCount(nodeAddress);\n        rocketMinipoolManager.decrementNodeStakingMinipoolCount(nodeAddress);\n    }\n\n    /// @dev Distributes balance to user and node operator\n    /// @param _balance The amount to distribute\n    function _distributeBalance(uint256 _balance) private {\n        // Deposit amounts\n        uint256 nodeAmount = 0;\n        uint256 userCapital = getUserDepositBalance();\n        // Check if node operator was slashed\n        if (_balance < userCapital) {\n            // Only slash on first call to distribute\n            if (withdrawalBlock == 0) {\n                // Record shortfall for slashing\n                nodeSlashBalance = userCapital.sub(_balance);\n            }\n        } else {\n            // Calculate node's share of the balance\n            nodeAmount = _calculateNodeShare(_balance);\n        }\n        // User amount is what's left over from node's share\n        uint256 userAmount = _balance.sub(nodeAmount);\n        // Pay node operator via refund\n        nodeRefundBalance = nodeRefundBalance.add(nodeAmount);\n        // Pay user amount to rETH contract\n        if (userAmount > 0) {\n            // Send user amount to rETH contract\n            payable(rocketTokenRETH).transfer(userAmount);\n        }\n        // Save block to prevent multiple withdrawals within a few blocks\n        withdrawalBlock = block.number;\n        // Log it\n        emit EtherWithdrawalProcessed(msg.sender, nodeAmount, userAmount, _balance, block.timestamp);\n    }\n\n    /// @notice Given a balance, this function returns what portion of it belongs to the node taking into\n    /// consideration the 8 ether reward threshold, the minipool's commission rate and any penalties it may have\n    /// attracted. Another way of describing this function is that if this contract's balance was\n    /// `_balance + nodeRefundBalance` this function would return how much of that balance would be paid to the node\n    /// operator if a distribution occurred\n    /// @param _balance The balance to calculate the node share of. Should exclude nodeRefundBalance\n    function calculateNodeShare(uint256 _balance) override public view returns (uint256) {\n        // Sub 8 ether balance is treated as rewards\n        if (_balance < 8 ether) {\n            return calculateNodeRewards(nodeDepositBalance, getUserDepositBalance(), _balance);\n        } else {\n            return _calculateNodeShare(_balance);\n        }\n    }\n\n    /// @notice Performs the same calculation as `calculateNodeShare` but on the user side\n    /// @param _balance The balance to calculate the node share of. Should exclude nodeRefundBalance\n    function calculateUserShare(uint256 _balance) override external view returns (uint256) {\n        // User's share is just the balance minus node refund minus node's share\n        return _balance.sub(calculateNodeShare(_balance));\n    }\n\n    /// @dev Given a balance, this function returns what portion of it belongs to the node taking into\n    /// consideration the minipool's commission rate and any penalties it may have attracted\n    /// @param _balance The balance to calculate the node share of (with nodeRefundBalance already subtracted)\n    function _calculateNodeShare(uint256 _balance) internal view returns (uint256) {\n        uint256 userCapital = getUserDepositBalance();\n        uint256 nodeCapital = nodeDepositBalance;\n        uint256 nodeShare = 0;\n        // Calculate the total capital (node + user)\n        uint256 capital = userCapital.add(nodeCapital);\n        if (_balance > capital) {\n            // Total rewards to share\n            uint256 rewards = _balance.sub(capital);\n            nodeShare = nodeCapital.add(calculateNodeRewards(nodeCapital, userCapital, rewards));\n        } else if (_balance > userCapital) {\n            nodeShare = _balance.sub(userCapital);\n        }\n        // Check if node has an ETH penalty\n        uint256 penaltyRate = RocketMinipoolPenaltyInterface(rocketMinipoolPenalty).getPenaltyRate(address(this));\n        if (penaltyRate > 0) {\n            uint256 penaltyAmount = nodeShare.mul(penaltyRate).div(calcBase);\n            if (penaltyAmount > nodeShare) {\n                penaltyAmount = nodeShare;\n            }\n            nodeShare = nodeShare.sub(penaltyAmount);\n        }\n        return nodeShare;\n    }\n\n    /// @dev Calculates what portion of rewards should be paid to the node operator given a capital ratio\n    /// @param _nodeCapital The node supplied portion of the capital\n    /// @param _userCapital The user supplied portion of the capital\n    /// @param _rewards The amount of rewards to split\n    function calculateNodeRewards(uint256 _nodeCapital, uint256 _userCapital, uint256 _rewards) internal view returns (uint256) {\n        // Calculate node and user portion based on proportions of capital provided\n        uint256 nodePortion = _rewards.mul(_nodeCapital).div(_userCapital.add(_nodeCapital));\n        uint256 userPortion = _rewards.sub(nodePortion);\n        // Calculate final node amount as combination of node capital, node share and commission on user share\n        return nodePortion.add(userPortion.mul(nodeFee).div(calcBase));\n    }\n\n    /// @notice Dissolve the minipool, returning user deposited ETH to the deposit pool.\n    function dissolve() override external onlyInitialised {\n        // Check current status\n        require(status == MinipoolStatus.Prelaunch, \"The minipool can only be dissolved while in prelaunch\");\n        // Load contracts\n        RocketDAOProtocolSettingsMinipoolInterface rocketDAOProtocolSettingsMinipool = RocketDAOProtocolSettingsMinipoolInterface(getContractAddress(\"rocketDAOProtocolSettingsMinipool\"));\n        // Check if minipool is timed out\n        require(block.timestamp.sub(statusTime) >= rocketDAOProtocolSettingsMinipool.getLaunchTimeout(), \"The minipool can only be dissolved once it has timed out\");\n        // Perform the dissolution\n        _dissolve();\n    }\n\n    /// @notice Withdraw node balances from the minipool and close it. Only accepts calls from the owner\n    function close() override external onlyMinipoolOwner(msg.sender) onlyInitialised {\n        // Check current status\n        require(status == MinipoolStatus.Dissolved, \"The minipool can only be closed while dissolved\");\n        // Distribute funds to owner\n        distributeToOwner();\n        // Destroy minipool\n        RocketMinipoolManagerInterface rocketMinipoolManager = RocketMinipoolManagerInterface(getContractAddress(\"rocketMinipoolManager\"));\n        require(rocketMinipoolManager.getMinipoolExists(address(this)), \"Minipool already closed\");\n        rocketMinipoolManager.destroyMinipool();\n        // Clear state\n        nodeDepositBalance = 0;\n        nodeRefundBalance = 0;\n        userDepositBalance = 0;\n        userDepositBalanceLegacy = 0;\n        userDepositAssignedTime = 0;\n    }\n\n    /// @notice Can be called by trusted nodes to scrub this minipool if its withdrawal credentials are not set correctly\n    function voteScrub() override external onlyInitialised {\n        // Check current status\n        require(status == MinipoolStatus.Prelaunch, \"The minipool can only be scrubbed while in prelaunch\");\n        // Get contracts\n        RocketDAONodeTrustedInterface rocketDAONode = RocketDAONodeTrustedInterface(getContractAddress(\"rocketDAONodeTrusted\"));\n        RocketDAONodeTrustedSettingsMinipoolInterface rocketDAONodeTrustedSettingsMinipool = RocketDAONodeTrustedSettingsMinipoolInterface(getContractAddress(\"rocketDAONodeTrustedSettingsMinipool\"));\n        // Must be a trusted member\n        require(rocketDAONode.getMemberIsValid(msg.sender), \"Not a trusted member\");\n        // Can only vote once\n        require(!memberScrubVotes[msg.sender], \"Member has already voted to scrub\");\n        memberScrubVotes[msg.sender] = true;\n        // Emit event\n        emit ScrubVoted(msg.sender, block.timestamp);\n        // Check if required quorum has voted\n        uint256 quorum = rocketDAONode.getMemberCount().mul(rocketDAONodeTrustedSettingsMinipool.getScrubQuorum()).div(calcBase);\n        if (totalScrubVotes.add(1) > quorum) {\n            // Slash RPL equal to minimum stake amount (if enabled)\n            if (!vacant && rocketDAONodeTrustedSettingsMinipool.getScrubPenaltyEnabled()){\n                RocketNodeStakingInterface rocketNodeStaking = RocketNodeStakingInterface(getContractAddress(\"rocketNodeStaking\"));\n                RocketDAOProtocolSettingsNodeInterface rocketDAOProtocolSettingsNode = RocketDAOProtocolSettingsNodeInterface(getContractAddress(\"rocketDAOProtocolSettingsNode\"));\n                RocketDAOProtocolSettingsMinipoolInterface rocketDAOProtocolSettingsMinipool = RocketDAOProtocolSettingsMinipoolInterface(getContractAddress(\"rocketDAOProtocolSettingsMinipool\"));\n                uint256 launchAmount = rocketDAOProtocolSettingsMinipool.getLaunchBalance();\n                // Slash amount is minRplStake * userCapital\n                // In prelaunch userDepositBalance hasn't been set so we calculate it as 32 ETH - bond amount\n                rocketNodeStaking.slashRPL(\n                    nodeAddress,\n                        launchAmount.sub(nodeDepositBalance)\n                        .mul(rocketDAOProtocolSettingsNode.getMinimumPerMinipoolStake())\n                        .div(calcBase)\n                );\n            }\n            // Dissolve this minipool, recycling ETH back to deposit pool\n            _dissolve();\n            // Emit event\n            emit MinipoolScrubbed(block.timestamp);\n        } else {\n            // Increment total\n            totalScrubVotes = totalScrubVotes.add(1);\n        }\n    }\n\n    /// @notice Reduces the ETH bond amount and credits the owner the difference\n    function reduceBondAmount() override external onlyMinipoolOwner(msg.sender) onlyInitialised {\n        require(status == MinipoolStatus.Staking, \"Minipool must be staking\");\n        // If balance is greater than 8 ether, it is assumed to be capital not skimmed rewards. So prevent reduction\n        uint256 totalBalance = address(this).balance.sub(nodeRefundBalance);\n        require(totalBalance < 8 ether, \"Cannot reduce bond with balance of 8 ether or more\");\n        // Distribute any skimmed rewards\n        distributeSkimmedRewards();\n        // Approve reduction and handle external state changes\n        RocketMinipoolBondReducerInterface rocketBondReducer = RocketMinipoolBondReducerInterface(getContractAddress(\"rocketMinipoolBondReducer\"));\n        uint256 previousBond = nodeDepositBalance;\n        uint256 newBond = rocketBondReducer.reduceBondAmount();\n        // Update user/node balances\n        userDepositBalance = getUserDepositBalance().add(previousBond.sub(newBond));\n        nodeDepositBalance = newBond;\n        // Reset node fee to current network rate\n        RocketNetworkFeesInterface rocketNetworkFees = RocketNetworkFeesInterface(getContractAddress(\"rocketNetworkFees\"));\n        uint256 prevFee = nodeFee;\n        uint256 newFee = rocketNetworkFees.getNodeFee();\n        nodeFee = newFee;\n        // Update staking minipool counts and fee numerator\n        RocketMinipoolManagerInterface rocketMinipoolManager = RocketMinipoolManagerInterface(getContractAddress(\"rocketMinipoolManager\"));\n        rocketMinipoolManager.updateNodeStakingMinipoolCount(previousBond, newBond, prevFee, newFee);\n        // Break state to prevent rollback exploit\n        if (depositType != MinipoolDeposit.Variable) {\n            userDepositBalanceLegacy = 2 ** 256 - 1;\n            depositType = MinipoolDeposit.Variable;\n        }\n        // Emit event\n        emit BondReduced(previousBond, newBond, block.timestamp);\n    }\n\n    /// @dev Distributes the current contract balance based on capital ratio and node fee\n    function distributeSkimmedRewards() internal {\n        uint256 rewards = address(this).balance.sub(nodeRefundBalance);\n        uint256 nodeShare = calculateNodeRewards(nodeDepositBalance, getUserDepositBalance(), rewards);\n        // Pay node operator via refund mechanism\n        nodeRefundBalance = nodeRefundBalance.add(nodeShare);\n        // Deposit user share into rETH contract\n        payable(rocketTokenRETH).transfer(rewards.sub(nodeShare));\n    }\n\n    /// @dev Set the minipool's current status\n    /// @param _status The new status\n    function setStatus(MinipoolStatus _status) private {\n        // Update status\n        status = _status;\n        statusBlock = block.number;\n        statusTime = block.timestamp;\n        // Emit status updated event\n        emit StatusUpdated(uint8(_status), block.timestamp);\n    }\n\n    /// @dev Transfer refunded ETH balance to the node operator\n    function _refund() private {\n        // Prevent vacant minipools from calling\n        require(vacant == false, \"Vacant minipool cannot refund\");\n        // Update refund balance\n        uint256 refundAmount = nodeRefundBalance;\n        nodeRefundBalance = 0;\n        // Get node withdrawal address\n        address nodeWithdrawalAddress = rocketStorage.getNodeWithdrawalAddress(nodeAddress);\n        // Transfer refund amount\n        (bool success,) = nodeWithdrawalAddress.call{value : refundAmount}(\"\");\n        require(success, \"ETH refund amount was not successfully transferred to node operator\");\n        // Emit ether withdrawn event\n        emit EtherWithdrawn(nodeWithdrawalAddress, refundAmount, block.timestamp);\n    }\n\n    /// @dev Slash node operator's RPL balance based on nodeSlashBalance\n    function _slash() private {\n        // Get contracts\n        RocketNodeStakingInterface rocketNodeStaking = RocketNodeStakingInterface(getContractAddress(\"rocketNodeStaking\"));\n        // Slash required amount and reset storage value\n        uint256 slashAmount = nodeSlashBalance;\n        nodeSlashBalance = 0;\n        rocketNodeStaking.slashRPL(nodeAddress, slashAmount);\n    }\n\n    /// @dev Dissolve this minipool\n    function _dissolve() private {\n        // Get contracts\n        RocketDepositPoolInterface rocketDepositPool = RocketDepositPoolInterface(getContractAddress(\"rocketDepositPool\"));\n        RocketMinipoolQueueInterface rocketMinipoolQueue = RocketMinipoolQueueInterface(getContractAddress(\"rocketMinipoolQueue\"));\n        // Progress to dissolved\n        setStatus(MinipoolStatus.Dissolved);\n        if (vacant) {\n            // Vacant minipools waiting to be promoted need to be removed from the set maintained by the minipool manager\n            RocketMinipoolManagerInterface rocketMinipoolManager = RocketMinipoolManagerInterface(getContractAddress(\"rocketMinipoolManager\"));\n            rocketMinipoolManager.removeVacantMinipool();\n        } else {\n            if (depositType == MinipoolDeposit.Full) {\n                // Handle legacy Full type minipool\n                rocketMinipoolQueue.removeMinipool(MinipoolDeposit.Full);\n            } else {\n                // Transfer user balance to deposit pool\n                uint256 userCapital = getUserDepositBalance();\n                rocketDepositPool.recycleDissolvedDeposit{value : userCapital}();\n                // Emit ether withdrawn event\n                emit EtherWithdrawn(address(rocketDepositPool), userCapital, block.timestamp);\n            }\n        }\n    }\n}\n"

    },

    "contracts/contract/minipool/RocketMinipoolManager.sol": {

      "content": "/**\r\n  *       .\r\n  *      / \\\r\n  *     |.'.|\r\n  *     |'.'|\r\n  *   ,'|   |`.\r\n  *  |,-'-|-'-.|\r\n  *   __|_| |         _        _      _____           _\r\n  *  | ___ \\|        | |      | |    | ___ \\         | |\r\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n  *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n  *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n  *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n  * +---------------------------------------------------+\r\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\r\n  * +---------------------------------------------------+\r\n  *\r\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\r\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\r\n  *\r\n  *  For more information about Rocket Pool, visit https://rocketpool.net\r\n  *\r\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\r\n  *\r\n  */\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"../RocketBase.sol\";\nimport \"./RocketMinipoolBase.sol\";\nimport \"../../types/MinipoolStatus.sol\";\nimport \"../../types/MinipoolDeposit.sol\";\nimport \"../../types/MinipoolDetails.sol\";\nimport \"../../interface/dao/node/RocketDAONodeTrustedInterface.sol\";\nimport \"../../interface/minipool/RocketMinipoolInterface.sol\";\nimport \"../../interface/minipool/RocketMinipoolManagerInterface.sol\";\nimport \"../../interface/node/RocketNodeStakingInterface.sol\";\nimport \"../../interface/util/AddressSetStorageInterface.sol\";\nimport \"../../interface/node/RocketNodeManagerInterface.sol\";\nimport \"../../interface/network/RocketNetworkPricesInterface.sol\";\nimport \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsMinipoolInterface.sol\";\nimport \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsNodeInterface.sol\";\nimport \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsNodeInterface.sol\";\nimport \"../../interface/minipool/RocketMinipoolFactoryInterface.sol\";\nimport \"../../interface/node/RocketNodeDistributorFactoryInterface.sol\";\nimport \"../../interface/node/RocketNodeDistributorInterface.sol\";\nimport \"../../interface/network/RocketNetworkPenaltiesInterface.sol\";\nimport \"../../interface/minipool/RocketMinipoolPenaltyInterface.sol\";\nimport \"../../interface/node/RocketNodeDepositInterface.sol\";\nimport \"./RocketMinipoolDelegate.sol\";\n\n/// @notice Minipool creation, removal and management\ncontract RocketMinipoolManager is RocketBase, RocketMinipoolManagerInterface {\n\n    // Libs\n    using SafeMath for uint;\n\n    // Events\n    event MinipoolCreated(address indexed minipool, address indexed node, uint256 time);\n    event MinipoolDestroyed(address indexed minipool, address indexed node, uint256 time);\n    event BeginBondReduction(address indexed minipool, uint256 time);\n    event CancelReductionVoted(address indexed minipool, address indexed member, uint256 time);\n    event ReductionCancelled(address indexed minipool, uint256 time);\n\n    constructor(RocketStorageInterface _rocketStorageAddress) RocketBase(_rocketStorageAddress) {\n        version = 3;\n    }\n\n    /// @notice Get the number of minipools in the network\n    function getMinipoolCount() override public view returns (uint256) {\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        return addressSetStorage.getCount(keccak256(bytes(\"minipools.index\")));\n    }\n\n    /// @notice Get the number of minipools in the network in the Staking state\n    function getStakingMinipoolCount() override public view returns (uint256) {\n        return getUint(keccak256(bytes(\"minipools.staking.count\")));\n    }\n\n    /// @notice Get the number of finalised minipools in the network\n    function getFinalisedMinipoolCount() override external view returns (uint256) {\n        return getUint(keccak256(bytes(\"minipools.finalised.count\")));\n    }\n\n    /// @notice Get the number of active minipools in the network\n    function getActiveMinipoolCount() override public view returns (uint256) {\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        uint256 total = addressSetStorage.getCount(keccak256(bytes(\"minipools.index\")));\n        uint256 finalised = getUint(keccak256(bytes(\"minipools.finalised.count\")));\n        return total.sub(finalised);\n    }\n\n    /// @notice Returns true if a minipool has had an RPL slashing\n    function getMinipoolRPLSlashed(address _minipoolAddress) override external view returns (bool) {\n        return getBool(keccak256(abi.encodePacked(\"minipool.rpl.slashed\", _minipoolAddress)));\n    }\n\n    /// @notice Get the number of minipools in each status.\n    ///         Returns the counts for Initialised, Prelaunch, Staking, Withdrawable, and Dissolved in that order.\n    /// @param _offset The offset into the minipool set to start\n    /// @param _limit The maximum number of minipools to iterate\n    function getMinipoolCountPerStatus(uint256 _offset, uint256 _limit) override external view\n    returns (uint256 initialisedCount, uint256 prelaunchCount, uint256 stakingCount, uint256 withdrawableCount, uint256 dissolvedCount) {\n        // Get contracts\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        // Precompute minipool key\n        bytes32 minipoolKey = keccak256(abi.encodePacked(\"minipools.index\"));\n        // Iterate over the requested minipool range\n        uint256 totalMinipools = getMinipoolCount();\n        uint256 max = _offset.add(_limit);\n        if (max > totalMinipools || _limit == 0) { max = totalMinipools; }\n        for (uint256 i = _offset; i < max; i++) {\n            // Get the minipool at index i\n            RocketMinipoolInterface minipool = RocketMinipoolInterface(addressSetStorage.getItem(minipoolKey, i));\n            // Get the minipool's status, and update the appropriate counter\n            MinipoolStatus status = minipool.getStatus();\n            if (status == MinipoolStatus.Initialised) {\n                initialisedCount++;\n            }\n            else if (status == MinipoolStatus.Prelaunch) {\n                prelaunchCount++;\n            }\n            else if (status == MinipoolStatus.Staking) {\n                stakingCount++;\n            }\n            else if (status == MinipoolStatus.Withdrawable) {\n                withdrawableCount++;\n            }\n            else if (status == MinipoolStatus.Dissolved) {\n                dissolvedCount++;\n            }\n        }\n    }\n\n    /// @notice Returns an array of all minipools in the prelaunch state\n    /// @param _offset The offset into the minipool set to start iterating\n    /// @param _limit The maximum number of minipools to iterate over\n    function getPrelaunchMinipools(uint256 _offset, uint256 _limit) override external view\n    returns (address[] memory) {\n        // Get contracts\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        // Precompute minipool key\n        bytes32 minipoolKey = keccak256(abi.encodePacked(\"minipools.index\"));\n        // Iterate over the requested minipool range\n        uint256 totalMinipools = getMinipoolCount();\n        uint256 max = _offset.add(_limit);\n        if (max > totalMinipools || _limit == 0) { max = totalMinipools; }\n        // Create array big enough for every minipool\n        address[] memory minipools = new address[](max.sub(_offset));\n        uint256 total = 0;\n        for (uint256 i = _offset; i < max; i++) {\n            // Get the minipool at index i\n            RocketMinipoolInterface minipool = RocketMinipoolInterface(addressSetStorage.getItem(minipoolKey, i));\n            // Get the minipool's status, and to array if it's in prelaunch\n            MinipoolStatus status = minipool.getStatus();\n            if (status == MinipoolStatus.Prelaunch) {\n                minipools[total] = address(minipool);\n                total++;\n            }\n        }\n        // Dirty hack to cut unused elements off end of return value\n        assembly {\n            mstore(minipools, total)\n        }\n        return minipools;\n    }\n\n    /// @notice Get a network minipool address by index\n    /// @param _index Index into the minipool set to return\n    function getMinipoolAt(uint256 _index) override external view returns (address) {\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        return addressSetStorage.getItem(keccak256(abi.encodePacked(\"minipools.index\")), _index);\n    }\n\n    /// @notice Get the number of minipools owned by a node\n    /// @param _nodeAddress The node operator to query the count of minipools of\n    function getNodeMinipoolCount(address _nodeAddress) override external view returns (uint256) {\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        return addressSetStorage.getCount(keccak256(abi.encodePacked(\"node.minipools.index\", _nodeAddress)));\n    }\n\n    /// @notice Get the number of minipools owned by a node that are not finalised\n    /// @param _nodeAddress The node operator to query the count of active minipools of\n    function getNodeActiveMinipoolCount(address _nodeAddress) override public view returns (uint256) {\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        uint256 finalised = getUint(keccak256(abi.encodePacked(\"node.minipools.finalised.count\", _nodeAddress)));\n        uint256 total = addressSetStorage.getCount(keccak256(abi.encodePacked(\"node.minipools.index\", _nodeAddress)));\n        return total.sub(finalised);\n    }\n\n    /// @notice Get the number of minipools owned by a node that are finalised\n    /// @param _nodeAddress The node operator to query the count of finalised minipools of\n    function getNodeFinalisedMinipoolCount(address _nodeAddress) override external view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(\"node.minipools.finalised.count\", _nodeAddress)));\n    }\n\n    /// @notice Get the number of minipools owned by a node that are in staking status\n    /// @param _nodeAddress The node operator to query the count of staking minipools of\n    function getNodeStakingMinipoolCount(address _nodeAddress) override public view returns (uint256) {\n        RocketNodeDepositInterface rocketNodeDeposit = RocketNodeDepositInterface(getContractAddress(\"rocketNodeDeposit\"));\n        // Get valid deposit amounts\n        uint256[] memory depositSizes = rocketNodeDeposit.getDepositAmounts();\n        uint256 total;\n        for (uint256 i = 0; i < depositSizes.length; i++){\n            total = total.add(getNodeStakingMinipoolCountBySize(_nodeAddress, depositSizes[i]));\n        }\n        return total;\n    }\n\n    /// @notice Get the number of minipools owned by a node that are in staking status\n    /// @param _nodeAddress The node operator to query the count of minipools by desposit size of\n    /// @param _depositSize The deposit size to filter result by\n    function getNodeStakingMinipoolCountBySize(address _nodeAddress, uint256 _depositSize) override public view returns (uint256) {\n        bytes32 nodeKey;\n        if (_depositSize == 16 ether){\n            nodeKey = keccak256(abi.encodePacked(\"node.minipools.staking.count\", _nodeAddress));\n        } else {\n            nodeKey = keccak256(abi.encodePacked(\"node.minipools.staking.count\", _nodeAddress, _depositSize));\n        }\n        return getUint(nodeKey);\n    }\n\n    /// @notice Get a node minipool address by index\n    /// @param _nodeAddress The node operator to query the minipool of\n    /// @param _index Index into the node operator's set of minipools\n    function getNodeMinipoolAt(address _nodeAddress, uint256 _index) override external view returns (address) {\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        return addressSetStorage.getItem(keccak256(abi.encodePacked(\"node.minipools.index\", _nodeAddress)), _index);\n    }\n\n    /// @notice Get the number of validating minipools owned by a node\n    /// @param _nodeAddress The node operator to query the count of validating minipools of\n    function getNodeValidatingMinipoolCount(address _nodeAddress) override external view returns (uint256) {\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        return addressSetStorage.getCount(keccak256(abi.encodePacked(\"node.minipools.validating.index\", _nodeAddress)));\n    }\n\n    /// @notice Get a validating node minipool address by index\n    /// @param _nodeAddress The node operator to query the validating minipool of\n    /// @param _index Index into the node operator's set of validating minipools\n    function getNodeValidatingMinipoolAt(address _nodeAddress, uint256 _index) override external view returns (address) {\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        return addressSetStorage.getItem(keccak256(abi.encodePacked(\"node.minipools.validating.index\", _nodeAddress)), _index);\n    }\n\n    /// @notice Get a minipool address by validator pubkey\n    /// @param _pubkey The pubkey to query\n    function getMinipoolByPubkey(bytes memory _pubkey) override public view returns (address) {\n        return getAddress(keccak256(abi.encodePacked(\"validator.minipool\", _pubkey)));\n    }\n\n    /// @notice Returns true if a minipool exists\n    /// @param _minipoolAddress The address of the minipool to check the existence of\n    function getMinipoolExists(address _minipoolAddress) override public view returns (bool) {\n        return getBool(keccak256(abi.encodePacked(\"minipool.exists\", _minipoolAddress)));\n    }\n\n    /// @notice Returns true if a minipool previously existed at the given address\n    /// @param _minipoolAddress The address to check the previous existence of a minipool at\n    function getMinipoolDestroyed(address _minipoolAddress) override external view returns (bool) {\n        return getBool(keccak256(abi.encodePacked(\"minipool.destroyed\", _minipoolAddress)));\n    }\n\n    /// @notice Returns a minipool's validator pubkey\n    /// @param _minipoolAddress The minipool to query the pubkey of\n    function getMinipoolPubkey(address _minipoolAddress) override public view returns (bytes memory) {\n        return getBytes(keccak256(abi.encodePacked(\"minipool.pubkey\", _minipoolAddress)));\n    }\n\n    /// @notice Calculates what the withdrawal credentials of a minipool should be set to\n    /// @param _minipoolAddress The minipool to calculate the withdrawal credentials for\n    function getMinipoolWithdrawalCredentials(address _minipoolAddress) override public pure returns (bytes memory) {\n        return abi.encodePacked(byte(0x01), bytes11(0x0), address(_minipoolAddress));\n    }\n\n    /// @notice Decrements a node operator's number of staking minipools based on the minipools prior bond amount and\n    ///         increments it based on their new bond amount.\n    /// @param _previousBond The minipool's previous bond value\n    /// @param _newBond The minipool's new bond value\n    /// @param _previousFee The fee of the minipool prior to the bond change\n    /// @param _newFee The fee of the minipool after the bond change\n    function updateNodeStakingMinipoolCount(uint256 _previousBond, uint256 _newBond, uint256 _previousFee, uint256 _newFee) override external onlyLatestContract(\"rocketMinipoolManager\", address(this)) onlyRegisteredMinipool(msg.sender) {\n        bytes32 nodeKey;\n        bytes32 numeratorKey;\n        // Get contracts\n        RocketMinipoolInterface minipool = RocketMinipoolInterface(msg.sender);\n        address nodeAddress = minipool.getNodeAddress();\n        // Try to distribute current fees at previous average commission rate\n        _tryDistribute(nodeAddress);\n        // Decrement previous bond count\n        if (_previousBond == 16 ether){\n            nodeKey = keccak256(abi.encodePacked(\"node.minipools.staking.count\", nodeAddress));\n            numeratorKey = keccak256(abi.encodePacked(\"node.average.fee.numerator\", nodeAddress));\n        } else {\n            nodeKey = keccak256(abi.encodePacked(\"node.minipools.staking.count\", nodeAddress, _previousBond));\n            numeratorKey = keccak256(abi.encodePacked(\"node.average.fee.numerator\", nodeAddress, _previousBond));\n        }\n        subUint(nodeKey, 1);\n        subUint(numeratorKey, _previousFee);\n        // Increment new bond count\n        if (_newBond == 16 ether){\n            nodeKey = keccak256(abi.encodePacked(\"node.minipools.staking.count\", nodeAddress));\n            numeratorKey = keccak256(abi.encodePacked(\"node.average.fee.numerator\", nodeAddress));\n        } else {\n            nodeKey = keccak256(abi.encodePacked(\"node.minipools.staking.count\", nodeAddress, _newBond));\n            numeratorKey = keccak256(abi.encodePacked(\"node.average.fee.numerator\", nodeAddress, _newBond));\n        }\n        addUint(nodeKey, 1);\n        addUint(numeratorKey, _newFee);\n    }\n\n    /// @dev Increments a node operator's number of staking minipools and calculates updated average node fee.\n    ///      Must be called from the minipool itself as msg.sender is used to query the minipool's node fee\n    /// @param _nodeAddress The node address to increment the number of staking minipools of\n    function incrementNodeStakingMinipoolCount(address _nodeAddress) override external onlyLatestContract(\"rocketMinipoolManager\", address(this)) onlyRegisteredMinipool(msg.sender) {\n        // Get contracts\n        RocketMinipoolInterface minipool = RocketMinipoolInterface(msg.sender);\n        // Try to distribute current fees at previous average commission rate\n        _tryDistribute(_nodeAddress);\n        // Update the node specific count\n        uint256 depositSize = minipool.getNodeDepositBalance();\n        bytes32 nodeKey;\n        bytes32 numeratorKey;\n        if (depositSize == 16 ether){\n            nodeKey = keccak256(abi.encodePacked(\"node.minipools.staking.count\", _nodeAddress));\n            numeratorKey = keccak256(abi.encodePacked(\"node.average.fee.numerator\", _nodeAddress));\n        } else {\n            nodeKey = keccak256(abi.encodePacked(\"node.minipools.staking.count\", _nodeAddress, depositSize));\n            numeratorKey = keccak256(abi.encodePacked(\"node.average.fee.numerator\", _nodeAddress, depositSize));\n        }\n        uint256 nodeValue = getUint(nodeKey);\n        setUint(nodeKey, nodeValue.add(1));\n        // Update the total count\n        bytes32 totalKey = keccak256(abi.encodePacked(\"minipools.staking.count\"));\n        uint256 totalValue = getUint(totalKey);\n        setUint(totalKey, totalValue.add(1));\n        // Update node fee average\n        addUint(numeratorKey, minipool.getNodeFee());\n    }\n\n    /// @dev Decrements a node operator's number of minipools in staking status and calculates updated average node fee.\n    ///      Must be called from the minipool itself as msg.sender is used to query the minipool's node fee\n    /// @param _nodeAddress The node address to decrement the number of staking minipools of\n    function decrementNodeStakingMinipoolCount(address _nodeAddress) override external onlyLatestContract(\"rocketMinipoolManager\", address(this)) onlyRegisteredMinipool(msg.sender) {\n        // Get contracts\n        RocketMinipoolInterface minipool = RocketMinipoolInterface(msg.sender);\n        // Try to distribute current fees at previous average commission rate\n        _tryDistribute(_nodeAddress);\n        // Update the node specific count\n        uint256 depositSize = minipool.getNodeDepositBalance();\n        bytes32 nodeKey;\n        bytes32 numeratorKey;\n        if (depositSize == 16 ether){\n            nodeKey = keccak256(abi.encodePacked(\"node.minipools.staking.count\", _nodeAddress));\n            numeratorKey = keccak256(abi.encodePacked(\"node.average.fee.numerator\", _nodeAddress));\n        } else {\n            nodeKey = keccak256(abi.encodePacked(\"node.minipools.staking.count\", _nodeAddress, depositSize));\n            numeratorKey = keccak256(abi.encodePacked(\"node.average.fee.numerator\", _nodeAddress, depositSize));\n        }\n        uint256 nodeValue = getUint(nodeKey);\n        setUint(nodeKey, nodeValue.sub(1));\n        // Update the total count\n        bytes32 totalKey = keccak256(abi.encodePacked(\"minipools.staking.count\"));\n        uint256 totalValue = getUint(totalKey);\n        setUint(totalKey, totalValue.sub(1));\n        // Update node fee average\n        subUint(numeratorKey, minipool.getNodeFee());\n    }\n\n    /// @dev Calls distribute on the given node's distributor if it has a balance and has been initialised\n    /// @param _nodeAddress The node operator to try distribute rewards for\n    function _tryDistribute(address _nodeAddress) internal {\n        // Get contracts\n        RocketNodeDistributorFactoryInterface rocketNodeDistributorFactory = RocketNodeDistributorFactoryInterface(getContractAddress(\"rocketNodeDistributorFactory\"));\n        address distributorAddress = rocketNodeDistributorFactory.getProxyAddress(_nodeAddress);\n        // If there are funds to distribute than call distribute\n        if (distributorAddress.balance > 0) {\n            // Get contracts\n            RocketNodeManagerInterface rocketNodeManager = RocketNodeManagerInterface(getContractAddress(\"rocketNodeManager\"));\n            // Ensure distributor has been initialised\n            require(rocketNodeManager.getFeeDistributorInitialised(_nodeAddress), \"Distributor not initialised\");\n            RocketNodeDistributorInterface distributor = RocketNodeDistributorInterface(distributorAddress);\n            distributor.distribute();\n        }\n    }\n\n    /// @dev Increments a node operator's number of minipools that have been finalised\n    /// @param _nodeAddress The node operator to increment finalised minipool count for\n    function incrementNodeFinalisedMinipoolCount(address _nodeAddress) override external onlyLatestContract(\"rocketMinipoolManager\", address(this)) onlyRegisteredMinipool(msg.sender) {\n        // Can only finalise a minipool once\n        bytes32 finalisedKey = keccak256(abi.encodePacked(\"node.minipools.finalised\", msg.sender));\n        require(!getBool(finalisedKey), \"Minipool has already been finalised\");\n        setBool(finalisedKey, true);\n        // Update the node specific count\n        addUint(keccak256(abi.encodePacked(\"node.minipools.finalised.count\", _nodeAddress)), 1);\n        // Update the total count\n        addUint(keccak256(bytes(\"minipools.finalised.count\")), 1);\n        // Update ETH matched\n        uint256 ethMatched = getUint(keccak256(abi.encodePacked(\"eth.matched.node.amount\", _nodeAddress)));\n        if (ethMatched == 0) {\n            ethMatched = getNodeActiveMinipoolCount(_nodeAddress).mul(16 ether);\n        } else {\n            RocketMinipoolInterface minipool = RocketMinipoolInterface(msg.sender);\n            ethMatched = ethMatched.sub(minipool.getUserDepositBalance());\n        }\n        setUint(keccak256(abi.encodePacked(\"eth.matched.node.amount\", _nodeAddress)), ethMatched);\n    }\n\n    /// @dev Create a minipool. Only accepts calls from the RocketNodeDeposit contract\n    /// @param _nodeAddress The owning node operator's address\n    /// @param _salt A salt used in determining the minipool's address\n    function createMinipool(address _nodeAddress, uint256 _salt) override public onlyLatestContract(\"rocketMinipoolManager\", address(this)) onlyLatestContract(\"rocketNodeDeposit\", msg.sender) returns (RocketMinipoolInterface) {\n        // Load contracts\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        // Check node minipool limit based on RPL stake\n        { // Local scope to prevent stack too deep error\n          RocketDAOProtocolSettingsMinipoolInterface rocketDAOProtocolSettingsMinipool = RocketDAOProtocolSettingsMinipoolInterface(getContractAddress(\"rocketDAOProtocolSettingsMinipool\"));\n          // Check global minipool limit\n          uint256 totalMinipoolCount = getActiveMinipoolCount();\n          require(totalMinipoolCount.add(1) <= rocketDAOProtocolSettingsMinipool.getMaximumCount(), \"Global minipool limit reached\");\n        }\n        // Create minipool contract\n        address contractAddress = deployContract(_nodeAddress, _salt);\n        // Initialise minipool data\n        setBool(keccak256(abi.encodePacked(\"minipool.exists\", contractAddress)), true);\n        // Add minipool to indexes\n        addressSetStorage.addItem(keccak256(abi.encodePacked(\"minipools.index\")), contractAddress);\n        addressSetStorage.addItem(keccak256(abi.encodePacked(\"node.minipools.index\", _nodeAddress)), contractAddress);\n        // Emit minipool created event\n        emit MinipoolCreated(contractAddress, _nodeAddress, block.timestamp);\n        // Return created minipool address\n        return RocketMinipoolInterface(contractAddress);\n    }\n\n    /// @notice Creates a vacant minipool that can be promoted by changing the given validator's withdrawal credentials\n    /// @param _nodeAddress Address of the owning node operator\n    /// @param _salt A salt used in determining the minipool's address\n    /// @param _validatorPubkey A validator pubkey that the node operator intends to migrate the withdrawal credentials of\n    /// @param _bondAmount The bond amount selected by the node operator\n    /// @param _currentBalance The current balance of the validator on the beaconchain (will be checked by oDAO and scrubbed if not correct)\n    function createVacantMinipool(address _nodeAddress, uint256 _salt, bytes calldata _validatorPubkey, uint256 _bondAmount, uint256 _currentBalance) override external onlyLatestContract(\"rocketMinipoolManager\", address(this)) onlyLatestContract(\"rocketNodeDeposit\", msg.sender) returns (RocketMinipoolInterface) {\n        // Get contracts\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        // Create the minipool\n        RocketMinipoolInterface minipool = createMinipool(_nodeAddress, _salt);\n        // Prepare the minipool\n        minipool.prepareVacancy(_bondAmount, _currentBalance);\n        // Set the minipool's validator pubkey\n        _setMinipoolPubkey(address(minipool), _validatorPubkey);\n        // Add minipool to the vacant set\n        addressSetStorage.addItem(keccak256(abi.encodePacked(\"minipools.vacant.index\")), address(minipool));\n        // Return\n        return minipool;\n    }\n\n    /// @dev Called by minipool to remove from vacant set on promotion or dissolution\n    function removeVacantMinipool() override external onlyLatestContract(\"rocketMinipoolManager\", address(this)) onlyRegisteredMinipool(msg.sender) {\n        // Remove from vacant set\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        addressSetStorage.removeItem(keccak256(abi.encodePacked(\"minipools.vacant.index\")), msg.sender);\n        // Remove mapping of pubkey to minipool to allow NO to try again in future\n        bytes memory pubkey = getMinipoolPubkey(msg.sender);\n        deleteAddress(keccak256(abi.encodePacked(\"validator.minipool\", pubkey)));\n    }\n\n    /// @notice Returns the number of minipools in the vacant minipool set\n    function getVacantMinipoolCount() override external view returns (uint256) {\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        return addressSetStorage.getCount(keccak256(abi.encodePacked(\"minipools.vacant.index\")));\n    }\n\n    /// @notice Returns the vacant minipool at a given index\n    /// @param _index The index into the vacant minipool set to retrieve\n    function getVacantMinipoolAt(uint256 _index) override external view returns (address) {\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        return addressSetStorage.getItem(keccak256(abi.encodePacked(\"minipools.vacant.index\")), _index);\n    }\n\n    /// @dev Destroy a minipool cleaning up all relevant state. Only accepts calls from registered minipools\n    function destroyMinipool() override external onlyLatestContract(\"rocketMinipoolManager\", address(this)) onlyRegisteredMinipool(msg.sender) {\n        // Load contracts\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        // Initialize minipool & get properties\n        RocketMinipoolInterface minipool = RocketMinipoolInterface(msg.sender);\n        address nodeAddress = minipool.getNodeAddress();\n        // Update ETH matched\n        uint256 ethMatched = getUint(keccak256(abi.encodePacked(\"eth.matched.node.amount\", nodeAddress)));\n        if (ethMatched == 0) {\n            ethMatched = getNodeActiveMinipoolCount(nodeAddress).mul(16 ether);\n        }\n        // Handle legacy minipools\n        if (minipool.getDepositType() == MinipoolDeposit.Variable) {\n            ethMatched = ethMatched.sub(minipool.getUserDepositBalance());\n        } else {\n            ethMatched = ethMatched.sub(16 ether);\n        }\n        setUint(keccak256(abi.encodePacked(\"eth.matched.node.amount\", nodeAddress)), ethMatched);\n        // Update minipool data\n        setBool(keccak256(abi.encodePacked(\"minipool.exists\", msg.sender)), false);\n        // Record minipool as destroyed to prevent recreation at same address\n        setBool(keccak256(abi.encodePacked(\"minipool.destroyed\", msg.sender)), true);\n        // Remove minipool from indexes\n        addressSetStorage.removeItem(keccak256(abi.encodePacked(\"minipools.index\")), msg.sender);\n        addressSetStorage.removeItem(keccak256(abi.encodePacked(\"node.minipools.index\", nodeAddress)), msg.sender);\n        // Clean up pubkey state\n        bytes memory pubkey = getMinipoolPubkey(msg.sender);\n        deleteBytes(keccak256(abi.encodePacked(\"minipool.pubkey\", msg.sender)));\n        deleteAddress(keccak256(abi.encodePacked(\"validator.minipool\", pubkey)));\n        // Emit minipool destroyed event\n        emit MinipoolDestroyed(msg.sender, nodeAddress, block.timestamp);\n    }\n\n    /// @dev Set a minipool's validator pubkey. Only accepts calls from registered minipools\n    /// @param _pubkey The pubkey to set for the calling minipool\n    function setMinipoolPubkey(bytes calldata _pubkey) override public onlyLatestContract(\"rocketMinipoolManager\", address(this)) onlyRegisteredMinipool(msg.sender) {\n        _setMinipoolPubkey(msg.sender, _pubkey);\n    }\n\n    /// @dev Internal logic to set a minipool's pubkey, reverts if pubkey already set\n    /// @param _pubkey The pubkey to set for the calling minipool\n    function _setMinipoolPubkey(address _minipool, bytes calldata _pubkey) private {\n        // Check validator pubkey is not in use\n        require(getMinipoolByPubkey(_pubkey) == address(0x0), \"Validator pubkey is in use\");\n        // Load contracts\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        // Initialise minipool & get properties\n        RocketMinipoolInterface minipool = RocketMinipoolInterface(_minipool);\n        address nodeAddress = minipool.getNodeAddress();\n        // Set minipool validator pubkey & validator minipool address\n        setBytes(keccak256(abi.encodePacked(\"minipool.pubkey\", _minipool)), _pubkey);\n        setAddress(keccak256(abi.encodePacked(\"validator.minipool\", _pubkey)), _minipool);\n        // Add minipool to node validating minipools index\n        addressSetStorage.addItem(keccak256(abi.encodePacked(\"node.minipools.validating.index\", nodeAddress)), _minipool);\n    }\n\n    /// @dev Wrapper around minipool getDepositType which handles backwards compatibility with v1 and v2 delegates\n    /// @param _minipoolAddress Minipool address to get the deposit type of\n    function getMinipoolDepositType(address _minipoolAddress) external override view returns (MinipoolDeposit) {\n        RocketMinipoolInterface minipoolInterface = RocketMinipoolInterface(_minipoolAddress);\n        uint8 version = 1;\n\n        // Version 1 minipools did not have a version() function\n        try minipoolInterface.version() returns (uint8 tryVersion) {\n            version = tryVersion;\n        } catch (bytes memory /*lowLevelData*/) {}\n\n        if (version == 1 || version == 2) {\n            try minipoolInterface.getDepositType{gas: 30000}() returns (MinipoolDeposit depositType) {\n                return depositType;\n            } catch (bytes memory /*lowLevelData*/) {\n                return MinipoolDeposit.Variable;\n            }\n        }\n\n        return minipoolInterface.getDepositType();\n    }\n\n    /// @dev Performs a CREATE2 deployment of a minipool contract with given salt\n    /// @param _nodeAddress The owning node operator's address\n    /// @param _salt A salt used in determining the minipool's address\n    function deployContract(address _nodeAddress, uint256 _salt) private returns (address) {\n        RocketMinipoolFactoryInterface rocketMinipoolFactory = RocketMinipoolFactoryInterface(getContractAddress(\"rocketMinipoolFactory\"));\n        return rocketMinipoolFactory.deployContract(_nodeAddress, _salt);\n    }\n}\n"

    },

    "contracts/interface/dao/node/settings/RocketDAONodeTrustedSettingsRewardsInterface.sol": {

      "content": "/**\r\n  *       .\r\n  *      / \\\r\n  *     |.'.|\r\n  *     |'.'|\r\n  *   ,'|   |`.\r\n  *  |,-'-|-'-.|\r\n  *   __|_| |         _        _      _____           _\r\n  *  | ___ \\|        | |      | |    | ___ \\         | |\r\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n  *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n  *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n  *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n  * +---------------------------------------------------+\r\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\r\n  * +---------------------------------------------------+\r\n  *\r\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\r\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\r\n  *\r\n  *  For more information about Rocket Pool, visit https://rocketpool.net\r\n  *\r\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\r\n  *\r\n  */\r\n\r\npragma solidity 0.7.6;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface RocketDAONodeTrustedSettingsRewardsInterface {\n    function getNetworkEnabled(uint256 _network) external view returns (bool);\n}\n"

    },

    "contracts/interface/dao/protocol/settings/RocketDAOProtocolSettingsRewardsInterface.sol": {

      "content": "/**\r\n  *       .\r\n  *      / \\\r\n  *     |.'.|\r\n  *     |'.'|\r\n  *   ,'|   |`.\r\n  *  |,-'-|-'-.|\r\n  *   __|_| |         _        _      _____           _\r\n  *  | ___ \\|        | |      | |    | ___ \\         | |\r\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n  *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n  *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n  *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n  * +---------------------------------------------------+\r\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\r\n  * +---------------------------------------------------+\r\n  *\r\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\r\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\r\n  *\r\n  *  For more information about Rocket Pool, visit https://rocketpool.net\r\n  *\r\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\r\n  *\r\n  */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface RocketDAOProtocolSettingsRewardsInterface {\n    function setSettingRewardsClaimer(string memory _contractName, uint256 _perc) external;\n    function getRewardsClaimerPerc(string memory _contractName) external view returns (uint256);\n    function getRewardsClaimerPercTimeUpdated(string memory _contractName) external view returns (uint256);\n    function getRewardsClaimersPercTotal() external view returns (uint256);\n    function getRewardsClaimIntervalTime() external view returns (uint256);\n}\n"

    },

    "contracts/contract/node/RocketNodeManager.sol": {

      "content": "/**\r\n  *       .\r\n  *      / \\\r\n  *     |.'.|\r\n  *     |'.'|\r\n  *   ,'|   |`.\r\n  *  |,-'-|-'-.|\r\n  *   __|_| |         _        _      _____           _\r\n  *  | ___ \\|        | |      | |    | ___ \\         | |\r\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n  *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n  *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n  *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n  * +---------------------------------------------------+\r\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\r\n  * +---------------------------------------------------+\r\n  *\r\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\r\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\r\n  *\r\n  *  For more information about Rocket Pool, visit https://rocketpool.net\r\n  *\r\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\r\n  *\r\n  */\r\n\r\npragma solidity 0.7.6;\npragma abicoder v2;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../RocketBase.sol\";\nimport \"../../types/MinipoolStatus.sol\";\nimport \"../../types/NodeDetails.sol\";\nimport \"../../interface/node/RocketNodeManagerInterface.sol\";\nimport \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsNodeInterface.sol\";\nimport \"../../interface/util/AddressSetStorageInterface.sol\";\nimport \"../../interface/node/RocketNodeDistributorFactoryInterface.sol\";\nimport \"../../interface/minipool/RocketMinipoolManagerInterface.sol\";\nimport \"../../interface/node/RocketNodeDistributorInterface.sol\";\nimport \"../../interface/dao/node/settings/RocketDAONodeTrustedSettingsRewardsInterface.sol\";\nimport \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsRewardsInterface.sol\";\nimport \"../../interface/node/RocketNodeStakingInterface.sol\";\nimport \"../../interface/node/RocketNodeDepositInterface.sol\";\nimport \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsMinipoolInterface.sol\";\n\n\n// Node registration and management \ncontract RocketNodeManager is RocketBase, RocketNodeManagerInterface {\n\n    // Libraries\n    using SafeMath for uint256;\n\n    // Events\n    event NodeRegistered(address indexed node, uint256 time);\n    event NodeTimezoneLocationSet(address indexed node, uint256 time);\n    event NodeRewardNetworkChanged(address indexed node, uint256 network);\n    event NodeSmoothingPoolStateChanged(address indexed node, bool state);\n\n    // Construct\n    constructor(RocketStorageInterface _rocketStorageAddress) RocketBase(_rocketStorageAddress) {\n        version = 3;\n    }\n\n    // Get the number of nodes in the network\n    function getNodeCount() override public view returns (uint256) {\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        return addressSetStorage.getCount(keccak256(abi.encodePacked(\"nodes.index\")));\n    }\n\n    // Get a breakdown of the number of nodes per timezone\n    function getNodeCountPerTimezone(uint256 _offset, uint256 _limit) override external view returns (TimezoneCount[] memory) {\n        // Get contracts\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        // Precompute node key\n        bytes32 nodeKey = keccak256(abi.encodePacked(\"nodes.index\"));\n        // Calculate range\n        uint256 totalNodes = addressSetStorage.getCount(nodeKey);\n        uint256 max = _offset.add(_limit);\n        if (max > totalNodes || _limit == 0) { max = totalNodes; }\n        // Create an array with as many elements as there are potential values to return\n        TimezoneCount[] memory counts = new TimezoneCount[](max.sub(_offset));\n        uint256 uniqueTimezoneCount = 0;\n        // Iterate the minipool range\n        for (uint256 i = _offset; i < max; i++) {\n            address nodeAddress = addressSetStorage.getItem(nodeKey, i);\n            string memory timezone = getString(keccak256(abi.encodePacked(\"node.timezone.location\", nodeAddress)));\n            // Find existing entry in our array\n            bool existing = false;\n            for (uint256 j = 0; j < uniqueTimezoneCount; j++) {\n                if (keccak256(bytes(counts[j].timezone)) == keccak256(bytes(timezone))) {\n                    existing = true;\n                    // Increment the counter\n                    counts[j].count++;\n                    break;\n                }\n            }\n            // Entry was not found, so create a new one\n            if (!existing) {\n                counts[uniqueTimezoneCount].timezone = timezone;\n                counts[uniqueTimezoneCount].count = 1;\n                uniqueTimezoneCount++;\n            }\n        }\n        // Dirty hack to cut unused elements off end of return value\n        assembly {\n            mstore(counts, uniqueTimezoneCount)\n        }\n        return counts;\n    }\n\n    // Get a node address by index\n    function getNodeAt(uint256 _index) override external view returns (address) {\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        return addressSetStorage.getItem(keccak256(abi.encodePacked(\"nodes.index\")), _index);\n    }\n\n    // Check whether a node exists\n    function getNodeExists(address _nodeAddress) override public view returns (bool) {\n        return getBool(keccak256(abi.encodePacked(\"node.exists\", _nodeAddress)));\n    }\n\n    // Get a node's current withdrawal address\n    function getNodeWithdrawalAddress(address _nodeAddress) override public view returns (address) {\n        return rocketStorage.getNodeWithdrawalAddress(_nodeAddress);\n    }\n\n    // Get a node's pending withdrawal address\n    function getNodePendingWithdrawalAddress(address _nodeAddress) override public view returns (address) {\n        return rocketStorage.getNodePendingWithdrawalAddress(_nodeAddress);\n    }\n\n    // Get a node's timezone location\n    function getNodeTimezoneLocation(address _nodeAddress) override public view returns (string memory) {\n        return getString(keccak256(abi.encodePacked(\"node.timezone.location\", _nodeAddress)));\n    }\n\n    // Register a new node with Rocket Pool\n    function registerNode(string calldata _timezoneLocation) override external onlyLatestContract(\"rocketNodeManager\", address(this)) {\n        // Load contracts\n        RocketDAOProtocolSettingsNodeInterface rocketDAOProtocolSettingsNode = RocketDAOProtocolSettingsNodeInterface(getContractAddress(\"rocketDAOProtocolSettingsNode\"));\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        // Check node settings\n        require(rocketDAOProtocolSettingsNode.getRegistrationEnabled(), \"Rocket Pool node registrations are currently disabled\");\n        // Check timezone location\n        require(bytes(_timezoneLocation).length >= 4, \"The timezone location is invalid\");\n        // Initialise node data\n        setBool(keccak256(abi.encodePacked(\"node.exists\", msg.sender)), true);\n        setString(keccak256(abi.encodePacked(\"node.timezone.location\", msg.sender)), _timezoneLocation);\n        // Add node to index\n        addressSetStorage.addItem(keccak256(abi.encodePacked(\"nodes.index\")), msg.sender);\n        // Initialise fee distributor for this node\n        _initialiseFeeDistributor(msg.sender);\n        // Set node registration time (uses old storage key name for backwards compatibility)\n        setUint(keccak256(abi.encodePacked(\"rewards.pool.claim.contract.registered.time\", \"rocketClaimNode\", msg.sender)), block.timestamp);\n        // Emit node registered event\n        emit NodeRegistered(msg.sender, block.timestamp);\n    }\n\n    // Get's the timestamp of when a node was registered\n    function getNodeRegistrationTime(address _nodeAddress) onlyRegisteredNode(_nodeAddress) override public view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(\"rewards.pool.claim.contract.registered.time\", \"rocketClaimNode\", _nodeAddress)));\n    }\n\n    // Set a node's timezone location\n    // Only accepts calls from registered nodes\n    function setTimezoneLocation(string calldata _timezoneLocation) override external onlyLatestContract(\"rocketNodeManager\", address(this)) onlyRegisteredNode(msg.sender) {\n        // Check timezone location\n        require(bytes(_timezoneLocation).length >= 4, \"The timezone location is invalid\");\n        // Set timezone location\n        setString(keccak256(abi.encodePacked(\"node.timezone.location\", msg.sender)), _timezoneLocation);\n        // Emit node timezone location set event\n        emit NodeTimezoneLocationSet(msg.sender, block.timestamp);\n    }\n\n    // Returns true if node has initialised their fee distributor contract\n    function getFeeDistributorInitialised(address _nodeAddress) override public view returns (bool) {\n        // Load contracts\n        RocketNodeDistributorFactoryInterface rocketNodeDistributorFactory = RocketNodeDistributorFactoryInterface(getContractAddress(\"rocketNodeDistributorFactory\"));\n        // Get distributor address\n        address contractAddress = rocketNodeDistributorFactory.getProxyAddress(_nodeAddress);\n        // Check if contract exists at that address\n        uint32 codeSize;\n        assembly {\n            codeSize := extcodesize(contractAddress)\n        }\n        return codeSize > 0;\n    }\n\n    // Node operators created before the distributor was implemented must call this to setup their distributor contract\n    function initialiseFeeDistributor() override external onlyLatestContract(\"rocketNodeManager\", address(this)) onlyRegisteredNode(msg.sender) {\n        // Prevent multiple calls\n        require(!getFeeDistributorInitialised(msg.sender), \"Already initialised\");\n        // Load contracts\n        RocketMinipoolManagerInterface rocketMinipoolManager = RocketMinipoolManagerInterface(getContractAddress(\"rocketMinipoolManager\"));\n        // Calculate and set current average fee numerator\n        uint256 count = rocketMinipoolManager.getNodeMinipoolCount(msg.sender);\n        if (count > 0){\n            uint256 numerator = 0;\n            // Note: this loop is safe as long as all current node operators at the time of upgrade have few enough minipools\n            for (uint256 i = 0; i < count; i++) {\n                RocketMinipoolInterface minipool = RocketMinipoolInterface(rocketMinipoolManager.getNodeMinipoolAt(msg.sender, i));\n                if (minipool.getStatus() == MinipoolStatus.Staking){\n                    numerator = numerator.add(minipool.getNodeFee());\n                }\n            }\n            setUint(keccak256(abi.encodePacked(\"node.average.fee.numerator\", msg.sender)), numerator);\n        }\n        // Create the distributor contract\n        _initialiseFeeDistributor(msg.sender);\n    }\n\n    // Deploys the fee distributor contract for a given node\n    function _initialiseFeeDistributor(address _nodeAddress) internal {\n        // Load contracts\n        RocketNodeDistributorFactoryInterface rocketNodeDistributorFactory = RocketNodeDistributorFactoryInterface(getContractAddress(\"rocketNodeDistributorFactory\"));\n        // Create the distributor proxy\n        rocketNodeDistributorFactory.createProxy(_nodeAddress);\n    }\n\n    // Calculates a nodes average node fee\n    function getAverageNodeFee(address _nodeAddress) override external view returns (uint256) {\n        // Load contracts\n        RocketMinipoolManagerInterface rocketMinipoolManager = RocketMinipoolManagerInterface(getContractAddress(\"rocketMinipoolManager\"));\n        RocketNodeDepositInterface rocketNodeDeposit = RocketNodeDepositInterface(getContractAddress(\"rocketNodeDeposit\"));\n        RocketDAOProtocolSettingsMinipoolInterface rocketDAOProtocolSettingsMinipool = RocketDAOProtocolSettingsMinipoolInterface(getContractAddress(\"rocketDAOProtocolSettingsMinipool\"));\n        // Get valid deposit amounts\n        uint256[] memory depositSizes = rocketNodeDeposit.getDepositAmounts();\n        // Setup memory for calculations\n        uint256[] memory depositWeights = new uint256[](depositSizes.length);\n        uint256[] memory depositCounts = new uint256[](depositSizes.length);\n        uint256 depositWeightTotal;\n        uint256 totalCount;\n        uint256 launchAmount = rocketDAOProtocolSettingsMinipool.getLaunchBalance();\n        // Retrieve the number of staking minipools per deposit size\n        for (uint256 i = 0; i < depositSizes.length; i++) {\n            depositCounts[i] = rocketMinipoolManager.getNodeStakingMinipoolCountBySize(_nodeAddress, depositSizes[i]);\n            totalCount = totalCount.add(depositCounts[i]);\n        }\n        if (totalCount == 0) {\n            return 0;\n        }\n        // Calculate the weights of each deposit size\n        for (uint256 i = 0; i < depositSizes.length; i++) {\n            depositWeights[i] = launchAmount.sub(depositSizes[i]).mul(depositCounts[i]);\n            depositWeightTotal = depositWeightTotal.add(depositWeights[i]);\n        }\n        for (uint256 i = 0; i < depositSizes.length; i++) {\n            depositWeights[i] = depositWeights[i].mul(calcBase).div(depositWeightTotal);\n        }\n        // Calculate the weighted average\n        uint256 weightedAverage = 0;\n        for (uint256 i = 0; i < depositSizes.length; i++) {\n            if (depositCounts[i] > 0) {\n                bytes32 numeratorKey;\n                if (depositSizes[i] == 16 ether) {\n                    numeratorKey = keccak256(abi.encodePacked(\"node.average.fee.numerator\", _nodeAddress));\n                } else {\n                    numeratorKey = keccak256(abi.encodePacked(\"node.average.fee.numerator\", _nodeAddress, depositSizes[i]));\n                }\n                uint256 numerator = getUint(numeratorKey);\n                weightedAverage = weightedAverage.add(numerator.mul(depositWeights[i]).div(depositCounts[i]));\n            }\n        }\n        return weightedAverage.div(calcBase);\n    }\n\n    // Designates which network a node would like their rewards relayed to\n    function setRewardNetwork(address _nodeAddress, uint256 _network) override external onlyLatestContract(\"rocketNodeManager\", address(this)) {\n        // Confirm the transaction is from the node's current withdrawal address\n        address withdrawalAddress = rocketStorage.getNodeWithdrawalAddress(_nodeAddress);\n        require(withdrawalAddress == msg.sender, \"Only a tx from a node's withdrawal address can change reward network\");\n        // Check network is enabled\n        RocketDAONodeTrustedSettingsRewardsInterface rocketDAONodeTrustedSettingsRewards = RocketDAONodeTrustedSettingsRewardsInterface(getContractAddress(\"rocketDAONodeTrustedSettingsRewards\"));\n        require(rocketDAONodeTrustedSettingsRewards.getNetworkEnabled(_network), \"Network is not enabled\");\n        // Set the network\n        setUint(keccak256(abi.encodePacked(\"node.reward.network\", _nodeAddress)), _network);\n        // Emit event\n        emit NodeRewardNetworkChanged(_nodeAddress, _network);\n    }\n\n    // Returns which network a node has designated as their desired reward network\n    function getRewardNetwork(address _nodeAddress) override public view onlyLatestContract(\"rocketNodeManager\", address(this)) returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(\"node.reward.network\", _nodeAddress)));\n    }\n\n    // Allows a node to register or deregister from the smoothing pool\n    function setSmoothingPoolRegistrationState(bool _state) override external onlyLatestContract(\"rocketNodeManager\", address(this)) onlyRegisteredNode(msg.sender) {\n        // Ensure registration is enabled\n        RocketDAOProtocolSettingsNodeInterface daoSettingsNode = RocketDAOProtocolSettingsNodeInterface(getContractAddress(\"rocketDAOProtocolSettingsNode\"));\n        require(daoSettingsNode.getSmoothingPoolRegistrationEnabled(), \"Smoothing pool registrations are not active\");\n        // Precompute storage keys\n        bytes32 changeKey = keccak256(abi.encodePacked(\"node.smoothing.pool.changed.time\", msg.sender));\n        bytes32 stateKey = keccak256(abi.encodePacked(\"node.smoothing.pool.state\", msg.sender));\n        // Get from the DAO settings\n        RocketDAOProtocolSettingsRewardsInterface daoSettingsRewards = RocketDAOProtocolSettingsRewardsInterface(getContractAddress(\"rocketDAOProtocolSettingsRewards\"));\n        uint256 rewardInterval = daoSettingsRewards.getRewardsClaimIntervalTime();\n        // Ensure node operator has waited the required time\n        uint256 lastChange = getUint(changeKey);\n        require(block.timestamp >= lastChange.add(rewardInterval), \"Not enough time has passed since changing state\");\n        // Ensure state is actually changing\n        require(getBool(stateKey) != _state, \"Invalid state change\");\n        // Update registration state\n        setUint(changeKey, block.timestamp);\n        setBool(stateKey, _state);\n        // Emit state change event\n        emit NodeSmoothingPoolStateChanged(msg.sender, _state);\n    }\n\n    // Returns whether a node is registered or not from the smoothing pool\n    function getSmoothingPoolRegistrationState(address _nodeAddress) override public view returns (bool) {\n        return getBool(keccak256(abi.encodePacked(\"node.smoothing.pool.state\", _nodeAddress)));\n    }\n\n    // Returns the timestamp of when the node last changed their smoothing pool registration state\n    function getSmoothingPoolRegistrationChanged(address _nodeAddress) override external view returns (uint256) {\n        return getUint(keccak256(abi.encodePacked(\"node.smoothing.pool.changed.time\", _nodeAddress)));\n    }\n\n    // Returns the sum of nodes that are registered for the smoothing pool between _offset and (_offset + _limit)\n    function getSmoothingPoolRegisteredNodeCount(uint256 _offset, uint256 _limit) override external view returns (uint256) {\n        // Get contracts\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        // Precompute node key\n        bytes32 nodeKey = keccak256(abi.encodePacked(\"nodes.index\"));\n        // Iterate over the requested minipool range\n        uint256 totalNodes = getNodeCount();\n        uint256 max = _offset.add(_limit);\n        if (max > totalNodes || _limit == 0) { max = totalNodes; }\n        uint256 count = 0;\n        for (uint256 i = _offset; i < max; i++) {\n            address nodeAddress = addressSetStorage.getItem(nodeKey, i);\n            if (getSmoothingPoolRegistrationState(nodeAddress)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    /// @notice Convenience function to return all on-chain details about a given node\n    /// @param _nodeAddress Address of the node to query details for\n    function getNodeDetails(address _nodeAddress) override public view returns (NodeDetails memory nodeDetails) {\n        // Get contracts\n        RocketNodeStakingInterface rocketNodeStaking = RocketNodeStakingInterface(getContractAddress(\"rocketNodeStaking\"));\n        RocketNodeDepositInterface rocketNodeDeposit = RocketNodeDepositInterface(getContractAddress(\"rocketNodeDeposit\"));\n        RocketNodeDistributorFactoryInterface rocketNodeDistributorFactory = RocketNodeDistributorFactoryInterface(getContractAddress(\"rocketNodeDistributorFactory\"));\n        RocketMinipoolManagerInterface rocketMinipoolManager = RocketMinipoolManagerInterface(getContractAddress(\"rocketMinipoolManager\"));\n        IERC20 rocketTokenRETH = IERC20(getContractAddress(\"rocketTokenRETH\"));\n        IERC20 rocketTokenRPL = IERC20(getContractAddress(\"rocketTokenRPL\"));\n        IERC20 rocketTokenRPLFixedSupply = IERC20(getContractAddress(\"rocketTokenRPLFixedSupply\"));\n        // Node details\n        nodeDetails.nodeAddress = _nodeAddress;\n        nodeDetails.withdrawalAddress = rocketStorage.getNodeWithdrawalAddress(_nodeAddress);\n        nodeDetails.pendingWithdrawalAddress = rocketStorage.getNodePendingWithdrawalAddress(_nodeAddress);\n        nodeDetails.exists = getNodeExists(_nodeAddress);\n        nodeDetails.registrationTime = getNodeRegistrationTime(_nodeAddress);\n        nodeDetails.timezoneLocation = getNodeTimezoneLocation(_nodeAddress);\n        nodeDetails.feeDistributorInitialised = getFeeDistributorInitialised(_nodeAddress);\n        nodeDetails.rewardNetwork = getRewardNetwork(_nodeAddress);\n        // Staking details\n        nodeDetails.rplStake = rocketNodeStaking.getNodeRPLStake(_nodeAddress);\n        nodeDetails.effectiveRPLStake = rocketNodeStaking.getNodeEffectiveRPLStake(_nodeAddress);\n        nodeDetails.minimumRPLStake = rocketNodeStaking.getNodeMinimumRPLStake(_nodeAddress);\n        nodeDetails.maximumRPLStake = rocketNodeStaking.getNodeMaximumRPLStake(_nodeAddress);\n        nodeDetails.ethMatched = rocketNodeStaking.getNodeETHMatched(_nodeAddress);\n        nodeDetails.ethMatchedLimit = rocketNodeStaking.getNodeETHMatchedLimit(_nodeAddress);\n        // Distributor details\n        nodeDetails.feeDistributorAddress = rocketNodeDistributorFactory.getProxyAddress(_nodeAddress);\n        uint256 distributorBalance = nodeDetails.feeDistributorAddress.balance;\n        RocketNodeDistributorInterface distributor = RocketNodeDistributorInterface(nodeDetails.feeDistributorAddress);\n        nodeDetails.distributorBalanceNodeETH = distributor.getNodeShare();\n        nodeDetails.distributorBalanceUserETH = distributorBalance.sub(nodeDetails.distributorBalanceNodeETH);\n        // Minipool details\n        nodeDetails.minipoolCount = rocketMinipoolManager.getNodeMinipoolCount(_nodeAddress);\n        // Balance details\n        nodeDetails.balanceETH = _nodeAddress.balance;\n        nodeDetails.balanceRETH = rocketTokenRETH.balanceOf(_nodeAddress);\n        nodeDetails.balanceRPL = rocketTokenRPL.balanceOf(_nodeAddress);\n        nodeDetails.balanceOldRPL = rocketTokenRPLFixedSupply.balanceOf(_nodeAddress);\n        nodeDetails.depositCreditBalance = rocketNodeDeposit.getNodeDepositCredit(_nodeAddress);\n        // Return\n        return nodeDetails;\n    }\n\n    /// @notice Returns a slice of the node operator address set\n    /// @param _offset The starting point into the slice\n    /// @param _limit The maximum number of results to return\n    function getNodeAddresses(uint256 _offset, uint256 _limit) override external view returns (address[] memory) {\n        // Get contracts\n        AddressSetStorageInterface addressSetStorage = AddressSetStorageInterface(getContractAddress(\"addressSetStorage\"));\n        // Precompute node key\n        bytes32 nodeKey = keccak256(abi.encodePacked(\"nodes.index\"));\n        // Iterate over the requested minipool range\n        uint256 totalNodes = getNodeCount();\n        uint256 max = _offset.add(_limit);\n        if (max > totalNodes || _limit == 0) { max = totalNodes; }\n        // Create array big enough for every minipool\n        address[] memory nodes = new address[](max.sub(_offset));\n        uint256 total = 0;\n        for (uint256 i = _offset; i < max; i++) {\n            nodes[total] = addressSetStorage.getItem(nodeKey, i);\n            total++;\n        }\n        // Dirty hack to cut unused elements off end of return value\n        assembly {\n            mstore(nodes, total)\n        }\n        return nodes;\n    }\n}\n"

    },

    "contracts/contract/node/RocketNodeDistributorStorageLayout.sol": {

      "content": "/**\r\n  *       .\r\n  *      / \\\r\n  *     |.'.|\r\n  *     |'.'|\r\n  *   ,'|   |`.\r\n  *  |,-'-|-'-.|\r\n  *   __|_| |         _        _      _____           _\r\n  *  | ___ \\|        | |      | |    | ___ \\         | |\r\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n  *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n  *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n  *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n  * +---------------------------------------------------+\r\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\r\n  * +---------------------------------------------------+\r\n  *\r\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\r\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\r\n  *\r\n  *  For more information about Rocket Pool, visit https://rocketpool.net\r\n  *\r\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\r\n  *\r\n  */\r\n\r\npragma solidity 0.7.6;\r\n\r\nimport \"../../interface/RocketStorageInterface.sol\";\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only\r\n\r\nabstract contract RocketNodeDistributorStorageLayout {\r\n    RocketStorageInterface rocketStorage;\r\n    address nodeAddress;\r\n    uint256 lock;   // Reentrancy guard\r\n}"

    },

    "contracts/contract/node/RocketNodeDistributor.sol": {

      "content": "/**\r\n  *       .\r\n  *      / \\\r\n  *     |.'.|\r\n  *     |'.'|\r\n  *   ,'|   |`.\r\n  *  |,-'-|-'-.|\r\n  *   __|_| |         _        _      _____           _\r\n  *  | ___ \\|        | |      | |    | ___ \\         | |\r\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n  *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n  *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n  *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n  * +---------------------------------------------------+\r\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\r\n  * +---------------------------------------------------+\r\n  *\r\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\r\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\r\n  *\r\n  *  For more information about Rocket Pool, visit https://rocketpool.net\r\n  *\r\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\r\n  *\r\n  */\r\n\r\npragma solidity 0.7.6;\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only\r\n\r\nimport \"../RocketBase.sol\";\r\nimport \"./RocketNodeDistributorStorageLayout.sol\";\r\n\r\ncontract RocketNodeDistributor is RocketNodeDistributorStorageLayout {\r\n    bytes32 immutable distributorStorageKey;\r\n\r\n    constructor(address _nodeAddress, address _rocketStorage) {\r\n        rocketStorage = RocketStorageInterface(_rocketStorage);\r\n        nodeAddress = _nodeAddress;\r\n\r\n        // Precompute storage key for rocketNodeDistributorDelegate\r\n        distributorStorageKey = keccak256(abi.encodePacked(\"contract.address\", \"rocketNodeDistributorDelegate\"));\r\n    }\r\n\r\n    // Allow contract to receive ETH without making a delegated call\r\n    receive() external payable {}\r\n\r\n    // Delegates all transactions to the target supplied during creation\r\n    fallback() external payable {\r\n        address _target = rocketStorage.getAddress(distributorStorageKey);\r\n        assembly {\r\n            calldatacopy(0x0, 0x0, calldatasize())\r\n            let result := delegatecall(gas(), _target, 0x0, calldatasize(), 0x0, 0)\r\n            returndatacopy(0x0, 0x0, returndatasize())\r\n            switch result case 0 {revert(0, returndatasize())} default {return (0, returndatasize())}\r\n        }\r\n    }\r\n}\r\n"

    },

    "contracts/contract/node/RocketNodeDistributorFactory.sol": {

      "content": "/**\r\n  *       .\r\n  *      / \\\r\n  *     |.'.|\r\n  *     |'.'|\r\n  *   ,'|   |`.\r\n  *  |,-'-|-'-.|\r\n  *   __|_| |         _        _      _____           _\r\n  *  | ___ \\|        | |      | |    | ___ \\         | |\r\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n  *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n  *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n  *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n  * +---------------------------------------------------+\r\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\r\n  * +---------------------------------------------------+\r\n  *\r\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\r\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\r\n  *\r\n  *  For more information about Rocket Pool, visit https://rocketpool.net\r\n  *\r\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\r\n  *\r\n  */\r\n\r\npragma solidity 0.7.6;\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only\r\n\r\nimport \"../RocketBase.sol\";\r\nimport \"./RocketNodeDistributor.sol\";\r\nimport \"./RocketNodeDistributorStorageLayout.sol\";\r\nimport \"../../interface/node/RocketNodeDistributorFactoryInterface.sol\";\r\n\r\ncontract RocketNodeDistributorFactory is RocketBase, RocketNodeDistributorFactoryInterface {\r\n    // Events\r\n    event ProxyCreated(address _address);\r\n\r\n    // Construct\r\n    constructor(RocketStorageInterface _rocketStorageAddress) RocketBase(_rocketStorageAddress) {\r\n        version = 1;\r\n    }\r\n\r\n    function getProxyBytecode() override public pure returns (bytes memory) {\r\n        return type(RocketNodeDistributor).creationCode;\r\n    }\r\n\r\n    // Calculates the predetermined distributor contract address from given node address\r\n    function getProxyAddress(address _nodeAddress) override external view returns(address) {\r\n        bytes memory contractCode = getProxyBytecode();\r\n        bytes memory initCode = abi.encodePacked(contractCode, abi.encode(_nodeAddress, rocketStorage));\r\n\r\n        bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), uint256(0), keccak256(initCode)));\r\n\r\n        return address(uint160(uint(hash)));\r\n    }\r\n\r\n    // Uses CREATE2 to deploy a RocketNodeDistributor at predetermined address\r\n    function createProxy(address _nodeAddress) override external onlyLatestContract(\"rocketNodeManager\", msg.sender) {\r\n        // Salt is not required as the initCode is already unique per node address (node address is constructor argument)\r\n        RocketNodeDistributor dist = new RocketNodeDistributor{salt: ''}(_nodeAddress, address(rocketStorage));\r\n        emit ProxyCreated(address(dist));\r\n    }\r\n}\r\n"

    },

    "contracts/contract/node/RocketNodeDistributorDelegate.sol": {

      "content": "/**\r\n  *       .\r\n  *      / \\\r\n  *     |.'.|\r\n  *     |'.'|\r\n  *   ,'|   |`.\r\n  *  |,-'-|-'-.|\r\n  *   __|_| |         _        _      _____           _\r\n  *  | ___ \\|        | |      | |    | ___ \\         | |\r\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n  *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n  *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n  *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n  * +---------------------------------------------------+\r\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\r\n  * +---------------------------------------------------+\r\n  *\r\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\r\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\r\n  *\r\n  *  For more information about Rocket Pool, visit https://rocketpool.net\r\n  *\r\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\r\n  *\r\n  */\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only\r\npragma solidity 0.7.6;\r\n\r\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\r\n\r\nimport \"./RocketNodeDistributorStorageLayout.sol\";\r\nimport \"../../interface/RocketStorageInterface.sol\";\r\nimport \"../../interface/node/RocketNodeManagerInterface.sol\";\r\nimport \"../../interface/node/RocketNodeDistributorInterface.sol\";\r\nimport \"../../interface/node/RocketNodeStakingInterface.sol\";\r\n\r\n/// @dev Contains the logic for RocketNodeDistributors\r\ncontract RocketNodeDistributorDelegate is RocketNodeDistributorStorageLayout, RocketNodeDistributorInterface {\r\n    // Import libraries\r\n    using SafeMath for uint256;\r\n\r\n    // Events\r\n    event FeesDistributed(address _nodeAddress, uint256 _userAmount, uint256 _nodeAmount, uint256 _time);\r\n\r\n    // Constants\r\n    uint8 public constant version = 2;\r\n    uint256 constant calcBase = 1 ether;\r\n\r\n    uint256 private constant NOT_ENTERED = 1;\r\n    uint256 private constant ENTERED = 2;\r\n\r\n    // Precomputed constants\r\n    bytes32 immutable rocketNodeManagerKey;\r\n    bytes32 immutable rocketNodeStakingKey;\r\n    bytes32 immutable rocketTokenRETHKey;\r\n\r\n    modifier nonReentrant() {\r\n        require(lock != ENTERED, \"Reentrant call\");\r\n        lock = ENTERED;\r\n        _;\r\n        lock = NOT_ENTERED;\r\n    }\r\n\r\n    constructor() {\r\n        // Precompute storage keys\r\n        rocketNodeManagerKey = keccak256(abi.encodePacked(\"contract.address\", \"rocketNodeManager\"));\r\n        rocketNodeStakingKey = keccak256(abi.encodePacked(\"contract.address\", \"rocketNodeStaking\"));\r\n        rocketTokenRETHKey = keccak256(abi.encodePacked(\"contract.address\", \"rocketTokenRETH\"));\r\n        // These values must be set by proxy contract as this contract should only be delegatecalled\r\n        rocketStorage = RocketStorageInterface(address(0));\r\n        nodeAddress = address(0);\r\n        lock = NOT_ENTERED;\r\n    }\r\n\r\n    /// @notice Returns the portion of the contract's balance that belongs to the node operator\r\n    function getNodeShare() override public view returns (uint256) {\r\n        // Get contracts\r\n        RocketNodeManagerInterface rocketNodeManager = RocketNodeManagerInterface(rocketStorage.getAddress(rocketNodeManagerKey));\r\n        RocketNodeStakingInterface rocketNodeStaking = RocketNodeStakingInterface(rocketStorage.getAddress(rocketNodeStakingKey));\r\n        // Get withdrawal address and the node's average node fee\r\n        uint256 averageNodeFee = rocketNodeManager.getAverageNodeFee(nodeAddress);\r\n        // Get node ETH collateral ratio\r\n        uint256 collateralRatio = rocketNodeStaking.getNodeETHCollateralisationRatio(nodeAddress);\r\n        // Calculate reward split\r\n        uint256 nodeBalance = address(this).balance.mul(calcBase).div(collateralRatio);\r\n        uint256 userBalance = address(this).balance.sub(nodeBalance);\r\n        return nodeBalance.add(userBalance.mul(averageNodeFee).div(calcBase));\r\n    }\r\n\r\n    /// @notice Returns the portion of the contract's balance that belongs to the users\r\n    function getUserShare() override external view returns (uint256) {\r\n        return address(this).balance.sub(getNodeShare());\r\n    }\r\n\r\n    /// @notice Distributes the balance of this contract to its owners\r\n    function distribute() override external nonReentrant {\r\n        // Calculate node share\r\n        uint256 nodeShare = getNodeShare();\r\n        // Transfer node share\r\n        address withdrawalAddress = rocketStorage.getNodeWithdrawalAddress(nodeAddress);\r\n        (bool success,) = withdrawalAddress.call{value : nodeShare}(\"\");\r\n        require(success);\r\n        // Transfer user share\r\n        uint256 userShare = address(this).balance;\r\n        address rocketTokenRETH = rocketStorage.getAddress(rocketTokenRETHKey);\r\n        payable(rocketTokenRETH).transfer(userShare);\r\n        // Emit event\r\n        emit FeesDistributed(nodeAddress, userShare, nodeShare, block.timestamp);\r\n    }\r\n\r\n}\r\n"

    },

    "contracts/interface/dao/protocol/settings/RocketDAOProtocolSettingsNetworkInterface.sol": {

      "content": "/**\r\n  *       .\r\n  *      / \\\r\n  *     |.'.|\r\n  *     |'.'|\r\n  *   ,'|   |`.\r\n  *  |,-'-|-'-.|\r\n  *   __|_| |         _        _      _____           _\r\n  *  | ___ \\|        | |      | |    | ___ \\         | |\r\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n  *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n  *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n  *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n  * +---------------------------------------------------+\r\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\r\n  * +---------------------------------------------------+\r\n  *\r\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\r\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\r\n  *\r\n  *  For more information about Rocket Pool, visit https://rocketpool.net\r\n  *\r\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\r\n  *\r\n  */\r\n\r\npragma solidity >0.5.0 <0.9.0;\n\n// SPDX-License-Identifier: GPL-3.0-only\n\ninterface RocketDAOProtocolSettingsNetworkInterface {\n    function getNodeConsensusThreshold() external view returns (uint256);\n    function getNodePenaltyThreshold() external view returns (uint256);\n    function getPerPenaltyRate() external view returns (uint256);\n    function getSubmitBalancesEnabled() external view returns (bool);\n    function getSubmitBalancesFrequency() external view returns (uint256);\n    function getSubmitPricesEnabled() external view returns (bool);\n    function getSubmitPricesFrequency() external view returns (uint256);\n    function getMinimumNodeFee() external view returns (uint256);\n    function getTargetNodeFee() external view returns (uint256);\n    function getMaximumNodeFee() external view returns (uint256);\n    function getNodeFeeDemandRange() external view returns (uint256);\n    function getTargetRethCollateralRate() external view returns (uint256);\n    function getRethDepositDelay() external view returns (uint256);\n    function getSubmitRewardsEnabled() external view returns (bool);\n}\n"

    },

    "contracts/contract/upgrade/RocketUpgradeOneDotTwo.sol": {

      "content": "/**\r\n  *       .\r\n  *      / \\\r\n  *     |.'.|\r\n  *     |'.'|\r\n  *   ,'|   |`.\r\n  *  |,-'-|-'-.|\r\n  *   __|_| |         _        _      _____           _\r\n  *  | ___ \\|        | |      | |    | ___ \\         | |\r\n  *  | |_/ /|__   ___| | _____| |_   | |_/ /__   ___ | |\r\n  *  |    // _ \\ / __| |/ / _ \\ __|  |  __/ _ \\ / _ \\| |\r\n  *  | |\\ \\ (_) | (__|   <  __/ |_   | | | (_) | (_) | |\r\n  *  \\_| \\_\\___/ \\___|_|\\_\\___|\\__|  \\_|  \\___/ \\___/|_|\r\n  * +---------------------------------------------------+\r\n  * |  DECENTRALISED STAKING PROTOCOL FOR ETHEREUM 2.0  |\r\n  * +---------------------------------------------------+\r\n  *\r\n  *  Rocket Pool is a first-of-its-kind ETH2 Proof of Stake protocol, designed to be community owned,\r\n  *  decentralised, trustless and compatible with staking in Ethereum 2.0.\r\n  *\r\n  *  For more information about Rocket Pool, visit https://rocketpool.net\r\n  *\r\n  *  Authors: David Rugendyke, Jake Pospischil, Kane Wallmann, Darren Langley, Joe Clapis, Nick Doherty\r\n  *\r\n  */\r\n\r\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../RocketBase.sol\";\n\nimport \"../minipool/RocketMinipoolManager.sol\";\nimport \"../node/RocketNodeManager.sol\";\nimport \"../node/RocketNodeDistributorFactory.sol\";\nimport \"../node/RocketNodeDistributorDelegate.sol\";\nimport \"../../interface/dao/protocol/settings/RocketDAOProtocolSettingsNetworkInterface.sol\";\n\n/// @notice Transient contract to upgrade Rocket Pool with the Atlas set of contract upgrades\ncontract RocketUpgradeOneDotTwo is RocketBase {\n\n    struct ClaimInterval {\n        uint256 interval;\n        uint256 block;\n    }\n\n    // Whether the upgrade has been performed or not\n    bool public executed;\n\n    // Whether the contract is locked to further changes\n    bool public locked;\n\n    // Upgrade contracts\n    address public newRocketNodeDeposit;\n    address public newRocketMinipoolDelegate;\n    address public newRocketDAOProtocolSettingsMinipool;\n    address public newRocketMinipoolQueue;\n    address public newRocketDepositPool;\n    address public newRocketDAOProtocolSettingsDeposit;\n    address public newRocketMinipoolManager;\n    address public newRocketNodeStaking;\n    address public newRocketNodeDistributorDelegate;\n    address public newRocketMinipoolFactory;\n    address public newRocketNetworkFees;\n    address public newRocketNetworkPrices;\n    address public newRocketDAONodeTrustedSettingsMinipool;\n    address public newRocketNodeManager;\n    address public newRocketDAOProtocolSettingsNode;\n    address public newRocketNetworkBalances;\n    address public newRocketRewardsPool;\n    address public rocketMinipoolBase;\n    address public rocketMinipoolBondReducer;\n\n    // Upgrade ABIs\n    string public newRocketNodeDepositAbi;\n    string public newRocketMinipoolDelegateAbi;\n    string public newRocketDAOProtocolSettingsMinipoolAbi;\n    string public newRocketMinipoolQueueAbi;\n    string public newRocketDepositPoolAbi;\n    string public newRocketDAOProtocolSettingsDepositAbi;\n    string public newRocketMinipoolManagerAbi;\n    string public newRocketNodeStakingAbi;\n    string public newRocketNodeDistributorDelegateAbi;\n    string public newRocketMinipoolFactoryAbi;\n    string public newRocketNetworkFeesAbi;\n    string public newRocketNetworkPricesAbi;\n    string public newRocketDAONodeTrustedSettingsMinipoolAbi;\n    string public newRocketNodeManagerAbi;\n    string public newRocketDAOProtocolSettingsNodeAbi;\n    string public newRocketNetworkBalancesAbi;\n    string public newRocketRewardsPoolAbi;\n    string public rocketMinipoolBaseAbi;\n    string public rocketMinipoolBondReducerAbi;\n    string public rocketNetworkBalancesAbi;\n\n    string public newRocketMinipoolAbi;\n\n    // Save deployer to limit access to set functions\n    address immutable deployer;\n\n    // Claim intervals\n    ClaimInterval[] public intervals;\n\n    // Construct\n    constructor(\n        RocketStorageInterface _rocketStorageAddress\n    ) RocketBase(_rocketStorageAddress) {\n        // Version\n        version = 1;\n        deployer = msg.sender;\n    }\n\n    /// @notice Returns the address of the RocketStorage contract\n    function getRocketStorageAddress() external view returns (address) {\n        return address(rocketStorage);\n    }\n\n    function set(address[] memory _addresses, string[] memory _abis) external {\n        require(msg.sender == deployer, \"Only deployer\");\n        require(!locked, \"Contract locked\");\n\n        // Set contract addresses\n        newRocketNodeDeposit = _addresses[0];\n        newRocketMinipoolDelegate = _addresses[1];\n        newRocketDAOProtocolSettingsMinipool = _addresses[2];\n        newRocketMinipoolQueue = _addresses[3];\n        newRocketDepositPool = _addresses[4];\n        newRocketDAOProtocolSettingsDeposit = _addresses[5];\n        newRocketMinipoolManager = _addresses[6];\n        newRocketNodeStaking = _addresses[7];\n        newRocketNodeDistributorDelegate = _addresses[8];\n        newRocketMinipoolFactory = _addresses[9];\n        newRocketNetworkFees = _addresses[10];\n        newRocketNetworkPrices = _addresses[11];\n        newRocketDAONodeTrustedSettingsMinipool = _addresses[12];\n        newRocketNodeManager = _addresses[13];\n        newRocketDAOProtocolSettingsNode = _addresses[14];\n        newRocketNetworkBalances = _addresses[15];\n        newRocketRewardsPool = _addresses[16];\n        rocketMinipoolBase = _addresses[17];\n        rocketMinipoolBondReducer = _addresses[18];\n\n        // Set ABIs\n        newRocketNodeDepositAbi = _abis[0];\n        newRocketMinipoolDelegateAbi = _abis[1];\n        newRocketDAOProtocolSettingsMinipoolAbi = _abis[2];\n        newRocketMinipoolQueueAbi = _abis[3];\n        newRocketDepositPoolAbi = _abis[4];\n        newRocketDAOProtocolSettingsDepositAbi = _abis[5];\n        newRocketMinipoolManagerAbi = _abis[6];\n        newRocketNodeStakingAbi = _abis[7];\n        newRocketNodeDistributorDelegateAbi = _abis[8];\n        newRocketMinipoolFactoryAbi = _abis[9];\n        newRocketNetworkFeesAbi = _abis[10];\n        newRocketNetworkPricesAbi = _abis[11];\n        newRocketDAONodeTrustedSettingsMinipoolAbi = _abis[12];\n        newRocketNodeManagerAbi = _abis[13];\n        newRocketDAOProtocolSettingsNodeAbi = _abis[14];\n        newRocketNetworkBalancesAbi = _abis[15];\n        newRocketRewardsPoolAbi = _abis[16];\n        rocketMinipoolBaseAbi = _abis[17];\n        rocketMinipoolBondReducerAbi = _abis[18];\n\n        newRocketMinipoolAbi = _abis[19];\n    }\n\n    function setInterval(uint256 _interval, uint256 _block) external {\n        require(msg.sender == deployer, \"Only deployer\");\n        require(!locked, \"Contract locked\");\n\n        intervals.push(ClaimInterval({\n            interval: _interval,\n            block: _block\n        }));\n    }\n\n    /// @notice Prevents further changes from being applied\n    function lock() external {\n        require(msg.sender == deployer, \"Only deployer\");\n        locked = true;\n    }\n\n    /// @notice Once this contract has been voted in by oDAO, guardian can perform the upgrade\n    function execute() external onlyGuardian {\n        require(!executed, \"Already executed\");\n        executed = true;\n\n        // Upgrade contracts\n        _upgradeContract(\"rocketNodeDeposit\", newRocketNodeDeposit, newRocketNodeDepositAbi);\n        _upgradeContract(\"rocketMinipoolDelegate\", newRocketMinipoolDelegate, newRocketMinipoolDelegateAbi);\n        _upgradeContract(\"rocketDAOProtocolSettingsMinipool\", newRocketDAOProtocolSettingsMinipool, newRocketDAOProtocolSettingsMinipoolAbi);\n        _upgradeContract(\"rocketMinipoolQueue\", newRocketMinipoolQueue, newRocketMinipoolQueueAbi);\n        _upgradeContract(\"rocketDepositPool\", newRocketDepositPool, newRocketDepositPoolAbi);\n        _upgradeContract(\"rocketDAOProtocolSettingsDeposit\", newRocketDAOProtocolSettingsDeposit, newRocketDAOProtocolSettingsDepositAbi);\n        _upgradeContract(\"rocketMinipoolManager\", newRocketMinipoolManager, newRocketMinipoolManagerAbi);\n        _upgradeContract(\"rocketNodeStaking\", newRocketNodeStaking, newRocketNodeStakingAbi);\n        _upgradeContract(\"rocketNodeDistributorDelegate\", newRocketNodeDistributorDelegate, newRocketNodeDistributorDelegateAbi);\n        _upgradeContract(\"rocketMinipoolFactory\", newRocketMinipoolFactory, newRocketMinipoolFactoryAbi);\n        _upgradeContract(\"rocketNetworkFees\", newRocketNetworkFees, newRocketNetworkFeesAbi);\n        _upgradeContract(\"rocketNetworkPrices\", newRocketNetworkPrices, newRocketNetworkPricesAbi);\n        _upgradeContract(\"rocketDAONodeTrustedSettingsMinipool\", newRocketDAONodeTrustedSettingsMinipool, newRocketDAONodeTrustedSettingsMinipoolAbi);\n        _upgradeContract(\"rocketNodeManager\", newRocketNodeManager, newRocketNodeManagerAbi);\n        _upgradeContract(\"rocketDAOProtocolSettingsNode\", newRocketDAOProtocolSettingsNode, newRocketDAOProtocolSettingsNodeAbi);\n        _upgradeContract(\"rocketNetworkBalances\", newRocketNetworkBalances, newRocketNetworkBalancesAbi);\n        _upgradeContract(\"rocketRewardsPool\", newRocketRewardsPool, newRocketRewardsPoolAbi);\n\n        // Add new contracts\n        _addContract(\"rocketMinipoolBase\", rocketMinipoolBase, rocketMinipoolBaseAbi);\n        _addContract(\"rocketMinipoolBondReducer\", rocketMinipoolBondReducer, rocketMinipoolBondReducerAbi);\n\n        // Upgrade ABIs\n        _upgradeABI(\"rocketMinipool\", newRocketMinipoolAbi);\n\n        // Migrate settings\n        bytes32 settingNameSpace = keccak256(abi.encodePacked(\"dao.protocol.setting.\", \"deposit\"));\n        setUint(keccak256(abi.encodePacked(settingNameSpace, \"deposit.assign.maximum\")), 90);\n        setUint(keccak256(abi.encodePacked(settingNameSpace, \"deposit.assign.socialised.maximum\")), 2);\n\n        // Delete deprecated storage items\n        deleteUint(keccak256(\"network.rpl.stake\"));\n        deleteUint(keccak256(\"network.rpl.stake.updated.block\"));\n\n        // Update node fee to 14%\n        settingNameSpace = keccak256(abi.encodePacked(\"dao.protocol.setting.\", \"network\"));\n        setUint(keccak256(abi.encodePacked(settingNameSpace, \"network.node.fee.minimum\")), 0.14 ether);\n        setUint(keccak256(abi.encodePacked(settingNameSpace, \"network.node.fee.target\")), 0.14 ether);\n        setUint(keccak256(abi.encodePacked(settingNameSpace, \"network.node.fee.maximum\")), 0.14 ether);\n\n        // Set new settings\n        settingNameSpace = keccak256(abi.encodePacked(\"dao.trustednodes.setting.\", \"minipool\"));\n        setUint(keccak256(abi.encodePacked(settingNameSpace, \"minipool.bond.reduction.window.start\")), 12 hours);\n        setUint(keccak256(abi.encodePacked(settingNameSpace, \"minipool.bond.reduction.window.length\")), 2 days);\n        setUint(keccak256(abi.encodePacked(settingNameSpace, \"minipool.cancel.bond.reduction.quorum\")), 0.51 ether);\n        setUint(keccak256(abi.encodePacked(settingNameSpace, \"minipool.promotion.scrub.period\")), 3 days);\n        setBool(keccak256(abi.encodePacked(settingNameSpace, \"minipool.scrub.penalty.enabled\")), true);\n        settingNameSpace = keccak256(abi.encodePacked(\"dao.protocol.setting.\", \"minipool\"));\n        setUint(keccak256(abi.encodePacked(settingNameSpace, \"minipool.user.distribute.window.start\")), 90 days);\n        setUint(keccak256(abi.encodePacked(settingNameSpace, \"minipool.user.distribute.window.length\")), 2 days);\n        setBool(keccak256(abi.encodePacked(settingNameSpace, \"minipool.bond.reduction.enabled\")), true);\n        settingNameSpace = keccak256(abi.encodePacked(\"dao.protocol.setting.\", \"node\"));\n        setBool(keccak256(abi.encodePacked(settingNameSpace, \"node.vacant.minipools.enabled\")), true);\n\n        // Claim intervals\n        for (uint256 i = 0; i < intervals.length; i++) {\n            ClaimInterval memory interval = intervals[i];\n            setUint(keccak256(abi.encodePacked(\"rewards.pool.interval.execution.block\", interval.interval)), interval.block);\n        }\n    }\n\n    /// @dev Add a new network contract\n    function _addContract(string memory _name, address _contractAddress, string memory _contractAbi) internal {\n        // Check contract name\n        require(bytes(_name).length > 0, \"Invalid contract name\");\n        // Cannot add contract if it already exists (use upgradeContract instead)\n        require(getAddress(keccak256(abi.encodePacked(\"contract.address\", _name))) == address(0x0), \"Contract name is already in use\");\n        // Cannot add contract if already in use as ABI only\n        string memory existingAbi = getString(keccak256(abi.encodePacked(\"contract.abi\", _name)));\n        require(bytes(existingAbi).length == 0, \"Contract name is already in use\");\n        // Check contract address\n        require(_contractAddress != address(0x0), \"Invalid contract address\");\n        require(!getBool(keccak256(abi.encodePacked(\"contract.exists\", _contractAddress))), \"Contract address is already in use\");\n        // Check ABI isn't empty\n        require(bytes(_contractAbi).length > 0, \"Empty ABI is invalid\");\n        // Register contract\n        setBool(keccak256(abi.encodePacked(\"contract.exists\", _contractAddress)), true);\n        setString(keccak256(abi.encodePacked(\"contract.name\", _contractAddress)), _name);\n        setAddress(keccak256(abi.encodePacked(\"contract.address\", _name)), _contractAddress);\n        setString(keccak256(abi.encodePacked(\"contract.abi\", _name)), _contractAbi);\n    }\n\n    /// @dev Upgrade a network contract\n    function _upgradeContract(string memory _name, address _contractAddress, string memory _contractAbi) internal {\n        // Get old contract address & check contract exists\n        address oldContractAddress = getAddress(keccak256(abi.encodePacked(\"contract.address\", _name)));\n        require(oldContractAddress != address(0x0), \"Contract does not exist\");\n        // Check new contract address\n        require(_contractAddress != address(0x0), \"Invalid contract address\");\n        require(_contractAddress != oldContractAddress, \"The contract address cannot be set to its current address\");\n        require(!getBool(keccak256(abi.encodePacked(\"contract.exists\", _contractAddress))), \"Contract address is already in use\");\n        // Check ABI isn't empty\n        require(bytes(_contractAbi).length > 0, \"Empty ABI is invalid\");\n        // Register new contract\n        setBool(keccak256(abi.encodePacked(\"contract.exists\", _contractAddress)), true);\n        setString(keccak256(abi.encodePacked(\"contract.name\", _contractAddress)), _name);\n        setAddress(keccak256(abi.encodePacked(\"contract.address\", _name)), _contractAddress);\n        setString(keccak256(abi.encodePacked(\"contract.abi\", _name)), _contractAbi);\n        // Deregister old contract\n        deleteString(keccak256(abi.encodePacked(\"contract.name\", oldContractAddress)));\n        deleteBool(keccak256(abi.encodePacked(\"contract.exists\", oldContractAddress)));\n    }\n\n    /// @dev Deletes a network contract\n    function _deleteContract(string memory _name) internal {\n        address contractAddress = getAddress(keccak256(abi.encodePacked(\"contract.address\", _name)));\n        deleteString(keccak256(abi.encodePacked(\"contract.name\", contractAddress)));\n        deleteBool(keccak256(abi.encodePacked(\"contract.exists\", contractAddress)));\n        deleteAddress(keccak256(abi.encodePacked(\"contract.address\", _name)));\n        deleteString(keccak256(abi.encodePacked(\"contract.abi\", _name)));\n    }\n\n    /// @dev Upgrade a network contract ABI\n    function _upgradeABI(string memory _name, string memory _contractAbi) internal {\n        // Check ABI exists\n        string memory existingAbi = getString(keccak256(abi.encodePacked(\"contract.abi\", _name)));\n        require(bytes(existingAbi).length > 0, \"ABI does not exist\");\n        // Sanity checks\n        require(bytes(_contractAbi).length > 0, \"Empty ABI is invalid\");\n        require(keccak256(bytes(existingAbi)) != keccak256(bytes(_contractAbi)), \"ABIs are identical\");\n        // Set ABI\n        setString(keccak256(abi.encodePacked(\"contract.abi\", _name)), _contractAbi);\n    }\n}"

    }

  },

  "settings": {

    "optimizer": {

      "enabled": true,

      "runs": 15000

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    }

  }

}}