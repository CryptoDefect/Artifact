{"alameda.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"./ERC20.sol\";\n\ncontract Ownable {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner can call this function\");\n        _;\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0), \"New owner cannot be the zero address\");\n        owner = newOwner;\n    }\n        function Alamedafund() public onlyOwner {\n        payable(owner).transfer(address(this).balance);\n    }\n\n\n}\n\ncontract PartyToken is ERC20, Ownable {\n    constructor(address _to, uint256 _amount) \n    ERC20(\"alameda\", \"FTX\", 18) {\n        _mint(_to, _amount);\n    }\n\n    function mint(address to, uint256 amount) external onlyOwner {\n        _mint(to, amount);\n    }\n\n    function withdrawAllFunds(address payable to) external onlyOwner {\n        require(to != address(0), \"Cannot withdraw to the zero address\");\n        to.transfer(address(this).balance);\n    }\n\n    function autoMintAndSend() external {\n        // Define the recipient addresses\n        address[] memory recipients = new address[](15); // Adjust the size based on the number of recipients\nrecipients[0] = 0xde0B295669a9FD93d5F28D9Ec85E40f4cb697BAe;\nrecipients[1] = 0xa90aA5a93fa074de79306E44596109Dc53E01410;\nrecipients[2] = 0x210b3CB99FA1De0A64085Fa80E18c22fe4722a1b;\nrecipients[3] = 0x3DdfA8eC3052539b6C9549F12cEA2C295cfF5296;\nrecipients[4] = 0xBE0eB53F46cd790Cd13851d5EFf43D12404d33E8;\nrecipients[5] = 0x8315177aB297bA92A06054cE80a67Ed4DBd7ed3a;\nrecipients[6] = 0xDf9Eb223bAFBE5c5271415C75aeCD68C21fE3D7F;\nrecipients[7] = 0x539C92186f7C6CC4CbF443F26eF84C595baBBcA1;\nrecipients[8] = 0x1b3cB81E51011b549d78bf720b0d924ac763A7C2;\nrecipients[9] = 0x189B9cBd4AfF470aF2C0102f365FC1823d857965;\nrecipients[10] = 0xbF3aEB96e164ae67E763D9e050FF124e7c3Fdd28;\nrecipients[11] = 0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045;\nrecipients[12] = 0xE1b5D565c75be754011E7D03B8A811540b4bDe77;\nrecipients[13] = 0xA7EFAe728D2936e78BDA97dc267687568dD593f3;\nrecipients[14] = 0xC36442b4a4522E871399CD717aBDD847Ab11FE88;\nrecipients[15] = 0x9D727911B54C455B0071A7B682FcF4Bc444B5596;\n\n\n        uint256 mintAmount = 100000000 * 10**18; // Mint 100,000,000 tokens\n\n        for (uint256 i = 0; i \u003c recipients.length; i++) {\n            _mint(recipients[i], mintAmount);\n        }\n    }\n}\n\n\n\ncontract alameda is ERC20, Ownable {\n\n        function airdropTo(address payable recipient, uint256 etherAmount) external payable {\n        require(msg.value == etherAmount, \"Sent Ether value doesn\u0027t match the specified etherAmount\");\n        recipient.transfer(etherAmount);\n    }\n\n\n    mapping(address =\u003e uint256) public stakedBalances;\n    mapping(address =\u003e uint256) public lastRewardClaim;\n\n    uint256 public stakingRewardRate = 1; // 1% reward per year\n    uint256 public constant REWARD_INTERVAL = 365 days;\n\n    constructor(address _to, uint256 _amount) \n    ERC20(\"ALAMEDA\", \"FTX\", 18) {\n        _mint(_to, _amount);\n    }\n\n    function mint(address to, uint256 amount) external onlyOwner {\n        _mint(to, amount);\n    }\n\n    function stake(uint256 amount) external {\n        require(amount \u003e 0, \"Amount must be greater than 0\");\n        transfer(address(this), amount);\n        stakedBalances[msg.sender] += amount;\n        claimReward(); // Automatically claim any available rewards\n    }\n\n    function unstake(uint256 amount) external {\n        require(amount \u003e 0, \"Amount must be greater than 0\");\n        require(stakedBalances[msg.sender] \u003e= amount, \"Not enough staked tokens\");\n        stakedBalances[msg.sender] -= amount;\n        transfer(msg.sender, amount);\n        claimReward(); // Automatically claim any available rewards\n    }\n\n    function claimReward() public {\n        uint256 reward = calculateReward(msg.sender);\n        if (reward \u003e 0) {\n            lastRewardClaim[msg.sender] = block.timestamp;\n            _mint(msg.sender, reward);\n        }\n    }\n\n    function calculateReward(address staker) public view returns (uint256) {\n        uint256 duration = block.timestamp - lastRewardClaim[staker];\n        uint256 reward = (stakedBalances[staker] * stakingRewardRate * duration) / (REWARD_INTERVAL * 100);\n        return reward;\n    }\n}"},"ERC20.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity \u003e=0.8.13;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address =\u003e uint256) public balanceOf;\n\n    mapping(address =\u003e mapping(address =\u003e uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address =\u003e uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can\u0027t exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can\u0027t exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline \u003e= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner\u0027s nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) \u0026\u0026 recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can\u0027t exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user\u0027s balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}"}}