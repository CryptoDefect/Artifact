{{

  "language": "Solidity",

  "sources": {

    "@openzeppelin/contracts/access/Ownable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"

    },

    "@openzeppelin/contracts/security/Pausable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"

    },

    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/Context.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/math/Math.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/math/SignedMath.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/Strings.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"

    },

    "contracts/common/Signable.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./../lib/Signature.sol\";\n\n// NOTE: Use distinct wallets for different admin roles/purposes, because it's safer.\n// Role hierarchy:\n// 1. operator (autohorized cold wallet, which should also be hardware and multi-signature (in this case it's actually a contract) wallet): `owner()`\n// 2. automator (autohorized hot wallet, used from the automated backend): `defaultSigner`\n// 3. sender (any wallet or contract): `_msgSender()`\nabstract contract Signable is Ownable {\n\n    // =======================================================================\n    // Errors.\n    // =======================================================================\n\n    error ParamInvalid(uint8 paramPosIdx);\n\n    error SenderInvalid();\n\n    // =======================================================================\n    // Events.\n    // =======================================================================\n\n    event DefaultSignerUpdated(address indexed oldSigner, address indexed newSigner);\n\n    // =======================================================================\n    // State vars.\n    // =======================================================================\n\n    // Automator.\n    address public defaultSigner;\n    // A count of number of TXs triggered from the sender, i.e. from his account/wallet/contract/address. Use and increment it in functions which do a state change and/or are payable, but are only needed if an outside user is the sender.\n    // NOTE: Both smart contracts and wallets (i.e. EOA - Externally Owner Account) have nonces already implemented. However, contracts can't make transactions, they can only make calls that are triggered by transactions. But contracts still can create other contracts and for the newly generated contract the nonce of the sender is relevant. A nonce of a contract is only incremented when that contract creates another contract. There is no built-in method for a contract to access an account's nonce, including its own - hence, this contract uses its storage to keep track of the nonce for its senders, via this var. Note that via the frontend you can get those nonces via e.g. `web3.eth.getTransactionCount` funciton, but the nonce here is specifically for the TXs that were sent to this contract (by this contract's senders), so we need to use this one always for the senders, and can use the mentioned function call just for the contract's nonce, in our case.\n    // NOTE: Since we use `uint24` type for the state vars which represent quantities per season (and its lower store nodes), e.g. the number of NFTs for the particular season (i.e. `Season.maxSupply` field; e.g. imagine 1 NFT per 2^24 = 16,8 million unique users for the particular season), we implicitly limit the size of the state vars, both dynamic arrays and mappings, which store user wallet and contract addresses doing state changing interactions with our contract (specifically, the ones successfully calling (i.e. without TX reverting) functions which update this state var), to `uint40` possible values altogether (i.e. across all seasons of all leagues and sports), and we don't limit the size to `uint32` possible values instead, because a user may use many wallets or contracts to interact with our contract, hence we add extra 8 bytes of possible values (i.e. 2^8 = 256 wallets and contracts per each NFT (ownable/transferable by the same user) from across all seasons' collections), which allows 2^40 / 2^24 = 256 * 256 = 65536 times more possible values. Hence the limit shouldn't be reachable.\n    // NOTE: We limit the quantity of state changing interactions each user wallet or contract address interacting with our contract (specifically, the ones successfully calling (i.e. without TX reverting) functions which update this state var) can do altogether (i.e. across all seasons of all leagues and sports) to `uint24` possible values, i.e. 2^24 = 16,8 million. Hence the limit shouldn't be reachable.\n    mapping(address => uint24) public senderNonces;\n\n    // =======================================================================\n    // Setter functions.\n    // =======================================================================\n\n    function setDefaultSigner(address _defaultSigner)\n        external\n        onlyOwner\n    {\n        // Validate input params.\n\n        // NOTE: Should be an automator wallet, so it can prepare TXs automatically.\n        if(_defaultSigner == address(0) || _defaultSigner == owner()) revert ParamInvalid(0);\n\n        // Update/set state vars.\n\n        address oldDefaultSigner = defaultSigner;\n        defaultSigner = _defaultSigner;\n\n        // Emit events.\n\n        emit DefaultSignerUpdated(oldDefaultSigner, _defaultSigner);\n    }\n\n    // =======================================================================\n    // Validator functions.\n    // =======================================================================\n\n    function _verifyNonOwnerCallSignature(address _signer, address _sender, bytes memory _data, bytes memory _signature, uint40 _signatureExpiryTimestamp)\n        internal\n        view\n    {\n        Signature.verifyNonOwnerCallSignature(_signer, _sender, senderNonces[_sender], _data, _signature,  _signatureExpiryTimestamp);\n    }\n\n}\n"

    },

    "contracts/lib/Conversion.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.19;\n\nlibrary Conversion {\n\n    // =======================================================================\n    // Parser functions.\n    // =======================================================================\n\n    // This parses/interprets `bytes` type as a `string` type, and doesn't convert it instead. E.g. `bytes` value `0xa22cb465` becomes `string` value \"0xa22cb465\".\n    // NOTE: Can be used when a signature is provided via both `bytes` and `string` type, becasuse verifying signed signature params works only if they are provided in the `string` format, instead of the `bytes` format. . Because we can't include the `bytes` type param in the signature, we verify separately that it's equivalent to its parsed `sting` type param/version.\n    function parseBytesAsString(bytes memory _buffer)\n        external\n        pure\n        returns(string memory)\n    {\n        // Fixed buffer size for hexadecimal conversion.\n        bytes memory converted = new bytes(_buffer.length * 2);\n        bytes memory base = \"0123456789abcdef\";\n\n        // NOTE: For vars which represent (or iterate, in this case) buffers of arbitrary size, we use `uint256` type, even though maybe a smaller size could be enough, because when using elements that are smaller than 32 bytes, the smart contract's gas usage may be higher; this is because the EVM operates on (a word size of) 256 bits / 32 bytes at a time (to facilitate native hashing and elliptic curve operations), therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size. Hence the limit shouldn't be reachable. Note, however, that we can optimize gas consumption when storing or loading statically-sized variables, because in state variables, structs and statically sized arrays (actually, this is true for all statically-sized variables, except for mappings and dynamically-sized arrays), e.g. `uint8` does cost less than a traditional `uint`, because of the tight variable packing feature (coding pattern; which is unfortunately, until the time of writing, not automatically achieved by the optimizer). Also be sure that in structs your uints are next to your other uints, and bytes next to bytes, etc., because this further increases the tightly packed features, because the order you declare your state vars can affect the overall number of storage slots your contract uses. If you declare 2 `uint128`'s and then a `uin256`, that will use 2 256-bit storage slots; 1 slot for the 2 `uint128`'s and 1 slot for the `uint256`. If you declare 1 `uint128`, then a `uint256`, then a `uint128`, your contract will use 3 storage slots, because it can't fit the middle `uint256` state variable into a storage slot with either of the `uint128`'s, so each variable will need to have its own storage slot. Note, by default, to put the dynamic types / (state) vars (i.e. `bytes`, dynamically-sized arrays and `mapping`s) at the end or the beginning, before other, statically-sized types / (state) vars; but this tactic might not always use less gas (if at all - not verified!) (if optimizer is enabled, it might use even more gas, but just for the initial deployment of contracts and libraries, of course). Note that the difference between the gas cost to deploy `unit8` and `uint256` is geeting smaller with newer versions of Solidity, e.g. in Solidity 0.8.10 the `unit8` is now only 100 gas more expensive than `uint256`, compared to the SOLC 0.4.18, where they cost 75414 and 73867 gas respectively, i.e. a difference of 1547 gas. Note also that using bigger types will make the signatures which use vars with such types significantly larger then they could have been, leading to tangible increase in the gas price of all the methods which deal with such signatures. See: https://fravoll.github.io/solidity-patterns/tight_variable_packing.html\n        // NOTE: Related to the upper note, using smaller type values for storage hence makes sense, because writing to storage is expensive, and the compiler will pack multiple smaller arguments. For function parameters and memory variables, it only makes sense if you want to restrict the range of values: there's no packing, so it's neither more nor less expensive.\n        // NOTE (TODO): Before deploying the contract to the testnet or mainnet, rearrange all storage vars in all contracts and libraries to optimize gas usage via tight variable packing feature.\n        for (uint256 i = 0; i < _buffer.length; i++) {\n            converted[i * 2] = base[uint8(_buffer[i]) / base.length];\n            converted[i * 2 + 1] = base[uint8(_buffer[i]) % base.length];\n        }\n\n        return string(abi.encodePacked(\"0x\", converted));\n    }\n\n}\n"

    },

    "contracts/lib/Signature.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.19;\n\nlibrary Signature {\n\n    // =======================================================================\n    // Errors.\n    // =======================================================================\n\n    error SignatureInvalid();\n    error SignatureExpired();\n\n    // =======================================================================\n    // Parser functions.\n    // =======================================================================\n\n    // The prefix is a way to distinguish signatures meant for Ethereum smart contracts, and for other cryptographic platforms. By adding the Ethereum-specific prefix, the message (with the prefix) results in a different signature, specific just for Ethereum. But if there were no platform-specific prefixes, the resulting signature would be the same for all platforms, which could potentially lead to signature replay attacks.\n    // NOTE: Back in 2016, when this standard was introduced, there were no other EVM networks (e.g. Binance Smart Chain and Polygon), or at least they were not widely used. Nowdays it's common to use the \"Ethereum\" prefix even if the message is intended for other EVM networks such as Polygon.\n    // NOTE: The specific specific byte `0x19` was standardized simply because an already existing implementation (in the Go Ethereum client software, i.e. Geth) was using it before the standard was finalized. And the last number (`32` in this case) is the byte length of the message (excluding the prefix) that is being signed.\n    // NOTE: E.g. Geth client software prepends the string `\\x19Ethereum Signed Message:\\n32` to all data before signing it (https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign). If you want to verify such a signature from Solidity, you have to prepend the same string in Solidity before doing the `ecrecover`. The reason was that by allowing signing arbitrary data, a DApp can trick the user to sign a transaction masqueraded as some arbitrary application data. This prefix ensures that no matter what data a DApp sends to Geth, it cannot be abused as a transaction. To use this mechanism for signature verification in solidity, you'll need to have your contract also do this prefixing.\n    function _getEthPrefixedHash(bytes32 _hash)\n        private\n        pure\n        returns(bytes32)\n    {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _hash));\n    }\n\n    function _splitSignature(bytes memory _signature)\n        private\n        pure\n        returns(uint8 v, bytes32 r, bytes32 s)\n    {\n        // Validate input params.\n\n        if (_signature.length != 65) revert SignatureInvalid();\n\n        assembly {\n            // First 32 bytes, after the length prefix.\n            r := mload(add(_signature, 32))\n            // Second 32 bytes.\n            s := mload(add(_signature, 64))\n            // Final byte (first byte of the next 32 bytes).\n            v := byte(0, mload(add(_signature, 96)))\n        }\n\n        return (v, r, s);\n    }\n\n    function _recoverSigner(bytes32 _message, bytes memory _signature)\n        private\n        pure\n        returns(address _signer)\n    {\n        (uint8 v, bytes32 r, bytes32 s) = _splitSignature(_signature);\n\n        return ecrecover(_message, v, r, s);\n    }\n\n    // =======================================================================\n    // Validator functions.\n    // =======================================================================\n\n    // Same as `verifyNonOwnerCallSignature` function, except that it's meant for the cases where the signer (e.g. operator) is also the sender, or the sender is controlled by or in the same trustworthy group as the signer (e.g. automator). In which case the meta params don't need to be verified, as the verification is already safe enough without them. It can also be used for any other type of signature verifications (e.g. for encrypting/encoding (actually jsut hashing) secret data, e.g. via Commit-Reveal Schemes).\n    function verifySignature(address _signer, bytes memory _data, bytes memory _signature)\n        public\n        pure\n    {\n        bytes32 message = _getEthPrefixedHash(keccak256(_data));\n\n        if (_recoverSigner(message, _signature) != _signer) revert SignatureInvalid();\n    }\n\n    // We need to use this signature verification inside functions which should only be executed if the signer (e.g. operator) confirmed (preparred) the TX to be sent/transmitted to the smart ocntract (by providing a signature param to the calling function), to prevent non-signer (i.e. sender) wallets or contracts from tempering the function params' values confirmed/provided by the signer.\n    // NOTE: Include all calling function's params in the singature, even the ones that are not a potential threat if they are changed intentionally or unintentionally by the sender (even if the signer also owns the sender), just to make sure that the sender transmits exactly the same TX as we signed/confirmed, without being able to modify any of the params. The redundant params (e.g. `NftType` struct's excess params) can be omitted, to reduce hitting the vars limit (i.e. getting stack too deep error).\n    // NOTE: We use `uint40` type for `_signatureExpiryTimestamp` param. Unix time is traditionally stored in a 32-bit number. This will lead to the \"Year 2038\" problem, when 32-bit Unix timestamps will overflow, because it won't be able to store that high number. To avoid this issue, we can choose to use 64-bit number instead (in Solidity 40-bit can be used and is enough), although that will require a higher gas fee.\n    function verifyNonOwnerCallSignature(address _signer, address _sender, uint24 senderNonce, bytes memory _data, bytes memory _signature, uint40 _signatureExpiryTimestamp)\n        external\n        view\n    {\n        // Validate input params.\n\n        // Optionally (i.e. if `_signatureExpiryTimestamp > 0`) validate the signature isn't expired yet (specifically, that it's not past, but can be the same as, the provided expiry timestamp).\n        // NOTE: `block.timestamp` is a Unix timestamp of the latest block (the number of seconds that have passed since January 1st 1970).\n        if (_signatureExpiryTimestamp > 0 && block.timestamp > _signatureExpiryTimestamp) revert SignatureExpired();\n\n        _data = bytes.concat(\n            // Meta params:\n            // - Chain ID: To prevent replay attacks between different Ethereum compatible chains (e.g. between the main ETH and ETC chains, which both have a network ID of 1). Note that both network and chain ID are required for the chain to operate in general, e.g. it's required when signing transactions, meaning transactions signed on the ETH network end up with a different hash than those signed on ETC. Note that the \"Ethereum\" prefix added via `Signature._prefixed` function (see it) doesn't prevent replay attacks accross other EVM networks (e.g. Binance Smart Chain and Polygon), because they all use this same \"Ethereum\" prefix (when the \"Ethereum\" prefix standard was introduced, there were no other EVM networks, or at least they were not widely used), hence why we use this meta param.\n            // - This contracts's address: To make sure the sender is not sending/transmitting a TX that was signed for another contract with the same function signature (i.e. the same combination of the function's name and the types of parameters it takes).\n            // - Sender public address: To make sure the signed TX is sent/transmitted by the same sender for which it was signed.\n            // - Current sender nonce: A count of number of TXs triggered from the sender, i.e. from his account/address/wallet/contract. To prevent replay attacks, i.e. make sure the sender can't execute the signed TX anymore if he already sent/transmitted another TX (or many of them, and of the same or different function signatures) in the mean time, because those TXs could have changed the current state of the contract (i.e. it's state vars), potentially making the signature non valid anymore if our (backend) pre-validation for producing the signature for this same type of TX would now fail, hence this TX should now fail/be reverted if sent/transmitted. It can also be used for specifying the order in which the TXs should be executed.\n            // - Max valid timestamp: Verified later on. To make sure the signed TX is sent/transmitted by the sender before the specified timestamp, before the provided timestamp is greater (or even equal) to the current block's timestamp, i.e. `block.timestamp`.\n            abi.encodePacked(block.chainid, this, _sender, senderNonce),\n            _data\n        );\n\n        verifySignature(_signer, _data, _signature);\n    }\n\n}\n"

    },

    "contracts/lib/StoreDeleter.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport \"./../lib/StoreGetter.sol\";\n\n// NOTE: All these functions should be called in functions which are called only by (i.e. limited to) or signature gated by the operator.\nlibrary StoreDeleter {\n\n    // =======================================================================\n    // Libraries attached to var types.\n    // =======================================================================\n\n    using Strings for string;\n\n    // =======================================================================\n    // Errors.\n    // =======================================================================\n\n    error NodeHasChildren();\n    error LeafNodeAlreadyUsed(uint8 arrayPosIdx);\n\n    error AssetsLockError();\n\n    // =======================================================================\n    // Events.\n    // =======================================================================\n\n    event NodeDeleted(StoreGetter.NftType nftType, uint8 nodeDepth);\n\n    // =======================================================================\n    // Deleter functions.\n    // =======================================================================\n\n    function deleteSport(StoreGetter.Store storage store, StoreGetter.NftType memory _nftType)\n        external\n    {\n        // Validate input params.\n\n        // NOTE: Not needed, since checking for the existance of nodes (specifically, including the last, 1-st/sport node) is done later on. But `NftType` struct's excess params are allowed to be non-default, hence potentially breaking the event filtering logic when filtering by the `NftType` struct, if an event including a `NftType` struct param is emitted within this function.\n        // StoreGetter._validateNftType(_nftType, 1);\n\n        // Validate existence of objects associated with the input params.\n        StoreGetter.Sport storage sport = StoreGetter._getSport(store, _nftType);\n\n        // Validate assets (e.g. ETH amount or NFTs) not getting irrevocably locked in the contract.\n        // NOTE: NOT NEEDED in the current logic, since there are no assets managed in a sport `struct`.\n\n        // Validate sport's state vars.\n\n        if (sport.hLeagueNames.length > 0) revert NodeHasChildren();\n\n        // Delete sport's `mapping` state vars, because a deletion of a (sport) `struct` containing mappings will not delete (i.e. reset to their default values) the mappings. All containing struct fields of any other type will be deleted/reset automatically, and deletion also recurse into struct members that are structs themselves and deletes them as well.\n        // NOTE: NOT NEEDED in the current logic, because if all the current validations in this function pass, then all the sport `struct`'s mappings are either yet unused/uninitialized or already deleted/reset.\n\n        // Delete sport's parent nodes' state vars.\n\n        // Delete Mapped Struct.\n        delete store.sports[_nftType.sport];\n\n        // Delete Mapped Struct's Index. Preserve array order.\n        // NOTE: We implicitly limit the `Store.hSportNames` array size to `uint8` possible values.\n        uint8 i = 0;\n        for (; i < store.hSportNames.length;) {\n            if (store.hSportNames[i].equal(_nftType.sport)) {\n                break;\n            }\n            unchecked { i++; }\n        }\n        for (; i < store.hSportNames.length - 1;){\n            store.hSportNames[i] = store.hSportNames[i + 1];\n            unchecked { i++; }\n        }\n        store.hSportNames.pop();\n\n        // Emit events.\n\n        emit NodeDeleted(_nftType, 1);\n    }\n\n    function deleteLeague(StoreGetter.Store storage store, StoreGetter.NftType memory _nftType)\n        external\n    {\n        // Validate input params.\n\n        // NOTE: Not needed, since checking for the existance of nodes (specifically, including the last, 2-nd/league node) is done later on. But `NftType` struct's excess params are allowed to be non-default, hence potentially breaking the event filtering logic when filtering by the `NftType` struct, if an event including a `NftType` struct param is emitted within this function.\n        // StoreGetter._validateNftType(_nftType, 2);\n\n        // Validate existence of objects associated with the input params.\n        // NOTE: We could just get the child store nodes from the parent ones directly without the getters, but they also perform the validation and reduce gas costs.\n        StoreGetter.Sport storage sport = StoreGetter._getSport(store, _nftType);\n        StoreGetter.League storage league = StoreGetter._getLeague(store, _nftType);\n\n        // Validate assets (e.g. ETH amount or NFTs) not getting irrevocably locked in the contract.\n        // NOTE: NOT NEEDED in the current logic, since there are no assets managed in a league `struct`.\n\n        // Validate league's state vars.\n\n        if (league.hSeasonNames.length > 0) revert NodeHasChildren();\n\n        // Delete league's `mapping` state vars, because a deletion of a (league) `struct` containing mappings will not delete (i.e. reset to their default values) the mappings. All containing struct fields of any other type will be deleted/reset automatically, and deletion also recurse into struct members that are structs themselves and deletes them as well.\n        // NOTE: NOT NEEDED in the current logic, because if all the current validations in this function pass, then all the league `struct`'s mappings are either yet unused/uninitialized or already deleted/reset.\n\n        // Delete league's parent nodes' state vars.\n\n        // Delete Mapped Struct.\n        delete sport.leagues[_nftType.league];\n\n        // Delete Mapped Struct's Index. Preserve array order.\n        // NOTE: We implicitly limit the `Sport.hLeagueNames` array size to `uint8` possible values.\n        uint8 i = 0;\n        for (; i < sport.hLeagueNames.length;) {\n            if (sport.hLeagueNames[i].equal(_nftType.league)) {\n                break;\n            }\n            unchecked { i++; }\n        }\n        for (; i < sport.hLeagueNames.length - 1;){\n            sport.hLeagueNames[i] = sport.hLeagueNames[i + 1];\n            unchecked { i++; }\n        }\n        sport.hLeagueNames.pop();\n\n        // Emit events.\n\n        emit NodeDeleted(_nftType, 2);\n    }\n\n    function deleteSeason(StoreGetter.Store storage store, StoreGetter.NftType memory _nftType)\n        external\n    {\n        // Validate input params.\n\n        // NOTE: Not needed, since checking for the existance of nodes (specifically, including the last, 3-rd/season node) is done later on. But `NftType` struct's excess params are allowed to be non-default, hence potentially breaking the event filtering logic when filtering by the `NftType` struct, if an event including a `NftType` struct param is emitted within this function.\n        // StoreGetter._validateNftType(_nftType, 3);\n\n        // Validate existence of objects associated with the input params.\n        // NOTE: We could just get the child store nodes from the parent ones directly without the getters, but they also perform the validation and reduce gas costs.\n        StoreGetter.League storage league = StoreGetter._getLeague(store, _nftType);\n        StoreGetter.Season storage season = StoreGetter._getSeason(store, _nftType);\n\n        // Validate assets (e.g. ETH amount or NFTs) not getting irrevocably locked in the contract.\n\n        if (season.spentPrizePoolAmount < season.totalPrizePoolAmount) revert AssetsLockError();\n\n        // Validate season's state vars.\n\n        if (season.hSaleNames.length > 0) revert NodeHasChildren();\n\n        // Delete season's `mapping` state vars, because a deletion of a (season) `struct` containing mappings will not delete (i.e. reset to their default values) the mappings. All containing struct fields of any other type will be deleted/reset automatically, and deletion also recurse into struct members that are structs themselves and deletes them as well.\n        // NOTE: NOT NEEDED in the current logic, because if all the current validations in this function pass, then all the season `struct`'s mappings are either yet unused/uninitialized or already deleted/reset.\n\n        // Delete season's parent nodes' state vars.\n\n        // Delete Mapped Struct.\n        delete league.seasons[_nftType.season];\n\n        // Delete Mapped Struct's Index. Preserve array order.\n        // NOTE: We implicitly limit the `League.hSeasonNames` array size to `uint8` possible values.\n        uint8 i = 0;\n        for (;  i < league.hSeasonNames.length;) {\n            if (league.hSeasonNames[i].equal(_nftType.season)) {\n                break;\n            }\n            unchecked { i++; }\n        }\n        for (; i < league.hSeasonNames.length - 1;) {\n            league.hSeasonNames[i] = league.hSeasonNames[i + 1];\n            unchecked { i++; }\n        }\n        league.hSeasonNames.pop();\n\n        // Emit events.\n\n        emit NodeDeleted(_nftType, 3);\n    }\n\n    function deleteSale(StoreGetter.Store storage store, StoreGetter.NftType memory _nftType)\n        external\n    {\n        // Validate input params.\n\n        // NOTE: Not needed, since checking for the existance of nodes (specifically, including the last, 4-th/sale node) is done later on. But `NftType` struct's excess params are allowed to be non-default, hence potentially breaking the event filtering logic when filtering by the `NftType` struct, if an event including a `NftType` struct param is emitted within this function.\n        // StoreGetter._validateNftType(_nftType, 4);\n\n        // Validate existence of objects associated with the input params.\n        // NOTE: We could just get the child store nodes from the parent ones directly without the getters, but they also perform the validation and reduce gas costs.\n        StoreGetter.Season storage season = StoreGetter._getSeason(store, _nftType);\n        StoreGetter.Sale storage sale = StoreGetter._getSale(store, _nftType);\n\n        // Validate assets (e.g. ETH amount or NFTs) not getting irrevocably locked in the contract.\n        // NOTE: NOT NEEDED in the current logic, since there are no assets managed in a sale `struct`.\n\n        // Validate sale's state vars.\n\n        // NOTE: We implicitly limit the `Sale.tiers` array size to `uint8` possible values via `NftType.tier` field.\n        uint8 i = 0;\n        for (; i < sale.tiers.length;) {\n            // Validate tier's state vars.\n            StoreGetter.Tier storage tier = sale.tiers[i];\n            if (tier.sold > 0) revert LeafNodeAlreadyUsed(i);\n\n            // Read excess old tier's state vars before they are deleted/reset. Update sale's parent nodes' state vars.\n            // NOTE: Not needed, since we do this via `sale.hMaxSupply` field later on.\n            // season.hTotalSalesMaxSupply -= tier.maxSupply;\n\n            // Delete tier's state vars.\n            // NOTE: NOT NEEDED, because the arrays (both static and dynamic) are deleted (i.e. reset to their default values) automatically later on, upon the deletion of the struct containing them, hence it's more efficient without doing this.\n            // sale.tiers.pop();\n            unchecked { i++; }\n        }\n\n        // Update sale's parent nodes' state vars.\n\n        season.hTotalSalesMaxSupply -= sale.hMaxSupply;\n\n        // Delete sale's `mapping` state vars, because a deletion of a (sale) `struct` containing mappings will not delete (i.e. reset to their default values) the mappings. All containing struct fields of any other type will be deleted/reset automatically, and deletion also recurse into struct members that are structs themselves and deletes them as well.\n        // NOTE: NOT NEEDED in the current logic, because there are no mappings in the sale `struct`.\n\n        // Delete sale's parent nodes' state vars.\n\n        // Delete Mapped Struct.\n        delete season.sales[_nftType.sale];\n\n        // Delete Mapped Struct's Index. Preserve array order.\n        // NOTE: We implicitly limit the `Season.hSaleNames` array size to `uint8` possible values.\n        for (i = 0; i < season.hSaleNames.length;) {\n            if (season.hSaleNames[i].equal(_nftType.sale)) {\n                break;\n            }\n            unchecked { i++; }\n        }\n        for (; i < season.hSaleNames.length - 1;) {\n            season.hSaleNames[i] = season.hSaleNames[i + 1];\n            unchecked { i++; }\n        }\n        season.hSaleNames.pop();\n\n        // Emit events.\n\n        emit NodeDeleted(_nftType, 4);\n    }\n\n}\n"

    },

    "contracts/lib/StoreGetter.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.19;\n\nimport \"./../nfts/IAkshunSeasonPassNft.sol\";\n\n// NOTE: Declaring all of this library's functions' visibility to `external` doesn't make this library be deployed separately from the `AkshunStore.sol` smart contract, for some unknown reason. Note also that using `external` on any of the functions in this library would actually bloat both this library and `AkshunStore.sol` contract even more, for some reason, hence we use `internal` for them, although it's very counterintuitive, but we save on gas costs (both for deployment, but also when calling them, since now they are internally embedded in the contract using this library, because of the function(s) with the `internal` visibility).\nlibrary StoreGetter {\n\n    // =======================================================================\n    // Custom errors.\n    // =======================================================================\n\n    error NodeNameInvalid(uint8 nodeDepth);\n    error NodeNonexistent(uint8 nodeDepth);\n\n    // =======================================================================\n    // State var definitions.\n    // =======================================================================\n\n    string constant publicSaleName = \"Public\";\n    string constant customPrizeType = \"Custom\";\n\n    // Hierarchical store structure.\n    // NOTE: Using nested `Mapped Structs with Index` storage pattern.\n\n    // What types to use:\n    // - For state vars which represent quantities per season (and its lower store nodes), e.g. the number of NFTs for the particular season (i.e. `Season.maxSupply` field), we use `uint24` type, because 2^24 = 16,8 million possible values should be enough (e.g. imagine 1 NFT per 16,8 million unique users for the particular season).\n    // - The same as for the state vars which represent quantities per season, goes also for the state vars which represent ETH amounts and prices per season (and its lower store nodes), i.e. using `uint24` type. But because the inherited contracts already use `uint256` (hence it wouldn't be compatibel with our amounts), and sent ETH amount `msg.value` also uses `uint256` (hence it wouldn't be compatibel with our prices/costs), we use that instead. Hence the limits shouldn't be reachable.\n    // - Related to the previous two notes, the lower store nodes use types which are bigger than necessary, because the higher store nodes represent values altogether (i.e. across all lower store nodes). We don't use smaller types in such cases, so that we can use the same type for all of them (simplifies operations between them and their managements, and potentially reduces computational costs).\n    // - For state vars which are dynamic arrays, we implicitly limit their size to `uint8` possible values, because 2^8 = 256 possible values should be enough for all the sports, all the sport's leagues, all the league's seasons, all the season's sales and all the sale's tiers, not altogether but separately (i.e. each of the mentioned groups has its own 256 possible values/slots; except for tiers, where there are 255 possible possible values/slots, because Tier grades start with 1, but their position indexes in `Tier.tiers` start with 0). The same goes for the mapping state vars which have such dynamic array dependent on it. Hence both limit shouldn't be reachable.\n    // - Solidity timestamp uses Unix timestamp in seconds format (i.e. the number of seconds that have passed since January 1st 1970) and the type `uint256` is used by the timestamp vars in Solidity (e.g. `block.timestamp`), so use this type for timestamps. Unix time is traditionally stored in a 32-bit number. This will lead to the \"Year 2038\" problem, when 32-bit Unix timestamps will overflow, because it won't be able to store that high number. To avoid this issue, we can choose to use 64-bit number instead - in Solidity 40-bit can be used for the timestamps and is enough, although that will require a higher gas fee compared to 32-bit type.\n    // - Related to the previous note, for delta time vars we use `uint24`, because cca. 16.8 minutes (= 11.651 days) should be enough for any delta time. Note the delta time shouldn't be too small in practice, since miners can vary or cheat the timestamp of the block by some tolerance. In practice, there has not been any notable timestamp skew ever. The block time itself is ~15 seconds, so as a rule of thumb it would be accurate to a minute. The only rule about timestamps is that the timestamp of a block must be greater than the previous block's timestamp; there is no other rule - old docs such as the white paper and wiki may mention 15 minutes (900 seconds), but these were corrected; the Yellow paper is the formal specification (see Block Header Validity (section 4.4.4, equation 48)). Small differences in time are tolerated by nodes, but as one node's time gets further away from the Coordinated UTC Time (per Network Time Protocol (NTP)), its number of peers will reduce and eventually it will have zero peers and be disconnected from the network. A miner wants to have a time consistent with the network, so that other miners will build upon the blocks that this miner mines. Blocks must be within a reasonable Unix time, otherwise miners are unlikely to build upon blocks with unreasonable timestamps.\n\n    // NOTE: `Store` struct is needed to encompass the top-level vars. This way we can pass all the vars (fields) to other library and other contract functions via a single `Store` reference.\n    // NOTE: The struct definition could also be put in a separate library, e.g. `StoreStructure`, and imported here. Then this library's current name `StoreGetter` would become more appropriate.\n    struct Store {\n        // NOTE: Since we use `uint24` type for the state vars which represent ETH amounts per season (and its lower store nodes), which allows 2^32 / 2^24 = 256 times more possible values. But because the inherited contracts already use `uint256` (hence it wouldn't be compatibel with our amounts), and sent ETH amount `msg.value` also uses `uint256` (hence it wouldn't be compatibel with our prices/costs), we use that instead. Hence the limit shouldn't be reachable.\n        uint256 unspentOperationalFundAmount;\n\n        // NOTE: We implicitly limit the array size to `uint16` possible values via `AkshunSeasonPassNft.hTokenSubcollectionIdx` var.\n        // NOTE: Each season equals a unique subcollection.\n        uint16 subcollectionsCnt;\n\n        // TODO: Make it season bound!\n        // Whether automator (`defaultSigner`) can sign free mints, otherwise only operator (`operator`) can. Less safe, but automation is not hindered.\n         bool canAutomatorSignFreeMints;\n\n        // Sports.\n\n        // NOTE: We implicitly limit the mapping size to `uint8` possible values via `Store.hSportNames` field.\n        mapping(string => Sport) sports;\n        // NOTE: We implicitly limit the array size to `uint8` possible values.\n        string[] hSportNames; // NOTE: Helper field practically underivable (because of `mapping` type) from `sports` (i.e. a list of `sports` Mapped Struct's Indexes), needed because you can't get them (or their existance) neatly and efficiently from the `Store.sports` mapping (via its keys).\n    }\n\n    struct Sport {\n        bool hExists; // NOTE: Helper field derivable from `Store.hSportNames`, explicitly indicating whether the (sport) struct instance (i.e. node, fetched from `sports` mapping) exists, because it doesn't contain any other field which would have a non-default (i.e. non-reset) value after all of its nested structs (i.e. child nodes) are deleted, indicating an existing struct.\n\n        // Types of prizes and the corresponding ETH prizes (which are specified as a % of the NFT type's minting prize) which can be claimed.\n        // NOTE: We implicitly limit the array size to `uint8` possible values.\n        string[] prizeTypes;\n        mapping(string => bool) hPrizeTypesExist; // NOTE: Helper field derivable from `Sport.prizeTypes`, explicitly indicating whether a particular prize type exists, to assure unique prize types in `prizeTypes` field.\n\n        // Leagues.\n\n        // NOTE: We implicitly limit the mapping size to `uint8` possible values via `Sport.hLeagueNames` field.\n        mapping(string => League) leagues;\n        // NOTE: We implicitly limit the array size to `uint8` possible values.\n        string[] hLeagueNames; // NOTE: Helper field practically underivable (because of `mapping` type) from `leagues` (i.e. a list of `leagues` Mapped Struct's Indexes), needed because you can't get them (or their existance) neatly and efficiently from the `Sport.leagues` mapping (via its keys).\n    }\n\n    struct League {\n        bool hExists; // NOTE: Helper field derivable from `Sport.hLeagueNames`, explicitly indicating whether the (league) struct instance (i.e. node, fetched from `Sport.leagues` mapping) exists, because it doesn't contain any other field which would have a non-default (i.e. non-reset) value after all of its nested structs (i.e. child nodes) are deleted, indicating an existing struct.\n\n        // Seasons.\n\n        // NOTE: We implicitly limit the mapping size to `uint8` possible values via `League.hSeasonNames` field.\n        mapping(string => Season) seasons;\n        // NOTE: We implicitly limit the array size to `uint8` possible values.\n        string[] hSeasonNames; // NOTE: Helper field practically underivable (because of `mapping` type) from `seasons` (i.e. a list of `seasons` Mapped Struct's Indexes), needed because you can't get them (or their existance) neatly and efficiently from the `League.seasons` mapping (via its keys).\n    }\n\n    // Each Season Pass NFT sub-collection is tied to a particular season.\n    struct Season {\n        // Dependent contract and library vars.\n\n        // NOTE: Albeit they can use the same wallet, it might be safer having separate wallets for the Store contract owner and Season Pass NFT contract owner.\n        // NOTE: The same NFT contract can be used across multiple seasons/subcollections (even of other leagues and sports), or a new one.\n        IAkshunSeasonPassNft nftContract;\n        // NOTE: We implicitly limit the array size to `uint16` possible values via `AkshunSeasonPassNft.hTokenSubcollectionIdx` var.\n        uint16 subcollectionIdx;\n        // The NFT's baseURI used when minting the whole season collection. The swaps are done with newer base URIs, preferably in batches (i.e. using the same new NFT's baseURI for multiple (potentially) swapped NFTS).\n        // NOTE: Check it's dependent state var `tokenBaseURIIndexes` in `nftContract`/`AkshunSeasonPassNft.sol` smart contract.\n        // NOTE: NOT NEEDED, since it's always `0` for the original minted (i.e. not burned and swapped) season's collection of Season pass NFTs.\n        // uint8 initialTokenBaseURIIdx;\n\n        // Commitment/Commit-Reveal Scheme to commit to a disposable wallet by storing its encrypted (specifically, by digitally signing it) public address in `encryptedRngProvider` (signature), and after the info doesn't need to be secret anymore (either after the whole season collection is minted out or the season is over, even if we still allow minting), we also store the unencrypted/revealed public address (revealedRngProvider), proving it's the same address which was before encrypted and also letting others see it. After a disposable wallet's hash is set, the wallet will be used to call a VRF (Verifiable Random Function), e.g. Chainlink VRF, to generate a provably fair and verifiable random number, without compromising security or usability. We commit to using a specific wallet before doing the call to the RNG, in order to prove we couldn't have manipulated it. The wallet is hashed so no one can see which RNG was created. This RNG will be used as a seed to determine the mapping between the NFTs and their metadata, providing a fully randomized distribution of NFTs.\n        bytes encryptedRngProvider;\n        address revealedRngProvider;\n\n        // Overall mint quantities and amounts. Encompasses/includes all other mint quantities (e.g. free mint quantities).\n\n        uint24 maxSupply; // NOTE: Also use this field as a field implicitly indicating whether the (season) struct instance (i.e. node, fetched from `League.seasons` mapping) exists.\n        // A sum of max supplies of all season sales. I.e. the part of season's total supply which is already distributed among its sales' tiers.\n        uint24 hTotalSalesMaxSupply; // NOTE: Helper field derivable from all season sales' `Tier.maxSupply`s. Must be `<= maxSupply`.\n        uint24 hSold; // NOTE: Helper field derivable from all season sales' `Tier.sold`s. Must be `<= maxSupply`.\n\n        // Free mint quantities. These quantities are accounted for in the overall mint quantities.\n\n        uint24 maxFreeSupply; // NOTE: Must be `<= maxSupply`.\n        uint24 freeSold; // NOTE: Must be `<= hSold`.\n\n        // Delta time in minutes, starting from the provided timestamp of the creation of the digital signature (for the mint or swap function), until which the (signed) mint (or swap) TX can be executed. If it's not executed within this delta time, the signature verfication and hence the TX will revert/fail, and when we stop signing the TX for minting (or swapping), we need to wait for this delta time duration and then we can be sure no one can no longer execute any of the previously signed TXs (i.e. to do the next Season Pass NFTs batch reveal without breaking the IPFS metadata binding logic). This also prevents user from getting a lot of signed mint (or swap) TXs (with different wallets, because otherwise the nonce check would prevent executing more than one among the singed but not yet executed TXs) and executing them at once at a later time.\n        uint24 mintPeriodMins;\n\n        // Prize pool amounts.\n\n        // BPS of the whole deposited ETH amount via Season Pass NFT mints/purchases reserved solely for the prize payouts.\n        uint16 prizePoolBps; // NOTE: Must be `<= 10000`. BPS (or BP or BIPS) is a Basis Point(s), which equals one hundredth of 1 percentage point. I.e. 1% is 100 bps.\n        // BPS of the ETH reserved solely for the prize payouts which can currently be distributed. A safety mechanism to prevent the season's whole prize pool drainage if the automator wallet gets compromised. A sensible BPS is between 5% and 10% higher than the current already distributed BPS of the whole prize pool amount.\n        uint16 unlockedPrizePoolBps; // NOTE: Must be `<= 10000`. BPS (or BP or BIPS) is a Basis Point(s), which equals one hundredth of 1 percentage point. I.e. 1% is 100 bps.\n\n        // Total ETH ever deposited (and/or moved from the operational funds) to the prize pool.\n        uint256 totalPrizePoolAmount; // NOTE: We can't have a single e.g. `unspentPrizePoolAmount` field instead of both `totalPrizePoolAmount` and `spentPrizePoolAmount` fields, because this field is needed by `unlockedPrizePoolBps` field.\n        uint256 spentPrizePoolAmount; // NOTE: Must be `<= totalPrizePoolAmount`.\n\n        // Percentage of any of the Public sale/stage tiers' price for each sport's prize type in the dependent `Sport.prizeTypes`, used for calculating the prize pool payouts. Note that the winning Season Pass NFT's tier is used, but from the Public sale/stage instead.\n        // NOTE: We implicitly limit the array size to `uint8` possible values, the same as we do for the dependent `Sport.prizeTypes` array.\n        uint16[] prizeTypePcts; // NOTE: Must have the same size as `Sport.prizeTypes` array.\n        // Whether a particular prize type was alredy used (paid out), hence its value in `prizeTypePcts` shouldn't change anymore.\n        // NOTE: We could use bool array instead, but for existance/bool values it's more gas efficient and less error prone to use a mapping instead (because you need to push (e.g. initialize new elements as they come) and manage array elements).\n        // NOTE: We limit the mapping value and implicitly limit the mapping size to `uint8` possible values, the same as we do for the dependent `Sport.prizeTypes` array.\n        mapping(uint8 => bool) prizeTypesUsed;\n\n        // Delta time in minutes, starting from the provided timestamp of the action associated with the claimable prize, until which the prize can be claimed. If it's not claimed within this delta time, the signature verfication and hence the TX will revert/fail, and the prize amount is again available for other prizes instead, as part of the total prize pool.\n        uint24 prizeClaimPeriodMins;\n\n        // Sales.\n\n        // NOTE: We implicitly limit the mapping size to `uint8` possible values via `Season.hSaleNames` field.\n        mapping (string => Sale) sales;\n        // NOTE: We implicitly limit the array size to `uint8` possible values.\n        string[] hSaleNames; // NOTE: Helper field practically underivable (because of `mapping` type) from `sales` (i.e. a list of `sales` Mapped Struct's Indexes), needed because you can't get them (or their existance) neatly and efficiently from the `Season.sales` mapping (via its keys).\n    }\n\n    struct Sale {\n        bool hExists; // NOTE: Helper field derivable from `Season.hSaleNames`, explicitly indicating whether the (sale) struct instance (i.e. node, fetched from `Season.sales` mapping) exists, because it doesn't contain any other field which would have a non-default (i.e. non-reset) value after all of its nested structs (i.e. child nodes) are deleted, indicating an existing struct.\n\n        // Whether the sale is meant for trying out, e.g. playing the game, but with much smaller/nominal tier prices and lesser prizes.\n        bool tryout;\n\n        // Mint quantities.\n\n        // A sum of max supplies of all sale's tiers.\n        uint24 hMaxSupply; // NOTE: Helper field derivable from all sale's `Tier.maxSupply`s. Total season sales' `Tier.maxSupply`s must be `<= Season.maxSupply`.\n        uint24 hSold; // NOTE: Helper field derivable from all sale's `Tier.sold`s. Must be `<= hMaxSupply`.\n\n        // Per wallet mint quantities.\n\n        uint24 maxPerWalletSupply; // NOTE: Must be `<= hMaxSupply`.\n        mapping(address => uint24) perWalletSold; // NOTE: Must be `<= maxPerWalletSupply`.\n        uint24 hMaxPerWalletSold; // NOTE: Helper field almost impossibly derivable from `perWalletSold`.\n\n        // Tiers.\n\n        // Tier grade equals its `Tier[]` array's index plus 1.\n        // NOTE: We implicitly limit the array size to `uint8` possible values via `NftType.tier` field.\n        Tier[] tiers; // NOTE: We could use the `mapping` instead, but this enforces Tier grade order by design, albeit tier deletion becomes less gas-efficient. Also use this field as a field implicitly indicating whether a tier struct instance (i.e. node, yet to be fetched from `Sale.tiers` array) exists.\n        // Tier for each minted Season Pass NFT, needed for computing the prizes won by it. Note that these are tiers (i.e. starting from 1), not their respective indexes (i.e. starting from 0).\n        // NOTE: We implicitly limit the mapping value to `uint8` possible values via `NftType.tier` field.\n        // NOTE: We use tier grades (i.e. their values start from 1), instead of tier indexes (i.e. their values start from 0), because then we can check whether the value is `0`, meaning the NFT/token with the provided ID doesn't exist (at least within the season), and also that the provided function param was specified.\n        mapping(uint256 => uint8) tokenTiers; // NOTE: Values must be `> 0` and `<= tiers.length`. Also use this field as a field implicitly indicating whether the Season Pass NFT exists for this sale.\n    }\n\n    struct Tier {\n        // Dependent contract and library vars.\n\n        // NOTE: We implicitly limit the array size to `uint8` possible values via `AkshunSeasonPassNft.Subcollection.presetURIs` var.\n        uint8 tokenPresetURIIdx;\n\n        // Mint quantities.\n\n        uint24 maxSupply; // NOTE: Sum of all parent sale's `Tier.tiersMaxSupply`s must be `<= Season.maxSupply`.\n        // Amount of `Tier.maxSupply` which can currently be minted. A mechanism to enable gradual Season Pass NFT minting of the season sale's tier supply.\n        uint24 unlockedMaxSupply; // NOTE: Must be `>= sold` and `<= maxSupply`.\n        uint24 sold; // NOTE: Must be `<= tiersMaxSupply`.\n\n        // Price amounts.\n\n        uint256 price;\n    }\n\n    // Helper struct for passing NFT type params via function params.\n    // NOTE: The bottom fields can have a default value (i.e. mimicking undefined values) when applicable (e.g. in function `getSeason` we don't need to specify the sale and tier). Beneficial for reducing the number of vars in a function. Use this as a function param whenever any of its encompassing fields are needed, to be consistent.\n    struct NftType {\n        string sport;\n        string league;\n        string season;\n        string sale;\n        // Tier grades start with 1, but their position indexes in `Tier.tiers` start with 0.\n        // NOTE: We explicitly limit the array size to `uint8` possible values.\n        uint8 tier;\n    }\n\n    // =======================================================================\n    // Validator functions.\n    // =======================================================================\n\n    // NOTE: A nice side effect of using this function is preventing the usage of `NftType` struct's excess params, otherwise the events which emit `NftType` struct could emit different `NftType` struct values for the same NFT type, breaking the event filtering logic when filtering by the `NftType` struct (because all of struct's fields need to be provided, even if their default values are set for the fields which are not relevant in a particular use case, e.g. `NftType.sale` and `NftType.tier` fields when referring to a season node). But if the calling function is not changing the `StoreNodes` structure (i.e. state vars for it), don't use it (hence sacrifice events emitting `NftType` struct's excess params, but reducing gas costs), since using node getter functions (e.g. `_getSport`) is enough, because they will throw an error if the fetched node doesn't exist.\n    //\n    // NOTE: When using this function, we can omit `NftType` struct's excess params in the signature, if we're using one, but a cheaper alternative (not sure if true, because the signature computation rises because of the extra params) is to include them in the signature and skip using this function, but (probably) only if the calling function is already using/verifying a signature.\n    function _validateNftType(NftType memory _nftType, uint8 _nodeDepth)\n        internal\n        pure\n    {\n        // Validate input params.\n\n        if (bytes(_nftType.sport).length == 0) revert NodeNameInvalid(1);\n        if (_nodeDepth >= 2 ? bytes(_nftType.league).length == 0 : bytes(_nftType.league).length > 0) revert NodeNameInvalid(2);\n        if (_nodeDepth >= 3 ? bytes(_nftType.season).length == 0 : bytes(_nftType.season).length > 0) revert NodeNameInvalid(3);\n        if (_nodeDepth >= 4 ? bytes(_nftType.sale).length == 0 : bytes(_nftType.sale).length > 0) revert NodeNameInvalid(4);\n        if (_nodeDepth == 5 ? _nftType.tier == 0 : _nftType.tier > 0) revert NodeNameInvalid(5);\n    }\n\n    function _packNftTypeFields(StoreGetter.NftType memory _nftType)\n        internal\n        pure\n        returns(bytes memory)\n    {\n        return abi.encodePacked(_nftType.sport, _nftType.league, _nftType.season, _nftType.sale, _nftType.tier);\n    }\n\n    // =======================================================================\n    // Getter functions.\n    // =======================================================================\n    // NOTE: In the contract using this library, we could just get the particualr nodes, or even child store nodes from the parent ones directly without these getters, but they also perform the validation and reduce gas costs, in both of the mentioned cases. Hence, always use these getters to get the store nodes, even when getting a hierarchically connected nodes.\n    // NOTE: Putting getters in a separate library, just as we did for deleters, costs us more in gas, since both the contract and the library get more bloated (at least for the deployment), hence we don't do it.\n\n    function _getSport(Store storage _store, NftType memory _nftType)\n        internal\n        view\n        returns(Sport storage)\n    {\n        // Validate input params.\n\n        // Validate existence of objects associated with the input params.\n        Sport storage sport = _store.sports[_nftType.sport];\n        if (!sport.hExists) revert NodeNonexistent(1);\n\n        // Get state vars.\n\n        return sport;\n    }\n\n    function _getLeague(Store storage _store, NftType memory _nftType)\n        internal\n        view\n        returns(League storage)\n    {\n        // Validate input params.\n\n        // Validate existence of objects associated with the input params.\n        League storage league = _store.sports[_nftType.sport].leagues[_nftType.league];\n        if (!league.hExists) revert NodeNonexistent(2);\n\n        // Get state vars.\n\n        return league;\n    }\n\n    // NOTE: Types (i.e. `struct`) containing (nested or not) mappings can only be parameters or return variables of internal or library functions.\n    function _getSeason(Store storage _store, NftType memory _nftType)\n        internal\n        view\n        returns(Season storage)\n    {\n        // Validate input params.\n\n        // Validate existence of objects associated with the input params.\n        Season storage season = _store.sports[_nftType.sport].leagues[_nftType.league].seasons[_nftType.season];\n        if (season.maxSupply == 0) revert NodeNonexistent(3);\n\n        // Get state vars.\n\n        return season;\n    }\n\n    function _getSale(Store storage _store, NftType memory _nftType)\n        internal\n        view\n        returns(Sale storage)\n    {\n        // Validate input params.\n\n        // Validate existence of objects associated with the input params.\n        Sale storage sale = _store.sports[_nftType.sport].leagues[_nftType.league].seasons[_nftType.season].sales[_nftType.sale];\n        if (!sale.hExists) revert NodeNonexistent(4);\n\n        // Get state vars.\n\n        return sale;\n    }\n\n    function _getTier(Store storage _store, NftType memory _nftType)\n        internal\n        view\n        returns(Tier storage)\n    {\n        // Validate input params.\n\n        // Validate existence of objects associated with the input params.\n        // NOTE: If invalid `0` is supplied, the TX will be reverted with `panic code 0x11 (Arithmetic operation underflowed or overflowed outside of an unchecked block)`.\n        uint8 tierIdx = _nftType.tier - 1;\n        Tier[] storage tiers = _store.sports[_nftType.sport].leagues[_nftType.league].seasons[_nftType.season].sales[_nftType.sale].tiers;\n        if (tierIdx >= tiers.length) revert NodeNonexistent(5);\n\n        // Get state vars.\n\n        return tiers[tierIdx];\n    }\n\n}\n"

    },

    "contracts/lib/StoreManager.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.19;\n\nimport \"./../lib/StoreRevealCommit.sol\";\n\n// NOTE: All these functions should be called in functions which are called only by (i.e. limited to) or signature gated by the operator.\n// NOTE: You can have `storage` data location for `external` functions' parameters in libraries, but not in contracts, because libraries don't have their own storage, they us theirs to load in the storage from the calling contract's storage and effectively operate and even change it. Doing the same in a contract would result in an error - Data location must be \"memory\" or \"calldata\" for parameter in external function, but \"storage\" was given. You could use the `.call()` function on the contract, but it's less efficient (also more gas costly) and less secure, and the data needs to be copied to the calling contract's function (instead of just being referenced, as is the case in a library). Hence we made a library, instead of a contract, for this code.\nlibrary StoreManager {\n\n    // =======================================================================\n    // Libraries attached to var types.\n    // =======================================================================\n\n    using Strings for string;\n\n    // =======================================================================\n    // Errors.\n    // =======================================================================\n\n    error ArrayParamInvalid(uint8 paramPosIdx, uint256 arrayPosIdx);\n\n    error EthBalanceInsufficient();\n    error EthWithdrawalFailed();\n\n    // =======================================================================\n    // Events.\n    // =======================================================================\n\n    event PrizesSetOrUpdated(StoreGetter.NftType nftType, string[] prizeTypes, uint16[] prizeTypePcts);\n\n    event OperationalFundsMovedToPrizePool(StoreGetter.NftType nftType, uint256 amount);\n    event OperationalFundsWithdrawn(uint256 amount, address indexed recipient);\n\n    // =======================================================================\n    // Setter functions.\n    // =======================================================================\n\n    // Secrets management.\n\n    function commitRngProvider(StoreGetter.Store storage _store, StoreGetter.NftType memory _nftType, bytes memory _encryptedRngProvider, string memory _encryptedRngProviderString)\n        external\n    {\n        // Commit the encrypted (more precisely, signed) version of the secret data.\n        StoreRevealCommit.commitRngProvider(_store, _nftType, _encryptedRngProvider, _encryptedRngProviderString);\n    }\n\n    function revealRngProvider(StoreGetter.Store storage _store, StoreGetter.NftType memory _nftType, address _revealedRngProvider, address _signer)\n        external\n    {\n        // Verify the previously committed encrypted (more precisely, signed) version of the secret data matches the unencrypted/unsigned/revealed one.\n        StoreRevealCommit.revealRngProvider(_store, _nftType, _revealedRngProvider, _signer);\n    }\n\n    // Minting & burning management.\n\n    function updateTierMaxSupplyLock(StoreGetter.Store storage _store, StoreGetter.NftType memory _nftType, uint24 _unlockedMaxSupply)\n        external\n    {\n        // Validate input params.\n\n        // NOTE: Not needed, since checking for the existance of nodes (specifically, including the last, 5-th/tier node) is done later on.\n        // StoreGetter._validateNftType(_nftType, 5);\n\n        // Validate existence of objects associated with the input params.\n        StoreGetter.Tier storage tier = StoreGetter._getTier(_store, _nftType);\n\n        if (_unlockedMaxSupply < tier.sold || _unlockedMaxSupply > tier.maxSupply) revert StoreRevealCommit.ParamInvalid(1);\n\n        // Update season's state vars.\n\n        tier.unlockedMaxSupply = _unlockedMaxSupply;\n\n        // NOTE: No event emitted, because it's a part of a purily operational security management which shouldn't have any direct effects on the users.\n    }\n\n    // NOTE: Should be enabled only temporarily for a particular free mint batch to be minted, for security reasons.\n    function updateCanAutomatorSignFreeMints(StoreGetter.Store storage _store, bool _canAutomatorSignFreeMints)\n        external\n    {\n        // Update season's state vars.\n\n        _store.canAutomatorSignFreeMints = _canAutomatorSignFreeMints;\n\n        // NOTE: No event emitted, because it's a part of a purily operational security management which shouldn't have any direct effects on the users. Although it can be useful for automator to read this event, in order to be notified when it can free mint, it's a security concern, since this would also notify any other bad actors listening to it, tempting them to get an unauthorized access to the automator's wallet.\n    }\n\n    // Prizes management.\n\n    function addPrizeTypes(StoreGetter.Store storage _store, StoreGetter.NftType memory _nftType, string[] memory _prizeTypes)\n        external\n    {\n        // Validate input params.\n\n        // NOTE: Not needed, since checking for the existance of nodes (specifically, including the last, 1-st/sport node) is done later on. But `NftType` struct's excess params are allowed to be non-default, hence potentially breaking the event filtering logic when filtering by the `NftType` struct, if an event including a `NftType` struct param is emitted within this function.\n        // StoreGetter._validateNftType(_nftType, 1);\n\n        // Validate existence of objects associated with the input params.\n        StoreGetter.Sport storage sport = StoreGetter._getSport(_store, _nftType);\n\n        // NOTE: The first `Sport.prizeTypes` is always a custom prize with a custom (not predefined) amount.\n        if (_prizeTypes.length == 0 || sport.prizeTypes.length == 0 && !_prizeTypes[0].equal(StoreGetter.customPrizeType)) revert StoreRevealCommit.ParamInvalid(1);\n\n        // Validate and update/set sport's state vars.\n\n        // NOTE: `_prizeTypes` is a dynamic/unlimited array, but we implicitly limit it to `uint8` possible values and for the iterator we use the same `uint8` type as it is implicitly used for the dependent `Sport.prizeTypes` field size.\n        for (uint8 i = 0; i < _prizeTypes.length;) {\n            // Validate old/new sport's state vars.\n\n            string memory prizeType = _prizeTypes[i];\n\n            if (bytes(prizeType).length == 0 || sport.hPrizeTypesExist[prizeType]) revert ArrayParamInvalid(1, i);\n\n            // Update/set sport's state vars.\n\n            sport.prizeTypes.push(prizeType);\n            sport.hPrizeTypesExist[prizeType] = true;\n            unchecked { i++; }\n        }\n\n        // NOTE: No event emitted, because until the `Season.prizeTypePcts` field is also updated to set the corresponding values for the newly added `_prizeTypes`, this function has no effect on the business logic.\n    }\n\n    function setOrUpdatePrizes(StoreGetter.Store storage _store, StoreGetter.NftType memory _nftType, uint24 _prizeClaimPeriodMins, uint16[] memory _prizeTypePcts)\n        external\n    {\n        // Validate input params.\n\n        // NOTE: Not needed, since checking for the existance of nodes (specifically, including the last, 3-rd/season node) is done later on. But `NftType` struct's excess params are allowed to be non-default, hence potentially breaking the event filtering logic when filtering by the `NftType` struct, if an event including a `NftType` struct param is emitted within this function.\n        // StoreGetter._validateNftType(_nftType, 3);\n\n        // Validate existence of objects associated with the input params.\n        // NOTE: We could just get the child store nodes from the parent ones directly without the getters, but they also perform the validation and reduce gas costs.\n        StoreGetter.Sport storage sport = StoreGetter._getSport(_store, _nftType);\n        StoreGetter.Season storage season = StoreGetter._getSeason(_store, _nftType);\n\n        if (_prizeClaimPeriodMins < season.prizeClaimPeriodMins) revert StoreRevealCommit.ParamInvalid(1);\n        if (_prizeTypePcts.length != sport.prizeTypes.length) revert StoreRevealCommit.ParamInvalid(2);\n\n        // Validate old/new season's state vars.\n\n        // NOTE: `_prizeTypePcts` is a dynamic/unlimited array, but we implicitly limit it to `uint8` possible values and for the iterator we use the same `uint8` type as it is implicitly used for the dependent `Season.prizeTypePcts` field size.\n        for (uint8 i = 0; i < _prizeTypePcts.length;) {\n            // NOTE: `0` just means the prize type's percentage wasn't set yet.\n            uint16 oldPrizeTypePct = i < season.prizeTypePcts.length ? season.prizeTypePcts[i] : 0;\n\n            // NOTE: The first `Sport.prizeTypes` is always a custom prize with a custom (not predefined) amount.\n            // NOTE: The prize types' percentages are independent from each other.\n            if ((i == 0 && _prizeTypePcts[i] > 0) || season.prizeTypesUsed[i] && _prizeTypePcts[i] != oldPrizeTypePct || _prizeTypePcts[i] < oldPrizeTypePct) revert ArrayParamInvalid(2, i);\n\n            // Update old prize type state vars.\n            // NOTE: NOT NEEDED, because we assign the newly provided array to the one in the state variable later on, hence it's more efficient without doing this.\n            // if (oldPrizeTypePct == 0) {\n            //     season.prizeTypePcts[i] = _prizeTypePcts[i];\n            // }\n            unchecked { i++; }\n        }\n\n        // Update/set season's state vars.\n\n        season.prizeTypePcts = _prizeTypePcts;\n        season.prizeClaimPeriodMins = _prizeClaimPeriodMins;\n\n        // Emit events.\n\n        emit PrizesSetOrUpdated(_nftType, sport.prizeTypes, season.prizeTypePcts);\n    }\n\n    function updatePrizePoolLock(StoreGetter.Store storage _store, StoreGetter.NftType memory _nftType, uint16 _unlockedPrizePoolBps)\n        external\n    {\n        // Validate input params.\n\n        // NOTE: Not needed, since checking for the existance of nodes (specifically, including the last, 3-rd/season node) is done later on. But `NftType` struct's excess params are allowed to be non-default, hence potentially breaking the event filtering logic when filtering by the `NftType` struct, if an event including a `NftType` struct param is emitted within this function.\n        // StoreGetter._validateNftType(_nftType, 3);\n\n        // Validate existence of objects associated with the input params.\n        StoreGetter.Season storage season = StoreGetter._getSeason(_store, _nftType);\n\n        // NOTE: Division must always be the last operation, because decimals are truncated, since we are computing with integers.\n        if (_unlockedPrizePoolBps > 10_000 || _unlockedPrizePoolBps <= season.spentPrizePoolAmount * 1e4 / season.totalPrizePoolAmount) revert StoreRevealCommit.ParamInvalid(1);\n\n        // Update/set season's state vars.\n\n        season.unlockedPrizePoolBps = _unlockedPrizePoolBps;\n\n        // NOTE: No event emitted, because it's a part of a purily operational security management which shouldn't have any direct effects on the users, specifically, the prize pool should be unlocked further each time and before the `season.spentPrizePoolAmount` comes close to the unlocked amount defined by `season.unlockedPrizePoolBps`.\n    }\n\n    // Operational funds management.\n\n    function receiveOperationalFunds(StoreGetter.Store storage _store, uint256 _amount)\n        external\n    {\n        // NOTE: There are no side effects if the sent amount is `0`; adding validation to prevent/revert such case would be less gas efficient.\n        _store.unspentOperationalFundAmount += _amount;\n    }\n\n    function moveOperationalFundsToPrizePool(StoreGetter.Store storage _store, StoreGetter.NftType memory _nftType, uint256 _amount)\n        external\n    {\n        // Validate input params.\n\n        // NOTE: Not needed, since checking for the existance of nodes (specifically, including the last, 3-rd/season node) is done later on. But `NftType` struct's excess params are allowed to be non-default, hence potentially breaking the event filtering logic when filtering by the `NftType` struct, if an event including a `NftType` struct param is emitted within this function.\n        // StoreGetter._validateNftType(_nftType, 3);\n\n        // Validate existence of objects associated with the input params.\n        StoreGetter.Season storage season = StoreGetter._getSeason(_store, _nftType);\n\n        if (_amount == 0) revert StoreRevealCommit.ParamInvalid(1);\n\n        // Validate signer's signature.\n        // NOTE: We don't use signature here, because it can place unnecessary overhead on the operations, i.e. it adds the need of creating a streamline/UI interface/API for getting specific signatures for this function. Hence it's advisable to use an alternative, which is using a multisignature wallet, such as Gnosis.\n\n        // bytes memory data = abi.encodePacked(_nftType.sport, _nftType.league, _nftType.season, _amount);\n        // Signature.verifySignature(_signer, data, _signature);\n\n        // Validate and update operational fund's amount state var.\n\n        if (_amount > _store.unspentOperationalFundAmount) revert EthBalanceInsufficient();\n        _store.unspentOperationalFundAmount -= _amount;\n\n        // Update prize pool's amount state var.\n\n        season.totalPrizePoolAmount += _amount;\n\n        // Emit events.\n\n        emit OperationalFundsMovedToPrizePool(_nftType, _amount);\n    }\n\n    function withdrawOperationalFunds(StoreGetter.Store storage _store, uint256 _amount, address payable _recipient)\n        external\n    {\n        // Validate input params.\n\n        if (_amount == 0) revert StoreRevealCommit.ParamInvalid(0);\n        if (_recipient == address(0)) revert StoreRevealCommit.ParamInvalid(1);\n\n        // Validate signer's signature.\n        // NOTE: We don't use signature here, because it can place unnecessary overhead on the operations, i.e. it adds the need of creating a streamline/UI interface/API for getting specific signatures for this function. Hence it's advisable to use an alternative, which is using a multisignature wallet, such as Gnosis.\n\n        // bytes memory data = abi.encodePacked(_amount, _recipient);\n        // Signature.verifySignature(_signer, data, _signature);\n\n        // Validate and update operational fund's amount state var.\n\n        if (_amount > _store.unspentOperationalFundAmount) revert EthBalanceInsufficient();\n        _store.unspentOperationalFundAmount -= _amount;\n\n        // NOTE: All the state changes should be done before this comment (e.g. to prevent reentrancy attack).\n\n        // Send ETH amount to the recipient and validate it.\n\n        _transferEth(_amount, _recipient);\n\n        // Emit events.\n\n        emit OperationalFundsWithdrawn(_amount, _recipient);\n    }\n\n    // Safe transfer of ETH to another account (wallet or smart contract), since it doesn't impose a gas limit.\n    function _transferEth(uint256 _amount, address _sender)\n        public\n    {\n        (bool sent, ) = _sender.call{value: _amount}(\"\");\n        if (!sent) revert StoreManager.EthWithdrawalFailed();\n    }\n\n}\n"

    },

    "contracts/lib/StoreRevealCommit.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport \"./../lib/Conversion.sol\";\nimport \"./../lib/Signature.sol\";\nimport \"./../lib/StoreGetter.sol\";\n\n// NOTE: All these functions should be called in functions which are called only by (i.e. limited to) or signature gated by the operator.\nlibrary StoreRevealCommit {\n\n    // =======================================================================\n    // Libraries attached to var types.\n    // =======================================================================\n\n    using Strings for string;\n\n    // =======================================================================\n    // Errors.\n    // =======================================================================\n\n    error ParamInvalid(uint8 paramPosIdx);\n    enum StateVars { SeasonEncryptedRngProvider, SeasonRevealedRngProvider }\n    error StateVarAlreadySet(StateVars stateVar);\n\n    // =======================================================================\n    // Events.\n    // =======================================================================\n\n    event RngProviderCommited(StoreGetter.NftType nftType, bytes encryptedRngProvider);\n    event RngProviderRevealed(StoreGetter.NftType nftType, address revealedRngProvider);\n\n    // =======================================================================\n    // Setter functions.\n    // =======================================================================\n\n    function commitRngProvider(StoreGetter.Store storage _store, StoreGetter.NftType memory _nftType, bytes memory _encryptedRngProvider, string memory _encryptedRngProviderString)\n        external\n    {\n        // Validate input params.\n\n        // NOTE: Not needed, since checking for the existance of nodes (specifically, including the last, 3-rd/season node) is done later on. But `NftType` struct's excess params are allowed to be non-default, hence potentially breaking the event filtering logic when filtering by the `NftType` struct, if an event including a `NftType` struct param is emitted within this function.\n        // StoreGetter._validateNftType(_nftType, 3);\n\n        // Validate existence of objects associated with the input params.\n        StoreGetter.Season storage season = StoreGetter._getSeason(_store, _nftType);\n\n        if (_encryptedRngProvider.length == 0) revert ParamInvalid(2);\n        // NOTE: We use `_encryptedRngProviderString` param as the parsed (not converted) `string` equivalent of `bytes` param `_encryptedRngProvider`, becasuse verifying signed signature params (which we do later on) works only if they are provided in the `string` format, instead of `bytes` format. Because we can't include the `_encryptedRngProvider` param in the signature, we verify separately that it's equivalent to its parsed `string` type param/version `_encryptedRngProviderString`.\n        string memory encryptedRngProviderString = Conversion.parseBytesAsString(abi.encodePacked(_encryptedRngProvider));\n        if(!encryptedRngProviderString.equal(_encryptedRngProviderString)) revert ParamInvalid(3);\n\n        // Validate signer's signature.\n        // NOTE: We don't use signature here, because it can place unnecessary overhead on the operations, i.e. it adds the need of creating a streamline/UI interface/API for getting specific signatures for this function. Hence it's advisable to use an alternative, which is using a multisignature wallet, such as Gnosis.\n\n        // We use and verify the calling function call signature to prevent a different sender from committing some encrypted data.\n        // NOTE: Singer and sender aren't part of the signature, because the calling function deduces them, hence it doesn't get them via its function params.\n        // bytes memory data = abi.encodePacked(_nftType.sport, _nftType.league, _nftType.season, _encryptedRngProviderString);\n        // Signature.verifySignature(_signer, data, _signature);\n\n        // Validate season's state vars.\n\n        if (season.encryptedRngProvider.length > 0) revert StateVarAlreadySet(StateVars.SeasonEncryptedRngProvider);\n\n        // Set season's state vars.\n\n        // Commit the encrypted (more precisely, signed) version of the secret data.\n        season.encryptedRngProvider = _encryptedRngProvider;\n\n        // Emit events.\n\n        emit RngProviderCommited(_nftType, _encryptedRngProvider);\n    }\n\n    function revealRngProvider(StoreGetter.Store storage _store, StoreGetter.NftType memory _nftType, address _revealedRngProvider, address _signer)\n        external\n    {\n        // Validate input params.\n\n        // NOTE: Not needed, since checking for the existance of nodes (specifically, including the last, 3-rd/season node) is done later on. But `NftType` struct's excess params are allowed to be non-default, hence potentially breaking the event filtering logic when filtering by the `NftType` struct, if an event including a `NftType` struct param is emitted within this function.\n        // StoreGetter._validateNftType(_nftType, 3);\n\n        // Validate existence of objects associated with the input params.\n        StoreGetter.Season storage season = StoreGetter._getSeason(_store, _nftType);\n\n        if (_revealedRngProvider == address(0)) revert ParamInvalid(2);\n\n        // Validate signer's signatures.\n\n        // NOTE: We don't use signature here, because it can place unnecessary overhead on the operations, i.e. it adds the need of creating a streamline/UI interface/API for getting specific signatures for this function. Hence it's advisable to use an alternative, which is using a multisignature wallet, such as Gnosis.\n        // We use and verify the calling function call signature to prevent a different sender from revealing the encrypted data, in case it somehow comes into its possession.\n        // NOTE: Singer and sender aren't part of the signature, because the calling function deduces them, hence it doesn't get them via its function params.\n        // bytes memory data = abi.encodePacked(_nftType.sport, _nftType.league, _nftType.season, _revealedRngProvider);\n        // Signature.verifySignature(_signer, data, _signature);\n\n        // Validate season's state vars.\n\n        if (season.revealedRngProvider != address(0)) revert StateVarAlreadySet(StateVars.SeasonRevealedRngProvider);\n\n        // Verify the previously committed encrypted (more precisely, signed) version of the secret data matches the unencrypted/unsigned/revealed one.\n        bytes memory data = abi.encodePacked(_revealedRngProvider);\n        Signature.verifySignature(_signer, data, season.encryptedRngProvider);\n\n        // Set season's state vars.\n\n        season.revealedRngProvider = _revealedRngProvider;\n\n        // Emit events.\n\n        emit RngProviderRevealed(_nftType, _revealedRngProvider);\n    }\n\n}\n"

    },

    "contracts/nft_store/AkshunStore.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"./AkshunStoreBuilder.sol\";\n\nimport \"./../lib/StoreManager.sol\";\n\n// NOTE: With multiple inheritance, there is an issue caused by the Diamond Problem, so the order of inheritance is important to avoid it. Solidity solves this problem like Python in that it uses C3 Linearization to force a specific order in the directed acyclic graph (DAG) of base classes. This results in the desirable property of monotonicity but disallows some inheritance graphs, especially, the order in which the base classes are given in the `is` directive is important. You have to list the direct base contracts in the order from \"most base-like\" (i.e. classes on the top level of inheritance) to \"most derived\" (i.e. classes on lower levels). Note that this order is the reverse of the one used in Python. When a function is called that is defined multiple times in different contracts, the given bases are searched from right to left (left to right in Python) in a depth-first manner, stopping at the first match. If a base contract has already been searched, it is skipped. E.g. in `contract C is A, B {}`, `C` requests `B` to override `A` (by specifying `A, B` in this order), and then `C` overrides `B`. Note that this means the default preference is to specify the inherited interfaces and directly inherited/dependent (abstract) contracts at the beginning. See https://docs.soliditylang.org/en/develop/contracts.html#multiple-inheritance-and-linearization\ncontract AkshunStore is AkshunStoreBuilder, ReentrancyGuard, Pausable {\n\n    // =======================================================================\n    // Libraries attached to var types.\n    // =======================================================================\n\n    using Strings for string;\n\n    // =======================================================================\n    // Errors.\n    // =======================================================================\n\n    error StateVarUnset(StoreRevealCommit.StateVars stateVar);\n    error PublicSaleUnset();\n\n    error EthDepositInsufficient();\n    enum MintLimitTypes { Tier, Unlocked, Free, Wallet }\n    error MintLimitReached(MintLimitTypes mintLimitType);\n\n    // =======================================================================\n    // Events.\n    // =======================================================================\n    // NOTE: Indexed event parameters that are not value types, i.e. arrays and structs, are not stored directly but instead a Keccak-256 hash of an encoding is stored. Specifically, the encoding of a struct is the concatenation of the (hashed) encoding of its members, always padded to a multiple of 32 bytes (even `bytes` and `string` types). Hence the indexed arguments for simple types will be in the event topics as is, for example `address`, `uint`, `bytes`; but types like `string` will be hashed with keccak256 and you will not be able to recover them. Hence we don't index `struct`, `[]`, `string` and `bytes` types (some of them, e.g. struct with only one filed, can be recovered though).\n\n    event RngProviderCommited(StoreGetter.NftType nftType, bytes encryptedRngProvider, address indexed sender);\n    event RngProviderRevealed(StoreGetter.NftType nftType, address revealedRngProvider, address indexed sender);\n\n    event SeasonPassMinted(StoreGetter.NftType nftType, uint24 quantity, uint256 cost, uint8 tokenBaseURIIdx, uint256 indexed firstNewSeasonPassId, uint256 indexed lastNewSeasonPassId, address sender, address indexed recipient);\n    event SeasonPassSwapped(StoreGetter.NftType nftType, uint256[] burnedSeasonPassIds, uint8 tokenBaseURIIdx, uint256 indexed firstNewSeasonPassId, uint256 indexed lastNewSeasonPassId, address sender, address indexed recipient);\n\n    event PrizesSetOrUpdated(StoreGetter.NftType nftType, string[] prizeTypes, uint16[] prizeTypePcts);\n    event PrizeClaimed(StoreGetter.NftType nftType, uint256 indexed seasonPassId, uint8 indexed prizeType, uint40 prizeTimestamp, uint256 amount, address sender, address indexed recipient);\n    event OperationalFundsMovedToPrizePool(StoreGetter.NftType nftType, uint256 amount, address indexed signer, address indexed sender);\n\n    // =======================================================================\n    // General contract management functions.\n    // =======================================================================\n\n    // constructor()\n    // {\n    //     // Call initializers.\n    //     // NOTE: By default, the owner of an Ownable contract is the account that deployed it.\n    //\n    //     // Create instances of interfaced contracts and libraries.\n    //\n    //     // Set general management state vars.\n    //\n    // }\n\n    function pause()\n        external\n        onlyOwner\n    {\n        _pause();\n    }\n\n    function unpause()\n        external\n        onlyOwner\n    {\n        _unpause();\n    }\n\n    // =======================================================================\n    // Setter functions.\n    // =======================================================================\n\n    // Secrets management.\n\n    function commitRngProvider(StoreGetter.NftType memory _nftType, bytes memory _encryptedRngProvider, string memory _encryptedRngProviderString)\n        external\n        onlyOwner\n    {\n        // NOTE: Only operator can commit the encrypted version of the RNG provider (i.e. sign TX), hence the `_encryptedRngProvider` is assumed to be encrypted by his wallet.\n\n        // Commit the encrypted (more precisely, signed) version of the secret data.\n        StoreManager.commitRngProvider(store, _nftType, _encryptedRngProvider, _encryptedRngProviderString);\n    }\n\n    function revealRngProvider(StoreGetter.NftType memory _nftType, address _revealedRngProvider)\n        external\n        onlyOwner\n    {\n        // Set sender and signer.\n\n        // NOTE: Sender already validated via `onlyOwner` modifier.\n        // address sender = _msgSender();\n\n        // NOTE: Only operator can reveal (and before that commit the encrypted version of) the RNG provider (i.e. sign TX).\n        address signer = owner();\n\n        // Set season's state vars.\n\n        // Verify the previously committed encrypted (more precisely, signed) version of the secret data matches the unencrypted/unsigned/revealed one.\n        StoreManager.revealRngProvider(store, _nftType, _revealedRngProvider, signer);\n    }\n\n    // Minting & burning management.\n\n    function updateTierMaxSupplyLock(StoreGetter.NftType memory _nftType, uint24 _unlockedMaxSupply)\n        external\n        onlyOwner\n    {\n        StoreManager.updateTierMaxSupplyLock(store, _nftType, _unlockedMaxSupply);\n    }\n\n    // NOTE: Should be enabled only temporarily for a particular free mint batch to be minted, for security reasons.\n    function updateCanAutomatorSignFreeMints(bool _canAutomatorSignFreeMints)\n        external\n        onlyOwner\n    {\n        StoreManager.updateCanAutomatorSignFreeMints(store, _canAutomatorSignFreeMints);\n    }\n\n    function mintSeasonPasses(StoreGetter.NftType memory _nftType, uint24 _quantity, bool _free, uint8 _tokenBaseURIIdx, address _recipient, uint40 _mintTimestamp, bytes memory _signature)\n        external\n        payable\n        whenNotPaused\n        nonReentrant\n    {\n        // Validate input params.\n\n        // NOTE: Not needed, since checking for the existance of nodes (specifically, including the last, 5-th/tier node) is done later on.\n        // StoreGetter._validateNftType(_nftType, 5);\n\n        // Validate existence of objects associated with the input params.\n        // NOTE: We could just get the child store nodes from the parent ones directly without the getters, but they also perform the validation and reduce gas costs.\n        StoreGetter.Season storage season = StoreGetter._getSeason(store, _nftType);\n        StoreGetter.Sale storage sale = StoreGetter._getSale(store, _nftType);\n        StoreGetter.Tier storage tier = StoreGetter._getTier(store, _nftType);\n\n        // NOTE: `_quantity` validation is done later instead, when the quantity is adjusted based on the available quantity.\n        // if (_quantity == 0) revert ParamInvalid(1);\n        // NOTE: `_free` and `_tokenBaseURIIdx` can't be validated, since their default values are also valid.\n        // NOTE: Redundant validation, since `season.nftContract.mint` method already does it.\n        // if (_recipient == address(0)) revert ParamInvalid(4);\n        if (_mintTimestamp == 0) revert ParamInvalid(5);\n\n        // Validate sender and signer's signature.\n\n        { // NOTE: Scope to avoid stack too deep error.\n        // Declare this var inside of this scope to avoid stack too deep error.\n        address sender = _msgSender();\n\n        // NOTE: Only operator can mint for free (i.e. sign TX), unless permitted otherwise.\n        address signer = _free && !store.canAutomatorSignFreeMints || sender == owner() ? owner() : defaultSigner;\n        bytes memory data = bytes.concat(StoreGetter._packNftTypeFields(_nftType), abi.encodePacked(_quantity, _free, _tokenBaseURIIdx, _recipient, _mintTimestamp));\n        uint40 signatureExpiryTimestamp = _mintTimestamp + season.mintPeriodMins * 60;\n        _verifyNonOwnerCallSignature(signer, sender, data, _signature, signatureExpiryTimestamp);\n\n        } { // NOTE: Scope to avoid stack too deep error.\n        // Validate the RNG provider was commited before the minting starts.\n\n        if (season.encryptedRngProvider.length == 0) revert StateVarUnset(StoreRevealCommit.StateVars.SeasonEncryptedRngProvider);\n\n        // Validate and compute mint quantity.\n\n        // NOTE: We don't need to also check for `season.maxSupply`, since `tier.maxSupply`, which is a stricter condition, is enough.\n        // NOTE: Checking `tierUnsold` is not needed, since, `tierUnlockedUnsold` (or `seasonFreeUnsold` in case of a free mint) is a stricter condition (always a lower or the same value), but we use it so we can revert with a more precise error `MintLimitReached`.\n        uint24 tierUnsold = tier.maxSupply - tier.sold;\n        if (tierUnsold == 0) revert MintLimitReached(MintLimitTypes.Tier);\n        // NOTE: Not needed; check the explanation above.\n        // if (_quantity > tierUnsold) {\n        //     _quantity = tierUnsold;\n        // }\n\n        // NOTE: We can free mint even if the requested tier quantity is locked (but it gets updated). This is needed, because otherwise if we would unlock an additional (tier's) NFT quantity in order to free mint it, other users could replay the old signed but not yet sent/broadcasted mint TX messages, effectively minting some or all of the tier's quantities we reserved for free mints.\n        uint24 seasonFreeUnsold;\n        uint24 tierUnlockedUnsold = tier.unlockedMaxSupply - tier.sold;\n        if (!_free) {\n            if (tierUnlockedUnsold == 0) revert MintLimitReached(MintLimitTypes.Unlocked);\n            if (_quantity > tierUnlockedUnsold) {\n                _quantity = tierUnlockedUnsold;\n            }\n        } else {\n            seasonFreeUnsold = season.maxFreeSupply - season.freeSold;\n            if (seasonFreeUnsold == 0) revert MintLimitReached(MintLimitTypes.Free);\n            if (_quantity > seasonFreeUnsold) {\n                _quantity = seasonFreeUnsold;\n            }\n        }\n\n        uint24 salePerWalletUnsold = sale.maxPerWalletSupply - sale.perWalletSold[_recipient];\n        if (salePerWalletUnsold == 0) revert MintLimitReached(MintLimitTypes.Wallet);\n        if (_quantity > salePerWalletUnsold) {\n            _quantity = salePerWalletUnsold;\n        }\n\n        if (_quantity == 0) revert ParamInvalid(1);\n\n        // Update quantity's state vars.\n        // NOTE: Helper vars need to always be updated as well, besides the dependent var.\n\n        tier.sold += _quantity;\n        sale.hSold += _quantity;\n        season.hSold += _quantity;\n\n        if (_free) {\n            if (_quantity > tierUnlockedUnsold) {\n                tier.unlockedMaxSupply = tier.sold;\n            }\n\n            season.freeSold += _quantity;\n            // NOTE: Can't subtract unsigned ints before validating the result is non-negative, since an underflow error would be thrown.\n            uint24 seasonUnsold = season.maxSupply - season.hSold;\n            if (seasonFreeUnsold > seasonUnsold) {\n                season.maxFreeSupply -= seasonFreeUnsold - seasonUnsold;\n            }\n        }\n\n        uint24 salePerWalletSold = sale.perWalletSold[_recipient] += _quantity;\n        if (salePerWalletSold > sale.hMaxPerWalletSold) {\n            sale.hMaxPerWalletSold = salePerWalletSold;\n        }\n\n        } // NOTE: Scope to avoid stack too deep error.\n        // Validate and read mint cost.\n\n        uint256 cost = _quantity * (_free ? 0 : tier.price);\n        if (msg.value < cost) revert EthDepositInsufficient();\n\n        { // NOTE: Scope to avoid stack too deep error.\n        // Update cost's state vars.\n\n        // NOTE: Division must always be the last operation, because decimals are truncated, since we are computing with integers.\n        uint256 addedPrizePoolAmount = cost * season.prizePoolBps / 1e4;\n        season.totalPrizePoolAmount += addedPrizePoolAmount;\n        store.unspentOperationalFundAmount += cost - addedPrizePoolAmount;\n\n        } // NOTE: Scope to avoid stack too deep error.\n        // Update general management state vars.\n\n        senderNonces[_msgSender()]++;\n\n        // NOTE: All the state changes should be done before this comment (e.g. to prevent reentrancy attack).\n\n        _hMintAndReturnOverpayment(_nftType, season, sale, _quantity, cost, tier.tokenPresetURIIdx, _tokenBaseURIIdx, _msgSender(), _recipient);\n    }\n\n    function _hMintAndReturnOverpayment(StoreGetter.NftType memory _nftType, StoreGetter.Season storage _season, StoreGetter.Sale storage _sale, uint24 _quantity, uint256 _cost, uint8 _tokenPresetURIIdx, uint8 _tokenBaseURIIdx, address _sender, address _recipient)\n        private\n    {\n        // Send overpaid ETH amount back to the sender and validate it, if applicable.\n\n        uint256 overpaidCost = msg.value - _cost;\n        if(overpaidCost > 0) {\n            StoreManager._transferEth(overpaidCost, _sender);\n        }\n\n        // Mint new Season Pass NFT to the recipient.\n\n        (uint256 lastNewSeasonPassId, uint256 firstNewSeasonPassId) = _mintSeasonPasses(_nftType, _season, _sale, _quantity, _tokenPresetURIIdx, _tokenBaseURIIdx, _recipient);\n\n        // Emit events.\n\n        emit SeasonPassMinted(_nftType, _quantity, _cost, _tokenBaseURIIdx, firstNewSeasonPassId, lastNewSeasonPassId, _sender, _recipient);\n    }\n\n    function _mintSeasonPasses(StoreGetter.NftType memory _nftType, StoreGetter.Season storage _season, StoreGetter.Sale storage _sale, uint24 _quantity, uint8 _tokenPresetURIIdx, uint8 _tokenBaseURIIdx, address _recipient)\n        private\n        returns(uint256 _lastNewSeasonPassId, uint256 _firstNewSeasonPassId)\n    {\n        for (uint24 i = 0; i < _quantity;) {\n            _lastNewSeasonPassId = _season.nftContract.mint(_season.subcollectionIdx, _tokenPresetURIIdx, _tokenBaseURIIdx, _recipient);\n\n            _sale.tokenTiers[_lastNewSeasonPassId] = _nftType.tier;\n            unchecked { i++; }\n        }\n        _firstNewSeasonPassId = _lastNewSeasonPassId - (_quantity - 1);\n    }\n\n    function swapSeasonPasses(StoreGetter.NftType memory _nftType, uint256[] memory _seasonPassIds, uint24 _quantity, uint8 _tokenBaseURIIdx, address _recipient, uint40 _swapTimestamp, bytes memory _signature)\n        external\n        whenNotPaused\n        nonReentrant\n    {\n        // Validate input params.\n\n        // NOTE: Not needed, since checking for the existance of nodes (specifically, including the last, 5-th/tier node) is done later on.\n        // StoreGetter._validateNftType(_nftType, 5);\n\n        // Validate existence of objects associated with the input params.\n        StoreGetter.Season storage season = StoreGetter._getSeason(store, _nftType);\n        StoreGetter.Sale storage sale = StoreGetter._getSale(store, _nftType);\n        // NOTE: We don't need to check existence of the tier via `_nftType.tier`, because we check it later via `sale.tokenTiers`. But we use the tier instance later on.\n\n        if (_seasonPassIds.length == 0) revert ParamInvalid(1);\n        // We can't mint more Season Pass NFTs than we burn, since that would enlarge the season collection beyond it's quantity limits. And we can only mint new Season Pass NFTs which are of the same NFT type, to assure no quantity limits are broken.\n        if (_quantity > _seasonPassIds.length) revert ParamInvalid(2);\n        // NOTE: The swapped Season Passes will never have the first, i.e. `0`, token's base URI, since it's always a newer than the initial base URI (for the corresponding season).\n        if (_tokenBaseURIIdx == 0) revert ParamInvalid(3);\n        // NOTE: Redundant validation, since `season.nftContract.mint` method already does it.\n        // if (_recipient == address(0)) revert ParamInvalid(4);\n        if (_swapTimestamp == 0) revert ParamInvalid(5);\n\n        // Validate sender and signer's signature.\n\n        { // NOTE: Scope to avoid stack too deep error.\n        // Declare this var inside of this scope to avoid stack too deep error.\n        address sender = _msgSender();\n\n        address signer = sender == owner() ? owner() : defaultSigner;\n        // NOTE: `_nftType.sale` and `_nftType.tier` aren't required in the signature, as explained before.\n        bytes memory data = bytes.concat(StoreGetter._packNftTypeFields(_nftType), abi.encodePacked(_seasonPassIds, _quantity, _tokenBaseURIIdx, _recipient, _swapTimestamp));\n        uint40 signatureExpiryTimestamp = _swapTimestamp + season.mintPeriodMins * 60;\n        _verifyNonOwnerCallSignature(signer, sender, data, _signature, signatureExpiryTimestamp);\n\n        } // NOTE: Scope to avoid stack too deep error.\n        // Update general management state vars.\n\n        senderNonces[_msgSender()]++;\n\n        // NOTE: All the state changes should be done before this comment (e.g. to prevent reentrancy attack).\n\n        // Burn the old sender's Season Pass NFTs.\n\n        _burnSeasonPasses(_nftType, season, sale, _seasonPassIds);\n\n        // Mint new Season Pass NFT to the recipient.\n\n        StoreGetter.Tier storage tier = StoreGetter._getTier(store, _nftType);\n        (uint256 lastNewSeasonPassId, uint256 firstNewSeasonPassId) = _mintSeasonPasses(_nftType, season, sale, _quantity, tier.tokenPresetURIIdx, _tokenBaseURIIdx, _recipient);\n\n        // Emit events.\n\n        emit SeasonPassSwapped(_nftType, _seasonPassIds, _tokenBaseURIIdx, firstNewSeasonPassId, lastNewSeasonPassId, _msgSender(), _recipient);\n    }\n\n    function _burnSeasonPasses(StoreGetter.NftType memory _nftType, StoreGetter.Season storage _season, StoreGetter.Sale storage _sale, uint256[] memory _seasonPassIds)\n        private\n    {\n        // NOTE: `_seasonPassIds` is a dynamic/unlimited array, but we implicitly limit them to `uint24` possible values and for the iterator we use the same `uint24` type as the dependent `Season.maxSupply` field.\n        for (uint24 i = 0; i < _seasonPassIds.length;) {\n            uint8 tier = _sale.tokenTiers[_seasonPassIds[i]];\n            // NOTE: We could just check if all the to-be burnt Season Pass NFTs exist in the sale and are of the same NFT type, but by also checking against `_nftType.tier` we are more explicit and hence more bullet proof, plus `_nftType` can't have invalid values this way, which would break the filtering logic of the event emmiting it.\n            if (tier == 0 || tier != _nftType.tier) revert ArrayParamInvalid(1, i);\n            // NOTE: Redundant validation, since `_season.nftContract.burn` method already does it (via `ERC721.ownerOf`).\n            // if (_seasonPassIds[i] == 0) revert ArrayParamInvalid(1, i);\n            // NOTE: Redundant validation, since `_season.nftContract.burn` method already does it (via `ERC721._isApprovedOrOwner`), and also allows the approved addresses to burn the token.\n            // _season.nftContract.ownerOf(_seasonPassIds[i]);\n\n            _season.nftContract.burn(_seasonPassIds[i]);\n            unchecked {  i++; }\n        }\n    }\n\n    // Prizes management.\n\n    function addPrizeTypes(StoreGetter.NftType memory _nftType, string[] memory _prizeTypes)\n        external\n        onlyOwner\n    {\n        StoreManager.addPrizeTypes(store, _nftType, _prizeTypes);\n    }\n\n    function setOrUpdatePrizes(StoreGetter.NftType memory _nftType, uint24 _prizeClaimPeriodMins, uint16[] memory _prizeTypePcts)\n        external\n        onlyOwner\n    {\n        StoreManager.setOrUpdatePrizes(store, _nftType, _prizeClaimPeriodMins, _prizeTypePcts);\n    }\n\n    function updatePrizePoolLock(StoreGetter.NftType memory _nftType, uint16 _unlockedPrizePoolBps)\n        external\n        onlyOwner\n    {\n        StoreManager.updatePrizePoolLock(store, _nftType, _unlockedPrizePoolBps);\n    }\n\n    function claimPrize(StoreGetter.NftType memory _nftType, uint256 _seasonPassId, uint8 _prizeType, uint40 _prizeTimestamp, uint256 _amount, bool _canUseOperationalFundAmount, address payable _recipient, bytes memory _signature)\n        external\n        whenNotPaused\n        nonReentrant\n    {\n        // Validate input params.\n\n        // NOTE: Not needed, since checking for the existance of nodes (specifically, including the last, 5-th/tier node) is done later on.\n        // StoreGetter._validateNftType(_nftType, 5);\n\n        // Validate existence of objects associated with the input params.\n        // NOTE: We could just get the child store nodes from the parent ones directly without the getters, but they also perform the validation and reduce gas costs.\n        StoreGetter.Season storage season = StoreGetter._getSeason(store, _nftType);\n        // NOTE: We don't need to check which sale is set via `_nftType.sale` (i.e. to which sale the `_seasonPassId` Season Pass NFT belongs to, given that the right one was provided to this function call), because the prizes are always based on the Public sale/stage. But we need it later on to get the Season Pass NFT's tier.\n        // NOTE: We intentionally don't call `StoreGetter._getSale(store, _nftType)` instead, to return a more informative `PublicSaleUnset()` error, instead of `NodeNonexistent(4)` error.\n        StoreGetter.Sale storage publicSale = season.sales[StoreGetter.publicSaleName];\n        if (!publicSale.hExists) revert PublicSaleUnset();\n        // NOTE: We don't need to check existence of the tier via `_nftType.tier`, because we check it later via `sale.tokenTiers`.\n\n        // NOTE: The prize is bound to the particular Season Pass NFT.\n        if (_seasonPassId == 0) revert ParamInvalid(1);\n        // NOTE: `_amount` param should be `> 0` only when `_prizeType` is `0`, since the first `Sport.prizeTypes` is always a custom prize with a custom (not predefined) amount.\n        if ((_prizeType == 0) == (_amount == 0)) revert ParamInvalid(2);\n        if (_prizeTimestamp == 0) revert ParamInvalid(3);\n        // NOTE: `_amount` was already validated with `_prizeType`, and `_canUseOperationalFundAmount` can't be validated, since its default value is also valid.\n        if (_recipient == address(0)) revert ParamInvalid(6);\n\n        // Validate sender and signer's signature.\n\n        address sender = _msgSender();\n\n        { // NOTE: Scope to avoid stack too deep error.\n        // NOTE: Only operator can spend operational funds (i.e. sign TX).\n        address signer = _canUseOperationalFundAmount || sender == owner() ? owner() : defaultSigner;\n        // NOTE: `_nftType.sale` and `_nftType.tier` aren't required in the signature, as explained before.\n        bytes memory data = bytes.concat(StoreGetter._packNftTypeFields(_nftType), abi.encodePacked(_seasonPassId, _prizeType, _prizeTimestamp, _amount, _canUseOperationalFundAmount, _recipient));\n        uint40 signatureExpiryTimestamp = _prizeTimestamp + season.prizeClaimPeriodMins * 60;\n        _verifyNonOwnerCallSignature(signer, sender, data, _signature, signatureExpiryTimestamp);\n\n        // Validate ownership of the winning Season Pass NFT.\n\n        // NOTE: The Season Pass NFT existance check (i.e. `seasonPassOwner == address(0)`) could revert separately with e.g. `TokenNonexistent()` error, but we combine the checks to reduce gas costs.\n        address seasonPassOwner = season.nftContract.ownerOf(_seasonPassId);\n        if (seasonPassOwner == address(0) || sender != seasonPassOwner && (_recipient != seasonPassOwner || sender != defaultSigner && sender != owner())) revert SenderInvalid();\n\n        } // NOTE: Scope to avoid stack too deep error.\n        // Validate and compute prize amount.\n\n        if (_prizeType >= season.prizeTypePcts.length) revert ParamInvalid(2);\n\n        uint256 amount;\n        if (_prizeType == 0) {\n            // The first `Sport.prizeTypes` is always the custom prize type (i.e. `StoreGetter.customPrizeType`) with a custom (not predefined) amount.\n            amount = _amount;\n        } else {\n            StoreGetter.Sale storage sale = StoreGetter._getSale(store, _nftType);\n            uint8 tier = sale.tokenTiers[_seasonPassId];\n            // NOTE: We could just check if the to-be burnt Season Pass NFT exists in the sale, but by also checking against `_nftType.tier` we are more explicit and hence more bullet proof, plus `_nftType` can't have invalid values this way, which would break the filtering logic of the event emmiting it.\n            if (tier == 0 || tier != _nftType.tier) revert ParamInvalid(1);\n\n            // NOTE/TODO: We need to make sure the Public sale/stage has as many tiers as the sale with the most tiers, otherwise an exception can be thrown for accessing the array at an out-of-bounds index.\n            amount = publicSale.tiers[tier - 1].price * season.prizeTypePcts[_prizeType] / 100;\n        }\n\n        { // NOTE: Scope to avoid stack too deep error.\n        // Validate and update prize pool's and operational fund's amount state vars.\n\n        // NOTE: Division must always be the last operation, because decimals are truncated, since we are computing with integers.\n        uint256 unlockedPrizePoolAmount = season.totalPrizePoolAmount * season.unlockedPrizePoolBps / 1e4;\n        uint256 unspentPrizePoolAmount = unlockedPrizePoolAmount - season.spentPrizePoolAmount;\n        if (amount <= unspentPrizePoolAmount) {\n            season.spentPrizePoolAmount += amount;\n        } else {\n            // Use the rest of the prize pool funds when claiming prize from the operational fund.\n            uint256 extraSpentOperationalFundAmount = amount - unspentPrizePoolAmount;\n            if (!_canUseOperationalFundAmount || extraSpentOperationalFundAmount > store.unspentOperationalFundAmount) revert StoreManager.EthBalanceInsufficient();\n\n            season.spentPrizePoolAmount = unlockedPrizePoolAmount;\n            store.unspentOperationalFundAmount -= extraSpentOperationalFundAmount;\n        }\n\n        // Update prize state vars.\n\n        // NOTE: Check if it's cheaper to always set it, without checking it's value. Storing values is expensive in Solidity, so probably it's not.\n        if (!season.prizeTypesUsed[_prizeType]) {\n            season.prizeTypesUsed[_prizeType] = true;\n        }\n\n        // Update general management state vars.\n\n        senderNonces[sender]++;\n\n        // NOTE: All the state changes should be done before this comment (e.g. to prevent reentrancy attack).\n\n        // Send ETH amount to the recipient and validate it.\n\n        StoreManager._transferEth(amount, _recipient);\n\n        } // NOTE: Scope to avoid stack too deep error.\n        // Emit events.\n\n        emit PrizeClaimed(_nftType, _seasonPassId, _prizeType, _prizeTimestamp, amount, sender, _recipient);\n    }\n\n    // Operational funds management.\n\n    function moveOperationalFundsToPrizePool(StoreGetter.NftType memory _nftType, uint256 _amount)\n        external\n        onlyOwner\n    {\n        StoreManager.moveOperationalFundsToPrizePool(store, _nftType, _amount);\n    }\n\n    function withdrawOperationalFunds(uint256 _amount, address payable _recipient)\n        external\n        onlyOwner\n    {\n        StoreManager.withdrawOperationalFunds(store, _amount, _recipient);\n    }\n\n    // NOTE: To enable depositing ETH directy to the contract's address, the contract must define at least one of the functions below. `receive()` is called if `msg.data` is empty, otherwise `fallback()` is called.\n\n    // Function invoked when ETH is deposited directy to the contract's address and `msg.data` is empty.\n    //\n    // We use it to assign the ETH which was deposited directy to the contract's address, to the operational fund.\n    //\n    // NOTE: We assign the deposited ETH to the operational fund because then we can still transfer any of the available ETH amount from the operational fund to the prize pool.\n    receive()\n        external\n        payable\n    {\n        // NOTE: There are no side effects if the sent amount is `0`; adding validation to prevent/revert such case would be less gas efficient.\n        // NOTE: It could be safer (i.e. more stricter) to send the `msg` var itself and get the sent amount in the called function via `msg.value`, but the values of all members of `msg`, including `msg.sender` and `msg.value`, can change for every external function call. This includes calls to library functions.\n        StoreManager.receiveOperationalFunds(store, msg.value);\n    }\n\n    // A fallback function, optionally payable (i.e. is defined with `payable` modifier), invoked when no other function matches the call (not even the `receive()` function, but only if `fallback()` function is payable), otherwise the contract will throw an exception. If it is payable, then it's also invoked when ETH is deposited directy to the contract's address and `msg.data` is either not empty or `msg.data` is empty and `receive()` method doesn't exists (i.e. isn't defined in the contract; in which case the `fallback()` function is restricted to 2300 gas, even if `call()` function was used to send ETH), otherwise the contract will throw an exception in both cases.\n    //\n    // NOTE: You should only need to implement the fallback function if you are following an upgrade or proxy pattern.\n    // fallback()\n    //     external\n    //     payable\n    // {}\n\n    // =======================================================================\n    // Getter functions.\n    // =======================================================================\n\n    function getPerSaleWalletSold(StoreGetter.NftType memory _nftType, address _user)\n        external\n        view\n        returns(uint24)\n    {\n        // Validate input params.\n\n        // Validate existence of objects associated with the input params.\n        StoreGetter.Sale storage sale = StoreGetter._getSale(store, _nftType);\n\n        // Get state vars.\n\n        return sale.perWalletSold[_user];\n    }\n\n}\n"

    },

    "contracts/nft_store/AkshunStoreBuilder.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.19;\n\nimport \"./../common/Signable.sol\";\n\nimport \"./../lib/StoreDeleter.sol\";\n\n// NOTE: For functions which are setting or updating the Store nodes we check for \"existance\", i.e. whether the Store node was already set and is trying to be updated now, instead of checking for \"usage\", e.g. whether the Store node was already used (e.g. when any of it's associated NFTs were already minted), because this way we prevent changing Store structure/settings in a way which would be worse for the user who might use the contract after this change, while assuming it wasn't changed (especially in the edge case where he would be the first one to execute the (singed) mint TX which was singed before this change). But we use the \"usage\" approach for functions which are deleting the Store nodes, since in that case e.g. the minting TX of the affected NFT type would fail/revert anyway.\n// NOTE: Could also move all the code inside of set or update functions into a library called `StoreSetter`, and reduce this contract's size even further, but the gas costs would rise because of the calls to the libraries. See: https://ethereum.stackexchange.com/questions/101961/is-it-safe-to-mark-library-functions-that-modify-the-calling-contracts-state-as\nabstract contract AkshunStoreBuilder is Signable {\n\n    // =======================================================================\n    // Libraries attached to var types.\n    // =======================================================================\n\n    using Strings for string;\n\n    // =======================================================================\n    // Errors.\n    // =======================================================================\n\n    error ArrayParamInvalid(uint8 paramPosIdx, uint256 arrayPosIdx);\n\n    // =======================================================================\n    // Events.\n    // =======================================================================\n\n    event SeasonSetOrUpdated(StoreGetter.NftType nftType, uint24 maxSupply, uint24 maxFreeSupply, uint24 mintPeriodMins, uint16 prizePoolBps);\n    event SaleSetOrUpdated(StoreGetter.NftType nftType, bool tryout, uint24 maxPerWalletSupply, uint24[] tiersMaxSupply, uint256[] tiersPrice);\n    event NodeDeleted(StoreGetter.NftType nftType, uint8 nodeDepth);\n\n    // =======================================================================\n    // State vars.\n    // =======================================================================\n\n    // Hierarchical store structure.\n    // NOTE: Can't use `public` visibility, because this struct has all its members omitted, therefore the getter cannot return any values.\n    StoreGetter.Store store;\n\n    // =======================================================================\n    // Setter functions.\n    // =======================================================================\n\n    function setOrUpdateSeason(address _nftContract, StoreGetter.NftType memory _nftType, uint24 _maxSupply, uint24 _maxFreeSupply, uint24 _mintPeriodMins, uint16 _prizePoolBps)\n        external\n        onlyOwner\n    {\n        // Validate input params.\n\n        StoreGetter._validateNftType(_nftType, 3);\n\n        // Validate existence of objects associated with the input params.\n        // NOTE: We can't use `StoreNodes`'s getters, because our encompassing function also sets, not just updates the store's sport, league and season nodes, which means the TX would revert on (initial) setup. Hence we validate the NFT type fileds via `StoreGetter._validateNftType` validator.\n        StoreGetter.Sport storage sport = store.sports[_nftType.sport];\n        StoreGetter.League storage league = sport.leagues[_nftType.league];\n        StoreGetter.Season storage season = league.seasons[_nftType.season];\n\n        // NOTE: We could instead use `bool seasonUsed = season.hSold > 0`, but this way we prevent changing Store (particularly, season) structure/settings in a way which would be worse for the user who might use the contract after this change, while assuming it wasn't changed (especially in the edge case where he would be the first one to execute the (singed) mint TX which was singed before this change). But we use this \"used\" approach when deleting the Store nodes, since in that case the minting TX of the affected NFT type would fail/revert anyway. We use \"exists\" instead of \"used\" also for other set or update method (e.g. `setOrUpdateSale`).\n        bool seasonExists = season.maxSupply > 0;\n        if (_nftContract == address(0) || seasonExists && _nftContract != address(season.nftContract)) revert ParamInvalid(0);\n        if (_maxSupply == 0 || seasonExists && (_maxSupply > season.maxSupply || _maxSupply < season.hSold || _maxSupply < season.hTotalSalesMaxSupply)) revert ParamInvalid(2);\n        if (_maxFreeSupply > _maxSupply || seasonExists && (_maxFreeSupply > season.maxFreeSupply || _maxFreeSupply < season.freeSold)) revert ParamInvalid(3);\n        if (_mintPeriodMins == 0 || _mintPeriodMins < season.mintPeriodMins) revert ParamInvalid(4);\n        // NOTE: The current logic doesn't work correctly when prize pool BPS is updated. Hence, we only allow to set it.\n        if (_prizePoolBps == 0 || _prizePoolBps > 10_000 || seasonExists && _prizePoolBps != season.prizePoolBps) revert ParamInvalid(5);\n\n        // Update/set season's state vars.\n\n        season.maxSupply = _maxSupply;\n        season.maxFreeSupply = _maxFreeSupply;\n        season.mintPeriodMins = _mintPeriodMins;\n\n        if (!seasonExists) {\n            season.subcollectionIdx = store.subcollectionsCnt++;\n            season.nftContract = IAkshunSeasonPassNft(_nftContract);\n            season.prizePoolBps = _prizePoolBps;\n\n            // Update season's parent nodes' state vars.\n\n            league.hSeasonNames.push(_nftType.season);\n\n            if (!league.hExists) {\n                league.hExists = true;\n                sport.hLeagueNames.push(_nftType.league);\n\n                if (!sport.hExists) {\n                    sport.hExists = true;\n                    store.hSportNames.push(_nftType.sport);\n                }\n            }\n        }\n\n        // Emit events.\n\n        emit SeasonSetOrUpdated(_nftType, _maxSupply, _maxFreeSupply, _mintPeriodMins, _prizePoolBps);\n    }\n\n    function setOrUpdateSale(StoreGetter.NftType memory _nftType, uint8 _hSaleNameIdx, bool _tryout, uint24 _maxPerWalletSupply, uint8[] memory _tokenPresetURIIdxs, uint24[] memory _tiersMaxSupply, uint256[] memory _tiersPrice)\n        external\n        onlyOwner\n    {\n        // Validate input params.\n\n        StoreGetter._validateNftType(_nftType, 4);\n\n        // Validate existence of objects associated with the input params.\n        // NOTE: We could just get the child store nodes from the parent ones directly without the getters, but they also perform the validation and reduce gas costs.\n        StoreGetter.Season storage season = StoreGetter._getSeason(store, _nftType);\n        // NOTE: We can't use `StoreNodes`'s getters, because our encompassing function also sets, not just updates the store's sale and tier nodes, which means the TX would revert on (initial) setup. Hence we validate the NFT type fileds via `StoreGetter._validateNftType` validator.\n        StoreGetter.Sale storage sale = season.sales[_nftType.sale];\n\n        if (_tokenPresetURIIdxs.length == 0) revert ParamInvalid(4);\n        if (_tiersMaxSupply.length != _tokenPresetURIIdxs.length) revert ParamInvalid(5);\n        if (_tiersPrice.length != _tiersMaxSupply.length) revert ParamInvalid(6);\n\n        { // NOTE: Scope to avoid stack too deep error.\n        // Validate sale's state vars.\n\n        // NOTE: We intentionally don't call `StoreGetter._getSale(store, _nftType)` instead, to not raise `NodeNonexistent(4)` error.\n        StoreGetter.Sale storage publicSale = season.sales[StoreGetter.publicSaleName];\n        // Tryout sale phases can only be added after the Public sale phase, and they can't be switched to non-tryout and vice versa.\n        if (sale.hExists && sale.tryout != _tryout || _tryout && !publicSale.hExists) revert ParamInvalid(2);\n\n        } // NOTE: Scope to avoid stack too deep error.\n        // Previous sale's tiers' quantities and prices must be better for the user (i.e. scarcer quantity and cheaper price), to incentivize minting at an early stage. Except for the tryout Season Pass NFTs, of which prices and quantities are not validated against the previous sale (because the prices, and probably also quantities, will be much smaller; and the prizes will be lesser).\n        // NOTE: We use `_hSaleNameIdx` helper param to avoid iterating over `season.sales` array until finding the (potential) previous sale. Could be avoided with a different approach.\n        if (!sale.hExists && _hSaleNameIdx != season.hSaleNames.length || sale.hExists && (_hSaleNameIdx >= season.hSaleNames.length || !season.hSaleNames[_hSaleNameIdx].equal(_nftType.sale))) revert ParamInvalid(1);\n        if (_hSaleNameIdx > 0 && !_tryout) {\n            StoreGetter.Sale storage previousSale = season.sales[season.hSaleNames[_hSaleNameIdx - 1]];\n            StoreGetter.Tier storage previousSaleFirstTier = previousSale.tiers[0];\n            StoreGetter.Tier storage previousSaleLastTier = previousSale.tiers[previousSale.tiers.length - 1];\n\n            if (_tiersMaxSupply[0] < previousSaleFirstTier.maxSupply || _tiersMaxSupply[_tiersMaxSupply.length - 1] < previousSaleLastTier.maxSupply) revert ParamInvalid(5);\n            if (_tiersPrice[0] < previousSaleFirstTier.price || _tiersPrice[_tiersPrice.length - 1] < previousSaleLastTier.price) revert ParamInvalid(6);\n        }\n\n        // Validate and delete/update/set sale's state vars.\n\n        if (_tiersMaxSupply.length < sale.tiers.length) {\n            // NOTE: We implicitly limit the `sale.tiers` array (and hence the dependent `_tiersMaxSupply` array) size to `uint8` possible values via `NftType.tier` field.\n            for (uint8 i = uint8(sale.tiers.length) - 1; i >= _tiersMaxSupply.length;) {\n                // Validate excess old tier's state vars.\n                StoreGetter.Tier storage excessOldTier = sale.tiers[i];\n                if (excessOldTier.sold > 0) revert StoreDeleter.LeafNodeAlreadyUsed(i);\n\n                // Read excess old tier's state vars before they are deleted/reset. Update sale's and sale's parent nodes' state vars.\n                // NOTE: Helper vars need to always be updated as well, besides the dependent var.\n                sale.hMaxSupply -= excessOldTier.maxSupply;\n                season.hTotalSalesMaxSupply -= excessOldTier.maxSupply;\n\n                // Delete excess old tier's state vars.\n                sale.tiers.pop();\n                unchecked { i--; }\n            }\n        }\n\n        uint24 hSaleMaxSupply = 0;\n        bool previousTierExists;\n        uint24 previousTierMaxSupply;\n        uint256 previousTierPrice;\n        // NOTE: We implicitly limit the `sale.tiers` array (and hence the dependent `_tiersMaxSupply` array) size to `uint8` possible values via `NftType.tier` field.\n        for (uint8 i = 0; i < _tiersMaxSupply.length;) {\n            // Validate old/new tier's state vars.\n            StoreGetter.Tier memory oldTier; // NOTE: Can't use `storage`, because a storage var always needs to point to an existing state variable.\n            bool oldTierSoldAny;\n            bool tierExists = i < sale.tiers.length;\n            if (tierExists) {\n                oldTier = sale.tiers[i];\n                oldTierSoldAny = oldTier.sold > 0;\n            }\n\n            // NOTE: The rules for updating preset URIs are relaxed, since they aren't so important, because the actual/revealed base URIs are later assigned permanently (to each token).\n            if (i > 0 && _tokenPresetURIIdxs[i] <= _tokenPresetURIIdxs[i - 1]) revert ArrayParamInvalid(4, i);\n            // Previous sale's tier quantity must be better for the user (i.e. scarcer quantity), but the price must be worse for the user (i.e. more expensive price), since the payout is bigger, to incentivize minting of sale's higher tier grades (i.e. tiers with lower tier number). If a sale's lower tier grade has already some Season Pass NFTs sold and gets updated, its quantity must get better for the user (i.e. scarcer quantity), to incentivize minting of this sale's tier grade, but its price must remain the same, to not harm the users who already bought this tier's Season Pass NFTs. Note that if the tier hasn't sold any Season Pass NFTs yet, we can update both its quantity and price with the same validation rules as if it would be added (for the first time) instead, because in such case any change to the validation logic doesn't make sense, since the tier can also be deleted via `StoreDeleter.deleteSale` method and then readded via this method.\n            // NOTE: Even though you can later reduce the quantity of the tiers' supply, it can't be lower than the previous tier, and can't be lower than the previous sale's last tier, and the lowest quantity the first sale's first tier can have is 1, and the lowest quantity the last sale's last tier can have equals the previous tier's quantity (if it's the only tier in a sale, than the previous tier is the previous sale's last tier). A use case for lowering the quantities is when the different sales and tiers wouldn't get sold out.\n            if (_tiersMaxSupply[i] == 0 || previousTierExists && _tiersMaxSupply[i] < previousTierMaxSupply || oldTierSoldAny && (_tiersMaxSupply[i] < oldTier.sold || _tiersMaxSupply[i] > oldTier.maxSupply)) revert ArrayParamInvalid(5, i);\n            if (_tiersPrice[i] == 0 || previousTierExists && _tiersPrice[i] > previousTierPrice || oldTierSoldAny && _tiersPrice[i] != oldTier.price) revert ArrayParamInvalid(6, i);\n\n            hSaleMaxSupply += _tiersMaxSupply[i];\n            if (tierExists) {\n                // Read old tier's state vars before they are updated.\n                // NOTE: Not needed.\n\n                // Update old tier's state vars.\n                oldTier.maxSupply = _tiersMaxSupply[i];\n                if (oldTier.unlockedMaxSupply > oldTier.maxSupply) {\n                    oldTier.unlockedMaxSupply = oldTier.maxSupply;\n                }\n                oldTier.price = _tiersPrice[i];\n                sale.tiers[i] = oldTier;\n            } else {\n                // Set new tier's state vars.\n                StoreGetter.Tier memory newTier = StoreGetter.Tier(_tokenPresetURIIdxs[i], _tiersMaxSupply[i], 0, 0, _tiersPrice[i]);\n                sale.tiers.push(newTier);\n            }\n\n            previousTierExists = tierExists;\n            previousTierMaxSupply = _tiersMaxSupply[i];\n            previousTierPrice = _tiersPrice[i];\n            unchecked { i++; }\n        }\n\n        // Update/set and validate sale's and sale's parent nodes' state vars.\n\n        if (_maxPerWalletSupply == 0 || _maxPerWalletSupply > hSaleMaxSupply || sale.hExists && (_maxPerWalletSupply > sale.maxPerWalletSupply || _maxPerWalletSupply < sale.hMaxPerWalletSold)) revert ParamInvalid(3);\n        // NOTE: When subtracting `uint<number>`s, do it in a way the result and any intermediary calculations can't be negative, to prevent arithmetic underflow error. Hence we need to first add to the var the new value(s) and then, always at the end, subtract from it the old one(s).\n        // Wrong:\n        // `season.hTotalSalesMaxSupply += hSaleMaxSupply - sale.hMaxSupply;`\n        // Correct:\n        // `season.hTotalSalesMaxSupply += hSaleMaxSupply;`\n        // `season.hTotalSalesMaxSupply -= sale.hMaxSupply;`\n        // Or:\n        season.hTotalSalesMaxSupply = season.hTotalSalesMaxSupply + hSaleMaxSupply - sale.hMaxSupply;\n        if (season.hTotalSalesMaxSupply > season.maxSupply) revert ParamInvalid(5);\n\n        if (!sale.hExists) {\n            season.hSaleNames.push(_nftType.sale);\n\n            sale.hExists = true;\n            sale.tryout = _tryout;\n        }\n        sale.hMaxSupply = hSaleMaxSupply;\n        sale.maxPerWalletSupply = _maxPerWalletSupply;\n\n        // Emit events.\n\n        emit SaleSetOrUpdated(_nftType, _tryout, _maxPerWalletSupply, _tiersMaxSupply, _tiersPrice);\n    }\n\n    // =======================================================================\n    // Deleter functions.\n    // =======================================================================\n\n    function deleteSport(StoreGetter.NftType memory _nftType)\n        external\n        onlyOwner\n    {\n        StoreDeleter.deleteSport(store, _nftType);\n    }\n\n    function deleteLeague(StoreGetter.NftType memory _nftType)\n        external\n        onlyOwner\n    {\n        StoreDeleter.deleteLeague(store, _nftType);\n    }\n\n    function deleteSeason(StoreGetter.NftType memory _nftType)\n        external\n        onlyOwner\n    {\n        StoreDeleter.deleteSeason(store, _nftType);\n\n        // Update state vars.\n\n        store.subcollectionsCnt--;\n    }\n\n    function deleteSale(StoreGetter.NftType memory _nftType)\n        external\n        onlyOwner\n    {\n        StoreDeleter.deleteSale(store, _nftType);\n    }\n\n    // =======================================================================\n    // Getter functions.\n    // =======================================================================\n    // NOTE: Putting getters in a separate library, just as we did for deleters, costs us more in gas, since both the contract and the library get more bloated (at least for the deployment), hence we don't do it.\n\n    function getStore()\n        external\n        view\n        returns(uint256 _unspentOperationalFundAmount, uint16 _subcollectionsCnt, bool _canAutomatorSignFreeMints, string[] memory _sportNames)\n    {\n        return (store.unspentOperationalFundAmount, store.subcollectionsCnt, store.canAutomatorSignFreeMints, store.hSportNames);\n    }\n\n    function getSport(StoreGetter.NftType memory _nftType)\n        external\n        view\n        returns(string[] memory _prizeTypes, string[] memory _leagueNames)\n    {\n        // Validate input params.\n\n        // Validate existence of objects associated with the input params.\n        StoreGetter.Sport storage sport = StoreGetter._getSport(store, _nftType);\n\n        // Get state vars.\n\n        return (sport.prizeTypes, sport.hLeagueNames);\n    }\n\n    function getLeague(StoreGetter.NftType memory _nftType)\n        external\n        view\n        returns(string[] memory _seasonNames)\n    {\n        // Validate input params.\n\n        // Validate existence of objects associated with the input params.\n        StoreGetter.League storage league = StoreGetter._getLeague(store, _nftType);\n\n        // Get state vars.\n\n        return league.hSeasonNames;\n    }\n\n    // NOTE: Types (i.e. `struct`) containing (nested or not) mappings can only be parameters or return variables of internal or library functions. Hence we can't directly return the `StoreNode`'s `struct`s.\n    function getSeason(StoreGetter.NftType memory _nftType)\n        external\n        view\n        returns(address _nftContract, uint16 _subcollectionIdx, address _revealedRngProvider, uint24[2] memory _maxSupplyAndSold, uint24[2] memory _maxFreeSupplyAndSold, uint24 _mintPeriodMins, uint16[2] memory _prizePoolBpsAndUnlockedBps, uint256[2] memory _totalAndSpentPrizePoolAmount, uint16[] memory _prizeTypePcts, uint24 _prizeClaimPeriodMins, string[] memory _saleNames)\n    {\n        // Validate input params.\n\n        // Validate existence of objects associated with the input params.\n        StoreGetter.Season storage season = StoreGetter._getSeason(store, _nftType);\n\n        // Get state vars.\n\n        return (address(season.nftContract), season.subcollectionIdx, season.revealedRngProvider, [season.maxSupply, season.hSold], [season.maxFreeSupply, season.freeSold], season.mintPeriodMins, [season.prizePoolBps, season.unlockedPrizePoolBps], [season.totalPrizePoolAmount, season.spentPrizePoolAmount], season.prizeTypePcts, season.prizeClaimPeriodMins, season.hSaleNames);\n    }\n\n    function getSale(StoreGetter.NftType memory _nftType)\n        external\n        view\n        returns(bool _tryout, uint24[2] memory _maxPerWalletSupplyAndMaxSold, uint8 _tiersCnt)\n    {\n        // Validate input params.\n\n        // Validate existence of objects associated with the input params.\n        StoreGetter.Sale storage sale = StoreGetter._getSale(store, _nftType);\n\n        // Get state vars.\n\n        return (sale.tryout, [sale.maxPerWalletSupply, sale.hMaxPerWalletSold], uint8(sale.tiers.length));\n    }\n\n    function getTier(StoreGetter.NftType memory _nftType)\n        external\n        view\n        returns(uint8 _tokenPresetURIIdx, uint24 _maxSupply, uint24 _unlockedMaxSupply, uint24 _sold, uint256 _price)\n    {\n        // Validate input params.\n\n        // Validate existence of objects associated with the input params.\n        StoreGetter.Tier storage tier = StoreGetter._getTier(store, _nftType);\n\n        // Get state vars.\n\n        return (tier.tokenPresetURIIdx, tier.maxSupply, tier.unlockedMaxSupply, tier.sold, tier.price);\n    }\n\n}\n"

    },

    "contracts/nfts/IAkshunSeasonPassNft.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.19;\n\n// NOTE: We can also use the interfaces for reading/changing the state of already deployed/existing (e.g. others') contracts and libraries. Only include the methods needed/used, because just those methods will be imported and compiled to ABI, so you save gas on contract/library deployment. You create an instance of such interfaced contract/library from their address, preferably by passing it in the constuctor or/and initializer when deploying.\ninterface IAkshunSeasonPassNft {\n    function mint(uint16 subcollectionIdx, uint8 tokenPresetURIIdx, uint8 tokenBaseURIIdx, address to) external returns(uint256);\n    function burn(uint256 tokenId) external;\n    function ownerOf(uint256 tokenId) external returns(address);\n}\n"

    }

  },

  "settings": {

    "optimizer": {

      "enabled": true,

      "runs": 200

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "libraries": {

      "contracts/lib/Signature.sol": {

        "Signature": "0x1e3f549ed59d80dcbb424cd43d1528075751dbdd"

      },

      "contracts/lib/StoreDeleter.sol": {

        "StoreDeleter": "0x074f021189d5eba8384250e71957afbecda64d7c"

      },

      "contracts/lib/StoreManager.sol": {

        "StoreManager": "0xf7adbcf76ded456b72ff8cc86142650db47801bd"

      }

    }

  }

}}