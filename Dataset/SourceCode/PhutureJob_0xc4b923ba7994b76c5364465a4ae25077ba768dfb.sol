{{

  "language": "Solidity",

  "sources": {

    "contracts/PhutureJob.sol": {

      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nimport \"./libraries/ValidatorLibrary.sol\";\n\nimport \"./interfaces/IOrdererV2.sol\";\nimport \"./interfaces/IPhutureJob.sol\";\nimport \"./interfaces/IIndexRegistry.sol\";\nimport \"./interfaces/external/IKeep3r.sol\";\n\n/// @title Phuture job\n/// @notice Contains signature verification and order execution logic\ncontract PhutureJob is IPhutureJob, Pausable {\n    using ERC165Checker for address;\n    using Counters for Counters.Counter;\n    using ValidatorLibrary for ValidatorLibrary.Sign;\n\n    /// @notice Validator role\n    bytes32 internal immutable VALIDATOR_ROLE;\n    /// @notice Order executor role\n    bytes32 internal immutable ORDER_EXECUTOR_ROLE;\n    /// @notice Role allows configure ordering related data/components\n    bytes32 internal immutable ORDERING_MANAGER_ROLE;\n\n    /// @notice Nonce\n    Counters.Counter internal _nonce;\n\n    address public immutable override keep3r;\n    /// @inheritdoc IPhutureJob\n    address public immutable override registry;\n\n    /// @inheritdoc IPhutureJob\n    uint256 public override minAmountOfSigners = 1;\n\n    /// @notice Checks if msg.sender has the given role's permission\n    modifier onlyRole(bytes32 role) {\n        require(IAccessControl(registry).hasRole(role, msg.sender), \"PhutureJob: FORBIDDEN\");\n        _;\n    }\n\n    /// @notice Pays keeper for work\n    modifier payKeeper(address _keeper) {\n        require(IKeep3r(keep3r).isKeeper(_keeper), \"PhutureJob: !KEEP3R\");\n        _;\n        IKeep3r(keep3r).worked(_keeper);\n    }\n\n    constructor(address _keep3r, address _registry) {\n        bytes4[] memory interfaceIds = new bytes4[](2);\n        interfaceIds[0] = type(IAccessControl).interfaceId;\n        interfaceIds[1] = type(IIndexRegistry).interfaceId;\n        require(_registry.supportsAllInterfaces(interfaceIds), \"PhutureJob: INTERFACE\");\n\n        VALIDATOR_ROLE = keccak256(\"VALIDATOR_ROLE\");\n        ORDER_EXECUTOR_ROLE = keccak256(\"ORDER_EXECUTOR_ROLE\");\n        ORDERING_MANAGER_ROLE = keccak256(\"ORDERING_MANAGER_ROLE\");\n\n        keep3r = _keep3r;\n        registry = _registry;\n\n        _pause();\n    }\n\n    /// @inheritdoc IPhutureJob\n    function setMinAmountOfSigners(uint256 _minAmountOfSigners) external override onlyRole(ORDERING_MANAGER_ROLE) {\n        require(_minAmountOfSigners != 0, \"PhutureJob: INVALID\");\n\n        minAmountOfSigners = _minAmountOfSigners;\n    }\n\n    /// @inheritdoc IPhutureJob\n    function pause() external override onlyRole(ORDERING_MANAGER_ROLE) {\n        _pause();\n    }\n\n    /// @inheritdoc IPhutureJob\n    function unpause() external override onlyRole(ORDERING_MANAGER_ROLE) {\n        _unpause();\n    }\n\n    /// @inheritdoc IPhutureJob\n    function internalSwap(ValidatorLibrary.Sign[] calldata _signs, IOrdererV2.InternalSwapV2 calldata _info)\n        external\n        override\n        whenNotPaused\n        payKeeper(msg.sender)\n    {\n        IOrdererV2 orderer = IOrdererV2(IIndexRegistry(registry).orderer());\n        _validate(_signs, abi.encodeWithSelector(orderer.internalSwap.selector, _info));\n        orderer.internalSwap(_info);\n    }\n\n    /// @inheritdoc IPhutureJob\n    function externalSwap(ValidatorLibrary.Sign[] calldata _signs, IOrdererV2.ExternalSwapV2 calldata _info)\n        external\n        override\n        whenNotPaused\n        payKeeper(msg.sender)\n    {\n        IOrdererV2 orderer = IOrdererV2(IIndexRegistry(registry).orderer());\n        _validate(_signs, abi.encodeWithSelector(orderer.externalSwap.selector, _info));\n        orderer.externalSwap(_info);\n    }\n\n    /// @inheritdoc IPhutureJob\n    function internalSwapManual(ValidatorLibrary.Sign[] calldata _signs, IOrdererV2.InternalSwapV2 calldata _info)\n        external\n        override\n        onlyRole(ORDER_EXECUTOR_ROLE)\n    {\n        IOrdererV2 orderer = IOrdererV2(IIndexRegistry(registry).orderer());\n        _validate(_signs, abi.encodeWithSelector(orderer.internalSwap.selector, _info));\n        orderer.internalSwap(_info);\n    }\n\n    /// @inheritdoc IPhutureJob\n    function externalSwapManual(ValidatorLibrary.Sign[] calldata _signs, IOrdererV2.ExternalSwapV2 calldata _info)\n        external\n        override\n        onlyRole(ORDER_EXECUTOR_ROLE)\n    {\n        IOrdererV2 orderer = IOrdererV2(IIndexRegistry(registry).orderer());\n        _validate(_signs, abi.encodeWithSelector(orderer.externalSwap.selector, _info));\n        orderer.externalSwap(_info);\n    }\n\n    /// @inheritdoc IPhutureJob\n    function nonce() external view override returns (uint256) {\n        return _nonce.current();\n    }\n\n    /// @notice Verifies that list of signatures provided by validator have signed given `_data` object\n    /// @param _signs List of signatures\n    /// @param _data Data object to verify signature\n    function _validate(ValidatorLibrary.Sign[] calldata _signs, bytes memory _data) internal {\n        uint signsCount = _signs.length;\n        require(signsCount >= minAmountOfSigners, \"PhutureJob: !ENOUGH_SIGNERS\");\n\n        address lastAddress = address(0);\n        for (uint i; i < signsCount; ) {\n            address signer = _signs[i].signer;\n            require(uint160(signer) > uint160(lastAddress), \"PhutureJob: UNSORTED\");\n            require(\n                _signs[i].verify(_data, _useNonce()) && IAccessControl(registry).hasRole(VALIDATOR_ROLE, signer),\n                string.concat(\"PhutureJob: SIGN \", Strings.toHexString(uint160(signer), 20))\n            );\n\n            lastAddress = signer;\n\n            unchecked {\n                i = i + 1;\n            }\n        }\n    }\n\n    /// @notice Return the current value of nonce and increment\n    /// @return current Current nonce of signer\n    function _useNonce() internal virtual returns (uint256 current) {\n        current = _nonce.current();\n        _nonce.increment();\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/Strings.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/Counters.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"

    },

    "@openzeppelin/contracts/access/IAccessControl.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"

    },

    "@openzeppelin/contracts/security/Pausable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/introspection/ERC165Checker.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface,\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            _supportsERC165Interface(account, type(IERC165).interfaceId) &&\n            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && _supportsERC165Interface(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * _Available since v3.4._\n     */\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\n        internal\n        view\n        returns (bool[] memory)\n    {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = _supportsERC165Interface(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in _interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!_supportsERC165Interface(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     * Interface identification is specified in ERC-165.\n     */\n    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\n        (bool success, bytes memory result) = account.staticcall{gas: 30000}(encodedParams);\n        if (result.length < 32) return false;\n        return success && abi.decode(result, (bool));\n    }\n}\n"

    },

    "contracts/libraries/ValidatorLibrary.sol": {

      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity 0.8.13;\n\n/// @title Validator library\n/// @notice Library containing set of utilities related to Phuture job validation\nlibrary ValidatorLibrary {\n    struct Sign {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        address signer;\n        uint deadline;\n    }\n\n    /// @notice Verifies if the given `_data` object was signed by proper signer\n    /// @param self Sign object reference\n    /// @param _data Data object to verify signature\n    function verify(\n        Sign calldata self,\n        bytes memory _data,\n        uint _nonce\n    ) internal view returns (bool) {\n        require(block.timestamp <= self.deadline, \"ValidatorLibrary: EXPIRED\");\n\n        bytes32 eip712DomainHash = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,uint256 nonce,uint256 deadline)\"\n                ),\n                keccak256(bytes(\"PhutureJob\")),\n                keccak256(bytes(\"1\")),\n                block.chainid,\n                address(this),\n                _nonce,\n                self.deadline\n            )\n        );\n\n        return\n            self.signer ==\n            ecrecover(\n                keccak256(abi.encodePacked(\"\\x19\\x01\", eip712DomainHash, keccak256(_data))),\n                self.v,\n                self.r,\n                self.s\n            );\n    }\n}\n"

    },

    "contracts/interfaces/IOrdererV2.sol": {

      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity >=0.8.13;\n\n/// @title Orderer interface\n/// @notice Describes methods for reweigh execution, order creation and execution\ninterface IOrdererV2 {\n    struct InternalSwapV2 {\n        address sellAccount;\n        address buyAccount;\n        address sellAsset;\n        address buyAsset;\n        uint maxSellShares;\n    }\n\n    struct ExternalSwapV2 {\n        address account;\n        address sellAsset;\n        address buyAsset;\n        uint sellShares;\n        address swapTarget;\n        bytes swapData;\n    }\n\n    /// @notice Initializes orderer with the given params (overrides IOrderer's initialize)\n    /// @param _registry Index registry address\n    /// @param _orderLifetime Order lifetime in which it stays valid\n    /// @param _maxSlippageInBP Max slippage in BP\n    function initialize(\n        address _registry,\n        uint64 _orderLifetime,\n        uint16 _maxSlippageInBP\n    ) external;\n\n    /// @notice Sets max allowed slippage\n    /// @param _maxSlippageInBP Max allowed slippage\n    function setMaxSlippageInBP(uint16 _maxSlippageInBP) external;\n\n    /// @notice Swap shares between given indexes\n    /// @param _info Swap info objects with exchange details\n    function internalSwap(InternalSwapV2 calldata _info) external;\n\n    /// @notice Swap shares using DEX\n    /// @param _info Swap info objects with exchange details\n    function externalSwap(ExternalSwapV2 calldata _info) external;\n\n    /// @notice Max allowed exchange price impact\n    /// @return Returns max allowed exchange price impact\n    function maxSlippageInBP() external view returns (uint16);\n}\n"

    },

    "contracts/interfaces/IPhutureJob.sol": {

      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity >=0.8.13;\n\nimport \"../libraries/ValidatorLibrary.sol\";\n\nimport \"./IOrdererV2.sol\";\n\n/// @title Phuture job interface\n/// @notice Contains signature verification and order execution logic\ninterface IPhutureJob {\n    /// @notice Pause order execution\n    function pause() external;\n\n    /// @notice Unpause order execution\n    function unpause() external;\n\n    /// @notice Sets minimum amount of signers required to sign a job\n    /// @param _minAmountOfSigners Minimum amount of signers required to sign a job\n    function setMinAmountOfSigners(uint256 _minAmountOfSigners) external;\n\n    /// @notice Swap shares internally\n    /// @param _signs List of signatures\n    /// @param _info Swap info object\n    function internalSwap(ValidatorLibrary.Sign[] calldata _signs, IOrdererV2.InternalSwapV2 calldata _info) external;\n\n    /// @notice Swap shares using DEX\n    /// @param _signs List of signatures\n    /// @param _info Swap info object\n    function externalSwap(ValidatorLibrary.Sign[] calldata _signs, IOrdererV2.ExternalSwapV2 calldata _info) external;\n\n    /// @notice Swap shares internally (manual)\n    /// @param _signs List of signatures\n    /// @param _info Swap info object\n    function internalSwapManual(ValidatorLibrary.Sign[] calldata _signs, IOrdererV2.InternalSwapV2 calldata _info)\n        external;\n\n    /// @notice Swap shares using DEX (manual)\n    /// @param _signs List of signatures\n    /// @param _info Swap info object\n    function externalSwapManual(ValidatorLibrary.Sign[] calldata _signs, IOrdererV2.ExternalSwapV2 calldata _info)\n        external;\n\n    /// @notice Index registry address\n    /// @return Returns index registry address\n    function registry() external view returns (address);\n\n    /// @notice Keep3r address\n    /// @return Returns address of keep3r network\n    function keep3r() external view returns (address);\n\n    /// @notice Nonce of signer\n    /// @return Returns nonce of given signer\n    function nonce() external view returns (uint256);\n\n    /// @notice Minimum amount of signers required to sign a job\n    /// @return Returns minimum amount of signers required to sign a job\n    function minAmountOfSigners() external view returns (uint256);\n}\n"

    },

    "contracts/interfaces/IIndexRegistry.sol": {

      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity >=0.8.13;\n\nimport \"./IIndexFactory.sol\";\n\n/// @title Index registry interface\n/// @notice Contains core components, addresses and asset market capitalizations\ninterface IIndexRegistry {\n    event SetIndexLogic(address indexed account, address indexLogic);\n    event SetMaxComponents(address indexed account, uint maxComponents);\n    event UpdateAsset(address indexed asset, uint marketCap);\n    event SetOrderer(address indexed account, address orderer);\n    event SetFeePool(address indexed account, address feePool);\n    event SetPriceOracle(address indexed account, address priceOracle);\n\n    /// @notice Initializes IndexRegistry with the given params\n    /// @param _indexLogic Index logic address\n    /// @param _maxComponents Maximum assets for an index\n    function initialize(address _indexLogic, uint _maxComponents) external;\n\n    /// @notice Sets maximum assets for an index\n    /// @param _maxComponents Maximum assets for an index\n    function setMaxComponents(uint _maxComponents) external;\n\n    /// @notice Index logic address\n    /// @return Returns index logic address\n    function indexLogic() external returns (address);\n\n    /// @notice Sets index logic address\n    /// @param _indexLogic Index logic address\n    function setIndexLogic(address _indexLogic) external;\n\n    /// @notice Sets adminRole as role's admin role.\n    /// @param _role Role\n    /// @param _adminRole AdminRole of given role\n    function setRoleAdmin(bytes32 _role, bytes32 _adminRole) external;\n\n    /// @notice Registers new index\n    /// @param _index Index address\n    /// @param _nameDetails Name details (name and symbol) for provided index\n    function registerIndex(address _index, IIndexFactory.NameDetails calldata _nameDetails) external;\n\n    /// @notice Registers asset in the system, updates it's market capitalization and assigns required roles\n    /// @param _asset Asset to register\n    /// @param _marketCap It's current market capitalization\n    function addAsset(address _asset, uint _marketCap) external;\n\n    /// @notice Removes assets from the system\n    /// @param _asset Asset to remove\n    function removeAsset(address _asset) external;\n\n    /// @notice Updates market capitalization for the given asset\n    /// @param _asset Asset address to update market capitalization for\n    /// @param _marketCap Market capitalization value\n    function updateAssetMarketCap(address _asset, uint _marketCap) external;\n\n    /// @notice Sets price oracle address\n    /// @param _priceOracle Price oracle address\n    function setPriceOracle(address _priceOracle) external;\n\n    /// @notice Sets orderer address\n    /// @param _orderer Orderer address\n    function setOrderer(address _orderer) external;\n\n    /// @notice Sets fee pool address\n    /// @param _feePool Fee pool address\n    function setFeePool(address _feePool) external;\n\n    /// @notice Maximum assets for an index\n    /// @return Returns maximum assets for an index\n    function maxComponents() external view returns (uint);\n\n    /// @notice Market capitalization of provided asset\n    /// @return _asset Returns market capitalization of provided asset\n    function marketCapOf(address _asset) external view returns (uint);\n\n    /// @notice Returns total market capitalization of the given assets\n    /// @param _assets Assets array to calculate market capitalization of\n    /// @return _marketCaps Corresponding capitalizations of the given asset\n    /// @return _totalMarketCap Total market capitalization of the given assets\n    function marketCapsOf(address[] calldata _assets)\n        external\n        view\n        returns (uint[] memory _marketCaps, uint _totalMarketCap);\n\n    /// @notice Total market capitalization of all registered assets\n    /// @return Returns total market capitalization of all registered assets\n    function totalMarketCap() external view returns (uint);\n\n    /// @notice Price oracle address\n    /// @return Returns price oracle address\n    function priceOracle() external view returns (address);\n\n    /// @notice Orderer address\n    /// @return Returns orderer address\n    function orderer() external view returns (address);\n\n    /// @notice Fee pool address\n    /// @return Returns fee pool address\n    function feePool() external view returns (address);\n}\n"

    },

    "contracts/interfaces/external/IKeep3r.sol": {

      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity >=0.8.13;\n\ninterface IKeep3r {\n    function isKeeper(address _keeper) external returns (bool _isKeeper);\n\n    function worked(address _keeper) external;\n}\n"

    },

    "@openzeppelin/contracts/utils/Context.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"

    },

    "contracts/interfaces/IIndexFactory.sol": {

      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity >=0.8.13;\n\n/// @title Index factory interface\n/// @notice Contains logic for initial fee management for indexes which will be created by this factory\ninterface IIndexFactory {\n    struct NameDetails {\n        string name;\n        string symbol;\n    }\n\n    event SetVTokenFactory(address vTokenFactory);\n    event SetDefaultMintingFeeInBP(address indexed account, uint16 mintingFeeInBP);\n    event SetDefaultBurningFeeInBP(address indexed account, uint16 burningFeeInBP);\n    event SetDefaultAUMScaledPerSecondsRate(address indexed account, uint AUMScaledPerSecondsRate);\n\n    /// @notice Sets default index minting fee in base point (BP) format\n    /// @dev Will be set in FeePool on index creation\n    /// @param _mintingFeeInBP New minting fee value\n    function setDefaultMintingFeeInBP(uint16 _mintingFeeInBP) external;\n\n    /// @notice Sets default index burning fee in base point (BP) format\n    /// @dev Will be set in FeePool on index creation\n    /// @param _burningFeeInBP New burning fee value\n    function setDefaultBurningFeeInBP(uint16 _burningFeeInBP) external;\n\n    /// @notice Sets reweighting logic address\n    /// @param _reweightingLogic Reweighting logic address\n    function setReweightingLogic(address _reweightingLogic) external;\n\n    /// @notice Sets default AUM scaled per seconds rate that will be used for fee calculation\n    /**\n        @dev Will be set in FeePool on index creation.\n        Effective management fee rate (annual, in percent, after dilution) is calculated by the given formula:\n        fee = (rpow(scaledPerSecondRate, numberOfSeconds, 10*27) - 10**27) * totalSupply / 10**27, where:\n\n        totalSupply - total index supply;\n        numberOfSeconds - delta time for calculation period;\n        scaledPerSecondRate - scaled rate, calculated off chain by the given formula:\n\n        scaledPerSecondRate = ((1 + k) ** (1 / 365 days)) * AUMCalculationLibrary.RATE_SCALE_BASE, where:\n        k = (aumFeeInBP / BP) / (1 - aumFeeInBP / BP);\n\n        Note: rpow and RATE_SCALE_BASE are provided by AUMCalculationLibrary\n        More info: https://docs.enzyme.finance/fee-formulas/management-fee\n\n        After value calculated off chain, scaledPerSecondRate is set to setDefaultAUMScaledPerSecondsRate\n    */\n    /// @param _AUMScaledPerSecondsRate New AUM scaled per seconds rate\n    function setDefaultAUMScaledPerSecondsRate(uint _AUMScaledPerSecondsRate) external;\n\n    /// @notice Withdraw fee balance to fee pool for a given index\n    /// @param _index Index to withdraw fee balance from\n    function withdrawToFeePool(address _index) external;\n\n    /// @notice Index registry address\n    /// @return Returns index registry address\n    function registry() external view returns (address);\n\n    /// @notice vTokenFactory address\n    /// @return Returns vTokenFactory address\n    function vTokenFactory() external view returns (address);\n\n    /// @notice Minting fee in base point (BP) format\n    /// @return Returns minting fee in base point (BP) format\n    function defaultMintingFeeInBP() external view returns (uint16);\n\n    /// @notice Burning fee in base point (BP) format\n    /// @return Returns burning fee in base point (BP) format\n    function defaultBurningFeeInBP() external view returns (uint16);\n\n    /// @notice AUM scaled per seconds rate\n    ///         See setDefaultAUMScaledPerSecondsRate method description for more details.\n    /// @return Returns AUM scaled per seconds rate\n    function defaultAUMScaledPerSecondsRate() external view returns (uint);\n\n    /// @notice Reweighting logic address\n    /// @return Returns reweighting logic address\n    function reweightingLogic() external view returns (address);\n}\n"

    }

  },

  "settings": {

    "optimizer": {

      "enabled": true,

      "runs": 200

    },

    "metadata": {

      "bytecodeHash": "none"

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "libraries": {}

  }

}}