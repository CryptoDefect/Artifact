{{

  "language": "Solidity",

  "settings": {

    "evmVersion": "london",

    "libraries": {},

    "metadata": {

      "bytecodeHash": "ipfs",

      "useLiteralContent": true

    },

    "optimizer": {

      "enabled": true,

      "runs": 100

    },

    "remappings": [],

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    }

  },

  "sources": {

    "contracts/RWAHub.sol": {

      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/interfaces/IPricer.sol\";\nimport \"contracts/interfaces/IRWALike.sol\";\nimport \"contracts/external/openzeppelin/contracts/token/IERC20.sol\";\nimport \"contracts/external/openzeppelin/contracts/token/SafeERC20.sol\";\nimport \"contracts/interfaces/IRWAHub.sol\";\n\n// Additional Dependencies\nimport \"contracts/external/openzeppelin/contracts/token/IERC20Metadata.sol\";\nimport \"contracts/external/openzeppelin/contracts/access/AccessControlEnumerable.sol\";\nimport \"contracts/external/openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nabstract contract RWAHub is IRWAHub, ReentrancyGuard, AccessControlEnumerable {\n  using SafeERC20 for IERC20;\n  // RWA Token contract\n  IRWALike public immutable rwa;\n  // Pointer to Pricer\n  IPricer public pricer;\n  // Address to receive deposits\n  address public constant assetRecipient =\n    0x3127e67d5f7119a91Bd1842160De4CAb7D1D0d32;\n  // Address to send redemptions\n  address public assetSender;\n  // Address fee recipient\n  address public feeRecipient;\n  // Mapping from deposit Id -> Depositor\n  mapping(bytes32 => Depositor) public depositIdToDepositor;\n  // Mapping from redemptionId -> Redeemer\n  mapping(bytes32 => Redeemer) public redemptionIdToRedeemer;\n\n  /// @dev Mint/Redeem Parameters\n  // Minimum amount that must be deposited to mint the RWA token\n  // Denoted in decimals of `collateral`\n  uint256 public minimumDepositAmount;\n\n  // Minimum amount that must be redeemed for a withdraw request\n  uint256 public minimumRedemptionAmount;\n\n  // Minting fee specified in basis points\n  uint256 public mintFee = 0;\n\n  // Redemption fee specified in basis points\n  uint256 public redemptionFee = 0;\n\n  // The asset accepted by the RWAHub\n  IERC20 public immutable collateral;\n\n  // Decimal multiplier representing the difference between `rwa` decimals\n  // In `collateral` token decimals\n  uint256 public immutable decimalsMultiplier;\n\n  // Deposit counter to map subscription requests to\n  uint256 public subscriptionRequestCounter = 1;\n\n  // Redemption Id to map from\n  uint256 public redemptionRequestCounter = 1;\n\n  // Helper constant that allows us to specify basis points in calculations\n  uint256 public constant BPS_DENOMINATOR = 10_000;\n\n  // Pause variables\n  bool public redemptionPaused;\n  bool public subscriptionPaused;\n\n  /// @dev Role based access control roles\n  bytes32 public constant MANAGER_ADMIN = keccak256(\"MANAGER_ADMIN\");\n  bytes32 public constant MINTER_ADMIN = keccak256(\"MINTER_ADMIN\");\n  bytes32 public constant PAUSER_ADMIN = keccak256(\"PAUSER_ADMIN\");\n  bytes32 public constant PRICE_ID_SETTER_ROLE =\n    keccak256(\"PRICE_ID_SETTER_ROLE\");\n  bytes32 public constant RELAYER_ROLE = keccak256(\"RELAYER_ROLE\");\n\n  /// @notice constructor\n  constructor(\n    address _collateral,\n    address _rwa,\n    address managerAdmin,\n    address pauser,\n    address _assetSender,\n    address _feeRecipient,\n    uint256 _minimumDepositAmount,\n    uint256 _minimumRedemptionAmount\n  ) {\n    if (_collateral == address(0)) {\n      revert CollateralCannotBeZero();\n    }\n    if (_rwa == address(0)) {\n      revert RWACannotBeZero();\n    }\n    if (_assetSender == address(0)) {\n      revert AssetSenderCannotBeZero();\n    }\n    if (_feeRecipient == address(0)) {\n      revert FeeRecipientCannotBeZero();\n    }\n\n    _grantRole(DEFAULT_ADMIN_ROLE, managerAdmin);\n    _grantRole(MANAGER_ADMIN, managerAdmin);\n    _grantRole(PAUSER_ADMIN, pauser);\n    _setRoleAdmin(PAUSER_ADMIN, MANAGER_ADMIN);\n    _setRoleAdmin(PRICE_ID_SETTER_ROLE, MANAGER_ADMIN);\n    _setRoleAdmin(RELAYER_ROLE, MANAGER_ADMIN);\n\n    collateral = IERC20(_collateral);\n    rwa = IRWALike(_rwa);\n    feeRecipient = _feeRecipient;\n    assetSender = _assetSender;\n    minimumDepositAmount = _minimumDepositAmount;\n    minimumRedemptionAmount = _minimumRedemptionAmount;\n\n    decimalsMultiplier =\n      10 **\n        (IERC20Metadata(_rwa).decimals() -\n          IERC20Metadata(_collateral).decimals());\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                  Subscription/Redemption Functions\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Function used by users to request subscription to the fund\n   *\n   * @param amount The amount of collateral one wished to deposit\n   */\n  function requestSubscription(\n    uint256 amount\n  )\n    external\n    virtual\n    nonReentrant\n    ifNotPaused(subscriptionPaused)\n    checkRestrictions(msg.sender)\n  {\n    if (amount < minimumDepositAmount) {\n      revert DepositTooSmall();\n    }\n\n    uint256 feesInCollateral = _getMintFees(amount);\n    uint256 depositAmountAfterFee = amount - feesInCollateral;\n\n    // Link the depositor to their deposit ID\n    bytes32 depositId = bytes32(subscriptionRequestCounter++);\n    depositIdToDepositor[depositId] = Depositor(\n      msg.sender,\n      depositAmountAfterFee,\n      0\n    );\n\n    if (feesInCollateral > 0) {\n      collateral.safeTransferFrom(msg.sender, feeRecipient, feesInCollateral);\n    }\n\n    collateral.safeTransferFrom(\n      msg.sender,\n      assetRecipient,\n      depositAmountAfterFee\n    );\n\n    emit MintRequested(\n      msg.sender,\n      depositId,\n      amount,\n      depositAmountAfterFee,\n      feesInCollateral\n    );\n  }\n\n  /**\n   * @notice Function used to claim tokens corresponding to a deposit request\n   *\n   * @param depositIds An array containing the deposit Ids one wishes to claim\n   *\n   * @dev Implicitly does all transfer checks present in underlying `rwa`\n   * @dev The priceId corresponding to a given depositId must be set prior to\n   *      claiming a mint\n   */\n  function claimMint(\n    bytes32[] calldata depositIds\n  ) external virtual nonReentrant ifNotPaused(subscriptionPaused) {\n    uint256 depositsSize = depositIds.length;\n    for (uint256 i = 0; i < depositsSize; ++i) {\n      _claimMint(depositIds[i]);\n    }\n  }\n\n  /**\n   * @notice Internal claim mint helper\n   *\n   * @dev This function can be overriden to implement custom claiming logic\n   */\n  function _claimMint(bytes32 depositId) internal virtual {\n    Depositor memory depositor = depositIdToDepositor[depositId];\n    // Revert if priceId is not set\n    if (depositor.priceId == 0) {\n      revert PriceIdNotSet();\n    }\n\n    uint256 price = pricer.getPrice(depositor.priceId);\n    uint256 rwaOwed = _getMintAmountForPrice(\n      depositor.amountDepositedMinusFees,\n      price\n    );\n\n    delete depositIdToDepositor[depositId];\n    rwa.mint(depositor.user, rwaOwed);\n\n    emit MintCompleted(\n      depositor.user,\n      depositId,\n      rwaOwed,\n      depositor.amountDepositedMinusFees,\n      price,\n      depositor.priceId\n    );\n  }\n\n  /**\n   * @notice Function used by users to request a redemption from the fund\n   *\n   * @param amount The amount (in units of `rwa`) that a user wishes to redeem\n   *               from the fund\n   */\n  function requestRedemption(\n    uint256 amount\n  ) external virtual nonReentrant ifNotPaused(redemptionPaused) {\n    if (amount < minimumRedemptionAmount) {\n      revert RedemptionTooSmall();\n    }\n    bytes32 redemptionId = bytes32(redemptionRequestCounter++);\n    redemptionIdToRedeemer[redemptionId] = Redeemer(msg.sender, amount, 0);\n\n    rwa.burnFrom(msg.sender, amount);\n\n    emit RedemptionRequested(msg.sender, redemptionId, amount);\n  }\n\n  /**\n   * @notice Function to claim collateral corresponding to a redemption request\n   *\n   * @param redemptionIds an Array of redemption Id's which ought to fulfilled\n   *\n   * @dev Implicitly does all checks present in underlying `rwa`\n   * @dev The price Id corresponding to a redemptionId must be set prior to\n   *      claiming a redemption\n   */\n  function claimRedemption(\n    bytes32[] calldata redemptionIds\n  ) external virtual nonReentrant ifNotPaused(redemptionPaused) {\n    uint256 fees;\n    uint256 redemptionsSize = redemptionIds.length;\n    for (uint256 i = 0; i < redemptionsSize; ++i) {\n      Redeemer memory member = redemptionIdToRedeemer[redemptionIds[i]];\n      _checkRestrictions(member.user);\n      if (member.priceId == 0) {\n        // Then the price for this redemption has not been set\n        revert PriceIdNotSet();\n      }\n\n      // Calculate collateral due and fees\n      uint256 price = pricer.getPrice(member.priceId);\n      uint256 collateralDue = _getRedemptionAmountForRwa(\n        member.amountRwaTokenBurned,\n        price\n      );\n      uint256 fee = _getRedemptionFees(collateralDue);\n      uint256 collateralDuePostFees = collateralDue - fee;\n      fees += fee;\n\n      delete redemptionIdToRedeemer[redemptionIds[i]];\n\n      collateral.safeTransferFrom(\n        assetSender,\n        member.user,\n        collateralDuePostFees\n      );\n\n      emit RedemptionCompleted(\n        member.user,\n        redemptionIds[i],\n        member.amountRwaTokenBurned,\n        collateralDuePostFees,\n        price\n      );\n    }\n    if (fees > 0) {\n      collateral.safeTransferFrom(assetSender, feeRecipient, fees);\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                         Relayer Functions\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Adds a deposit proof to the contract\n   *\n   * @param txHash                The transaction hash of the deposit\n   * @param user                  The address of the user who made the deposit\n   * @param depositAmountAfterFee The amount of the deposit after fees\n   * @param feeAmount             The amount of the fees taken\n   * @param timestamp             The timestamp of the deposit\n   *\n   * @dev txHash is used as the depositId in storage\n   * @dev All amounts are in decimals of `collateral`\n   */\n  function addProof(\n    bytes32 txHash,\n    address user,\n    uint256 depositAmountAfterFee,\n    uint256 feeAmount,\n    uint256 timestamp\n  ) external override onlyRole(RELAYER_ROLE) checkRestrictions(user) {\n    if (depositIdToDepositor[txHash].user != address(0)) {\n      revert DepositProofAlreadyExists();\n    }\n    depositIdToDepositor[txHash] = Depositor(user, depositAmountAfterFee, 0);\n    emit DepositProofAdded(\n      txHash,\n      user,\n      depositAmountAfterFee,\n      feeAmount,\n      timestamp\n    );\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                           PriceId Setters\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Admin function to associate a depositId with a given Price Id\n   *\n   * @param depositIds an Array of deposit Ids to be associated\n   * @param priceIds   an Array of price Ids to be associated\n   *\n   * @dev Array size must match\n   */\n  function setPriceIdForDeposits(\n    bytes32[] calldata depositIds,\n    uint256[] calldata priceIds\n  ) external virtual onlyRole(PRICE_ID_SETTER_ROLE) {\n    uint256 depositsSize = depositIds.length;\n    if (depositsSize != priceIds.length) {\n      revert ArraySizeMismatch();\n    }\n    for (uint256 i = 0; i < depositsSize; ++i) {\n      if (depositIdToDepositor[depositIds[i]].user == address(0)) {\n        revert DepositorNull();\n      }\n      if (depositIdToDepositor[depositIds[i]].priceId != 0) {\n        revert PriceIdAlreadySet();\n      }\n      depositIdToDepositor[depositIds[i]].priceId = priceIds[i];\n      emit PriceIdSetForDeposit(depositIds[i], priceIds[i]);\n    }\n  }\n\n  /**\n   * @notice Admin function to associate redemptionId with a given priceId\n   *\n   * @param redemptionIds an Array of redemptionIds to associate\n   * @param priceIds  an Array of priceIds to associate\n   */\n  function setPriceIdForRedemptions(\n    bytes32[] calldata redemptionIds,\n    uint256[] calldata priceIds\n  ) external virtual onlyRole(PRICE_ID_SETTER_ROLE) {\n    uint256 redemptionsSize = redemptionIds.length;\n    if (redemptionsSize != priceIds.length) {\n      revert ArraySizeMismatch();\n    }\n    for (uint256 i = 0; i < redemptionsSize; ++i) {\n      if (redemptionIdToRedeemer[redemptionIds[i]].priceId != 0) {\n        revert PriceIdAlreadySet();\n      }\n      redemptionIdToRedeemer[redemptionIds[i]].priceId = priceIds[i];\n      emit PriceIdSetForRedemption(redemptionIds[i], priceIds[i]);\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                           Admin Setters\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Admin function to overwrite entries in the depoitIdToDepositor\n   *         mapping\n   *\n   * @param depositIdToOverwrite  The depositId of the entry we wish to\n   *                              overwrite\n   * @param user                  The user for the new entry\n   * @param depositAmountAfterFee The deposit value for the new entry\n   * @param priceId               The priceId to be associated with the new\n   *                              entry\n   */\n  function overwriteDepositor(\n    bytes32 depositIdToOverwrite,\n    address user,\n    uint256 depositAmountAfterFee,\n    uint256 priceId\n  ) external onlyRole(MANAGER_ADMIN) checkRestrictions(user) {\n    Depositor memory oldDepositor = depositIdToDepositor[depositIdToOverwrite];\n\n    depositIdToDepositor[depositIdToOverwrite] = Depositor(\n      user,\n      depositAmountAfterFee,\n      priceId\n    );\n\n    emit DepositorOverwritten(\n      depositIdToOverwrite,\n      oldDepositor.user,\n      user,\n      oldDepositor.priceId,\n      priceId,\n      oldDepositor.amountDepositedMinusFees,\n      depositAmountAfterFee\n    );\n  }\n\n  /**\n   * @notice Admin function to overwrite entries in the redemptionIdToRedeemer\n   *         mapping\n   *\n   * @param redemptionIdToOverwrite The redemptionId of the entry we wish to\n   *                                overwrite\n   * @param user                    The user for the new entry\n   * @param rwaTokenAmountBurned    The burn amount for the new entry\n   * @param priceId                 The priceID to be associated with the new\n   *                                entry\n   */\n  function overwriteRedeemer(\n    bytes32 redemptionIdToOverwrite,\n    address user,\n    uint256 rwaTokenAmountBurned,\n    uint256 priceId\n  ) external onlyRole(MANAGER_ADMIN) checkRestrictions(user) {\n    Redeemer memory oldRedeemer = redemptionIdToRedeemer[\n      redemptionIdToOverwrite\n    ];\n    redemptionIdToRedeemer[redemptionIdToOverwrite] = Redeemer(\n      user,\n      rwaTokenAmountBurned,\n      priceId\n    );\n    emit RedeemerOverwritten(\n      redemptionIdToOverwrite,\n      oldRedeemer.user,\n      user,\n      oldRedeemer.priceId,\n      priceId,\n      oldRedeemer.amountRwaTokenBurned,\n      rwaTokenAmountBurned\n    );\n  }\n\n  /**\n   * @notice Admin function to set the minimum amount to redeem\n   *\n   * @param _minimumRedemptionAmount The minimum amount required to submit a\n   *                                 redemption request\n   */\n  function setMinimumRedemptionAmount(\n    uint256 _minimumRedemptionAmount\n  ) external onlyRole(MANAGER_ADMIN) {\n    if (_minimumRedemptionAmount < BPS_DENOMINATOR) {\n      revert AmountTooSmall();\n    }\n    uint256 oldRedeemMinimum = minimumRedemptionAmount;\n    minimumRedemptionAmount = _minimumRedemptionAmount;\n    emit MinimumRedemptionAmountSet(oldRedeemMinimum, _minimumRedemptionAmount);\n  }\n\n  /**\n   * @notice Admin function to set the minimum amount required for a deposit\n   *\n   * @param minDepositAmount The minimum amount required to submit a deposit\n   *                         request\n   */\n  function setMinimumDepositAmount(\n    uint256 minDepositAmount\n  ) external onlyRole(MANAGER_ADMIN) {\n    if (minDepositAmount < BPS_DENOMINATOR) {\n      revert AmountTooSmall();\n    }\n    uint256 oldMinimumDepositAmount = minimumDepositAmount;\n    minimumDepositAmount = minDepositAmount;\n    emit MinimumDepositAmountSet(oldMinimumDepositAmount, minDepositAmount);\n  }\n\n  /**\n   * @notice Admin function to set the mint fee\n   *\n   * @param _mintFee The new mint fee specified in basis points\n   *\n   * @dev The maximum fee that can be set is 10_000 bps, or 100%\n   */\n  function setMintFee(uint256 _mintFee) external onlyRole(MANAGER_ADMIN) {\n    if (_mintFee > BPS_DENOMINATOR) {\n      revert FeeTooLarge();\n    }\n    uint256 oldMintFee = mintFee;\n    mintFee = _mintFee;\n    emit MintFeeSet(oldMintFee, _mintFee);\n  }\n\n  /**\n   * @notice Admin function to set the redeem fee\n   *\n   * @param _redemptionFee The new redeem fee specified in basis points\n   *\n   * @dev The maximum fee that can be set is 10_000 bps, or 100%\n   */\n  function setRedemptionFee(\n    uint256 _redemptionFee\n  ) external onlyRole(MANAGER_ADMIN) {\n    if (_redemptionFee > BPS_DENOMINATOR) {\n      revert FeeTooLarge();\n    }\n    uint256 oldRedeemFee = redemptionFee;\n    redemptionFee = _redemptionFee;\n    emit RedemptionFeeSet(oldRedeemFee, _redemptionFee);\n  }\n\n  /**\n   * @notice Admin function to set the address of the Pricer contract\n   *\n   * @param newPricer The address of the new pricer contract\n   */\n  function setPricer(address newPricer) external onlyRole(MANAGER_ADMIN) {\n    address oldPricer = address(pricer);\n    pricer = IPricer(newPricer);\n    emit NewPricerSet(oldPricer, newPricer);\n  }\n\n  /**\n   * @notice Admin function to set the address of `feeRecipient`\n   *\n   * @param newFeeRecipient The address of the new `feeRecipient`\n   */\n  function setFeeRecipient(\n    address newFeeRecipient\n  ) external onlyRole(MANAGER_ADMIN) {\n    address oldFeeRecipient = feeRecipient;\n    feeRecipient = newFeeRecipient;\n    emit FeeRecipientSet(oldFeeRecipient, feeRecipient);\n  }\n\n  /**\n   * @notice Admin function to set the address of `assetSender`\n   *\n   * @param newAssetSender The address of the new `assetSender`\n   */\n  function setAssetSender(\n    address newAssetSender\n  ) external onlyRole(MANAGER_ADMIN) {\n    address oldAssetSender = assetSender;\n    assetSender = newAssetSender;\n    emit AssetSenderSet(oldAssetSender, newAssetSender);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                            Pause Utils\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Modifier to check if a feature is paused\n   *\n   * @param feature The feature to check if paused\n   */\n  modifier ifNotPaused(bool feature) {\n    if (feature) {\n      revert FeaturePaused();\n    }\n    _;\n  }\n\n  /**\n   * @notice Function to pause subscription to RWAHub\n   */\n  function pauseSubscription() external onlyRole(PAUSER_ADMIN) {\n    subscriptionPaused = true;\n    emit SubscriptionPaused(msg.sender);\n  }\n\n  /**\n   * @notice Function to pause redemptions to RWAHub\n   */\n  function pauseRedemption() external onlyRole(PAUSER_ADMIN) {\n    redemptionPaused = true;\n    emit RedemptionPaused(msg.sender);\n  }\n\n  /**\n   * @notice Function to unpause subscriptions to RWAHub\n   */\n  function unpauseSubscription() external onlyRole(MANAGER_ADMIN) {\n    subscriptionPaused = false;\n    emit SubscriptionUnpaused(msg.sender);\n  }\n\n  /**\n   * @notice Function to unpause redemptions to RWAHub\n   */\n  function unpauseRedemption() external onlyRole(MANAGER_ADMIN) {\n    redemptionPaused = false;\n    emit RedemptionUnpaused(msg.sender);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n                      Check Restriction Utils\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Modifier to check restrictions status of an account\n   *\n   * @param account The account to check\n   */\n  modifier checkRestrictions(address account) {\n    _checkRestrictions(account);\n    _;\n  }\n\n  /**\n   * @notice internal function to check restriction status\n   *         of an address\n   *\n   * @param account The account to check restriction status for\n   *\n   * @dev This function is virtual to be overridden by child contract\n   *      to check restrictions on a more granular level\n   */\n  function _checkRestrictions(address account) internal view virtual;\n\n  /*//////////////////////////////////////////////////////////////\n                           Math Utils\n  //////////////////////////////////////////////////////////////*/\n\n  /**\n   * @notice Given amount of `collateral`, returns how much in fees\n   *         are owed\n   *\n   *\n   * @param collateralAmount Amount `collateral` to calculate fees\n   *                         (in decimals of `collateral`)\n   */\n  function _getMintFees(\n    uint256 collateralAmount\n  ) internal view returns (uint256) {\n    return (collateralAmount * mintFee) / BPS_DENOMINATOR;\n  }\n\n  /**\n   * @notice Given amount of `collateral`, returns how much in fees\n   *         are owed\n   *\n   * @param collateralAmount Amount of `collateral` to calculate fees\n   *                         (in decimals of `collateral`)\n   */\n  function _getRedemptionFees(\n    uint256 collateralAmount\n  ) internal view returns (uint256) {\n    return (collateralAmount * redemptionFee) / BPS_DENOMINATOR;\n  }\n\n  /**\n   * @notice Given a deposit amount and priceId, returns the amount\n   *         of `rwa` due\n   *\n   * @param depositAmt The amount deposited in units of `collateral`\n   * @param price      The price associated with this deposit\n   */\n  function _getMintAmountForPrice(\n    uint256 depositAmt,\n    uint256 price\n  ) internal view returns (uint256 rwaAmountOut) {\n    uint256 amountE36 = _scaleUp(depositAmt) * 1e18;\n    // Will revert with div by 0 if price not defined for a priceId\n    rwaAmountOut = amountE36 / price;\n  }\n\n  /**\n   * @notice Given a redemption amount and a priceId, returns the amount\n   *         of `collateral` due\n   *\n   * @param rwaTokenAmountBurned The amount of `rwa` burned for a redemption\n   * @param price                The price associated with this redemption\n   */\n  function _getRedemptionAmountForRwa(\n    uint256 rwaTokenAmountBurned,\n    uint256 price\n  ) internal view returns (uint256 collateralOwed) {\n    uint256 amountE36 = rwaTokenAmountBurned * price;\n    collateralOwed = _scaleDown(amountE36 / 1e18);\n  }\n\n  /**\n   * @notice Scale provided amount up by `decimalsMultiplier`\n   *\n   * @dev This helper is used for converting the collateral's decimals\n   *      representation to the RWA amount decimals representation.\n   */\n  function _scaleUp(uint256 amount) internal view returns (uint256) {\n    return amount * decimalsMultiplier;\n  }\n\n  /**\n   * @notice Scale provided amount down by `decimalsMultiplier`\n   *\n   * @dev This helper is used for converting `rwa`'s decimal\n   *      representation to the `collateral`'s decimal representation\n   */\n  function _scaleDown(uint256 amount) internal view returns (uint256) {\n    return amount / decimalsMultiplier;\n  }\n}\n"

    },

    "contracts/RWAHubOffChainRedemptions.sol": {

      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\n\npragma solidity 0.8.16;\n\nimport \"contracts/RWAHub.sol\";\nimport \"contracts/interfaces/IRWAHubOffChainRedemptions.sol\";\n\nabstract contract RWAHubOffChainRedemptions is\n  RWAHub,\n  IRWAHubOffChainRedemptions\n{\n  // To enable and disable off chain redemptions\n  bool public offChainRedemptionPaused;\n\n  // Minimum off chain redemption amount\n  uint256 public minimumOffChainRedemptionAmount;\n\n  constructor(\n    address _collateral,\n    address _rwa,\n    address managerAdmin,\n    address pauser,\n    address _assetSender,\n    address _feeRecipient,\n    uint256 _minimumDepositAmount,\n    uint256 _minimumRedemptionAmount\n  )\n    RWAHub(\n      _collateral,\n      _rwa,\n      managerAdmin,\n      pauser,\n      _assetSender,\n      _feeRecipient,\n      _minimumDepositAmount,\n      _minimumRedemptionAmount\n    )\n  {\n    // Default to the same minimum redemption amount as for On-Chain\n    // redemptions.\n    minimumOffChainRedemptionAmount = _minimumRedemptionAmount;\n  }\n\n  /**\n   * @notice Request a redemption to be serviced off chain.\n   *\n   * @param amountRWATokenToRedeem The requested redemption amount\n   * @param offChainDestination    A hash of the destination to which\n   *                               the request should be serviced to.\n   */\n  function requestRedemptionServicedOffchain(\n    uint256 amountRWATokenToRedeem,\n    bytes32 offChainDestination\n  ) external nonReentrant ifNotPaused(offChainRedemptionPaused) {\n    if (amountRWATokenToRedeem < minimumRedemptionAmount) {\n      revert RedemptionTooSmall();\n    }\n\n    bytes32 redemptionId = bytes32(redemptionRequestCounter++);\n\n    rwa.burnFrom(msg.sender, amountRWATokenToRedeem);\n\n    emit RedemptionRequestedServicedOffChain(\n      redemptionId,\n      msg.sender,\n      amountRWATokenToRedeem,\n      offChainDestination\n    );\n  }\n\n  /**\n   * @notice Function to pause off chain redemptoins\n   */\n  function pauseOffChainRedemption() external onlyRole(PAUSER_ADMIN) {\n    offChainRedemptionPaused = true;\n    emit OffChainRedemptionPaused(msg.sender);\n  }\n\n  /**\n   * @notice Function to unpause off chain redemptoins\n   */\n  function unpauseOffChainRedemption() external onlyRole(MANAGER_ADMIN) {\n    offChainRedemptionPaused = false;\n    emit OffChainRedemptionUnpaused(msg.sender);\n  }\n\n  /**\n   * @notice Admin Function to set the minimum off chain redemption amount\n   *\n   * @param _minimumOffChainRedemptionAmount The new minimum off chain\n   *                                         redemption amount\n   */\n  function setOffChainRedemptionMinimum(\n    uint256 _minimumOffChainRedemptionAmount\n  ) external onlyRole(MANAGER_ADMIN) {\n    uint256 oldMinimum = minimumOffChainRedemptionAmount;\n    minimumOffChainRedemptionAmount = _minimumOffChainRedemptionAmount;\n    emit OffChainRedemptionMinimumSet(\n      oldMinimum,\n      _minimumOffChainRedemptionAmount\n    );\n  }\n}\n"

    },

    "contracts/external/chainalysis/ISanctionsList.sol": {

      "content": "/// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.16;\n\ninterface ISanctionsList {\n  function isSanctioned(address addr) external view returns (bool);\n}\n"

    },

    "contracts/external/openzeppelin/contracts/access/AccessControl.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"contracts/external/openzeppelin/contracts/access/IAccessControl.sol\";\nimport \"contracts/external/openzeppelin/contracts/utils/Context.sol\";\nimport \"contracts/external/openzeppelin/contracts/utils/Strings.sol\";\nimport \"contracts/external/openzeppelin/contracts/utils/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n  struct RoleData {\n    mapping(address => bool) members;\n    bytes32 adminRole;\n  }\n\n  mapping(bytes32 => RoleData) private _roles;\n\n  bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n  /**\n   * @dev Modifier that checks that an account has a specific role. Reverts\n   * with a standardized message including the required role.\n   *\n   * The format of the revert reason is given by the following regular expression:\n   *\n   *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n   *\n   * _Available since v4.1._\n   */\n  modifier onlyRole(bytes32 role) {\n    _checkRole(role, _msgSender());\n    _;\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    virtual\n    override\n    returns (bool)\n  {\n    return\n      interfaceId == type(IAccessControl).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  /**\n   * @dev Returns `true` if `account` has been granted `role`.\n   */\n  function hasRole(bytes32 role, address account)\n    public\n    view\n    virtual\n    override\n    returns (bool)\n  {\n    return _roles[role].members[account];\n  }\n\n  /**\n   * @dev Revert with a standard message if `account` is missing `role`.\n   *\n   * The format of the revert reason is given by the following regular expression:\n   *\n   *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n   */\n  function _checkRole(bytes32 role, address account) internal view virtual {\n    if (!hasRole(role, account)) {\n      revert(\n        string(\n          abi.encodePacked(\n            \"AccessControl: account \",\n            Strings.toHexString(uint160(account), 20),\n            \" is missing role \",\n            Strings.toHexString(uint256(role), 32)\n          )\n        )\n      );\n    }\n  }\n\n  /**\n   * @dev Returns the admin role that controls `role`. See {grantRole} and\n   * {revokeRole}.\n   *\n   * To change a role's admin, use {_setRoleAdmin}.\n   */\n  function getRoleAdmin(bytes32 role)\n    public\n    view\n    virtual\n    override\n    returns (bytes32)\n  {\n    return _roles[role].adminRole;\n  }\n\n  /**\n   * @dev Grants `role` to `account`.\n   *\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\n   * event.\n   *\n   * Requirements:\n   *\n   * - the caller must have ``role``'s admin role.\n   */\n  function grantRole(bytes32 role, address account)\n    public\n    virtual\n    override\n    onlyRole(getRoleAdmin(role))\n  {\n    _grantRole(role, account);\n  }\n\n  /**\n   * @dev Revokes `role` from `account`.\n   *\n   * If `account` had been granted `role`, emits a {RoleRevoked} event.\n   *\n   * Requirements:\n   *\n   * - the caller must have ``role``'s admin role.\n   */\n  function revokeRole(bytes32 role, address account)\n    public\n    virtual\n    override\n    onlyRole(getRoleAdmin(role))\n  {\n    _revokeRole(role, account);\n  }\n\n  /**\n   * @dev Revokes `role` from the calling account.\n   *\n   * Roles are often managed via {grantRole} and {revokeRole}: this function's\n   * purpose is to provide a mechanism for accounts to lose their privileges\n   * if they are compromised (such as when a trusted device is misplaced).\n   *\n   * If the calling account had been revoked `role`, emits a {RoleRevoked}\n   * event.\n   *\n   * Requirements:\n   *\n   * - the caller must be `account`.\n   */\n  function renounceRole(bytes32 role, address account) public virtual override {\n    require(\n      account == _msgSender(),\n      \"AccessControl: can only renounce roles for self\"\n    );\n\n    _revokeRole(role, account);\n  }\n\n  /**\n   * @dev Grants `role` to `account`.\n   *\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\n   * event. Note that unlike {grantRole}, this function doesn't perform any\n   * checks on the calling account.\n   *\n   * [WARNING]\n   * ====\n   * This function should only be called from the constructor when setting\n   * up the initial roles for the system.\n   *\n   * Using this function in any other way is effectively circumventing the admin\n   * system imposed by {AccessControl}.\n   * ====\n   *\n   * NOTE: This function is deprecated in favor of {_grantRole}.\n   */\n  function _setupRole(bytes32 role, address account) internal virtual {\n    _grantRole(role, account);\n  }\n\n  /**\n   * @dev Sets `adminRole` as ``role``'s admin role.\n   *\n   * Emits a {RoleAdminChanged} event.\n   */\n  function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n    bytes32 previousAdminRole = getRoleAdmin(role);\n    _roles[role].adminRole = adminRole;\n    emit RoleAdminChanged(role, previousAdminRole, adminRole);\n  }\n\n  /**\n   * @dev Grants `role` to `account`.\n   *\n   * Internal function without access restriction.\n   */\n  function _grantRole(bytes32 role, address account) internal virtual {\n    if (!hasRole(role, account)) {\n      _roles[role].members[account] = true;\n      emit RoleGranted(role, account, _msgSender());\n    }\n  }\n\n  /**\n   * @dev Revokes `role` from `account`.\n   *\n   * Internal function without access restriction.\n   */\n  function _revokeRole(bytes32 role, address account) internal virtual {\n    if (hasRole(role, account)) {\n      _roles[role].members[account] = false;\n      emit RoleRevoked(role, account, _msgSender());\n    }\n  }\n}\n"

    },

    "contracts/external/openzeppelin/contracts/access/AccessControlEnumerable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"contracts/external/openzeppelin/contracts/access/IAccessControlEnumerable.sol\";\nimport \"contracts/external/openzeppelin/contracts/access/AccessControl.sol\";\nimport \"contracts/external/openzeppelin/contracts/utils/EnumerableSet.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is\n  IAccessControlEnumerable,\n  AccessControl\n{\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    virtual\n    override\n    returns (bool)\n  {\n    return\n      interfaceId == type(IAccessControlEnumerable).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  /**\n   * @dev Returns one of the accounts that have `role`. `index` must be a\n   * value between 0 and {getRoleMemberCount}, non-inclusive.\n   *\n   * Role bearers are not sorted in any particular way, and their ordering may\n   * change at any point.\n   *\n   * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n   * you perform all queries on the same block. See the following\n   * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n   * for more information.\n   */\n  function getRoleMember(bytes32 role, uint256 index)\n    public\n    view\n    virtual\n    override\n    returns (address)\n  {\n    return _roleMembers[role].at(index);\n  }\n\n  /**\n   * @dev Returns the number of accounts that have `role`. Can be used\n   * together with {getRoleMember} to enumerate all bearers of a role.\n   */\n  function getRoleMemberCount(bytes32 role)\n    public\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    return _roleMembers[role].length();\n  }\n\n  /**\n   * @dev Overload {_grantRole} to track enumerable memberships\n   */\n  function _grantRole(bytes32 role, address account) internal virtual override {\n    super._grantRole(role, account);\n    _roleMembers[role].add(account);\n  }\n\n  /**\n   * @dev Overload {_revokeRole} to track enumerable memberships\n   */\n  function _revokeRole(bytes32 role, address account)\n    internal\n    virtual\n    override\n  {\n    super._revokeRole(role, account);\n    _roleMembers[role].remove(account);\n  }\n}\n"

    },

    "contracts/external/openzeppelin/contracts/access/IAccessControl.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n  /**\n   * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n   *\n   * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n   * {RoleAdminChanged} not being emitted signaling this.\n   *\n   * _Available since v3.1._\n   */\n  event RoleAdminChanged(\n    bytes32 indexed role,\n    bytes32 indexed previousAdminRole,\n    bytes32 indexed newAdminRole\n  );\n\n  /**\n   * @dev Emitted when `account` is granted `role`.\n   *\n   * `sender` is the account that originated the contract call, an admin role\n   * bearer except when using {AccessControl-_setupRole}.\n   */\n  event RoleGranted(\n    bytes32 indexed role,\n    address indexed account,\n    address indexed sender\n  );\n\n  /**\n   * @dev Emitted when `account` is revoked `role`.\n   *\n   * `sender` is the account that originated the contract call:\n   *   - if using `revokeRole`, it is the admin role bearer\n   *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n   */\n  event RoleRevoked(\n    bytes32 indexed role,\n    address indexed account,\n    address indexed sender\n  );\n\n  /**\n   * @dev Returns `true` if `account` has been granted `role`.\n   */\n  function hasRole(bytes32 role, address account) external view returns (bool);\n\n  /**\n   * @dev Returns the admin role that controls `role`. See {grantRole} and\n   * {revokeRole}.\n   *\n   * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n   */\n  function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n  /**\n   * @dev Grants `role` to `account`.\n   *\n   * If `account` had not been already granted `role`, emits a {RoleGranted}\n   * event.\n   *\n   * Requirements:\n   *\n   * - the caller must have ``role``'s admin role.\n   */\n  function grantRole(bytes32 role, address account) external;\n\n  /**\n   * @dev Revokes `role` from `account`.\n   *\n   * If `account` had been granted `role`, emits a {RoleRevoked} event.\n   *\n   * Requirements:\n   *\n   * - the caller must have ``role``'s admin role.\n   */\n  function revokeRole(bytes32 role, address account) external;\n\n  /**\n   * @dev Revokes `role` from the calling account.\n   *\n   * Roles are often managed via {grantRole} and {revokeRole}: this function's\n   * purpose is to provide a mechanism for accounts to lose their privileges\n   * if they are compromised (such as when a trusted device is misplaced).\n   *\n   * If the calling account had been granted `role`, emits a {RoleRevoked}\n   * event.\n   *\n   * Requirements:\n   *\n   * - the caller must be `account`.\n   */\n  function renounceRole(bytes32 role, address account) external;\n}\n"

    },

    "contracts/external/openzeppelin/contracts/access/IAccessControlEnumerable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"contracts/external/openzeppelin/contracts/access/IAccessControl.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable is IAccessControl {\n  /**\n   * @dev Returns one of the accounts that have `role`. `index` must be a\n   * value between 0 and {getRoleMemberCount}, non-inclusive.\n   *\n   * Role bearers are not sorted in any particular way, and their ordering may\n   * change at any point.\n   *\n   * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n   * you perform all queries on the same block. See the following\n   * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n   * for more information.\n   */\n  function getRoleMember(bytes32 role, uint256 index)\n    external\n    view\n    returns (address);\n\n  /**\n   * @dev Returns the number of accounts that have `role`. Can be used\n   * together with {getRoleMember} to enumerate all bearers of a role.\n   */\n  function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"

    },

    "contracts/external/openzeppelin/contracts/security/ReentrancyGuard.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n  // Booleans are more expensive than uint256 or any type that takes up a full\n  // word because each write operation emits an extra SLOAD to first read the\n  // slot's contents, replace the bits taken up by the boolean, and then write\n  // back. This is the compiler's defense against contract upgrades and\n  // pointer aliasing, and it cannot be disabled.\n\n  // The values being non-zero value makes deployment a bit more expensive,\n  // but in exchange the refund on every call to nonReentrant will be lower in\n  // amount. Since refunds are capped to a percentage of the total\n  // transaction's gas, it is best to keep them low in cases like this one, to\n  // increase the likelihood of the full refund coming into effect.\n  uint256 private constant _NOT_ENTERED = 1;\n  uint256 private constant _ENTERED = 2;\n\n  uint256 private _status;\n\n  constructor() {\n    _status = _NOT_ENTERED;\n  }\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and making it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    // On the first call to nonReentrant, _notEntered will be true\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n    // Any calls to nonReentrant after this point will fail\n    _status = _ENTERED;\n\n    _;\n\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    _status = _NOT_ENTERED;\n  }\n}\n"

    },

    "contracts/external/openzeppelin/contracts/token/IERC20.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `to`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address to, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender)\n    external\n    view\n    returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `from` to `to` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"

    },

    "contracts/external/openzeppelin/contracts/token/IERC20Metadata.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"contracts/external/openzeppelin/contracts/token/IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n  /**\n   * @dev Returns the name of the token.\n   */\n  function name() external view returns (string memory);\n\n  /**\n   * @dev Returns the symbol of the token.\n   */\n  function symbol() external view returns (string memory);\n\n  /**\n   * @dev Returns the decimals places of the token.\n   */\n  function decimals() external view returns (uint8);\n}\n"

    },

    "contracts/external/openzeppelin/contracts/token/SafeERC20.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"contracts/external/openzeppelin/contracts/token/IERC20.sol\";\nimport \"contracts/external/openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n  using Address for address;\n\n  function safeTransfer(\n    IERC20 token,\n    address to,\n    uint256 value\n  ) internal {\n    _callOptionalReturn(\n      token,\n      abi.encodeWithSelector(token.transfer.selector, to, value)\n    );\n  }\n\n  function safeTransferFrom(\n    IERC20 token,\n    address from,\n    address to,\n    uint256 value\n  ) internal {\n    _callOptionalReturn(\n      token,\n      abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n    );\n  }\n\n  /**\n   * @dev Deprecated. This function has issues similar to the ones found in\n   * {IERC20-approve}, and its usage is discouraged.\n   *\n   * Whenever possible, use {safeIncreaseAllowance} and\n   * {safeDecreaseAllowance} instead.\n   */\n  function safeApprove(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    // safeApprove should only be called when setting an initial allowance,\n    // or when resetting it to zero. To increase and decrease it, use\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n    require(\n      (value == 0) || (token.allowance(address(this), spender) == 0),\n      \"SafeERC20: approve from non-zero to non-zero allowance\"\n    );\n    _callOptionalReturn(\n      token,\n      abi.encodeWithSelector(token.approve.selector, spender, value)\n    );\n  }\n\n  function safeIncreaseAllowance(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    uint256 newAllowance = token.allowance(address(this), spender) + value;\n    _callOptionalReturn(\n      token,\n      abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\n    );\n  }\n\n  function safeDecreaseAllowance(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    unchecked {\n      uint256 oldAllowance = token.allowance(address(this), spender);\n      require(\n        oldAllowance >= value,\n        \"SafeERC20: decreased allowance below zero\"\n      );\n      uint256 newAllowance = oldAllowance - value;\n      _callOptionalReturn(\n        token,\n        abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\n      );\n    }\n  }\n\n  /**\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n   * on the return value: the return value is optional (but if data is returned, it must not be false).\n   * @param token The token targeted by the call.\n   * @param data The call data (encoded using abi.encode or one of its variants).\n   */\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n    // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n    // the target address contains contract code and also asserts for success in the low-level call.\n\n    bytes memory returndata =\n      address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n    if (returndata.length > 0) {\n      // Return data is optional\n      require(\n        abi.decode(returndata, (bool)),\n        \"SafeERC20: ERC20 operation did not succeed\"\n      );\n    }\n  }\n}\n"

    },

    "contracts/external/openzeppelin/contracts/utils/Address.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n  /**\n   * @dev Returns true if `account` is a contract.\n   *\n   * [IMPORTANT]\n   * ====\n   * It is unsafe to assume that an address for which this function returns\n   * false is an externally-owned account (EOA) and not a contract.\n   *\n   * Among others, `isContract` will return false for the following\n   * types of addresses:\n   *\n   *  - an externally-owned account\n   *  - a contract in construction\n   *  - an address where a contract will be created\n   *  - an address where a contract lived, but was destroyed\n   * ====\n   *\n   * [IMPORTANT]\n   * ====\n   * You shouldn't rely on `isContract` to protect against flash loan attacks!\n   *\n   * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n   * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n   * constructor.\n   * ====\n   */\n  function isContract(address account) internal view returns (bool) {\n    // This method relies on extcodesize/address.code.length, which returns 0\n    // for contracts in construction, since the code is only stored at the end\n    // of the constructor execution.\n\n    return account.code.length > 0;\n  }\n\n  /**\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n   * `recipient`, forwarding all available gas and reverting on errors.\n   *\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\n   * imposed by `transfer`, making them unable to receive funds via\n   * `transfer`. {sendValue} removes this limitation.\n   *\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n   *\n   * IMPORTANT: because control is transferred to `recipient`, care must be\n   * taken to not create reentrancy vulnerabilities. Consider using\n   * {ReentrancyGuard} or the\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n   */\n  function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n    (bool success, ) = recipient.call{value: amount}(\"\");\n    require(\n      success,\n      \"Address: unable to send value, recipient may have reverted\"\n    );\n  }\n\n  /**\n   * @dev Performs a Solidity function call using a low level `call`. A\n   * plain `call` is an unsafe replacement for a function call: use this\n   * function instead.\n   *\n   * If `target` reverts with a revert reason, it is bubbled up by this\n   * function (like regular Solidity function calls).\n   *\n   * Returns the raw returned data. To convert to the expected return value,\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n   *\n   * Requirements:\n   *\n   * - `target` must be a contract.\n   * - calling `target` with `data` must not revert.\n   *\n   * _Available since v3.1._\n   */\n  function functionCall(address target, bytes memory data)\n    internal\n    returns (bytes memory)\n  {\n    return functionCall(target, data, \"Address: low-level call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n   * `errorMessage` as a fallback revert reason when `target` reverts.\n   *\n   * _Available since v3.1._\n   */\n  function functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but also transferring `value` wei to `target`.\n   *\n   * Requirements:\n   *\n   * - the calling contract must have an ETH balance of at least `value`.\n   * - the called Solidity function must be `payable`.\n   *\n   * _Available since v3.1._\n   */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value\n  ) internal returns (bytes memory) {\n    return\n      functionCallWithValue(\n        target,\n        data,\n        value,\n        \"Address: low-level call with value failed\"\n      );\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n   * with `errorMessage` as a fallback revert reason when `target` reverts.\n   *\n   * _Available since v3.1._\n   */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(\n      address(this).balance >= value,\n      \"Address: insufficient balance for call\"\n    );\n    require(isContract(target), \"Address: call to non-contract\");\n\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\n    return verifyCallResult(success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but performing a static call.\n   *\n   * _Available since v3.3._\n   */\n  function functionStaticCall(address target, bytes memory data)\n    internal\n    view\n    returns (bytes memory)\n  {\n    return\n      functionStaticCall(target, data, \"Address: low-level static call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n   * but performing a static call.\n   *\n   * _Available since v3.3._\n   */\n  function functionStaticCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    require(isContract(target), \"Address: static call to non-contract\");\n\n    (bool success, bytes memory returndata) = target.staticcall(data);\n    return verifyCallResult(success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but performing a delegate call.\n   *\n   * _Available since v3.4._\n   */\n  function functionDelegateCall(address target, bytes memory data)\n    internal\n    returns (bytes memory)\n  {\n    return\n      functionDelegateCall(\n        target,\n        data,\n        \"Address: low-level delegate call failed\"\n      );\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n   * but performing a delegate call.\n   *\n   * _Available since v3.4._\n   */\n  function functionDelegateCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(isContract(target), \"Address: delegate call to non-contract\");\n\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return verifyCallResult(success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n   * revert reason using the provided one.\n   *\n   * _Available since v4.3._\n   */\n  function verifyCallResult(\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal pure returns (bytes memory) {\n    if (success) {\n      return returndata;\n    } else {\n      // Look for revert reason and bubble it up if present\n      if (returndata.length > 0) {\n        // The easiest way to bubble the revert reason is using memory via assembly\n\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      } else {\n        revert(errorMessage);\n      }\n    }\n  }\n}\n"

    },

    "contracts/external/openzeppelin/contracts/utils/Context.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n  function _msgSender() internal view virtual returns (address) {\n    return msg.sender;\n  }\n\n  function _msgData() internal view virtual returns (bytes calldata) {\n    return msg.data;\n  }\n}\n"

    },

    "contracts/external/openzeppelin/contracts/utils/ERC165.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"contracts/external/openzeppelin/contracts/utils/IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    virtual\n    override\n    returns (bool)\n  {\n    return interfaceId == type(IERC165).interfaceId;\n  }\n}\n"

    },

    "contracts/external/openzeppelin/contracts/utils/EnumerableSet.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n  // To implement this library for multiple types with as little code\n  // repetition as possible, we write it in terms of a generic Set type with\n  // bytes32 values.\n  // The Set implementation uses private functions, and user-facing\n  // implementations (such as AddressSet) are just wrappers around the\n  // underlying Set.\n  // This means that we can only create new EnumerableSets for types that fit\n  // in bytes32.\n\n  struct Set {\n    // Storage of set values\n    bytes32[] _values;\n    // Position of the value in the `values` array, plus 1 because index 0\n    // means a value is not in the set.\n    mapping(bytes32 => uint256) _indexes;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function _add(Set storage set, bytes32 value) private returns (bool) {\n    if (!_contains(set, value)) {\n      set._values.push(value);\n      // The value is stored at length-1, but we add 1 to all indexes\n      // and use 0 as a sentinel value\n      set._indexes[value] = set._values.length;\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function _remove(Set storage set, bytes32 value) private returns (bool) {\n    // We read and store the value's index to prevent multiple reads from the same storage slot\n    uint256 valueIndex = set._indexes[value];\n\n    if (valueIndex != 0) {\n      // Equivalent to contains(set, value)\n      // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n      // the array, and then remove the last element (sometimes called as 'swap and pop').\n      // This modifies the order of the array, as noted in {at}.\n\n      uint256 toDeleteIndex = valueIndex - 1;\n      uint256 lastIndex = set._values.length - 1;\n\n      if (lastIndex != toDeleteIndex) {\n        bytes32 lastvalue = set._values[lastIndex];\n\n        // Move the last value to the index where the value to delete is\n        set._values[toDeleteIndex] = lastvalue;\n        // Update the index for the moved value\n        set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n      }\n\n      // Delete the slot where the moved value was stored\n      set._values.pop();\n\n      // Delete the index for the deleted slot\n      delete set._indexes[value];\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function _contains(Set storage set, bytes32 value)\n    private\n    view\n    returns (bool)\n  {\n    return set._indexes[value] != 0;\n  }\n\n  /**\n   * @dev Returns the number of values on the set. O(1).\n   */\n  function _length(Set storage set) private view returns (uint256) {\n    return set._values.length;\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function _at(Set storage set, uint256 index) private view returns (bytes32) {\n    return set._values[index];\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function _values(Set storage set) private view returns (bytes32[] memory) {\n    return set._values;\n  }\n\n  // Bytes32Set\n\n  struct Bytes32Set {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n    return _add(set._inner, value);\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function remove(Bytes32Set storage set, bytes32 value)\n    internal\n    returns (bool)\n  {\n    return _remove(set._inner, value);\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function contains(Bytes32Set storage set, bytes32 value)\n    internal\n    view\n    returns (bool)\n  {\n    return _contains(set._inner, value);\n  }\n\n  /**\n   * @dev Returns the number of values in the set. O(1).\n   */\n  function length(Bytes32Set storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(Bytes32Set storage set, uint256 index)\n    internal\n    view\n    returns (bytes32)\n  {\n    return _at(set._inner, index);\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function values(Bytes32Set storage set)\n    internal\n    view\n    returns (bytes32[] memory)\n  {\n    return _values(set._inner);\n  }\n\n  // AddressSet\n\n  struct AddressSet {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function add(AddressSet storage set, address value) internal returns (bool) {\n    return _add(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function remove(AddressSet storage set, address value)\n    internal\n    returns (bool)\n  {\n    return _remove(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function contains(AddressSet storage set, address value)\n    internal\n    view\n    returns (bool)\n  {\n    return _contains(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Returns the number of values in the set. O(1).\n   */\n  function length(AddressSet storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(AddressSet storage set, uint256 index)\n    internal\n    view\n    returns (address)\n  {\n    return address(uint160(uint256(_at(set._inner, index))));\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function values(AddressSet storage set)\n    internal\n    view\n    returns (address[] memory)\n  {\n    bytes32[] memory store = _values(set._inner);\n    address[] memory result;\n\n    assembly {\n      result := store\n    }\n\n    return result;\n  }\n\n  // UintSet\n\n  struct UintSet {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function add(UintSet storage set, uint256 value) internal returns (bool) {\n    return _add(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function remove(UintSet storage set, uint256 value) internal returns (bool) {\n    return _remove(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function contains(UintSet storage set, uint256 value)\n    internal\n    view\n    returns (bool)\n  {\n    return _contains(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Returns the number of values on the set. O(1).\n   */\n  function length(UintSet storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(UintSet storage set, uint256 index)\n    internal\n    view\n    returns (uint256)\n  {\n    return uint256(_at(set._inner, index));\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function values(UintSet storage set)\n    internal\n    view\n    returns (uint256[] memory)\n  {\n    bytes32[] memory store = _values(set._inner);\n    uint256[] memory result;\n\n    assembly {\n      result := store\n    }\n\n    return result;\n  }\n}\n"

    },

    "contracts/external/openzeppelin/contracts/utils/IERC165.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n  /**\n   * @dev Returns true if this contract implements the interface defined by\n   * `interfaceId`. See the corresponding\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n   * to learn more about how these ids are created.\n   *\n   * This function call must use less than 30 000 gas.\n   */\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"

    },

    "contracts/external/openzeppelin/contracts/utils/Strings.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n  bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n   */\n  function toString(uint256 value) internal pure returns (string memory) {\n    // Inspired by OraclizeAPI's implementation - MIT licence\n    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n    if (value == 0) {\n      return \"0\";\n    }\n    uint256 temp = value;\n    uint256 digits;\n    while (temp != 0) {\n      digits++;\n      temp /= 10;\n    }\n    bytes memory buffer = new bytes(digits);\n    while (value != 0) {\n      digits -= 1;\n      buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n      value /= 10;\n    }\n    return string(buffer);\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n   */\n  function toHexString(uint256 value) internal pure returns (string memory) {\n    if (value == 0) {\n      return \"0x00\";\n    }\n    uint256 temp = value;\n    uint256 length = 0;\n    while (temp != 0) {\n      length++;\n      temp >>= 8;\n    }\n    return toHexString(value, length);\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n   */\n  function toHexString(uint256 value, uint256 length)\n    internal\n    pure\n    returns (string memory)\n  {\n    bytes memory buffer = new bytes(2 * length + 2);\n    buffer[0] = \"0\";\n    buffer[1] = \"x\";\n    for (uint256 i = 2 * length + 1; i > 1; --i) {\n      buffer[i] = _HEX_SYMBOLS[value & 0xf];\n      value >>= 4;\n    }\n    require(value == 0, \"Strings: hex length insufficient\");\n    return string(buffer);\n  }\n}\n"

    },

    "contracts/interfaces/IBlocklist.sol": {

      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\ninterface IBlocklist {\n  function addToBlocklist(address[] calldata accounts) external;\n\n  function removeFromBlocklist(address[] calldata accounts) external;\n\n  function isBlocked(address account) external view returns (bool);\n\n  /**\n   * @notice Event emitted when addresses are added to the blocklist\n   *\n   * @param accounts The addresses that were added to the blocklist\n   */\n  event BlockedAddressesAdded(address[] accounts);\n\n  /**\n   * @notice Event emitted when addresses are removed from the blocklist\n   *\n   * @param accounts The addresses that were removed from the blocklist\n   */\n  event BlockedAddressesRemoved(address[] accounts);\n}\n"

    },

    "contracts/interfaces/IBlocklistClient.sol": {

      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/interfaces/IBlocklist.sol\";\n\n/**\n * @title IBlocklistClient\n * @author Ondo Finance\n * @notice The client interface for the Blocklist contract.\n */\ninterface IBlocklistClient {\n  /// @notice Returns reference to the blocklist that this client queries\n  function blocklist() external view returns (IBlocklist);\n\n  /// @notice Sets the blocklist reference\n  function setBlocklist(address registry) external;\n\n  /// @notice Error for when caller attempts to set the blocklist reference\n  ///         to the zero address\n  error BlocklistZeroAddress();\n\n  /// @notice Error for when caller attempts to perform action on a blocked\n  ///         account\n  error BlockedAccount();\n\n  /**\n   * @dev Event for when the blocklist reference is set\n   *\n   * @param oldBlocklist The old blocklist\n   * @param newBlocklist The new blocklist\n   */\n  event BlocklistSet(address oldBlocklist, address newBlocklist);\n}\n"

    },

    "contracts/interfaces/IPricer.sol": {

      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\ninterface IPricer {\n  /**\n   * @notice Gets the latest price of the asset\n   *\n   * @return uint256 The latest price of the asset\n   */\n  function getLatestPrice() external view returns (uint256);\n\n  /**\n   * @notice Gets the price of the asset at a specific priceId\n   *\n   * @param priceId The priceId at which to get the price\n   *\n   * @return uint256 The price of the asset with the given priceId\n   */\n  function getPrice(uint256 priceId) external view returns (uint256);\n\n  /**\n   * @notice Adds a price to the pricer\n   *\n   * @param price     The price to add\n   * @param timestamp The timestamp associated with the price\n   *\n   * @dev Updates the oracle price if price is the latest\n   */\n  function addPrice(uint256 price, uint256 timestamp) external;\n\n  /**\n   * @notice Updates a price in the pricer\n   *\n   * @param priceId The priceId to update\n   * @param price   The price to set\n   */\n  function updatePrice(uint256 priceId, uint256 price) external;\n\n  /**\n   * @notice Updates a price in the pricer by pulling it from the oracle\n   */\n  function addLatestOraclePrice() external;\n}\n"

    },

    "contracts/interfaces/IRWAHub.sol": {

      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n */\npragma solidity 0.8.16;\n\ninterface IRWAHub {\n  // Struct to contain the deposit information for a given depositId\n  struct Depositor {\n    address user;\n    uint256 amountDepositedMinusFees;\n    uint256 priceId;\n  }\n\n  // Struc to contain withdrawal infromation for a given redemptionId\n  struct Redeemer {\n    address user;\n    uint256 amountRwaTokenBurned;\n    uint256 priceId;\n  }\n\n  function requestSubscription(uint256 amount) external;\n\n  function claimMint(bytes32[] calldata depositIds) external;\n\n  function requestRedemption(uint256 amount) external;\n\n  function claimRedemption(bytes32[] calldata redemptionIds) external;\n\n  function addProof(\n    bytes32 txHash,\n    address user,\n    uint256 depositAmountAfterFee,\n    uint256 feeAmount,\n    uint256 timestamp\n  ) external;\n\n  function setPriceIdForDeposits(\n    bytes32[] calldata depositIds,\n    uint256[] calldata priceIds\n  ) external;\n\n  function setPriceIdForRedemptions(\n    bytes32[] calldata redemptionIds,\n    uint256[] calldata priceIds\n  ) external;\n\n  function setPricer(address newPricer) external;\n\n  function overwriteDepositor(\n    bytes32 depositIdToOverride,\n    address user,\n    uint256 depositAmountAfterFee,\n    uint256 priceId\n  ) external;\n\n  function overwriteRedeemer(\n    bytes32 redemptionIdToOverride,\n    address user,\n    uint256 rwaTokenAmountBurned,\n    uint256 priceId\n  ) external;\n\n  /**\n   * @notice Event emitted when fee recipient is set\n   *\n   * @param oldFeeRecipient Old fee recipient\n   * @param newFeeRecipient New fee recipient\n   */\n  event FeeRecipientSet(address oldFeeRecipient, address newFeeRecipient);\n\n  /**\n   * @notice Event emitted when the assetSender is changed\n   *\n   * @param oldAssetSender The address of the old assetSender\n   * @param newAssetSender The address of the new assetSender\n   */\n  event AssetSenderSet(address oldAssetSender, address newAssetSender);\n\n  /**\n   * @notice Event emitted when minimum deposit amount is set\n   *\n   * @param oldMinimum Old minimum\n   * @param newMinimum New minimum\n   *\n   * @dev See inheriting contract for decimals representation\n   */\n  event MinimumDepositAmountSet(uint256 oldMinimum, uint256 newMinimum);\n\n  /**\n   * @notice Event emitted when a new redeem minimum is set.\n   *         All units are in 1e18\n   *\n   * @param oldRedemptionMin The old redeem minimum value\n   * @param newRedemptionMin The new redeem minimum value\n   */\n  event MinimumRedemptionAmountSet(\n    uint256 oldRedemptionMin,\n    uint256 newRedemptionMin\n  );\n\n  /**\n   * @notice Event emitted when mint fee is set\n   *\n   * @param oldFee Old fee\n   * @param newFee New fee\n   *\n   * @dev See inheriting contract for decimals representation\n   */\n  event MintFeeSet(uint256 oldFee, uint256 newFee);\n\n  /**\n   * @notice Event emitted when redeem fee is set\n   *\n   * @param oldFee Old fee\n   * @param newFee New fee\n   *\n   * @dev see inheriting contract for decimal representation\n   */\n  event RedemptionFeeSet(uint256 oldFee, uint256 newFee);\n\n  /**\n   * @notice Event emitted when redemption request is submitted\n   *\n   * @param user         The user submitting the redemption request\n   * @param redemptionId The id corresponding to a given redemption\n   * @param rwaAmountIn The amount of cash being burned\n   */\n  event RedemptionRequested(\n    address indexed user,\n    bytes32 indexed redemptionId,\n    uint256 rwaAmountIn\n  );\n\n  /**\n   * @notice Event emitted when a mint request is submitted\n   *\n   * @param user                      The user requesting to mint\n   * @param depositId                 The depositId of the request\n   * @param collateralAmountDeposited The total amount deposited\n   * @param depositAmountAfterFee     The value deposited - fee\n   * @param feeAmount                 The fee amount taken\n   *                                  (units of collateral)\n   */\n  event MintRequested(\n    address indexed user,\n    bytes32 indexed depositId,\n    uint256 collateralAmountDeposited,\n    uint256 depositAmountAfterFee,\n    uint256 feeAmount\n  );\n\n  /**\n   * @notice Event emitted when a redemption request is completed\n   *\n   * @param user                     The address of the user getting the funds\n   * @param redemptionId             The id corresponding to a given redemption\n   *                                 requested\n   * @param rwaAmountRequested       Amount of RWA originally requested by the user\n   * @param collateralAmountReturned Amount of collateral received by the user\n   * @param price                    The price at which the redemption was\n   *                                 serviced at\n   */\n  event RedemptionCompleted(\n    address indexed user,\n    bytes32 indexed redemptionId,\n    uint256 rwaAmountRequested,\n    uint256 collateralAmountReturned,\n    uint256 price\n  );\n\n  /**\n   * @notice Event emitted when a Mint request is completed\n   *\n   * @param user                      The address of the user getting the funds\n   * @param depositId                 The depositId of the mint request\n   * @param rwaAmountOut              The amount of RWA token minted to the\n   *                                  user\n   * @param collateralAmountDeposited The amount of collateral deposited\n   * @param price                     The price set for the given\n   *                                  deposit id\n   * @param priceId                   The priceId used to determine price\n   */\n  event MintCompleted(\n    address indexed user,\n    bytes32 indexed depositId,\n    uint256 rwaAmountOut,\n    uint256 collateralAmountDeposited,\n    uint256 price,\n    uint256 priceId\n  );\n\n  /**\n   * @notice Event emitted when a deposit has its corresponding priceId set\n   *\n   * @param depositIdSet The Deposit Id for which the price Id is being set\n   * @param priceIdSet   The price Id being associate with a deposit Id\n   */\n  event PriceIdSetForDeposit(\n    bytes32 indexed depositIdSet,\n    uint256 indexed priceIdSet\n  );\n\n  /**\n   * @notice Event Emitted when a redemption has its corresponding priceId set\n   *\n   * @param redemptionIdSet The Redemption Id for which the price Id is being\n   *                        set\n   * @param priceIdSet      The Price Id being associated with a redemption Id\n   */\n  event PriceIdSetForRedemption(\n    bytes32 indexed redemptionIdSet,\n    uint256 indexed priceIdSet\n  );\n\n  /**\n   * @notice Event emitted when a new Pricer contract is set\n   *\n   * @param oldPricer The address of the old pricer contract\n   * @param newPricer The address of the new pricer contract\n   */\n  event NewPricerSet(address oldPricer, address newPricer);\n\n  /**\n   * @notice Event emitted when deposit proof has been added\n   *\n   * @param txHash                Tx hash of the deposit\n   * @param user                  Address of the user who made the deposit\n   * @param depositAmountAfterFee Amount of the deposit after fees\n   * @param feeAmount             Amount of fees taken\n   * @param timestamp             Timestamp of the deposit\n   */\n  event DepositProofAdded(\n    bytes32 indexed txHash,\n    address indexed user,\n    uint256 depositAmountAfterFee,\n    uint256 feeAmount,\n    uint256 timestamp\n  );\n\n  /**\n   * @notice Event emitted when subscriptions are paused\n   *\n   * @param caller Address which initiated the pause\n   */\n  event SubscriptionPaused(address caller);\n\n  /**\n   * @notice Event emitted when redemptions are paused\n   *\n   * @param caller Address which initiated the pause\n   */\n  event RedemptionPaused(address caller);\n\n  /**\n   * @notice Event emitted when subscriptions are unpaused\n   *\n   * @param caller Address which initiated the unpause\n   */\n  event SubscriptionUnpaused(address caller);\n\n  /**\n   * @notice Event emitted when redemptions are unpaused\n   *\n   * @param caller Address which initiated the unpause\n   */\n  event RedemptionUnpaused(address caller);\n\n  event DepositorOverwritten(\n    bytes32 indexed depositId,\n    address oldDepositor,\n    address newDepositor,\n    uint256 oldPriceId,\n    uint256 newPriceId,\n    uint256 oldDepositAmount,\n    uint256 newDepositAmount\n  );\n\n  event RedeemerOverwritten(\n    bytes32 indexed redemptionId,\n    address oldRedeemer,\n    address newRedeemer,\n    uint256 oldPriceId,\n    uint256 newPriceId,\n    uint256 oldRWATokenAmountBurned,\n    uint256 newRWATokenAmountBurned\n  );\n\n  /// ERRORS ///\n  error PriceIdNotSet();\n  error ArraySizeMismatch();\n  error DepositTooSmall();\n  error RedemptionTooSmall();\n  error TxnAlreadyValidated();\n  error CollateralCannotBeZero();\n  error RWACannotBeZero();\n  error AssetSenderCannotBeZero();\n  error FeeRecipientCannotBeZero();\n  error FeeTooLarge();\n  error AmountTooSmall();\n  error DepositorNull();\n  error RedeemerNull();\n  error DepositProofAlreadyExists();\n  error FeaturePaused();\n  error PriceIdAlreadySet();\n}\n"

    },

    "contracts/interfaces/IRWAHubOffChainRedemptions.sol": {

      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n */\npragma solidity 0.8.16;\n\ninterface IRWAHubOffChainRedemptions {\n  function requestRedemptionServicedOffchain(\n    uint256 amountRWATokenToRedeem,\n    bytes32 offChainDestination\n  ) external;\n\n  function pauseOffChainRedemption() external;\n\n  function unpauseOffChainRedemption() external;\n\n  function setOffChainRedemptionMinimum(uint256 minimumAmount) external;\n\n  /**\n   * @notice Event emitted when redemption request is submitted\n   *\n   * @param redemptionId        The user submitting the redemption request\n   * @param user                The user submitting the redemption request\n   * @param rwaTokenAmountIn    The amount of cash being burned\n   * @param offChainDestination Hash of destination to which the request\n   *                            should be serviced to\n   */\n  event RedemptionRequestedServicedOffChain(\n    bytes32 indexed redemptionId,\n    address indexed user,\n    uint256 rwaTokenAmountIn,\n    bytes32 offChainDestination\n  );\n\n  /**\n   * @notice Event emitted when the off chain redemption feature is\n   *         paused\n   *\n   * @param caller Address which initiated the pause\n   */\n  event OffChainRedemptionPaused(address caller);\n\n  /**\n   * @notice Event emitted when the off chain redemption feature is\n   *         unpaused\n   *\n   * @param caller Address which initiated the unpause\n   */\n  event OffChainRedemptionUnpaused(address caller);\n\n  /**\n   * @notice Event emitted when the off chain redemption minimum is\n   *         updated\n   *\n   * @param oldMinimum the old minimum redemption amount\n   * @param newMinimum the new minimum redemption amount\n   */\n  event OffChainRedemptionMinimumSet(uint256 oldMinimum, uint256 newMinimum);\n}\n"

    },

    "contracts/interfaces/IRWALike.sol": {

      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n */\npragma solidity 0.8.16;\n\n// This interface is not inherited directly by RWA, instead, it is a\n// subset of functions provided by all RWA tokens that the RWA Hub\n// Client uses.\nimport \"contracts/external/openzeppelin/contracts/token/IERC20.sol\";\n\ninterface IRWALike is IERC20 {\n  function mint(address to, uint256 amount) external;\n\n  function burn(address from, uint256 amount) external;\n\n  function burn(uint256 amount) external;\n\n  function burnFrom(address from, uint256 amount) external;\n\n  function grantRole(bytes32, address) external;\n}\n"

    },

    "contracts/interfaces/IUSDYManager.sol": {

      "content": "/**SPDX-License-Identifier: BUSL-1.1\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n */\npragma solidity 0.8.16;\n\ninterface IUSDYManager {\n  function setClaimableTimestamp(\n    uint256 claimDate,\n    bytes32[] calldata depositIds\n  ) external;\n\n  /**\n   * @notice Event emitted when claimable timestamp is set\n   *\n   * @param claimTimestamp The timestamp at which the mint can be claimed\n   * @param depositId      The depositId that can claim at the given \n                           `claimTimestamp`\n   */\n  event ClaimableTimestampSet(\n    uint256 indexed claimTimestamp,\n    bytes32 indexed depositId\n  );\n\n  /// ERRORS ///\n  error MintNotYetClaimable();\n  error ClaimableTimestampInPast();\n  error ClaimableTimestampNotSet();\n}\n"

    },

    "contracts/sanctions/ISanctionsListClient.sol": {

      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/external/chainalysis/ISanctionsList.sol\";\n\n/**\n * @title ISanctionsListClient\n * @author Ondo Finance\n * @notice The client interface for sanctions contract.\n */\ninterface ISanctionsListClient {\n  /// @notice Returns reference to the sanctions list that this client queries\n  function sanctionsList() external view returns (ISanctionsList);\n\n  /// @notice Sets the sanctions list reference\n  function setSanctionsList(address sanctionsList) external;\n\n  /// @notice Error for when caller attempts to set the `sanctionsList`\n  ///         reference to the zero address\n  error SanctionsListZeroAddress();\n\n  /// @notice Error for when caller attempts to perform an action on a\n  ///         sanctioned account\n  error SanctionedAccount();\n\n  /**\n   * @dev Event for when the sanctions list reference is set\n   *\n   * @param oldSanctionsList The old list\n   * @param newSanctionsList The new list\n   */\n  event SanctionsListSet(address oldSanctionsList, address newSanctionsList);\n}\n"

    },

    "contracts/sanctions/SanctionsListClient.sol": {

      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/external/chainalysis/ISanctionsList.sol\";\nimport \"contracts/sanctions/ISanctionsListClient.sol\";\n\n/**\n * @title SanctionsListClient\n * @author Ondo Finance\n * @notice This abstract contract manages state required for clients\n *         of the sanctions list\n */\nabstract contract SanctionsListClient is ISanctionsListClient {\n  // Sanctions list address\n  ISanctionsList public override sanctionsList;\n\n  /**\n   * @notice Constructor\n   *\n   * @param _sanctionsList Address of the sanctions list contract\n   */\n  constructor(address _sanctionsList) {\n    _setSanctionsList(_sanctionsList);\n  }\n\n  /**\n   * @notice Sets the sanctions list address for this client\n   *\n   * @param _sanctionsList The new sanctions list address\n   */\n  function _setSanctionsList(address _sanctionsList) internal {\n    if (_sanctionsList == address(0)) {\n      revert SanctionsListZeroAddress();\n    }\n    address oldSanctionsList = address(sanctionsList);\n    sanctionsList = ISanctionsList(_sanctionsList);\n    emit SanctionsListSet(oldSanctionsList, _sanctionsList);\n  }\n\n  /**\n   * @notice Checks whether an address has been sanctioned\n   *\n   * @param account The account to check\n   */\n  function _isSanctioned(address account) internal view returns (bool) {\n    return sanctionsList.isSanctioned(account);\n  }\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint256[50] private __gap;\n}\n"

    },

    "contracts/usdy/USDYManager.sol": {

      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\n\npragma solidity 0.8.16;\n\nimport \"contracts/RWAHubOffChainRedemptions.sol\";\nimport \"contracts/usdy/blocklist/BlocklistClient.sol\";\nimport \"contracts/sanctions/SanctionsListClient.sol\";\nimport \"contracts/interfaces/IUSDYManager.sol\";\n\ncontract USDYManager is\n  RWAHubOffChainRedemptions,\n  BlocklistClient,\n  SanctionsListClient,\n  IUSDYManager\n{\n  bytes32 public constant TIMESTAMP_SETTER_ROLE =\n    keccak256(\"TIMESTAMP_SETTER_ROLE\");\n\n  mapping(bytes32 => uint256) public depositIdToClaimableTimestamp;\n\n  constructor(\n    address _collateral,\n    address _rwa,\n    address managerAdmin,\n    address pauser,\n    address _assetSender,\n    address _feeRecipient,\n    uint256 _minimumDepositAmount,\n    uint256 _minimumRedemptionAmount,\n    address blocklist,\n    address sanctionsList\n  )\n    RWAHubOffChainRedemptions(\n      _collateral,\n      _rwa,\n      managerAdmin,\n      pauser,\n      _assetSender,\n      _feeRecipient,\n      _minimumDepositAmount,\n      _minimumRedemptionAmount\n    )\n    BlocklistClient(blocklist)\n    SanctionsListClient(sanctionsList)\n  {}\n\n  /**\n   * @notice Function to enforce blocklist and sanctionslist restrictions to be\n   *         implemented on calls to `requestSubscription` and\n   *         `claimRedemption`\n   *\n   * @param account The account to check blocklist and sanctions list status\n   *                for\n   */\n  function _checkRestrictions(address account) internal view override {\n    if (_isBlocked(account)) {\n      revert BlockedAccount();\n    }\n    if (_isSanctioned(account)) {\n      revert SanctionedAccount();\n    }\n  }\n\n  /**\n   * @notice Internal hook that is called by `claimMint` to enforce the time\n   *         at which a user can claim their USDY\n   *\n   * @param depositId The depositId to check the claimable timestamp for\n   *\n   * @dev This function will call the `_claimMint` function in the parent\n   *      once USDY-specific checks have been made\n   */\n  function _claimMint(bytes32 depositId) internal virtual override {\n    if (depositIdToClaimableTimestamp[depositId] == 0) {\n      revert ClaimableTimestampNotSet();\n    }\n\n    if (depositIdToClaimableTimestamp[depositId] > block.timestamp) {\n      revert MintNotYetClaimable();\n    }\n\n    super._claimMint(depositId);\n    delete depositIdToClaimableTimestamp[depositId];\n  }\n\n  /**\n   * @notice Update blocklist address\n   *\n   * @param blocklist The new blocklist address\n   */\n  function setBlocklist(\n    address blocklist\n  ) external override onlyRole(MANAGER_ADMIN) {\n    _setBlocklist(blocklist);\n  }\n\n  /**\n   * @notice Update sanctions list address\n   *\n   * @param sanctionsList The new sanctions list address\n   */\n  function setSanctionsList(\n    address sanctionsList\n  ) external override onlyRole(MANAGER_ADMIN) {\n    _setSanctionsList(sanctionsList);\n  }\n\n  /**\n   * @notice Set the claimable timestamp for a list of depositIds\n   *\n   * @param claimTimestamp The timestamp at which the deposit can be claimed\n   * @param depositIds The depositIds to set the claimable timestamp for\n   */\n  function setClaimableTimestamp(\n    uint256 claimTimestamp,\n    bytes32[] calldata depositIds\n  ) external onlyRole(TIMESTAMP_SETTER_ROLE) {\n    if (claimTimestamp < block.timestamp) {\n      revert ClaimableTimestampInPast();\n    }\n\n    uint256 depositsSize = depositIds.length;\n    for (uint256 i; i < depositsSize; ++i) {\n      depositIdToClaimableTimestamp[depositIds[i]] = claimTimestamp;\n      emit ClaimableTimestampSet(claimTimestamp, depositIds[i]);\n    }\n  }\n}\n"

    },

    "contracts/usdy/blocklist/BlocklistClient.sol": {

      "content": "/**SPDX-License-Identifier: BUSL-1.1\n\n      ▄▄█████████▄\n   ╓██▀└ ,╓▄▄▄, '▀██▄\n  ██▀ ▄██▀▀╙╙▀▀██▄ └██µ           ,,       ,,      ,     ,,,            ,,,\n ██ ,██¬ ▄████▄  ▀█▄ ╙█▄      ▄███▀▀███▄   ███▄    ██  ███▀▀▀███▄    ▄███▀▀███,\n██  ██ ╒█▀'   ╙█▌ ╙█▌ ██     ▐██      ███  █████,  ██  ██▌    └██▌  ██▌     └██▌\n██ ▐█▌ ██      ╟█  █▌ ╟█     ██▌      ▐██  ██ └███ ██  ██▌     ╟██ j██       ╟██\n╟█  ██ ╙██    ▄█▀ ▐█▌ ██     ╙██      ██▌  ██   ╙████  ██▌    ▄██▀  ██▌     ,██▀\n ██ \"██, ╙▀▀███████████⌐      ╙████████▀   ██     ╙██  ███████▀▀     ╙███████▀`\n  ██▄ ╙▀██▄▄▄▄▄,,,                ¬─                                    '─¬\n   ╙▀██▄ '╙╙╙▀▀▀▀▀▀▀▀\n      ╙▀▀██████R⌐\n\n */\npragma solidity 0.8.16;\n\nimport \"contracts/interfaces/IBlocklist.sol\";\nimport \"contracts/interfaces/IBlocklistClient.sol\";\n\n/**\n * @title BlocklistClient\n * @author Ondo Finance\n * @notice This abstract contract manages state for blocklist clients\n */\nabstract contract BlocklistClient is IBlocklistClient {\n  // blocklist address\n  IBlocklist public override blocklist;\n\n  /**\n   * @notice Constructor\n   *\n   * @param _blocklist Address of the blocklist contract\n   */\n  constructor(address _blocklist) {\n    _setBlocklist(_blocklist);\n  }\n\n  /**\n   * @notice Sets the blocklist address for this client\n   *\n   * @param _blocklist The new blocklist address\n   */\n  function _setBlocklist(address _blocklist) internal {\n    if (_blocklist == address(0)) {\n      revert BlocklistZeroAddress();\n    }\n    address oldBlocklist = address(blocklist);\n    blocklist = IBlocklist(_blocklist);\n    emit BlocklistSet(oldBlocklist, _blocklist);\n  }\n\n  /**\n   * @notice Checks whether an address has been blocked\n   *\n   * @param account The account to check\n   */\n  function _isBlocked(address account) internal view returns (bool) {\n    return blocklist.isBlocked(account);\n  }\n}\n"

    }

  }

}}