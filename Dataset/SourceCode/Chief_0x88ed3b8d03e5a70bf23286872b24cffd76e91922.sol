{{

  "language": "Solidity",

  "sources": {

    "src/Chief.sol": {

      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.15;\n\n/**\n * @title Chief\n *\n * @author Fujidao Labs\n *\n * @notice Controls vault deploy factories, deployed flashers, vault ratings and core access control.\n *\n * @dev Deployments of new vaults are done through this contract that also stores the addresses of all\n * deployed vaults.\n */\n\nimport {AccessControl} from \"openzeppelin-contracts/contracts/access/AccessControl.sol\";\nimport {TimelockController} from\n  \"openzeppelin-contracts/contracts/governance/TimelockController.sol\";\nimport {Address} from \"openzeppelin-contracts/contracts/utils/Address.sol\";\nimport {IVault} from \"./interfaces/IVault.sol\";\nimport {IPausableVault} from \"./interfaces/IPausableVault.sol\";\nimport {IVaultFactory} from \"./interfaces/IVaultFactory.sol\";\nimport {IChief} from \"./interfaces/IChief.sol\";\nimport {AddrMapper} from \"./helpers/AddrMapper.sol\";\nimport {CoreRoles} from \"./access/CoreRoles.sol\";\n\ncontract Chief is CoreRoles, AccessControl, IChief {\n  using Address for address;\n\n  /**\n   * @dev Emitted when the deployements of new vaults is alllowed/disallowed.\n   *\n   * @param allowed \"true\" to allow, \"false\" to disallow\n   */\n  event AllowPermissionlessDeployments(bool allowed);\n\n  /**\n   * @dev Emitted when `vault` is set to be active or not.\n   *\n   * @param vault address\n   * @param active boolean\n   */\n  event SetVaultStatus(address vault, bool active);\n\n  /**\n   * @dev Emitted when a new flasher is alllowed/disallowed.\n   *\n   * @param flasher address of the flasher\n   * @param allowed \"true\" to allow, \"false\" to disallow\n   */\n  event AllowFlasher(address indexed flasher, bool allowed);\n\n  /**\n   * @dev Emitted when a new swapper is allowed/disallowed.\n   *\n   * @param swapper address of the swapper\n   * @param allowed \"true\" to allow, \"false\" to disallow\n   */\n  event AllowSwapper(address indexed swapper, bool allowed);\n\n  /**\n   * @dev Emitted when a new factory is alllowed/disallowed.\n   *\n   * @param factory address of the factory\n   * @param allowed \"true\" to allow, \"false\" to disallow\n   */\n  event AllowVaultFactory(address indexed factory, bool allowed);\n\n  /**\n   * @dev Emitted when a new `timelock` is set.\n   *\n   * @param timelock address of the new timelock\n   */\n  event UpdateTimelock(address indexed timelock);\n\n  /**\n   * @dev Emitted when a new rating is attributed to a vault.\n   *\n   * @param vault address of the vault\n   * @param newRating value of the new rating\n   */\n  event ChangeSafetyRating(address indexed vault, uint256 newRating);\n\n  /// @dev Custom Errors\n  error Chief__checkInput_zeroAddress();\n  error Chief__setVaultStatus_noStatusChange();\n  error Chief__allowFlasher_noAllowChange();\n  error Chief__allowVaultFactory_noAllowChange();\n  error Chief__deployVault_factoryNotAllowed();\n  error Chief__deployVault_missingRole(address account, bytes32 role);\n  error Chief__onlyTimelock_callerIsNotTimelock();\n  error Chief__setSafetyRating_notActiveVault();\n  error Chief__checkRatingValue_notInRange();\n  error Chief__allowSwapper_noAllowChange();\n\n  /**\n   * @dev When `permissionlessDeployments` is \"false\", only addresses with this role\n   * can deploy new vaults.\n   */\n  bytes32 public constant DEPLOYER_ROLE = keccak256(\"DEPLOYER_ROLE\");\n\n  address public timelock;\n  address public addrMapper;\n\n  /// @dev Control who can deploy new vaults through `deployVault()`\n  bool public permissionlessDeployments;\n\n  mapping(address => bool) public isVaultActive;\n  mapping(address => uint256) public vaultSafetyRating;\n\n  mapping(address => bool) public allowedVaultFactory;\n  mapping(address => bool) public allowedFlasher;\n  mapping(address => bool) public allowedSwapper;\n\n  modifier onlyTimelock() {\n    if (msg.sender != timelock) {\n      revert Chief__onlyTimelock_callerIsNotTimelock();\n    }\n    _;\n  }\n\n  constructor(bool deployTimelock, bool deployAddrMapper) {\n    _grantRole(DEPLOYER_ROLE, msg.sender);\n    _grantRole(HOUSE_KEEPER_ROLE, msg.sender);\n    _grantRole(PAUSER_ROLE, address(this));\n    _grantRole(UNPAUSER_ROLE, address(this));\n    if (deployTimelock) _deployTimelockController();\n    if (deployAddrMapper) _deployAddrMapper();\n  }\n\n  /**\n   * @notice Changes the status of `vault`, while triggering\n   * corresponding \"pause\" actions.\n   *\n   * @param vault to change state\n   * @param active boolean\n   *\n   * @dev Refer to internal function for implementation.\n   * Requirements:\n   * - Must be called from timelock\n   * - Must check `active` argument does change current state.\n   * - Must check `vault` is not address zero.\n   * - Must pause Deposit action in `vault`.\n   * - Must pause Borrow action if `vault` is a {BorrowingVault}.\n   */\n  function setVaultStatus(address vault, bool active) external onlyTimelock {\n    _setVaultStatus(vault, active);\n  }\n\n  /**\n   * @notice Sets a new timelock.\n   *\n   * @param newTimelock address of the new timelock contract\n   *\n   * @dev Requirements:\n   *  - Must be restricted to timelock.\n   *  - Revokes `DEFAULT_ADMIN_ROLE` from the existing timelock.\n   *  - Grants `DEFAULT_ADMIN_ROLE` to `newTimelock`.\n   *  - `newTimelock` must be a non-zero address.\n   *  - Emits a `UpdateTimelock` event.\n   *\n   */\n  function setTimelock(address newTimelock) external onlyTimelock {\n    _checkInputIsNotZeroAddress(newTimelock);\n    // Revoke admin role from current timelock\n    _revokeRole(DEFAULT_ADMIN_ROLE, timelock);\n    // Assign `timelock` to new timelock address\n    timelock = newTimelock;\n    // grant admin role to new timelock address\n    _grantRole(DEFAULT_ADMIN_ROLE, timelock);\n    emit UpdateTimelock(newTimelock);\n  }\n\n  /**\n   * @notice Sets `permissionlessDeployments`.\n   *\n   * @param allowed anyone can deploy a vault when \"true\",\n   * otherwise only address with a DEPLOYER_ROLE\n   *\n   * @dev Requirements:\n   *  - Must be restricted to timelock.\n   *  - Emits a `AllowPermissionlessDeployments` event.\n   */\n  function setPermissionlessDeployments(bool allowed) external onlyTimelock {\n    permissionlessDeployments = allowed;\n\n    emit AllowPermissionlessDeployments(allowed);\n  }\n\n  /**\n   * @notice Deploys a new vault through a factory, attribute an intial rating and\n   * store new vault's address in `_vaults`.\n   *\n   * @param factory allowed vault factory contract\n   * @param deployData encoded data that will be used in the factory to create a new vault\n   * @param rating initial rating attributed to the new vault\n   *\n   * @dev Requirements:\n   *  - Must use an allowed factory.\n   *  - Msg.sender must have `DEPLOYER_ROLE` if `permissionlessDeployments` is \"false\".\n   *  - `rating` must be in range (1,100].\n   *  - Emits a `DeployVault` event.\n   *\n   */\n  function deployVault(\n    address factory,\n    bytes calldata deployData,\n    uint256 rating\n  )\n    external\n    returns (address vault)\n  {\n    if (!allowedVaultFactory[factory]) {\n      revert Chief__deployVault_factoryNotAllowed();\n    }\n    if (!permissionlessDeployments && !hasRole(DEPLOYER_ROLE, msg.sender)) {\n      revert Chief__deployVault_missingRole(msg.sender, DEPLOYER_ROLE);\n    }\n    _checkRatingValue(rating);\n\n    vault = IVaultFactory(factory).deployVault(deployData);\n    vaultSafetyRating[vault] = rating;\n    _setVaultStatus(vault, true);\n  }\n\n  /**\n   * @notice Sets `vaultSafetyRating` for `vault`.\n   *\n   * @param vault address of the vault whose rating will be changed\n   * @param newRating a new value for the rating\n   *\n   * @dev Requirements:\n   *  - Emits a `ChangeSafetyRating` event.\n   *  - Only timelock can change rating.\n   *  - `newRating` is in range (1,100].\n   *  - `vault` is a non-zero address and is contained in `_vaults`.\n   */\n  function setSafetyRating(address vault, uint256 newRating) external onlyTimelock {\n    if (!isVaultActive[vault]) {\n      revert Chief__setSafetyRating_notActiveVault();\n    }\n    _checkRatingValue(newRating);\n\n    vaultSafetyRating[vault] = newRating;\n\n    emit ChangeSafetyRating(vault, newRating);\n  }\n\n  /**\n   * @notice Sets `flasher` as an authorized address for flashloan operations.\n   *\n   * @param flasher Address of the flasher to allow/disallow.\n   * @param allowed \"true\" to allow, \"false\" to disallow.\n   *\n   * @dev Requirements:\n   *  - `flasher` must be a non-zero address.\n   *  - `allowed` must be different the previously recorded for the same `flasher`.\n   *  - Emits a `AllowFlasher` event.\n   */\n  function allowFlasher(address flasher, bool allowed) external onlyTimelock {\n    _checkInputIsNotZeroAddress(flasher);\n    if (allowedFlasher[flasher] == allowed) {\n      revert Chief__allowFlasher_noAllowChange();\n    }\n    allowedFlasher[flasher] = allowed;\n\n    emit AllowFlasher(flasher, allowed);\n  }\n\n  /**\n   * @notice Sets `swapper` as an authorized address for swap operations.\n   *\n   * @param swapper Address of the swapper to allow/disallow.\n   * @param allowed \"true\" to allow, \"false\" to disallow.\n   *\n   * @dev Requirements:\n   *  - `swapper` must be a non-zero address.\n   *  - `allowed` must be different the previously recorded for the same `swapper`.\n   *  - Emits a `AllowSwapper` event.\n   */\n  function allowSwapper(address swapper, bool allowed) external onlyTimelock {\n    _checkInputIsNotZeroAddress(swapper);\n    if (allowedSwapper[swapper] == allowed) {\n      revert Chief__allowSwapper_noAllowChange();\n    }\n    allowedSwapper[swapper] = allowed;\n\n    emit AllowSwapper(swapper, allowed);\n  }\n\n  /**\n   * @notice Sets `factory` as an authorized address for vault deployments.\n   *\n   * @param factory address of the factory to allow/disallow\n   * @param allowed \"true\" to allow, \"false\" to disallow\n   *\n   * @dev Requirements:\n   *  - `allowed` must be different than previously recorded.\n   *  - Emits a `AllowVaultFactory` event.\n   */\n  function allowVaultFactory(address factory, bool allowed) external onlyTimelock {\n    _checkInputIsNotZeroAddress(factory);\n    if (allowedVaultFactory[factory] == allowed) {\n      revert Chief__allowVaultFactory_noAllowChange();\n    }\n    allowedVaultFactory[factory] = allowed;\n    emit AllowVaultFactory(factory, allowed);\n  }\n\n  /**\n   * @notice Force pause all actions in `vaults`.\n   *\n   * @param vaults to pause\n   *\n   * @dev Requirements:\n   *  - Must be restricted to `PAUSER_ROLE`.\n   */\n  function pauseForceVaults(IPausableVault[] calldata vaults) external onlyRole(PAUSER_ROLE) {\n    bytes memory data = abi.encodeWithSelector(IPausableVault.pauseForceAll.selector);\n    _changePauseState(vaults, data);\n  }\n\n  /**\n   * @notice Resumes all actions by force unpausing all `vaults`.\n   *\n   * @param vaults to unpause\n   *\n   * @dev Requirements:\n   *  - Must be restricted to `UNPAUSER_ROLE`.\n   */\n  function unpauseForceVaults(IPausableVault[] calldata vaults) external onlyRole(UNPAUSER_ROLE) {\n    bytes memory callData = abi.encodeWithSelector(IPausableVault.unpauseForceAll.selector);\n    _changePauseState(vaults, callData);\n  }\n\n  /**\n   * @notice Pauses specific action in all vaults in `_vaults`.\n   *\n   * @param action enum: 0-deposit, 1-withdraw, 2-borrow, 3-payback.\n   *\n   * @dev Requirements:\n   *  - `action` in all vaults' must be not paused; otherwise revert.\n   *  - Must be restricted to `PAUSER_ROLE`.\n   */\n  function pauseActionInVaults(\n    IPausableVault[] calldata vaults,\n    IPausableVault.VaultActions action\n  )\n    external\n    onlyRole(PAUSER_ROLE)\n  {\n    bytes memory callData = abi.encodeWithSelector(IPausableVault.pause.selector, action);\n    _changePauseState(vaults, callData);\n  }\n\n  /**\n   * @notice Resumes specific `action` by unpausing in all vaults in `_vaults`.\n   *\n   * @param action enum: 0-deposit, 1-withdraw, 2-borrow, 3-payback.\n   *\n   * @dev Requirements:\n   *  - `action` in all vaults' must be in paused state; otherwise revert.\n   *  - Must be restricted to `PAUSER_ROLE`.\n   */\n  function upauseActionInVaults(\n    IPausableVault[] calldata vaults,\n    IPausableVault.VaultActions action\n  )\n    external\n    onlyRole(UNPAUSER_ROLE)\n  {\n    bytes memory callData = abi.encodeWithSelector(IPausableVault.unpause.selector, action);\n    _changePauseState(vaults, callData);\n  }\n\n  /**\n   * @dev Deploys {TimelockController} contract during Chief deployment.\n   */\n  function _deployTimelockController() internal {\n    address[] memory admins = new address[](1);\n    admins[0] = msg.sender;\n    timelock = address(new TimelockController{salt: \"0x00\"}(3 seconds, admins, admins, address(0)));\n    _grantRole(DEFAULT_ADMIN_ROLE, timelock);\n  }\n\n  /**\n   * @dev Deploys {AddrMapper} contract during Chief deployment.\n   */\n  function _deployAddrMapper() internal {\n    addrMapper = address(new AddrMapper{salt: \"0x00\"}(address(this)));\n  }\n\n  /**\n   * @dev Executes pause state changes.\n   *\n   * @param vaults to change pause state\n   * @param data encoded data containing pause or unpause commands.\n   */\n  function _changePauseState(IPausableVault[] memory vaults, bytes memory data) internal {\n    uint256 alength = vaults.length;\n    for (uint256 i; i < alength;) {\n      address(vaults[i]).functionCall(data, \": pause call failed\");\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Refer to {Chief-setVaultStatus}.\n   *\n   * @param vault to change state\n   * @param active boolean\n   */\n  function _setVaultStatus(address vault, bool active) internal {\n    _checkInputIsNotZeroAddress(vault);\n    if (isVaultActive[vault] == active) {\n      revert Chief__setVaultStatus_noStatusChange();\n    }\n    isVaultActive[vault] = active;\n\n    // Pause Deposit and Borrow actions if corresponding and applicable to `vault`.\n    if (active == false) {\n      vaultSafetyRating[vault] = 0;\n      IPausableVault(vault).pause(IPausableVault.VaultActions.Deposit);\n\n      // If `vault` is a {BorrowingVault}.\n      if (IVault(vault).debtAsset() != address(0)) {\n        IPausableVault(vault).pause(IPausableVault.VaultActions.Borrow);\n      }\n    }\n\n    emit SetVaultStatus(vault, active);\n  }\n\n  /**\n   * @dev Reverts if `input` is zero address.\n   *\n   * @param input address to verify\n   */\n  function _checkInputIsNotZeroAddress(address input) internal pure {\n    if (input == address(0)) {\n      revert Chief__checkInput_zeroAddress();\n    }\n  }\n\n  /**\n   * @dev Reverts if `rating` input is not in range (1,100].\n   *\n   * @param rating value to verify is in the accepted range\n   */\n  function _checkRatingValue(uint256 rating) internal pure {\n    if (rating == 0 || rating > 100) {\n      revert Chief__checkRatingValue_notInRange();\n    }\n  }\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/access/AccessControl.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(account),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/governance/TimelockController.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.2) (governance/TimelockController.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../access/AccessControl.sol\";\nimport \"../token/ERC721/IERC721Receiver.sol\";\nimport \"../token/ERC1155/IERC1155Receiver.sol\";\n\n/**\n * @dev Contract module which acts as a timelocked controller. When set as the\n * owner of an `Ownable` smart contract, it enforces a timelock on all\n * `onlyOwner` maintenance operations. This gives time for users of the\n * controlled contract to exit before a potentially dangerous maintenance\n * operation is applied.\n *\n * By default, this contract is self administered, meaning administration tasks\n * have to go through the timelock process. The proposer (resp executor) role\n * is in charge of proposing (resp executing) operations. A common use case is\n * to position this {TimelockController} as the owner of a smart contract, with\n * a multisig or a DAO as the sole proposer.\n *\n * _Available since v3.3._\n */\ncontract TimelockController is AccessControl, IERC721Receiver, IERC1155Receiver {\n    bytes32 public constant TIMELOCK_ADMIN_ROLE = keccak256(\"TIMELOCK_ADMIN_ROLE\");\n    bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n    bytes32 public constant CANCELLER_ROLE = keccak256(\"CANCELLER_ROLE\");\n    uint256 internal constant _DONE_TIMESTAMP = uint256(1);\n\n    mapping(bytes32 => uint256) private _timestamps;\n    uint256 private _minDelay;\n\n    /**\n     * @dev Emitted when a call is scheduled as part of operation `id`.\n     */\n    event CallScheduled(\n        bytes32 indexed id,\n        uint256 indexed index,\n        address target,\n        uint256 value,\n        bytes data,\n        bytes32 predecessor,\n        uint256 delay\n    );\n\n    /**\n     * @dev Emitted when a call is performed as part of operation `id`.\n     */\n    event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data);\n\n    /**\n     * @dev Emitted when new proposal is scheduled with non-zero salt.\n     */\n    event CallSalt(bytes32 indexed id, bytes32 salt);\n\n    /**\n     * @dev Emitted when operation `id` is cancelled.\n     */\n    event Cancelled(bytes32 indexed id);\n\n    /**\n     * @dev Emitted when the minimum delay for future operations is modified.\n     */\n    event MinDelayChange(uint256 oldDuration, uint256 newDuration);\n\n    /**\n     * @dev Initializes the contract with the following parameters:\n     *\n     * - `minDelay`: initial minimum delay for operations\n     * - `proposers`: accounts to be granted proposer and canceller roles\n     * - `executors`: accounts to be granted executor role\n     * - `admin`: optional account to be granted admin role; disable with zero address\n     *\n     * IMPORTANT: The optional admin can aid with initial configuration of roles after deployment\n     * without being subject to delay, but this role should be subsequently renounced in favor of\n     * administration through timelocked proposals. Previous versions of this contract would assign\n     * this admin to the deployer automatically and should be renounced as well.\n     */\n    constructor(uint256 minDelay, address[] memory proposers, address[] memory executors, address admin) {\n        _setRoleAdmin(TIMELOCK_ADMIN_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(PROPOSER_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(EXECUTOR_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(CANCELLER_ROLE, TIMELOCK_ADMIN_ROLE);\n\n        // self administration\n        _setupRole(TIMELOCK_ADMIN_ROLE, address(this));\n\n        // optional admin\n        if (admin != address(0)) {\n            _setupRole(TIMELOCK_ADMIN_ROLE, admin);\n        }\n\n        // register proposers and cancellers\n        for (uint256 i = 0; i < proposers.length; ++i) {\n            _setupRole(PROPOSER_ROLE, proposers[i]);\n            _setupRole(CANCELLER_ROLE, proposers[i]);\n        }\n\n        // register executors\n        for (uint256 i = 0; i < executors.length; ++i) {\n            _setupRole(EXECUTOR_ROLE, executors[i]);\n        }\n\n        _minDelay = minDelay;\n        emit MinDelayChange(0, minDelay);\n    }\n\n    /**\n     * @dev Modifier to make a function callable only by a certain role. In\n     * addition to checking the sender's role, `address(0)` 's role is also\n     * considered. Granting a role to `address(0)` is equivalent to enabling\n     * this role for everyone.\n     */\n    modifier onlyRoleOrOpenRole(bytes32 role) {\n        if (!hasRole(role, address(0))) {\n            _checkRole(role, _msgSender());\n        }\n        _;\n    }\n\n    /**\n     * @dev Contract might receive/hold ETH as part of the maintenance process.\n     */\n    receive() external payable {}\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, AccessControl) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns whether an id correspond to a registered operation. This\n     * includes both Pending, Ready and Done operations.\n     */\n    function isOperation(bytes32 id) public view virtual returns (bool) {\n        return getTimestamp(id) > 0;\n    }\n\n    /**\n     * @dev Returns whether an operation is pending or not. Note that a \"pending\" operation may also be \"ready\".\n     */\n    function isOperationPending(bytes32 id) public view virtual returns (bool) {\n        return getTimestamp(id) > _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Returns whether an operation is ready for execution. Note that a \"ready\" operation is also \"pending\".\n     */\n    function isOperationReady(bytes32 id) public view virtual returns (bool) {\n        uint256 timestamp = getTimestamp(id);\n        return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp;\n    }\n\n    /**\n     * @dev Returns whether an operation is done or not.\n     */\n    function isOperationDone(bytes32 id) public view virtual returns (bool) {\n        return getTimestamp(id) == _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Returns the timestamp at which an operation becomes ready (0 for\n     * unset operations, 1 for done operations).\n     */\n    function getTimestamp(bytes32 id) public view virtual returns (uint256) {\n        return _timestamps[id];\n    }\n\n    /**\n     * @dev Returns the minimum delay for an operation to become valid.\n     *\n     * This value can be changed by executing an operation that calls `updateDelay`.\n     */\n    function getMinDelay() public view virtual returns (uint256) {\n        return _minDelay;\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a single\n     * transaction.\n     */\n    function hashOperation(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32) {\n        return keccak256(abi.encode(target, value, data, predecessor, salt));\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a batch of\n     * transactions.\n     */\n    function hashOperationBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32) {\n        return keccak256(abi.encode(targets, values, payloads, predecessor, salt));\n    }\n\n    /**\n     * @dev Schedule an operation containing a single transaction.\n     *\n     * Emits {CallSalt} if salt is nonzero, and {CallScheduled}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function schedule(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\n        _schedule(id, delay);\n        emit CallScheduled(id, 0, target, value, data, predecessor, delay);\n        if (salt != bytes32(0)) {\n            emit CallSalt(id, salt);\n        }\n    }\n\n    /**\n     * @dev Schedule an operation containing a batch of transactions.\n     *\n     * Emits {CallSalt} if salt is nonzero, and one {CallScheduled} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function scheduleBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        require(targets.length == values.length, \"TimelockController: length mismatch\");\n        require(targets.length == payloads.length, \"TimelockController: length mismatch\");\n\n        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);\n        _schedule(id, delay);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            emit CallScheduled(id, i, targets[i], values[i], payloads[i], predecessor, delay);\n        }\n        if (salt != bytes32(0)) {\n            emit CallSalt(id, salt);\n        }\n    }\n\n    /**\n     * @dev Schedule an operation that is to become valid after a given delay.\n     */\n    function _schedule(bytes32 id, uint256 delay) private {\n        require(!isOperation(id), \"TimelockController: operation already scheduled\");\n        require(delay >= getMinDelay(), \"TimelockController: insufficient delay\");\n        _timestamps[id] = block.timestamp + delay;\n    }\n\n    /**\n     * @dev Cancel an operation.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'canceller' role.\n     */\n    function cancel(bytes32 id) public virtual onlyRole(CANCELLER_ROLE) {\n        require(isOperationPending(id), \"TimelockController: operation cannot be cancelled\");\n        delete _timestamps[id];\n\n        emit Cancelled(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a single transaction.\n     *\n     * Emits a {CallExecuted} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    // This function can reenter, but it doesn't pose a risk because _afterCall checks that the proposal is pending,\n    // thus any modifications to the operation during reentrancy should be caught.\n    // slither-disable-next-line reentrancy-eth\n    function execute(\n        address target,\n        uint256 value,\n        bytes calldata payload,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        bytes32 id = hashOperation(target, value, payload, predecessor, salt);\n\n        _beforeCall(id, predecessor);\n        _execute(target, value, payload);\n        emit CallExecuted(id, 0, target, value, payload);\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a batch of transactions.\n     *\n     * Emits one {CallExecuted} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    // This function can reenter, but it doesn't pose a risk because _afterCall checks that the proposal is pending,\n    // thus any modifications to the operation during reentrancy should be caught.\n    // slither-disable-next-line reentrancy-eth\n    function executeBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        require(targets.length == values.length, \"TimelockController: length mismatch\");\n        require(targets.length == payloads.length, \"TimelockController: length mismatch\");\n\n        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);\n\n        _beforeCall(id, predecessor);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            address target = targets[i];\n            uint256 value = values[i];\n            bytes calldata payload = payloads[i];\n            _execute(target, value, payload);\n            emit CallExecuted(id, i, target, value, payload);\n        }\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Execute an operation's call.\n     */\n    function _execute(address target, uint256 value, bytes calldata data) internal virtual {\n        (bool success, ) = target.call{value: value}(data);\n        require(success, \"TimelockController: underlying transaction reverted\");\n    }\n\n    /**\n     * @dev Checks before execution of an operation's calls.\n     */\n    function _beforeCall(bytes32 id, bytes32 predecessor) private view {\n        require(isOperationReady(id), \"TimelockController: operation is not ready\");\n        require(predecessor == bytes32(0) || isOperationDone(predecessor), \"TimelockController: missing dependency\");\n    }\n\n    /**\n     * @dev Checks after execution of an operation's calls.\n     */\n    function _afterCall(bytes32 id) private {\n        require(isOperationReady(id), \"TimelockController: operation is not ready\");\n        _timestamps[id] = _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Changes the minimum timelock duration for future operations.\n     *\n     * Emits a {MinDelayChange} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the timelock itself. This can only be achieved by scheduling and later executing\n     * an operation where the timelock is the target and the data is the ABI-encoded call to this function.\n     */\n    function updateDelay(uint256 newDelay) external virtual {\n        require(msg.sender == address(this), \"TimelockController: caller must be timelock\");\n        emit MinDelayChange(_minDelay, newDelay);\n        _minDelay = newDelay;\n    }\n\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     */\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    /**\n     * @dev See {IERC1155Receiver-onERC1155Received}.\n     */\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    /**\n     * @dev See {IERC1155Receiver-onERC1155BatchReceived}.\n     */\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/utils/Address.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"

    },

    "src/interfaces/IVault.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.15;\n\n/**\n * @title IVault\n *\n * @author Fujidao Labs\n *\n * @notice Defines the interface for vaults extending from IERC4326.\n */\n\nimport {IERC4626} from \"openzeppelin-contracts/contracts/interfaces/IERC4626.sol\";\nimport {ILendingProvider} from \"./ILendingProvider.sol\";\nimport {IFujiOracle} from \"./IFujiOracle.sol\";\n\ninterface IVault is IERC4626 {\n  /**\n   * @dev Emit when borrow action occurs.\n   *\n   * @param sender who calls {IVault-borrow}\n   * @param receiver of the borrowed 'debt' amount\n   * @param owner who will incur the debt\n   * @param debt amount\n   * @param shares amount of 'debtShares' received\n   */\n  event Borrow(\n    address indexed sender,\n    address indexed receiver,\n    address indexed owner,\n    uint256 debt,\n    uint256 shares\n  );\n\n  /**\n   * @dev Emit when payback action occurs.\n   *\n   * @param sender address who calls {IVault-payback}\n   * @param owner address whose debt will be reduced\n   * @param debt amount\n   * @param shares amound of 'debtShares' burned\n   */\n  event Payback(address indexed sender, address indexed owner, uint256 debt, uint256 shares);\n\n  /**\n   * @dev Emit when the vault is initialized\n   *\n   * @param initializer of this vault\n   *\n   */\n  event VaultInitialized(address initializer);\n\n  /**\n   * @dev Emit when the oracle address is changed.\n   *\n   * @param newOracle the new oracle address\n   */\n  event OracleChanged(IFujiOracle newOracle);\n\n  /**\n   * @dev Emit when the available providers for the vault change.\n   *\n   * @param newProviders the new providers available\n   */\n  event ProvidersChanged(ILendingProvider[] newProviders);\n\n  /**\n   * @dev Emit when the active provider is changed.\n   *\n   * @param newActiveProvider the new active provider\n   */\n  event ActiveProviderChanged(ILendingProvider newActiveProvider);\n\n  /**\n   * @dev Emit when the vault is rebalanced.\n   *\n   * @param assets amount to be rebalanced\n   * @param debt amount to be rebalanced\n   * @param from provider\n   * @param to provider\n   */\n  event VaultRebalance(uint256 assets, uint256 debt, address indexed from, address indexed to);\n\n  /**\n   * @dev Emit when the max LTV is changed.\n   * See factors: https://github.com/Fujicracy/CrossFuji/tree/main/packages/protocol#readme.\n   *\n   * @param newMaxLtv the new max LTV\n   */\n  event MaxLtvChanged(uint256 newMaxLtv);\n\n  /**\n   * @dev Emit when the liquidation ratio is changed.\n   * See factors: https://github.com/Fujicracy/CrossFuji/tree/main/packages/protocol#readme.\n   *\n   * @param newLiqRatio the new liquidation ratio\n   */\n  event LiqRatioChanged(uint256 newLiqRatio);\n\n  /**\n   * @dev Emit when the minumum amount is changed.\n   *\n   * @param newMinAmount the new minimum amount\n   */\n  event MinAmountChanged(uint256 newMinAmount);\n\n  /**\n   * @dev Emit when the deposit cap is changed.\n   *\n   * @param newDepositCap the new deposit cap of this vault\n   */\n  event DepositCapChanged(uint256 newDepositCap);\n\n  /*///////////////////////////\n    Asset management functions\n  //////////////////////////*/\n\n  /**\n   * @notice Returns the amount of assets owned by `owner`.\n   *\n   * @param owner to check balance\n   *\n   * @dev This method avoids having to do external conversions from shares to\n   * assets, since {IERC4626-balanceOf} returns shares.\n   */\n  function balanceOfAsset(address owner) external view returns (uint256 assets);\n\n  /*///////////////////////////\n    Debt management functions\n  //////////////////////////*/\n\n  /**\n   * @notice Returns the decimals for 'debtAsset' of this vault.\n   *\n   * @dev Requirements:\n   * - Must match the 'debtAsset' decimals in ERC20 token.\n   * - Must return zero in a {YieldVault}.\n   */\n  function debtDecimals() external view returns (uint8);\n\n  /**\n   * @notice Returns the address of the underlying token used as debt in functions\n   * `borrow()`, and `payback()`. Based on {IERC4626-asset}.\n   *\n   * @dev Requirements:\n   * - Must be an ERC-20 token contract.\n   * - Must not revert.\n   * - Must return zero in a {YieldVault}.\n   */\n  function debtAsset() external view returns (address);\n\n  /**\n   * @notice Returns the amount of debt owned by `owner`.\n   *\n   * @param owner to check balance\n   */\n  function balanceOfDebt(address owner) external view returns (uint256 debt);\n\n  /**\n   * @notice Returns the amount of `debtShares` owned by `owner`.\n   *\n   * @param owner to check balance\n   */\n  function balanceOfDebtShares(address owner) external view returns (uint256 debtShares);\n\n  /**\n   * @notice Returns the total amount of the underlying debt asset\n   * that is “managed” by this vault. Based on {IERC4626-totalAssets}.\n   *\n   * @dev Requirements:\n   * - Must account for any compounding occuring from yield or interest accrual.\n   * - Must be inclusive of any fees that are charged against assets in the Vault.\n   * - Must not revert.\n   * - Must return zero in a {YieldVault}.\n   */\n  function totalDebt() external view returns (uint256);\n\n  /**\n   * @notice Returns the amount of shares this vault would exchange for the amount\n   * of debt assets provided. Based on {IERC4626-convertToShares}.\n   *\n   * @param debt to convert into `debtShares`\n   *\n   * @dev Requirements:\n   * - Must not be inclusive of any fees that are charged against assets in the Vault.\n   * - Must not show any variations depending on the caller.\n   * - Must not reflect slippage or other on-chain conditions, when performing the actual exchange.\n   * - Must not revert.\n   *\n   * NOTE: This calculation MAY not reflect the “per-user” price-per-share, and instead Must reflect the\n   * “average-user’s” price-per-share, meaning what the average user Must expect to see when exchanging to and\n   * from.\n   */\n  function convertDebtToShares(uint256 debt) external view returns (uint256 shares);\n\n  /**\n   * @notice Returns the amount of debt assets that this vault would exchange for the amount\n   * of shares provided. Based on {IERC4626-convertToAssets}.\n   *\n   * @param shares amount to convert into `debt`\n   *\n   * @dev Requirements:\n   * - Must not be inclusive of any fees that are charged against assets in the Vault.\n   * - Must not show any variations depending on the caller.\n   * - Must not reflect slippage or other on-chain conditions, when performing the actual exchange.\n   * - Must not revert.\n   *\n   * NOTE: This calculation MAY not reflect the “per-user” price-per-share, and instead must reflect the\n   * “average-user’s” price-per-share, meaning what the average user Must expect to see when exchanging to and\n   * from.\n   */\n  function convertToDebt(uint256 shares) external view returns (uint256 debt);\n\n  /**\n   * @notice Returns the maximum amount of the debt asset that can be borrowed for the `owner`,\n   * through a borrow call.\n   *\n   * @param owner to check\n   *\n   * @dev Requirements:\n   * - Must return a limited value if receiver is subject to some borrow limit.\n   * - Must return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be borrowed.\n   * - Must not revert.\n   */\n  function maxBorrow(address owner) external view returns (uint256 debt);\n\n  /**\n   * @notice Returns the maximum amount of debt that can be payback by the `borrower`.\n   *\n   * @param owner to check\n   *\n   * @dev Requirements:\n   * - Must not revert.\n   */\n  function maxPayback(address owner) external view returns (uint256 debt);\n\n  /**\n   * @notice Returns the maximum amount of debt shares that can be \"minted-for-borrowing\" by the `borrower`.\n   *\n   * @param owner to check\n   *\n   * @dev Requirements:\n   * - Must not revert.\n   */\n  function maxMintDebt(address owner) external view returns (uint256 shares);\n\n  /**\n   * @notice Returns the maximum amount of debt shares that can be \"burned-for-payback\" by the `borrower`.\n   *\n   * @param owner to check\n   *\n   * @dev Requirements:\n   * - Must not revert.\n   */\n  function maxBurnDebt(address owner) external view returns (uint256 shares);\n\n  /**\n   * @notice Returns the amount of `debtShares` that borrowing `debt` amount will generate.\n   *\n   * @param debt amount to check\n   *\n   * @dev Requirements:\n   * - Must not revert.\n   */\n  function previewBorrow(uint256 debt) external view returns (uint256 shares);\n\n  /**\n   * @notice Returns the amount of debt that borrowing `debtShares` amount will generate.\n   *\n   * @param shares of debt to check\n   *\n   * @dev Requirements:\n   * - Must not revert.\n   */\n  function previewMintDebt(uint256 shares) external view returns (uint256 debt);\n\n  /**\n   * @notice Returns the amount of `debtShares` that will be burned by paying back\n   * `debt` amount.\n   *\n   * @param debt to check\n   *\n   * @dev Requirements:\n   * - Must not revert.\n   */\n  function previewPayback(uint256 debt) external view returns (uint256 shares);\n\n  /**\n   * @notice Returns the amount of debt asset that will be pulled from user, if `debtShares` are\n   * burned to payback.\n   *\n   * @param debt to check\n   *\n   * @dev Requirements:\n   * - Must not revert.\n   */\n  function previewBurnDebt(uint256 shares) external view returns (uint256 debt);\n\n  /**\n   * @notice Perform a borrow action. Function inspired on {IERC4626-deposit}.\n   *\n   * @param debt amount\n   * @param receiver of the `debt` amount\n   * @param owner who will incur the `debt` amount\n   *\n   * * @dev Mints debtShares to owner by taking a loan of exact amount of underlying tokens.\n   * Requirements:\n   * - Must emit the Borrow event.\n   * - Must revert if owner does not own sufficient collateral to back debt.\n   * - Must revert if caller is not owner or permissioned operator to act on owner behalf.\n   */\n  function borrow(uint256 debt, address receiver, address owner) external returns (uint256 shares);\n\n  /**\n   * @notice Perform a borrow action by minting `debtShares`.\n   *\n   * @param shares of debt to mint\n   * @param receiver of the borrowed amount\n   * @param owner who will incur the `debt` and whom `debtShares` will be accounted\n   *\n   * * @dev Mints `debtShares` to `owner`.\n   * Requirements:\n   * - Must emit the Borrow event.\n   * - Must revert if owner does not own sufficient collateral to back debt.\n   * - Must revert if caller is not owner or permissioned operator to act on owner behalf.\n   */\n  function mintDebt(\n    uint256 shares,\n    address receiver,\n    address owner\n  )\n    external\n    returns (uint256 debt);\n\n  /**\n   * @notice Burns `debtShares` to `receiver` by paying back loan with exact amount of underlying tokens.\n   *\n   * @param debt amount to payback\n   * @param receiver to whom debt amount is being paid back\n   *\n   * @dev Implementations will require pre-erc20-approval of the underlying debt token.\n   * Requirements:\n   * - Must emit a Payback event.\n   */\n  function payback(uint256 debt, address receiver) external returns (uint256 shares);\n\n  /**\n   * @notice Burns `debtShares` to `owner` by paying back loan by specifying debt shares.\n   *\n   * @param shares of debt to payback\n   * @param owner to whom debt amount is being paid back\n   *\n   * @dev Implementations will require pre-erc20-approval of the underlying debt token.\n   * Requirements:\n   * - Must emit a Payback event.\n   */\n  function burnDebt(uint256 shares, address owner) external returns (uint256 debt);\n\n  /*///////////////////\n    General functions\n  ///////////////////*/\n\n  /**\n   * @notice Returns the active provider of this vault.\n   */\n  function getProviders() external view returns (ILendingProvider[] memory);\n  /**\n   * @notice Returns the active provider of this vault.\n   */\n  function activeProvider() external view returns (ILendingProvider);\n\n  /*/////////////////////////\n     Rebalancing Function\n  ////////////////////////*/\n\n  /**\n   * @notice Performs rebalancing of vault by moving funds across providers.\n   *\n   * @param assets amount of this vault to be rebalanced\n   * @param debt amount of this vault to be rebalanced (Note: pass zero if this is a {YieldVault})\n   * @param from provider\n   * @param to provider\n   * @param fee expected from rebalancing operation\n   * @param setToAsActiveProvider boolean\n   *\n   * @dev Requirements:\n   * - Must check providers `from` and `to` are valid.\n   * - Must be called from a {RebalancerManager} contract that makes all proper checks.\n   * - Must revert if caller is not an approved rebalancer.\n   * - Must emit the VaultRebalance event.\n   * - Must check `fee` is a reasonable amount.\n   */\n  function rebalance(\n    uint256 assets,\n    uint256 debt,\n    ILendingProvider from,\n    ILendingProvider to,\n    uint256 fee,\n    bool setToAsActiveProvider\n  )\n    external\n    returns (bool);\n\n  /*/////////////////////////\n     Liquidation Functions\n  /////////////////////////*/\n\n  /**\n   * @notice Returns the current health factor of 'owner'.\n   *\n   * @param owner to get health factor\n   *\n   * @dev Requirements:\n   * - Must return type(uint254).max when 'owner' has no debt.\n   * - Must revert in {YieldVault}.\n   *\n   * 'healthFactor' is scaled up by 1e18. A value below 1e18 means 'owner' is eligable for liquidation.\n   * See factors: https://github.com/Fujicracy/CrossFuji/tree/main/packages/protocol#readme.\n   */\n  function getHealthFactor(address owner) external returns (uint256 healthFactor);\n\n  /**\n   * @notice Returns the liquidation close factor based on 'owner's' health factor.\n   *\n   * @param owner of debt position\n   *\n   * @dev Requirements:\n   * - Must return zero if `owner` is not liquidatable.\n   * - Must revert in {YieldVault}.\n   */\n  function getLiquidationFactor(address owner) external returns (uint256 liquidationFactor);\n\n  /**\n   * @notice Performs liquidation of an unhealthy position, meaning a 'healthFactor' below 100.\n   *\n   * @param owner to be liquidated\n   * @param receiver of the collateral shares of liquidation\n   *\n   * @dev Requirements:\n   * - Must revert if caller is not an approved liquidator.\n   * - Must revert if 'owner' is not liquidatable.\n   * - Must emit the Liquidation event.\n   * - Must liquidate 50% of 'owner' debt when: 100 >= 'healthFactor' > 95.\n   * - Must liquidate 100% of 'owner' debt when: 95 > 'healthFactor'.\n   * - Must revert in {YieldVault}.\n   *\n   * WARNING! It is liquidator's responsability to check if liquidation is profitable.\n   */\n  function liquidate(address owner, address receiver) external returns (uint256 gainedShares);\n\n  /*/////////////////////\n     Setter functions \n  ////////////////////*/\n\n  /**\n   * @notice Sets the lists of providers of this vault.\n   *\n   * @param providers address array\n   *\n   * @dev Requirements:\n   * - Must not contain zero addresses.\n   */\n  function setProviders(ILendingProvider[] memory providers) external;\n\n  /**\n   * @notice Sets the active provider for this vault.\n   *\n   * @param activeProvider address\n   *\n   * @dev Requirements:\n   * - Must be a provider previously set by `setProviders()`.\n   * - Must be called from a timelock contract.\n   *\n   * WARNING! Changing active provider without a `rebalance()` call\n   * can result in denial of service for vault users.\n   */\n  function setActiveProvider(ILendingProvider activeProvider) external;\n\n  /**\n   * @notice Sets the minimum amount for: `deposit()`, `mint()` and borrow()`.\n   *\n   * @param amount to be as minimum.\n   */\n  function setMinAmount(uint256 amount) external;\n}\n"

    },

    "src/interfaces/IPausableVault.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.15;\n\n/**\n * @title IPausableVault\n *\n * @author Fujidao Labs\n *\n * @notice Defines the interface {PausableVault} contract.\n */\n\ninterface IPausableVault {\n  enum VaultActions {\n    Deposit,\n    Withdraw,\n    Borrow,\n    Payback\n  }\n\n  /**\n   * @dev Emit when pause of `action` is triggered by `account`.\n   *\n   * @param account who called the pause\n   * @param action being paused\n   */\n  event Paused(address account, VaultActions action);\n  /**\n   * @dev Emit when the pause of `action` is lifted by `account`.\n   *\n   * @param account who called the unpause\n   * @param action being paused\n   */\n  event Unpaused(address account, VaultActions action);\n  /**\n   * emit\n   * @dev Emitted when forced pause all `VaultActions` triggered by `account`.\n   *\n   * @param account who called all pause\n   */\n  event PausedForceAll(address account);\n  /**\n   * @dev Emit when forced pause is lifted to all `VaultActions` by `account`.\n   *\n   * @param account who called the all unpause\n   */\n  event UnpausedForceAll(address account);\n\n  /**\n   * @notice Returns true if the `action` in contract is paused, otherwise false.\n   *\n   * @param action to check pause status\n   */\n  function paused(VaultActions action) external view returns (bool);\n\n  /**\n   * @notice Force pause state for all `VaultActions`.\n   *\n   * @dev Requirements:\n   * - Must be implemented in child contract with access restriction.\n   */\n  function pauseForceAll() external;\n\n  /**\n   * @notice Force unpause state for all `VaultActions`.\n   *\n   * @dev Requirements:\n   * - Must be implemented in child contract with access restriction.\n   */\n  function unpauseForceAll() external;\n\n  /**\n   * @notice Set paused state for `action` of this vault.\n   *\n   * @param action Enum: 0-deposit, 1-withdraw, 2-borrow, 3-payback\n   *\n   * Requirements:\n   * - The `action` in contract must not be unpaused.\n   * - Must be implemented in child contract with access restriction.\n   */\n  function pause(VaultActions action) external;\n\n  /**\n   * @notice Set unpause state for `action` of this vault.\n   *\n   * @param action Enum: 0-deposit, 1-withdraw, 2-borrow, 3-payback\n   *\n   * @dev Requirements:\n   * - The `action` in contract must be paused.\n   * - Must be implemented in child contract with access restriction.\n   */\n  function unpause(VaultActions action) external;\n}\n"

    },

    "src/interfaces/IVaultFactory.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.15;\n\n/**\n * @title IVaultFactory\n *\n * @author Fujidao Labs\n *\n * @notice Vault factory deployment interface.\n */\n\ninterface IVaultFactory {\n  /**\n   * @notice Deploys a new type of vault.\n   *\n   * @param deployData The encoded data containing constructor arguments.\n   *\n   * @dev Requirements:\n   * - Must be called from {Chief} contract only.\n   */\n  function deployVault(bytes calldata deployData) external returns (address vault);\n\n  /**\n   * @notice Returns the address for a specific salt.\n   *\n   * @param data bytes32 used as salt in vault deployment\n   */\n  function configAddress(bytes32 data) external returns (address vault);\n}\n"

    },

    "src/interfaces/IChief.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.15;\n\n/**\n * @title IChief\n *\n * @author Fujidao Labs\n *\n * @notice Defines interface for {Chief} access control operations.\n */\n\nimport {IAccessControl} from \"openzeppelin-contracts/contracts/access/IAccessControl.sol\";\n\ninterface IChief is IAccessControl {\n  /// @notice Returns the timelock address of the FujiV2 system.\n  function timelock() external view returns (address);\n\n  /// @notice Returns the address mapper contract address of the FujiV2 system.\n  function addrMapper() external view returns (address);\n\n  /**\n   * @notice Returns true if `vault` is active.\n   *\n   * @param vault to check status\n   */\n  function isVaultActive(address vault) external view returns (bool);\n\n  /**\n   * @notice Returns true if `flasher` is an allowed {IFlasher}.\n   *\n   * @param flasher address to check\n   */\n  function allowedFlasher(address flasher) external view returns (bool);\n\n  /**\n   * @notice Returns true if `swapper` is an allowed {ISwapper}.\n   *\n   * @param swapper address to check\n   */\n  function allowedSwapper(address swapper) external view returns (bool);\n}\n"

    },

    "src/helpers/AddrMapper.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.15;\n\n/**\n * @title AddrMapper\n *\n * @author Fujidao Labs\n *\n * @notice Contract that stores and returns addresses mappings\n * Required for getting contract addresses for some providers and flashloan providers.\n */\n\nimport {SystemAccessControl} from \"../access/SystemAccessControl.sol\";\nimport {IAddrMapper} from \"../interfaces/IAddrMapper.sol\";\n\ncontract AddrMapper is IAddrMapper, SystemAccessControl {\n  // provider name => key address => returned address\n  // (e.g. Compound_V2 => public erc20 => protocol Token)\n  mapping(string => mapping(address => address)) private _addrMapping;\n  // provider name => key1 address => key2 address => returned address\n  // (e.g. Compound_V3 => collateral erc20 => borrow erc20 => Protocol market)\n  mapping(string => mapping(address => mapping(address => address))) private _addrNestedMapping;\n\n  string[] private _providerNames;\n\n  mapping(string => bool) private _isProviderNameAdded;\n\n  constructor(address chief) SystemAccessControl(chief) {}\n\n  /**\n   * @notice Returns a list of all the providers who have a mapping.\n   */\n  function getProviders() public view returns (string[] memory) {\n    return _providerNames;\n  }\n\n  /// @inheritdoc IAddrMapper\n  function getAddressMapping(\n    string memory providerName,\n    address inputAddr\n  )\n    external\n    view\n    override\n    returns (address)\n  {\n    return _addrMapping[providerName][inputAddr];\n  }\n\n  /// @inheritdoc IAddrMapper\n  function getAddressNestedMapping(\n    string memory providerName,\n    address inputAddr1,\n    address inputAddr2\n  )\n    external\n    view\n    override\n    returns (address)\n  {\n    return _addrNestedMapping[providerName][inputAddr1][inputAddr2];\n  }\n\n  /// @inheritdoc IAddrMapper\n  function setMapping(\n    string memory providerName,\n    address keyAddr,\n    address returnedAddr\n  )\n    public\n    override\n    onlyTimelock\n  {\n    if (!_isProviderNameAdded[providerName]) {\n      _isProviderNameAdded[providerName] = true;\n      _providerNames.push(providerName);\n    }\n    _addrMapping[providerName][keyAddr] = returnedAddr;\n    address[] memory inputAddrs = new address[](1);\n    inputAddrs[0] = keyAddr;\n    emit MappingChanged(inputAddrs, returnedAddr);\n  }\n\n  /// @inheritdoc IAddrMapper\n  function setNestedMapping(\n    string memory providerName,\n    address keyAddr1,\n    address keyAddr2,\n    address returnedAddr\n  )\n    public\n    override\n    onlyTimelock\n  {\n    if (!_isProviderNameAdded[providerName]) {\n      _isProviderNameAdded[providerName] = true;\n      _providerNames.push(providerName);\n    }\n    _addrNestedMapping[providerName][keyAddr1][keyAddr2] = returnedAddr;\n    address[] memory inputAddrs = new address[](2);\n    inputAddrs[0] = keyAddr1;\n    inputAddrs[1] = keyAddr2;\n    emit MappingChanged(inputAddrs, returnedAddr);\n  }\n}\n"

    },

    "src/access/CoreRoles.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.15;\n\n/**\n * @title CoreRoles\n *\n * @author Fujidao Labs\n *\n * @notice System definition of roles used across FujiV2 contracts.\n */\n\ncontract CoreRoles {\n  bytes32 public constant HOUSE_KEEPER_ROLE = keccak256(\"HOUSE_KEEPER_ROLE\");\n\n  bytes32 public constant REBALANCER_ROLE = keccak256(\"REBALANCER_ROLE\");\n  bytes32 public constant HARVESTER_ROLE = keccak256(\"HARVESTER_ROLE\");\n  bytes32 public constant LIQUIDATOR_ROLE = keccak256(\"LIQUIDATOR_ROLE\");\n\n  bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n  bytes32 public constant UNPAUSER_ROLE = keccak256(\"UNPAUSER_ROLE\");\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/access/IAccessControl.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/utils/Context.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/utils/Strings.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155Receiver.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/interfaces/IERC4626.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (interfaces/IERC4626.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\nimport \"../token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @dev Interface of the ERC4626 \"Tokenized Vault Standard\", as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n *\n * _Available since v4.7._\n */\ninterface IERC4626 is IERC20, IERC20Metadata {\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed sender,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is “managed” by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n}\n"

    },

    "src/interfaces/ILendingProvider.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.15;\n\nimport {IVault} from \"./IVault.sol\";\n\n/**\n * @title ILendingProvider\n *\n * @author Fujidao Labs\n *\n * @notice  Defines the interface for core engine to perform operations at lending providers.\n *\n * @dev Functions are intended to be called in the context of a Vault via delegateCall,\n * except indicated.\n */\n\ninterface ILendingProvider {\n  function providerName() external view returns (string memory);\n  /**\n   * @notice Returns the operator address that requires ERC20-approval for vault operations.\n   *\n   * @param keyAsset address to inquiry operator\n   * @param asset address of the calling vault\n   * @param debtAsset address of the calling vault. Note: if {YieldVault} this will be address(0).\n   *\n   * @dev Provider implementations may or not require all 3 inputs.\n   */\n  function approvedOperator(\n    address keyAsset,\n    address asset,\n    address debtAsset\n  )\n    external\n    view\n    returns (address operator);\n\n  /**\n   * @notice Performs deposit operation at lending provider on behalf vault.\n   *\n   * @param amount amount to deposit\n   * @param vault IVault calling this function\n   *\n   * @dev Requirements:\n   * - This function should be delegate called in the context of a `vault`.\n   */\n  function deposit(uint256 amount, IVault vault) external returns (bool success);\n\n  /**\n   * @notice Performs borrow operation at lending provider on behalf vault.\n   *\n   * @param amount amount to borrow\n   * @param vault IVault calling this function\n   *\n   * @dev Requirements:\n   * - This function should be delegate called in the context of a `vault`.\n   */\n  function borrow(uint256 amount, IVault vault) external returns (bool success);\n\n  /**\n   * @notice Performs withdraw operation at lending provider on behalf vault.\n   * @param amount amount to withdraw\n   * @param vault IVault calling this function.\n   *\n   * @dev Requirements:\n   * - This function should be delegate called in the context of a `vault`.\n   */\n  function withdraw(uint256 amount, IVault vault) external returns (bool success);\n\n  /**\n   *\n   * @notice Performs payback operation at lending provider on behalf vault.\n   *\n   * @param amount amount to payback\n   * @param vault IVault calling this function.\n   *\n   * @dev Requirements:\n   * - This function should be delegate called in the context of a `vault`.\n   * - Check there is erc20-approval to `approvedOperator` by the `vault` prior to call.\n   */\n  function payback(uint256 amount, IVault vault) external returns (bool success);\n\n  /**\n   * @notice Returns DEPOSIT balance of 'user' at lending provider.\n   *\n   * @param user address whom balance is needed\n   * @param vault IVault required by some specific providers with multi-markets, otherwise pass address(0).\n   *\n   * @dev Requirements:\n   * - Must not require Vault context.\n   */\n  function getDepositBalance(address user, IVault vault) external view returns (uint256 balance);\n\n  /**\n   * @notice Returns BORROW balance of 'user' at lending provider.\n   *\n   * @param user address whom balance is needed\n   * @param vault IVault required by some specific providers with multi-markets, otherwise pass address(0).\n   *\n   * @dev Requirements:\n   * - Must not require Vault context.\n   */\n  function getBorrowBalance(address user, IVault vault) external view returns (uint256 balance);\n\n  /**\n   * @notice Returns the latest SUPPLY annual percent rate (APR) at lending provider.\n   *\n   * @param vault IVault required by some specific providers with multi-markets, otherwise pass address(0)\n   *\n   * @dev Requirements:\n   * - Must return the rate in ray units (1e27)\n   * Example 8.5% APR = 0.085 x 1e27 = 85000000000000000000000000\n   * - Must not require Vault context.\n   */\n  function getDepositRateFor(IVault vault) external view returns (uint256 rate);\n\n  /**\n   * @notice Returns the latest BORROW annual percent rate (APR) at lending provider.\n   *\n   * @param vault IVault required by some specific providers with multi-markets, otherwise pass address(0)\n   *\n   * @dev Requirements:\n   * - Must return the rate in ray units (1e27)\n   * Example 8.5% APR = 0.085 x 1e27 = 85000000000000000000000000\n   * - Must not require Vault context.\n   */\n  function getBorrowRateFor(IVault vault) external view returns (uint256 rate);\n}\n"

    },

    "src/interfaces/IFujiOracle.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.15;\n\n/**\n * @title IFujiOracle\n *\n * @author Fujidao Labs\n *\n * @notice Defines the interface of the {FujiOracle}.\n */\n\ninterface IFujiOracle {\n  /**\n   * @dev Emit when a change in price feed address is done for an `asset`.\n   *\n   * @param asset address\n   * @param newPriceFeedAddress that returns USD price from Chainlink\n   */\n  event AssetPriceFeedChanged(address asset, address newPriceFeedAddress);\n\n  /**\n   * @notice Returns the exchange rate between two assets, with price oracle given in\n   * specified `decimals`.\n   *\n   * @param currencyAsset to be used, zero-address for USD\n   * @param commodityAsset to be used, zero-address for USD\n   * @param decimals  of the desired price output\n   *\n   * @dev Price format is defined as: (amount of currencyAsset per unit of commodityAsset Exchange Rate).\n   * Requirements:\n   * - Must check that both `currencyAsset` and `commodityAsset` are set in\n   *   usdPriceFeeds, otherwise return zero.\n   */\n  function getPriceOf(\n    address currencyAsset,\n    address commodityAsset,\n    uint8 decimals\n  )\n    external\n    view\n    returns (uint256);\n}\n"

    },

    "src/access/SystemAccessControl.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.15;\n\n/**\n * @title SystemAccessControl\n *\n * @author Fujidao Labs\n *\n * @notice Abstract contract that should be inherited by contract implementations that\n * call the {Chief} contract for access control checks.\n */\n\nimport {IChief} from \"../interfaces/IChief.sol\";\nimport {CoreRoles} from \"./CoreRoles.sol\";\n\ncontract SystemAccessControl is CoreRoles {\n  /// @dev Custom Errors\n  error SystemAccessControl__hasRole_missingRole(address caller, bytes32 role);\n  error SystemAccessControl__onlyTimelock_callerIsNotTimelock();\n  error SystemAccessControl__onlyHouseKeeper_notHouseKeeper();\n\n  IChief public immutable chief;\n\n  /**\n   * @dev Modifier that checks `caller` has `role`.\n   */\n  modifier hasRole(address caller, bytes32 role) {\n    if (!chief.hasRole(role, caller)) {\n      revert SystemAccessControl__hasRole_missingRole(caller, role);\n    }\n    _;\n  }\n\n  /**\n   * @dev Modifier that checks `msg.sender` has HOUSE_KEEPER_ROLE.\n   */\n  modifier onlyHouseKeeper() {\n    if (!chief.hasRole(HOUSE_KEEPER_ROLE, msg.sender)) {\n      revert SystemAccessControl__onlyHouseKeeper_notHouseKeeper();\n    }\n    _;\n  }\n\n  /**\n   * @dev Modifier that checks `msg.sender` is the defined `timelock` in {Chief}\n   * contract.\n   */\n  modifier onlyTimelock() {\n    if (msg.sender != chief.timelock()) {\n      revert SystemAccessControl__onlyTimelock_callerIsNotTimelock();\n    }\n    _;\n  }\n\n  /**\n   * @notice Abstract constructor of a new {SystemAccessControl}.\n   *\n   * @param chief_ address\n   *\n   * @dev Requirements:\n   * - Must pass non-zero {Chief} address, that could be checked at child contract.\n   */\n  constructor(address chief_) {\n    chief = IChief(chief_);\n  }\n}\n"

    },

    "src/interfaces/IAddrMapper.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.15;\n\n/**\n * @title IAddrMapper\n *\n * @author Fujidao Labs\n *\n * @notice Defines interface for {AddrMapper} mapping operations.\n */\n\ninterface IAddrMapper {\n  /**\n   * @notice Log a change in address mapping\n   */\n  event MappingChanged(address[] keyAddress, address mappedAddress);\n\n  /**\n   * @notice Returns the address of the underlying token associated with the `keyAddr` for the providerName protocol.\n   *\n   * @param providerName string name of the provider\n   * @param keyAddr address of the token associated with the underlying token\n   */\n  function getAddressMapping(\n    string memory providerName,\n    address keyAddr\n  )\n    external\n    view\n    returns (address returnedAddr);\n\n  /**\n   * @notice Returns the address of the underlying token associated with both `keyAddr1` and `keyAddr2` tokens.\n   *\n   * @param providerName string name of the provider\n   * @param keyAddr1 address of the token (provided as collateral) associated with the underlying token\n   * @param keyAddr2 address of the token (borrowed) associated with the underlying token\n   */\n  function getAddressNestedMapping(\n    string memory providerName,\n    address keyAddr1,\n    address keyAddr2\n  )\n    external\n    view\n    returns (address returnedAddr);\n\n  /**\n   * @notice Sets the mapping of the underlying `returnedAddr` token associated with the `providerName` and the token `keyAddr`.\n   *\n   * @param providerName string name of the provider\n   * @param keyAddr address of the token associated with the underlying token\n   * @param returnedAddr address of the underlying token to be returned by the {IAddrMapper-getAddressMapping}\n   */\n  function setMapping(string memory providerName, address keyAddr, address returnedAddr) external;\n\n  /**\n   * @notice Sets the mapping associated with the `providerName` and both `keyAddr1` (collateral) and `keyAddr2` (borrowed) tokens.\n   *\n   * @param providerName string name of the provider\n   * @param keyAddr1 address of the token provided as collateral\n   * @param keyAddr2 address of the token to be borrowed\n   * @param returnedAddr address of the underlying token to be returned by the {IAddrMapper-getAddressNestedMapping}\n   */\n  function setNestedMapping(\n    string memory providerName,\n    address keyAddr1,\n    address keyAddr2,\n    address returnedAddr\n  )\n    external;\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/utils/math/Math.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"

    },

    "lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"

    }

  },

  "settings": {

    "remappings": [

      "@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/",

      "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",

      "@std/=lib/forge-std/src/",

      "ds-test/=lib/forge-std/lib/ds-test/src/",

      "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",

      "forge-std/=lib/forge-std/src/",

      "nxtp/=lib/nxtp/packages/deployments/contracts/contracts/",

      "openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/",

      "openzeppelin-contracts/=lib/openzeppelin-contracts/",

      "openzeppelin/=lib/openzeppelin-contracts/contracts/"

    ],

    "optimizer": {

      "enabled": true,

      "runs": 200

    },

    "metadata": {

      "bytecodeHash": "ipfs"

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "evmVersion": "london",

    "libraries": {}

  }

}}