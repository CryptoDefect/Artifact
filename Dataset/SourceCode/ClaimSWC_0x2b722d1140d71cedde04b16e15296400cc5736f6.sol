{{

  "language": "Solidity",

  "sources": {

    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     *\n     * _Available since v4.7._\n     */\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     *\n     * _Available since v4.7._\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"

    },

    "contracts/work/Claim.sol": {

      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport {MerkleProof} from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\ninterface IPair {\n    function getReserves() external view returns ( uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast );\n}\n\nstruct Slot0 {\n    // the current price\n    uint160 sqrtPriceX96;\n    // the current tick\n    int24 tick;\n    // the most-recently updated index of the observations array\n    uint16 observationIndex;\n    // the current maximum number of observations that are being stored\n    uint16 observationCardinality;\n    // the next maximum number of observations to store, triggered in observations.write\n    uint16 observationCardinalityNext;\n    // the current protocol fee as a percentage of the swap fee taken on withdrawal\n    // represented as an integer denominator (1/x)%\n    uint8 feeProtocol;\n    // whether the pool is locked\n    bool unlocked;\n}\ninterface IUniswapV3PoolState {\n    function slot0() external view returns(Slot0 memory);\n}\n\ninterface INFT {\n    function ownerOf(uint256 tokenId) external view returns (address);\n}\n\ninterface IBurnable {\n    function burn(uint256 amount) external;\n}\n\ncontract ClaimSWC {\n    /// @notice USDC token address\n    address public constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n    /// @notice WETH token address\n    address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    /// @notice EHT/USDC lp\n    address public constant USDC_WETH = 0x88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640;\n\n    /// @notice  airdrop merkle root\n    address public constant COINBASE = 0xA9D1e08C7793af67e9d92fe308d5697FB81d3E43;\n    /// @notice  nft\n    INFT public constant NFT = INFT(0x9D90669665607F08005CAe4A7098143f554c59EF);\n\n    /// @notice Merkle root of the SWC airdrop\n    bytes32 public immutable merkleRoot;\n\n    /// @notice SWC token address\n    address public immutable swc;\n    /// @notice SWC/ETH lp\n    address public immutable swcEthePair;\n\n    /// @notice snapshot last id\n    uint public immutable snapshotId;\n\n    /// @notice burn start block time\n    uint64 public immutable burnStartBlock;\n    /// @notice burn balnece\n    uint public burnBalance;\n    /// @notice claimed nft id\n    mapping(uint => bool) public claimed;\n    event Claimed(address indexed to, uint indexed nftId);\n\n    /// @notice claimed\n    mapping(address => bool) public claimedMerkle;\n\n    address public owner;\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"only owner\");\n        _;\n    }\n\n    constructor(\n        address _swc,\n        bytes32 _merkleRoot,\n        address _swcEthePair,\n        uint _snapshotId,\n        uint _burnBalance,\n        uint _burnStartBlock\n    ) {\n        swc = _swc;\n        merkleRoot = _merkleRoot;\n        swcEthePair = _swcEthePair;\n        snapshotId = _snapshotId;\n        burnBalance = _burnBalance;\n        burnStartBlock = uint64(block.timestamp + _burnStartBlock);\n        owner = msg.sender;\n    }\n\n    function waiveOwner() external onlyOwner {\n        owner = address(0);\n    }\n\n    function verify(\n        bytes32[] memory proof,\n        address addr,\n        uint256 amount\n    ) public view {\n        require(\n            MerkleProof.verify(\n                proof,\n                merkleRoot, \n                keccak256(bytes.concat(keccak256(abi.encode(addr, amount))))\n            ),\n            \"Invalid proof\"\n        );\n    }\n\n    function getNftAmount(uint _nftAmount) public view returns(uint) {\n        (uint _ethRes, uint _swcRes) = swcPrice();\n        uint _claimAmount;\n        if ( _ethRes == 0 ) {\n            _claimAmount = 1e9 ether;\n        } else {\n            _claimAmount = 1e24 * _swcRes / _ethRes / ethPrice();\n        }\n       \n        if ( _claimAmount > 1e9 ether) _claimAmount = 1e9 ether;\n        return _claimAmount * _nftAmount;\n    }\n\n    function _claim(address _to, uint _nftAmount) internal returns(uint) {\n        uint _claimAmount = getNftAmount(_nftAmount);\n        _safeTransfer(swc, _to, _claimAmount);\n        _safeTransfer(swc, COINBASE, _claimAmount / 100);\n        burnBalance -= _claimAmount;\n        return _claimAmount;\n    }\n\n    function claim(\n        bytes32[] calldata proof,\n        address addr,\n        uint256 nftAmount\n    ) external returns(uint) {\n        require(burnStartBlock >= block.timestamp, \"burn end\");\n        require(claimedMerkle[addr] == false, \"claimed\");\n        verify(proof, addr, nftAmount);\n        claimedMerkle[addr] = true;\n        return _claim(addr, nftAmount);\n    }\n\n\n    function nO(uint _userId) external view returns(address) {\n        return NFT.ownerOf(_userId);\n    }\n\n    function claimAfter(uint[] calldata nftId) external {\n        address _sender = msg.sender;\n        for (uint i = 0; i < nftId.length; i++) {\n            uint _nId = nftId[i];\n            require(NFT.ownerOf(_nId) == _sender, \"not owner\");\n            require(!claimed[_nId] && _nId > snapshotId, \"claimed\");\n            claimed[_nId] = true;\n            \n            emit Claimed(_sender, _nId);\n        }\n        uint _claimAmount = nftId.length * 1e7 ether;\n        _safeTransfer(swc, _sender, _claimAmount);\n        _safeTransfer(swc, COINBASE, _claimAmount / 100);\n    }\n\n    function swcPrice() public view returns(uint, uint) {\n        (uint112 _swcRes, uint112 _ethRes,) = IPair(swcEthePair).getReserves();\n        if (_swcRes == 0 || _ethRes == 0) return (0,0);\n        if (swc > WETH) (_swcRes, _ethRes) = (_ethRes, _swcRes);\n        return (_ethRes , _swcRes);\n    }\n\n    function ethPrice() public view returns(uint) {\n        Slot0 memory _slot0 = IUniswapV3PoolState(USDC_WETH).slot0();\n        return 1e30 / (_slot0.sqrtPriceX96 * 1e6 / 2**96) ** 2;\n    }\n    \n    /// @notice burn SWC\n    function burn() public {\n        require(burnStartBlock < block.timestamp, \"not start\");\n        IBurnable(swc).burn(burnBalance);\n    }\n    \n    /// @notice Upgrade preparation\n    function shift(address token, address to, uint amount) external onlyOwner {\n        _safeTransfer(token, to, amount);\n    }\n\n    function _safeTransfer(address token, address to, uint256 value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"!safeTransfer\");\n    }\n}\n\n\n"

    }

  },

  "settings": {

    "optimizer": {

      "enabled": true,

      "runs": 200

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "libraries": {}

  }

}}