{{

  "language": "Solidity",

  "sources": {

    "contracts/Polls.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity 0.8.23;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n    address private _previousOwner;\r\n    uint256 private _lockTime;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }   \r\n    \r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    \r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n\r\n    function getUnlockTime() public view returns (uint256) {\r\n        return _lockTime;\r\n    }\r\n    \r\n    function getTime() public view returns (uint256) {\r\n        return block.timestamp;\r\n    }\r\n\r\n    function lock(uint256 time) public virtual onlyOwner {\r\n        _previousOwner = _owner;\r\n        _owner = address(0);\r\n        _lockTime = block.timestamp + time;\r\n        emit OwnershipTransferred(_owner, address(0));\r\n    }\r\n    \r\n    function unlock() public virtual {\r\n        require(_previousOwner == msg.sender, \"You don't have permission to unlock\");\r\n        require(block.timestamp > _lockTime , \"Contract is locked until 7 days\");\r\n        emit OwnershipTransferred(_owner, _previousOwner);\r\n        _owner = _previousOwner;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract Polls is Ownable {\r\n\t/* EVENTS  */\r\n\tevent voteCasted(address voter, uint256 pollID, uint256 vote, uint256 weight);\r\n\tevent pollCreated(address creator, uint256 pollID, string description, uint256 votingLength, bool lotteryBounty, uint256 tokensBounty);\r\n\tevent pollStatusUpdate(uint256 pollID, PollStatus status);\r\n\tevent bountyAssigned(uint256 pollID, uint256 numTokens);\r\n\tevent bountyGiven(uint256 pollID);\r\n\r\n\t/* Determine the current state of a poll */\r\n\tenum PollStatus { IN_PROGRESS, ENDED }\r\n\r\n\t/* Determine mechanism to give bounty for a poll */\r\n\tenum BountyMechanism { PROPORTIONAL, LOTTERY }\r\n\r\n\t/* POLL */\r\n\tstruct Poll {\r\n\t\tstring[] options;\r\n\t\tuint256[] optionVotes;\r\n\t\tuint256 optionWinning;\r\n\t\tuint256 expirationTimeInDays;\r\n\t\tstring description;\r\n\t\tPollStatus status;\r\n\t\taddress creator;\r\n\t\taddress[] voters;\r\n\t\tmapping(address => Voter) voterInfo;\r\n\t\tBountyMechanism mechanism;\r\n\t\taddress winner;\r\n\t}\r\n\r\n\t/* VOTER */\r\n\tstruct Voter {\r\n\t\tbool hasVoted;\r\n\t\tuint256 vote;\r\n\t\tuint256 weight;\r\n\t}\r\n\r\n\t/* TOKEN MANAGER */\r\n\tstruct TokenManager {\r\n\t\tuint256 tokenBalance;\r\n\t\tuint256[] participatedPolls;\r\n\t\tmapping(uint256 => uint256) lockedTokens;\r\n\t\tmapping(uint256 => uint256) bountyTokens;\r\n\t}\r\n\r\n\tuint256 public pollCount;\r\n\tuint256 public limit;\r\n\tmapping(uint256 => Poll) public polls;\r\n\tmapping(address => TokenManager) public bank;\r\n\tmapping(uint256 => uint256) public bounties;\r\n\tIERC20 public token;\r\n\r\n\t/* AUTHENTICATION */\r\n    address public master;\r\n\r\n    modifier onlyOwnerOrMaster() {\r\n        require(msg.sender == owner() || msg.sender == master);\r\n        _;\r\n    }\r\n\r\n\tconstructor(address _token, uint256 _limit) {\r\n\t\trequire(_token != address(0) );\r\n\t\ttoken = IERC20(_token);\r\n\t\tlimit = _limit;\r\n\t}\r\n\r\n\t/* AUTHENTICATION OPERATIONS */\r\n\r\n    /**\r\n     *Sets a new master\r\n     */\r\n    function setMaster(address _master) external onlyOwner {\r\n        master = _master;\r\n    }\r\n\r\n\t/* POLL OPERATIONS */\r\n\r\n\t/*\r\n\t * Creates a new poll.\r\n\t * NOTE: _tokensBounty is denominated in *wei*.\r\n\t */\r\n\tfunction createPoll(string calldata _description, uint256 _voteDurationInDays, bool _lotteryBounty, uint256 _tokensBounty) external onlyOwnerOrMaster returns (uint256) {\r\n\t\trequire(_voteDurationInDays > 0);\r\n\t\trequire(token.balanceOf(msg.sender) >= _tokensBounty);\r\n\r\n\t\tuint256 tokensReceived = 0;\r\n\r\n\t\tif (_tokensBounty > 0) {\r\n\t\t\tuint256 initialBalance = token.balanceOf(address(this));\r\n\t\t\trequire(token.transferFrom(msg.sender, address(this), _tokensBounty));\r\n\t\t\tuint256 finalBalance = token.balanceOf(address(this));\r\n\t\t\ttokensReceived = finalBalance - initialBalance;\r\n\t\t}\r\n\r\n\t\tpollCount++;\r\n\r\n\t\tPoll storage curPoll = polls[pollCount];\r\n\t\tcurPoll.creator = owner();\r\n\t\tcurPoll.status = PollStatus.IN_PROGRESS;\r\n\t\tcurPoll.expirationTimeInDays = block.timestamp + _voteDurationInDays * 1 days;\r\n\t\tcurPoll.description = _description;\r\n\r\n\t\tif (_lotteryBounty) {\r\n\t\t\tcurPoll.mechanism = BountyMechanism.LOTTERY;\r\n\t\t} else {\r\n\t\t\tcurPoll.mechanism = BountyMechanism.PROPORTIONAL;\r\n\t\t}\t\t\r\n\r\n\t\temit pollCreated(owner(), pollCount, _description, _voteDurationInDays, _lotteryBounty, tokensReceived);\r\n\r\n\t\tassignBounty(pollCount, tokensReceived);\r\n\r\n\t\treturn pollCount;\r\n\t}\r\n\r\n\t/*\r\n\t * Ends a poll. Only the creator of a given poll can end that poll.\r\n\t */\r\n\tfunction endPoll(uint256 _pollID, bool _force) external onlyOwnerOrMaster validPoll(_pollID) {\r\n\t\trequire(polls[_pollID].status == PollStatus.IN_PROGRESS, \"Poll has already ended.\");\r\n\r\n\t\tif (!_force) {\r\n\t\t\trequire(block.timestamp >= getPollExpirationTime(_pollID), \"Voting period has not expired\");\r\n\t\t}\r\n\r\n\t\t// Assign winning option to the poll\r\n\t\tuint256 winner = 0;\r\n\r\n\t\tfor (uint256 i = 0; i < polls[_pollID].options.length; i++) {\r\n\t\t\tif (polls[_pollID].optionVotes[i] > polls[_pollID].optionVotes[winner]) {\r\n\t\t\t\twinner = i;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tpolls[_pollID].optionWinning = winner;\r\n\t\tpolls[_pollID].status = PollStatus.ENDED;\r\n\r\n\t\tupdateTokenBank(_pollID, false);\r\n\t\tgiveBounty(_pollID);\r\n\r\n\t\temit pollStatusUpdate(_pollID, polls[_pollID].status);\r\n\t}\r\n\r\n\tfunction addOption(uint256 _pollID, string calldata _optionDescription) external onlyOwnerOrMaster validPoll(_pollID) {\r\n\t\trequire(polls[_pollID].voters.length == 0, \"Poll is in progress. It is not possible to add an option at this time.\");\r\n\r\n\t\tpolls[_pollID].options.push(_optionDescription);\r\n\t\tpolls[_pollID].optionVotes.push(0);\r\n\t}\r\n\r\n\tfunction removeOption(uint256 _pollID, uint256 _optionIndex) external onlyOwnerOrMaster validPoll(_pollID) {\r\n\t\trequire(polls[_pollID].voters.length == 0, \"Poll is in progress. It is not possible to remove an option at this time.\");\r\n\r\n\t\tstring[] memory newOptions = new string[](polls[_pollID].options.length - 1);\r\n\t\tuint256[] memory newVotes = new uint256[](polls[_pollID].optionVotes.length - 1);\r\n\t\tuint256 index = 0;\r\n\r\n\t\tfor (uint256 i = 0; i < polls[_pollID].options.length; i++) {\r\n\t\t\tif (i != _optionIndex) {\r\n\t\t\t\tnewOptions[index] = polls[_pollID].options[i];\r\n\t\t\t\tnewVotes[index] = polls[_pollID].optionVotes[i];\r\n\t\t\t\tindex++;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tpolls[_pollID].options = newOptions;\r\n\t\tpolls[_pollID].optionVotes = newVotes;\r\n\t}\r\n\r\n\t/* GETTERS */\r\n\r\n\t/*\r\n\t * Gets the status of a poll.\r\n\t */\r\n\tfunction getPollStatus(uint256 _pollID) public view validPoll(_pollID) returns (PollStatus) {\r\n\t\treturn polls[_pollID].status;\r\n\t}\r\n\r\n\t/*\r\n\t * Gets the winning option of a poll.\r\n\t */\r\n\tfunction getPollWinningOption(uint256 _pollID) public view validPoll(_pollID) returns (uint256) {\r\n\t\trequire(polls[_pollID].status == PollStatus.ENDED, \"Poll is still in progress.\");\r\n\t\treturn polls[_pollID].optionWinning;\r\n\t}\r\n\r\n\t/*\r\n\t * Gets the complete list of options for a poll with their votes.\r\n\t */\r\n\tfunction getPollOptions(uint256 _pollID) public view returns(string[] memory, uint256[] memory) {\r\n\t\treturn (polls[_pollID].options, polls[_pollID].optionVotes);\r\n\t}\r\n\r\n\t/*\r\n\t * Gets the expiration date of a poll.\r\n\t */\r\n\tfunction getPollExpirationTime(uint256 _pollID) public view validPoll(_pollID) returns (uint256) {\r\n\t\treturn polls[_pollID].expirationTimeInDays;\r\n\t}\r\n\r\n\t/*\r\n\t * Gets the expiration date of a poll.\r\n\t */\r\n\tfunction getPollDescription(uint256 _pollID) public view validPoll(_pollID) returns (string memory) {\r\n\t\treturn polls[_pollID].description;\r\n\t}\r\n\r\n\t/*\r\n\t * Gets the number of tokens of the bounty of a given poll.\r\n\t */\r\n\tfunction getPollBountyTokens(uint256 _pollID) public view validPoll(_pollID) returns (uint256) {\r\n\t\treturn bounties[_pollID];\r\n\t}\r\n\r\n\t/*\r\n\t * Gets the mechanism used to give the bounty of a given poll.\r\n\t */\r\n\tfunction getPollBountyMechanism(uint256 _pollID) public view validPoll(_pollID) returns (BountyMechanism) {\r\n\t\treturn polls[_pollID].mechanism;\r\n\t}\r\n\r\n\t/*\r\n\t * Gets the winner of the bounty of a given poll.\r\n\t */\r\n\tfunction getPollBountyWinner(uint256 _pollID) public view validPoll(_pollID) returns (address) {\r\n\t\trequire(polls[_pollID].mechanism == BountyMechanism.LOTTERY, \"Poll mechanism has to be lottery.\");\r\n\t\treturn polls[_pollID].winner;\r\n\t}\r\n\r\n\t/*\r\n\t * Gets the complete list of polls a user has voted in.\r\n\t */\r\n\tfunction getPollHistory(address _voter) public view returns(uint256[] memory) {\r\n\t\treturn bank[_voter].participatedPolls;\r\n\t}\r\n\r\n\t/*\r\n\t * Gets a voter's vote and weight for a given poll.\r\n\t */\r\n\tfunction getPollInfoForVoter(uint256 _pollID, address _voter) public view validPoll(_pollID) returns (uint256, uint256) {\r\n\t\trequire(getIfUserHasVoted(_pollID, _voter));\r\n\t\tPoll storage curPoll = polls[_pollID];\r\n\t\tuint256 vote = curPoll.voterInfo[_voter].vote;\r\n\t\tuint256 weight = curPoll.voterInfo[_voter].weight;\r\n\t\treturn (vote, weight);\r\n\t}\r\n\r\n\tfunction getPollsByStatus(uint256 _status) public view returns(string[] memory, uint256[] memory) {\r\n\t\tPollStatus _pollStatus = PollStatus.IN_PROGRESS;\r\n\r\n\t\tif (_status == 1) {\r\n\t\t\t_pollStatus = PollStatus.ENDED;\r\n\t\t}\r\n\r\n\t\tuint256 length = 0;\r\n\r\n\t\tfor (uint256 i = 1; i <= pollCount; i++) {\r\n\t\t\tif (polls[i].status == _pollStatus) {\r\n\t\t\t\tlength++;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tstring[] memory pollDescriptions = new string[](length);\r\n\t\tuint256[] memory pollIDs = new uint256[](length);\r\n\r\n\t\tuint256 index = 0;\r\n\r\n\t\tfor (uint256 i = 1; i <= pollCount; i++) {\r\n\t\t\tif (polls[i].status == _pollStatus) {\r\n\t\t\t\tpollDescriptions[index] = polls[i].description;\r\n\t\t\t\tpollIDs[index] = i;\r\n\t\t\t\tindex++;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn (pollDescriptions, pollIDs);\r\n\t}\r\n\r\n\t/*\r\n\t * Gets all the voters of a poll.\r\n\t */\r\n\tfunction getVotersForPoll(uint256 _pollID) public view validPoll(_pollID) returns (address[] memory) {\r\n\t\trequire(getPollStatus(_pollID) != PollStatus.IN_PROGRESS);\r\n\t\treturn polls[_pollID].voters;\r\n\t}\r\n\r\n\t\t/*\r\n\t * Gets the amount of Voting Tokens that are locked for a given voter.\r\n\t */\r\n\r\n\tfunction getLockedAmount(address _voter) public view returns (uint256) {\r\n\t\tTokenManager storage manager = bank[_voter];\r\n\t\tuint256 largest;\r\n\t\tfor (uint256 i = 0; i < manager.participatedPolls.length; i++) {\r\n\t\t\tuint256 curPollID = manager.participatedPolls[i];\r\n\t\t\tif (manager.lockedTokens[curPollID] > largest)\r\n\t\t\t\tlargest = manager.lockedTokens[curPollID];\r\n\t\t}\r\n\t\treturn largest;\r\n\t}\r\n\r\n\t/*\r\n\t * Gets the amount of Voting Credits for a given voter.\r\n\t */\r\n\tfunction getTokenStake(address _voter) public view returns(uint256) {\r\n\t\treturn bank[_voter].tokenBalance;\r\n\t}\r\n\r\n\t/*\r\n\t * Gets the amount of bounty tokens earned for a given poll by a given voter.\r\n\t */\r\n\tfunction getTokenBounty(address _voter, uint256 _pollID) public view returns(uint256) {\r\n\t\treturn bank[_voter].bountyTokens[_pollID];\r\n\t}\r\n\r\n\t/*\r\n\t * Checks if a user has voted for a specific poll.\r\n\t */\r\n\tfunction getIfUserHasVoted(uint256 _pollID, address _user) public view validPoll(_pollID) returns (bool) {\r\n\t\treturn (polls[_pollID].voterInfo[_user].hasVoted);\r\n\t}\r\n\r\n\t/*\r\n\t * Modifier that checks for a valid poll ID.\r\n\t */\r\n\tmodifier validPoll(uint256 _pollID) {\r\n\t\trequire(_pollID > 0 && _pollID <= pollCount, \"Not a valid poll Id.\");\r\n\t\t_;\r\n\t}\r\n\r\n\t/* VOTE OPERATIONS */\r\n\r\n\t/*\r\n\t * Casts a vote for a given poll.\r\n\t * NOTE: _weight is denominated in *wei*.\r\n\t */\r\n\tfunction castVote(uint256 _pollID, uint256 _vote, uint256 _weight) external validPoll(_pollID) {\r\n\t\trequire(_weight > 0, \"Weight must be greater than 0.\");\r\n\t\trequire(getPollStatus(_pollID) == PollStatus.IN_PROGRESS, \"Poll has expired.\");\r\n\t\trequire(!getIfUserHasVoted(_pollID, msg.sender), \"User has already voted.\");\r\n\t\trequire(getPollExpirationTime(_pollID) > block.timestamp);\r\n\t\trequire(getTokenStake(msg.sender) >= _weight, \"User does not have enough staked tokens.\");\r\n\r\n\t\tPoll storage curPoll = polls[_pollID];\r\n\r\n\t\trequire(_vote < curPoll.options.length, \"Vote option is not available.\");\r\n\r\n\t\t// update token bank\r\n\t\tbank[msg.sender].lockedTokens[_pollID] = _weight;\r\n\t\tbank[msg.sender].participatedPolls.push(_pollID);\t\r\n\r\n\t\tcurPoll.voterInfo[msg.sender] = Voter({\r\n\t\t\t\thasVoted: true,\r\n\t\t\t\tvote: _vote,\r\n\t\t\t\tweight: _weight\r\n\t\t});\r\n\r\n\t\tcurPoll.optionVotes[_vote] += _weight;\r\n\r\n\t\tcurPoll.voters.push(msg.sender);\r\n\t\temit voteCasted(msg.sender, _pollID, _vote, _weight);\r\n\t}\r\n\r\n\t/* TOKEN OPERATIONS */\r\n\r\n\t/*\r\n\t * Stakes tokens for a given voter in return for voting credits.\r\n\t * NOTE:\r\n\t *  User must approve transfer of tokens.\r\n\t *  _numTokens is denominated in *wei*.\r\n\t */\r\n\tfunction stakeVotingTokens(uint256 _numTokens) external {\r\n\t\trequire(token.balanceOf(msg.sender) >= _numTokens, \"User does not have enough tokens.\");\r\n\t\tuint256 initialBalance = token.balanceOf(address(this));\r\n\t\trequire(token.transferFrom(msg.sender, address(this), _numTokens), \"User did not approve token transfer.\");\r\n\t\tuint256 finalBalance = token.balanceOf(address(this));\r\n\t\tuint256 tokensReceived = finalBalance - initialBalance;\r\n\t\tbank[msg.sender].tokenBalance += tokensReceived;\r\n\t\trequire(bank[msg.sender].tokenBalance <= limit, \"User has exceeded the limit of tokens staked.\");\r\n\t}\r\n\r\n\t/*\r\n\t * Allows a voter to withdraw voting tokens after a poll has ended.\r\n\t * NOTE: _numTokens is denominated in *wei*.\r\n\t */\r\n\tfunction withdrawTokens(uint256 _numTokens) external {\r\n\t\tuint256 largest = getLockedAmount(msg.sender);\r\n\t\trequire(getTokenStake(msg.sender) - largest >= _numTokens, \"User is trying to withdraw too many tokens.\");\r\n\t\tbank[msg.sender].tokenBalance -= _numTokens;\r\n\t\trequire(token.transfer(msg.sender, _numTokens));\r\n\t}\r\n\r\n\t/*\r\n\t * Allows a voter to withdraw all tokens that aren't locked.\r\n\t */\r\n\tfunction withdrawAllTokens() external {\r\n\t\tuint256 largest = getLockedAmount(msg.sender);\r\n\t\tuint numTokens = getTokenStake(msg.sender) - largest;\r\n\t\tbank[msg.sender].tokenBalance -= numTokens;\r\n\t\trequire(token.transfer(msg.sender, numTokens));\r\n\t}\r\n\r\n\t/*\r\n\t * Helper function that updates active token balances after a poll has ended.\r\n\t */\r\n\tfunction updateTokenBank(uint256 _pollID, bool _resetBalance) internal {\r\n\t\tPoll storage curPoll = polls[_pollID];\r\n\t\tfor (uint256 i = 0; i < curPoll.voters.length; i++) {\r\n\t\t\taddress voter = curPoll.voters[i];\r\n\t\t\tbank[voter].lockedTokens[_pollID] = 0;\r\n\r\n\t\t\tif (_resetBalance) {\r\n\t\t\t\tbank[voter].tokenBalance = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/* BOUNTIES */\r\n\r\n \tfunction getPseudoRandomNumber(uint256 _pollID) public view returns (uint256) {\r\n        return uint256(keccak256(abi.encodePacked(block.prevrandao, block.timestamp, polls[_pollID].voters))) % polls[_pollID].voters.length;       \r\n    }\r\n\r\n\tfunction assignBounty(uint256 _pollID, uint256 _numTokens) internal {\r\n\t\tbounties[_pollID] = _numTokens;\r\n\t\temit bountyAssigned(_pollID, _numTokens);\r\n\t}\r\n\r\n\tfunction giveBounty(uint256 _pollID) internal {\r\n\t\tuint256 bountyTokens = bounties[_pollID];\r\n\r\n\t\tPoll storage curPoll = polls[_pollID];\r\n\r\n\t\tif (curPoll.mechanism == BountyMechanism.LOTTERY) {\r\n\t\t\taddress winnerVoter = curPoll.voters[getPseudoRandomNumber(_pollID)];\r\n\t\t\tcurPoll.winner = winnerVoter;\r\n\t\t\tbank[winnerVoter].tokenBalance += bountyTokens;\r\n\t\t\tbank[winnerVoter].bountyTokens[_pollID] = bountyTokens;\r\n\t\t} else {\r\n\t\t\tuint256 pollTokens = 0;\r\n\r\n\t\t\tfor (uint256 i = 0; i < curPoll.optionVotes.length; i++) {\r\n\t\t\t\tpollTokens += curPoll.optionVotes[i];\r\n\t\t\t}\r\n\r\n\t\t\tfor (uint256 i = 0; i < curPoll.voters.length; i++) {\r\n\t\t\t\taddress voter = curPoll.voters[i];\r\n\t\t\t\tuint256 voterTokens = (bountyTokens * curPoll.voterInfo[voter].weight) / pollTokens;\r\n\t\t\t\tbank[voter].tokenBalance += voterTokens;\r\n\t\t\t\tbank[voter].bountyTokens[_pollID] = voterTokens;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\temit bountyGiven(_pollID);\r\n\t}\r\n\r\n\t/* RESCUE */\r\n\r\n\t/*\r\n\t * Reset token bank for a given poll manually in case tokens have to be rescued\r\n\t */\r\n\r\n\tfunction resetTokenBank(uint256 _pollID) external onlyOwner {\r\n\t\tupdateTokenBank(_pollID, true);\r\n\t}\r\n\r\n\t/*\r\n\t * Send any token from the contract balance to an address\r\n\t */\r\n\r\n    function rescueToken(address _token, address _to) external onlyOwner {\r\n        IERC20(_token).transfer(_to, IERC20(_token).balanceOf(address(this)));\r\n    }\r\n}\r\n"

    }

  },

  "settings": {

    "evmVersion": "paris",

    "optimizer": {

      "enabled": false,

      "runs": 200

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "libraries": {}

  }

}}