/**

 *Submitted for verification at Etherscan.io on 2023-07-11

*/

pragma solidity >=0.5.0 <0.8.0;

pragma abicoder v2;

library LowGasSafeMath {

    /// @notice Returns x + y, reverts if sum overflows uint256

    /// @param x The augend

    /// @param y The addend

    /// @return z The sum of x and y

    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {

        require((z = x + y) >= x);

    }



    /// @notice Returns x - y, reverts if underflows

    /// @param x The minuend

    /// @param y The subtrahend

    /// @return z The difference of x and y

    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {

        require((z = x - y) <= x);

    }



    /// @notice Returns x * y, reverts if overflows

    /// @param x The multiplicand

    /// @param y The multiplier

    /// @return z The product of x and y

    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {

        require(x == 0 || (z = x * y) / x == y);

    }



    /// @notice Returns x + y, reverts if overflows or underflows

    /// @param x The augend

    /// @param y The addend

    /// @return z The sum of x and y

    function add(int256 x, int256 y) internal pure returns (int256 z) {

        require((z = x + y) >= x == (y >= 0));

    }



    /// @notice Returns x - y, reverts if overflows or underflows

    /// @param x The minuend

    /// @param y The subtrahend

    /// @return z The difference of x and y

    function sub(int256 x, int256 y) internal pure returns (int256 z) {

        require((z = x - y) <= x == (y >= 0));

    }

}

library TickMath {

    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128

    int24 internal constant MIN_TICK = -887272;

    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128

    int24 internal constant MAX_TICK = -MIN_TICK;



    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)

    uint160 internal constant MIN_SQRT_RATIO = 4295128739;

    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)

    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;



    /// @notice Calculates sqrt(1.0001^tick) * 2^96

    /// @dev Throws if |tick| > max tick

    /// @param tick The input tick for the above formula

    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)

    /// at the given tick

    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {

        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));

        require(absTick <= uint256(MAX_TICK), 'T');



        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;

        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;

        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;

        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;

        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;

        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;

        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;

        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;

        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;

        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;

        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;

        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;

        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;

        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;

        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;

        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;

        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;

        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;

        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;

        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;



        if (tick > 0) ratio = type(uint256).max / ratio;



        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.

        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint

        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent

        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));

    }



    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio

    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may

    /// ever return.

    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96

    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio

    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {

        // second inequality must be < because the price can never reach the price at the max tick

        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');

        uint256 ratio = uint256(sqrtPriceX96) << 32;



        uint256 r = ratio;

        uint256 msb = 0;



        assembly {

            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))

            msb := or(msb, f)

            r := shr(f, r)

        }

        assembly {

            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))

            msb := or(msb, f)

            r := shr(f, r)

        }

        assembly {

            let f := shl(5, gt(r, 0xFFFFFFFF))

            msb := or(msb, f)

            r := shr(f, r)

        }

        assembly {

            let f := shl(4, gt(r, 0xFFFF))

            msb := or(msb, f)

            r := shr(f, r)

        }

        assembly {

            let f := shl(3, gt(r, 0xFF))

            msb := or(msb, f)

            r := shr(f, r)

        }

        assembly {

            let f := shl(2, gt(r, 0xF))

            msb := or(msb, f)

            r := shr(f, r)

        }

        assembly {

            let f := shl(1, gt(r, 0x3))

            msb := or(msb, f)

            r := shr(f, r)

        }

        assembly {

            let f := gt(r, 0x1)

            msb := or(msb, f)

        }



        if (msb >= 128) r = ratio >> (msb - 127);

        else r = ratio << (127 - msb);



        int256 log_2 = (int256(msb) - 128) << 64;



        assembly {

            r := shr(127, mul(r, r))

            let f := shr(128, r)

            log_2 := or(log_2, shl(63, f))

            r := shr(f, r)

        }

        assembly {

            r := shr(127, mul(r, r))

            let f := shr(128, r)

            log_2 := or(log_2, shl(62, f))

            r := shr(f, r)

        }

        assembly {

            r := shr(127, mul(r, r))

            let f := shr(128, r)

            log_2 := or(log_2, shl(61, f))

            r := shr(f, r)

        }

        assembly {

            r := shr(127, mul(r, r))

            let f := shr(128, r)

            log_2 := or(log_2, shl(60, f))

            r := shr(f, r)

        }

        assembly {

            r := shr(127, mul(r, r))

            let f := shr(128, r)

            log_2 := or(log_2, shl(59, f))

            r := shr(f, r)

        }

        assembly {

            r := shr(127, mul(r, r))

            let f := shr(128, r)

            log_2 := or(log_2, shl(58, f))

            r := shr(f, r)

        }

        assembly {

            r := shr(127, mul(r, r))

            let f := shr(128, r)

            log_2 := or(log_2, shl(57, f))

            r := shr(f, r)

        }

        assembly {

            r := shr(127, mul(r, r))

            let f := shr(128, r)

            log_2 := or(log_2, shl(56, f))

            r := shr(f, r)

        }

        assembly {

            r := shr(127, mul(r, r))

            let f := shr(128, r)

            log_2 := or(log_2, shl(55, f))

            r := shr(f, r)

        }

        assembly {

            r := shr(127, mul(r, r))

            let f := shr(128, r)

            log_2 := or(log_2, shl(54, f))

            r := shr(f, r)

        }

        assembly {

            r := shr(127, mul(r, r))

            let f := shr(128, r)

            log_2 := or(log_2, shl(53, f))

            r := shr(f, r)

        }

        assembly {

            r := shr(127, mul(r, r))

            let f := shr(128, r)

            log_2 := or(log_2, shl(52, f))

            r := shr(f, r)

        }

        assembly {

            r := shr(127, mul(r, r))

            let f := shr(128, r)

            log_2 := or(log_2, shl(51, f))

            r := shr(f, r)

        }

        assembly {

            r := shr(127, mul(r, r))

            let f := shr(128, r)

            log_2 := or(log_2, shl(50, f))

        }



        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number



        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);

        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);



        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;

    }

}



library FullMath {

    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0

    /// @param a The multiplicand

    /// @param b The multiplier

    /// @param denominator The divisor

    /// @return result The 256-bit result

    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv

    function mulDiv(

        uint256 a,

        uint256 b,

        uint256 denominator

    ) internal pure returns (uint256 result) {

        // 512-bit multiply [prod1 prod0] = a * b

        // Compute the product mod 2**256 and mod 2**256 - 1

        // then use the Chinese Remainder Theorem to reconstruct

        // the 512 bit result. The result is stored in two 256

        // variables such that product = prod1 * 2**256 + prod0

        uint256 prod0; // Least significant 256 bits of the product

        uint256 prod1; // Most significant 256 bits of the product

        assembly {

            let mm := mulmod(a, b, not(0))

            prod0 := mul(a, b)

            prod1 := sub(sub(mm, prod0), lt(mm, prod0))

        }



        // Handle non-overflow cases, 256 by 256 division

        if (prod1 == 0) {

            require(denominator > 0);

            assembly {

                result := div(prod0, denominator)

            }

            return result;

        }



        // Make sure the result is less than 2**256.

        // Also prevents denominator == 0

        require(denominator > prod1);



        ///////////////////////////////////////////////

        // 512 by 256 division.

        ///////////////////////////////////////////////



        // Make division exact by subtracting the remainder from [prod1 prod0]

        // Compute remainder using mulmod

        uint256 remainder;

        assembly {

            remainder := mulmod(a, b, denominator)

        }

        // Subtract 256 bit number from 512 bit number

        assembly {

            prod1 := sub(prod1, gt(remainder, prod0))

            prod0 := sub(prod0, remainder)

        }



        // Factor powers of two out of denominator

        // Compute largest power of two divisor of denominator.

        // Always >= 1.

        uint256 twos = -denominator & denominator;

        // Divide denominator by power of two

        assembly {

            denominator := div(denominator, twos)

        }



        // Divide [prod1 prod0] by the factors of two

        assembly {

            prod0 := div(prod0, twos)

        }

        // Shift in bits from prod1 into prod0. For this we need

        // to flip `twos` such that it is 2**256 / twos.

        // If twos is zero, then it becomes one

        assembly {

            twos := add(div(sub(0, twos), twos), 1)

        }

        prod0 |= prod1 * twos;



        // Invert denominator mod 2**256

        // Now that denominator is an odd number, it has an inverse

        // modulo 2**256 such that denominator * inv = 1 mod 2**256.

        // Compute the inverse by starting with a seed that is correct

        // correct for four bits. That is, denominator * inv = 1 mod 2**4

        uint256 inv = (3 * denominator) ^ 2;

        // Now use Newton-Raphson iteration to improve the precision.

        // Thanks to Hensel's lifting lemma, this also works in modular

        // arithmetic, doubling the correct bits in each step.

        inv *= 2 - denominator * inv; // inverse mod 2**8

        inv *= 2 - denominator * inv; // inverse mod 2**16

        inv *= 2 - denominator * inv; // inverse mod 2**32

        inv *= 2 - denominator * inv; // inverse mod 2**64

        inv *= 2 - denominator * inv; // inverse mod 2**128

        inv *= 2 - denominator * inv; // inverse mod 2**256



        // Because the division is now exact we can divide by multiplying

        // with the modular inverse of denominator. This will give us the

        // correct result modulo 2**256. Since the precoditions guarantee

        // that the outcome is less than 2**256, this is the final result.

        // We don't need to compute the high bits of the result and prod1

        // is no longer required.

        result = prod0 * inv;

        return result;

    }



    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0

    /// @param a The multiplicand

    /// @param b The multiplier

    /// @param denominator The divisor

    /// @return result The 256-bit result

    function mulDivRoundingUp(

        uint256 a,

        uint256 b,

        uint256 denominator

    ) internal pure returns (uint256 result) {

        result = mulDiv(a, b, denominator);

        if (mulmod(a, b, denominator) > 0) {

            require(result < type(uint256).max);

            result++;

        }

    }

}



interface IUniswapV3Router {

    struct ExactInputParams {

        bytes path;

        address recipient;

        uint256 deadline;

        uint256 amountIn;

        uint256 amountOutMinimum;

    }

    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);

}



library PoolAddress {

    bytes32 internal constant POOL_INIT_CODE_HASH = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;



    /// @notice The identifying key of the pool

    struct PoolKey {

        address token0;

        address token1;

        uint24 fee;

    }



    /// @notice Returns PoolKey: the ordered tokens with the matched fee levels

    /// @param tokenA The first token of a pool, unsorted

    /// @param tokenB The second token of a pool, unsorted

    /// @param fee The fee level of the pool

    /// @return Poolkey The pool details with ordered token0 and token1 assignments

    function getPoolKey(

        address tokenA,

        address tokenB,

        uint24 fee

    ) internal pure returns (PoolKey memory) {

        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);

        return PoolKey({token0: tokenA, token1: tokenB, fee: fee});

    }



    /// @notice Deterministically computes the pool address given the factory and PoolKey

    /// @param factory The Uniswap V3 factory contract address

    /// @param key The PoolKey

    /// @return pool The contract address of the V3 pool

    function computeAddress(address factory, PoolKey memory key) internal pure returns (address pool) {

        require(key.token0 < key.token1);

        pool = address(

            uint256(

                keccak256(

                    abi.encodePacked(

                        hex'ff',

                        factory,

                        keccak256(abi.encode(key.token0, key.token1, key.fee)),

                        POOL_INIT_CODE_HASH

                    )

                )

            )

        );

    }

    

}



interface IUniswapV3Pool 

{

    struct Slot0 {

        // the current price

        uint160 sqrtPriceX96;

        // the current tick

        int24 tick;

        // the most-recently updated index of the observations array

        uint16 observationIndex;

        // the current maximum number of observations that are being stored

        uint16 observationCardinality;

        // the next maximum number of observations to store, triggered in observations.write

        uint16 observationCardinalityNext;

        // the current protocol fee as a percentage of the swap fee taken on withdrawal

        // represented as an integer denominator (1/x)%

        uint8 feeProtocol;

        // whether the pool is locked

        bool unlocked;

    }

    function liquidity()

        external

        view

        returns (uint256);

    function slot0()

        external

        view

        returns (

            uint160 sqrtPriceX96,

            int24 tick,

            uint16 observationIndex,

            uint16 observationCardinality,

            uint16 observationCardinalityNext,

            uint8 feeProtocol,

            bool unlocked

        );

}



interface INonfungiblePositionManager

{

    /// @notice Emitted when liquidity is increased for a position NFT

    /// @dev Also emitted when a token is minted

    /// @param tokenId The ID of the token for which liquidity was increased

    /// @param liquidity The amount by which liquidity for the NFT position was increased

    /// @param amount0 The amount of token0 that was paid for the increase in liquidity

    /// @param amount1 The amount of token1 that was paid for the increase in liquidity

    event IncreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);

    /// @notice Emitted when liquidity is decreased for a position NFT

    /// @param tokenId The ID of the token for which liquidity was decreased

    /// @param liquidity The amount by which liquidity for the NFT position was decreased

    /// @param amount0 The amount of token0 that was accounted for the decrease in liquidity

    /// @param amount1 The amount of token1 that was accounted for the decrease in liquidity

    event DecreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);

    /// @notice Emitted when tokens are collected for a position NFT

    /// @dev The amounts reported may not be exactly equivalent to the amounts transferred, due to rounding behavior

    /// @param tokenId The ID of the token for which underlying tokens were collected

    /// @param recipient The address of the account that received the collected tokens

    /// @param amount0 The amount of token0 owed to the position that was collected

    /// @param amount1 The amount of token1 owed to the position that was collected

    event Collect(uint256 indexed tokenId, address recipient, uint256 amount0, uint256 amount1);



    /// @notice Returns the position information associated with a given token ID.

    /// @dev Throws if the token ID is not valid.

    /// @param tokenId The ID of the token that represents the position

    /// @return nonce The nonce for permits

    /// @return operator The address that is approved for spending

    /// @return token0 The address of the token0 for a specific pool

    /// @return token1 The address of the token1 for a specific pool

    /// @return fee The fee associated with the pool

    /// @return tickLower The lower end of the tick range for the position

    /// @return tickUpper The higher end of the tick range for the position

    /// @return liquidity The liquidity of the position

    /// @return feeGrowthInside0LastX128 The fee growth of token0 as of the last action on the individual position

    /// @return feeGrowthInside1LastX128 The fee growth of token1 as of the last action on the individual position

    /// @return tokensOwed0 The uncollected amount of token0 owed to the position as of the last computation

    /// @return tokensOwed1 The uncollected amount of token1 owed to the position as of the last computation

    function positions(uint256 tokenId)

        external

        view

        returns (

            uint96 nonce,

            address operator,

            address token0,

            address token1,

            uint24 fee,

            int24 tickLower,

            int24 tickUpper,

            uint128 liquidity,

            uint256 feeGrowthInside0LastX128,

            uint256 feeGrowthInside1LastX128,

            uint128 tokensOwed0,

            uint128 tokensOwed1

        );



    struct MintParams {

        address token0;

        address token1;

        uint24 fee;

        int24 tickLower;

        int24 tickUpper;

        uint256 amount0Desired;

        uint256 amount1Desired;

        uint256 amount0Min;

        uint256 amount1Min;

        address recipient;

        uint256 deadline;

    }



    /// @notice Creates a new position wrapped in a NFT

    /// @dev Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized

    /// a method does not exist, i.e. the pool is assumed to be initialized.

    /// @param params The params necessary to mint a position, encoded as `MintParams` in calldata

    /// @return tokenId The ID of the token that represents the minted position

    /// @return liquidity The amount of liquidity for this position

    /// @return amount0 The amount of token0

    /// @return amount1 The amount of token1

    function mint(MintParams calldata params)

        external

        payable

        returns (

            uint256 tokenId,

            uint128 liquidity,

            uint256 amount0,

            uint256 amount1

        );



    struct IncreaseLiquidityParams {

        uint256 tokenId;

        uint256 amount0Desired;

        uint256 amount1Desired;

        uint256 amount0Min;

        uint256 amount1Min;

        uint256 deadline;

    }



    /// @notice Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`

    /// @param params tokenId The ID of the token for which liquidity is being increased,

    /// amount0Desired The desired amount of token0 to be spent,

    /// amount1Desired The desired amount of token1 to be spent,

    /// amount0Min The minimum amount of token0 to spend, which serves as a slippage check,

    /// amount1Min The minimum amount of token1 to spend, which serves as a slippage check,

    /// deadline The time by which the transaction must be included to effect the change

    /// @return liquidity The new liquidity amount as a result of the increase

    /// @return amount0 The amount of token0 to acheive resulting liquidity

    /// @return amount1 The amount of token1 to acheive resulting liquidity

    function increaseLiquidity(IncreaseLiquidityParams calldata params)

        external

        payable

        returns (

            uint128 liquidity,

            uint256 amount0,

            uint256 amount1

        );



    struct DecreaseLiquidityParams {

        uint256 tokenId;

        uint128 liquidity;

        uint256 amount0Min;

        uint256 amount1Min;

        uint256 deadline;

    }



    /// @notice Decreases the amount of liquidity in a position and accounts it to the position

    /// @param params tokenId The ID of the token for which liquidity is being decreased,

    /// amount The amount by which liquidity will be decreased,

    /// amount0Min The minimum amount of token0 that should be accounted for the burned liquidity,

    /// amount1Min The minimum amount of token1 that should be accounted for the burned liquidity,

    /// deadline The time by which the transaction must be included to effect the change

    /// @return amount0 The amount of token0 accounted to the position's tokens owed

    /// @return amount1 The amount of token1 accounted to the position's tokens owed

    function decreaseLiquidity(DecreaseLiquidityParams calldata params)

        external

        payable

        returns (uint256 amount0, uint256 amount1);



    struct CollectParams {

        uint256 tokenId;

        address recipient;

        uint128 amount0Max;

        uint128 amount1Max;

    }



    /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient

    /// @param params tokenId The ID of the NFT for which tokens are being collected,

    /// recipient The account that should receive the tokens,

    /// amount0Max The maximum amount of token0 to collect,

    /// amount1Max The maximum amount of token1 to collect

    /// @return amount0 The amount of fees collected in token0

    /// @return amount1 The amount of fees collected in token1

    function collect(CollectParams calldata params) external payable returns (uint256 amount0, uint256 amount1);



    /// @notice Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens

    /// must be collected first.

    /// @param tokenId The ID of the token that is being burned

    function burn(uint256 tokenId) external payable;

    function factory() external view returns (address);

}

// File: @openzeppelin/contracts/utils/math/SafeMath.sol



// CAUTION

// This version of SafeMath should only be used with Solidity 0.8 or later,

// because it relies on the compiler's built in overflow checks.



/**

 * @dev Wrappers over Solidity's arithmetic operations.

 *

 * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler

 * now has built in overflow checking.

 */

// File: @openzeppelin/contracts/utils/Address.sol





// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)



/**

 * @dev Collection of functions related to the address type

 */

// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)



/**

 * @dev Provides information about the current execution context, including the

 * sender of the transaction and its data. While these are generally available

 * via msg.sender and msg.data, they should not be accessed in such a direct

 * manner, since when dealing with meta-transactions the account sending and

 * paying for execution may not be the actual sender (as far as an application

 * is concerned).

 *

 * This contract is only required for intermediate, library-like contracts.

 */

abstract contract Context {

    function _msgSender() internal view virtual returns (address) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes calldata) {

        return msg.data;

    }

}





// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)



/**

 * @dev Contract module which provides a basic access control mechanism, where

 * there is an account (an owner) that can be granted exclusive access to

 * specific functions.

 *

 * By default, the owner account will be the one that deploys the contract. This

 * can later be changed with {transferOwnership}.

 *

 * This module is used through inheritance. It will make available the modifier

 * `onlyOwner`, which can be applied to your functions to restrict their use to

 * the owner.

 */

abstract contract Ownable is Context {

    address private _owner;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    /**

     * @dev Initializes the contract setting the deployer as the initial owner.

     */

    constructor() {

        _transferOwnership(_msgSender());

    }



    /**

     * @dev Throws if called by any account other than the owner.

     */

    modifier onlyOwner() {

        _checkOwner();

        _;

    }



    /**

     * @dev Returns the address of the current owner.

     */

    function owner() public view virtual returns (address) {

        return _owner;

    }



    /**

     * @dev Throws if the sender is not the owner.

     */

    function _checkOwner() internal view virtual {

        require(owner() == _msgSender(), "Ownable: caller is not the owner");

    }



    /**

     * @dev Leaves the contract without owner. It will not be possible to call

     * `onlyOwner` functions anymore. Can only be called by the current owner.

     *

     * NOTE: Renouncing ownership will leave the contract without an owner,

     * thereby removing any functionality that is only available to the owner.

     */

    function renounceOwnership() public virtual onlyOwner {

        _transferOwnership(address(0));

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Can only be called by the current owner.

     */

    function transferOwnership(address newOwner) public virtual onlyOwner {

        require(newOwner != address(0), "Ownable: new owner is the zero address");

        _transferOwnership(newOwner);

    }



    /**

     * @dev Transfers ownership of the contract to a new account (`newOwner`).

     * Internal function without access restriction.

     */

    function _transferOwnership(address newOwner) internal virtual {

        address oldOwner = _owner;

        _owner = newOwner;

        emit OwnershipTransferred(oldOwner, newOwner);

    }

}



// File: @openzeppelin/contracts/token/ERC20/IERC20.sol





// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)



/**

 * @dev Interface of the ERC20 standard as defined in the EIP.

 */

interface IERC20 {

    /**

     * @dev Emitted when `value` tokens are moved from one account (`from`) to

     * another (`to`).

     *

     * Note that `value` may be zero.

     */

    event Transfer(address indexed from, address indexed to, uint256 value);



    /**

     * @dev Emitted when the allowance of a `spender` for an `owner` is set by

     * a call to {approve}. `value` is the new allowance.

     */

    event Approval(address indexed owner, address indexed spender, uint256 value);



    /**

     * @dev Returns the amount of tokens in existence.

     */

    function totalSupply() external view returns (uint256);



    /**

     * @dev Returns the amount of tokens owned by `account`.

     */

    function balanceOf(address account) external view returns (uint256);



    /**

     * @dev Moves `amount` tokens from the caller's account to `to`.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transfer(address to, uint256 amount) external returns (bool);



    /**

     * @dev Returns the remaining number of tokens that `spender` will be

     * allowed to spend on behalf of `owner` through {transferFrom}. This is

     * zero by default.

     *

     * This value changes when {approve} or {transferFrom} are called.

     */

    function allowance(address owner, address spender) external view returns (uint256);



    /**

     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * IMPORTANT: Beware that changing an allowance with this method brings the risk

     * that someone may use both the old and the new allowance by unfortunate

     * transaction ordering. One possible solution to mitigate this race

     * condition is to first reduce the spender's allowance to 0 and set the

     * desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     *

     * Emits an {Approval} event.

     */

    function approve(address spender, uint256 amount) external returns (bool);



    /**

     * @dev Moves `amount` tokens from `from` to `to` using the

     * allowance mechanism. `amount` is then deducted from the caller's

     * allowance.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transferFrom(

        address from,

        address to,

        uint256 amount

    ) external returns (bool);

}



// File: @openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol





// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)



/**

 * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in

 * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].

 *

 * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by

 * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't

 * need to send a transaction, and thus is not required to hold Ether at all.

 */

interface IERC20Permit {

    /**

     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,

     * given ``owner``'s signed approval.

     *

     * IMPORTANT: The same issues {IERC20-approve} has related to transaction

     * ordering also apply here.

     *

     * Emits an {Approval} event.

     *

     * Requirements:

     *

     * - `spender` cannot be the zero address.

     * - `deadline` must be a timestamp in the future.

     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`

     * over the EIP712-formatted function arguments.

     * - the signature must use ``owner``'s current nonce (see {nonces}).

     *

     * For more information on the signature format, see the

     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP

     * section].

     */

    function permit(

        address owner,

        address spender,

        uint256 value,

        uint256 deadline,

        uint8 v,

        bytes32 r,

        bytes32 s

    ) external;



    /**

     * @dev Returns the current nonce for `owner`. This value must be

     * included whenever a signature is generated for {permit}.

     *

     * Every successful call to {permit} increases ``owner``'s nonce by one. This

     * prevents a signature from being used multiple times.

     */

    function nonces(address owner) external view returns (uint256);



    /**

     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.

     */

    // solhint-disable-next-line func-name-mixedcase

    function DOMAIN_SEPARATOR() external view returns (bytes32);

}



/**

 * @title SafeERC20

 * @dev Wrappers around ERC20 operations that throw on failure (when the token

 * contract returns false). Tokens that return no value (and instead revert or

 * throw on failure) are also supported, non-reverting calls are assumed to be

 * successful.

 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,

 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.

 */



interface HonoToken {

    function deposit() external payable;

    function balanceOf(address account) external view returns (uint);

    function redeem(uint256 _amount) external;

}



interface HonoLPEngine

{

    function increaseLiquidityCurrentRange(uint256 tokenId, uint256 amountAdd0, uint256 amountAdd1, uint256 slippage, address referrer)

        external

        payable

        returns (uint128 liquidity, uint256 amount0, uint256 amount1);

}



interface IWETH {

    function deposit() external payable;

    function transfer(address to, uint value) external returns (bool);

    function withdraw(uint) external;

    function balanceOf(address account) external view returns (uint);

}



contract DistributionContract is Ownable {

    using FullMath for uint256;

    event RevenueSent(uint256 honoAmount, uint256 timestamp);

    

    HonoToken public HONO;

    IERC20 public WETH;

    IERC20 public USDC;

    IERC20 public LINK;

    IUniswapV3Router public router;



    uint24 public  feeForETHLINK = 3000;

    uint256 public  minimumLinkToSwap = 100000000000000000;

    uint24 public  feeForHONOUSDC = 3000;

    uint256 public  minimumUSDCToSwap = 100000000000000000000;

    uint256 public  minimumHONOToRedeem = 100000000000000000000;

    uint256 public  minimumWETHToRedeem = 100000000000000000000;

    uint256 public  minimumETHToDistribute = 100000000000000000;

    uint256 public HonoBackingP = 4000;

    uint256 public AddLPP = 500;



    uint256 public OperationWalletP = 2500;

    address payable public OperationWallet = 0x1784cf268e4a5D48562F01506C6f570aBc35F9c1;



    uint256 public HONOStakingRewardP = 2000;

    address payable public HONOStakingReward = 0xf39D0162e3d03fD95ea8355611cD331B3E068B18;



    uint256 public PoolMinterP = 1000;

    address payable public PoolMinter = 0x0aC73C4559E08C05C7c3E0B5255f8E6cdd4639b0;



    uint256 public sqrt_price_high;

    uint256 public sqrt_price_low;



    IUniswapV3Pool public _pool; 

    INonfungiblePositionManager public _posMgr;

    HonoLPEngine public _lpEngine;

    uint256 public _tokenId;

    uint256 maxApprove = 11579208923731619542357098500868790785326998466564056403945758400791312963993;





    function updateMinimumLinkToSwap(uint256 _newAmount) external onlyOwner {

        minimumLinkToSwap = _newAmount;

    }



    function updateMinimumUSDCToSwap(uint256 _newAmount) external onlyOwner {

        minimumUSDCToSwap = _newAmount;

    }



    function updateminimumHONOToRedeem(uint256 _newAmount) external onlyOwner {

        minimumHONOToRedeem = _newAmount;

    }



    function updateminimumWETHToRedeem(uint256 _newAmount) external onlyOwner {

        minimumWETHToRedeem = _newAmount;

    }



    function updateminimumETHToDistribute(uint256 _newAmount) external onlyOwner {

        minimumETHToDistribute = _newAmount;

    }



    function updateETHLinkFee(uint24 _BP) external onlyOwner {

        feeForETHLINK = _BP;

    }



    function UpdateHONOUSDTFEE(uint24 _BP) external onlyOwner {

        feeForHONOUSDC = _BP;

    }



    function UpdateAddLPP(uint256 _BP) external onlyOwner {

        AddLPP = _BP;

    }



    function UpdateHonoBackingP(uint256 _BP) external onlyOwner {

        HonoBackingP = _BP;

    }



    function UpdateHONOStakingReward(address payable _newRecipient, uint256 _BP) external onlyOwner {

        HONOStakingReward = _newRecipient;

        HONOStakingRewardP = _BP;

    }



    function UpdatePoolMinter(address payable _newRecipient, uint256 _BP) external onlyOwner {

        PoolMinter = _newRecipient;

        PoolMinterP = _BP;

    }



    function UpdateOperationWallet(address payable _newRecipient, uint256 _BP) external onlyOwner {

        OperationWallet = _newRecipient;

        OperationWalletP = _BP;

    }



    constructor(address honoAddress, address posMgr, address lpengine, uint256 tokenId,  address routerAddress, address weth, address link, uint256 usdc) {

        HONO = HonoToken(honoAddress);

        _posMgr = INonfungiblePositionManager(posMgr);

        _lpEngine = HonoLPEngine(lpengine);

        router = IUniswapV3Router(routerAddress);

        WETH = IERC20(weth);

        LINK = IERC20(link);

        USDC = IERC20(usdc);

        _tokenId = tokenId;

        _preconfig(_tokenId);

    }



    // Owner can drain tokens that are sent here by mistake

    function drainToken(IERC20 _token, uint256 _amount, address _to) external onlyOwner {

        _token.transfer(_to,_amount);

    }

    

    function distributeFee() external {



        if(LINK.balanceOf(address(this)) > minimumLinkToSwap)

        {

            univ3swapWithLINKInput(LINK.balanceOf(address(this)));

        }



        if(USDC.balanceOf(address(this)) > minimumUSDCToSwap)

        {

            univ3swapWithUSDCInputHonoOutput(USDC.balanceOf(address(this)));

        }



        if(HONO.balanceOf(address(this)) > minimumHONOToRedeem)

        {

            HONO.redeem(HONO.balanceOf(address(this)));

        }



        if(WETH.balanceOf(address(this)) > minimumWETHToRedeem)

        {

            IWETH(address(WETH)).withdraw(WETH.balanceOf(address(this)));

        }



        uint totalETH =  address(this).balance;

        if(totalETH > minimumETHToDistribute)

        {

            if(HONOStakingRewardP > 0)

            sendEth(HONOStakingReward,totalETH*HONOStakingRewardP/10000);

            if(PoolMinterP > 0)

                sendEth(PoolMinter, totalETH*PoolMinterP/10000);

            if(HonoBackingP > 0)

                HONO.deposit{value: totalETH*HonoBackingP/10000}();

            if(OperationWalletP > 0)    

                sendEth(OperationWallet, totalETH*OperationWalletP/10000);

            if(AddLPP > 0)     

                swapAndAddLp(address(this).balance);

            emit RevenueSent(totalETH, block.timestamp);

        }

        

    }



    function withdrawFunds() external onlyOwner {

        uint256 contractBalance = address(this).balance;

        require(contractBalance > 0, "No value to withdraw");

        payable(owner()).transfer(contractBalance);

    }

    

    receive() payable external {

        

    } 



    function sendEth(address _address, uint256 _value) internal {

        (bool success, ) = _address.call{value: _value}("");

        require(success, "ETH Transfer failed.");

    }



    function sqrtPriceX96ToUint(uint160 sqrtPriceX96, uint8 decimalsToken0)

    internal

    pure

    returns (uint256)

    {

        uint256 numerator1 = uint256(sqrtPriceX96) * uint256(sqrtPriceX96);

        uint256 numerator2 = 10**decimalsToken0;

        return FullMath.mulDiv(numerator1, numerator2, 1 << 192);

    }



    function swapAndAddLp(uint256 totalEth) internal

    {

        (uint256 ethToAddLp, uint256  ethToSwap) = _calculateCorrectAmount(totalEth);

        uint256 amountLINK =  univ3swapWithETHInput(ethToSwap);

        LINK.approve(address(_lpEngine),amountLINK);

        _lpEngine.increaseLiquidityCurrentRange{value:ethToAddLp}(_tokenId,amountLINK,ethToAddLp,feeForETHLINK,0x0000000000000000000000000000000000000000);

    }



    function swapAndAddLp() external payable onlyOwner

    {

        (uint256 ethToAddLp, uint256  ethToSwap) = _calculateCorrectAmount(msg.value);

        uint256 amountLINK =  univ3swapWithETHInput(ethToSwap);

        LINK.approve(address(_lpEngine),amountLINK );

        _lpEngine.increaseLiquidityCurrentRange{value:ethToAddLp}(_tokenId,amountLINK,ethToAddLp,feeForETHLINK,0x0000000000000000000000000000000000000000);

    }



    function calculateCorrectAmount(uint256 totalETH) external view returns (uint256, uint256)

    {

        return _calculateCorrectAmount(totalETH);

    }



    function _calculateCorrectAmount(uint256 totalETH) internal view returns (uint256, uint256)

    {

        //we know eth is the token0, so can do this, if it is reverse need to change a bit

        (uint160 sqrtRatioX96,,,,,,) = _pool.slot0();

        uint256 amountLINK = FullMath.mulDiv(_pool.liquidity(), 0x1000000000000000000000000, sqrtRatioX96);

        uint256 amountETH = FullMath.mulDiv(_pool.liquidity(), sqrtRatioX96, 0x1000000000000000000000000);

        // x USDE for 10**18 ETH

        if(amountLINK > amountETH)

        {

            uint256 amountUNeededFor1ETHAddLp  = 10**18 / _getAmount1Needed(10**18);

            uint256 amountUNeededFor1ETHSwap  = amountLINK/amountETH;

            //a little hack to make computing for gas efficient

            uint256 amountETHToAddLp = FullMath.mulDiv(amountUNeededFor1ETHSwap, totalETH, amountUNeededFor1ETHSwap + amountUNeededFor1ETHAddLp);

            return(amountETHToAddLp, totalETH - amountETHToAddLp);

        } 

        else

        {

            //toolazy it shouldnt happen lul

        }

    }



    function computeAddress(address token0, address token1, uint24 fee) external view returns (address )

    {

       return  PoolAddress.computeAddress(

                _posMgr.factory(), PoolAddress.PoolKey({token0: token0, token1: token1, fee: fee})

            );

    }



    function _preconfig(uint256 tokenId) internal

    {

        _tokenId = tokenId;

        (,, address token0, address token1, uint24 fee,int24 tickLower ,int24 tickUpper,,,,,) = _posMgr.positions(tokenId);



        _pool = IUniswapV3Pool(

            PoolAddress.computeAddress(

                _posMgr.factory(), PoolAddress.PoolKey({token0: token0, token1: token1, fee: fee})

            )

        );

        IERC20(token0).approve(address(router),maxApprove);

        IERC20(token1).approve(address(router),maxApprove);



        IERC20(token0).approve(address(_lpEngine), maxApprove);

        IERC20(token1).approve(address(_lpEngine), maxApprove);



        LINK.approve(address(router),maxApprove);

        USDC.approve(address(router),maxApprove);



        sqrt_price_high = TickMath.getSqrtRatioAtTick(tickUpper);

        sqrt_price_low = TickMath.getSqrtRatioAtTick(tickLower);



    }



    function PreConfig(uint256 tokenId) external onlyOwner

    {

        _preconfig(tokenId);

    }



    function _getAmount1Needed(uint256 totalToken0) internal view returns (uint256 token1needed)

    {

        (uint160 sqrtRatioX96,,,,,,) = _pool.slot0();

        token1needed = FullMath.mulDiv(sqrt_price_high, sqrtRatioX96 - sqrt_price_low, 2**96);

        token1needed = FullMath.mulDiv(sqrtRatioX96,token1needed,2**96);

        token1needed = FullMath.mulDiv(totalToken0,token1needed, sqrt_price_high - sqrtRatioX96);

    }



    function getAmount1Needed(uint256 totalToken0) external view returns (uint256 token1needed)

    {

        token1needed = _getAmount1Needed(totalToken0);

    }



    function univ3swapWithETHInput(uint256 amount) internal returns  (uint256) {

        uint deadline = block.timestamp + 3000;

        IUniswapV3Router.ExactInputParams memory params =

            IUniswapV3Router.ExactInputParams({

                path: abi.encodePacked(WETH, feeForETHLINK, LINK),

                recipient: address(this),

                deadline: deadline,

                amountIn: amount,

                amountOutMinimum: 0

            });

        // Executes the swap.

        return router.exactInput{value: amount}(params);

    }



    function univ3swapWithLINKInput(uint256 amount) internal returns  (uint256) {

        uint deadline = block.timestamp + 3000;

        

        IUniswapV3Router.ExactInputParams memory params =

            IUniswapV3Router.ExactInputParams({

                path: abi.encodePacked(LINK, feeForETHLINK, WETH),

                recipient: address(this),

                deadline: deadline,

                amountIn: amount,

                amountOutMinimum: 0

            });

        // Executes the swap.

        return router.exactInput(params);

    }



    function univ3swapWithUSDCInputHonoOutput(uint256 amount) internal returns  (uint256) {

        uint deadline = block.timestamp + 3000;

        

        IUniswapV3Router.ExactInputParams memory params =

            IUniswapV3Router.ExactInputParams({

                path: abi.encodePacked(USDC, feeForHONOUSDC, HONO),

                recipient: address(this),

                deadline: deadline,

                amountIn: amount,

                amountOutMinimum: 0

            });

        // Executes the swap.

        return router.exactInput(params);

    }

}