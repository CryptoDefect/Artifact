{{

  "language": "Solidity",

  "sources": {

    "/contracts/core/Whitelist.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.6.10;\n\nimport \"../interfaces/AddressBookInterface.sol\";\nimport \"../packages/oz/Ownable.sol\";\n\n/**\n * @author Opyn Team\n * @title Whitelist Module\n * @notice The whitelist module keeps track of all valid oToken addresses, product hashes, collateral addresses, and callee addresses.\n */\ncontract Whitelist is Ownable {\n    /// @notice AddressBook module address\n    address public addressBook;\n    /// @dev mapping to track whitelisted products\n    mapping(bytes32 => bool) internal whitelistedProduct;\n    /// @dev mapping to track whitelisted collateral\n    mapping(address => bool) internal whitelistedCollateral;\n    /// @dev mapping to mapping to track whitelisted collateral for covered calls or puts\n    mapping(bytes32 => bool) internal coveredWhitelistedCollateral;\n    /// @dev mapping to mapping to track whitelisted collateral for naked calls or puts\n    mapping(bytes32 => bool) internal nakedWhitelistedCollateral;\n    /// @dev mapping to track whitelisted oTokens\n    mapping(address => bool) internal whitelistedOtoken;\n    /// @dev mapping to track whitelisted callee addresses for the call action\n    mapping(address => bool) internal whitelistedCallee;\n\n    /**\n     * @dev constructor\n     * @param _addressBook AddressBook module address\n     */\n    constructor(address _addressBook) public {\n        require(_addressBook != address(0), \"Invalid address book\");\n\n        addressBook = _addressBook;\n    }\n\n    /// @notice emits an event a product is whitelisted by the owner address\n    event ProductWhitelisted(\n        bytes32 productHash,\n        address indexed underlying,\n        address indexed strike,\n        address indexed collateral,\n        bool isPut\n    );\n    /// @notice emits an event a product is blacklisted by the owner address\n    event ProductBlacklisted(\n        bytes32 productHash,\n        address indexed underlying,\n        address indexed strike,\n        address indexed collateral,\n        bool isPut\n    );\n    /// @notice emits an event when a collateral address is whitelisted by the owner address\n    event CollateralWhitelisted(address indexed collateral);\n    /// @notice emits an event when a collateral address for vault type 0 is whitelisted by the owner address\n    event CoveredCollateralWhitelisted(address indexed collateral, address underlying, bool isPut);\n    /// @notice emits an event when a collateral address for vault type 1 is whitelisted by the owner address\n    event NakedCollateralWhitelisted(address indexed collateral, address underlying, bool isPut);\n    /// @notice emits an event when a collateral address is blacklist by the owner address\n    event CollateralBlacklisted(address indexed collateral);\n    /// @notice emits an event when an oToken is whitelisted by the OtokenFactory module\n    event OtokenWhitelisted(address indexed otoken);\n    /// @notice emits an event when an oToken is blacklisted by the OtokenFactory module\n    event OtokenBlacklisted(address indexed otoken);\n    /// @notice emits an event when a callee address is whitelisted by the owner address\n    event CalleeWhitelisted(address indexed _callee);\n    /// @notice emits an event when a callee address is blacklisted by the owner address\n    event CalleeBlacklisted(address indexed _callee);\n\n    /**\n     * @notice check if the sender is the oTokenFactory module\n     */\n    modifier onlyFactory() {\n        require(\n            msg.sender == AddressBookInterface(addressBook).getOtokenFactory(),\n            \"Whitelist: Sender is not OtokenFactory\"\n        );\n\n        _;\n    }\n\n    /**\n     * @notice check if a product is whitelisted\n     * @dev product is the hash of underlying asset, strike asset, collateral asset, and isPut\n     * @param _underlying asset that the option references\n     * @param _strike asset that the strike price is denominated in\n     * @param _collateral asset that is held as collateral against short/written options\n     * @param _isPut True if a put option, False if a call option\n     * @return boolean, True if product is whitelisted\n     */\n    function isWhitelistedProduct(\n        address _underlying,\n        address _strike,\n        address _collateral,\n        bool _isPut\n    ) external view returns (bool) {\n        bytes32 productHash = keccak256(abi.encode(_underlying, _strike, _collateral, _isPut));\n\n        return whitelistedProduct[productHash];\n    }\n\n    /**\n     * @notice check if a collateral asset is whitelisted\n     * @param _collateral asset that is held as collateral against short/written options\n     * @return boolean, True if the collateral is whitelisted\n     */\n    function isWhitelistedCollateral(address _collateral) external view returns (bool) {\n        return whitelistedCollateral[_collateral];\n    }\n\n    /**\n     * @notice check if a collateral asset is whitelisted for vault type 0\n     * @param _collateral asset that is held as collateral against short/written options\n     * @param _underlying asset that is used as the underlying asset for the written options\n     * @param _isPut bool for whether the collateral is to be checked for suitability on a call or put\n     * @return boolean, True if the collateral is whitelisted for vault type 0\n     */\n    function isCoveredWhitelistedCollateral(\n        address _collateral,\n        address _underlying,\n        bool _isPut\n    ) external view returns (bool) {\n        bytes32 productHash = keccak256(abi.encode(_collateral, _underlying, _isPut));\n        return coveredWhitelistedCollateral[productHash];\n    }\n\n    /**\n     * @notice check if a collateral asset is whitelisted for vault type 1\n     * @param _collateral asset that is held as collateral against short/written options\n     * @param _underlying asset that is used as the underlying asset for the written options\n     * @param _isPut bool for whether the collateral is to be checked for suitability on a call or put\n     * @return boolean, True if the collateral is whitelisted for vault type 1\n     */\n    function isNakedWhitelistedCollateral(\n        address _collateral,\n        address _underlying,\n        bool _isPut\n    ) external view returns (bool) {\n        bytes32 productHash = keccak256(abi.encode(_collateral, _underlying, _isPut));\n        return nakedWhitelistedCollateral[productHash];\n    }\n\n    /**\n     * @notice check if an oToken is whitelisted\n     * @param _otoken oToken address\n     * @return boolean, True if the oToken is whitelisted\n     */\n    function isWhitelistedOtoken(address _otoken) external view returns (bool) {\n        return whitelistedOtoken[_otoken];\n    }\n\n    /**\n     * @notice check if a callee address is whitelisted for the call action\n     * @param _callee callee destination address\n     * @return boolean, True if the address is whitelisted\n     */\n    function isWhitelistedCallee(address _callee) external view returns (bool) {\n        return whitelistedCallee[_callee];\n    }\n\n    /**\n     * @notice allows the owner to whitelist a product\n     * @dev product is the hash of underlying asset, strike asset, collateral asset, and isPut\n     * can only be called from the owner address\n     * @param _underlying asset that the option references\n     * @param _strike asset that the strike price is denominated in\n     * @param _collateral asset that is held as collateral against short/written options\n     * @param _isPut True if a put option, False if a call option\n     */\n    function whitelistProduct(\n        address _underlying,\n        address _strike,\n        address _collateral,\n        bool _isPut\n    ) external onlyOwner {\n        require(whitelistedCollateral[_collateral], \"Whitelist: Collateral is not whitelisted\");\n\n        bytes32 productHash = keccak256(abi.encode(_underlying, _strike, _collateral, _isPut));\n\n        whitelistedProduct[productHash] = true;\n\n        emit ProductWhitelisted(productHash, _underlying, _strike, _collateral, _isPut);\n    }\n\n    /**\n     * @notice allow the owner to blacklist a product\n     * @dev product is the hash of underlying asset, strike asset, collateral asset, and isPut\n     * can only be called from the owner address\n     * @param _underlying asset that the option references\n     * @param _strike asset that the strike price is denominated in\n     * @param _collateral asset that is held as collateral against short/written options\n     * @param _isPut True if a put option, False if a call option\n     */\n    function blacklistProduct(\n        address _underlying,\n        address _strike,\n        address _collateral,\n        bool _isPut\n    ) external onlyOwner {\n        bytes32 productHash = keccak256(abi.encode(_underlying, _strike, _collateral, _isPut));\n\n        whitelistedProduct[productHash] = false;\n\n        emit ProductBlacklisted(productHash, _underlying, _strike, _collateral, _isPut);\n    }\n\n    /**\n     * @notice allows the owner to whitelist a collateral address\n     * @dev can only be called from the owner address. This function is used to whitelist any asset other than Otoken as collateral. WhitelistOtoken() is used to whitelist Otoken contracts.\n     * @param _collateral collateral asset address\n     */\n    function whitelistCollateral(address _collateral) external onlyOwner {\n        whitelistedCollateral[_collateral] = true;\n\n        emit CollateralWhitelisted(_collateral);\n    }\n\n    /**\n     * @notice allows the owner to whitelist a collateral address for vault type 0\n     * @dev can only be called from the owner address. This function is used to whitelist any asset other than Otoken as collateral.\n     * @param _collateral collateral asset address\n     * @param _underlying underlying asset address\n     * @param _isPut bool for whether the collateral is suitable for puts or calls\n     */\n    function whitelistCoveredCollateral(\n        address _collateral,\n        address _underlying,\n        bool _isPut\n    ) external onlyOwner {\n        bytes32 productHash = keccak256(abi.encode(_collateral, _underlying, _isPut));\n        coveredWhitelistedCollateral[productHash] = true;\n        emit CoveredCollateralWhitelisted(_collateral, _underlying, _isPut);\n    }\n\n    /**\n     * @notice allows the owner to whitelist a collateral address for vault type 1\n     * @dev can only be called from the owner address. This function is used to whitelist any asset other than Otoken as collateral.\n     * @param _collateral collateral asset address\n     * @param _underlying underlying asset address\n     * @param _isPut bool for whether the collateral is suitable for puts or calls\n     */\n    function whitelistNakedCollateral(\n        address _collateral,\n        address _underlying,\n        bool _isPut\n    ) external onlyOwner {\n        bytes32 productHash = keccak256(abi.encode(_collateral, _underlying, _isPut));\n        nakedWhitelistedCollateral[productHash] = true;\n        emit NakedCollateralWhitelisted(_collateral, _underlying, _isPut);\n    }\n\n    /**\n     * @notice allows the owner to blacklist a collateral address\n     * @dev can only be called from the owner address\n     * @param _collateral collateral asset address\n     */\n    function blacklistCollateral(address _collateral) external onlyOwner {\n        whitelistedCollateral[_collateral] = false;\n\n        emit CollateralBlacklisted(_collateral);\n    }\n\n    /**\n     * @notice allows the OtokenFactory module to whitelist a new option\n     * @dev can only be called from the OtokenFactory address\n     * @param _otokenAddress oToken\n     */\n    function whitelistOtoken(address _otokenAddress) external onlyFactory {\n        whitelistedOtoken[_otokenAddress] = true;\n\n        emit OtokenWhitelisted(_otokenAddress);\n    }\n\n    /**\n     * @notice allows the owner to blacklist an option\n     * @dev can only be called from the owner address\n     * @param _otokenAddress oToken\n     */\n    function blacklistOtoken(address _otokenAddress) external onlyOwner {\n        whitelistedOtoken[_otokenAddress] = false;\n\n        emit OtokenBlacklisted(_otokenAddress);\n    }\n\n    /**\n     * @notice allows the owner to whitelist a destination address for the call action\n     * @dev can only be called from the owner address\n     * @param _callee callee address\n     */\n    function whitelistCallee(address _callee) external onlyOwner {\n        whitelistedCallee[_callee] = true;\n\n        emit CalleeWhitelisted(_callee);\n    }\n\n    /**\n     * @notice allows the owner to blacklist a destination address for the call action\n     * @dev can only be called from the owner address\n     * @param _callee callee address\n     */\n    function blacklistCallee(address _callee) external onlyOwner {\n        whitelistedCallee[_callee] = false;\n\n        emit CalleeBlacklisted(_callee);\n    }\n}\n"

    },

    "/contracts/packages/oz/Ownable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// openzeppelin-contracts v3.1.0\n\npragma solidity 0.6.10;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"

    },

    "/contracts/packages/oz/Context.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// openzeppelin-contracts v3.1.0\n\npragma solidity 0.6.10;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"

    },

    "/contracts/interfaces/AddressBookInterface.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.10;\n\ninterface AddressBookInterface {\n    /* Getters */\n\n    function getOtokenImpl() external view returns (address);\n\n    function getOtokenFactory() external view returns (address);\n\n    function getWhitelist() external view returns (address);\n\n    function getController() external view returns (address);\n\n    function getOracle() external view returns (address);\n\n    function getMarginPool() external view returns (address);\n\n    function getMarginCalculator() external view returns (address);\n\n    function getMarginRequirements() external view returns (address);\n\n    function getLiquidationManager() external view returns (address);\n\n    function getKeeper() external view returns (address);\n\n    function getOTCWrapper() external view returns (address);\n\n    function getAddress(bytes32 _id) external view returns (address);\n\n    /* Setters */\n\n    function setOtokenImpl(address _otokenImpl) external;\n\n    function setOtokenFactory(address _factory) external;\n\n    function setOracleImpl(address _otokenImpl) external;\n\n    function setWhitelist(address _whitelist) external;\n\n    function setController(address _controller) external;\n\n    function setMarginPool(address _marginPool) external;\n\n    function setMarginCalculator(address _calculator) external;\n\n    function setLiquidationManager(address _liquidationManager) external;\n\n    function setAddress(bytes32 _id, address _newImpl) external;\n}\n"

    }

  },

  "settings": {

    "remappings": [],

    "optimizer": {

      "enabled": true,

      "runs": 200

    },

    "evmVersion": "istanbul",

    "libraries": {},

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    }

  }

}}