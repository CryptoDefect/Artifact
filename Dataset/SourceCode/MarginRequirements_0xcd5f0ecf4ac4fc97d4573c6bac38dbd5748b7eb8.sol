{{

  "language": "Solidity",

  "sources": {

    "/contracts/core/MarginRequirements.sol": {

      "content": "/**\n * SPDX-License-Identifier: UNLICENSED\n */\npragma solidity =0.6.10;\n\npragma experimental ABIEncoderV2;\n\nimport {Ownable} from \"../packages/oz/Ownable.sol\";\nimport {OtokenInterface} from \"../interfaces/OtokenInterface.sol\";\nimport {OracleInterface} from \"../interfaces/OracleInterface.sol\";\nimport {AddressBookInterface} from \"../interfaces/AddressBookInterface.sol\";\nimport {MarginVault} from \"../libs/MarginVault.sol\";\nimport {SafeMath} from \"../packages/oz/SafeMath.sol\";\nimport {ERC20Interface} from \"../interfaces/ERC20Interface.sol\";\n\n/**\n * @title MarginRequirements\n * @author Ribbon Team\n * @notice Contract that defines margin requirements and operations\n */\ncontract MarginRequirements is Ownable {\n    using MarginVault for MarginVault.Vault;\n    using SafeMath for uint256;\n\n    OracleInterface public oracle;\n\n    /************************************************\n     *  CONSTANTS\n     ***********************************************/\n\n    /// @notice Max initial margin value - equivalent to 100%\n    uint256 public constant MAX_INITIAL_MARGIN = 100 * 10**2;\n\n    /// @notice Number of decimals in notional variable\n    uint256 public constant NOTIONAL_DECIMALS = 6;\n\n    /// @notice Number of decimals in price output from oracle\n    uint256 public constant ORACLE_DECIMALS = 8;\n\n    /************************************************\n     *  STORAGE\n     ***********************************************/\n\n    /// @notice AddressBook module\n    address public addressBook;\n\n    ///@dev mapping between a hash of (underlying asset, collateral asset, isPut) and a mapping of an account to an initial margin value\n    mapping(bytes32 => mapping(address => uint256)) public initialMargin;\n    ///@dev mapping between an account owner and a specific vault id to a maintenance margin value\n    mapping(uint256 => uint256) public maintenanceMargin;\n\n    /************************************************\n     *  CONSTRUCTOR\n     ***********************************************/\n\n    /**\n     * @notice constructor\n     * @param _addressBook AddressBook address\n     */\n    constructor(address _addressBook) public {\n        require(_addressBook != address(0), \"Invalid address book\");\n\n        addressBook = _addressBook;\n\n        oracle = OracleInterface(AddressBookInterface(_addressBook).getOracle());\n    }\n\n    /**\n     * @notice modifier to check if the sender is the Keeper address\n     */\n    modifier onlyKeeper() {\n        require(\n            msg.sender == AddressBookInterface(addressBook).getKeeper(),\n            \"MarginRequirements: Sender is not Keeper\"\n        );\n\n        _;\n    }\n\n    /************************************************\n     *  SETTERS\n     ***********************************************/\n\n    /**\n     * @notice sets the initial margin %\n     * @dev can only be called by owner\n     * @param _underlying underlying asset address\n     * @param _collateralAsset collateral asset address\n     * @param _isPut option type the vault is selling\n     * @param _account account address\n     * @param _initialMargin initial margin percentage (eg. 10% = 10 * 10**2 = 1000)\n     */\n    function setInitialMargin(\n        address _underlying,\n        address _collateralAsset,\n        bool _isPut,\n        address _account,\n        uint256 _initialMargin\n    ) external onlyOwner {\n        require(\n            _initialMargin > 0 && _initialMargin <= MAX_INITIAL_MARGIN,\n            \"MarginRequirements: initial margin cannot be 0 or higher than 100%\"\n        );\n        require(_underlying != address(0), \"MarginRequirements: invalid underlying\");\n        require(_collateralAsset != address(0), \"MarginRequirements: invalid collateral\");\n        require(_account != address(0), \"MarginRequirements: invalid account\");\n\n        initialMargin[keccak256(abi.encode(_underlying, _collateralAsset, _isPut))][_account] = _initialMargin;\n    }\n\n    /**\n     * @notice sets the maintenance margin absolute amount\n     * @dev can only be called by keeper\n     * @param _vaultID id of the vault\n     * @param _maintenanceMargin maintenance margin absolute amount with its respective token decimals\n     */\n    function setMaintenanceMargin(uint256 _vaultID, uint256 _maintenanceMargin) external onlyKeeper {\n        require(_maintenanceMargin > 0, \"MarginRequirements: maintenance margin cannot be 0\");\n\n        maintenanceMargin[_vaultID] = _maintenanceMargin;\n    }\n\n    /************************************************\n     *  MARGIN OPERATIONS\n     ***********************************************/\n\n    /**\n     * @notice checks if there is enough collateral to mint the desired amount of otokens\n     * @param _account account address\n     * @param _notional order notional amount (USD value with 6 decimals)\n     * @param _underlying underlying asset address\n     * @param _isPut option type the vault is selling\n     * @param _collateralAsset collateral asset address\n     * @param _collateralAmount collateral amount (with its respective token decimals)\n     * @return boolean value stating whether there is enough collateral to mint\n     */\n    function checkMintCollateral(\n        address _account,\n        uint256 _notional,\n        address _underlying,\n        bool _isPut,\n        uint256 _collateralAmount,\n        address _collateralAsset\n    ) external view returns (bool) {\n        // retrieve collateral decimals\n        uint256 collateralDecimals = uint256(ERC20Interface(_collateralAsset).decimals());\n\n        // retrieve initial margin\n        uint256 initialMarginRequired = initialMargin[keccak256(abi.encode(_underlying, _collateralAsset, _isPut))][\n            _account\n        ];\n\n        // initial margin must have been set up before this call\n        require(\n            initialMarginRequired > 0,\n            \"MarginRequirements: initial margin cannot be 0 when checking mint collateral\"\n        );\n\n        // InitialMargin <= Collateral\n\n        // Starts with:\n        // notional (USD) * (initial margin/100) <= collateral (#tokens) * collateral price (in USD)\n\n        // initial margin is dividing by 100 since it is a %. Then, 100 moves to the other equation side multiplying:\n        // notional (USD) * initial margin <= collateral (#tokens) * collateral price * 100\n\n        // Remaining values are added to ensure both sides of the equation are scaled equally given they differ in decimal amounts\n\n        return\n            _notional.mul(initialMarginRequired).mul(10**collateralDecimals).mul(10**ORACLE_DECIMALS) <=\n            _collateralAmount.mul(oracle.getPrice(_collateralAsset)).mul(MAX_INITIAL_MARGIN).mul(10**NOTIONAL_DECIMALS);\n    }\n\n    /**\n     * @notice checks if there is enough collateral to withdraw the desired amount\n     * @param _account account address\n     * @param _notional order notional amount (USD value with 6 decimals)\n     * @param _withdrawAmount desired amount to withdraw (with its respective token decimals)\n     * @param _otokenAddress otoken address\n     * @param _vaultID id of the vault\n     * @param _vault vault struct\n     * @return boolean value stating whether there is enough collateral to withdraw\n     */\n    function checkWithdrawCollateral(\n        address _account,\n        uint256 _notional,\n        uint256 _withdrawAmount,\n        address _otokenAddress,\n        uint256 _vaultID,\n        MarginVault.Vault memory _vault\n    ) external view returns (bool) {\n        // retrieve collateral decimals\n        uint256 collateralDecimals = uint256(ERC20Interface(_vault.collateralAssets[0]).decimals());\n\n        // avoids subtraction overflow\n        if (_withdrawAmount.add(maintenanceMargin[_vaultID]) > _vault.collateralAmounts[0]) {\n            return false;\n        }\n\n        //     InitialMargin + MaintenanceMargin <= Collateral - WithdrawAmount\n        // (=) InitialMargin <= Collateral - WithdrawAmount - MaintenanceMargin\n\n        // Starts with:\n        // notional (USD) * (initial margin/100) <= [collateral (#tokens) - withdrawAmount (#tokens) - maintenanceMargin (#tokens)] * collateral price (in USD)\n\n        // initial margin is dividing by 100 since it is a %. Then, 100 moves to the other equation side multiplying:\n        // notional (USD) * initial margin <= [collateral (#tokens) - WithdrawAmount (#tokens) - MaintenanceMargin (#tokens)] * collateral price (in USD) * 100\n\n        // Remaining values are added to ensure both sides of the equation are scaled equally given they differ in decimal amounts\n\n        return\n            _notional.mul(_getInitialMargin(_otokenAddress, _account)).mul(10**collateralDecimals).mul(\n                10**ORACLE_DECIMALS\n            ) <=\n            (_vault.collateralAmounts[0].sub(_withdrawAmount).sub(maintenanceMargin[_vaultID]))\n                .mul(oracle.getPrice(_vault.collateralAssets[0]))\n                .mul(MAX_INITIAL_MARGIN)\n                .mul(10**NOTIONAL_DECIMALS);\n    }\n\n    /**\n     * @notice returns the initial margin value (avoids stack too deep)\n     * @param _otoken otoken address\n     * @param _account account address\n     * @return inital margin value\n     */\n    function _getInitialMargin(address _otoken, address _account) internal view returns (uint256) {\n        OtokenInterface otoken = OtokenInterface(_otoken);\n\n        uint256 initialMarginRequired = initialMargin[\n            keccak256(abi.encode(otoken.underlyingAsset(), otoken.collateralAsset(), otoken.isPut()))\n        ][_account];\n\n        // initial margin must have been set up before this call\n        require(\n            initialMarginRequired > 0,\n            \"MarginRequirements: initial margin cannot be 0 when checking withdraw collateral\"\n        );\n\n        return initialMarginRequired;\n    }\n}\n"

    },

    "/contracts/packages/oz/SafeMath.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// openzeppelin-contracts v3.1.0\n\n/* solhint-disable */\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"

    },

    "/contracts/packages/oz/Ownable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// openzeppelin-contracts v3.1.0\n\npragma solidity 0.6.10;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"

    },

    "/contracts/packages/oz/Context.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// openzeppelin-contracts v3.1.0\n\npragma solidity 0.6.10;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"

    },

    "/contracts/libs/MarginVault.sol": {

      "content": "/**\n * SPDX-License-Identifier: UNLICENSED\n */\npragma solidity =0.6.10;\n\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"../packages/oz/SafeMath.sol\";\n\n/**\n * MarginVault Error Codes\n * V1: invalid short otoken amount\n * V2: invalid short otoken index\n * V3: short otoken address mismatch\n * V4: invalid long otoken amount\n * V5: invalid long otoken index\n * V6: long otoken address mismatch\n * V7: invalid collateral amount\n * V8: invalid collateral token index\n * V9: collateral token address mismatch\n */\n\n/**\n * @title MarginVault\n * @author Opyn Team\n * @notice A library that provides the Controller with a Vault struct and the functions that manipulate vaults.\n * Vaults describe discrete position combinations of long options, short options, and collateral assets that a user can have.\n */\nlibrary MarginVault {\n    using SafeMath for uint256;\n\n    // vault is a struct of 6 arrays that describe a position a user has, a user can have multiple vaults.\n    struct Vault {\n        // addresses of oTokens a user has shorted (i.e. written) against this vault\n        address[] shortOtokens;\n        // addresses of oTokens a user has bought and deposited in this vault\n        // user can be long oTokens without opening a vault (e.g. by buying on a DEX)\n        // generally, long oTokens will be 'deposited' in vaults to act as collateral in order to write oTokens against (i.e. in spreads)\n        address[] longOtokens;\n        // addresses of other ERC-20s a user has deposited as collateral in this vault\n        address[] collateralAssets;\n        // quantity of oTokens minted/written for each oToken address in shortOtokens\n        uint256[] shortAmounts;\n        // quantity of oTokens owned and held in the vault for each oToken address in longOtokens\n        uint256[] longAmounts;\n        // quantity of ERC-20 deposited as collateral in the vault for each ERC-20 address in collateralAssets\n        uint256[] collateralAmounts;\n    }\n\n    // vaultLiquidationDetails is a struct of 3 variables that store the series address, short amount liquidated and collateral transferred for\n    // a given liquidation\n    struct VaultLiquidationDetails {\n        address series;\n        uint128 shortAmount;\n        uint128 collateralAmount;\n    }\n\n    /**\n     * @dev increase the short oToken balance in a vault when a new oToken is minted\n     * @param _vault vault to add or increase the short position in\n     * @param _shortOtoken address of the _shortOtoken being minted from the user's vault\n     * @param _amount number of _shortOtoken being minted from the user's vault\n     * @param _index index of _shortOtoken in the user's vault.shortOtokens array\n     */\n    function addShort(\n        Vault storage _vault,\n        address _shortOtoken,\n        uint256 _amount,\n        uint256 _index\n    ) external {\n        require(_amount > 0, \"V1\");\n\n        // valid indexes in any array are between 0 and array.length - 1.\n        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1\n        if ((_index == _vault.shortOtokens.length) && (_index == _vault.shortAmounts.length)) {\n            _vault.shortOtokens.push(_shortOtoken);\n            _vault.shortAmounts.push(_amount);\n        } else {\n            require((_index < _vault.shortOtokens.length) && (_index < _vault.shortAmounts.length), \"V2\");\n            address existingShort = _vault.shortOtokens[_index];\n            require((existingShort == _shortOtoken) || (existingShort == address(0)), \"V3\");\n\n            _vault.shortAmounts[_index] = _vault.shortAmounts[_index].add(_amount);\n            _vault.shortOtokens[_index] = _shortOtoken;\n        }\n    }\n\n    /**\n     * @dev decrease the short oToken balance in a vault when an oToken is burned\n     * @param _vault vault to decrease short position in\n     * @param _shortOtoken address of the _shortOtoken being reduced in the user's vault\n     * @param _amount number of _shortOtoken being reduced in the user's vault\n     * @param _index index of _shortOtoken in the user's vault.shortOtokens array\n     */\n    function removeShort(\n        Vault storage _vault,\n        address _shortOtoken,\n        uint256 _amount,\n        uint256 _index\n    ) external {\n        // check that the removed short oToken exists in the vault at the specified index\n        require(_index < _vault.shortOtokens.length, \"V2\");\n        require(_vault.shortOtokens[_index] == _shortOtoken, \"V3\");\n\n        uint256 newShortAmount = _vault.shortAmounts[_index].sub(_amount);\n\n        if (newShortAmount == 0) {\n            delete _vault.shortOtokens[_index];\n        }\n        _vault.shortAmounts[_index] = newShortAmount;\n    }\n\n    /**\n     * @dev increase the long oToken balance in a vault when an oToken is deposited\n     * @param _vault vault to add a long position to\n     * @param _longOtoken address of the _longOtoken being added to the user's vault\n     * @param _amount number of _longOtoken the protocol is adding to the user's vault\n     * @param _index index of _longOtoken in the user's vault.longOtokens array\n     */\n    function addLong(\n        Vault storage _vault,\n        address _longOtoken,\n        uint256 _amount,\n        uint256 _index\n    ) external {\n        require(_amount > 0, \"V4\");\n\n        // valid indexes in any array are between 0 and array.length - 1.\n        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1\n        if ((_index == _vault.longOtokens.length) && (_index == _vault.longAmounts.length)) {\n            _vault.longOtokens.push(_longOtoken);\n            _vault.longAmounts.push(_amount);\n        } else {\n            require((_index < _vault.longOtokens.length) && (_index < _vault.longAmounts.length), \"V5\");\n            address existingLong = _vault.longOtokens[_index];\n            require((existingLong == _longOtoken) || (existingLong == address(0)), \"V6\");\n\n            _vault.longAmounts[_index] = _vault.longAmounts[_index].add(_amount);\n            _vault.longOtokens[_index] = _longOtoken;\n        }\n    }\n\n    /**\n     * @dev decrease the long oToken balance in a vault when an oToken is withdrawn\n     * @param _vault vault to remove a long position from\n     * @param _longOtoken address of the _longOtoken being removed from the user's vault\n     * @param _amount number of _longOtoken the protocol is removing from the user's vault\n     * @param _index index of _longOtoken in the user's vault.longOtokens array\n     */\n    function removeLong(\n        Vault storage _vault,\n        address _longOtoken,\n        uint256 _amount,\n        uint256 _index\n    ) external {\n        // check that the removed long oToken exists in the vault at the specified index\n        require(_index < _vault.longOtokens.length, \"V5\");\n        require(_vault.longOtokens[_index] == _longOtoken, \"V6\");\n\n        uint256 newLongAmount = _vault.longAmounts[_index].sub(_amount);\n\n        if (newLongAmount == 0) {\n            delete _vault.longOtokens[_index];\n        }\n        _vault.longAmounts[_index] = newLongAmount;\n    }\n\n    /**\n     * @dev increase the collateral balance in a vault\n     * @param _vault vault to add collateral to\n     * @param _collateralAsset address of the _collateralAsset being added to the user's vault\n     * @param _amount number of _collateralAsset being added to the user's vault\n     * @param _index index of _collateralAsset in the user's vault.collateralAssets array\n     */\n    function addCollateral(\n        Vault storage _vault,\n        address _collateralAsset,\n        uint256 _amount,\n        uint256 _index\n    ) external {\n        require(_amount > 0, \"V7\");\n\n        // valid indexes in any array are between 0 and array.length - 1.\n        // if adding an amount to an preexisting short oToken, check that _index is in the range of 0->length-1\n        if ((_index == _vault.collateralAssets.length) && (_index == _vault.collateralAmounts.length)) {\n            _vault.collateralAssets.push(_collateralAsset);\n            _vault.collateralAmounts.push(_amount);\n        } else {\n            require((_index < _vault.collateralAssets.length) && (_index < _vault.collateralAmounts.length), \"V8\");\n            address existingCollateral = _vault.collateralAssets[_index];\n            require((existingCollateral == _collateralAsset) || (existingCollateral == address(0)), \"V9\");\n\n            _vault.collateralAmounts[_index] = _vault.collateralAmounts[_index].add(_amount);\n            _vault.collateralAssets[_index] = _collateralAsset;\n        }\n    }\n\n    /**\n     * @dev decrease the collateral balance in a vault\n     * @param _vault vault to remove collateral from\n     * @param _collateralAsset address of the _collateralAsset being removed from the user's vault\n     * @param _amount number of _collateralAsset being removed from the user's vault\n     * @param _index index of _collateralAsset in the user's vault.collateralAssets array\n     */\n    function removeCollateral(\n        Vault storage _vault,\n        address _collateralAsset,\n        uint256 _amount,\n        uint256 _index\n    ) external {\n        // check that the removed collateral exists in the vault at the specified index\n        require(_index < _vault.collateralAssets.length, \"V8\");\n        require(_vault.collateralAssets[_index] == _collateralAsset, \"V9\");\n\n        uint256 newCollateralAmount = _vault.collateralAmounts[_index].sub(_amount);\n\n        if (newCollateralAmount == 0) {\n            delete _vault.collateralAssets[_index];\n        }\n        _vault.collateralAmounts[_index] = newCollateralAmount;\n    }\n}\n"

    },

    "/contracts/interfaces/OtokenInterface.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.10;\n\ninterface OtokenInterface {\n    function addressBook() external view returns (address);\n\n    function underlyingAsset() external view returns (address);\n\n    function strikeAsset() external view returns (address);\n\n    function collateralAsset() external view returns (address);\n\n    function strikePrice() external view returns (uint256);\n\n    function expiryTimestamp() external view returns (uint256);\n\n    function isPut() external view returns (bool);\n\n    function init(\n        address _addressBook,\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _strikePrice,\n        uint256 _expiry,\n        bool _isPut\n    ) external;\n\n    function getOtokenDetails()\n        external\n        view\n        returns (\n            address,\n            address,\n            address,\n            uint256,\n            uint256,\n            bool\n        );\n\n    function mintOtoken(address account, uint256 amount) external;\n\n    function burnOtoken(address account, uint256 amount) external;\n}\n"

    },

    "/contracts/interfaces/OracleInterface.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.10;\n\ninterface OracleInterface {\n    function isLockingPeriodOver(address _asset, uint256 _expiryTimestamp) external view returns (bool);\n\n    function isDisputePeriodOver(address _asset, uint256 _expiryTimestamp) external view returns (bool);\n\n    function getExpiryPrice(address _asset, uint256 _expiryTimestamp) external view returns (uint256, bool);\n\n    function getDisputer() external view returns (address);\n\n    function getPricer(address _asset) external view returns (address);\n\n    function getPrice(address _asset) external view returns (uint256);\n\n    function getPricerLockingPeriod(address _pricer) external view returns (uint256);\n\n    function getPricerDisputePeriod(address _pricer) external view returns (uint256);\n\n    function getChainlinkRoundData(address _asset, uint80 _roundId) external view returns (uint256, uint256);\n\n    // Non-view function\n\n    function setAssetPricer(address _asset, address _pricer) external;\n\n    function setLockingPeriod(address _pricer, uint256 _lockingPeriod) external;\n\n    function setDisputePeriod(address _pricer, uint256 _disputePeriod) external;\n\n    function setExpiryPrice(\n        address _asset,\n        uint256 _expiryTimestamp,\n        uint256 _price\n    ) external;\n\n    function disputeExpiryPrice(\n        address _asset,\n        uint256 _expiryTimestamp,\n        uint256 _price\n    ) external;\n\n    function setDisputer(address _disputer) external;\n}\n"

    },

    "/contracts/interfaces/ERC20Interface.sol": {

      "content": "/**\n * SPDX-License-Identifier: UNLICENSED\n */\npragma solidity 0.6.10;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface ERC20Interface {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"

    },

    "/contracts/interfaces/AddressBookInterface.sol": {

      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.6.10;\n\ninterface AddressBookInterface {\n    /* Getters */\n\n    function getOtokenImpl() external view returns (address);\n\n    function getOtokenFactory() external view returns (address);\n\n    function getWhitelist() external view returns (address);\n\n    function getController() external view returns (address);\n\n    function getOracle() external view returns (address);\n\n    function getMarginPool() external view returns (address);\n\n    function getMarginCalculator() external view returns (address);\n\n    function getMarginRequirements() external view returns (address);\n\n    function getLiquidationManager() external view returns (address);\n\n    function getKeeper() external view returns (address);\n\n    function getOTCWrapper() external view returns (address);\n\n    function getAddress(bytes32 _id) external view returns (address);\n\n    /* Setters */\n\n    function setOtokenImpl(address _otokenImpl) external;\n\n    function setOtokenFactory(address _factory) external;\n\n    function setOracleImpl(address _otokenImpl) external;\n\n    function setWhitelist(address _whitelist) external;\n\n    function setController(address _controller) external;\n\n    function setMarginPool(address _marginPool) external;\n\n    function setMarginCalculator(address _calculator) external;\n\n    function setLiquidationManager(address _liquidationManager) external;\n\n    function setAddress(bytes32 _id, address _newImpl) external;\n}\n"

    }

  },

  "settings": {

    "remappings": [],

    "optimizer": {

      "enabled": true,

      "runs": 200

    },

    "evmVersion": "istanbul",

    "libraries": {},

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    }

  }

}}