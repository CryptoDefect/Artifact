{{

  "language": "Solidity",

  "sources": {

    "contracts/MimicCustom/Mimic/MimicMimic.sol": {

      "content": "\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\nimport { CoreMimic } from \"./CoreMimic.sol\";\nimport { Combo721Base } from \"./Combo721Base.sol\";\n\n\ncontract MimicMimic is CoreMimic {\n    constructor()\n        Combo721Base(\"Mimic\", \"MIMIC\")\n        {}\n}\n\n\n\n\n"

    },

    "contracts/MimicCustom/Mimic/CoreMimic.sol": {

      "content": "\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\n\nimport { ILore } from \"../Interfaces/ILore.sol\";\n\nimport { Combo721Base } from \"./Combo721Base.sol\";\n\nimport { MimicMeta } from \"./MimicMeta.sol\";\nimport { CoreShield } from \"./CoreShield.sol\";\n\n\nabstract contract CoreMimic is Combo721Base {\n    MimicMeta cMeta;\n    CoreShield cShield;\n    address aGuild;\n\n    ////\n    // Mimic Data\n\n    mapping(uint256 => address) POKED_CONTRACTS;\n    mapping(uint256 => uint256) POKED_IDS;\n    mapping(uint256 => uint256) MATURITIES;\n    mapping(uint256 => bool) SKIP_ID_REPLACEMENT;\n\n    ////\n    // Guild Data\n\n    uint256 guildGenesis;\n    uint256 guildPrice;\n    uint256 guildRate18;\n\n    ////\n    // Events\n\n    event Poke(uint256 indexed _mimicId, address _targetContract, uint256 _targetId);\n    event Rite(uint256 indexed _mimicId);\n    event SkipIdReplace(uint256 indexed _mimicId, bool _trueOrFalse);\n\n    ////\n    // Init\n\n    function init(address _guild, address _shield, address _meta) external {\n        require(aGuild == address(0x0), \"already initialized\");\n\n        aGuild = _guild;\n        cShield = CoreShield(_shield);\n        cMeta = MimicMeta(_meta);\n    }\n\n    ////\n    // Mimic Lifecycle\n\n    function maturityHash(address _targetContract, uint256 _targetId) internal pure returns (uint) {\n        return uint(keccak256(abi.encodePacked(\"MH\", _targetContract, _targetId)));\n    }\n\n    function maturityHashForMimic(uint256 _mimicId) internal view returns (uint) {\n        return maturityHash(POKED_CONTRACTS[_mimicId], POKED_IDS[_mimicId]);\n    }\n\n    function _pokeShared(uint256 _mimicId, address _targetContract, uint256 _targetId) internal {\n        require(_isApprovedOrOwner(msg.sender, _mimicId), \"*SLAP*, not your mimic!\");\n        require(_targetContract != address(0x0), \"that's not poking, that's pointing\");\n        require(_targetContract != address(this), \"this would cause poor mimic to explode\");\n        require(_targetContract != address(cShield), \"this is essence-ally a bad idea\");\n        uint256 mimicMatHashMimicId = MATURITIES[maturityHashForMimic(_mimicId)];\n        require(mimicMatHashMimicId != _mimicId, \"mature mimics won't poke\");\n        uint256 targetMatHashMimicId = MATURITIES[maturityHash(_targetContract, _targetId)];\n        require(targetMatHashMimicId == 0x0, \"mimic honor code violation\");\n\n        POKED_CONTRACTS[_mimicId] = _targetContract;\n        POKED_IDS[_mimicId] = _targetId;\n        emit Poke(_mimicId, _targetContract, _targetId);\n    }\n\n    function _riteShared(uint256 _mimicId) internal view returns (address pokedContract, uint256 matHash) {\n        require(_isApprovedOrOwner(msg.sender, _mimicId), \"*SLAP*, not your mimic!\");\n\n        pokedContract = POKED_CONTRACTS[_mimicId];\n        require(pokedContract != address(0x0), \"need to poke first\");\n        matHash = maturityHashForMimic(_mimicId);\n        uint256 matHashMimicId = MATURITIES[matHash];\n        require(matHashMimicId != _mimicId, \"mimic is already mature\");\n        require(matHashMimicId == 0x0, \"mimic honor code violation\");\n    }\n\n    function mimic_IsAdult(uint256 _mimicId) external view returns (bool) {\n        if (_exists(_mimicId) && (MATURITIES[maturityHashForMimic(_mimicId)] == _mimicId)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function mimic_Poke721(uint256 _mimicId, address _pokeNftContract, uint256 _pokeNftId) external {\n        (bool success, bytes memory ownerResult) = _pokeNftContract.staticcall(abi.encodeWithSignature(\"ownerOf(uint256)\", _pokeNftId));\n        require(success, \"not a valid 721\");\n        address owner721 = abi.decode(ownerResult, (address));\n        uint256 auraCount = cShield.activeCount(owner721);\n        require(auraCount == 0, \"blocked by active shield\");\n\n        _pokeShared(_mimicId, _pokeNftContract, _pokeNftId);\n   }\n\n    function mimic_Poke1155(uint256 _mimicId, address _pokeNftContract, uint256 _pokeNftId, address _ownerOf1155) external {\n        (bool success, bytes memory countResult) = _pokeNftContract.staticcall(abi.encodeWithSignature(\"balanceOf(address,uint256)\", _ownerOf1155, _pokeNftId));\n        require(success, \"not a valid 1155\");\n        require(abi.decode(countResult, (uint256)) > 0, \"not a valid owner of the NFT\");\n        require(cShield.activeCount(_ownerOf1155) == 0, \"blocked by active shield\");\n\n        _pokeShared(_mimicId, _pokeNftContract, _pokeNftId);\n    }\n\n    function mimic_Relax(uint256 _mimicId) external {\n        require(_isApprovedOrOwner(msg.sender, _mimicId), \"*SLAP*, not your mimic!\");\n\n        require(MATURITIES[maturityHashForMimic(_mimicId)] != _mimicId, \"adult mimics can never relax\");\n        delete POKED_CONTRACTS[_mimicId];\n        delete POKED_IDS[_mimicId];\n        emit Poke(_mimicId, address(0x0), 0x0);\n    }\n\n    function mimic_RiteOf721(uint256 _mimicId) external {\n        (address pokedContract, uint256 matHash) = _riteShared(_mimicId);\n\n        (bool success, bytes memory ownerResult) = pokedContract.staticcall(abi.encodeWithSignature(\"ownerOf(uint256)\", POKED_IDS[_mimicId]));\n        require(success, \"rite of 721 failed\");\n\n        MATURITIES[matHash] = _mimicId;\n\n        cShield.cMimic_Mint(abi.decode(ownerResult, (address)), _mimicId);\n        emit Rite(_mimicId);\n    }\n\n    function mimic_RiteOf1155(uint256 _mimicId, address _ownerOf1155) external {\n        require(_ownerOf1155 != address(0x0), \"nowner!\");\n\n        (address pokedContract, uint256 matHash) = _riteShared(_mimicId);\n\n        (bool success, bytes memory ownershipCountResult) = pokedContract.staticcall(abi.encodeWithSignature(\"balanceOf(address,uint256)\", _ownerOf1155, POKED_IDS[_mimicId]));\n        require(success, \"rite of 1155 failed\");\n        require(abi.decode(ownershipCountResult, (uint256)) > 0, \"not the owner you're looking for\");\n\n        MATURITIES[matHash] = _mimicId;\n\n        cShield.cMimic_Mint(_ownerOf1155, _mimicId);\n        emit Rite(_mimicId);\n    }\n\n    function mimic_SkipIdReplacement(uint256 _mimicId, bool _trueOrFalse) external {\n        require(_isApprovedOrOwner(msg.sender, _mimicId), \"*SLAP*, not your mimic!\");\n\n        SKIP_ID_REPLACEMENT[_mimicId] = _trueOrFalse;\n\n        emit SkipIdReplace(_mimicId, _trueOrFalse);\n    }\n\n    ////\n    // Metadata\n\n    function tokenURI(uint256 _mimicId) public view override returns (string memory) {\n        require(msg.sender.code.length == 0, \"nah!\");\n        require(_exists(_mimicId), \"no such mimic\");\n\n        address pokedContract = POKED_CONTRACTS[_mimicId];\n\n        // juvenile mimic that has not poked\n        if (pokedContract == address(0x0)) {\n            return cMeta.mimicNative(_mimicId, \"\");  // normal eyes\n        }\n\n        uint256 pokedId = POKED_IDS[_mimicId];\n\n        // juvenile mimic that has poked an NFT that is another mimic's maturity NFT\n        uint256 matHash = maturityHash(pokedContract, pokedId);\n        uint256 matHashMimicId = MATURITIES[matHash];\n        if ( (matHashMimicId != _mimicId) && (matHashMimicId != 0x0) ) {\n            return cMeta.mimicNative(_mimicId, \"\");  // normal eyes\n        }\n\n        (bool success, bytes memory uriBytes) = pokedContract.staticcall(abi.encodeWithSignature(\"tokenURI(uint256)\", pokedId));\n        // 721\n        if (success) {\n            if (SKIP_ID_REPLACEMENT[_mimicId]) {\n                return abi.decode(uriBytes, (string));\n            }\n\n            return uriIdReplace(abi.decode(uriBytes, (string)), pokedId);\n        }\n\n        (success, uriBytes) = pokedContract.staticcall(abi.encodeWithSignature(\"uri(uint256)\", pokedId));\n        // 1155\n        if (success) {\n            if (SKIP_ID_REPLACEMENT[_mimicId]) {\n                return abi.decode(uriBytes, (string));\n            }\n\n            return uriIdReplace(abi.decode(uriBytes, (string)), pokedId);\n        }\n\n        // if we get here then that is bad, poor mimic is sick :(\n\n        if (matHashMimicId == _mimicId) {\n            return cMeta.mimicNative(_mimicId, \"X\"); // adult sick eyes (whoops)\n        }\n\n        return cMeta.mimicNative(_mimicId, \"x\"); // juvenile sick eyes\n    }\n\n    ////\n    // Guild Mint\n\n    function cGuild_Mint(address _owner) external {\n        require(msg.sender == aGuild);\n        _mint(_owner, totalSupply() + 1);\n    }\n\n    ////\n    // Lore\n\n    function lore() external view returns (string memory) {\n        return ILore(aGuild).lore();\n    }\n\n    ////\n    // Util\n\n    function uriIdReplace(string memory uri, uint tokenId) internal pure returns (string memory) {\n        bytes memory s = bytes(uri);\n        uint sLen = s.length;\n        if (sLen < 4) {\n            return uri; // can't fit \"{id}\"\n        }\n\n        bytes memory t = uint256ToPaddedBytesHex(tokenId);\n        uint sLenM3 = sLen - 3;\n\n        bytes memory o = bytes(uri);\n\n        uint si = 0;\n        uint oi = 0;\n\n        while (si < sLenM3) {\n            if (s[si] == \"{\" && s[si+1] == \"i\" && s[si+2] == \"d\" && s[si+3] == \"}\") {\n                o = bytes.concat(o, new bytes(60));\n                for (uint ti = 0; ti < 64; ti++) {\n                    o[oi++] = t[ti];\n                }\n                si += 4;\n                break;\n            } else {\n                oi++;\n                si++;\n            }\n        }\n\n        while (si < sLenM3) {\n            if (s[si] == \"{\" && s[si+1] == \"i\" && s[si+2] == \"d\" && s[si+3] == \"}\") {\n                o = bytes.concat(o, new bytes(60));\n                for (uint ti = 0; ti < 64; ti++) {\n                    o[oi++] = t[ti];\n                }\n                si += 4;\n            } else {\n                o[oi++] = s[si++];\n            }\n        }\n\n        while (si < sLen) {\n            o[oi++] = s[si++];\n        }\n\n        return string(o);\n    }\n\n    function uint256ToPaddedBytesHex(uint256 value) internal pure returns (bytes memory) {\n        bytes memory o = new bytes(64);\n        uint256 mask = 0xf; // hex 15\n        uint i = 63;\n        while (true) {\n            uint8 end = uint8(value & mask);\n            if (end < 10) {\n                o[i] = bytes1(end + 48);\n            } else {\n                o[i] = bytes1(end + 87);\n            }\n            value >>= 4;\n            if (i == 0) {\n                break;\n            }\n            i--;\n        }\n        return o;\n    }\n\n    function d() external pure returns (string memory) {\n        return \"Rm9yIG15IGZhdGhlciwgd2hvIG5ldmVyIGNvbXBsYWlucyBhYm91dCBteSBob25vcmFibGUgbWlzY2hpZWYu\";\n    }\n}\n\n"

    },

    "contracts/MimicCustom/Mimic/Combo721Base.sol": {

      "content": "\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\nimport \"../Interfaces/IERC721.sol\";\nimport \"../Interfaces/IERC721Receiver.sol\";\nimport \"../Interfaces/IERC721Metadata.sol\";\nimport \"../Interfaces/IERC721Enumerable.sol\";\nimport \"../Interfaces/IERC165.sol\";\n\n\nabstract contract Combo721Base is IERC165, IERC721, IERC721Metadata, IERC721Enumerable {\n\n    ////\n    // 721 Vanilla - Storage\n\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _approvals;\n    mapping(address => mapping(address => bool)) private _operators; // approved for all owner's tokens\n\n    ////\n    // 721 Metadata - Storage\n\n    string private _name;\n    string private _symbol;\n\n    ////\n    // 721 Enumerable - Storage\n\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n    uint256[] private _allTokens;\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    ////\n    // 165\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId ||\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            interfaceId == type(IERC721Enumerable).interfaceId;\n    }\n\n    // Constructor\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    ////\n    // 721 Metadata\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    ////\n    // 721 Vanilla - Ownership\n\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    function balanceOf(address owner) public view returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    ////\n    // 721 Vanilla - Auth\n\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n        address owner = ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    function approve(address to, uint256 tokenId) public {\n        address owner = ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            msg.sender == owner || isApprovedForAll(owner, msg.sender),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approvals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    function getApproved(uint256 tokenId) public view returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n        return _approvals[tokenId];\n    }\n\n    function setApprovalForAll(address operator, bool approved) public {\n        _operators[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n        return _operators[owner][operator];\n    }\n\n    ////\n    // 721 Vanilla - Transfers\n\n    function safeTransferFrom( address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    function safeTransferFrom( address from, address to, uint256 tokenId, bytes memory _data) public {\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    function transferFrom(address from, address to, uint256 tokenId) public {\n        require( _isApprovedOrOwner(msg.sender, tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal {\n        _transfer(from, to, tokenId);\n        if (to.code.length > 0) {\n            bytes4 ret = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);\n            require(ret == IERC721Receiver.onERC721Received.selector, \"receiver\");\n        }\n    }\n\n    function _transfer( address from, address to, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _innerTransfer(from, to, tokenId);\n\n        _balances[from] -= 1;\n        _approvals[tokenId] = address(0x0);\n    }\n\n    function _innerTransfer(address from, address to, uint256 tokenId) internal {\n        _beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual { }\n\n    ////\n    // 721 Vanilla - Mint\n\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _innerTransfer(address(0), to, tokenId);\n    }\n\n    ////\n    // 721 Enumerable\n\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\n        require(index < balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _allTokens.length;\n    }\n\n    function tokenByIndex(uint256 index) public view returns (uint256) {\n        require(index < totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n\n}\n\n\n"

    },

    "contracts/MimicCustom/Interfaces/ILore.sol": {

      "content": "\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\n\ninterface ILore {\n    function lore() external view returns (string memory);\n}\n\n\n\n\n"

    },

    "contracts/MimicCustom/Mimic/MimicMeta.sol": {

      "content": "\n// SPDX-License-Identifier: MIT\n\n// Initial structure and some code copied from Loot - MIT license\n// https://etherscan.io/address/0xff9c1b15b16263c61d017ee9f65c50e4ae0113d7#code#L1\n\npragma solidity 0.8.11;\n\ncontract MimicMeta {\n\n    address aMimic;\n    address aShield;\n\n    string constant COLOR = \"COLORS\";\n    string constant EYE = \"EYE\";\n    string constant MOUTH = \"MOUTH\";\n    string constant TOOTH = \"TOOTH\";\n\n    string[] private colors = [\n        \"#abffbc\", // forest\n        \"#abffbc\",\n        \"#abffbc\",\n        \"#abffbc\",\n        \"#abffbc\",\n        \"#abfff5\", // sky\n        \"#abfff5\",\n        \"#abfff5\",\n        \"#abfff5\",\n        \"#abfff5\",\n        \"#aaddff\", // sea\n        \"#aaddff\",\n        \"#aaddff\",\n        \"#aaddff\",\n        \"#aaddff\",\n        \"#abb2ff\", // lavender\n        \"#abb2ff\",\n        \"#abb2ff\",\n        \"#abb2ff\",\n        \"#abb2ff\",\n        \"#ffa8a8\", // clay\n        \"#ffa8a8\",\n        \"#ffa8a8\",\n        \"#ffa8a8\",\n        \"#ffa8a8\",\n        \"#ffd2aa\", // wheat\n        \"#ffd2aa\",\n        \"#ffd2aa\",\n        \"#ffd2aa\",\n        \"#ffd2aa\",\n        \"#ffaafa\", // pink\n        \"#ffaafa\",\n        \"#ffaafa\",\n        \"#ffaafa\",\n        \"#ffaafa\",\n        \"#f72585\", // cyber pink\n        \"#f72585\",\n        \"#a025f7\", // cyber purple\n        \"#a025f7\",\n        \"#2538f7\", // cyber blue\n        \"#2538f7\",\n        \"#f5f725\", // cyber yellow\n        \"#f5f725\",\n        \"#27fb6b\", // cyber green\n        \"#27fb6b\",\n        \"#f51000\", // cyber red\n        \"#f51000\",\n        \"#edc531\", // gold\n        \"#dee2e6\", // silver\n        \"#33333a\"  // shadow\n    ];\n\n    string[] private eyes = [\n        \"0\", // 0\n        \"0\",\n        \"0\",\n        \"0\",\n        \"0\",\n        \"0\",\n        \"O\", // O\n        \"O\",\n        \"O\",\n        \"O\",\n        \"O\",\n        \"O\",\n        \"^\", // ^\n        \"^\",\n        \"^\",\n        \"^\",\n        \"^\",\n        \"^\",\n        \"'\", // '\n        \"'\",\n        \"'\",\n        \"'\",\n        \"'\",\n        \"'\",\n        \"~\", // ~\n        \"~\",\n        \"~\",\n        \"~\",\n        \"~\",\n        \"~\",\n        \"-\", // -\n        \"-\",\n        \"-\",\n        \"-\",\n        \"-\",\n        \"-\",\n        \"o\", // o\n        \"o\",\n        \"o\",\n        \"o\",\n        \"o\",\n        \"o\",\n        \"#\", // #\n        \"@\", // @\n        \"$\"  // $\n    ];\n\n    string[] private left_mouths = [\n        \"[\",  // [\n        \"[\",\n        \"(\",  // (\n        \"(\",\n        \"{\",  // {\n        \"{\",\n        \"\\\\\", // \\\n        \":\"   // :\n    ];\n\n    string[] private right_mouths = [\n        \"]\", // ]\n        \"]\",\n        \")\", // }\n        \")\",\n        \"}\", // }\n        \"}\",\n        \"/\", // /\n        \":\"  // :\n    ];\n\n    string[] private teeth = [\n        \"=\",\n        \"_\",\n        \".\"\n    ];\n\n    function init(address _mimic, address _shield) external {\n        require(aMimic == address(0x0));\n        aMimic = _mimic;\n        aShield = _shield;\n    }\n\n    function randomUS(uint256 input, string memory input2) internal pure returns (uint) {\n        return uint256(keccak256(abi.encodePacked(input, input2)));\n    }\n\n    function pluck(uint256 tokenId, string memory keyPrefix, string[] memory sourceArray) internal pure returns (string memory) {\n        uint256 rand = randomUS(tokenId, keyPrefix);\n        string memory output = sourceArray[rand % sourceArray.length];\n        return output;\n    }\n\n    ////\n    // Mimic\n\n    function mimicNative(uint256 _tokenId, string calldata _eye) external view returns (string memory output) {\n        require(msg.sender == aMimic);\n        string memory tidString = uintToString(_tokenId);\n        string memory json = Base64.encodeNew(bytes(string(abi.encodePacked(\n            '{',\n                '\"name\": \"Mimic #',\n                    tidString,\n                '\",'\n                '\"description\": \"Mimic #',\n                    tidString,\n                    '\\\\n\\\\n'\n                    'Mimics are mischeivous but honorable digital creatures that live deep within the ethereum blockchain.'\n                    '\\\\n\\\\n'\n                    'They are known to interact in interesting ways with other NFTs from throughout the ethereum ecosystem.'\n                '\",'\n                '\"image\": \"data:image/svg+xml;base64,',\n                    Base64.encodeNew(bytes(imageFace(_tokenId, _eye))),\n                '\"'\n            '}'\n        ))));\n        output = string(abi.encodePacked('data:application/json;base64,', json));\n    }\n\n    function imageFace(uint256 _mimicId, string memory _eye) internal view returns (string memory) {\n        string memory color = pluck(_mimicId, COLOR, colors);\n        if (bytes(_eye).length == 0) {\n            _eye = pluck(_mimicId, EYE, eyes);\n        }\n        string memory tooth = pluck(_mimicId, TOOTH, teeth);\n        uint256 rand_mouth = randomUS(_mimicId, MOUTH) % left_mouths.length;\n\n        return string(abi.encodePacked(\n            '<svg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"xMinYMin meet\" viewBox=\"0 0 350 350\">'\n                '<style>'\n                    '.base { fill: ', color, '; font-family: monospace; text-anchor: middle; font-size: 80px; } '\n                    '@keyframes glow { 0% { opacity: 0.2; } 3% { opacity: 0.9; } 30% { opacity: 0.2 } 70% {opacity: 0.9} } '\n                    '.face { animation: glow 3s linear infinite alternate } '\n                    '.f1 { animation-delay: 0.5s } '\n                    '.f2 { animation-delay: 1.5s } '\n                    '.f3 { animation-delay: 0.7s } '\n                    '.f4 { animation-delay: 2.5s } '\n                    '.f5 { animation-delay: 0.3s } '\n                    '.f6 { animation-delay: 2.2s } '\n                    '.d1 { animation-duration: 2.7s } '\n                    '.d2 { animation-duration: 2.8s } '\n                    '.d3 { animation-duration: 2.9s } '\n                    '.d4 { animation-duration: 3.0s } '\n                    '.d5 { animation-duration: 3.1s } '\n                    '.d6 { animation-duration: 3.2s } '\n                    '.d7 { animation-duration: 3.3s } '\n                '</style>'\n                '<rect width=\"100%\" height=\"100%\" fill=\"black\" />'\n                '<text x=\"100\" y=\"130\" class=\"base face f1 d1\">',\n                _eye,\n                '</text>'\n                '<text x=\"250\" y=\"130\" class=\"base face f2 d2\">',\n                _eye,\n                '</text>'\n                '<text x=\"100\" y=\"260\" class=\"base face f3 d3\">',\n                left_mouths[rand_mouth],\n                '</text>'\n                '<text x=\"150\" y=\"260\" class=\"base face f4 d4\">',\n                tooth,\n                '</text>'\n                '<text x=\"200\" y=\"260\" class=\"base face f5 d5\">',\n                tooth,\n                '</text>'\n                '<text x=\"250\" y=\"260\" class=\"base face f6 d6\">',\n                right_mouths[rand_mouth],\n                '</text>'\n                '<rect class=\"face d7\" width=\"100%\" height=\"100%\" fill=\"#000000ee\" />'\n            '</svg>'\n        ));\n    }\n\n    ////\n    // Shield\n\n    function shieldNative(uint256 _tokenId, bool _active) external view returns (string memory output) {\n        require(msg.sender == aShield);\n        string memory tidString = uintToString(_tokenId);\n        string memory aura;\n        if (_active) {\n            aura = \"Active\";\n        } else {\n            aura = \"Inactive\";\n        }\n        string memory json = Base64.encodeNew(bytes(string(abi.encodePacked(\n            '{',\n                '\"name\": \"Mimic Shield #',\n                    tidString,\n                '\",'\n                '\"description\": \"Mimic Shield #',\n                    tidString,\n                    '\\\\n\\\\n'\n                    'A Mimic Shield is the reified character of a mimic that has undertaken a sacred rite to become an adult.'\n                    '\\\\n\\\\n'\n                    \"The aura of a shield is of great significance to mimics and their ritual practice.\"\n                '\",'\n                '\"attributes\": [{ \"trait_type\": \"Aura\", \"value\": \"',\n                    aura,\n                '\"}],'\n                '\"image\": \"data:image/svg+xml;base64,',\n                    Base64.encodeNew(bytes(imageShield(_tokenId, _active))),\n                '\"'\n            '}'\n        ))));\n        output = string(abi.encodePacked('data:application/json;base64,', json));\n    }\n\n    function imageShield(uint256 _mimicId, bool _active) internal view returns (string memory) {\n        string memory color = pluck(_mimicId, COLOR, colors);\n        string memory aura = shieldAura(_active);\n\n        return string(abi.encodePacked(\n            '<svg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"xMinYMin meet\" viewBox=\"0 0 350 350\">'\n                '<style>'\n                    '.base { fill: ', color, '; font-family: monospace; text-anchor: middle; font-size: 30px; }'\n                    '@keyframes glow { 0% { opacity: 0.4; } 3% { opacity: 0.9; } 30% { opacity: 0.4 } 70% {opacity: 0.9} }'\n                    '@keyframes rx {0% { transform: translateX(11px) } 2% { transform: translateX(83px) } 3% { transform: translateX(227px) } 4% { transform: translateX(19px) } 5% { transform: translateX(160px) } 6% { transform: translateX(252px) } 7% { transform: translateX(177px) } 8% { transform: translateX(64px) } 9% { transform: translateX(317px) } 10% { transform: translateX(192px) } 11% { transform: translateX(310px) } 12% { transform: translateX(92px) } 13% { transform: translateX(184px) } 14% { transform: translateX(248px) } 15% { transform: translateX(64px) } 16% { transform: translateX(205px) } 17% { transform: translateX(243px) } 18% { transform: translateX(11px) } 19% { transform: translateX(348px) } 20% { transform: translateX(232px) } 21% { transform: translateX(191px) } 22% { transform: translateX(313px) } 23% { transform: translateX(154px) } 24% { transform: translateX(4px) } 25% { transform: translateX(105px) } 26% { transform: translateX(140px) } 27% { transform: translateX(229px) } 28% { transform: translateX(262px) } 29% { transform: translateX(200px) } 30% { transform: translateX(107px) } 31% { transform: translateX(30px) } 32% { transform: translateX(193px) } 33% { transform: translateX(105px) } 34% { transform: translateX(222px) } 35% { transform: translateX(64px) } 36% { transform: translateX(285px) } 37% { transform: translateX(224px) } 38% { transform: translateX(96px) } 39% { transform: translateX(284px) } 40% { transform: translateX(32px) } 41% { transform: translateX(216px) } 42% { transform: translateX(273px) } 43% { transform: translateX(28px) } 44% { transform: translateX(6px) } 45% { transform: translateX(303px) } 46% { transform: translateX(177px) } 47% { transform: translateX(145px) } 48% { transform: translateX(103px) } 49% { transform: translateX(85px) } 50% { transform: translateX(342px) } 51% { transform: translateX(201px) } 52% { transform: translateX(321px) } 53% { transform: translateX(152px) } 54% { transform: translateX(204px) } 55% { transform: translateX(267px) } 56% { transform: translateX(19px) } 57% { transform: translateX(137px) } 58% { transform: translateX(1px) } 59% { transform: translateX(314px) } 60% { transform: translateX(174px) } 61% { transform: translateX(143px) } 62% { transform: translateX(132px) } 63% { transform: translateX(130px) } 64% { transform: translateX(219px) } 65% { transform: translateX(281px) } 66% { transform: translateX(272px) } 67% { transform: translateX(244px) } 68% { transform: translateX(311px) } 69% { transform: translateX(110px) } 70% { transform: translateX(59px) } 71% { transform: translateX(72px) } 72% { transform: translateX(285px) } 73% { transform: translateX(296px) } 74% { transform: translateX(319px) } 75% { transform: translateX(96px) } 76% { transform: translateX(192px) } 77% { transform: translateX(293px) } 78% { transform: translateX(26px) } 79% { transform: translateX(174px) } 80% { transform: translateX(246px) } 81% { transform: translateX(276px) } 82% { transform: translateX(255px) } 83% { transform: translateX(298px) } 84% { transform: translateX(137px) } 85% { transform: translateX(296px) } 86% { transform: translateX(112px) } 87% { transform: translateX(32px) } 88% { transform: translateX(66px) } 89% { transform: translateX(288px) } 90% { transform: translateX(76px) } 91% { transform: translateX(116px) } 92% { transform: translateX(158px) } 93% { transform: translateX(280px) } 94% { transform: translateX(161px) } 95% { transform: translateX(81px) } 96% { transform: translateX(260px) } 97% { transform: translateX(185px) } 98% { transform: translateX(213px) } 99% { transform: translateX(102px) } 100% { transform: translateX(160px) }}'\n                    '@keyframes ry {0% { transform: translateY(41px) } 1% { transform: translateY(320px) } 2% { transform: translateY(239px) } 3% { transform: translateY(220px) } 4% { transform: translateY(158px) } 5% { transform: translateY(301px) } 6% { transform: translateY(335px) } 8% { transform: translateY(39px) } 9% { transform: translateY(171px) } 10% { transform: translateY(305px) } 11% { transform: translateY(148px) } 12% { transform: translateY(152px) } 13% { transform: translateY(168px) } 14% { transform: translateY(178px) } 15% { transform: translateY(57px) } 16% { transform: translateY(94px) } 17% { transform: translateY(307px) } 18% { transform: translateY(19px) } 19% { transform: translateY(249px) } 20% { transform: translateY(48px) } 21% { transform: translateY(332px) } 22% { transform: translateY(234px) } 23% { transform: translateY(302px) } 24% { transform: translateY(139px) } 25% { transform: translateY(255px) } 26% { transform: translateY(80px) } 27% { transform: translateY(184px) } 28% { transform: translateY(87px) } 29% { transform: translateY(337px) } 30% { transform: translateY(83px) } 31% { transform: translateY(204px) } 32% { transform: translateY(182px) } 33% { transform: translateY(348px) } 34% { transform: translateY(285px) } 35% { transform: translateY(273px) } 36% { transform: translateY(273px) } 37% { transform: translateY(99px) } 38% { transform: translateY(206px) } 39% { transform: translateY(217px) } 40% { transform: translateY(345px) } 41% { transform: translateY(329px) } 42% { transform: translateY(128px) } 43% { transform: translateY(61px) } 44% { transform: translateY(79px) } 45% { transform: translateY(302px) } 46% { transform: translateY(153px) } 47% { transform: translateY(98px) } 48% { transform: translateY(294px) } 49% { transform: translateY(189px) } 50% { transform: translateY(347px) } 51% { transform: translateY(20px) } 52% { transform: translateY(300px) } 53% { transform: translateY(216px) } 54% { transform: translateY(285px) } 55% { transform: translateY(72px) } 56% { transform: translateY(53px) } 57% { transform: translateY(178px) } 58% { transform: translateY(292px) } 59% { transform: translateY(340px) } 60% { transform: translateY(273px) } 61% { transform: translateY(197px) } 62% { transform: translateY(71px) } 63% { transform: translateY(279px) } 64% { transform: translateY(247px) } 65% { transform: translateY(120px) } 66% { transform: translateY(22px) } 67% { transform: translateY(20px) } 68% { transform: translateY(217px) } 69% { transform: translateY(12px) } 70% { transform: translateY(246px) } 71% { transform: translateY(219px) } 72% { transform: translateY(347px) } 73% { transform: translateY(252px) } 74% { transform: translateY(155px) } 75% { transform: translateY(290px) } 76% { transform: translateY(163px) } 77% { transform: translateY(132px) } 78% { transform: translateY(146px) } 79% { transform: translateY(121px) } 80% { transform: translateY(227px) } 81% { transform: translateY(189px) } 82% { transform: translateY(311px) } 83% { transform: translateY(243px) } 84% { transform: translateY(83px) } 85% { transform: translateY(59px) } 86% { transform: translateY(44px) } 87% { transform: translateY(75px) } 88% { transform: translateY(312px) } 89% { transform: translateY(161px) } 90% { transform: translateY(31px) } 91% { transform: translateY(310px) } 92% { transform: translateY(119px) } 93% { transform: translateY(292px) } 94% { transform: translateY(187px) } 95% { transform: translateY(176px) } 96% { transform: translateY(20px) } 97% { transform: translateY(312px) } 98% { transform: translateY(342px) } 99% { transform: translateY(47px) } 100% { transform: translateY(336px) }}'\n                    '.aura { animation: glow 5s ease infinite alternate-reverse }'\n                    '.shield { opacity: 0.6 }'\n                    '.xv { animation-name: rx; animation-timing-function: step-end; animation-iteration-count: infinite; }'\n                    '.yv { animation: ry 87s step-end infinite }'\n                    '.t { transform: rotateY(260deg) }'\n                    '.f1 { animation-delay: -0.5s }'\n                    '.f2 { animation-delay: -10.5s }'\n                    '.f3 { animation-delay: -15.7s }'\n                    '.f4 { animation-delay: -32.5s }'\n                    '.f5 { animation-delay: -37.3s }'\n                    '.f6 { animation-delay: -32.2s }'\n                    '.a1 { animation-duration: 31.11s }'\n                    '.a2 { animation-duration: 37.91s }'\n                    '.a3 { animation-duration: 42.31s }'\n                    '.a4 { animation-duration: 47.71s }'\n                    '.a5 { animation-duration: 131.11s }'\n                    '.a6 { animation-duration: 141.01s }'\n                '</style>'\n                '<defs>'\n                    '<radialGradient id=\"rgaura\">'\n                        '<stop offset=\"30%\" stop-color=\"transparent\" />'\n                        '<stop offset=\"70%\" stop-color=\"',\n                        color,\n                        '\" stop-opacity=\"0.30\" />'\n                    '</radialGradient>'\n                '</defs>'\n                '<rect width=\"100%\" height=\"100%\" fill=\"111111\" />',\n                shieldFeatures(_mimicId),\n                '<rect class=\"aura a4\" x=\"0%\" y=\"0\" width=\"100%\" height=\"100%\" fill=\"#aaddff11\" />',\n                aura,\n                '<g transform=\"translate(175, 175)\">', shield(_mimicId, color), '</g>'\n            '</svg>'\n        ));\n    }\n\n    function shieldFeatures(uint256 _mimicId) internal view returns (string memory) {\n        string memory eye = pluck(_mimicId, EYE, eyes);\n        string memory tooth = pluck(_mimicId, TOOTH, teeth);\n        uint256 rand_mouth = randomUS(_mimicId, MOUTH) % left_mouths.length;\n\n        return string(abi.encodePacked(\n            '<g class=\"xv f2 a1\"><g class=\"yv f1 a3\"><text class=\"base aura f1\">', eye, '</text></g></g>'\n            '<g class=\"xv f4 a2\"><g class=\"yv f3 a4\"><text class=\"base aura f3\">', eye, '</text></g></g>'\n            '<g class=\"xv f3 a3\"><g class=\"yv f4 a5\"><text class=\"base aura f2\">', left_mouths[rand_mouth], '</text></g></g>'\n            '<g class=\"xv f1 a4\"><g class=\"yv f2 a6\"><text class=\"base aura f4\">', tooth, '</text></g></g>'\n            '<g class=\"xv f5 a5\"><g class=\"yv f2 a1\"><text class=\"base aura f2\">', tooth, '</text></g></g>'\n            '<g class=\"xv f2 a6\"><g class=\"yv f5 a2\"><text class=\"base aura f5\">', right_mouths[rand_mouth], '</text></g></g>'\n        ));\n    }\n\n    function shieldAura(bool _active) internal pure returns (string memory) {\n        if (_active) {\n            return '<rect width=\"200%\" height=\"200%\" x=\"-175\" y=\"-175\" fill=\"url(#rgaura)\" />';\n        }\n        return \"\";\n    }\n\n    function shield(uint256 _mimicId, string memory _color) internal pure returns (string memory) {\n        string memory vdx = uintToString((randomUS(_mimicId, \"VDX\") % 100)+25);\n        string memory vdy = uintToString((randomUS(_mimicId, \"VDY\") % 100)+25);\n        string memory vvx = uintToString((randomUS(_mimicId, \"VVX\") % 100)+25);\n        string memory hdx = uintToString((randomUS(_mimicId, \"HDX\") % 100)+25);\n        string memory hdy = uintToString((randomUS(_mimicId, \"HDY\") % 100)+25);\n        string memory hhy = uintToString((randomUS(_mimicId, \"HHY\") % 100)+25);\n\n        return string(abi.encodePacked(\n            poly1(_color, vdx, vdy, vvx),\n            poly2(_color, vdx, vdy, vvx),\n            poly3(_color, hdx, hdy, hhy),\n            poly4(_color, hdx, hdy, hhy)\n        ));\n    }\n\n    function poly1(string memory _color, string memory _x, string memory _y, string memory _z) internal pure returns (string memory) {\n        return string(abi.encodePacked(\n            '<polygon fill=\"', _color, '\" class=\"shield aura f2 a1\" points=\"0,0 ', _x, ',-', _y, ' 0,-', _z, ' -', _x, ',-', _y, '\" />'\n        ));\n    }\n\n    function poly2(string memory _color, string memory _x, string memory _y, string memory _z) internal pure returns (string memory) {\n        return string(abi.encodePacked(\n            '<polygon fill=\"', _color, '\" class=\"shield aura f3 a2\" points=\"0,0 ', _x, ',', _y, ' 0,', _z, ' -', _x, ',', _y, '\" />'\n        ));\n    }\n\n    function poly3(string memory _color, string memory _x, string memory _y, string memory _z) internal pure returns (string memory) {\n        return string(abi.encodePacked(\n            '<polygon fill=\"', _color, '\" class=\"shield aura f4 a3\" points=\"0,0 ', _x, ',', _y, ' ', _z, ',0 ', _x, ',-', _y, '\" />'\n        ));\n    }\n\n    function poly4(string memory _color, string memory _x, string memory _y, string memory _z) internal pure returns (string memory) {\n        return string(abi.encodePacked(\n            '<polygon fill=\"', _color, '\" class=\"shield aura f5 a4\" points=\"0,0 -', _x, ',', _y, ' -', _z, ',0 -', _x, ',-', _y, '\" />'\n        ));\n    }\n\n    function uintToString(uint256 value) internal pure returns (string memory) {\n    // Inspired by OraclizeAPI's implementation - MIT license\n    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n}\n\n/// [MIT License]\n/// @title Base64\n/// @notice Provides a function for encoding some bytes in base64\n/// @author Brecht Devos <brecht@loopring.org>\nlibrary Base64 {\n    string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n    function encodeNew(bytes memory data) internal pure returns (string memory) {\n        if (data.length == 0) return '';\n\n        // load the table into memory\n        string memory table = TABLE_ENCODE;\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n\n        // add some extra buffer at the end required for the writing\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            // set the actual output length\n            mstore(result, encodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 3 bytes at a time\n            for {} lt(dataPtr, endPtr) {}\n            {\n                // read 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // write 4 characters\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))\n                resultPtr := add(resultPtr, 1)\n            }\n\n            // padding with '='\n            switch mod(mload(data), 3)\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\n        }\n\n        return result;\n    }\n}\n\n"

    },

    "contracts/MimicCustom/Mimic/CoreShield.sol": {

      "content": "\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\nimport { ILore } from \"../Interfaces/ILore.sol\";\n\nimport { MimicMeta } from \"./MimicMeta.sol\";\nimport { Combo721Base } from \"./Combo721Base.sol\";\n\nabstract contract CoreShield is Combo721Base {\n    address aGuild;\n    address aMimic;\n    MimicMeta cMeta;\n\n    mapping(uint256 => bool) ACTIVE;\n    mapping(address => uint256) ACTIVE_BALANCES;\n\n    string internal constant NOT_SHIELD_OWNER = \"you do not own this this shield\";\n\n    event Activation(uint256 indexed _shieldId, bool _active);\n\n    function init(address _guild, address _mimic, address _meta) external {\n        require(aMimic == address(0x0), \"already initialized\");\n        aGuild = _guild;\n        aMimic = _mimic;\n        cMeta = MimicMeta(_meta);\n    }\n\n    function cMimic_Mint(address _recipient, uint256 _mimicId) external {\n        require(msg.sender == aMimic, \"can't touch this\");\n        _mint(_recipient, _mimicId);\n    }\n\n    function tokenURI(uint256 _shieldId) public view override returns (string memory) {\n        require(msg.sender.code.length == 0, \"nope\");\n        require(_exists(_shieldId));\n        return cMeta.shieldNative(_shieldId, ACTIVE[_shieldId]);\n    }\n\n    ////\n    // ACTIVATIONS\n\n    function activeCount(address _owner) external view returns (uint256) {\n        return ACTIVE_BALANCES[_owner];\n    }\n\n    function shield_Activate(uint256 _shieldId) external {\n        require(_isApprovedOrOwner(msg.sender, _shieldId), NOT_SHIELD_OWNER);\n        require(!ACTIVE[_shieldId], \"Mimic Shield: aura is already active\");\n        ACTIVE[_shieldId] = true;\n        ACTIVE_BALANCES[msg.sender] += 1;\n        emit Activation(_shieldId, true);\n    }\n\n    function shield_Deactivate(uint256 _shieldId) external {\n        require(_isApprovedOrOwner(msg.sender, _shieldId), NOT_SHIELD_OWNER);\n        require(ACTIVE[_shieldId], \"Mimic Shield: aura is already inactive\");\n        delete ACTIVE[_shieldId];\n        ACTIVE_BALANCES[msg.sender] -= 1;\n        emit Activation(_shieldId, false);\n    }\n\n    function _beforeTokenTransfer(address _from, address _to, uint256 _tokenId) internal override {\n        super._beforeTokenTransfer(_from, _to, _tokenId);\n        if (ACTIVE[_tokenId]) {\n            ACTIVE_BALANCES[_from] -= 1;\n            ACTIVE_BALANCES[_to] += 1;\n        }\n    }\n\n    ////\n    // Lore\n\n    function lore() external view returns (string memory) {\n        return ILore(aGuild).lore();\n    }\n}"

    },

    "contracts/MimicCustom/Interfaces/IERC721.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\n/// @title ERC-721 Non-Fungible Token Standard\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\ninterface IERC721 /* is ERC165 */ {\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\n    ///  may be created and assigned without emitting Transfer. At the time of\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n\n    /// @dev This emits when the approved address for an NFT is changed or\n    ///  reaffirmed. The zero address indicates there is no approved address.\n    ///  When a Transfer event emits, this also indicates that the approved\n    ///  address for that NFT (if any) is reset to none.\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n\n    /// @dev This emits when an operator is enabled or disabled for an owner.\n    ///  The operator can manage all NFTs of the owner.\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n    /// @notice Count all NFTs assigned to an owner\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\n    ///  function throws for queries about the zero address.\n    /// @param _owner An address for whom to query the balance\n    /// @return The number of NFTs owned by `_owner`, possibly zero\n    function balanceOf(address _owner) external view returns (uint256);\n\n    /// @notice Find the owner of an NFT\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\n    ///  about them do throw.\n    /// @param _tokenId The identifier for an NFT\n    /// @return The address of the owner of the NFT\n    function ownerOf(uint256 _tokenId) external view returns (address);\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\n    ///  `onERC721Received` on `_to` and throws if the return value is not\n    ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    /// @param data Additional data with no specified format, sent in call to `_to`\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external;\n\n    /// @notice Transfers the ownership of an NFT from one address to another address\n    /// @dev This works identically to the other function with an extra data parameter,\n    ///  except this function just sets data to \"\".\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;\n\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n    ///  THEY MAY BE PERMANENTLY LOST\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n    ///  `_tokenId` is not a valid NFT.\n    /// @param _from The current owner of the NFT\n    /// @param _to The new owner\n    /// @param _tokenId The NFT to transfer\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\n\n    /// @notice Change or reaffirm the approved address for an NFT\n    /// @dev The zero address indicates there is no approved address.\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\n    ///  operator of the current owner.\n    /// @param _approved The new approved NFT controller\n    /// @param _tokenId The NFT to approve\n    function approve(address _approved, uint256 _tokenId) external;\n\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\n    ///  all of `msg.sender`'s assets\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\n    ///  multiple operators per owner.\n    /// @param _operator Address to add to the set of authorized operators\n    /// @param _approved True if the operator is approved, false to revoke approval\n    function setApprovalForAll(address _operator, bool _approved) external;\n\n    /// @notice Get the approved address for a single NFT\n    /// @dev Throws if `_tokenId` is not a valid NFT.\n    /// @param _tokenId The NFT to find the approved address for\n    /// @return The approved address for this NFT, or the zero address if there is none\n    function getApproved(uint256 _tokenId) external view returns (address);\n\n    /// @notice Query if an address is an authorized operator for another address\n    /// @param _owner The address that owns the NFTs\n    /// @param _operator The address that acts on behalf of the owner\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}"

    },

    "contracts/MimicCustom/Interfaces/IERC721Receiver.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\ninterface IERC721Receiver {\n    /// @notice Handle the receipt of an NFT\n    /// @dev The ERC721 smart contract calls this function on the recipient\n    ///  after a `transfer`. This function MAY throw to revert and reject the\n    ///  transfer. Return of other than the magic value MUST result in the\n    ///  transaction being reverted.\n    ///  Note: the contract address is always the message sender.\n    /// @param _operator The address which called `safeTransferFrom` function\n    /// @param _from The address which previously owned the token\n    /// @param _tokenId The NFT identifier which is being transferred\n    /// @param _data Additional data with no specified format\n    /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    ///  unless throwing\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\n}"

    },

    "contracts/MimicCustom/Interfaces/IERC721Metadata.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity 0.8.11;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"

    },

    "contracts/MimicCustom/Interfaces/IERC721Enumerable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"

    },

    "contracts/MimicCustom/Interfaces/IERC165.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceID The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}"

    }

  },

  "settings": {

    "optimizer": {

      "enabled": false,

      "runs": 200

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "libraries": {}

  }

}}