/**
 *Submitted for verification at Etherscan.io on 2022-09-11
*/

// SPDX-License-Identifier: UNLICENSED
// © 2022 Legends of the FirstBorne. All rights reserved. www.thefirstborne.wtf
/*


.____     ___________ ___________________ _______  ________    _________                           
|    |    \_   _____//  _____/\_   _____/ \      \ \______ \  /   _____/                           
|    |     |    __)_/   \  ___ |    __)_  /   |   \ |    |  \ \_____  \                            
|    |___  |        \    \_\  \|        \/    |    \|    `   \/        \                           
|_______ \/_______  /\______  /_______  /\____|__  /_______  /_______  /                           
        \/        \/        \/        \/         \/        \/        \/                            
________  ___________    ______________ ______________                                                
\_____  \ \_   _____/    \__    ___/   |   \_   _____/                                                
 /   |   \ |    __)        |    | /    ~    \    __)_                                                 
/    |    \|     \         |    | \    Y    /        \                                                
\_______  /\___  /         |____|  \___|_  /_______  /                                                
        \/     \/                        \/        \/                                                 
___________._____________  ______________________________ ________ __________  _______  ___________
\_   _____/|   \______   \/   _____/\__    ___/\______   \\_____  \\______   \ \      \ \_   _____/
 |    __)  |   ||       _/\_____  \   |    |    |    |  _/ /   |   \|       _/ /   |   \ |    __)_ 
 |     \   |   ||    |   \/        \  |    |    |    |   \/    |    \    |   \/    |    \|        \
 \___  /   |___||____|_  /_______  /  |____|    |______  /\_______  /____|_  /\____|__  /_______  /
     \/                \/        \/                    \/         \/       \/         \/        \/ 


------------------------------------------
CHAPTER ONE: The Blasphemous Incursion
------------------------------------------

The sun fell, bleeding a crimson pall over a tranquil sky. Winged explorers rested safely in their nests, the cool of night spreading like a tsunami, covering the forests, the plains, in a blanket of mist, a shroud of peace. Distant stars shared their incandescence, light years away, watching solemnly as the land, the world moved through its rhythms, its seasons. The magic of the FirstBorne, the spirit that had breathed this world into being, permeated all, the very air, watching, moving, waiting. 
   
A guttural scream shattered the night calm, sending small forest dwellers scurrying terrified for their burrows. Creatures within earshot shuddered, knowing viscerally that one of their own was to meet its end. A blood trail betrayed the location of the hunted, a luminous trickle of ethereal life glowing weakly against the razor-sharp volcanic crag. The broken body of a sprite lay quivering inside the entrance of a cave, its former radiance all but gone. 

The hunter, a garnasta, hadn’t bothered hiding its prideful gasconade of victory - snarling, growling, it exuded a toxic arrogance as it paced slowly and smugly up to the cave.

The sprite had a name, and a life once celebrated and enjoyed. It hadn’t sought out this fate. Its purpose had always been to connect the bumbling forest floor fauna to a greater meaning. For much of its life, it had danced in the morning dew, whilst clumsy snirklons rooted among the leaves for mucus-covered worms, rousing all who could hear to the knowledge of the FirstBorne magic. It had flittered among the branches of the Pharonn trees during the day, proselytizing to all who would listen, sensing the deep magic that had knit together the very world itself, whilst the simple and happily ignorant creatures, both small and very small, kept following their daily routines. 

It had friends: other sprites, some of the owls, the occasional ancient treefolk known for communing with other sentient beings. It had a gentle willingness to embrace the smaller ones who scampered beneath the feet of the fantastical inhabitants of this strange land. The lambent child-like creature glowed a myriad of hues, a warmth that fluctuated, as its mood flickered between love, curiosity and revere.

And so, from a life of peace and praise, this sprite was unprepared for the overwhelming violence that had confronted it the previous day. As it had gazed in wonder upon the iridescent glow of the morning mist from the Great Auel waterfalls, a jagged slime-covered boulder crashed into its ribs, sending the sprite plummeting down amongst the foliage surrounding the edge of the southern shore of the pool that received this waterfall’s thunderous outpouring. The sprite’s body immediately burned a savage red in pain and anger, an emotion it knew little of, before relenting finally to a trembling pale yellow. 

The victorious grunts and gnarring from the garnasta who had committed the foul, unprovoked attack seemed to sour the air. The ground itself convulsed, as if in revulsion at the presence of this vile intruder. The sprite had attempted with some success to subdue its luminescence, searching for refuge within the welcoming verdure, as it tried vainly to comprehend the source, the nature of the attack. 

And so the pursuit had continued, through the day, into the night, along sympathetic forest trails, ancient ravenes, through merciless thorn-berry fields, until the sprite finally lost its way and became trapped within the cave entrance. Whimpering, struggling to breathe, its chest heaving with the fear of impending finality, the trembling messenger of hope and wonder listened in horror, as a blade was dragged amongst the boulders littering the rocky ground that surrounded the cave mouth.

There seemed to be no purpose to what had occurred. No grudge, revenge or comeuppance. The sprite knew of the garnasta species, but had never imagined meeting one. Such ruination, such immense creatures of violence and senseless destruction, dwelling far beneath the sun-lit world, in caverns and tunnels, in the bowels of the land. Initially offspring of insane Gargantua and rabid goblins, the foul interbreeding had been whispered in quiet conversations, and briefly mentioned in ancient scrolls, but the sprite had never believed it would one day meet such a nightmare. 

And so the end would come. The blade scraped harshly over the volcanic scree, screeching. The sprite rested its head on the abrasive scoria, its skin almost translucent, as hope fled its plaintive heart. No tears left, bloodshot eyes slowly closed as the garnasta’s brutish head raised up and over the final boulder to view its forlorn prize.      

Squinting its sunken, beady eyes, it could barely make out the lithe body of its prey. The dark cave seemed to stare ominously at this sacrilegious act taking place. The blade almost appeared redundant, yet the bloodlust of this fallen monstrosity kept its call, and to it, this creature happily obeyed. Lifting the instrument of death, the garnasta reached in, sniggering, as its goal lay within reach. 

And so, between the mockery, and the blade’s horrendous scraping through the rocks, this formidable hunter’s ears were deaf to its own impending doom. Deep within the cave, the furious eyes of the protector, the upholder of the wylde law, burned as it gazed upon this blasphemy. This abhorrence, this tumultuous torrent of evil being expressed, brought forth an unrelenting rage. Rising up to its full height, nearly ten feet high, and spreading its feathered wings with a deadly flourish, its blade-like claws released their grip on a well worn boulder, as holy retribution coursed through the guardian’s veins. 

As the garnasta’s muscle laden arm propelled its encrusted blade through the air towards the sprite’s prone body, it felt a shift in the cave air, but was too slow to react, as an immense wall of fury collided with its chest. 


*/

// File: @openzeppelin/contracts/utils/cryptography/MerkleProof.sol
// OpenZeppelin Contracts (last updated v4.6.0) (utils/cryptography/MerkleProof.sol)

pragma solidity ^0.8.0;

library MerkleProof {

    function verify(
        bytes32[] memory proof,
        bytes32 root,
        bytes32 leaf
    ) internal pure returns (bool) {
        return processProof(proof, leaf) == root;
    }

    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {
        bytes32 computedHash = leaf;
        for (uint256 i = 0; i < proof.length; i++) {
            bytes32 proofElement = proof[i];
            if (computedHash <= proofElement) {
                // Hash(current computed hash + current element of the proof)
                computedHash = _efficientHash(computedHash, proofElement);
            } else {
                // Hash(current element of the proof + current computed hash)
                computedHash = _efficientHash(proofElement, computedHash);
            }
        }
        return computedHash;
    }

    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {
        assembly {
            mstore(0x00, a)
            mstore(0x20, b)
            value := keccak256(0x00, 0x40)
        }
    }
}

// File: @openzeppelin/contracts/utils/Strings.sol


// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)

pragma solidity ^0.8.0;


library Strings {
    bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";


    function toString(uint256 value) internal pure returns (string memory) {
        // Inspired by OraclizeAPI's implementation - MIT licence
        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol

        if (value == 0) {
            return "0";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }


    function toHexString(uint256 value) internal pure returns (string memory) {
        if (value == 0) {
            return "0x00";
        }
        uint256 temp = value;
        uint256 length = 0;
        while (temp != 0) {
            length++;
            temp >>= 8;
        }
        return toHexString(value, length);
    }


    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
        bytes memory buffer = new bytes(2 * length + 2);
        buffer[0] = "0";
        buffer[1] = "x";
        for (uint256 i = 2 * length + 1; i > 1; --i) {
            buffer[i] = _HEX_SYMBOLS[value & 0xf];
            value >>= 4;
        }
        require(value == 0, "Strings: hex length insufficient");
        return string(buffer);
    }
}

// File: @openzeppelin/contracts/utils/Context.sol

//  ───────█████████████████████
//  ────████▀─────────────────▀████
//  ──███▀───────────────────────▀███
//  ─██▀───────────────────────────▀██
//  █▀───────────────────────────────▀█
//  █─────────────────────────────────█
//  █─────────────────────────────────█
//  █─────────────────────────────────█
//  █───█████─────────────────█████───█
//  █──██▓▓▓███─────────────███▓▓▓██──█
//  █──██▓▓▓▓▓██───────────██▓▓▓▓▓██──█
//  █──██▓▓▓▓▓▓██─────────██▓▓▓▓▓▓██──█
//  █▄──████▓▓▓▓██───────██▓▓▓▓████──▄█
//  ▀█▄───▀███▓▓▓██─────██▓▓▓███▀───▄█▀
//  ──█▄────▀█████▀─────▀█████▀────▄█
//  ─▄██───────────▄█─█▄───────────██▄
//  ─███───────────██─██───────────███
//  ─███───────────────────────────███
//  ──▀██──██▀██──█──█──█──██▀██──██▀
//  ───▀████▀─██──█──█──█──██─▀████▀
//  ────▀██▀──██──█──█──█──██──▀██▀
//  ──────────██──█──█──█──██
//  ──────────██──█──█──█──██
//  ──────────██──█──█──█──██
//  ──────────██──█──█──█──██
//  ──────────██──█──█──█──██
//  ──────────██──█──█──█──██
//  ──────────██──█──█──█──██
//  ──────────██──█──█──█──██
//  ──────────██──█──█──█──██
//  ──────────██──█──█──█──██
//  ──────────██──█──█──█──██
//  ──────────██──█──█──█──██
//  ───────────█▄▄█▄▄█▄▄█▄▄█


// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)

pragma solidity ^0.8.0;

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

// File: @openzeppelin/contracts/access/Ownable.sol


// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)

pragma solidity ^0.8.0;


abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);


    constructor() {
        _transferOwnership(_msgSender());
    }


    function owner() public view virtual returns (address) {
        return _owner;
    }


    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

      function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }


    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }


    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

// File: @openzeppelin/contracts/utils/Address.sol


// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)

pragma solidity ^0.8.1;


library Address {
      function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize/address.code.length, which returns 0
        // for contracts in construction, since the code is only stored at the end
        // of the constructor execution.

        return account.code.length > 0;
    }

      function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

      function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCall(target, data, "Address: low-level call failed");
    }


    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

     function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        require(isContract(target), "Address: call to non-contract");

        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

      function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }


    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        require(isContract(target), "Address: static call to non-contract");

        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }


    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }


    function functionDelegateCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(isContract(target), "Address: delegate call to non-contract");

        (bool success, bytes memory returndata) = target.delegatecall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }


    function verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            // Look for revert reason and bubble it up if present
            if (returndata.length > 0) {
                // The easiest way to bubble the revert reason is using memory via assembly

                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

// File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol


// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)

pragma solidity ^0.8.0;

interface IERC721Receiver {

    function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) external returns (bytes4);
}

// File: @openzeppelin/contracts/utils/introspection/IERC165.sol


// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)

pragma solidity ^0.8.0;

interface IERC165 {

    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

// File: @openzeppelin/contracts/utils/introspection/ERC165.sol


// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)

pragma solidity ^0.8.0;


abstract contract ERC165 is IERC165 {

    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IERC165).interfaceId;
    }
}

// File: @openzeppelin/contracts/token/ERC721/IERC721.sol


// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721.sol)

pragma solidity ^0.8.0;



interface IERC721 is IERC165 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    function balanceOf(address owner) external view returns (uint256 balance);

    function ownerOf(uint256 tokenId) external view returns (address owner);


    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes calldata data
    ) external;

    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    function approve(address to, uint256 tokenId) external;

    function setApprovalForAll(address operator, bool _approved) external;

    function getApproved(uint256 tokenId) external view returns (address operator);

    function isApprovedForAll(address owner, address operator) external view returns (bool);
}

// File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol

//                                  ,- 
//                                 //        
//                                /:      ,
//                               ;.(     //
//                     |   ,     /`|    //
//                     |\  |\    |,|   //
//                  |  (\  (\    |`|   |(
//                  (\  \\  \\   |,|   ;|
//              .   ||   \\  \\  |`(   ;( 
//              \\   \\  \\  \\  |.\\  ((                              
//               \\   \\  \\  \\  \\ \;/:\                 
//                 \\  \\  \'. \\_,\\ /\""-._                
//                  \\  \\  \ \-"   \/ `;._ ".
//                 ___\\-\\-" \ \_  /,  |_ "._\
//           _,--""___ \ \,_   "-_"- |".|(._ ".".-.
//       _,-"_,--"""__ ) "."-_    "--\ \"("o\_\ "- ".
//     ,",-""" _.-'''_-"   "-_"-.__   \ \_\_//\)__"\_)
//   ,"    ',-'  ,-""   7"  _ "-.._""_>\__`""'"__ ""``-._
//          ;  ," ,-",'/` ,":\.    `   `  `"""___`""-._  ".   )
//          ;,"_," ,' /`,"}}::\\         `... \____''' "\  '.|\
//         ,","   :  /`/{{)/:::"\__,---._    \  \_____'''\    \
//        , ,"_  ;  /`/ ///::::::::' ,-"-\    \__   \____''\ \ \
//       ,,"   `;| ";; /}}/::'``':::(._``."-.__  """--    '_\ \ \
//      ('       ;// / {;;:'`````':; /`._."""  ""-.._ `"-. " (   )
//      /         )(/ <";"'``   ``/ /_.(             "_  "-_"\`);
//                (/ <";"``     `/ /`,(                "._ _".\; 
//                 |<";"`   ``  / /"-"                    "  
//                 <";"` ``    / /__,;   
//   
//   
//   
//   
//   
//   
//   

// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)

pragma solidity ^0.8.0;


interface IERC721Enumerable is IERC721 {

    function totalSupply() external view returns (uint256);


    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);


    function tokenByIndex(uint256 index) external view returns (uint256);
}

// File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol


// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)

pragma solidity ^0.8.0;


interface IERC721Metadata is IERC721 {

    function name() external view returns (string memory);

    function symbol() external view returns (string memory);

    function tokenURI(uint256 tokenId) external view returns (string memory);
}

// File: contracts/finalcontract.sol


pragma solidity ^0.8.0;

error ApprovalCallerNotOwnerNorApproved();
error ApprovalQueryForNonexistentToken();
error ApproveToCaller();
error ApprovalToCurrentOwner();
error BalanceQueryForZeroAddress();
error MintedQueryForZeroAddress();
error MintToZeroAddress();
error MintZeroQuantity();
error OwnerIndexOutOfBounds();
error OwnerQueryForNonexistentToken();
error TokenIndexOutOfBounds();
error TransferCallerNotOwnerNorApproved();
error TransferFromIncorrectOwner();
error TransferToNonERC721ReceiverImplementer();
error TransferToZeroAddress();
error UnableDetermineTokenOwner();
error URIQueryForNonexistentToken();

contract ERC721A is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable {
    using Address for address;
    using Strings for uint256;

    struct TokenOwnership {
        address addr;
        uint64 startTimestamp;
    }

    struct AddressData {
        uint128 balance;
        uint128 numberMinted;
    }

    uint256 internal _currentIndex;

    // Token name
    string private _name;

    // Token symbol
    string private _symbol;

    // Mapping from token ID to ownership details
    // An empty struct value does not necessarily mean the token is unowned. See ownershipOf implementation for details.
    mapping(uint256 => TokenOwnership) internal _ownerships;

    // Mapping owner address to address data
    mapping(address => AddressData) private _addressData;

    // Mapping from token ID to approved address
    mapping(uint256 => address) private _tokenApprovals;

    // Mapping from owner to operator approvals
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }

    function totalSupply() public view override returns (uint256) {
        return _currentIndex;
    }

    function tokenByIndex(uint256 index) public view override returns (uint256) {
        if (index >= totalSupply()) revert TokenIndexOutOfBounds();
        return index;
    }

    function tokenOfOwnerByIndex(address owner, uint256 index) public view override returns (uint256) {
        if (index >= balanceOf(owner)) revert OwnerIndexOutOfBounds();
        uint256 numMintedSoFar = totalSupply();
        uint256 tokenIdsIdx;
        address currOwnershipAddr;

        // Counter overflow is impossible as the loop breaks when uint256 i is equal to another uint256 numMintedSoFar.
        unchecked {
            for (uint256 i; i < numMintedSoFar; i++) {
                TokenOwnership memory ownership = _ownerships[i];
                if (ownership.addr != address(0)) {
                    currOwnershipAddr = ownership.addr;
                }
                if (currOwnershipAddr == owner) {
                    if (tokenIdsIdx == index) {
                        return i;
                    }
                    tokenIdsIdx++;
                }
            }
        }

        // Execution should never reach this point.
        assert(false);
        return tokenIdsIdx;
    }

    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
        return
            interfaceId == type(IERC721).interfaceId ||
            interfaceId == type(IERC721Metadata).interfaceId ||
            interfaceId == type(IERC721Enumerable).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    function balanceOf(address owner) public view override returns (uint256) {
        if (owner == address(0)) revert BalanceQueryForZeroAddress();
        return uint256(_addressData[owner].balance);
    }

    function _numberMinted(address owner) internal view returns (uint256) {
        if (owner == address(0)) revert MintedQueryForZeroAddress();
        return uint256(_addressData[owner].numberMinted);
    }


    function ownershipOf(uint256 tokenId) internal view returns (TokenOwnership memory) {
        if (!_exists(tokenId)) revert OwnerQueryForNonexistentToken();

        unchecked {
            for (uint256 curr = tokenId; curr >= 0; curr--) {
                TokenOwnership memory ownership = _ownerships[curr];
                if (ownership.addr != address(0)) {
                    return ownership;
                }
            }
        }

        revert UnableDetermineTokenOwner();
    }


    function ownerOf(uint256 tokenId) public view override returns (address) {
        return ownershipOf(tokenId).addr;
    }


    function name() public view virtual override returns (string memory) {
        return _name;
    }


    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }


    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
        if (!_exists(tokenId)) revert URIQueryForNonexistentToken();

        string memory baseURI = _baseURI();
        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : '';
    }


    function _baseURI() internal view virtual returns (string memory) {
        return '';
    }


    function approve(address to, uint256 tokenId) public override {
        address owner = ERC721A.ownerOf(tokenId);
        if (to == owner) revert ApprovalToCurrentOwner();

        if (_msgSender() != owner && !isApprovedForAll(owner, _msgSender())) revert ApprovalCallerNotOwnerNorApproved();

        _approve(to, tokenId, owner);
    }


    function getApproved(uint256 tokenId) public view override returns (address) {
        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();

        return _tokenApprovals[tokenId];
    }


    function setApprovalForAll(address operator, bool approved) public override {
        if (operator == _msgSender()) revert ApproveToCaller();

        _operatorApprovals[_msgSender()][operator] = approved;
        emit ApprovalForAll(_msgSender(), operator, approved);
    }


    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
        return _operatorApprovals[owner][operator];
    }


    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public virtual override {
        _transfer(from, to, tokenId);
    }


    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) public virtual override {
        safeTransferFrom(from, to, tokenId, '');
    }


    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) public override {
        _transfer(from, to, tokenId);
        if (!_checkOnERC721Received(from, to, tokenId, _data)) revert TransferToNonERC721ReceiverImplementer();
    }


    function _exists(uint256 tokenId) internal view returns (bool) {
        return tokenId < _currentIndex;
    }

    function _safeMint(address to, uint256 quantity) internal {
        _safeMint(to, quantity, '');
    }


    function _safeMint(
        address to,
        uint256 quantity,
        bytes memory _data
    ) internal {
        _mint(to, quantity, _data, true);
    }


    function _mint(
        address to,
        uint256 quantity,
        bytes memory _data,
        bool safe
    ) internal {
        uint256 startTokenId = _currentIndex;
        if (to == address(0)) revert MintToZeroAddress();
        if (quantity == 0) revert MintZeroQuantity();

        _beforeTokenTransfers(address(0), to, startTokenId, quantity);

        // Overflows are incredibly unrealistic.
        // balance or numberMinted overflow if current value of either + quantity > 3.4e38 (2**128) - 1
        // updatedIndex overflows if _currentIndex + quantity > 1.56e77 (2**256) - 1
        unchecked {
            _addressData[to].balance += uint128(quantity);
            _addressData[to].numberMinted += uint128(quantity);

            _ownerships[startTokenId].addr = to;
            _ownerships[startTokenId].startTimestamp = uint64(block.timestamp);

            uint256 updatedIndex = startTokenId;

            for (uint256 i; i < quantity; i++) {
                emit Transfer(address(0), to, updatedIndex);
                if (safe && !_checkOnERC721Received(address(0), to, updatedIndex, _data)) {
                    revert TransferToNonERC721ReceiverImplementer();
                }

                updatedIndex++;
            }

            _currentIndex = updatedIndex;
        }

        _afterTokenTransfers(address(0), to, startTokenId, quantity);
    }


    function _transfer(
        address from,
        address to,
        uint256 tokenId
    ) private {
        TokenOwnership memory prevOwnership = ownershipOf(tokenId);

        bool isApprovedOrOwner = (_msgSender() == prevOwnership.addr ||
            getApproved(tokenId) == _msgSender() ||
            isApprovedForAll(prevOwnership.addr, _msgSender()));

        if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();
        if (prevOwnership.addr != from) revert TransferFromIncorrectOwner();
        if (to == address(0)) revert TransferToZeroAddress();

        _beforeTokenTransfers(from, to, tokenId, 1);

        // Clear approvals from the previous owner
        _approve(address(0), tokenId, prevOwnership.addr);

        // Underflow of the sender's balance is impossible because we check for
        // ownership above and the recipient's balance can't realistically overflow.
        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.
        unchecked {
            _addressData[from].balance -= 1;
            _addressData[to].balance += 1;

            _ownerships[tokenId].addr = to;
            _ownerships[tokenId].startTimestamp = uint64(block.timestamp);

            // If the ownership slot of tokenId+1 is not explicitly set, that means the transfer initiator owns it.
            // Set the slot of tokenId+1 explicitly in storage to maintain correctness for ownerOf(tokenId+1) calls.
            uint256 nextTokenId = tokenId + 1;
            if (_ownerships[nextTokenId].addr == address(0)) {
                if (_exists(nextTokenId)) {
                    _ownerships[nextTokenId].addr = prevOwnership.addr;
                    _ownerships[nextTokenId].startTimestamp = prevOwnership.startTimestamp;
                }
            }
        }

        emit Transfer(from, to, tokenId);
        _afterTokenTransfers(from, to, tokenId, 1);
    }


    function _approve(
        address to,
        uint256 tokenId,
        address owner
    ) private {
        _tokenApprovals[tokenId] = to;
        emit Approval(owner, to, tokenId);
    }


    function _checkOnERC721Received(
        address from,
        address to,
        uint256 tokenId,
        bytes memory _data
    ) private returns (bool) {
        if (to.isContract()) {
            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {
                return retval == IERC721Receiver(to).onERC721Received.selector;
            } catch (bytes memory reason) {
                if (reason.length == 0) revert TransferToNonERC721ReceiverImplementer();
                else {
                    assembly {
                        revert(add(32, reason), mload(reason))
                    }
                }
            }
        } else {
            return true;
        }
    }


    function _beforeTokenTransfers(
        address from,
        address to,
        uint256 startTokenId,
        uint256 quantity
    ) internal virtual {}


    function _afterTokenTransfers(
        address from,
        address to,
        uint256 startTokenId,
        uint256 quantity
    ) internal virtual {}
}



contract CHAPTER1 is ERC721A, Ownable{
    using Strings for uint256;
    uint256 public constant MAX_SUPPLY = 11111;
    uint256 public constant MAX_PUBLIC_MINT = 5;
    uint256 public constant MAX_WHITELIST_MINT = 5;
    uint256 public PUBLIC_SALE_PRICE = .00 ether;
    uint256 public WHITELIST_SALE_PRICE = .00 ether;

    string private  baseTokenUri;
    string public   placeholderTokenUri;

    //deploy smart contract, toggle WL, toggle WL when done, toggle publicSale 
    //2 days later toggle reveal
    bool public isRevealed;
    bool public publicSale;
    bool public whiteListSale;
    bool public pause;
    bool public teamMinted;

    bytes32 private merkleRoot;

    mapping(address => uint256) public totalPublicMint;
    mapping(address => uint256) public totalWhitelistMint;

    constructor() ERC721A("LEGENDS OF THE FIRSTBORNE", "Chapter One"){

    }

    modifier callerIsUser() {
        require(tx.origin == msg.sender, "FIRSTBORNE :: Cannot be called by a contract");
        _;
    }

    function mint(uint256 _quantity) external payable callerIsUser{
        require(publicSale, "FIRSTBORNE :: Not Yet Active.");
        require((totalSupply() + _quantity) <= MAX_SUPPLY, "FIRSTBORNE :: Beyond Max Supply");
        require((totalPublicMint[msg.sender] +_quantity) <= MAX_PUBLIC_MINT, "FIRSTBORNE :: Already minted 3 times!");
        require(msg.value >= (PUBLIC_SALE_PRICE * _quantity), "FIRSTBORNE :: Below ");

        totalPublicMint[msg.sender] += _quantity;
        _safeMint(msg.sender, _quantity);
    }

    function whitelistMint(bytes32[] memory _merkleProof, uint256 _quantity) external payable callerIsUser{
        require(whiteListSale, "FIRSTBORNE :: Minting is on Pause");
        require((totalSupply() + _quantity) <= MAX_SUPPLY, "FIRSTBORNE :: Cannot mint beyond max supply");
        require((totalWhitelistMint[msg.sender] + _quantity)  <= MAX_WHITELIST_MINT, "FIRSTBORNE :: Cannot mint beyond whitelist max mint!");
        require(msg.value >= (WHITELIST_SALE_PRICE * _quantity), "FIRSTBORNE :: Payment is below the price");
        //create leaf node
        bytes32 sender = keccak256(abi.encodePacked(msg.sender));
        require(MerkleProof.verify(_merkleProof, merkleRoot, sender), "FIRSTBORNE :: You are not whitelisted");

        totalWhitelistMint[msg.sender] += _quantity;
        _safeMint(msg.sender, _quantity);
    }

    function teamMint() external onlyOwner{
        require(!teamMinted, "FIRSTBORNE :: Team already minted");
        teamMinted = true;
        _safeMint(msg.sender, 500);
    }

    function _baseURI() internal view virtual override returns (string memory) {
        return baseTokenUri;
    }

    //return uri for certain token
    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
        require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");

        uint256 trueId = tokenId + 1;

        if(!isRevealed){
            return placeholderTokenUri;
        }
        //string memory baseURI = _baseURI();
        return bytes(baseTokenUri).length > 0 ? string(abi.encodePacked(baseTokenUri, trueId.toString(), ".json")) : "";
    }

    /// @dev walletOf() function shouldn't be called on-chain due to gas consumption
    function walletOf() external view returns(uint256[] memory){
        address _owner = msg.sender;
        uint256 numberOfOwnedNFT = balanceOf(_owner);
        uint256[] memory ownerIds = new uint256[](numberOfOwnedNFT);

        for(uint256 index = 0; index < numberOfOwnedNFT; index++){
            ownerIds[index] = tokenOfOwnerByIndex(_owner, index);
        }

        return ownerIds;
    }

    function setTokenUri(string memory _baseTokenUri) external onlyOwner{
        baseTokenUri = _baseTokenUri;
    }
    function setPlaceHolderUri(string memory _placeholderTokenUri) external onlyOwner{
        placeholderTokenUri = _placeholderTokenUri;
    }

    function setMerkleRoot(bytes32 _merkleRoot) external onlyOwner{
        merkleRoot = _merkleRoot;
    }

    function getMerkleRoot() external view returns (bytes32){
        return merkleRoot;
    }

    function togglePause() external onlyOwner{
        pause = !pause;
    }

    function toggleWhiteListSale() external onlyOwner{
        whiteListSale = !whiteListSale;
    }

    function togglePublicSale() external onlyOwner{
        publicSale = !publicSale;
    }

     function update_public_price(uint price) external onlyOwner {
        PUBLIC_SALE_PRICE = price;
    }
       function update_preSale_price(uint price) external onlyOwner {
        WHITELIST_SALE_PRICE = price;
    }

function AirDrop(address[] memory _wallets, uint _count) public onlyOwner{
        require(_wallets.length > 0, "mint at least one token");
        require(totalSupply() + _wallets.length <= MAX_SUPPLY, "not enough tokens left");
        for (uint i = 0; i < _wallets.length; i++)
        {
            _safeMint(_wallets[i], _count);
        }
    }

    function toggleReveal() external onlyOwner{
        isRevealed = !isRevealed;
    }

    function withdraw() external onlyOwner{
uint _balance = address(this).balance;
        payable(owner()).transfer(_balance );//owner
}
}


//                                                             ▓▓▓▓▓▓                                                          
//                                                   ░░▓▓▓▓▓▓▓▓▓▓▓▓          ▓▓▓▓▓▓▓▓▓▓▓▓▓▓                                    
//                                               ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓░░  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓░░░░                                    
//                                           ▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒                                  
//                                         ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓                            
//                                       ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓                        
//                                   ██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓        ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓    ▓▓▓▓                      
//                                 ▓▓▓▓▓▓▓▓▓▓░░░░    ░░░░░░▓▓▓▓▓▓        ▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒  ▒▒░░                      
//                               ██▓▓                                        ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓                        
//                             ▓▓                                              ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓                      
//                                                                             ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓                  
//                               ▓▓  ▓▓                                        ▓▓▓▓▓▓▓▓▓▓        ▓▓▓▓▓▓▓▓▓▓▓▓▓▓░░              
//                             ▓▓▓▓  ▓▓▓▓            ░░▓▓▒▒                    ▓▓▓▓▓▓▓▓▓▓▓▓      ░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓              
//                               ▓▓  ▓▓    ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓░░      ██▓▓▓▓▓▓▓▓▓▓▓▓▓▓          ▓▓▓▓▓▓▓▓▓▓▓▓            
//                               ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓        ██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██          ▓▓▓▓▓▓▓▓▓▓▓▓          
//                             ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒  ▓▓▓▓▓▓▓▓▒▒▒▒▓▓▓▓▓▓▓▓          ▒▒▓▓▓▓▓▓▓▓▓▓        
//                           ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓░░░░▓▓▓▓▒▒▓▓▓▓▓▓▓▓▒▒  ▓▓▓▓▓▓▓▓▒▒  ▒▒▒▒▓▓▓▓▒▒          ░░▓▓▓▓▓▓▓▓▒▒      
//                       ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓      ░░▒▒            ██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓        ▓▓▓▓▓▓          ░░▓▓▓▓▓▓▓▓▓▓    
//                     ██▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓          ░░            ██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓        ▓▓▓▓▓▓          ▓▓▓▓▓▓▓▓▓▓    
//                 ░░▒▒▓▓▓▓░░  ▓▓▓▓▓▓▓▓▓▓▓▓                        ░░░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓        ▒▒▓▓▓▓          ░░▓▓▓▓▓▓▓▓    
//                 ░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓░░                            ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒        ░░▓▓▒▒          ▓▓▓▓▓▓▓▓▒▒  
//               ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓░░  ██                        ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓          ░░▓▓          ░░▓▓▓▓▓▓▓▓  
//       ▒▒▓▓▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓░░                        ░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓            ▓▓░░          ▓▓▓▓▓▓▓▓  
//       ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓                          ▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓              ▒▒            ▓▓▓▓▓▓▓▓
//       ▓▓▓▓▓▓▓▓▓▓▓▓  ██  ██    ▓▓▓▓▓▓▓▓▓▓                            ▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓              ▓▓▓▓          ▓▓▓▓▓▓▓▓
//       ░░▓▓▓▓▓▓░░▓▓    ▓▓    ░░▓▓▓▓░░                            ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ░░▓▓              ▒▒▓▓          ▓▓▓▓▓▓▓▓
//         ░░▓▓░░      ▓▓░░    ▓▓▓▓                              ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓    ▓▓              ░░▓▓          ░░▓▓▓▓▓▓
//             ██  ░░▓▓    ██  ▓▓▒▒  ██                        ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓    ▓▓              ░░▓▓            ▓▓▓▓▓▓
//             ░░  ░░▓▓    ▒▒▒▒▓▓▒▒▒▒▒▒                      ▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓    ▓▓              ░░▓▓            ▓▓▓▓▓▓
//                 ▓▓▓▓    ▓▓▓▓▓▓▓▓▓▓▓▓                  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓░░  ░░    ▓▓              ░░▓▓            ▓▓▓▓▓▓
//             ██  ▓▓      ▓▓▓▓▓▓▓▓▓▓▓▓▓▓            ▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓░░▓▓▓▓                          ░░▓▓            ▓▓▓▓▓▓
//           ▓▓    ▒▒        ▓▓▓▓                ██▓▓▓▓▓▓▓▓▓▓▓▓      ▓▓                                  ░░██            ▓▓▓▓▓▓
//         ▒▒▓▓  ▒▒▓▓        ░░░░            ▒▒▒▒▓▓▓▓▓▓▓▓▓▓██░░      ░░                                    ░░            ▓▓▓▓▓▓
//         ▓▓▒▒  ▓▓                      ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓                                                              ▓▓▓▓░░
//       ▒▒▒▒  ▒▒▓▓                    ▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒                                                              ▓▓▓▓  
//       ░░  ▒▒▓▓░░                  ▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓░░                                                            ░░▒▒▓▓▓▓  
//       ▓▓  ▓▓░░                  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓                                                                ▓▓▓▓░░  
//       ▓▓                        ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓                                ▓▓                                ▓▓▓▓    
//                               ██▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓                                ░░██                            ▓▓▓▓▓▓    
//                             ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓                                  ▓▓                            ▓▓▓▓░░    
//                             ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓                                  ▓▓▓▓                          ▓▓▓▓      
//                             ██  ▓▓▓▓▓▓    ░░▓▓▓▓██▓▓                                ▓▓▓▓                        ▓▓▓▓▓▓      
//                             ▓▓  ▓▓▓▓░░      ▓▓▓▓▓▓▒▒                                ▓▓▓▓                        ▓▓▓▓▒▒      
//                             ░░  ▓▓▓▓    ░░▓▓▓▓▓▓▓▓▓▓▓▓                              ▓▓▓▓                        ▓▓░░        
//                                 ▓▓▓▓▒▒  ░░▓▓▓▓▓▓▓▓▓▓▓▓▒▒                            ▓▓▓▓▒▒                    ▒▒▓▓          
//                                 ░░▓▓▓▓    ▓▓▓▓▓▓▓▓▓▓▓▓▓▓                          ▒▒▓▓▓▓▒▒                    ▓▓▓▓          
//                                   ▓▓▓▓    ░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓                      ▓▓▓▓▓▓▒▒                    ▓▓            
//                                     ▓▓▓▓    ░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓                  ▓▓▓▓▓▓▓▓▓▓                    ▓▓            
//                                     ▓▓▓▓▓▓    ░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓██░░          ▓▓▓▓▓▓▓▓▓▓                    ▓▓▓▓            
//                                       ▓▓▓▓▒▒    ░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓    ▓▓▓▓▓▓▓▓▓▓▓▓▓▓                    ▓▓▓▓            
//                                       ░░▓▓▓▓▓▓    ░░░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓░░                    ░░▓▓            
//                                         ░░▓▓▓▓▓▓          ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓                          ▓▓            
//                                           ░░▓▓▓▓▓▓▒▒            ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓                            ▓▓            
//                                             ░░░░▓▓▓▓▓▓        ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓░░░░                            ▓▓            
//                                                 ░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓░░                                                  
//                                                   ▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓              ▓▓▓▓▓▓                                      
//                                                 ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▓▓░░░░                                      
//                                           ░░▓▓▓▓▓▓▓▓▓▓░░░░      ▓▓▓▓▓▓▓▓▓▓▓▓  ░░░░                                          
//                                         ░░▓▓▓▓▓▓▓▓                  ░░                                                      
//                                         ▓▓▓▓▓▓░░░░                                                                          
//                                       ▓▓▓▓▓▓░░                                                                              
//                                       ▓▓▓▓        ░░▓▓▓▓██▓▓                                                                
//                                       ▓▓▓▓          ▓▓▓▓▓▓▓▓▒▒▒▒▒▒                                                          
//                                       ▓▓▓▓            ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓                                                      
//                                       ▓▓▒▒            ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓                                                    
//                                       ░░▓▓▓▓▒▒▒▒▒▒▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒  ▓▓▓▓▓▓▒▒                                                
//                                         ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓    ▓▓▓▓░░  ▓▓▓▓▓▓                                                
//                                           ░░▓▓▓▓▓▓▓▓██▓▓          ▓▓  ▓▓▓▓▓▓▓▓                                              
//                                         ▓▓    ░░▓▓▒▒                ▓▓  ▓▓▓▓▓▓                                              
//                                         ▒▒▒▒▓▓  ░░░░                ░░▒▒░░▓▓▓▓▒▒                                            
//                                           ▒▒▓▓▓▓▓▓                    ▓▓  ▓▓▓▓▓▓                ░░░░                        
//                                             ░░░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓      ░░  ░░▓▓▓▓              ░░    ░░                      
//                                                 ░░▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▓▓        ▓▓▓▓              ░░░░  ▒▒  ░░░░▒▒░░            
//                                                   ░░░░░░░░░░░░▓▓▓▓▓▓▓▓      ▓▓▓▓                ░░▒▒░░▒▒▒▒░░                
//                                                                 ▓▓▓▓▓▓      ▓▓▓▓                                            
//                                                                 ▓▓▓▓▓▓▓▓    ▓▓▓▓                                            
//                                                                 ▓▓▓▓▓▓▓▓    ▓▓▓▓                                            
//                                                                 ▓▓▓▓▓▓▓▓    ▓▓▓▓                                            
//                                                                 ▓▓▓▓▓▓▓▓    ▓▓▓▓                                            
//                                                                 ▓▓▓▓▓▓▓▓▒▒▒▒▓▓░░                                            
//                                                                 ▓▓▓▓▓▓▓▓▓▓▓▓▓▓                                              
//                                                                 ▓▓▓▓▓▓▓▓▓▓▓▓▓▓                                              
//                                                               ▓▓▓▓▓▓▓▓  ▓▓▓▓░░                                              
//                                   ██▓▓▓▓▓▓▓▓▓▓▓▓              ▓▓▓▓▓▓▓▓  ▓▓░░                                                
//                                 ██▓▓          ▓▓▓▓            ▓▓▓▓▓▓░░                                                      
//                                 ▓▓░░          ▒▒▓▓          ▒▒▓▓▓▓▓▓                                                        
//                               ▓▓▒▒            ░░▓▓          ▓▓▓▓▓▓▓▓                                                        
//                               ▓▓              ▒▒▓▓        ▒▒▓▓▓▓▒▒░░                                                        
//                               ▓▓            ▒▒▓▓░░      ▒▒▓▓▓▓▓▓                                                            
//                             ▓▓▓▓      ▓▓▒▒▓▓▓▓░░        ▓▓▓▓▓▓░░                                                            
//                             ▓▓▓▓      ░░▓▓▓▓▓▓        ▓▓▓▓▓▓                                                                
//                             ▓▓▓▓                  ▓▓▓▓▓▓██                                                                  
//                               ▓▓▓▓              ▓▓▓▓▓▓▓▓                                                                    
//                               ░░▓▓▓▓▓▓    ▓▓▓▓▓▓▓▓▓▓▓▓