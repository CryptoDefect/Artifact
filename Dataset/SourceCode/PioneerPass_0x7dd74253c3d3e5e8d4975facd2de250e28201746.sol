// SPDX-License-Identifier: MIT
// Creator: @casareafer at 1TM.io

/*

         _______                   _____                    _____                    _____                    _____
        /::\    \                 /\    \                  /\    \                  /\    \                  /\    \
       /::::\    \               /::\____\                /::\    \                /::\    \                /::\____\
      /::::::\    \             /::::|   |               /::::\    \              /::::\    \              /:::/    /
     /::::::::\    \           /:::::|   |              /::::::\    \            /::::::\    \            /:::/    /
    /:::/~~\:::\    \         /::::::|   |             /:::/\:::\    \          /:::/\:::\    \          /:::/    /
   /:::/    \:::\    \       /:::/|::|   |            /:::/__\:::\    \        /:::/  \:::\    \        /:::/    /
  /:::/    / \:::\    \     /:::/ |::|   |           /::::\   \:::\    \      /:::/    \:::\    \      /:::/    /
 /:::/____/   \:::\____\   /:::/  |::|   | _____    /::::::\   \:::\    \    /:::/    / \:::\    \    /:::/    /      _____
|:::|    |     |:::|    | /:::/   |::|   |/\    \  /:::/\:::\   \:::\    \  /:::/    /   \:::\    \  /:::/____/      /\    \
|:::|____|     |:::|    |/:: /    |::|   /::\____\/:::/__\:::\   \:::\____\/:::/____/     \:::\____\|:::|    /      /::\____\
 \:::\    \   /:::/    / \::/    /|::|  /:::/    /\:::\   \:::\   \::/    /\:::\    \      \::/    /|:::|____\     /:::/    /
  \:::\    \ /:::/    /   \/____/ |::| /:::/    /  \:::\   \:::\   \/____/  \:::\    \      \/____/  \:::\    \   /:::/    /
   \:::\    /:::/    /            |::|/:::/    /    \:::\   \:::\    \       \:::\    \               \:::\    \ /:::/    /
    \:::\__/:::/    /             |::::::/    /      \:::\   \:::\____\       \:::\    \               \:::\    /:::/    /
     \::::::::/    /              |:::::/    /        \:::\   \::/    /        \:::\    \               \:::\__/:::/    /
      \::::::/    /               |::::/    /          \:::\   \/____/          \:::\    \               \::::::::/    /
       \::::/    /                /:::/    /            \:::\    \               \:::\    \               \::::::/    /
        \::/____/                /:::/    /              \:::\____\               \:::\____\               \::::/    /
         ~~                      \::/    /                \::/    /                \::/    /                \::/____/
                                  \/____/                  \/____/                  \/____/                  ~~

                                                 _______________________
                                               //   __..--~~~~--..__    \\
                                              ||___/  |  |   |  |   \ __/ |
                                              ||  /   ___________    \    |
                                              ||_/   /.......... \    |   |
                                              | |   /..........   \   |   |
                         _____________________| |  /...........    \  |   |________________
                          ;   . . .   .       |_| |...........      | |   | .''."...  ... .
                         ___   ..~.         _.' | |..........       | |   |         . ~
                          .      '     .   / \_.| |..........       | |   |\ ~.   ._..---._
                                          |. /| \ \............     / /   |/ .    /\      /\
                            '""" ... ~~~  | \|| _\ \............   / /-.__|      // ~-._./ -\
                          ..~             |  |_.~\\ \_____________/ /// '.|     /__       __.\
                          ___   ..~.      |_.~    \\_______________//   _ ~-.  ~~~~..  ~~~~~.
                                         .~ -.     \__.---.________/   ______\.
                         .''."...  ... ./\        _|      |---|  = |__ \__\===\   '""" ... ~~~
                                       /  '.  .  |_|=     |---|    | _| \======\ ___   ..~.
                           ..~        / .   \      |=     |___|    ||       __. \
                                     /           _ |_______________|   _.        \
                         .''."...  ./                /   \___    ~~  \            \  '" ..   ~~
                                   /          '' /   \      /         \           /\
                         ___   .  /     -- .   /'   __\____/       ____\___.'   --  \ ___   ..~.
                                 /            /    / \\ --  _____//          ~ - .   \
                          ..--  /_..-       ./.   /  _/   _|___  \\       .     -   _/)
                               /   ___     ./|__  / _/   (_____ / \\  .          \ ~ /   .
                           .  /___////_   /  |   / _/    (_____ \  \\       _./ ..__/
                             /___/__/_ \ /  _|  /__/ _-- (_____  \: \\_____________/      ._
                         _  /         \ /_.' | /  /       (_________/ ~~-|
                           /           //   _|/  /-              .    __ |..~. _____ -.. '  "
                         ..\==========/'   \_/ _/  __      ___..     /  \|
                             / _____  \'.______/___....------......__\__/|
                         '  |          \     |\__________________|__|___/|  ~~~~~..   - ~  '
                          ~ |        _  \   /~      \     \ --  /         \
                            | | | | | \_|  |   \     \ ~      //           |
                         _. |_| | | | .    |-----..   \       /  /-      __|..~. _____ -.. '  "
                              |_|_|_|   _. |       \_  \\ _ ./          ___|
                          ~~~  ..   - ~  ' |         \__\___/__...------   |  ~~~~~..   - ~  '
                                           |  .-         | | .       __    |
                                           |     __..    | |    ______     |      .     ~
                        ..~. _  __ -.. '   \           __| |   |      |    | _        .
                                           /             | | ~ |__.___|.   |
                                           |    __       | |   |      |    |              .. '
                          ~~~~~..   - ~  ' | ''          / \   |      |    |___     __.
                          ....   -         |  _____...   | |   \______/    |  ~~~~~..   - ~  '
                                           | /        '--| |      ~~       |
                             ~..   - ~  '  |/            | |    __----  .. |   .      .     _
                                           ||____......._| |               |
                                           |----         | |               |  ~~~~~..   - ~  '
                           '""" ... ~~~    |       -.    | |       _..     |
                                           | ..         // |               | _~"".    .
                                           |          -  \ | __----.   ..  \
                          ~~~..   - ~  '   |_____________| |_______________/
                                           \_____________| |______________/   '    ...  __  ~
                                            /     ----- \   /----------- \
                           __~~..   - ~  ' /___      ----\ /--...___      \
                                          /    ..--      | | __..     ___./  .     .   ~
                              - ~  '..    \  __________./  |_____________/  .   - ~  ' ~~~~
                          ..._____~~~~~~JRO\___________/    \___________/  -_______...._____
                        ..            ___ . ~~~~~~~~~~~. __\ ~~~~~~~~~~~~~...      _  ~
                        __    ....         ''        ...""       ....'''      -_~~~     ~~~...

*/

pragma solidity ^0.8.17;

import "./PioneerPassToken.sol";

contract PioneerPass is PioneerPassToken {
    string public name = "1CU Pioneer Pass";
    string public symbol = "PNRP";

    constructor(string memory _contractURI, address royaltyAddress) PioneerPassToken(_contractURI, royaltyAddress){}

    function mint(bytes32[] calldata _merkleProof, uint256 _passId, uint16 _amount, bool whitelisted) external payable callerIsUser {
        Library.Pass storage pass = passIdToCollectionPass[_passId];
        require(pass.passId > 0, "Invalid Pass");
        require(pass.preSale || pass.publicSale, "No active sales");
        if (whitelisted) {
            require(!PioneerPassStorage.whitelistMinted[msg.sender][_passId], "Already minted");
            require(Library.ValidatePresaleMint(pass, _amount, true, _merkleProof));
            PioneerPassStorage.whitelistMinted[msg.sender][_passId] = true;
        } else if (pass.preSale) {
            require(_passId != 1, "No pre-sale for the ark");
            require(!PioneerPassStorage.presaleMinted[msg.sender][_passId], "Already minted");
            for (uint bar = 0; bar < _passId - 1; bar++) {
                require(balanceOf(msg.sender, passIdIndex[bar]) > 0, "Does not own previous tokens");
            }
            require(Library.ValidatePresaleMint(pass, _amount, false, _merkleProof));
            PioneerPassStorage.presaleMinted[msg.sender][_passId] = true;
        } else {
            uint16 _hodls;
            if (balanceOf(msg.sender, passIdIndex[0]) > 0) {
                if (_passId > 1) {
                    for (uint bar = 0; bar < _passId - 1; bar++) {
                        if (balanceOf(msg.sender, passIdIndex[bar]) > 0) {
                            _hodls += 1;
                        }
                    }
                }
            }
            else {
                _hodls = 0;
            }
            require(Library.ValidatePublicMint(pass, _amount, _hodls));
        }
        pass.totalMinted += _amount;
        _mint(msg.sender, _passId, _amount, "");
    }

    function reservedMints(uint256 _passId, uint16 _amount) external payable onlyOwner {
        Library.Pass storage pass = passIdToCollectionPass[_passId];
        require(pass.passId > 0, "Invalid Pass");
        require(pass.maxSupply >= _amount + pass.totalMinted, "Exceeds available supply");
        pass.totalMinted += _amount;
        _mint(msg.sender, _passId, _amount, "");
    }
}

// SPDX-License-Identifier: MIT
// Creator: @casareafer at 1TM.io

pragma solidity ^0.8.17;

import "./openzeppelin/ERC1155.sol";
import "./openzeppelin/Ownable.sol";
import "./PioneerPassLibrary.sol";
import "./PioneerPassStorage.sol";
import "./PioneerPassUtils.sol";
import "./ContractURI.sol";
import "./Staking.sol";

contract PioneerPassToken is ERC1155, Ownable, PioneerPassStorage, ContractURI, Stacking, PioneerPassUtils {
    address private royaltiesTeamWallet;
    mapping(uint256 => bool) private transfersLock;

    constructor(string memory _contractURI, address _royaltyAddress){
        _setContractURI(_contractURI);
        royaltiesTeamWallet = _royaltyAddress;
    }

    /**
    *   Pause control
    */

    function setTransfersLock(uint256 _passId, bool _value) external onlyOwner {
        transfersLock[_passId] = _value;
    }

    /**
    *   Royalties - EIP2981
    */

    function royaltyInfo(uint256 _passId, uint256 _salePrice) external view
    returns (address receiver, uint256 royaltyAmount)
    {
        if (_passId == 1) {
            return (royaltiesTeamWallet, _salePrice * 80 / 1000);
        } else
        {
            return (royaltiesTeamWallet, _salePrice * 50 / 1000);
        }
    }

    function setRoyaltyAddress(address _teamWallet) external onlyOwner {
        royaltiesTeamWallet = _teamWallet;
    }

    /**
    *   Burn implementation
    */

    function burn(
        address from,
        uint id,
        uint256 amount
    ) external {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            "ERC1155: caller is not token owner nor approved"
        );
        _burn(from, id, amount);
    }

    /**
    *   Token & Contract metadata
    */

    function setContractURI(string memory _contractURI) external onlyOwner {
        _setContractURI(_contractURI);
    }

    function setUri(uint256 _tokenId, string memory _tokenURI) external onlyOwner {
        _tokenURIs[_tokenId] = _tokenURI;
    }

    function uri(uint256 _passId)
    external
    view
    override
    returns (string memory)
    {
        require(passIdToCollectionPass[_passId].passId != 0, "Invalid pass");
        return string(
            abi.encodePacked(_baseURI, _tokenURIs[_passId])
        );
    }

    /**
    *   Withdraw
    */

    function withdraw() external onlyOwner {
        payable(owner()).transfer(address(this).balance);
    }

    /**
    *   Stacking & Transfers lock require these overrides
    */

    function _beforeTokenTransfer(
        address operator,
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) internal override(ERC1155) {
        for (uint bar = 0; bar < ids.length; bar++) {
            require(!transfersLock[ids[bar]], "Transfers locked");
        }
        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);
    }

    function _afterTokenTransfer(
        address operator,
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) internal override(ERC1155) {
        super._afterTokenTransfer(operator, from, to, ids, amounts, data);
        Stacking.stakeTransfer(ids, amounts, to, from);
    }
}

// SPDX-License-Identifier: MIT
// Creator: @casareafer at 1TM.io

pragma solidity ^0.8.17;

import "./openzeppelin/Ownable.sol";
import "./PioneerPassLibrary.sol";

contract PioneerPassStorage is Ownable {
    mapping(address => mapping(uint256 => bool)) internal presaleMinted;
    mapping(address => mapping(uint256 => bool)) internal whitelistMinted;
    mapping(uint256 => Library.Pass) internal passIdToCollectionPass;
    uint256[] internal passIdIndex;

    /**
    *   Retrieve a PioneerPass details
    */

    function getPioneerPassDetails(uint256 _passId) external view returns (Library.Pass memory){
        require(passIdToCollectionPass[_passId].passId != 0, "Invalid Pass");
        return passIdToCollectionPass[_passId];
    }

    /**
    *   Utils - Checks if the wallet address already minted
    */

    function getMinted(uint256 _passId, address _account) external view returns (bool presale, bool whitelist) {
        return (presaleMinted[_account][_passId], whitelistMinted[_account][_passId]);
    }

    /**
    *   Adds a new type of Pioneer Pass
    */

    function addPass(
        uint256 _passId,
        uint16 _maxSupply,
        uint8 _maxMint,
        uint24 _stakingPoints,
        bytes32 _whitelistMerkleRoot,
        uint256 _mintPrice,
        uint256 _whitelistPrice,
        uint256 _hodlersPrice
    ) external onlyOwner {
        require(_passId != 0, "Invalid Id");
        require(passIdToCollectionPass[_passId].passId != _passId, "Pass ID duplicate");
        Library.Pass memory pass = Library.Pass(
            false,
            false,
            _maxSupply,
            0,
            _maxMint,
            _stakingPoints,
            _whitelistMerkleRoot,
            _passId,
            _mintPrice,
            _whitelistPrice,
            _hodlersPrice
        );
        passIdToCollectionPass[_passId] = pass;
        passIdIndex.push(_passId);
    }

    /**
    *   Utils - Modify PioneerPass types
    */

    function updatePass(
        uint256 _passId,
        uint8 _maxMint,
        uint16 _maxSupply,
        uint16 _stackingPoints,
        bytes32 _merkleRoot,
        uint256 _mintPrice,
        uint256 _whitelistPrice,
        uint256 _hodlersPrice
    ) external onlyOwner {
        passIdToCollectionPass[_passId].maxSupply = _maxSupply;
        passIdToCollectionPass[_passId].stakingPoints = _stackingPoints;
        passIdToCollectionPass[_passId].maxMint = _maxMint;
        passIdToCollectionPass[_passId].whitelistMerkleRoot = _merkleRoot;
        passIdToCollectionPass[_passId].mintPrice = _mintPrice;
        passIdToCollectionPass[_passId].whitelistPrice = _whitelistPrice;
        passIdToCollectionPass[_passId].hodlersPrice = _hodlersPrice;
    }

    function setSaleStatus(uint256 _passId, bool _presale, bool _publicSale) external onlyOwner {
        passIdToCollectionPass[_passId].publicSale = _publicSale;
        passIdToCollectionPass[_passId].preSale = _presale;
    }
}

// SPDX-License-Identifier: MIT
// Creator: @casareafer at 1TM.io

pragma solidity ^0.8.17;

contract PioneerPassUtils {
    modifier callerIsUser() {
        require(tx.origin == msg.sender, "The caller is another contract");
        _;
    }
}

// SPDX-License-Identifier: MIT
// Creator: @casareafer at 1TM.io

pragma solidity ^0.8.17;

import "./openzeppelin/MerkleProof.sol";

library Library {
    struct Pass {
        bool publicSale;
        bool preSale;
        uint16 maxSupply;
        uint16 totalMinted;
        uint8 maxMint;
        uint24 stakingPoints;
        bytes32 whitelistMerkleRoot;
        uint256 passId;
        uint256 mintPrice;
        uint256 whitelistPrice;
        uint256 hodlersPrice;
    }

    /**
    *   Public sale validation
    *   Mint price -> For anyone in the public sale
    *   Mint price with discount -> If you hold the ark, you get starting 3% + 3% per held token-type
    */

    function ValidatePublicMint(
        Pass memory pass,
        uint16 _amount,
        uint16 _hodls
    ) public view returns (bool){
        require(pass.maxSupply >= (_amount + pass.totalMinted), "Exceeds available supply");
        require(msg.value >= ((pass.mintPrice) - ((pass.mintPrice * (_hodls * 30)) / 1000)) * _amount, "Invalid tx amount");
        require(_amount <= pass.maxMint, "Too many mints");
        return true;
    }

    /**
    *   Presale validation
    *   Hodlers price -> For holders of all preceding moments
    *   Whitelist price -> For people in the whitelist
    */

    function ValidatePresaleMint(
        Pass memory pass,
        uint16 _amount,
        bool _whitelisted,
        bytes32[] calldata merkleProof
    ) public view returns (bool){
        require(pass.maxSupply >= (_amount + pass.totalMinted), "Exceeds available supply");
        require(_amount <= pass.maxMint, "Too many mints");
        if (_whitelisted) {
            require(MerkleProof.verify(
                    merkleProof, pass.whitelistMerkleRoot, keccak256(abi.encodePacked(msg.sender))
                ), "Invalid proof");
            require(msg.value == pass.whitelistPrice * _amount, "Invalid tx amount");
        } else {
            require(msg.value == pass.hodlersPrice * _amount, "Invalid tx amount");
        }
        return true;
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)

pragma solidity ^0.8.17;

import "./Context.sol";

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _transferOwnership(_msgSender());
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        _checkOwner();
        _;
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if the sender is not the owner.
     */
    function _checkOwner() internal view virtual {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Internal function without access restriction.
     */
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

// SPDX-License-Identifier: MIT
// Creator: @casareafer at 1TM.io

pragma solidity ^0.8.17;

import "./openzeppelin/Ownable.sol";
import "./PioneerPassLibrary.sol";

contract Stacking is Ownable {

    /**
    *   Stores the time when the staking for a token type starts - block.timestamp
    */

    mapping(uint256 => uint256) private StackingTimer;

    /**
    *   Stores whenever the Staking timer already started - It starts once after the first mint of a pass
    */

    mapping(uint256 => bool) private BoOoOmBaby;

    /**
    *   Stores a Timestamp per owned token type in an address
    */

    mapping(address => mapping(uint256 => uint256[])) private lastBoughtTimestamp;

    /**
    *   Staking Point x (Days holding / Total days from the presale)
    *
    *   NOTE: SELLING YOUR TOKENS ERASE YOUR HOLDING TIME >:)
    *
    *   MORE NOTES: SELLING YOUR TOKENS WILL ERASE YOUR HOLDING TIME STARTING FROM THE
    *   LATEST BOUGHT TOKEN ;)
    */

    function stakeTransfer(uint256[] memory _passId, uint256[] memory _amount, address _to, address _from) internal {
        if (_from != address(0)) {
            for (uint foo = 0; foo < _passId.length; foo++) {
                for (uint bar = 0; bar < _amount[foo]; bar++) {
                    lastBoughtTimestamp[_to][_passId[foo]].push(block.timestamp);
                    lastBoughtTimestamp[_from][_passId[foo]].pop();
                }
            }
        } else if (_to == address(0)) {
                for (uint bar = 0; bar < _amount[0]; bar++) {
                    lastBoughtTimestamp[_from][_passId[0]].pop();
                }
        } else {
            if (BoOoOmBaby[_passId[0]] != true) {
                BoOoOmBaby[_passId[0]] = true;
                StackingTimer[_passId[0]] = block.timestamp;
            }
            for (uint i = 0; i < _amount[0]; i++) {
                lastBoughtTimestamp[_to][_passId[0]].push(block.timestamp);
            }
        }
    }

    /**
    *   Get Stacking info
    */

    function getStakingTimer(uint256 _passId) external view returns (uint256){
        return StackingTimer[_passId];
    }

    function getStakes(uint256 _passId, address _user) external view returns (uint256[] memory){
        return lastBoughtTimestamp[_user][_passId];
    }

}

// SPDX-License-Identifier: MIT
// Creator: @casareafer at 1TM.io
pragma solidity ^0.8.17;

contract ContractURI {
    string internal contractURI_ = "";

    function _setContractURI(string memory _contractURI) internal {
        contractURI_ = _contractURI;
    }

    function contractURI() external view returns (string memory) {
        return contractURI_;
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/ERC1155.sol)

pragma solidity ^0.8.17;

import "./ERC1155URIStorage.sol";
import "./interfaces/IERC1155Receiver.sol";
import "./Address.sol";
import "./Context.sol";
import "./ERC165.sol";

abstract contract ERC1155 is Context, ERC165, ERC1155URIStorage {
    using Address for address;

    /**
    *   Mapping from token ID to account balances
    */
    mapping(uint256 => mapping(address => uint256)) private _balances;

    /**
    *   Mapping from account to operator approvals
    */
    mapping(address => mapping(address => bool)) private _operatorApprovals;

    /**
    *   Uri override
    */

    function uri(uint256 id) external view virtual override returns (string memory);

    /**
     * @dev See {IERC1155-balanceOf}.
     *  Passing the 0 address will return the amount of burnt tokens
     */
    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {
        return _balances[id][account];
    }

    /**
     * @dev See {IERC1155-balanceOfBatch}.
     *
     * Requirements:
     * - `accounts` and `ids` must have the same length.
     */
    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)
    public
    view
    virtual
    override
    returns (uint256[] memory)
    {
        require(accounts.length == ids.length, "ERC1155: accounts and ids length mismatch");
        uint256[] memory batchBalances = new uint256[](accounts.length);
        for (uint256 i = 0; i < accounts.length; ++i) {
            batchBalances[i] = balanceOf(accounts[i], ids[i]);
        }
        return batchBalances;
    }

    /**
     * @dev See {IERC1155-setApprovalForAll}.
     */
    function setApprovalForAll(address operator, bool approved) public virtual override {
        _setApprovalForAll(_msgSender(), operator, approved);
    }

    /**
     * @dev See {IERC1155-isApprovedForAll}.
     */
    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {
        return _operatorApprovals[account][operator];
    }

    /**
     * @dev See {IERC1155-safeTransferFrom}.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            "ERC1155: caller is not token owner nor approved"
        );
        _safeTransferFrom(from, to, id, amount, data);
    }

    /**
     * @dev See {IERC1155-safeBatchTransferFrom}.
     */
    function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) public virtual override {
        require(
            from == _msgSender() || isApprovedForAll(from, _msgSender()),
            "ERC1155: caller is not token owner nor approved"
        );
        _safeBatchTransferFrom(from, to, ids, amounts, data);
    }

    /**
     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.
     *
     * Emits a {TransferSingle} event.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - `from` must have a balance of tokens of type `id` of at least `amount`.
     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the
     * acceptance magic value.
     */
    function _safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) internal virtual {
        require(to != address(0), "ERC1155: transfer to the zero address");

        address operator = _msgSender();
        uint256[] memory ids = _asSingletonArray(id);
        uint256[] memory amounts = _asSingletonArray(amount);

        _beforeTokenTransfer(operator, from, to, ids, amounts, data);

        uint256 fromBalance = _balances[id][from];
        require(fromBalance >= amount, "ERC1155: insufficient balance for transfer");
    unchecked {
        _balances[id][from] = fromBalance - amount;
    }
        _balances[id][to] += amount;

        emit TransferSingle(operator, from, to, id, amount);

        _afterTokenTransfer(operator, from, to, ids, amounts, data);

        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);
    }

    /**
     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.
     *
     * Emits a {TransferBatch} event.
     *
     * Requirements:
     *
     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the
     * acceptance magic value.
     */
    function _safeBatchTransferFrom(
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) internal virtual {
        require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch");
        require(to != address(0), "ERC1155: transfer to the zero address");

        address operator = _msgSender();

        _beforeTokenTransfer(operator, from, to, ids, amounts, data);

        for (uint256 i = 0; i < ids.length; ++i) {
            uint256 id = ids[i];
            uint256 amount = amounts[i];

            uint256 fromBalance = _balances[id][from];
            require(fromBalance >= amount, "ERC1155: insufficient balance for transfer");
        unchecked {
            _balances[id][from] = fromBalance - amount;
        }
            _balances[id][to] += amount;
        }

        emit TransferBatch(operator, from, to, ids, amounts);

        _afterTokenTransfer(operator, from, to, ids, amounts, data);

        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);
    }

    /**
     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.
     *
     * Emits a {TransferSingle} event.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the
     * acceptance magic value.
     */
    function _mint(
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) internal virtual {
        require(to != address(0), "ERC1155: mint to the zero address");
        address operator = _msgSender();
        uint256[] memory ids = _asSingletonArray(id);
        uint256[] memory amounts = _asSingletonArray(amount);

        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);

        _balances[id][to] += amount;
        emit TransferSingle(operator, address(0), to, id, amount);

        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);

        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);
    }

    /**
     * @dev Destroys `amount` tokens of token type `id` from `from`
     *
     * Emits a {TransferSingle} event.
     *
     * Requirements:
     *
     * - `from` cannot be the zero address.
     * - `from` must have at least `amount` tokens of token type `id`.
     */
    function _burn(
        address from,
        uint256 id,
        uint256 amount
    ) internal virtual {
        require(from != address(0), "ERC1155: burn from the zero address");

        address operator = _msgSender();
        uint256[] memory ids = _asSingletonArray(id);
        uint256[] memory amounts = _asSingletonArray(amount);

        _beforeTokenTransfer(operator, from, address(0), ids, amounts, "");

        uint256 fromBalance = _balances[id][from];
        require(fromBalance >= amount, "ERC1155: burn amount exceeds balance");
    unchecked {
        _balances[id][from] = fromBalance - amount;
    }

        emit TransferSingle(operator, from, address(0), id, amount);

        _afterTokenTransfer(operator, from, address(0), ids, amounts, "");
    }

    /**
     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.
     *
     * Emits a {TransferBatch} event.
     *
     * Requirements:
     *
     * - `ids` and `amounts` must have the same length.
     */
    function _burnBatch(
        address from,
        uint256[] memory ids,
        uint256[] memory amounts
    ) internal virtual {
        require(from != address(0), "ERC1155: burn from the zero address");
        require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch");

        address operator = _msgSender();

        _beforeTokenTransfer(operator, from, address(0), ids, amounts, "");

        for (uint256 i = 0; i < ids.length; i++) {
            uint256 id = ids[i];
            uint256 amount = amounts[i];

            uint256 fromBalance = _balances[id][from];
            require(fromBalance >= amount, "ERC1155: burn amount exceeds balance");
        unchecked {
            _balances[id][from] = fromBalance - amount;
        }
        }

        emit TransferBatch(operator, from, address(0), ids, amounts);

        _afterTokenTransfer(operator, from, address(0), ids, amounts, "");
    }

    /**
     * @dev Approve `operator` to operate on all of `owner` tokens
     *
     * Emits an {ApprovalForAll} event.
     */
    function _setApprovalForAll(
        address owner,
        address operator,
        bool approved
    ) internal virtual {
        require(owner != operator, "ERC1155: setting approval status for self");
        _operatorApprovals[owner][operator] = approved;
        emit ApprovalForAll(owner, operator, approved);
    }

    /**
     * @dev Hook that is called before any token transfer. This includes minting
     * and burning, as well as batched variants.
     *
     * The same hook is called on both single and batched variants. For single
     * transfers, the length of the `ids` and `amounts` arrays will be 1.
     *
     * Calling conditions (for each `id` and `amount` pair):
     *
     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * of token type `id` will be  transferred to `to`.
     * - When `from` is zero, `amount` tokens of token type `id` will be minted
     * for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`
     * will be burned.
     * - `from` and `to` are never both zero.
     * - `ids` and `amounts` have the same, non-zero length.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _beforeTokenTransfer(
        address operator,
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) internal virtual {}

    /**
     * @dev Hook that is called after any token transfer. This includes minting
     * and burning, as well as batched variants.
     *
     * The same hook is called on both single and batched variants. For single
     * transfers, the length of the `id` and `amount` arrays will be 1.
     *
     * Calling conditions (for each `id` and `amount` pair):
     *
     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens
     * of token type `id` will be  transferred to `to`.
     * - When `from` is zero, `amount` tokens of token type `id` will be minted
     * for `to`.
     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`
     * will be burned.
     * - `from` and `to` are never both zero.
     * - `ids` and `amounts` have the same, non-zero length.
     *
     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
     */
    function _afterTokenTransfer(
        address operator,
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) internal virtual {}

    function _doSafeTransferAcceptanceCheck(
        address operator,
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes memory data
    ) private {
        if (to.isContract()) {
            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {
                if (response != IERC1155Receiver.onERC1155Received.selector) {
                    revert("ERC1155: ERC1155Receiver rejected tokens");
                }
            } catch Error(string memory reason) {
                revert(reason);
            } catch {
                revert("ERC1155: transfer to non ERC1155Receiver implementer");
            }
        }
    }

    function _doSafeBatchTransferAcceptanceCheck(
        address operator,
        address from,
        address to,
        uint256[] memory ids,
        uint256[] memory amounts,
        bytes memory data
    ) private {
        if (to.isContract()) {
            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (
                bytes4 response
            ) {
                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {
                    revert("ERC1155: ERC1155Receiver rejected tokens");
                }
            } catch Error(string memory reason) {
                revert(reason);
            } catch {
                revert("ERC1155: transfer to non ERC1155Receiver implementer");
            }
        }
    }

    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {
        uint256[] memory array = new uint256[](1);
        array[0] = element;

        return array;
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (utils/cryptography/MerkleProof.sol)

pragma solidity ^0.8.17;

/**
 * @dev These functions deal with verification of Merkle Tree proofs.
 *
 * The proofs can be generated using the JavaScript library
 * https://github.com/miguelmota/merkletreejs[merkletreejs].
 * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.
 *
 * See `test/utils/cryptography/MerkleProof.test.js` for some examples.
 *
 * WARNING: You should avoid using leaf values that are 64 bytes long prior to
 * hashing, or use a hash function other than keccak256 for hashing leaves.
 * This is because the concatenation of a sorted pair of internal nodes in
 * the merkle tree could be reinterpreted as a leaf value.
 */
library MerkleProof {
    /**
     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree
     * defined by `root`. For this, a `proof` must be provided, containing
     * sibling hashes on the branch from the leaf to the root of the tree. Each
     * pair of leaves and each pair of pre-images are assumed to be sorted.
     */
    function verify(
        bytes32[] memory proof,
        bytes32 root,
        bytes32 leaf
    ) internal pure returns (bool) {
        return processProof(proof, leaf) == root;
    }

    /**
     * @dev Calldata version of {verify}
     *
     * _Available since v4.7._
     */
    function verifyCalldata(
        bytes32[] calldata proof,
        bytes32 root,
        bytes32 leaf
    ) internal pure returns (bool) {
        return processProofCalldata(proof, leaf) == root;
    }

    /**
     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up
     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt
     * hash matches the root of the tree. When processing the proof, the pairs
     * of leafs & pre-images are assumed to be sorted.
     *
     * _Available since v4.4._
     */
    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {
        bytes32 computedHash = leaf;
        for (uint256 i = 0; i < proof.length; i++) {
            computedHash = _hashPair(computedHash, proof[i]);
        }
        return computedHash;
    }

    /**
     * @dev Calldata version of {processProof}
     *
     * _Available since v4.7._
     */
    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {
        bytes32 computedHash = leaf;
        for (uint256 i = 0; i < proof.length; i++) {
            computedHash = _hashPair(computedHash, proof[i]);
        }
        return computedHash;
    }

    /**
     * @dev Returns true if the `leaves` can be proved to be a part of a Merkle tree defined by
     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.
     *
     * _Available since v4.7._
     */
    function multiProofVerify(
        bytes32[] memory proof,
        bool[] memory proofFlags,
        bytes32 root,
        bytes32[] memory leaves
    ) internal pure returns (bool) {
        return processMultiProof(proof, proofFlags, leaves) == root;
    }

    /**
     * @dev Calldata version of {multiProofVerify}
     *
     * _Available since v4.7._
     */
    function multiProofVerifyCalldata(
        bytes32[] calldata proof,
        bool[] calldata proofFlags,
        bytes32 root,
        bytes32[] memory leaves
    ) internal pure returns (bool) {
        return processMultiProofCalldata(proof, proofFlags, leaves) == root;
    }

    /**
     * @dev Returns the root of a tree reconstructed from `leaves` and the sibling nodes in `proof`,
     * consuming from one or the other at each step according to the instructions given by
     * `proofFlags`.
     *
     * _Available since v4.7._
     */
    function processMultiProof(
        bytes32[] memory proof,
        bool[] memory proofFlags,
        bytes32[] memory leaves
    ) internal pure returns (bytes32 merkleRoot) {
        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by
        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the
        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of
        // the merkle tree.
        uint256 leavesLen = leaves.length;
        uint256 totalHashes = proofFlags.length;

        // Check proof validity.
        require(leavesLen + proof.length - 1 == totalHashes, "MerkleProof: invalid multiproof");

        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using
        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's "pop".
        bytes32[] memory hashes = new bytes32[](totalHashes);
        uint256 leafPos = 0;
        uint256 hashPos = 0;
        uint256 proofPos = 0;
        // At each step, we compute the next hash using two values:
        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we
        //   get the next hash.
        // - depending on the flag, either another value for the "main queue" (merging branches) or an element from the
        //   `proof` array.
        for (uint256 i = 0; i < totalHashes; i++) {
            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];
            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];
            hashes[i] = _hashPair(a, b);
        }

        if (totalHashes > 0) {
            return hashes[totalHashes - 1];
        } else if (leavesLen > 0) {
            return leaves[0];
        } else {
            return proof[0];
        }
    }

    /**
     * @dev Calldata version of {processMultiProof}
     *
     * _Available since v4.7._
     */
    function processMultiProofCalldata(
        bytes32[] calldata proof,
        bool[] calldata proofFlags,
        bytes32[] memory leaves
    ) internal pure returns (bytes32 merkleRoot) {
        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by
        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the
        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of
        // the merkle tree.
        uint256 leavesLen = leaves.length;
        uint256 totalHashes = proofFlags.length;

        // Check proof validity.
        require(leavesLen + proof.length - 1 == totalHashes, "MerkleProof: invalid multiproof");

        // The xxxPos values are "pointers" to the next value to consume in each array. All accesses are done using
        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's "pop".
        bytes32[] memory hashes = new bytes32[](totalHashes);
        uint256 leafPos = 0;
        uint256 hashPos = 0;
        uint256 proofPos = 0;
        // At each step, we compute the next hash using two values:
        // - a value from the "main queue". If not all leaves have been consumed, we get the next leaf, otherwise we
        //   get the next hash.
        // - depending on the flag, either another value for the "main queue" (merging branches) or an element from the
        //   `proof` array.
        for (uint256 i = 0; i < totalHashes; i++) {
            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];
            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];
            hashes[i] = _hashPair(a, b);
        }

        if (totalHashes > 0) {
            return hashes[totalHashes - 1];
        } else if (leavesLen > 0) {
            return leaves[0];
        } else {
            return proof[0];
        }
    }

    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {
        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);
    }

    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {
        /// @solidity memory-safe-assembly
        assembly {
            mstore(0x00, a)
            mstore(0x20, b)
            value := keccak256(0x00, 0x40)
        }
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)

pragma solidity ^0.8.17;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts

pragma solidity ^0.8.17;

import "./ERC1155.sol";

contract ERC1155URIStorage {
    string internal _baseURI = "ipfs:/";
    mapping(uint256 => string) internal _tokenURIs;
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)

pragma solidity ^0.8.17;

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     *
     * [IMPORTANT]
     * ====
     * You shouldn't rely on `isContract` to protect against flash loan attacks!
     *
     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
     * constructor.
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize/address.code.length, which returns 0
        // for contracts in construction, since the code is only stored at the end
        // of the constructor execution.

        return account.code.length > 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain `call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCall(target, data, "Address: low-level call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        require(isContract(target), "Address: call to non-contract");

        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        require(isContract(target), "Address: static call to non-contract");

        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(isContract(target), "Address: delegate call to non-contract");

        (bool success, bytes memory returndata) = target.delegatecall(data);
        return verifyCallResult(success, returndata, errorMessage);
    }

    /**
     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the
     * revert reason using the provided one.
     *
     * _Available since v4.3._
     */
    function verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            // Look for revert reason and bubble it up if present
            if (returndata.length > 0) {
                // The easiest way to bubble the revert reason is using memory via assembly
                /// @solidity memory-safe-assembly
                assembly {
                    let returndata_size := mload(returndata)
                    revert(add(32, returndata), returndata_size)
                }
            } else {
                revert(errorMessage);
            }
        }
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)

pragma solidity ^0.8.17;

import "./interfaces/IERC165.sol";
import "./interfaces/IERC1155.sol";
import "./interfaces/IERC1155MetadataURI.sol";


abstract contract ERC165 is IERC165, IERC1155, IERC1155MetadataURI {
    mapping(bytes4 => bool) private interfaces;
    bytes4 private constant INTERFACE_ID_ERC2981 = 0x2a55205a;

    constructor () {
        /**
        *   I guess I will just register everything here, to keep it simple
        */
        registerInterface(type(IERC165).interfaceId);
        registerInterface(type(IERC1155).interfaceId);
        registerInterface(type(IERC1155MetadataURI).interfaceId);
        registerInterface(INTERFACE_ID_ERC2981);
    }

    function registerInterface(bytes4 interfaceId) private {
        interfaces[interfaceId] = true;
    }

    function supportsInterface(bytes4 interfaceId) external view returns (bool) {
        return interfaces[interfaceId];
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)

pragma solidity ^0.8.17;

import "./IERC165.sol";

/**
 * @dev _Available since v3.1._
 */
interface IERC1155Receiver is IERC165 {
    /**
     * @dev Handles the receipt of a single ERC1155 token type. This function is
     * called at the end of a `safeTransferFrom` after the balance has been updated.
     *
     * NOTE: To accept the transfer, this must return
     * `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`
     * (i.e. 0xf23a6e61, or its own function selector).
     *
     * @param operator The address which initiated the transfer (i.e. msg.sender)
     * @param from The address which previously owned the token
     * @param id The ID of the token being transferred
     * @param value The amount of tokens being transferred
     * @param data Additional data with no specified format
     * @return `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` if transfer is allowed
     */
    function onERC1155Received(
        address operator,
        address from,
        uint256 id,
        uint256 value,
        bytes calldata data
    ) external returns (bytes4);

    /**
     * @dev Handles the receipt of a multiple ERC1155 token types. This function
     * is called at the end of a `safeBatchTransferFrom` after the balances have
     * been updated.
     *
     * NOTE: To accept the transfer(s), this must return
     * `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`
     * (i.e. 0xbc197c81, or its own function selector).
     *
     * @param operator The address which initiated the batch transfer (i.e. msg.sender)
     * @param from The address which previously owned the token
     * @param ids An array containing ids of each token being transferred (order and length must match values array)
     * @param values An array containing amounts of each token being transferred (order and length must match ids array)
     * @param data Additional data with no specified format
     * @return `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))` if transfer is allowed
     */
    function onERC1155BatchReceived(
        address operator,
        address from,
        uint256[] calldata ids,
        uint256[] calldata values,
        bytes calldata data
    ) external returns (bytes4);
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)

pragma solidity ^0.8.17;

/**
 * @dev Interface of the ERC165 standard, as defined in the
 * https://eips.ethereum.org/EIPS/eip-165[EIP].
 *
 * Implementers can declare support of contract interfaces, which can then be
 * queried by others ({ERC165Checker}).
 *
 * For an implementation, see {ERC165}.
 */
interface IERC165 {
    /**
     * @dev Returns true if this contract implements the interface defined by
     * `interfaceId`. See the corresponding
     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
     * to learn more about how these ids are created.
     *
     * This function call must use less than 30 000 gas.
     */
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)

pragma solidity ^0.8.17;

import "./IERC165.sol";

/**
 * @dev Required interface of an ERC1155 compliant contract, as defined in the
 * https://eips.ethereum.org/EIPS/eip-1155[EIP].
 *
 * _Available since v3.1._
 */
interface IERC1155 is IERC165 {
    /**
     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.
     */
    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);

    /**
     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all
     * transfers.
     */
    event TransferBatch(
        address indexed operator,
        address indexed from,
        address indexed to,
        uint256[] ids,
        uint256[] values
    );

    /**
     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to
     * `approved`.
     */
    event ApprovalForAll(address indexed account, address indexed operator, bool approved);

    /**
     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.
     *
     * If an {URI} event was emitted for `id`, the standard
     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value
     * returned by {IERC1155MetadataURI-uri}.
     */
    event URI(string value, uint256 indexed id);

    /**
     * @dev Returns the amount of tokens of token type `id` owned by `account`.
     *
     * Requirements:
     *
     * - `account` cannot be the zero address.
     */
    function balanceOf(address account, uint256 id) external view returns (uint256);

    /**
     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.
     *
     * Requirements:
     *
     * - `accounts` and `ids` must have the same length.
     */
    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)
        external
        view
        returns (uint256[] memory);

    /**
     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,
     *
     * Emits an {ApprovalForAll} event.
     *
     * Requirements:
     *
     * - `operator` cannot be the caller.
     */
    function setApprovalForAll(address operator, bool approved) external;

    /**
     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.
     *
     * See {setApprovalForAll}.
     */
    function isApprovedForAll(address account, address operator) external view returns (bool);

    /**
     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.
     *
     * Emits a {TransferSingle} event.
     *
     * Requirements:
     *
     * - `to` cannot be the zero address.
     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.
     * - `from` must have a balance of tokens of type `id` of at least `amount`.
     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the
     * acceptance magic value.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes calldata data
    ) external;

    /**
     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.
     *
     * Emits a {TransferBatch} event.
     *
     * Requirements:
     *
     * - `ids` and `amounts` must have the same length.
     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the
     * acceptance magic value.
     */
    function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] calldata ids,
        uint256[] calldata amounts,
        bytes calldata data
    ) external;
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)

pragma solidity ^0.8.17;

/**
 * @dev Interface of the optional ERC1155MetadataExtension interface, as defined
 * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].
 *
 * _Available since v3.1._
 */
interface IERC1155MetadataURI {
    /**
     * @dev Returns the URI for token type `id`.
     *
     * If the `\{id\}` substring is present in the URI, it must be replaced by
     * clients with the actual token type ID.
     */
    function uri(uint256 id) external view returns (string memory);
}