{{

  "language": "Solidity",

  "sources": {

    "src/Greenhouse.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport {Auth} from \"chronicle-std/auth/Auth.sol\";\nimport {Toll} from \"chronicle-std/toll/Toll.sol\";\n\nimport {IGreenhouse} from \"./IGreenhouse.sol\";\n\nimport {LibCREATE3} from \"./libs/LibCREATE3.sol\";\n\n/**\n * @title Greenhouse\n * @custom:version 1.0.0\n *\n * @notice A greenhouse to plant contracts using CREATE3\n *\n * @dev Greenhouse is a contract factory planting contracts at deterministic\n *      addresses. The address of the planted contract solely depends on the\n *      provided salt.\n *\n *      The contract uses `chronicle-std`'s `Auth` module to grant addresses\n *      access to protected functions. `chronicle-std`'s `Toll` module is\n *      utilized to determine which addresses are eligible to plant new\n *      contracts. Note that auth'ed addresses are _not_ eligible to plant new\n *      contracts.\n */\ncontract Greenhouse is IGreenhouse, Auth, Toll {\n    constructor(address initialAuthed) Auth(initialAuthed) {}\n\n    /// @inheritdoc IGreenhouse\n    ///\n    /// @custom:invariant Planted contract's address is deterministic and solely\n    ///                   depends on `salt`.\n    ///                     ∀s ∊ bytes32: plant(s, _) = addressOf(s)\n    function plant(bytes32 salt, bytes memory creationCode)\n        external\n        toll\n        returns (address)\n    {\n        if (salt == bytes32(0)) {\n            revert EmptySalt();\n        }\n        if (creationCode.length == 0) {\n            revert EmptyCreationCode();\n        }\n\n        if (addressOf(salt).code.length != 0) {\n            revert AlreadyPlanted(salt);\n        }\n\n        bool ok;\n        address addr;\n        (ok, addr) = LibCREATE3.tryDeploy(salt, creationCode);\n        if (!ok) {\n            revert PlantingFailed(salt);\n        }\n        // assert(addr == addressOf(salt));\n\n        emit Planted(msg.sender, salt, addr);\n\n        return addr;\n    }\n\n    /// @inheritdoc IGreenhouse\n    function addressOf(bytes32 salt) public view returns (address) {\n        return LibCREATE3.addressOf(salt);\n    }\n\n    /// @dev Defines authorization for IToll's authenticated functions.\n    function toll_auth() internal override(Toll) auth {}\n}\n"

    },

    "lib/chronicle-std/src/auth/Auth.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport {IAuth} from \"./IAuth.sol\";\n\n/**\n * @title Auth Module\n *\n * @dev The `Auth` contract module provides a basic access control mechanism,\n *      where a set of addresses are granted access to protected functions.\n *      These addresses are said to be _auth'ed_.\n *\n *      Initially, the address given as constructor argument is the only address\n *      auth'ed. Through the `rely(address)` and `deny(address)` functions,\n *      auth'ed callers are able to grant/renounce auth to/from addresses.\n *\n *      This module is used through inheritance. It will make available the\n *      modifier `auth`, which can be applied to functions to restrict their\n *      use to only auth'ed callers.\n */\nabstract contract Auth is IAuth {\n    /// @dev Mapping storing whether address is auth'ed.\n    /// @custom:invariant Image of mapping is {0, 1}.\n    ///                     ∀x ∊ Address: _wards[x] ∊ {0, 1}\n    /// @custom:invariant Only address given as constructor argument is authenticated after deployment.\n    ///                     deploy(initialAuthed) → (∀x ∊ Address: _wards[x] == 1 → x == initialAuthed)\n    /// @custom:invariant Only functions `rely` and `deny` may mutate the mapping's state.\n    ///                     ∀x ∊ Address: preTx(_wards[x]) != postTx(_wards[x])\n    ///                                     → (msg.sig == \"rely\" ∨ msg.sig == \"deny\")\n    /// @custom:invariant Mapping's state may only be mutated by authenticated caller.\n    ///                     ∀x ∊ Address: preTx(_wards[x]) != postTx(_wards[x]) → _wards[msg.sender] = 1\n    mapping(address => uint) private _wards;\n\n    /// @dev List of addresses possibly being auth'ed.\n    /// @dev May contain duplicates.\n    /// @dev May contain addresses not being auth'ed anymore.\n    /// @custom:invariant Every address being auth'ed once is element of the list.\n    ///                     ∀x ∊ Address: authed(x) -> x ∊ _wardsTouched\n    address[] private _wardsTouched;\n\n    /// @dev Ensures caller is auth'ed.\n    modifier auth() {\n        assembly (\"memory-safe\") {\n            // Compute slot of _wards[msg.sender].\n            mstore(0x00, caller())\n            mstore(0x20, _wards.slot)\n            let slot := keccak256(0x00, 0x40)\n\n            // Revert if caller not auth'ed.\n            let isAuthed := sload(slot)\n            if iszero(isAuthed) {\n                // Store selector of `NotAuthorized(address)`.\n                mstore(0x00, 0x4a0bfec1)\n                // Store msg.sender.\n                mstore(0x20, caller())\n                // Revert with (offset, size).\n                revert(0x1c, 0x24)\n            }\n        }\n        _;\n    }\n\n    constructor(address initialAuthed) {\n        _wards[initialAuthed] = 1;\n        _wardsTouched.push(initialAuthed);\n\n        // Note to use address(0) as caller to indicate address was auth'ed\n        // during deployment.\n        emit AuthGranted(address(0), initialAuthed);\n    }\n\n    /// @inheritdoc IAuth\n    function rely(address who) external auth {\n        if (_wards[who] == 1) return;\n\n        _wards[who] = 1;\n        _wardsTouched.push(who);\n        emit AuthGranted(msg.sender, who);\n    }\n\n    /// @inheritdoc IAuth\n    function deny(address who) external auth {\n        if (_wards[who] == 0) return;\n\n        _wards[who] = 0;\n        emit AuthRenounced(msg.sender, who);\n    }\n\n    /// @inheritdoc IAuth\n    function authed(address who) public view returns (bool) {\n        return _wards[who] == 1;\n    }\n\n    /// @inheritdoc IAuth\n    /// @custom:invariant Only contains auth'ed addresses.\n    ///                     ∀x ∊ authed(): _wards[x] == 1\n    /// @custom:invariant Contains all auth'ed addresses.\n    ///                     ∀x ∊ Address: _wards[x] == 1 → x ∊ authed()\n    function authed() public view returns (address[] memory) {\n        // Initiate array with upper limit length.\n        address[] memory wardsList = new address[](_wardsTouched.length);\n\n        // Iterate through all possible auth'ed addresses.\n        uint ctr;\n        for (uint i; i < wardsList.length; i++) {\n            // Add address only if still auth'ed.\n            if (_wards[_wardsTouched[i]] == 1) {\n                wardsList[ctr++] = _wardsTouched[i];\n            }\n        }\n\n        // Set length of array to number of auth'ed addresses actually included.\n        assembly (\"memory-safe\") {\n            mstore(wardsList, ctr)\n        }\n\n        return wardsList;\n    }\n\n    /// @inheritdoc IAuth\n    function wards(address who) public view returns (uint) {\n        return _wards[who];\n    }\n}\n"

    },

    "lib/chronicle-std/src/toll/Toll.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport {IToll} from \"./IToll.sol\";\n\n/**\n * @title Toll Module\n *\n * @notice \"Toll paid, we kiss - but dissension looms, maybe diss?\"\n *\n * @dev The `Toll` contract module provides a basic access control mechanism,\n *      where a set of addresses are granted access to protected functions.\n *      These addresses are said the be _tolled_.\n *\n *      Initially, no address is tolled. Through the `kiss(address)` and\n *      `diss(address)` functions, auth'ed callers are able to toll/de-toll\n *      addresses. Authentication for these functions is defined via the\n *      downstream implemented `toll_auth()` function.\n *\n *      This module is used through inheritance. It will make available the\n *      modifier `toll`, which can be applied to functions to restrict their\n *      use to only tolled callers.\n */\nabstract contract Toll is IToll {\n    /// @dev Mapping storing whether address is tolled.\n    /// @custom:invariant Image of mapping is {0, 1}.\n    ///                     ∀x ∊ Address: _buds[x] ∊ {0, 1}\n    /// @custom:invariant Only functions `kiss` and `diss` may mutate the mapping's state.\n    ///                     ∀x ∊ Address: preTx(_buds[x]) != postTx(_buds[x])\n    ///                                     → (msg.sig == \"kiss\" ∨ msg.sig == \"diss\")\n    /// @custom:invariant Mapping's state may only be mutated by authenticated caller.\n    ///                     ∀x ∊ Address: preTx(_buds[x]) != postTx(_buds[x])\n    ///                                     → toll_auth()\n    mapping(address => uint) private _buds;\n\n    /// @dev List of addresses possibly being tolled.\n    /// @dev May contain duplicates.\n    /// @dev May contain addresses not being tolled anymore.\n    /// @custom:invariant Every address being tolled once is element of the list.\n    ///                     ∀x ∊ Address: tolled(x) → x ∊ _budsTouched\n    address[] private _budsTouched;\n\n    /// @dev Ensures caller is tolled.\n    modifier toll() {\n        assembly (\"memory-safe\") {\n            // Compute slot of _buds[msg.sender].\n            mstore(0x00, caller())\n            mstore(0x20, _buds.slot)\n            let slot := keccak256(0x00, 0x40)\n\n            // Revert if caller not tolled.\n            let isTolled := sload(slot)\n            if iszero(isTolled) {\n                // Store selector of `NotTolled(address)`.\n                mstore(0x00, 0xd957b595)\n                // Store msg.sender.\n                mstore(0x20, caller())\n                // Revert with (offset, size).\n                revert(0x1c, 0x24)\n            }\n        }\n        _;\n    }\n\n    /// @dev Reverts if caller not allowed to access protected function.\n    /// @dev Must be implemented in downstream contract.\n    function toll_auth() internal virtual;\n\n    /// @inheritdoc IToll\n    function kiss(address who) external {\n        toll_auth();\n\n        if (_buds[who] == 1) return;\n\n        _buds[who] = 1;\n        _budsTouched.push(who);\n        emit TollGranted(msg.sender, who);\n    }\n\n    /// @inheritdoc IToll\n    function diss(address who) external {\n        toll_auth();\n\n        if (_buds[who] == 0) return;\n\n        _buds[who] = 0;\n        emit TollRenounced(msg.sender, who);\n    }\n\n    /// @inheritdoc IToll\n    function tolled(address who) public view returns (bool) {\n        return _buds[who] == 1;\n    }\n\n    /// @inheritdoc IToll\n    /// @custom:invariant Only contains tolled addresses.\n    ///                     ∀x ∊ tolled(): _tolled[x]\n    /// @custom:invariant Contains all tolled addresses.\n    ///                     ∀x ∊ Address: _tolled[x] == 1 → x ∊ tolled()\n    function tolled() public view returns (address[] memory) {\n        // Initiate array with upper limit length.\n        address[] memory budsList = new address[](_budsTouched.length);\n\n        // Iterate through all possible tolled addresses.\n        uint ctr;\n        for (uint i; i < budsList.length; i++) {\n            // Add address only if still tolled.\n            if (_buds[_budsTouched[i]] == 1) {\n                budsList[ctr++] = _budsTouched[i];\n            }\n        }\n\n        // Set length of array to number of tolled addresses actually included.\n        assembly (\"memory-safe\") {\n            mstore(budsList, ctr)\n        }\n\n        return budsList;\n    }\n\n    /// @inheritdoc IToll\n    function bud(address who) public view returns (uint) {\n        return _buds[who];\n    }\n}\n"

    },

    "src/IGreenhouse.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\ninterface IGreenhouse {\n    /// @notice Thrown if salt `salt` already planted.\n    /// @param salt The salt to plant.\n    error AlreadyPlanted(bytes32 salt);\n\n    /// @notice Thrown if planting at salt `salt` failed.\n    /// @param salt The salt to plant.\n    error PlantingFailed(bytes32 salt);\n\n    /// @notice Thrown if provided salt is empty.\n    error EmptySalt();\n\n    /// @notice Thrown if provided creation code is empty.\n    error EmptyCreationCode();\n\n    /// @notice Emitted when new contract planted.\n    /// @param caller The caller's address.\n    /// @param salt The salt the contract got planted at.\n    /// @param addr The address of the planted contract.\n    event Planted(\n        address indexed caller, bytes32 indexed salt, address indexed addr\n    );\n\n    /// @notice Plants a new contract with creation code `creationCode` to a\n    ///         deterministic address solely depending on the salt `salt`.\n    ///\n    /// @dev Only callable by toll'ed addresses.\n    ///\n    /// @dev Note to add constructor arguments to the creation code, if\n    ///      applicable!\n    ///\n    /// @custom:example Appending constructor arguments to the creation code:\n    ///\n    ///     ```solidity\n    ///     bytes memory creationCode = abi.encodePacked(\n    ///         // Receive the creation code of `MyContract`.\n    ///         type(MyContract).creationCode,\n    ///\n    ///         // `MyContract` receives as constructor arguments an address\n    ///         // and a uint.\n    ///         abi.encode(address(0xcafe), uint(1))\n    ///     );\n    ///     ```\n    ///\n    /// @param salt The salt to plant the contract at.\n    /// @param creationCode The creation code of the contract to plant.\n    /// @return The address of the planted contract.\n    function plant(bytes32 salt, bytes memory creationCode)\n        external\n        returns (address);\n\n    /// @notice Returns the deterministic address for salt `salt`.\n    /// @dev Note that the address is not guaranteed to be utilized yet.\n    ///\n    /// @custom:example Verifying a contract is planted at some salt:\n    ///\n    ///     ```solidity\n    ///     bytes32 salt = bytes32(\"salt\");\n    ///     address contract_ = addressOf(salt);\n    ///     bool isPlanted = contract_.code.length != 0;\n    ///     ```\n    ///\n    /// @param salt The salt to query their deterministic address.\n    /// @return The deterministic address for given salt.\n    function addressOf(bytes32 salt) external view returns (address);\n}\n"

    },

    "src/libs/LibCREATE3.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n/**\n * @title LibCREATE3\n *\n * @notice Library to deploy to deterministic addresses without an initcode\n *         factor\n *\n * @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/e8f96f25d48fe702117ce76c79228ca4f20206cb/src/utils/CREATE3.sol)\n * @author Modified from Solady (https://github.com/Vectorized/solady/blob/50cbe1909e773b7e4ba76049c75a203e626d55ba/src/utils/CREATE3.sol)\n */\nlibrary LibCREATE3 {\n    // ╭────────────────────────────────────────────────────────────────────╮\n    // │ Opcode      │ Mnemonic         │ Stack        │ Memory             │\n    // ├────────────────────────────────────────────────────────────────────┤\n    // │ 36          │ CALLDATASIZE     │ cds          │                    │\n    // │ 3d          │ RETURNDATASIZE   │ 0 cds        │                    │\n    // │ 3d          │ RETURNDATASIZE   │ 0 0 cds      │                    │\n    // │ 37          │ CALLDATACOPY     │              │ [0..cds): calldata │\n    // │ 36          │ CALLDATASIZE     │ cds          │ [0..cds): calldata │\n    // │ 3d          │ RETURNDATASIZE   │ 0 cds        │ [0..cds): calldata │\n    // │ 34          │ CALLVALUE        │ value 0 cds  │ [0..cds): calldata │\n    // │ f0          │ CREATE           │ newContract  │ [0..cds): calldata │\n    // ├────────────────────────────────────────────────────────────────────┤\n    // │ Opcode      │ Mnemonic         │ Stack        │ Memory             │\n    // ├────────────────────────────────────────────────────────────────────┤\n    // │ 67 bytecode │ PUSH8 bytecode   │ bytecode     │                    │\n    // │ 3d          │ RETURNDATASIZE   │ 0 bytecode   │                    │\n    // │ 52          │ MSTORE           │              │ [0..8): bytecode   │\n    // │ 60 0x08     │ PUSH1 0x08       │ 0x08         │ [0..8): bytecode   │\n    // │ 60 0x18     │ PUSH1 0x18       │ 0x18 0x08    │ [0..8): bytecode   │\n    // │ f3          │ RETURN           │              │ [0..8): bytecode   │\n    // ╰────────────────────────────────────────────────────────────────────╯\n    bytes private constant _PROXY_BYTECODE =\n        hex\"67363d3d37363d34f03d5260086018f3\";\n\n    bytes32 private constant _PROXY_BYTECODE_HASH = keccak256(_PROXY_BYTECODE);\n\n    /// @dev Deploys `creationCode` deterministically with `salt` and returns the\n    ///      deployed contract's address.\n    ///\n    ///      Note that the address of the deployed contract solely depends on\n    ///      `salt`. The deterministic address for `salt` can be computed\n    ///      beforehand via `addressOf(bytes32)(address)`.\n    function tryDeploy(bytes32 salt, bytes memory creationCode)\n        internal\n        returns (bool, address)\n    {\n        // Load proxy's bytecode into memory as direct access not supported in\n        // inline assembly.\n        bytes memory proxyBytecode = _PROXY_BYTECODE;\n\n        address proxy;\n        assembly (\"memory-safe\") {\n            // Deploy a new contract with pre-made bytecode via CREATE2.\n            // Start 32 bytes into the code to avoid copying the byte length.\n            // forgefmt: disable-next-item\n            proxy := create2(\n                        0,\n                        add(proxyBytecode, 32),\n                        mload(proxyBytecode),\n                        salt\n                     )\n        }\n\n        // Fail if deployment failed.\n        if (proxy == address(0)) {\n            return (false, address(0));\n        }\n\n        // Get deployed proxy and initialize creationCode.\n        address deployed = addressOf(salt);\n        (bool ok,) = proxy.call(creationCode);\n\n        // Fail if call or initialization failed.\n        if (!ok || deployed.code.length == 0) {\n            return (false, address(0));\n        }\n\n        // Otherwise return deployed contract address.\n        return (true, deployed);\n    }\n\n    /// @dev Returns the deterministic address for `salt`.\n    function addressOf(bytes32 salt) internal view returns (address) {\n        address proxy = address(\n            uint160(\n                uint(\n                    keccak256(\n                        abi.encodePacked(\n                            // Prefix:\n                            bytes1(0xFF),\n                            // Creator:\n                            address(this),\n                            // Salt:\n                            salt,\n                            // Bytecode hash:\n                            _PROXY_BYTECODE_HASH\n                        )\n                    )\n                )\n            )\n        );\n\n        return address(\n            uint160(\n                uint(\n                    keccak256(\n                        abi.encodePacked(\n                            // 0xd6 =   0xc0 (short RLP prefix)\n                            //        + 0x16 (length of 0x94 ++ proxy ++ 0x01)\n                            // 0x94 =   0x80\n                            //        + 0x14 (0x14 = 20 = length of address)\n                            hex\"d694\",\n                            proxy,\n                            // Nonce of proxy contract:\n                            hex\"01\"\n                        )\n                    )\n                )\n            )\n        );\n    }\n}\n"

    },

    "lib/chronicle-std/src/auth/IAuth.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\ninterface IAuth {\n    /// @notice Thrown by protected function if caller not auth'ed.\n    /// @param caller The caller's address.\n    error NotAuthorized(address caller);\n\n    /// @notice Emitted when auth granted to address.\n    /// @param caller The caller's address.\n    /// @param who The address auth got granted to.\n    event AuthGranted(address indexed caller, address indexed who);\n\n    /// @notice Emitted when auth renounced from address.\n    /// @param caller The caller's address.\n    /// @param who The address auth got renounced from.\n    event AuthRenounced(address indexed caller, address indexed who);\n\n    /// @notice Grants address `who` auth.\n    /// @dev Only callable by auth'ed address.\n    /// @param who The address to grant auth.\n    function rely(address who) external;\n\n    /// @notice Renounces address `who`'s auth.\n    /// @dev Only callable by auth'ed address.\n    /// @param who The address to renounce auth.\n    function deny(address who) external;\n\n    /// @notice Returns whether address `who` is auth'ed.\n    /// @param who The address to check.\n    /// @return True if `who` is auth'ed, false otherwise.\n    function authed(address who) external view returns (bool);\n\n    /// @notice Returns full list of addresses granted auth.\n    /// @dev May contain duplicates.\n    /// @return List of addresses granted auth.\n    function authed() external view returns (address[] memory);\n\n    /// @notice Returns whether address `who` is auth'ed.\n    /// @custom:deprecated Use `authed(address)(bool)` instead.\n    /// @param who The address to check.\n    /// @return 1 if `who` is auth'ed, 0 otherwise.\n    function wards(address who) external view returns (uint);\n}\n"

    },

    "lib/chronicle-std/src/toll/IToll.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\ninterface IToll {\n    /// @notice Thrown by protected function if caller not tolled.\n    /// @param caller The caller's address.\n    error NotTolled(address caller);\n\n    /// @notice Emitted when toll granted to address.\n    /// @param caller The caller's address.\n    /// @param who The address toll got granted to.\n    event TollGranted(address indexed caller, address indexed who);\n\n    /// @notice Emitted when toll renounced from address.\n    /// @param caller The caller's address.\n    /// @param who The address toll got renounced from.\n    event TollRenounced(address indexed caller, address indexed who);\n\n    /// @notice Grants address `who` toll.\n    /// @dev Only callable by auth'ed address.\n    /// @param who The address to grant toll.\n    function kiss(address who) external;\n\n    /// @notice Renounces address `who`'s toll.\n    /// @dev Only callable by auth'ed address.\n    /// @param who The address to renounce toll.\n    function diss(address who) external;\n\n    /// @notice Returns whether address `who` is tolled.\n    /// @param who The address to check.\n    /// @return True if `who` is tolled, false otherwise.\n    function tolled(address who) external view returns (bool);\n\n    /// @notice Returns full list of addresses tolled.\n    /// @dev May contain duplicates.\n    /// @return List of addresses tolled.\n    function tolled() external view returns (address[] memory);\n\n    /// @notice Returns whether address `who` is tolled.\n    /// @custom:deprecated Use `tolled(address)(bool)` instead.\n    /// @param who The address to check.\n    /// @return 1 if `who` is tolled, 0 otherwise.\n    function bud(address who) external view returns (uint);\n}\n"

    }

  },

  "settings": {

    "remappings": [

      "ds-test/=lib/forge-std/lib/ds-test/src/",

      "forge-std/=lib/forge-std/src/",

      "chronicle-std/=lib/chronicle-std/src/",

      "@script/chronicle-std/=lib/chronicle-std/script/"

    ],

    "optimizer": {

      "enabled": true,

      "runs": 10000

    },

    "metadata": {

      "useLiteralContent": false,

      "bytecodeHash": "ipfs"

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "evmVersion": "london",

    "viaIR": true,

    "libraries": {}

  }

}}