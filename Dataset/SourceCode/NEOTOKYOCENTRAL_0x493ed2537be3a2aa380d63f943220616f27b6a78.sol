/**

 *Submitted for verification at Etherscan.io on 2023-06-24

*/



// SPDX-License-Identifier: UNLICENSED



pragma solidity ^0.8.0;



/**

 * @title NEO TOKYO CENTRAL (Staking contract)

 * @author 0xSumo

 * @notice NEO TOKYO CENTRAL handles staking and unstaking of Neo Tokyo Punks and ROARS.

 */



/// OwnControll by 0xSumo

abstract contract OwnControll {

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    event AdminSet(bytes32 indexed controllerType, bytes32 indexed controllerSlot, address indexed controller, bool status);

    address public owner;

    mapping(bytes32 => mapping(address => bool)) internal admin;

    constructor() { owner = msg.sender; }

    modifier onlyOwner() { require(owner == msg.sender, "only owner");_; }

    modifier onlyAdmin(string memory type_) { require(isAdmin(type_, msg.sender), "only admin");_; }

    function transferOwnership(address newOwner) external onlyOwner { emit OwnershipTransferred(owner, newOwner); owner = newOwner; }

    function setAdmin(string calldata type_, address controller, bool status) external onlyOwner { bytes32 typeHash = keccak256(abi.encodePacked(type_)); admin[typeHash][controller] = status; emit AdminSet(typeHash, typeHash, controller, status); }

    function isAdmin(string memory type_, address controller) public view returns (bool) { bytes32 typeHash = keccak256(abi.encodePacked(type_)); return admin[typeHash][controller]; }

}



library RLPReader {

    uint8 constant STRING_SHORT_START = 0x80;

    uint8 constant STRING_LONG_START = 0xb8;

    uint8 constant LIST_SHORT_START = 0xc0;

    uint8 constant LIST_LONG_START = 0xf8;

    uint8 constant WORD_SIZE = 32;



    struct RLPItem {

        uint256 len;

        uint256 memPtr;

    }



    struct Iterator {

        RLPItem item;

        uint256 nextPtr;

    }



    function next(Iterator memory self) internal pure returns (RLPItem memory) {

        require(hasNext(self));

        uint256 ptr = self.nextPtr;

        uint256 itemLength = _itemLength(ptr);

        self.nextPtr = ptr + itemLength;

        return RLPItem(itemLength, ptr);

    }



    function hasNext(Iterator memory self) internal pure returns (bool) {

        RLPItem memory item = self.item;

        return self.nextPtr < item.memPtr + item.len;

    }



    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {

        uint256 memPtr;

        assembly {

            memPtr := add(item, 0x20)

        }

        return RLPItem(item.length, memPtr);

    }



    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {

        require(isList(self));

        uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);

        return Iterator(self, ptr);

    }



    function rlpLen(RLPItem memory item) internal pure returns (uint256) {

        return item.len;

    }



    function payloadLen(RLPItem memory item) internal pure returns (uint256) {

        return item.len - _payloadOffset(item.memPtr);

    }



    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {

        require(isList(item));

        uint256 items = numItems(item);

        RLPItem[] memory result = new RLPItem[](items);

        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);

        uint256 dataLen;

        for (uint256 i = 0; i < items; i++) {

            dataLen = _itemLength(memPtr);

            result[i] = RLPItem(dataLen, memPtr);

            memPtr = memPtr + dataLen;

        }

        return result;

    }



    function isList(RLPItem memory item) internal pure returns (bool) {

        if (item.len == 0) return false;



        uint8 byte0;

        uint256 memPtr = item.memPtr;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }



        if (byte0 < LIST_SHORT_START) return false;

        return true;

    }



    function rlpBytesKeccak256(RLPItem memory item) internal pure returns (bytes32) {

        uint256 ptr = item.memPtr;

        uint256 len = item.len;

        bytes32 result;

        assembly {

            result := keccak256(ptr, len)

        }

        return result;

    }



    function payloadLocation(RLPItem memory item) internal pure returns (uint256, uint256) {

        uint256 offset = _payloadOffset(item.memPtr);

        uint256 memPtr = item.memPtr + offset;

        uint256 len = item.len - offset; // data length

        return (memPtr, len);

    }



    function payloadKeccak256(RLPItem memory item) internal pure returns (bytes32) {

        (uint256 memPtr, uint256 len) = payloadLocation(item);

        bytes32 result;

        assembly {

            result := keccak256(memPtr, len)

        }

        return result;

    }



    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {

        bytes memory result = new bytes(item.len);

        if (result.length == 0) return result;

        uint256 ptr;

        assembly {

            ptr := add(0x20, result)

        }

        copy(item.memPtr, ptr, item.len);

        return result;

    }



    function toBoolean(RLPItem memory item) internal pure returns (bool) {

        require(item.len == 1);

        uint256 result;

        uint256 memPtr = item.memPtr;

        assembly {

            result := byte(0, mload(memPtr))

        }



        return result == 0 ? false : true;

    }



    function toAddress(RLPItem memory item) internal pure returns (address) {

        require(item.len == 21);

        return address(uint160(toUint(item)));

    }



    function toUint(RLPItem memory item) internal pure returns (uint256) {

        require(item.len > 0 && item.len <= 33);

        uint256 offset = _payloadOffset(item.memPtr);

        uint256 len = item.len - offset;

        uint256 result;

        uint256 memPtr = item.memPtr + offset;

        assembly {

            result := mload(memPtr)

            if lt(len, 32) {

                result := div(result, exp(256, sub(32, len)))

            }

        }

        return result;

    }



    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {

        require(item.len == 33);

        uint256 result;

        uint256 memPtr = item.memPtr + 1;

        assembly {

            result := mload(memPtr)

        }

        return result;

    }



    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {

        require(item.len > 0);

        uint256 offset = _payloadOffset(item.memPtr);

        uint256 len = item.len - offset;

        bytes memory result = new bytes(len);

        uint256 destPtr;

        assembly {

            destPtr := add(0x20, result)

        }

        copy(item.memPtr + offset, destPtr, len);

        return result;

    }



    function numItems(RLPItem memory item) private pure returns (uint256) {

        if (item.len == 0) return 0;

        uint256 count = 0;

        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);

        uint256 endPtr = item.memPtr + item.len;

        while (currPtr < endPtr) {

            currPtr = currPtr + _itemLength(currPtr);

            count++;

        }

        return count;

    }



    function _itemLength(uint256 memPtr) private pure returns (uint256) {

        uint256 itemLen;

        uint256 byte0;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }

        if (byte0 < STRING_SHORT_START) itemLen = 1;

        else if (byte0 < STRING_LONG_START) itemLen = byte0 - STRING_SHORT_START + 1;

        else if (byte0 < LIST_SHORT_START) {

            assembly {

                let byteLen := sub(byte0, 0xb7)

                memPtr := add(memPtr, 1)

                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen)))

                itemLen := add(dataLen, add(byteLen, 1))

            }

        } else if (byte0 < LIST_LONG_START) {

            itemLen = byte0 - LIST_SHORT_START + 1;

        } else {

            assembly {

                let byteLen := sub(byte0, 0xf7)

                memPtr := add(memPtr, 1)

                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen)))

                itemLen := add(dataLen, add(byteLen, 1))

            }

        }

        return itemLen;

    }



    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {

        uint256 byte0;

        assembly {

            byte0 := byte(0, mload(memPtr))

        }

        if (byte0 < STRING_SHORT_START) return 0;

        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)) return 1;

        else if (byte0 < LIST_SHORT_START)

            return byte0 - (STRING_LONG_START - 1) + 1;

        else return byte0 - (LIST_LONG_START - 1) + 1;

    }



    function copy(uint256 src, uint256 dest, uint256 len) private pure {

        if (len == 0) return;

        for (; len >= WORD_SIZE; len -= WORD_SIZE) {

            assembly {

                mstore(dest, mload(src))

            }

            src += WORD_SIZE;

            dest += WORD_SIZE;

        }

        if (len == 0) return;

        uint256 mask = 256**(WORD_SIZE - len) - 1;



        assembly {

            let srcpart := and(mload(src), not(mask))

            let destpart := and(mload(dest), mask)

            mstore(dest, or(destpart, srcpart))

        }

    }

}



library MerklePatriciaProof {

    function verify(bytes memory value, bytes memory encodedPath, bytes memory rlpParentNodes, bytes32 root) internal pure returns (bool) {

        RLPReader.RLPItem memory item = RLPReader.toRlpItem(rlpParentNodes);

        RLPReader.RLPItem[] memory parentNodes = RLPReader.toList(item);

        bytes memory currentNode;

        RLPReader.RLPItem[] memory currentNodeList;

        bytes32 nodeKey = root;

        uint256 pathPtr = 0;

        bytes memory path = _getNibbleArray(encodedPath);

        if (path.length == 0) {

            return false;

        }

        for (uint256 i = 0; i < parentNodes.length; i++) {

            if (pathPtr > path.length) {

                return false;

            }

            currentNode = RLPReader.toRlpBytes(parentNodes[i]);

            if (nodeKey != keccak256(currentNode)) {

                return false;

            }

            currentNodeList = RLPReader.toList(parentNodes[i]);

            if (currentNodeList.length == 17) {

                if (pathPtr == path.length) {

                    if (keccak256(RLPReader.toBytes(currentNodeList[16])) == keccak256(value)) {

                        return true;

                    } else {

                        return false;

                    }

                }

                uint8 nextPathNibble = uint8(path[pathPtr]);

                if (nextPathNibble > 16) {

                    return false;

                }

                nodeKey = bytes32(RLPReader.toUintStrict(currentNodeList[nextPathNibble]));

                pathPtr += 1;

            } else if (currentNodeList.length == 2) {

                uint256 traversed = _nibblesToTraverse(RLPReader.toBytes(currentNodeList[0]), path, pathPtr);

                if (pathPtr + traversed == path.length) {

                    if (keccak256(RLPReader.toBytes(currentNodeList[1])) == keccak256(value)) {

                        return true;

                    } else {

                        return false;

                    }

                }

                if (traversed == 0) {

                    return false;

                }

                pathPtr += traversed;

                nodeKey = bytes32(RLPReader.toUintStrict(currentNodeList[1]));

            } else {

                return false;

            }

        }

    }



    function _nibblesToTraverse(bytes memory encodedPartialPath, bytes memory path, uint256 pathPtr) private pure returns (uint256) {

        uint256 len = 0;

        bytes memory partialPath = _getNibbleArray(encodedPartialPath);

        bytes memory slicedPath = new bytes(partialPath.length);

        for (uint256 i = pathPtr; i < pathPtr + partialPath.length; i++) {

            bytes1 pathNibble = path[i];

            slicedPath[i - pathPtr] = pathNibble;

        }

        if (keccak256(partialPath) == keccak256(slicedPath)) {

            len = partialPath.length;

        } else {

            len = 0;

        }

        return len;

    }



    function _getNibbleArray(bytes memory b) internal pure returns (bytes memory) {

        bytes memory nibbles = "";

        if (b.length > 0) {

            uint8 offset;

            uint8 hpNibble = uint8(_getNthNibbleOfBytes(0, b));

            if (hpNibble == 1 || hpNibble == 3) {

                nibbles = new bytes(b.length * 2 - 1);

                bytes1 oddNibble = _getNthNibbleOfBytes(1, b);

                nibbles[0] = oddNibble;

                offset = 1;

            } else {

                nibbles = new bytes(b.length * 2 - 2);

                offset = 0;

            }



            for (uint256 i = offset; i < nibbles.length; i++) {

                nibbles[i] = _getNthNibbleOfBytes(i - offset + 2, b);

            }

        }

        return nibbles;

    }



    function _getNthNibbleOfBytes(uint256 n, bytes memory str) private pure returns (bytes1) {

        return bytes1(n % 2 == 0 ? uint8(str[n / 2]) / 0x10 : uint8(str[n / 2]) % 0x10);

    }

}



library Merkle {

    function checkMembership(bytes32 leaf, uint256 index, bytes32 rootHash, bytes memory proof) internal pure returns (bool) {

        require(proof.length % 32 == 0, "Invalid proof length");

        uint256 proofHeight = proof.length / 32;

        require(index < 2**proofHeight, "Leaf index is too big");

        bytes32 proofElement;

        bytes32 computedHash = leaf;

        for (uint256 i = 32; i <= proof.length; i += 32) {

            assembly {

                proofElement := mload(add(proof, i))

            }

            if (index % 2 == 0) {

                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));

            } else {

                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));

            }

            index = index / 2;

        }

        return computedHash == rootHash;

    }

}



library ExitPayloadReader {

    using RLPReader for bytes;

    using RLPReader for RLPReader.RLPItem;



    uint8 constant WORD_SIZE = 32;



    struct ExitPayload {

        RLPReader.RLPItem[] data;

    }



    struct Receipt {

        RLPReader.RLPItem[] data;

        bytes raw;

        uint256 logIndex;

    }



    struct Log {

        RLPReader.RLPItem data;

        RLPReader.RLPItem[] list;

    }



    struct LogTopics {

        RLPReader.RLPItem[] data;

    }



    function copy(uint256 src, uint256 dest, uint256 len) private pure {

        if (len == 0) return;

        for (; len >= WORD_SIZE; len -= WORD_SIZE) {

            assembly {

                mstore(dest, mload(src))

            }

            src += WORD_SIZE;

            dest += WORD_SIZE;

        }

        if (len == 0) return;

        uint256 mask = 256**(WORD_SIZE - len) - 1;

        assembly {

            let srcpart := and(mload(src), not(mask))

            let destpart := and(mload(dest), mask)

            mstore(dest, or(destpart, srcpart))

        }

    }



    function toExitPayload(bytes memory data) internal pure returns (ExitPayload memory) {

        RLPReader.RLPItem[] memory payloadData = data.toRlpItem().toList();



        return ExitPayload(payloadData);

    }



    function getHeaderNumber(ExitPayload memory payload) internal pure returns (uint256) {

        return payload.data[0].toUint();

    }



    function getBlockProof(ExitPayload memory payload) internal pure returns (bytes memory) {

        return payload.data[1].toBytes();

    }



    function getBlockNumber(ExitPayload memory payload) internal pure returns (uint256) {

        return payload.data[2].toUint();

    }



    function getBlockTime(ExitPayload memory payload) internal pure returns (uint256) {

        return payload.data[3].toUint();

    }



    function getTxRoot(ExitPayload memory payload) internal pure returns (bytes32) {

        return bytes32(payload.data[4].toUint());

    }



    function getReceiptRoot(ExitPayload memory payload) internal pure returns (bytes32) {

        return bytes32(payload.data[5].toUint());

    }



    function getReceipt(ExitPayload memory payload) internal pure returns (Receipt memory receipt) {

        receipt.raw = payload.data[6].toBytes();

        RLPReader.RLPItem memory receiptItem = receipt.raw.toRlpItem();

        if (receiptItem.isList()) {

            receipt.data = receiptItem.toList();

        } else {

            bytes memory typedBytes = receipt.raw;

            bytes memory result = new bytes(typedBytes.length - 1);

            uint256 srcPtr;

            uint256 destPtr;

            assembly {

                srcPtr := add(33, typedBytes)

                destPtr := add(0x20, result)

            }

            copy(srcPtr, destPtr, result.length);

            receipt.data = result.toRlpItem().toList();

        }

        receipt.logIndex = getReceiptLogIndex(payload);

        return receipt;

    }



    function getReceiptProof(ExitPayload memory payload) internal pure returns (bytes memory) {

        return payload.data[7].toBytes();

    }



    function getBranchMaskAsBytes(ExitPayload memory payload) internal pure returns (bytes memory) {

        return payload.data[8].toBytes();

    }



    function getBranchMaskAsUint(ExitPayload memory payload) internal pure returns (uint256) {

        return payload.data[8].toUint();

    }



    function getReceiptLogIndex(ExitPayload memory payload) internal pure returns (uint256) {

        return payload.data[9].toUint();

    }



    function toBytes(Receipt memory receipt) internal pure returns (bytes memory) {

        return receipt.raw;

    }



    function getLog(Receipt memory receipt) internal pure returns (Log memory) {

        RLPReader.RLPItem memory logData = receipt.data[3].toList()[receipt.logIndex];

        return Log(logData, logData.toList());

    }



    function getEmitter(Log memory log) internal pure returns (address) {

        return RLPReader.toAddress(log.list[0]);

    }



    function getTopics(Log memory log) internal pure returns (LogTopics memory) {

        return LogTopics(log.list[1].toList());

    }



    function getData(Log memory log) internal pure returns (bytes memory) {

        return log.list[2].toBytes();

    }



    function toRlpBytes(Log memory log) internal pure returns (bytes memory) {

        return log.data.toRlpBytes();

    }



    function getField(LogTopics memory topics, uint256 index) internal pure returns (RLPReader.RLPItem memory) {

        return topics.data[index];

    }

}



interface IFxStateSender {

    function sendMessageToChild(address _receiver, bytes calldata _data) external;

}



contract ICheckpointManager {

    struct HeaderBlock {

        bytes32 root;

        uint256 start;

        uint256 end;

        uint256 createdAt;

        address proposer;

    }



    mapping(uint256 => HeaderBlock) public headerBlocks;

}



abstract contract FxBaseRootTunnel {

    using RLPReader for RLPReader.RLPItem;

    using Merkle for bytes32;

    using ExitPayloadReader for bytes;

    using ExitPayloadReader for ExitPayloadReader.ExitPayload;

    using ExitPayloadReader for ExitPayloadReader.Log;

    using ExitPayloadReader for ExitPayloadReader.LogTopics;

    using ExitPayloadReader for ExitPayloadReader.Receipt;



    bytes32 public constant SEND_MESSAGE_EVENT_SIG = 0x8c5261668696ce22758910d05bab8f186d6eb247ceac2af2e82c7dc17669b036;



    IFxStateSender public fxRoot;

    ICheckpointManager public checkpointManager;



    address public fxChildTunnel;

    mapping(bytes32 => bool) public processedExits;



    constructor(address _checkpointManager, address _fxRoot) {

        checkpointManager = ICheckpointManager(_checkpointManager);

        fxRoot = IFxStateSender(_fxRoot);

    }



    function setFxChildTunnel(address _fxChildTunnel) public virtual {

        require(fxChildTunnel == address(0x0), "FxBaseRootTunnel: CHILD_TUNNEL_ALREADY_SET");

        fxChildTunnel = _fxChildTunnel;

    }



    function _sendMessageToChild(bytes memory message) internal {

        fxRoot.sendMessageToChild(fxChildTunnel, message);

    }



    function _validateAndExtractMessage(bytes memory inputData) internal returns (bytes memory) {

        ExitPayloadReader.ExitPayload memory payload = inputData.toExitPayload();

        bytes memory branchMaskBytes = payload.getBranchMaskAsBytes();

        uint256 blockNumber = payload.getBlockNumber();

        bytes32 exitHash = keccak256(

            abi.encodePacked(

                blockNumber,

                MerklePatriciaProof._getNibbleArray(branchMaskBytes),

                payload.getReceiptLogIndex()

            )

        );

        require(processedExits[exitHash] == false, "FxRootTunnel: EXIT_ALREADY_PROCESSED");

        processedExits[exitHash] = true;

        ExitPayloadReader.Receipt memory receipt = payload.getReceipt();

        ExitPayloadReader.Log memory log = receipt.getLog();

        require(fxChildTunnel == log.getEmitter(), "FxRootTunnel: INVALID_FX_CHILD_TUNNEL");

        bytes32 receiptRoot = payload.getReceiptRoot();

        require(

            MerklePatriciaProof.verify(receipt.toBytes(), branchMaskBytes, payload.getReceiptProof(), receiptRoot),

            "FxRootTunnel: INVALID_RECEIPT_PROOF"

        );

        _checkBlockMembershipInCheckpoint(

            blockNumber,

            payload.getBlockTime(),

            payload.getTxRoot(),

            receiptRoot,

            payload.getHeaderNumber(),

            payload.getBlockProof()

        );

        ExitPayloadReader.LogTopics memory topics = log.getTopics();

        require(bytes32(topics.getField(0).toUint()) == SEND_MESSAGE_EVENT_SIG, "FxRootTunnel: INVALID_SIGNATURE");

        bytes memory message = abi.decode(log.getData(), (bytes));

        return message;

    }



    function _checkBlockMembershipInCheckpoint(uint256 blockNumber, uint256 blockTime, bytes32 txRoot, bytes32 receiptRoot, uint256 headerNumber, bytes memory blockProof) private view returns (uint256) {

        (bytes32 headerRoot, uint256 startBlock, , uint256 createdAt, ) = checkpointManager.headerBlocks(headerNumber);

        require(

            keccak256(abi.encodePacked(blockNumber, blockTime, txRoot, receiptRoot)).checkMembership(

                blockNumber - startBlock,

                headerRoot,

                blockProof

            ),

            "FxRootTunnel: INVALID_HEADER"

        );

        return createdAt;

    }



    function receiveMessage(bytes memory inputData) public virtual {

        bytes memory message = _validateAndExtractMessage(inputData);

        _processMessageFromChild(message);

    }



    function _processMessageFromChild(bytes memory message) internal virtual;

}



interface IERC721 {

    function ownerOf(uint256 tokenId_) external view returns (address);

    function balanceOf(address owner) external view returns (uint256 balance);

    function transferFrom(address _from, address _to, uint256 tokenId_) external;

}



contract NEOTOKYOCENTRAL is FxBaseRootTunnel, OwnControll {



    address public constant NTP = 0xA65bA71d653f62c64d97099b58D25a955Eb374a0;

    address public constant ROARS = 0x066b62EA211249925800eD8676f69eD506175714;



    bool public active;

    IERC721 public ERC721;



    struct tokenInfoNTP { address tokenOwner; }

    mapping(uint256 => tokenInfoNTP) public stakedTokenNTP;

    mapping(address => uint256) public stakedTokenAmountNTP;



    struct tokenInfoROARS { address tokenOwner; }

    mapping(uint256 => tokenInfoROARS) public stakedTokenROARS;

    mapping(address => uint256) public stakedTokenAmountROARS;



    constructor(address checkpointManager, address fxRoot) FxBaseRootTunnel(checkpointManager, fxRoot) {}



    function setActive() public onlyAdmin("ADMIN") {

        active = !active;

    }



    function multiTransferFrom(address contract_, address from_, address to_, uint256[] memory tokenIds_) internal {

        for (uint256 i = 0; i < tokenIds_.length; i++) {

            IERC721(contract_).transferFrom(from_, to_, tokenIds_[i]);

        }

    }



    /// Stake NTP

    function stakeBatchNTP(uint256[] memory tokenIds_) external {

        require(active, "Inactive");

        uint256 l = tokenIds_.length;

        uint256 i; unchecked { do {

            require(IERC721(NTP).ownerOf(tokenIds_[i]) == msg.sender, "Not Owner");

            stakedTokenNTP[tokenIds_[i]].tokenOwner = msg.sender;

        } while (++i < l); }

        _sendMessageToChild(abi.encode(msg.sender, NTP, l, true));

        stakedTokenAmountNTP[msg.sender] += l;

        multiTransferFrom(NTP, msg.sender, address(this), tokenIds_);

    }



    /// Unstake NTP

    function unstakeBatchNTP(uint256[] memory tokenIds_) external {

        uint256 l = tokenIds_.length;

        uint256 i; unchecked { do {

            require(stakedTokenNTP[tokenIds_[i]].tokenOwner == msg.sender, "Not Owner");

            delete stakedTokenNTP[tokenIds_[i]];

        } while (++i < l); }

        _sendMessageToChild(abi.encode(msg.sender, NTP, l, false));

        stakedTokenAmountNTP[msg.sender] -= l;

        multiTransferFrom(NTP, address(this), msg.sender, tokenIds_);

    }



    ///Stake ROARS

    function stakeBatchROARS(uint256[] memory tokenIds_) external {

        require(active, "Inactive");

        uint256 l = tokenIds_.length;

        uint256 i; unchecked { do {

            require(IERC721(ROARS).ownerOf(tokenIds_[i]) == msg.sender, "Not Owner");

            stakedTokenROARS[tokenIds_[i]].tokenOwner = msg.sender;

        } while (++i < l); }

        _sendMessageToChild(abi.encode(msg.sender, ROARS, l, true));

        stakedTokenAmountROARS[msg.sender] += l;

        multiTransferFrom(ROARS, msg.sender, address(this), tokenIds_);

    }



    ///Unstake ROARS

    function unstakeBatchROARS(uint256[] memory tokenIds_) external {

        uint256 l = tokenIds_.length;

        uint256 i; unchecked { do {

            require(stakedTokenROARS[tokenIds_[i]].tokenOwner == msg.sender, "Not Owner");

            delete stakedTokenROARS[tokenIds_[i]];

        } while (++i < l); }

        _sendMessageToChild(abi.encode(msg.sender, ROARS, l, false));

        stakedTokenAmountROARS[msg.sender] -= l;

        multiTransferFrom(ROARS, address(this), msg.sender, tokenIds_);

    }



    function getUserStakedTokensNTP(address user) public view returns (uint256[] memory) {

        uint256 stakedAmount = stakedTokenAmountNTP[user];

        uint256[] memory stakedTokens = new uint256[](stakedAmount);

        uint256 counter = 0;

        for (uint256 i = 1; i <= 2222; i++) {

            tokenInfoNTP memory st = stakedTokenNTP[i];

            if (st.tokenOwner == user) {

                stakedTokens[counter] = i;

                counter++;

            }

        }

        return stakedTokens;

    }



    function getUserStakedTokensROARS(address user) public view returns (uint256[] memory) {

        uint256 stakedAmount = stakedTokenAmountROARS[user];

        uint256[] memory stakedTokens = new uint256[](stakedAmount);

        uint256 counter = 0;

        for (uint256 i = 1; i <= 12345; i++) {

            tokenInfoROARS memory st = stakedTokenROARS[i];

            if (st.tokenOwner == user) {

                stakedTokens[counter] = i;

                counter++;

            }

        }

        return stakedTokens;

    }



    function _processMessageFromChild(bytes memory message) internal override {

        //✋👽🤚

    }

}