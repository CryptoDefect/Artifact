// SPDX-License-Identifier: MIT
/**----------------------------------------------------------------
    This is: v2.1 
    defunct: 0x612c6aB3c55B897BFf8cdFFc9e71143fd01f7f2A
             0x5E57C528EF9126200D76620e7b843600635E74Ca
             

                           ,▄▄███,                                 
                    ,▄▄███████████▄                                             
              ▄▄▄███████████████████                                            
         ,▄██████████████████████████⌐                                          
      ▄███████████████████████████████▄                                         
   ▄███████████████████████████████████▄                                        
  ██████████████████████████████████████▄                                       
   ▀█████████████████████████████████████▄                                      
     █████████████████████████████████████▄           ,▄▄▄████▌                 
      ▀████████████████████████████████████▌   ,▄▄▄██████████▀                  
        ███████████████████████████▀▀▀' ,▄▄██████████████▀▀'                    
         ▀██████████████████▀▀▀` ,▄▄▄████████████▀▀▀'                           
          ╙███████████▀▀"  ,▄▄██████████████████▄                               
            ███▀▀`  ,▄▄▄██████████████▀▀▀` -`` "▀▀█▄,                           
             ▀█▄▄███████████████▀▀' ▄▄▄             ▀█,                         
         ,▄▄███████████████▀▀` ▄      ▀▀███████████   █▄                        
    ▄▄████████████████▀▀'   ,,,▐█       ██▀,▄▄∞██▀█    █▌                      
▄███████████▀▀ ████▀   ▄▄██▀▀▀▀██▌      ███▀   ▀▀▐█    ▐█      ,▄▄              
▐█████▀▀▀     ███▀   ▄█" █▀  ,█╓██▌     ▀█▄    ,▄█`,▄▄▄▄██▄,   `▀██             
 ▀▀          ▐██▌  ╓██ ,█▀  ╓█▄▀ ▐█        ▀▀▀▀▀▀▄████████████████▀             
             ███  ▄██▌▄█▀  ▄▀▄▀ ▄▀█    ,▄███████████▀   ▐█  ▀▀`                 
            ▐██▌ ▐█ ▀██▌  ▄▀▄` █`▄▌   ████▀▀▀████▀▀'▄▄   █▌                     
            ▐██▌  █   '▀██▌█,▄█▄█▀  ╓███▀  ▄r ,▄▄▄▄▄ ▐▌ ]█                      
            ▐██▌  █U      `▀▀▀▀ ▄▄ ¿███   ]█▌ ▀╓▄M+  '  ██                      
             ███  ▐▌           ╘█▄▄██▀     ▀▀          ╓█▌                      
             ███▌ j█              -                   ╓█▀                       
              ███▄ █                                 ▄█▀                ▄██████▄
               █████                               ▄██▀               ,██▀ `▀▀` 
                ▀████▄                          ▄▄██▀                ▄█▀        
                   ▀████▄▄                 ,▄▄███▀██▄               ██          
                      ▀▀▀████████▄▄██████████▀  █  ▐██▄▄          ,██           
                          ▀█▄ -'▀█   ╙█  █`  ▀██▌ █▀ ▐█▀███▄▄▄  ▄██▀            
                           ╙█▄   █▌   █▌██▄   █▀▀▄ █▄▐█µ  ▀▀█████▀              
                            ▐██   ▀▀█ ▐█▀  ████  ╙█ ▐▄▀█                        
                            ████   ]█  █   ▐█ "█,  █▀  ▀█                       
                           ▄█▀▀██   ╙█▄▐▄  █▌   █▄ ▐█   ▀█                      
                          ▐█▌  ██     ▀██▄ █▌    █▄ █    ██                     
                          ██   ██▌      ▀█▄▀█,   █▌██     █▌                    
                         ██`   ███▄█▄▄    ██m██▄█▀ ▐█     ▐█                    
                        ▐██▄██▀██`╒█▀▀▀▀▀▀ ▀█▄  █  █▀      █`                   
                        ▀▀'    ██ █▌          ▀▀██▀        █▌                   
                              '▀  '              ▀         ▀`   
    
    ▄▄███▄▄·██╗██████╗     ████████╗ ██████╗ ██╗  ██╗███████╗███╗   ██╗
    ██╔════╝██║██╔══██╗    ╚══██╔══╝██╔═══██╗██║ ██╔╝██╔════╝████╗  ██║
    ███████╗██║██████╔╝       ██║   ██║   ██║█████╔╝ █████╗  ██╔██╗ ██║
    ╚════██║██║██╔══██╗       ██║   ██║   ██║██╔═██╗ ██╔══╝  ██║╚██╗██║
    ███████║██║██║  ██║       ██║   ╚██████╔╝██║  ██╗███████╗██║ ╚████║
    ╚═▀▀▀══╝╚═╝╚═╝  ╚═╝       ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚══════╝╚═╝  ╚═══╝

    initial supply 1.000.000.000 $IR
    to be burned     750.000.000 $IR
    final supply     250.000.000 $IR

    TAXES -------------------------------------------------------------

    - on sell 2% buyback & burn on the mainnet
      (on other networks added to treasury tax)
    - on buy, 2% added to liquidity
    - treasury 8%

    Total buy/sell tax 10%.

    wallet to wallet is not taxed.

    Burn and sell tax will end when the burn is completed.
    Auto buyback and burn works only on eth mainnet.

    Slippage up to 12%-15% will be required on sell/buy because of taxes!

    LIQUIDITY LOCK ----------------------------------------------------

    After address [0xAB] provides liquidity, we simply prevent any transaction, 
    from this address, with tokens in liquidity.
    Liquidity can't be removed manually before the set time (there is no such 
    function in the contract), nor can it be removed using Uniswap. 
    (Similar goes for other networks).

    setLock(address, timestamp) and [0xAB] (LP PROV.) tokens are locked.

    Lock time can't be shortened but it can be increased.
    We will not remove any liquidity until our next project is launched.
    If we can't open our next platform to the public on time, we will extend
    the liquidity lock until we are sure we can open our next platform to 
    the public.

    setLock(address, timestamp) sets or extends lock timestamp.

    All these actions are ofc logged on the blockchain.
    
    isLiqudityLocked() returns true or false.
    LiqudityIsLockedUntil() returns timestamp.
    unlock() unlocks liquidity if timer expired.

    Details and info on: https://dapp.sirtoken.com

    LOCKED TOKENS -----------------------------------------------------

    There are only three wallets with locked tokens ...
    SEED 90 days 37.5 mil.
    TEAM 90 days 10 mil.
    RESERVE 60 days 30 mil.

    There is no function in the contract that would enable unlocking before
    previously set time.
    
    setLocked(address, timestamp) to lock or extend lock time.
    AccountIsLockedUntil() returns timestamp.
    isAccountLocked(address) returns true/false

    LIMITS ---------------------------------------------------------
    
    The default max transfer amount by default is 1% of the current supply.
    This can be checked with getMaxTransactionAmount()
    or on https://dapp.sirtoken.com

    The default max sell amount by default is 0.3% of current liquidity tokens
    that round to about 1 mil $IR at market initialisation.
    This can be checked with getMaxSellAmount()
    or on https://dapp.sirtoken.com

    The default max buy amount by default is 0.3% of current liquidity tokens.
    that round to about 1 mil $IR at market initialisation.
    This can be checked with getMaxBuyAmount()
    or on https://dapp.sirtoken.com

    All transfer limits are disabled after the burn ends.

    Be aware:
        - if you ware to provide liquidity you will be taxed the same as if 
        you were selling tokens!
        - maximum liquidity that you could add is also limited to default
        0.3% of current liquidity tokens!

    -------------------------------------------------------------------

    
    web: https://sirtoken.com
    dapp: https://dapp.sirtoken.com
    twitter: https://twitter.com/likeaSIRtoken
    telegram: https://t.me/SirToken

    dev: [email protected]

    KEYS
    --------------
    BURN      0xA0 | LIQUIDITY 0xA1 | TREASURY  0xA2 | PROXY     0xA3
    DEV       0xA4 | ADVISORS  0xA5 | TEAM      0xA6 | MARKETING 0xA7
    RESERVE   0xA8 | SEED      0xA9 | AIRDROPS  0xAA | LP PROV.  0xAB
    PAIR      0xB3 | FACTORY   0xB4 | ROUTER    0xB2 | WETH      0xB1
    LP ADDR.  0xB0 |

    ERROR CODES
    ----------------------------------------------------------------
    00  Zero amount
    01  Zero address
    02  balance is zero 
    03  this tax no longer applies
    04  amount > than the allowance
    05  amount > than balance
    06  buy amount over the maximum
    07  base fee is over 8%
    08  Caller is not the owner
    09  value same as current
    10  LP time locked
    11  address time locked
    12  trading is not enabled
    13  transaction amount over the maximum
    14  sell amount over the maximum
    15  timestamp is in past
    16  amount > than the current Ethereum balance
    17  total tax is over 15%
    18  we are at the max burn
    19  we are not on the Etherum mainnet
    20  values can be only 1 to 10
    21  BuyBack&burn is not enabled
    22  over maximum
    23  only non-native token
    24  already used
    25  Invalid index
    26  timestamp must extend the lock time
    27  amount to low
    28  not over threshold
    29  tax not enabled
----------------------------------------------------------------*/
pragma solidity 0.8.17;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Context.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/utils/Address.sol";
import "@openzeppelin/contracts/utils/math/Safemath.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol";
import "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol";
import "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol";
import "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";

library UniswapV2Library {
    using SafeMath for uint;

    function sortTokens(address tokenA, address tokenB) internal pure returns(address token0, address token1) {
        require(tokenA != tokenB, "09");
        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
        require(token0 != address(0), "01");
    }

    function pairFor(address factory, address tokenA, address tokenB) internal pure returns(address pair) {
        (address token0, address token1) = sortTokens(tokenA, tokenB);
        pair = address(uint160(uint(keccak256(
            abi.encodePacked(hex"ff", factory, keccak256(abi.encodePacked(token0, token1)), 
            hex"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f"
        )))));
    }

    function getReserves(address factory, address tokenA, address tokenB) internal view returns(uint reserveA, uint reserveB) {
        (address token0,) = sortTokens(tokenA, tokenB);
        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();
        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);
    }
}

/// @dev for external swap eth to token
contract Proxy {
    address private main;

    receive() external payable {}
    fallback() external payable {}

    modifier onlyMainContract {
        require(msg.sender == main, "19");
        _;
    }

    constructor(address address_) payable {
        main = address_;
    }

    function sendEth() public onlyMainContract {
        payable(main).transfer(address(this).balance);
    }
}

contract SirToken is IERC20, Context {
    using SafeMath for uint;
    using EnumerableSet for EnumerableSet.AddressSet;

    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    mapping(address => uint256) private _locked;
    mapping(bytes1 => address) private _address;

    EnumerableSet.AddressSet private ExcludedFromFee;
    EnumerableSet.AddressSet private ExcludedFromMaxTx;
    EnumerableSet.AddressSet private Airdrops;

    IUniswapV2Router02 private _dexRouter;
    address private _dexPair;
    address private _owner;
    
    Proxy public proxy;
    bool inSwap;

    uint8 private constant _decimals = 18;
    string private constant _name = "SIR Token";
    string private constant _symbol = "$IR";

    uint256 private constant _multiplier = 10 ** _decimals;
    uint256 private constant _initialSupply = 1000000000 * _multiplier;
    address private constant DEAD = 0x000000000000000000000000000000000000dEaD;
    uint256 private tradingStartTime;

    struct Booleans {
        bool buyBack;
        bool isMainNet;
        bool isTradingEnabled;
        bool autoDistributeFees;
        bool limitsEnabled;
        bool feesEnabled;
        bool autoProcessFees;
        bool swapEnabled;
        bool liquidityLocked;
    }
    Booleans private Bool;

    struct Taxes {
        bool enabled;
        bool previousState;
        uint256 percent;
        uint256 previousPercent;
        uint256 ethBalance;
        uint256 balance;
        uint256 sirThreshold;
        uint256 ethThreshold;
    }
    mapping(bytes1 => Taxes) private Tax;
    
    struct Totals {
        uint8 lockedAccounts;
        uint256 baseTax;
        uint256 buyTax;
        uint256 sellTax;
        uint256 supply;
        uint256 burned;
        uint256 buyback;
        uint256 liquidatedTokens;
        uint256 liquidatedEthers;
        uint256 airdropped;
        uint256 sirFromFees;
        uint256 ethFromFees;
    }
    Totals private Total;

    struct MaxVal {
        uint256 sellPercent;
        uint256 buyPercent;
        uint256 txPercent;
        uint256 sellAmount;
        uint256 buyAmount;
        uint256 txAmount;
        uint256 burn;
        uint256 airdrop;
    }
    MaxVal private Max;

    event AccountExcludedFromFee(address address_, bool excluded);
    event AccountExcludedFromMaxTx(address address_, bool excluded);
    event AccountUnlocked(address account, uint256 timestamp);
    event AddedLiquidity(uint256 eth, uint256 token);
    event AddressSet(bytes1 index, address previous, address A);
    event Airdroped(address A, uint256 amount);
    event AutoBuyBackAndBurnEnabled(bool enabled);
    event AutoDistributeFeesEnabled(bool enabled);
    event AutoSwapEnabled(bool enabled);
    event BoughtBackAndBurned(uint256 amountETH, uint256 toBurn);
    event Burned(address account, uint256 amount);
    event BurnEnded(uint256 timestamp, uint256 number);
    event FeesEnabled(bool enabled);
    event LimitsEnabled(bool enabled);
    event LiquidityLockSet(address address_, uint256 previousTime, uint256 timestamp);
    event LiquidityUnlocked(address account, uint256 timestamp);
    event LockSet(address address_, uint256 previousTime, uint256 timestamp);
    event MaxBuyPercentChanged(uint256 previous, uint256 percent);
    event MaxSellPercentChanged(uint256 previous, uint256 percent);
    event MaxTransactionChanged(uint256 previousPercent, uint256 percent, uint256 previosAmount, uint256 amount);
    event Minted(address address_, uint256 amount_);
    event NewThresholdSet(bytes1 index, uint256 previous, uint256 amount, bool ethThreshold);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    event RouterUpdated(address previousAddress, address router, address previousPair, address _pair);
    event SentFees(uint256 total);
    event SetLpProvider(address address_, bool isSet);
    event TaxSet(bytes1 index, uint256 percent, bool enabled);
    event TradingEnabled(bool enabled, uint256 block, uint256 time);
    event WithdrawnERC20(address token, address ownerAddress, uint256 amount);
    event WithdrawnETH(address address_, uint256 amount);

    modifier lockTheSwap() {
        inSwap = true;
        _;
        inSwap = false;
    }

    modifier onlyOwner() {
        require(owner() == _msgSender(), "08");
        _;
    }

    constructor (
        address routerAddress_ // 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D
    ) payable {
        _owner = _msgSender();
        emit OwnershipTransferred(address(0), _owner);
    
        Bool = Booleans(true, false, false, true, true, true, true, true, false);

        proxy = new Proxy(address(this));
        _address[0xA0] = 0xcA3075C9ea6036a30027d5eC2009DEaF40c68492; // burn
        _address[0xA1] = 0xd8bAD6bef968e93Cff6614336dDfb4bc5Bb5b1B4; // liquidity
        _address[0xA2] = 0xB0B821b6588c9bd329cf8BF2837BD46fD44368d8; // treasury
        _address[0xA3] = payable(proxy);                             // proxy
        _address[0xA4] = 0x8D84381e3261f12C15C6c2ab87D05E1692aB9d85; // dev
        _address[0xA5] = 0xf2eBcBdE26E2903f7de1A9EbBDF7f8594621D183; // advisors
        _address[0xA6] = 0xa168f350c0B9Cc1c9a32bAAc64b82A1E0298C8EB; // team
        _address[0xA7] = 0xb2584e5e922B08Ed38b5179825CAC578CC2377D5; // marketing
        _address[0xA8] = 0xd57210E74D76df532E7E8Bb60C828dAB5BC3e00a; // reserve 
        _address[0xA9] = 0xb2c6c4994a47dfC327270F0835796cc25735EbDE; // seed investor
        _address[0xAA] = 0xbb3e0f9eC231eB1AAc41ea422A91D16923eca8F4; // airdrops
        _address[0xAB] = 0x39D4C8638a4c0679292a03628bA9c039533128eC; // LP provider address
        _address[0xAC] = 0x604861ad9b4212A938547C63e77D00815fDB0f5a; // liquify reserve address

        IUniswapV2Router02 router = IUniswapV2Router02(routerAddress_);
        _dexRouter = router;
        _address[0xB1] = _dexRouter.WETH();
        _dexPair = IUniswapV2Factory(router.factory()).createPair(address(this), _address[0xB1]);
        _address[0xB4] = address(router.factory());
        _address[0xB2] = address(_dexRouter);
        _address[0xB3] = address(_dexPair);
        _address[0xB0] = getLiquidityPoolAddress();
        Bool.isMainNet = isRouterUniswap();

        ExcludedFromFee.add(_owner);
        ExcludedFromFee.add(address(this));

        ExcludedFromFee.add(_address[0xA0]);
        ExcludedFromFee.add(_address[0xA1]);
        ExcludedFromFee.add(_address[0xA2]);
        ExcludedFromFee.add(_address[0xA3]);
        ExcludedFromFee.add(_address[0xA8]);
        ExcludedFromFee.add(_address[0xAB]);
        ExcludedFromFee.add(_address[0xAA]);

        ExcludedFromMaxTx.add(_owner);
        ExcludedFromMaxTx.add(address(this));

        ExcludedFromMaxTx.add(_address[0xA0]);
        ExcludedFromMaxTx.add(_address[0xA1]);
        ExcludedFromMaxTx.add(_address[0xA2]);
        ExcludedFromMaxTx.add(_address[0xA3]);
        ExcludedFromMaxTx.add(_address[0xB2]);
        ExcludedFromMaxTx.add(_address[0xB3]);
        ExcludedFromMaxTx.add(_address[0xAB]);

        Max = MaxVal(30, 30, 100, 0, 0, 0, 750000000 * _multiplier, 2000000 * _multiplier);

        if (Bool.isMainNet) {
            /// @dev tokens for Polygon are sent to Owner since 0xAB will be locked on mainnet
            __mint(_address[0xAB], 350000000 * _multiplier);   // Main LP
            __mint(_address[0xA6],  10000000 * _multiplier);   // team
            __mint(_address[0xA8],  30000000 * _multiplier);   // reserve
            __mint(_address[0xA9],  37500000 * _multiplier);   // seed investor
            __mint(_address[0xA7],   5000000 * _multiplier);   // marketing
            __mint(_address[0xA5],   3000000 * _multiplier);   // advisors
            __mint(_address[0xAA], Max.airdrop);               // airdrop 2.000.000
            __mint(_owner, _initialSupply - Total.supply);
        }
    }

    receive() external payable {}
    fallback() external payable {}

    /**
     *  @dev sets new router address
     *  @param address_ address router
     *  @notice Required:
     *      - address has to be different from the current router address
     *      - address 
     *  @notice Emits:
     *      {RouterUpdated} address previous, address new, address previous pair, address new pair
     */
    function setRouter(
        address address_
    ) public onlyOwner {
        validAddress(address_);
        require(address_ != _address[0xB2], "09");
        address previousAddress = _address[0xB2];
        address previousPair = _address[0xB3];

        IUniswapV2Router02 router = IUniswapV2Router02(address_);
        _dexRouter = router;

        _address[0xB1] = _dexRouter.WETH();
        address pair = IUniswapV2Factory(router.factory()).getPair(address(this), _address[0xB1]);
        if (pair == address(0)) {
            _dexPair = IUniswapV2Factory(router.factory()).createPair(address(this), _address[0xB1]);
        } else {
            _dexPair = pair;
        }

        _address[0xB4] = address(router.factory());
        _address[0xB2] = address(_dexRouter);
        _address[0xB3] = address(_dexPair);
        _address[0xB0] = getLiquidityPoolAddress();
        Bool.isMainNet = isRouterUniswap();

        emit RouterUpdated(previousAddress, _address[0xB2], previousPair, _address[0xB3]);
    }

    /**
     *  @dev initialize trading
     *  @notice Emits:
     *      {TradingEnabled} bool, uint256 block, uint256 timestamp
     */ 
    function initialize() external onlyOwner {
        if (!Bool.isTradingEnabled) {
            setDefaultVars(0xA0);
            setDefaultVars(0xA1);
            setDefaultVars(0xA2);

            Max.sellAmount = _getMaxSellAmount();
            Max.buyAmount = _getMaxBuyAmount();
            Max.txAmount = _getMaxTransactionAmount();

            tradingStartTime = block.timestamp;
            Bool.isTradingEnabled = true;

            setLock(_address[0xA8], tradingStartTime + 60 days);
            setLock(_address[0xA9], tradingStartTime + 90 days);
            setLock(_address[0xA6], tradingStartTime + 90 days);

            emit TradingEnabled(true, block.number, tradingStartTime);
        }
    }

    /**
     *  @dev Sets default taxes.
     * 
     *  Tax[index].enabled     (enable/disable = true/false)
     *  Tax[index].percent     (integer 0 - 9 | multiplied by 100)
     *  Tax[index].sirThreshold   (integer x * 10**18)
     *  Tax[index].ethThreshold   (integer x * 10**18)
     * 
     *  @param index_ bytes1 (lookup Keys)
     *  defult:
     *      - treasury 8%,  (800)
     *      - burn 2%,      (200)
     *      - liquidity 2%  (200)
     */
    function setDefaultVars(
        bytes1 index_
    ) private {
        Tax[index_].enabled = true;
        Tax[index_].percent = index_ == 0xA2 ? 800 : 200;
        Tax[index_].sirThreshold = index_ == 0xA2 ? 400000 * _multiplier : 100000 * _multiplier;
        Tax[index_].ethThreshold = 1e15;
        if (index_ == 0xA2) {
            Total.baseTax = Tax[0xA2].percent;
        }
        Total.buyTax = Total.baseTax + Tax[0xA0].percent;
        Total.sellTax = Total.baseTax + Tax[0xA1].percent;
    }

    /// @dev returns owner address
    function owner() public view virtual returns(address) {
        return _owner;
    }

    /**
     *  @dev transfers ownership & possible tokens on balance
     *  @param address_ address
     *  @notice Reuired:
     *      - validAddress(address_) non 0 address
     *      - new Owner address is different from current _owner address
     *  @notice Emits:
     *      {OwnershipTransferred} address _owner, address address_
     */
    function transferOwnership(
        address address_
    ) public onlyOwner {
        validAddress(address_);
        _transferOwnership(address_);
    }

    /**
     *  @dev transfers ownership & possible tokens on balance
     *  @param address_ address
     *  @notice Reuired:
     *      - address should not be 0 address or DEAD address
     *      - new Owner address must different from current _owner address
     */
    function _transferOwnership(
        address address_
    ) internal virtual {
        validAddress(address_);
        require(address_ != _owner, "09");
        ExcludedFromFee.remove(_owner);
        ExcludedFromMaxTx.remove(_owner);
        ExcludedFromFee.add(address_);
        ExcludedFromMaxTx.add(address_);
        if (_balances[_owner] > 0) {
            moveBalance(_owner, address_);
        }
        _owner = address_;
        emit OwnershipTransferred(_owner, address_);
    }

    /**
     *  @dev Get the name of the token.
     *  @return string name
     */
    function name() public pure returns(string memory) {
        return _name;
    }

    /**
     *  @dev Get the symbol of the token, usually a shorter version of the name.
     *  @return string symbol
     */
    function symbol() public pure returns(string memory) {
        return _symbol;
    }

    /**
     *  @dev See IERC20-decimals.
     *  @return uint8 decimal
     */
    function decimals() public pure returns(uint8) {
        return _decimals;
    }

    /**
     *  @dev See IERC20-totalSupply.
     *  @return uint256 token total initial supply
     */
    function totalSupply() public view override returns(uint256) {
        return Total.supply;
    }

    /**
     *  @dev Get account token balance.
     *  @param address_ address
     *  @return uint256 account balance
     */
    function balanceOf(
        address address_
    ) public view override returns(uint256) {
        return _balances[address_];
    }

    /// @dev See IERC20-transfer.
    function transfer(
        address recipient_,
        uint256 amount_
    ) public override returns(bool) {
        _transfer(_msgSender(), recipient_, amount_);
        return true;
    }

    /// @dev See IERC20-allowance
    function allowance(
        address owner_,
        address spender_
    ) public view override returns(uint256) {
        return _allowances[owner_][spender_];
    }

    /// @dev See IERC20-approve
    function approve(
        address spender_,
        uint256 amount_
    ) public override returns(bool) {
        _approve(_msgSender(), spender_, amount_);
        return true;
    }

    /// @dev See IERC20-transferFrom
    function transferFrom(
        address sender_,
        address recipient_,
        uint256 amount_
    ) public override returns(bool) {
        _transfer(sender_, recipient_, amount_);
        _approve(sender_, _msgSender(), _allowances[sender_][_msgSender()].sub(amount_, "04"));
        return true;
    }

    /**
     *  @dev Sets amount_ as the allowance of spender_ over the owner`s tokens.
     *  This internal function is equivalent to `approve`, and can be used to
     *  e.g. set automatic allowances for certain subsystems, etc.
     *  @notice Emits: 
     *      {Approval} event.
     *  @notice Required:
     *      - owner_ can't be zero address.
     *      - spender_ can't be zero address.
     */
    function _approve(
        address owner_,
        address spender_,
        uint256 amount_
    ) private {
        validAddress(owner_);
        validAddress(spender_);
        _allowances[owner_][spender_] = amount_;
        emit Approval(owner_, spender_, amount_);
    }

    /**
     *  @dev base token transfer
     *  @param sender_ address
     *  @param recipient_ address
     *  @param amount_ uint256
     *
     *  @notice Required:
     *      - sender_ can't be zero address
     *      - recipient_ can't be zero address
     *      - amount_ must be greater than 100 wei because under certain conditions
     *        when the amount is less than 100 wei we get wrong amounts in fee calculations 
     *        later in processing functions. This has been tested and amounts over 100 are OK.
     *      - amount_ must be less or equal to sender_ balance
     *      
     *  @notice Emits:
     *      {Transfer} address_ from, address_ to, amount_ tokens
     */
    function _transfer(
        address sender_,
        address recipient_,
        uint256 amount_
    ) private {
        validAddress(sender_);
        validAddress(recipient_);
        require(amount_ > 100 wei, "27");
        require(amount_ <= _balances[sender_], "05");

        bool SenderIsPair = sender_ == _address[0xB3];
        bool SenderExcludedFromFee = ExcludedFromFee.contains(sender_);
        
        bool txBuy = SenderIsPair && recipient_ != _address[0xB2];
        bool txSell = recipient_ == _address[0xB3] && sender_ != _address[0xB2];
        bool txTransfer = !txBuy && !txSell;
        
        if (!Bool.isTradingEnabled) {
            /// @dev only addresses excluded from fee can transfer brefore trading is enabled
            require(SenderExcludedFromFee || ExcludedFromFee.contains(recipient_), "12");
        } else {
            /// @dev check if sender or recipient is LP provider or locked address
            if (Total.lockedAccounts > 0) {
                require(!_checkLock(sender_), sender_ == _address[0xAB] ? "10" : "11");
                require(!_checkLock(recipient_), recipient_ == _address[0xAB] ? "10" : "11");
            }
            if (Bool.limitsEnabled) {
                if (!ExcludedFromMaxTx.contains(sender_) || 
                    !ExcludedFromMaxTx.contains(recipient_)) {
                    require(amount_ <= Max.txAmount, "13");
                    if (txSell) {
                        require(amount_ <= Max.sellAmount, "14");
                    } else if (txBuy) {
                        require(amount_ <= Max.buyAmount, "06");
                    }
                }
            }
        }

        /**
         *  @dev just transfer if in swap, transfer, excluded or sender is 
         *  router (LP remove)
         */
        if (inSwap || 
            txTransfer || 
            SenderExcludedFromFee || 
            sender_ == _address[0xB2]) {
            return transferBalance(sender_, recipient_, amount_);
        } else {
            if (Bool.feesEnabled) {
                uint256 _fee;
                /// @dev burn & liquidiy fee only util the end of burn
                if (Bool.buyBack) {
                    if (txSell && Tax[0xA0].enabled) {
                        _fee += _processFee(sender_, amount_, 0xA0);
                    } else
                    if (txBuy && Tax[0xA1].enabled) {
                        _fee += _processFee(sender_, amount_, 0xA1);
                    }
                }
                /// @dev calculate treasury fee
                if (Tax[0xA2].enabled) {
                    _fee += _processFee(sender_, amount_, 0xA2);
                }
                amount_ -= _fee;
            }

            if (Bool.swapEnabled && !SenderIsPair) { 
                if (isOverThresholdE(0xA0)) {
                    _buyBackAndBurn();
                } else 
                if (isOverThresholdE(0xA1)) {
                    _addLiquidity();
                } else 
                if (isOverThresholdE(0xA2)) {
                    _distributeFees();
                } else 
                if (Bool.isMainNet && 
                    Bool.buyBack && 
                    Tax[0xA0].enabled && 
                    isOverThresholdT(0xA0)) {
                    _processBurnFees();
                } else 
                if (Bool.buyBack && 
                    Tax[0xA1].enabled && 
                    isOverThresholdT(0xA1)) {
                    _processLiquidityFees();
                } else 
                if (Tax[0xA2].enabled && 
                    isOverThresholdT(0xA2)) {
                    _processTreasuryFees();
                }
            }

            transferBalance(sender_, recipient_, amount_);
        }
    }

    /**
     *  @dev calculates fee by tax index
     *  @param sender_ address
     *  @param amount_ uint256
     *  @param index_ bytes1 0xA0, 0xA1, and 0xA2
     *  @return fee uint256
     *  @notice transfers fee from sender_ to tax address
     */
    function _processFee(address sender_, uint256 amount_, bytes1 index_) private returns(uint256 fee) {
        fee = amount_.mul(Tax[index_].percent).div(1e4);
        if (index_ == 0xA0 && !Bool.isMainNet) {
            index_ = 0xA2;
        }
        transferBalance(sender_, _address[index_], fee);
        return fee;
    }

    function processBurnFees() external onlyOwner {
        require(isOverThresholdT(0xA0), "28");
        _processBurnFees();
    }

    function processLiquidityFees() external onlyOwner {
        require(isOverThresholdT(0xA1), "28");
        _processLiquidityFees();
    }

    function processTreasuryFees() external onlyOwner {
        require(isOverThresholdT(0xA2), "28");
        _processTreasuryFees();
    }

    function processBuyBack() external onlyOwner {
        require(isOverThresholdE(0xA0), "28");
        _buyBackAndBurn();
    }

    function processLiquidity() external onlyOwner {
        require(isOverThresholdE(0xA1), "28");
        _addLiquidity();
    }

    function distributeFees() external onlyOwner {
        require(isOverThresholdE(0xA2), "28");
        _distributeFees();
    }

    /**
     *  @dev processes collected burn fees
     *  also adds treasury fees if over threshold
     */
    function _processBurnFees() private {
        uint256 b = _balances[_address[0xA0]];
        moveBalance(_address[0xA0], address(this));
        bool t;
        if (Tax[0xA2].enabled && isOverThresholdE(0xA2)) {
            b += _balances[_address[0xA2]];
            moveBalance(_address[0xA2], address(this));
            t = true;
        }
        uint256 e = _swapTokensForEth(b);
        if (t) {
            uint256 p = e.div(Tax[0xA0].percent + Tax[0xA2].percent);
            uint256 r = p * Tax[0xA2].percent;
            Tax[0xA2].ethBalance += r;
            e -= r;
        }
        Tax[0xA0].ethBalance += e;
    }

    /**
     *  @dev processes collected liquidity fees
     */
    function _processLiquidityFees() private {
        uint256 b = _balances[_address[0xA1]];
        moveBalance(_address[0xA1], address(this));
        uint256 h = b / 2;
        uint256 e = _swapTokensForEth(h);
        Tax[0xA1].ethBalance += e;
        _balances[_address[0xAC]] += b - h;
    }

    /**
     *  @dev processes collected treasury fees
     */
    function _processTreasuryFees() private {
        uint256 b = _balances[_address[0xA2]];
        Total.sirFromFees += b;
        moveBalance(_address[0xA2], address(this));
        Tax[0xA2].ethBalance += _swapTokensForEth(b);
    }

    /**
     *  @dev distributes collected ethers to trasury and dev
     *  @notice Emits:
     *      {SentFees} amount eth
     */
    function _distributeFees() private {
        uint256 b = Tax[0xA2].ethBalance;
        Tax[0xA2].ethBalance = 0;
        uint256 p = b.mul(Total.baseTax * 2).div(1e4);
        payable(_address[0xA2]).transfer(b - p);
        payable(_address[0xA4]).transfer(p);
        Total.ethFromFees += b;
        emit SentFees(b);
    }

    /**
     *  @dev checkes if tax ether balance over threshold
     *  @return bool
     */
    function isOverThresholdE(
        bytes1 index_
    ) private view returns(bool) {
        return Tax[index_].ethBalance > Tax[index_].ethThreshold;
    }

    /**
     *  @dev checkes if tax token balance over threshold
     *  @return bool
     */
    function isOverThresholdT(
        bytes1 index_
    ) private view returns(bool) {
        return _balances[_address[index_]] > Tax[index_].sirThreshold;
    }

    /**
     *  @dev exclude or include an account in taxed list
     *  @param address_ address
     *  @notice Emits:
     *      {AccountExcludedFromFee} address account, bool true / false
     */
    function setAccountExcludedFromFee(
        address address_
    ) external onlyOwner {
        if (ExcludedFromFee.contains(address_)) {
            ExcludedFromFee.remove(address_);
            emit AccountExcludedFromFee(address_, false);
        } else {
            ExcludedFromFee.add(address_);
            emit AccountExcludedFromFee(address_, true);
        }
    }

    /**
     *  @dev exclude or include an account in max transfer list
     *  @param address_ address
     *  @notice Reqired:
     *      - only owner account
     *  @notice Emits:
     *      {AccountExcludedFromMaxTx} address account, bool true / false
     */
    function setAccountExcludedFromMaxTx(
        address address_
    ) external onlyOwner {
        if (ExcludedFromMaxTx.contains(address_)) {
            ExcludedFromMaxTx.remove(address_);
            emit AccountExcludedFromFee(address_, false);
        } else {
            ExcludedFromMaxTx.add(address_);
            emit AccountExcludedFromMaxTx(address_, true);
        }
    }

    /**
     *  @dev adds time lock to accounts tokens
     *  @param address_ address
     *  @param timestamp_ uint256 locked unitil timestamp
     *  @notice Required:
     *      - address_ is address of SEED, TEAM, RESERVE, or POOL (lp provider)
     *  @notice Emits:
     *      {LiquidityLockSet} address_ address, previousTime timestamp uint256, timestamp uint256
     *      {LockSet} address_ address, previousTime timestamp uint256, timestamp uint256
     */
    function setLock(
        address address_, 
        uint256 timestamp_
    ) public onlyOwner {
        validAddress(address_);
        require(
            address_ == _address[0xA6] || 
            address_ == _address[0xA8] ||
            address_ == _address[0xA9] || 
            address_ == _address[0xAB]
        );
        uint256 previousTime;
        if (_locked[address_] == 0) {
            require(timestamp_ > block.timestamp, "15");
            _locked[address_] = timestamp_;
            Total.lockedAccounts += 1;
        } else {
            require(timestamp_ > _locked[address_], "26");
            previousTime = _locked[address_];
            _locked[address_] = timestamp_;
        }
        if (address_ == _address[0xAB]) {
            Bool.liquidityLocked = true;
            emit LiquidityLockSet(address_, previousTime, _locked[address_]);
        } else {
            emit LockSet(address_, previousTime, _locked[address_]);
        }
    }

    /// @dev returns locks timestamps
    function getLockTimes() external view returns(uint256, uint256, uint256, uint256) {
        return (
            _locked[_address[0xA6]],
            _locked[_address[0xA8]],
            _locked[_address[0xA9]],
            _locked[_address[0xAB]]
        );
    }

    /**
     *  @dev returns lock state of an account
     *  @param address_ address
     *  @return bool locked
     */
    function isAccountLocked(
        address address_
    ) public view returns(bool) {
        return (_locked[address_] > 0) ? true : false;
    }

    /** 
     *  @dev returns account lock timestamp
     *  @param address_ address
     *  @return uint256 timestamp
     */
    function accountIsLockedUntil(
        address address_
    ) external view returns(uint256) {
        return _locked[address_];
    }

    /**
     *  @dev returns lock state of LP provider address
     *  @return bool locked
     */
    function isLiqudityLocked() public view returns(bool) {
        return _locked[_address[0xAB]] == 0 ? false : true;
    }

    /**
     *  @dev returns LP lock timestamp
     *  @return uint256 timestamp
     */
    function liqudityIsLockedUntil() external view returns(uint256) {
        return _locked[_address[0xAB]];
    }

    /**
     *  @dev toggles fees enabled/disabled
     *  @notice Emits:
     *      {FeesEnabled} bool
     */
    function toggleFeesEnabled() external onlyOwner {
        Bool.feesEnabled = !Bool.feesEnabled;
        emit FeesEnabled(Bool.feesEnabled);
    }

    /**
     *  @dev toggles limits enabled/disabled
     *  @notice Emits:
     *      {LimitsEnabled} bool
     */
    function toggleLimitsEnabled() external onlyOwner {
        Bool.limitsEnabled = !Bool.limitsEnabled;
        emit LimitsEnabled(Bool.limitsEnabled);
    }

    /**
     *  @dev toggles automatic processing of collected fees
     *  @notice Emits:
     *      {AutoSwapEnabled} bool
     */
    function toggleSwapEnabled() external onlyOwner {
        Bool.swapEnabled = !Bool.swapEnabled;
        emit AutoSwapEnabled(Bool.swapEnabled);
    }

    /**
     *  @dev toggles automatic distribution of collected fees
     *  @notice Emits:
     *      {AutoDistributeFeesEnabled} bool
     */
    function toggleAutoDistributeFees() external onlyOwner {
        Bool.autoDistributeFees = !Bool.autoDistributeFees;
        emit AutoDistributeFeesEnabled(Bool.autoDistributeFees);
    }

    /**
     *  @dev sets tax percentage of specific tax by index_
     *  @param index_ bytes1
     *  @param percent_ uint256 | multiply by 100 (100 = 1%, 50 = 0.5%, ...)
     *  @notice Required:
     *      - index_ must still be in effect (we are not in post burn era)
     *      - tax percentage has to be different from current
     *      - tax percentage for treasury tax has to be less or equal to 8% (800)
     *      - total sell or burn tax has to be less or equal to 15% (1500)
     *  @notice Emits:
     *      {TaxSet} index_ bytes1, percent_ uint256, bool enabled
     */
    function setTaxPercentage(
        bytes1 index_, 
        uint256 percent_
    ) external onlyOwner {
        applies(index_);
        require(Tax[index_].percent != percent_, "09");
        uint256 percent = percent_ > 0 ? percent_ : 0;
        Tax[index_].previousPercent = Tax[index_].percent;
        Tax[index_].previousState = Tax[index_].enabled;
        Tax[index_].enabled = percent > 0 ? true : false;
        Tax[index_].percent = Tax[index_].enabled ? percent : 0;
        if (index_ == 0xA2) {
            require(percent <= 800, "07");
            Total.baseTax = Tax[0xA2].percent;          
        }
        Total.sellTax = Total.baseTax + Tax[0xA0].percent;
        Total.buyTax = Total.baseTax + Tax[0xA1].percent;
        require(Total.sellTax <= 1500 && Total.buyTax <= 1500, "17");
        emit TaxSet(index_, percent_, Tax[index_].enabled);
    }

    /**
     *  @dev Other networks will not "know" if it's enabled or disabled.
     *      We need ability to disable or re-enable autobuybackandburn.
     *  @notice If something goes wrong it can also be turned on/off
     *      manually by the contract owner, but can be re-enabled only on main net;
     *      it will be auto disabled if total supply is equal or less then max burn
     *  @notice Requires if value_ is true:
     *      - Total of burned tokens must be less than Max.burn var
     *      - isMainNet is true eg. we have to be on ethereum mainnet
     *  @notice Emits:
     *      {AutoBuyBackAndBurnEnabled} bool value_
     */
    function setAutoBuyBackAndBurn(
        bool value_
    ) external onlyOwner {
        if (value_) {
            require(Total.burned < Max.burn, "18");
            require(Bool.isMainNet, "19");
            Tax[0xA0].enabled = Tax[0xA0].previousState;
            Tax[0xA0].percent = Tax[0xA0].previousPercent;
            Tax[0xA1].enabled = Tax[0xA1].previousState;
            Tax[0xA1].percent = Tax[0xA1].previousPercent;
            Bool.buyBack = true;
        }
        if (!value_ && Bool.buyBack) {
            cleanUpAndEndTheBurn();
        }
        emit AutoBuyBackAndBurnEnabled(value_);
    }

    /**
     *  @dev check is AutoBuyBackAndBurn is Enabled
     *  @return bool
     */
    function isBuyBackAndBurnEnabled() external view returns(bool) {
        return Bool.buyBack;
    }

    /**
     *  @param index_ bytes1
     *  @param threshold_ uint256, token amount threshold
     *  @param ethThreshold bool, if true eth threshold will be set
     *  @notice Requires:
     *      - index_ must still be in effect (we are not in post burn era)
     *      - amount_ must be different than current threshild
     *  @notice Emits:
     *      {NewThresholdSet} bytes1 index, uint256 previous, uint256 amount
     */
     /// @dev be carefull not to set the threshold too low on mainnet
    function setThreshold(
        bytes1 index_, 
        uint256 threshold_, 
        bool ethThreshold
    ) external onlyOwner {
        applies(index_);
        require(index_ >= 0xA0 && index_ <= 0xA3, "25");
        uint256 previous;
        if (ethThreshold) {
            require(Tax[index_].ethThreshold != threshold_, "09");
            previous = Tax[index_].ethThreshold;
            Tax[index_].ethThreshold = threshold_;
        } else {
            require(Tax[index_].sirThreshold != threshold_, "09");
            previous = Tax[index_].sirThreshold;
            Tax[index_].sirThreshold = threshold_;
        }
        emit NewThresholdSet(index_, previous, threshold_, ethThreshold);
    }

    /**
     *  @dev Check if an account is excluded from paying taxes.
     *  @param address_ address
     *  @return boolean
     */
    function isExcludedFromFee(
        address address_
    ) external view returns(bool) {
        return ExcludedFromFee.contains(address_);
    }

    /**
     *  @dev Check if an account is excluded from max transacion limit.
     *  @param address_ address
     *  @return boolean
     */
    function isExcludedFromMaxTx(
        address address_
    ) external view returns(bool) {
        return ExcludedFromMaxTx.contains(address_);
    }

   /**
     *  @dev Sets an address of account by index (lookup Keys).
     *  @notice if an address is locked then the lock timestamp will be 
     *  transferred to new address
     *  @param index_ bytes1
     *  @param address_ standard address
     *  @notice Required:
     *      - ValidAddress(address_) non 0 address
     *      - valid index_ (lookup Keys)
     *      - address_ is different from stored one.
     *  @notice Emits:
     *      {AddressSet} bytes1 index, address previous, address _address
     */
    function setAddress(
        bytes1 index_,
        address address_
    ) external onlyOwner {
        validAddress(address_);
        require(index_ >= 0xA0 && index_ <= 0xAC, "25");
        require(_address[index_] != address_, "09");
        address previousAddress = _address[index_];
        //if (_balances[previousAddress] > 0) {
        //    moveBalance(previousAddress, address_);
        //}
        _address[index_] = address_;
        if (isAccountLocked(previousAddress)) {
            setLock(_address[index_], _locked[previousAddress]);
            setLock(previousAddress, 0);
        }
        emit AddressSet(index_, previousAddress, address_);
    }

    /**
     *  @dev Sets maximum sell amount in percent.
     *  @param percent_ uint256 max sell in percent of liquidity.
     *  @notice Reqired: 
     *      - percent_ 100 to 1000 | multiply by 100 (100 = 1%, 50 = 0.5%, ...)
     *  @notice Emits: 
     *      {MaxSellPercentChanged} uint256 previous, uint256 percent.
     */
    function setMaxSellAmountPercent(
        uint256 percent_
    ) external onlyOwner {
        require(percent_ >= 100 && percent_ <= 1000, "20");
        uint256 previous = Max.sellPercent;
        Max.sellPercent = percent_;
        emit MaxSellPercentChanged(previous, percent_);
    }

    /**
     *  @dev Sets maximum buy amount in percent.
     *  @param percent_ uint256 max sell in percent of liquidity.
     *  @notice Reqired: 
     *      - percent_ 100 to 1000 | multiply by 100 (100 = 1%, 50 = 0.5%, ...)
     *  @notice Emits: 
     *      {MaxBuyPercentChanged} uint256 previous, uint256 percent.
     */
    function setMaxBuyAmountPercent(
        uint256 percent_
    ) external onlyOwner {
        require(percent_ >= 100 && percent_ <= 1000, "20");
        uint256 previous = Max.buyPercent;
        Max.buyPercent = percent_;
        emit MaxBuyPercentChanged(previous, percent_);
    }

    /// @dev returns maximum amount of tokens that can be sold in a transaction
    function getMaxSellAmount() external view returns(uint256) {
        return Max.sellAmount.div(_multiplier);
    }

    /// @dev returns maximum amount of tokens that can be sold in a transaction
    function _getMaxSellAmount() private view returns(uint256) {
        (uint256 count,) = _getReserves();
        return count.mul(Max.sellPercent).div(1e4);
    }

    /// @dev returns maximum amount of tokens that can be bought in a transaction
    function getMaxBuyAmount() external view returns(uint256) {
        return Max.buyAmount.div(_multiplier);
    }

    /// @dev returns maximum amount of tokens that can be bought in a transaction
    function _getMaxBuyAmount() private view returns(uint256) {
        (uint256 count,) = _getReserves();
        return count.mul(Max.buyPercent).div(1e4);
    }

    /// @dev returns maximum amount of tokens that can be transferred from wallet to wallet
    function getMaxTransactionAmount() external view returns(uint256) {
        return Max.txAmount.div(_multiplier);
    }

    /// @dev returns maximum amount of tokens that can be transferred from wallet to wallet
    function _getMaxTransactionAmount() private view returns(uint256) {
        return Total.supply.mul(Max.txPercent).div(1e4);
    }

    /// @dev returns data of Total struct
    function getTotals() external view returns(Totals memory) {
        return Total;
    }
    
    /// @dev returns data of Bool struct
    function getBooleans() external view returns(Booleans memory) {
        return Bool;
    }

    /// @dev returns data of Max struct
    function getMaxValues() external view returns(MaxVal memory) {
        return Max;
    }

    /**
     *  @dev returns data stored in Tax struct, by index
     *  @param index_ bytes1
     *  @return Taxes memory
     */
    function getTaxData(
        bytes1 index_
    ) external view returns(Taxes memory) {
        return Tax[index_];
    }

    /**
     *  @dev Sets maximum transaction amount in percent.
     *  @param percent_ uint256 max sell in percent of liquidity.
     *  @notice Reqired: 
     *      - percent_ 1 to 10 | multiply by 100 (100 = 1%, 50 = 0.5%, ...)
     *  @notice Emits: 
     *      {MaxTransactionChanged} uint256 previous percent, uint256 percent, previous Amount, new Amount
     */
    function setMaxTransactionPercent(
        uint256 percent_
    ) external onlyOwner {
        require(percent_ >= 100 && percent_ <= 1000, "20");
        uint256 previousPercent = Max.txPercent;
        uint256 previousAmount = Max.txAmount;
        Max.txPercent = percent_;
        Max.txAmount = _getMaxTransactionAmount();
        emit MaxTransactionChanged(previousPercent, Max.txPercent, previousAmount, Max.txAmount);
    }

    /**
     *  @param address_ address
     *  @param amount_ uint256
     *  @notice Required: 
     *      - non 0 or dead address
     *      - amount_ > 0
     *      - Total airdropped + amount has to be less than max total airdropped
     *      - isMainNet must be False
     *      - address_ wasn't used previously
     *  @notice Emits:
     *      {Airdroped} address _address, uint256 amount
     */
    function airdrop(
        address address_,
        uint256 amount_
    ) external onlyOwner {
        validAddress(address_);
        require(amount_ > 0, "00");
        require(Total.airdropped + amount_ <= Max.airdrop, "22");
        require(!Bool.isMainNet, "19");
        require(!Airdrops.contains(address_), "24");
        Total.airdropped += amount_;
        Airdrops.add(address_);
        transferBalance(_address[0xAA], address_, amount_);
        emit Airdroped(address_, amount_);
    }

    /**
     *  @dev buys tokens, with ETH on contract balance, and burns them.
     *  When amount of burned tokens reaches Max.burned limit, this function 
     *  is no longer used.
     *  @notice Emits:
     *      {BoughtBackAndBurned} uint256 eAmount eth, uint256 tAmount tokens
     */
    function _buyBackAndBurn() private lockTheSwap {
        uint256 eAmount = Tax[0xA0].ethBalance;
        Tax[0xA2].ethBalance = 0;
        if (Total.burned >= Max.burn && Bool.buyBack) {
            cleanUpAndEndTheBurn();
        } else {
            Total.buyback += eAmount;
            _swapEthForTokens(_address[0xA3], eAmount);
            uint256 diff;
            uint256 tAmount = _balances[_address[0xA3]];
            if (tAmount > 0) {
                uint256 burned = Total.burned + tAmount;
                if (burned > Max.burn) {
                    diff = burned - Max.burn;
                    tAmount -= diff;
                }
                __burn(_address[0xA3], tAmount);
                if (Total.burned == Max.burn) {
                    cleanUpAndEndTheBurn();
                }
                if (diff > 0) {
                    transferBalance(_address[0xA0], _address[0xA2], diff);
                }
                emit BoughtBackAndBurned(eAmount, tAmount);
            }
        }
    }

    /**
     *  @dev swap tokens to eth
     *  @param amount_ uint256 amount
     *  @return amount uint256 of new converted eth
     */
    function _swapTokensForEth(
        uint256 amount_
    ) private lockTheSwap returns(uint256) {
        uint256 previousBalance = address(this).balance;
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = _address[0xB1];
        _approve(address(this), _address[0xB2], amount_);
        _dexRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(
            amount_, 0, path, address(this), block.timestamp + 60000
        );
        return address(this).balance.sub(previousBalance);
    }

    /**
     *  @dev swap ethers to tokens
     *  @param to_ address
     *  @param amount_ uint256 amount
     */
    function _swapEthForTokens(
        address to_,
        uint256 amount_
    ) private lockTheSwap {
        address[] memory path = new address[](2);
        path[0] = _address[0xB1];
        path[1] = address(this);
        _dexRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount_}(
            0, path, to_, block.timestamp + 60000
        );
    }

    /**
     *  @dev returns address by index
     *  @param index_ bytes1 (lookup indexes)
     *  @return address
     */
    function getAddress(
        bytes1 index_
    ) external view returns(address) {
        return index_ <= 0xB4 ? _address[index_] : address(0);
    }

    /**
     *  @dev clean up after end of burn
     *  @notice Required:
     *      - buyBack has to be enabled 
     */
    function cleanUpAndEndTheBurn() private {
        require(Bool.buyBack, "21");
        //moveBalance(_address[0xA0], _address[0xA2]);
        //moveBalance(_address[0xA1], _address[0xA2]);
        //moveBalance(_address[0xA3], _address[0xA2]);
        Tax[0xA0].enabled = false;
        Tax[0xA1].enabled = false;
        Bool.buyBack = false;
        Bool.limitsEnabled = false;
        emit BurnEnded(block.timestamp, block.number);
    }

    /// @dev checks it trading enabled
    function isTradingEnabled() external view returns(bool) {
        return Bool.isTradingEnabled;
    }

    /// @dev returns state of lp (token, eth)
    function _getReserves() public view returns(uint256, uint256) {
        return UniswapV2Library.getReserves(_dexRouter.factory(), address(this), _address[0xB1]);
    }

    /// @dev returns address of liquidity pool
    function getLiquidityPoolAddress() public view returns(address) {
        return UniswapV2Library.pairFor(_address[0xB4], _address[0xB1], address(this));
    }

    /**
     *  @dev mints tokens to address
     *  @param address_ address
     *  @param amount_ amount
     *  @notice Required:
     *      - current total supply has to be less than initial supply
     *  @notice Emits:
     *      {Minted} address_ to, amount_ amount
     *      {Transfer} address_ from, address_ to, amount_ tokens
     */
    function __mint(
        address address_,
        uint256 amount_
    ) private {
        Total.supply += amount_;
        require(Total.supply <= _initialSupply, "22");
        _balances[address_] += amount_;
        emit Minted(address_, amount_);
        emit Transfer(address(0), address_, amount_);
    }

    /**
     *  @dev burns tokens from address
     *  @param from_ address
     *  @param amount_ amount
     *  @notice Required:
     *      - Total.burned + amount_ has to be less or equal to Max burn
     *      - amount has to be less or equal to balance
     *
    function burn(
        address from_, 
        uint256 amount_
    ) external onlyOwner {
        require(Total.burned + amount_ <= Max.burn, "22");
        require(amount_ <= _balances[from_], "05");
        __burn(from_, amount_);
    }*/

    /**
     *  @dev burns tokens from address
     *  @param address_ address
     *  @param amount_ amount
     *  @notice Emits:
     *      {Burned} address_ address, amount_ amount
     *      {Transfer} address_ from, address_ to, amount_ tokens
     */
    function __burn(
        address address_,
        uint256 amount_
    ) private {
        unchecked {
            _balances[address_] -= amount_;   
        }
        _balances[DEAD] += amount_;
        Total.burned += amount_;
        Total.supply -= amount_;
        Tax[0xA0].ethBalance = 0;
        IUniswapV2Pair(_dexPair).sync();
        Max.txAmount = _getMaxTransactionAmount();
        emit Burned(address_, amount_);
        emit Transfer(address_, DEAD, amount_);
    }

    /// @dev adds liquidity
    function _addLiquidity() private lockTheSwap {
        uint256 e = Tax[0xA1].ethBalance;
        Tax[0xA1].ethBalance = 0;
        uint256 b = _balances[_address[0xAC]];
        moveBalance(_address[0xAC], address(this));
        _approve(address(this), _address[0xB2], b);
        (uint256 t1, uint256 e1,) = _dexRouter.addLiquidityETH{value : e} (
            address(this), b, 0, 0, _owner, block.timestamp + 60000
        );
        Total.liquidatedTokens += t1;
        Total.liquidatedEthers += e1;
        Max.sellAmount = _getMaxSellAmount();
        Max.buyAmount = _getMaxBuyAmount();
        emit AddedLiquidity(e, b);
    }

    /**
     *  @dev Add eAmount_ of ETH and tAmount_ of tokens to the LP.
     *  Depends on the current rate for the pair between this token and WETH,
     *  eAmount_ and tAmount_ might not match perfectly.
     *  Dust(leftover) ETH or token will be refunded to this contract
     *  (usually very small quantity).
     *  @param eAmount_ uint256
     *  @param tAmount_ uint256
     *  @notice Required:
     *      - eth balance must be greater or equal to amount
     *      - token balance must be greater or equal to amount
     *
    function addLiquidity(
        uint256 eAmount_,
        uint256 tAmount_
    ) external onlyOwner {
        require(address(this).balance >= eAmount_, "16");
        require(_balances[_address[0xAC]] >= tAmount_, "05");
        _addLiquidity();
    }*/

    /**
     *  @dev transfer amount of tokens from_ address to to_ address
     *  @param from_ address
     *  @param to_ address
     *  @notice Emits:
     *      {Transfer} from_ address, to_ address, amount_ uint256
     */
    function moveBalance(
        address from_, 
        address to_
    ) private { 
        uint256 amount_ = _balances[from_];
        _balances[from_] = 0;
        _balances[to_] += amount_;
        emit Transfer(from_, to_, amount_);
    }

    /**
     *  @dev transfer amount of tokens from_ address to to_ address
     *  @param from_ address
     *  @param to_ address
     *  @param amount_ uint256
     *  @notice Emits:
     *      {Transfer} from_ address, to_ address, amount_ uint256
     */
    function transferBalance(
        address from_, 
        address to_, 
        uint256 amount_
    ) private {
        unchecked {
            _balances[from_] -= amount_;
            _balances[to_] += amount_;   
        }
        emit Transfer(from_, to_, amount_);
    }

    /// @dev recover ethers stuck on proxy
    function recoverETHFromProxy() external onlyOwner {
        proxy.sendEth();
    }

    /// @dev recovers Tokens stuck on proxy
    function recoverTokensFromProxy() external onlyOwner {
        moveBalance(_address[0xA3], _address[0xA2]);
    }

    /**
     *  @dev withdraw non-native tokens sent to contract address
     *  @param token_ address
     *  @param amount_ uint256
     *  @param senderAddress_ address
     *  @notice Required:
     *      - token address is not native token address
     *      - onlyOwner
     *  @notice Emits:
     *      {WithdrawnERC20} token_ address, senderAddress_ address, amount_ uint256
     */
    function withdrawTokenERC20(
        address token_,
        uint256 amount_,
        address senderAddress_
    ) external onlyOwner {
        require(token_ != address(this), "23");
        IERC20(token_).transfer(_owner, amount_);
        emit WithdrawnERC20(token_, senderAddress_, amount_);
    }

    /**
     *  @dev withdraw surplus ETH if any
     *  @param address_ address to
     */
    function withdrawETH(
        address address_
    ) external onlyOwner {
        uint256 sBalance = address(this).balance.sub(
            Tax[0xA0].ethBalance + 
            Tax[0xA1].ethBalance + 
            Tax[0xA2].ethBalance
        );
        if (sBalance > 1 ether) {
            payable(address_).transfer(sBalance);
            emit WithdrawnETH(address_, sBalance);
        }
    }

    /**
     *  @dev check if tax is in use - burn era
     *  @param index_ bytes1
     */
    function applies(
        bytes1 index_
    ) private view { 
        if (index_ == 0xA0 || index_ == 0xA1) {
            require(Bool.buyBack, "03");
        }
    }

    /**
     *  @dev cheks if an address is locked and unlocks if time has expired
     *  @param address_ address
     *  @return bool
     *  @notice Emits:
     *      {LiquidityUnlocked} address, timestamp
     *      or
     *      {AccountUnlocked} address, timestamp
     */
    function _checkLock(
        address address_
    ) private returns(bool) {
        if (_locked[address_] == 0) {
            return false;
        }
        if (_locked[address_] < block.timestamp) {
            _locked[address_] = 0;
            if (address_ == _address[0xAB]) {
                Bool.liquidityLocked = false;
                emit LiquidityUnlocked(address_, block.timestamp);
            } else {
                emit AccountUnlocked(address_, block.timestamp);
            }
            if (Total.lockedAccounts > 0) {
                Total.lockedAccounts -= 1;
            }
            return false;
        }
        return true;
    }

    /**
     *  @dev unlocks an address if timer has expired
     *  @param address_ address
     */
    function unlock(
        address address_
    ) external onlyOwner {
        _checkLock(address_);
    }

    /**
     *  @dev returns token and eth balances of tax addresses
     */
        function getTaxBalances() external view returns(
        uint256, uint256, uint256, 
        uint256, uint256, uint256, 
        uint256, uint256, uint256
    ) {
        return (
            address(this).balance,
            Tax[0xA0].ethBalance,
            Tax[0xA1].ethBalance,
            Tax[0xA2].ethBalance,
            _balances[address(this)],
            _balances[_address[0xA0]],
            _balances[_address[0xA1]],
            _balances[_address[0xAC]],
            _balances[_address[0xA2]]
        );
    }

    /**
     *  @dev check if router is Uniswap because we burn only on Uniswap
     *  @return bool
     */
    function isRouterUniswap() private view returns(bool) {
        return _address[0xB2] == address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D) ? true : false;
    }
    
    /**
     *  @dev check if an address is valid 
     *  @param address_ address
     *  @notice Required:
     *      - address should not be 0 or DEAD
     */
    function validAddress(
        address address_
    ) private pure {
        require(address_ != address(0) && address_ != DEAD, "01");
    }
}