{{

  "language": "Solidity",

  "sources": {

    "@openzeppelin/contracts/access/Ownable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/Context.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"

    },

    "contracts/test.sol": {

      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.19;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nstruct Account {\n    bool isGlobal;\n    uint256 balance;\n    uint256 globalRewardsPaid;\n}\n\ncontract RewardToken is Ownable {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n    uint256 private _totalSupply;\n    uint8 private immutable _adminTax;\n    uint8 private immutable _globalTax;\n    uint8 private immutable _burnTax;\n    address private immutable _adminTaxReceiver;\n    address private immutable _burnAddress;\n\n    address[] private _globalList;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event GlobalRewardPaid(address to, uint256 value);\n    event AdminTaxPaid(address to, uint256 value);\n    event Burn(address _burnAddress, uint256 value);\n    event ExcludeStatus(address, bool);\n\n    mapping(address => Account) private _accounts;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    mapping(address => bool) private _isExcludedFromTax;\n\n    constructor() {\n        _name = \"Trump Army\";\n        _symbol = \"TRUMPX\";\n        _decimals = 18;\n        _totalSupply = 100000000 * 10 ** _decimals;\n        _adminTax = 2;\n        _globalTax = 2;\n        _burnTax = 1;\n        _adminTaxReceiver = 0x1f6b32601345A92FB77656699ae157be9270D9B2;\n        _burnAddress = 0x000000000000000000000000000000000000dEaD;\n\n        _isExcludedFromTax[owner()] = true;\n\n        _accounts[msg.sender].balance += _totalSupply;\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n\n    function name() external view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() external view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() external view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address _userAddress) external view returns (uint256) {\n        return _accounts[_userAddress].balance;\n    }\n\n    function transfer(address to, uint256 amount) external {\n        _transfer(msg.sender, to, amount);\n    }\n\n    function allowance(\n        address owner,\n        address spender\n    ) external view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) external returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    function _approve(\n        address _owner,\n        address _spender,\n        uint256 _valueInWei\n    ) internal virtual {\n        require(_owner != address(0), \"ERC20: approve from the zero address\");\n        require(_spender != address(0), \"ERC20: approve to the zero address\");\n        require(_valueInWei > 0, \"ERC20: approve value is zero.\");\n\n        _allowances[_owner][_spender] = _valueInWei;\n        emit Approval(_owner, _spender, _valueInWei);\n    }\n\n    function globalList() external view returns (address[] memory) {\n        return _globalList;\n    }\n\n    function increaseAllowance(address _spender, uint256 _valueInWei) external {\n        require(_valueInWei > 0, \"ERC20: approve value is zero.\");\n        address _msgSender = msg.sender;\n        require(\n            _accounts[_msgSender].balance >=\n                _allowances[_msgSender][_spender] + _valueInWei,\n            \"ERC20: Insufficient balance to approve.\"\n        );\n        _allowances[_msgSender][_spender] += _valueInWei;\n    }\n\n    function decreaseAllowance(address _spender, uint256 _valueInWei) external {\n        require(_valueInWei > 0, \"ERC20: approve value is zero.\");\n        require(\n            _spender != address(0),\n            \"ERC20: spender can't be address zero.\"\n        );\n\n        address _msgSender = msg.sender;\n        require(\n            _allowances[_msgSender][_spender] - _valueInWei >= 0,\n            \"ERC20: Allowance cannot be less than zero.\"\n        );\n        _allowances[_msgSender][_spender] -= _valueInWei;\n    }\n\n    function transferFrom(address from, address to, uint256 amount) external {\n        address _msgSender = msg.sender;\n        _transferFrom(from, _msgSender, to, amount);\n    }\n\n    function _transfer(\n        address _from,\n        address _to,\n        uint256 _valueInWei\n    ) private {\n        require(\n            _to != address(0),\n            \"ERC20: Address zero cannot be the receiver.\"\n        );\n        require(_valueInWei > 0, \"ERC20: Value should be greater than zero.\");\n\n        uint256 userBalance = _accounts[_from].balance;\n        require(userBalance >= _valueInWei, \"ERC20: Insuffient balance.\");\n\n        if (_isExcludedFromTax[_from] || _isExcludedFromTax[_to]) {\n            unchecked {\n                _accounts[_from].balance -= _valueInWei;\n                _accounts[_to].balance += _valueInWei;\n                emit Transfer(_from, _to, _valueInWei);\n            }\n        } else {\n            Account storage toAccount = _accounts[_to];\n            address burnAddress = _burnAddress;\n            address adminTaxReceiver = _adminTaxReceiver;\n\n            if (!toAccount.isGlobal) {\n                _globalList.push(_to);\n                toAccount.isGlobal = true;\n            }\n\n            unchecked {\n                uint256 adminTaxValue = (_valueInWei * _adminTax) / 100;\n                uint256 globalReward = (_valueInWei * _globalTax) / 100;\n                uint256 burnTaxValue = (_valueInWei * _burnTax) / 100;\n\n                uint256 remainingValue = _valueInWei -\n                    (adminTaxValue + globalReward + burnTaxValue);\n\n                _accounts[_from].balance -= _valueInWei;\n\n                _accounts[adminTaxReceiver].balance += adminTaxValue;\n                emit AdminTaxPaid(adminTaxReceiver, adminTaxValue);\n\n                _accounts[burnAddress].balance += burnTaxValue;\n                emit Burn(burnAddress, burnTaxValue);\n\n                toAccount.balance += remainingValue;\n\n                address globalAddress = _getRandomGlobalAddress();\n                _accounts[globalAddress].balance += globalReward;\n                emit GlobalRewardPaid(globalAddress, globalReward);\n\n                emit Transfer(_from, _to, remainingValue);\n                emit Transfer(_from, adminTaxReceiver, adminTaxValue);\n                emit Transfer(_from, burnAddress, burnTaxValue);\n                emit Transfer(_from, globalAddress, globalReward);\n            }\n        }\n    }\n\n    function _transferFrom(\n        address _owner,\n        address _spender,\n        address _to,\n        uint256 _valueInWei\n    ) private {\n        require(_valueInWei > 0, \"ERC20: Cannot transfer zero value\");\n        require(\n            _spender != address(0),\n            \"ERC20: Spender can't be address zero.\"\n        );\n\n        require(\n            _allowances[_owner][_spender] >= _valueInWei,\n            \"ERC20: Insufficient allowance\"\n        );\n\n        _transfer(_owner, _to, _valueInWei);\n        _allowances[_owner][_spender] -= _valueInWei;\n    }\n\n    function _getRandomGlobalAddress() private view returns (address) {\n        uint256 randomHash = uint256(\n            keccak256(\n                abi.encodePacked(\n                    block.timestamp,\n                    block.prevrandao,\n                    blockhash(block.number - 1)\n                )\n            )\n        );\n\n        uint256 randomIndex = randomHash % _globalList.length;\n        return _globalList[randomIndex];\n    }\n\n    function getUserAccount(\n        address _userAccount\n    ) external view returns (Account memory) {\n        return _accounts[_userAccount];\n    }\n\n    function adminTax() external view returns (uint8) {\n        return _adminTax;\n    }\n\n    function adminTaxReceiverAddress() external view returns (address) {\n        return _adminTaxReceiver;\n    }\n\n    function burnTax() external view returns (uint8) {\n        return _burnTax;\n    }\n\n    function globalTax() external view returns (uint8) {\n        return _globalTax;\n    }\n\n    function totalTax() external view returns (uint8) {\n        return _adminTax + _globalTax + _burnTax;\n    }\n\n    function isExcludedFromTax(address _address) external view returns (bool) {\n        return _isExcludedFromTax[_address];\n    }\n\n    //exclude wallets from fees, this is needed for launch or other contracts.\n    function excludeFromFee(address _address, bool status) external onlyOwner {\n        require(\n            _isExcludedFromTax[_address] != status,\n            \"The wallet ialready have that status.\"\n        );\n        _isExcludedFromTax[_address] = status;\n        emit ExcludeStatus(_address, status);\n    }\n}\n"

    }

  },

  "settings": {

    "optimizer": {

      "enabled": true,

      "runs": 200

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "libraries": {}

  }

}}