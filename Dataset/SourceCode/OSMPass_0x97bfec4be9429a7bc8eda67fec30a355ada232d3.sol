{{

  "language": "Solidity",

  "sources": {

    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"

    },

    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"

    },

    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"

    },

    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"

    },

    "@openzeppelin/contracts/utils/Address.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/Base64.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Base64.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides a set of functions to operate with Base64 strings.\n *\n * _Available since v4.5._\n */\nlibrary Base64 {\n    /**\n     * @dev Base64 Encoding/Decoding Table\n     */\n    string internal constant _TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    /**\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\n     */\n    function encode(bytes memory data) internal pure returns (string memory) {\n        /**\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\n         */\n        if (data.length == 0) return \"\";\n\n        // Loads the table into memory\n        string memory table = _TABLE;\n\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\n        // and split into 4 numbers of 6 bits.\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\n        // - `data.length + 2`  -> Round up\n        // - `/ 3`              -> Number of 3-bytes chunks\n        // - `4 *`              -> 4 characters for each chunk\n        string memory result = new string(4 * ((data.length + 2) / 3));\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Prepare the lookup table (skip the first \"length\" byte)\n            let tablePtr := add(table, 1)\n\n            // Prepare result pointer, jump over length\n            let resultPtr := add(result, 32)\n\n            // Run over the input, 3 bytes at a time\n            for {\n                let dataPtr := data\n                let endPtr := add(data, mload(data))\n            } lt(dataPtr, endPtr) {\n\n            } {\n                // Advance 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // To write each character, shift the 3 bytes (18 bits) chunk\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\n                // and apply logical AND with 0x3F which is the number of\n                // the previous character in the ASCII table prior to the Base64 Table\n                // The result is then added to the table to get the character to write,\n                // and finally write it in the result pointer but with a left shift\n                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n            }\n\n            // When data `bytes` is not exactly 3 bytes long\n            // it is padded with `=` characters at the end\n            switch mod(mload(data), 3)\n            case 1 {\n                mstore8(sub(resultPtr, 1), 0x3d)\n                mstore8(sub(resultPtr, 2), 0x3d)\n            }\n            case 2 {\n                mstore8(sub(resultPtr, 1), 0x3d)\n            }\n        }\n\n        return result;\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/Context.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"

    },

    "@openzeppelin/contracts/utils/math/Math.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/Strings.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"

    },

    "contracts/OSM/Allowable.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\nimport \"./EIP712Allowlisting.sol\";\nimport \"./Phaseable.sol\";\nimport \"./FlexibleMetadata.sol\";\nimport \"./Nameable.sol\";\nimport { Phase, PhaseNotActiveYet, PhaseExhausted, WalletMintsFilled } from \"./SetPhaseable.sol\";\n\nabstract contract Allowable is EIP712Allowlisting {  \n    \n    constructor(string memory name, string memory symbol) FlexibleMetadata(name,symbol) {\n        setSigningAddress(msg.sender);\n        setDomainSeparator(name, symbol);\n        initializePhases();\n    }\n\n    function initializePhases() internal virtual;\n\n    function canMint(uint64 phase, uint256 quantity) internal override virtual returns(bool) {\n        uint64 activePhase = activePhase();\n        if (phase > activePhase) {\n            revert PhaseNotActiveYet();\n        }\n        uint256 requestedSupply = minted()+quantity;\n        Phase memory requestedPhase = findPhase(phase);\n        if (requestedSupply > requestedPhase.highestSupply) {\n            revert PhaseExhausted();\n        }\n       \n        uint256 requestedMints = quantity+getAux16(msg.sender)[phase];\n        if (requestedPhase.maxPerWallet > 0 && requestedMints > requestedPhase.maxPerWallet) {\n            revert WalletMintsFilled(requestedMints);\n        }\n        return true;\n    }\n}\n\n/**\n * Ordo Signum Machina - 2023\n */"

    },

    "contracts/OSM/Approvable.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"./Ownable.sol\";\nimport \"./Nameable.sol\";\nimport { TokenNonOwner } from \"./SetOwnerEnumerable.sol\";\nimport { OwnerEnumerable } from \"./OwnerEnumerable.sol\";\nimport { SetApprovable, ApprovableData, TokenNonExistent } from \"./SetApprovable.sol\";\nimport { PackableOwnership } from \"./PackableOwnership.sol\";\nabstract contract Approvable is OwnerEnumerable {  \n    using SetApprovable for ApprovableData; \n    ApprovableData approvable;\n\n    function _checkTokenOwner(uint256 tokenId) internal view virtual {\n        if (ownerOf(tokenId) != msg.sender) {\n            revert TokenNonOwner(msg.sender, tokenId);\n        }\n    }    \n \n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return approvable.isApprovedForAll(owner,operator);\n    }  \n\n    function approve(address to, uint256 tokenId) public virtual override {  \n        _checkTokenOwner(tokenId);      \n        approvable.approveForToken(to, tokenId);\n        emit Approval(ownerOf(tokenId), to, tokenId);        \n    }  \n\n    function setApprovalForAll(address operator, bool approved) public virtual override {   \n        approved ? approvable.approveForContract(operator): approvable.revokeApprovalForContract(operator, msg.sender);\n    }       \n\n    function validateApprovedOrOwner(address spender, uint256 tokenId) internal view {        \n        if (!(spender == ownerOf(tokenId) || isApprovedForAll(ownerOf(tokenId), spender) || approvable.getApproved(tokenId) == spender)) {\n            revert TokenNonOwner(spender, tokenId);\n        }\n    }  \n\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        requireMinted(tokenId);\n        return approvable.tokens[tokenId].approval;\n    }       \n\n    function revokeTokenApproval(uint256 tokenId) internal {\n        approvable.revokeTokenApproval(tokenId);\n    }\n\n    function revokeApprovals(address holder) internal {\n        approvable.revokeApprovals(holder,tokensOwnedBy(holder));                    \n    }\n\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function requireMinted(uint256 tokenId) internal view virtual {\n        if (!exists(tokenId)) {\n            revert TokenNonExistent(tokenId);\n        }\n    }    \n\n    function exists(uint256 tokenId) internal view virtual override returns (bool) {\n        if (enumerationExists(tokenId)) {\n            return approvable.tokens[tokenId].exists;\n        }\n        return PackableOwnership.exists(tokenId);\n    }      \n}"

    },

    "contracts/OSM/Assignable.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\nimport { SetAssignable, AssignableData, NotTokenOwner, NotAssigned } from \"./SetAssignable.sol\";\nimport { OwnerEnumerable } from \"./OwnerEnumerable.sol\";\nimport \"./Phaseable.sol\";\n\n\nabstract contract Assignable is Phaseable {  \n    using SetAssignable for AssignableData;\n    AssignableData assignables;\n    \n    function assignColdStorage(uint256 tokenId) external {        \n        if (msg.sender != ownerOf(tokenId)) {\n            revert NotTokenOwner();\n        }\n        assignables.addAssignment(msg.sender,tokenId);\n    }\n    \n    function revokeColdStorage(uint256 tokenId) external {        \n        if (assignables.findAssignment(msg.sender) != tokenId) {\n            revert NotAssigned(msg.sender);\n        }\n        assignables.removeAssignment(msg.sender);\n    }   \n    \n    function revokeAssignments(uint256 tokenId) external {        \n        if (msg.sender != ownerOf(tokenId)) {\n            revert NotTokenOwner();\n        }\n        assignables.revokeAll(tokenId);\n    }    \n    \n    function findAssignments(uint256 tokenId) external view returns (address[] memory){        \n        return assignables.findAssignees(tokenId);\n    }        \n\n    function balanceOf(address seekingContract, address owner) external view returns (uint256) {        \n        uint256 guardianBalance = balanceOf(owner);\n        if (guardianBalance > 0) {\n            uint256[] memory guardians = tokensOwnedBy(owner);\n            return assignables.iterateGuardiansBalance(guardians, seekingContract, 0);\n        }\n        return 0;\n    }     \n}"

    },

    "contracts/OSM/EIP712Allowlisting.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"./EIP712Listable.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nbytes32 constant ALLOW_MINT_TYPE =\n    keccak256(\"Minter(address wallet)\");\n\nbytes32 constant BAG_MINT_TYPE =\n    keccak256(\"Minter(string genesisBagAddress)\");\n\nbytes32 constant FREE_MINT_TYPE =\n    keccak256(\"Minter(string genesisStakedAddress)\");    \n\n\nabstract contract EIP712Allowlisting is EIP712Listable {\n    using ECDSA for bytes32;\n    using Strings for uint256;\n    using Strings for uint160;\n    using Strings for address;\n\n    struct recovered { \n        address receipient;\n        bytes signature;\n        address recovered;\n        address signingKey;\n    }\n\n    uint256[] empty;\n\n    function recoverAllowAddress(bytes calldata sig, address recip) public view returns (recovered memory) {\n        // bytes32 digest = keccak256(\n        //     abi.encodePacked(\n        //         \"\\x19\\x01\",\n        //         DOM_SEP,\n        //         keccak256(abi.encode(ALLOW_MINT_TYPE, recip))\n        //     )\n        // );      \n        bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(ALLOW_MINT_TYPE, recip)));          \n        address recoveredAddress = digest.recover(sig);\n        \n        return recovered(recip, sig, recoveredAddress, sigKey);\n    }\n    modifier requiresAllowSig(bytes calldata sig, address recip) {\n        require(sigKey != address(0), \"allowlist not enabled\");\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOM_SEP,\n                keccak256(abi.encode(ALLOW_MINT_TYPE, recip))\n            )\n        );\n        address recovery = digest.recover(sig);\n        require(recovery == sigKey, \"invalid signature\");\n        require(msg.sender == recip, \"invalid signature\");\n        _;\n    }\n    struct recoveredBag { \n        address receipient;\n        bytes signature;\n        address recovered;\n        address signingKey;\n        string bagging;\n        uint256 total;\n    }    \n    \n    function recoverClaimSig(bytes calldata sig, address recip, uint256[] memory bag) public view returns (recoveredBag memory) {        \n        return recoverClaimSig(sig, recip, bag, empty);            \n    }\n\n    function recoverClaimSig(bytes calldata sig, address recip, uint256[] memory bag, uint256[] memory staked) public view returns (recoveredBag memory) {\n        require(sigKey != address(0), \"allowlist not enabled\");\n        uint total = uint(uint160(recip));\n        for (uint i; i < bag.length; i++) {\n            total += bag[i];\n        }\n        for (uint i; i < staked.length; i++) {\n            total += staked[i];\n        }        \n        string memory bagged = total.toString();\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOM_SEP,\n                keccak256(abi.encode(FREE_MINT_TYPE,keccak256(abi.encodePacked(bagged))))\n            )\n        );\n        address recovery = digest.recover(sig);\n        return recoveredBag(recip, sig, recovery, sigKey, bagged, total);               \n    }\n    modifier requiresBagSig(bytes calldata sig, address recip, uint256[] memory bag) {\n        require(sigKey != address(0), \"allowlist not enabled\");\n        uint total = uint(uint160(recip));\n        for (uint i; i < bag.length; i++) {\n            total += bag[i];\n        }\n        string memory bagged = total.toString();\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOM_SEP,\n                keccak256(abi.encode(FREE_MINT_TYPE,keccak256(abi.encodePacked(bagged))))\n            )\n        );\n        address recovery = digest.recover(sig);\n        require(recovery == sigKey, \"invalid signature\");\n        require(msg.sender == recip, \"invalid signature\");\n        _;\n    }        \n    modifier requiresClaimSig(bytes calldata sig, address recip, uint256[] memory bag, uint256[] memory staked) {\n        require(sigKey != address(0), \"allowlist not enabled\");\n        uint total = uint(uint160(recip));\n        for (uint i; i < bag.length; i++) {\n            total += bag[i];\n        }\n        for (uint i; i < staked.length; i++) {\n            total += staked[i];\n        }        \n        string memory bagged = total.toString();\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOM_SEP,\n                keccak256(abi.encode(FREE_MINT_TYPE,keccak256(abi.encodePacked(bagged))))\n            )\n        );\n        address recovery = digest.recover(sig);\n        require(recovery == sigKey, \"invalid signature\");\n        require(msg.sender == recip, \"invalid signature\");\n        _;\n    }    \n}"

    },

    "contracts/OSM/EIP712Listable.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\nimport \"./Assignable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\nabstract contract EIP712Listable is Assignable {\n    using ECDSA for bytes32;\n\n    address internal sigKey = address(0);\n\n    bytes32 internal DOM_SEP;    \n\n    uint256 chainid = 420;\n\n    function setDomainSeparator(string memory _name, string memory _version) internal {\n        DOM_SEP = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(bytes(_name)),\n                keccak256(bytes(_version)),\n                chainid,\n                address(this)\n            )\n        );\n    }\n\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(DOM_SEP, structHash);\n    }    \n\n    function getSigningAddress() public view returns (address) {\n        return sigKey;\n    }\n\n    function setSigningAddress(address _sigKey) public onlyOwner {\n        sigKey = _sigKey;\n    }\n\n    function isOwner() public view returns (bool) {\n        return msg.sender == owner();\n    }\n  \n}"

    },

    "contracts/OSM/FlexibleMetadata.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"./Ownable.sol\";\nimport \"./Nameable.sol\";\nimport { DEFAULT, FLAG, PRE, Supplement, SetFlexibleMetadata, FlexibleMetadataData } from \"./SetFlexibleMetadata.sol\";\n\nabstract contract FlexibleMetadata is Ownable, Context, ERC165, IERC721, Nameable {  \n    using SetFlexibleMetadata for FlexibleMetadataData;\n    FlexibleMetadataData flexible;   \n\n    constructor(string memory _name, string memory _symbol) Nameable(_name,_symbol) {\n    }   \n    \n    function setContractUri(string memory uri) external onlyOwner {\n        flexible.setContractMetadataURI(uri);\n    }\n\n    function reveal(bool _reveal) external onlyOwner {\n        flexible.reveal(_reveal);\n    }\n\n    function setTokenUri(string memory uri, uint256 tokenType) external onlyOwner {\n        tokenType == FLAG ?\n            flexible.setFlaggedTokenMetadataURI(uri):\n            (tokenType == PRE) ?\n                flexible.setPrerevealTokenMetadataURI(uri):\n                    flexible.setDefaultTokenMetadataURI(uri);\n    }\n\n    function setSupplementalTokenUri(uint256 key, string memory uri) external onlyOwner {\n        flexible.setSupplementalTokenMetadataURI(key,uri);\n    }\n\n    function flagToken(uint256 tokenId, bool isFlagged) external onlyOwner {\n        flexible.flagToken(tokenId,isFlagged);\n    }\n\n    function setSupplemental(uint256 tokenId, bool isSupplemental, uint256 key) internal {\n        if (isSupplemental) {\n            flexible.supplemental[tokenId] = Supplement(key,true);\n        } else {\n            delete flexible.supplemental[tokenId];\n        }\n    }    \n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165,IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }   \n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {        \n        return flexible.getTokenMetadata(tokenId);\n    }          \n    function contractURI() external view returns (string memory) {\n        return flexible.getContractMetadata();\n    }    \n}"

    },

    "contracts/OSM/Lockable.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\nimport \"./Approvable.sol\";\nimport { SetLockable, LockableStatus,  LockableData, WalletLockedByOwner } from \"./SetLockable.sol\";\nabstract contract Lockable is Approvable {    \n    using SetLockable for LockableData; \n    LockableData lockable;\n\n    bool soulBound = false;\n\n    function custodianOf(uint256 id)\n        public\n        view\n        returns (address)\n    {             \n        return lockable.findCustodian(ownerOf(id));\n    }     \n\n    function lockWallet(uint256 id) public {           \n        revokeApprovals(ownerOf(id));\n        lockable.lockWallet(ownerOf(id));\n    }\n\n    function unlockWallet(uint256 id) public {              \n        lockable.unlockWallet(ownerOf(id));\n    }    \n\n    function _forceUnlock(uint256 id) internal {  \n        lockable.forceUnlock(ownerOf(id));\n    }    \n\n    function setCustodian(uint256 id, address custodianAddress) public {       \n        lockable.setCustodian(custodianAddress,ownerOf(id));\n    }\n\n    function isLocked(uint256 id) public view returns (bool) {     \n        if (enumerationExists(id)) {\n            return lockable.lockableStatus[ownerOf(id)].isLocked;\n        }\n        return false;\n    } \n\n    function lockedSince(uint256 id) public view returns (uint256) {     \n        return lockable.lockableStatus[ownerOf(id)].lockedAt;\n    }     \n\n    function validateLock(uint256 tokenId) internal view {\n        if (isLocked(tokenId)) {\n            revert WalletLockedByOwner();\n        }\n    }\n\n    function soulBind() internal {\n        soulBound = true;\n    }\n    \n    function releaseSoul() internal {\n        soulBound = false;\n    }    \n}"

    },

    "contracts/OSM/LockableTransferrable.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"./Lockable.sol\";\nimport { LockableStatus,InvalidTransferRecipient,ContractIsNot721Receiver } from \"./SetLockable.sol\";\n\n\n\nabstract contract LockableTransferrable is Lockable {  \n    using Address for address;\n\n    function approve(address to, uint256 tokenId) public virtual override {  \n        validateLock(tokenId);\n        super.approve(to,tokenId);      \n    }  \n\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        if (tokensOwnedBy(msg.sender).length > 0) {\n            validateLock(tokensOwnedBy(msg.sender)[0]);\n        }\n        super.setApprovalForAll(operator,approved);     \n    }        \n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {        \n        validateApprovedOrOwner(msg.sender, tokenId);\n        validateLock(tokenId);\n        _transfer(from,to,tokenId);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal {\n                \n        if(to == address(0)) {\n            revert InvalidTransferRecipient();\n        }\n\n        revokeTokenApproval(tokenId);   \n\n        if (enumerationExists(tokenId)) {\n            swapOwner(from,to,tokenId);\n        }\n        \n        packedTransferFrom(from, to, tokenId);\n\n        completeTransfer(from,to,tokenId);    \n    }   \n\n    function completeTransfer(\n        address from,\n        address to,\n        uint256 tokenId) internal {\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }    \n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        validateApprovedOrOwner(msg.sender, tokenId);\n        validateLock(tokenId);\n        _safeTransfer(from, to, tokenId, data);\n    }     \n\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        if (!_checkOnERC721Received(from, to, tokenId, data)) {\n            revert ContractIsNot721Receiver();\n        }        \n        _transfer(from, to, tokenId);\n    }\n\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert InvalidTransferRecipient();\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }    \n\n}"

    },

    "contracts/OSM/Mintable.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\nimport \"./LockableTransferrable.sol\";\nimport { TokenOwnership } from \"./SetOwnerEnumerable.sol\";\nerror InvalidRecipient(address zero);\nerror TokenAlreadyMinted(uint256 tokenId);\nerror InvalidToken(uint256 tokenId);\nerror MintIsNotLive();\n\nabstract contract Mintable is LockableTransferrable {  \n\n    mapping(address => mapping(uint256 => bool)) claimed; \n\n    bool isLive;\n\n    function setMintLive(bool _isLive) public onlyOwner {\n        isLive = _isLive;\n    }\n\n    function hasBeenClaimed(uint256 tokenId, address addressed) public view returns (bool) {\n        return claimed[addressed][tokenId];\n    }\n\n    function claim(uint256 tokenId, address addressed) internal {\n        claimed[addressed][tokenId] = true;\n    }\n\n    function getSenderMints() internal view returns (uint256) {\n        return numberMinted(msg.sender);\n    }\n\n    function _mint(address to, uint256 quantity, bool enumerate) internal virtual returns (uint256) {\n        if (!isLive) {\n            revert MintIsNotLive();\n        }\n        if (to == address(0)) {\n            revert InvalidRecipient(to);\n        }\n        \n        return enumerate ? enumerateMint(to, quantity) : packedMint(to, quantity);\n    }\n}"

    },

    "contracts/OSM/Nameable.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\n\n\nabstract contract Nameable is IERC721Metadata {   \n    string named;\n    string symbolic;\n\n    constructor(string memory _name, string memory _symbol) {\n        named = _name;\n        symbolic = _symbol;\n    }\n\n    function name() public virtual override view returns (string memory) {\n        return named;\n    }  \n\n    function symbol() public virtual override view returns (string memory) {\n        return symbolic;\n    }          \n      \n}"

    },

    "contracts/OSM/OSMPass.sol": {

      "content": "\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\nimport \"./Allowable.sol\";\nimport \"./PackableOwnership.sol\";\nimport \"@openzeppelin/contracts/utils/Base64.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { SetMetadataRenderable, RenderableData } from \"./SetMetadataRenderable.sol\";\nerror Unphased();\n/**\n                             ╓µ▄▄▓███████████████▓▄▄╓\n                      ,╔▄██████████████████████████████▓▄,\n                  ,▄▓███████████████████████████████████████▄,\n               ╓▄██████████████████████████████████████████████▄╓\n             ▄████████████████████████████████████████████████████▄\n          ,▄████████████████████████████████████████████████████████▓,\n         ▄█████▀▀██████▀▀█████████████████████████████████████████████▓\n       ╔██████▌  ╟████▒ ¡███████████████████████████████████████████████▄\n     ,▓████████  \"▀██▀  ▐█████████████████████████████████████████████████,\n    ]██████████▄        ╣██████████████████████████████████████████████████ε\n   ╔█████████████▓▄▄▄▄▓█████████████████████████████████████████████████████▄\n  ]█████████████▀╙╙╙╙╙╙▀████████▀╙╙╙╙╙╙╙╙▀██▌╙╙╙╙╠██╙╙╙╙▀███▀╙╙╙╙╚███████████▒\n ,▓███████████╙          ╚████╩          ]██▌    ▐▒      ╚█`      ╙███████████\n ╟███████████⌐     ,      ╟██▒           ▐██▌                      ╟███████████\n]███████████▌     ▓██▒    \"██⌐     ╔▄▓▓▄▄╣██▌    .▄█▓,    .▓█▓     ╟███████████▒\n║███████████▒    ]████     ╟█▒    ]█████████▌    ▐███▒    ╟███⌐    ╟███████████▌\n▓███████████░    ▐████     ╟█▌     ╟████████▌    ║███▒    ╟███⌐    ╟████████████\n████████████     ║████     ║██▒     ╚███████▌    ║███▒    ╟███⌐    ╟████████████\n████████████     ║████     ▐███▓     ╙██████▌    ║███▒    ╟███⌐    ╟████████████\n████████████     ║████     ▐█████▄     ╙████▌    ║███▒    ╟███⌐    ╟████████████\n╟███████████     ║████     ▐███████     ╙███▌    ║███▒    ╟███⌐    ╟████████████\n▐███████████░    ║████     ║████████     ▐██▌    ║███▒    ╟███⌐    ╟███████████▌\n ╟██████████▒    ╚████     ╟████████▌     ╟█▌    ║███▒    ╟███⌐    ╟███████████\n ╙██████████▌     ███▒    ,▓██▀█████\"     ╟█▌    ▐███▒    ╟███⌐    ╟██████████╩\n  ╚██████████     ╙▀╩     ║██▌            ╫█▌    ▐███▒    ╟███⌐    ╟█████████▌\n   ╟█████████▓           ;███▒           ▐██▌    ▐███▒    ╟███⌐    ╟████████▌\n    ╚██████████,       .▄████µ         ,▓███▒    ▐███░    ╟███⌐    ╟███████▌\n     ╙████████████▓▓▓█████████████▓▓██████████████████████████████████████╩\n      └╫█████████████████████████████████████████████████████████████████\"\n        ╙██████████████████████████████████████████████████████████████╩\n          ╙██████████████████████████████████████████████████████████▀\n            ╙██████████████████████████████████████████████████████╨\n               ╚████████████████████████████████████████████████▀\"\n                 `╙██████████████████████████████████████████▀`\n                     ╙▀██████████████████████████████████▀╙\n                          ╙╙▀██████████████████████▀▀╙ \n */\n\n/// @title Horde OSM Pass\n/// @author @OsmOnomous https://osm.tools\n\ncontract OSMPass is Allowable {    \n    using Strings for uint256;\n    using SetMetadataRenderable for RenderableData;\n    RenderableData renderings;\n    // minting phases\n    uint64 ALLOW_PHASE = 0;\n\n    // supply and allowances\n    uint64 MAX_SUPPLY = 1001;\n\n    // allowed phase\n    uint64 ALLOW_PER = 1;\n    uint64 ALLOW_SUPPLY = 1001;\n    uint64 ALLOW_PRICE = 0; \n    \n   /**\n     * Initialization\n     */\n        \n    /// @notice contract is initialized as soul bound, no transfers or approvals allowed\n    constructor() Allowable(\"Horde OSM Pass\",\"OSMPASS\") {\n        soulBind();\n        initializePhases();        \n    }\n\n    /// @notice initialization of minting phases\n    function initializePhases() internal virtual override {\n        Phase[] storage phases = getPhases();\n\n        // Phase struct\n        // name, maxPerWallet (0 indicates no limit), maxMint, price\n        phases.push(Phase(ALLOW_PHASE, ALLOW_PER, ALLOW_SUPPLY, ALLOW_PRICE));\n        \n        initialize(phases,MAX_SUPPLY);        \n    }\n\n    /**\n     * Minting & Burning\n     */      \n\n    /// @notice minting ALLOW_PHASE, requires trusted signature, maximum quantity 1 per wallet    \n    /// @param signature bytes trusted signature \n    function allowlistMint(bytes calldata signature) \n    external requiresAllowSig(signature,msg.sender) {                  \n        phasedMint(ALLOW_PHASE, 1, false);        \n        uint16[4] memory aux = getAux16(msg.sender);\n        aux[ALLOW_PHASE] = aux[ALLOW_PHASE]+1;\n        setAux32(msg.sender, aux);\n    }\n\n    /// @notice burn function\n    /// @param tokenId uint256 token id to burn\n    function burn(uint256 tokenId) external {\n\n        validateApprovedOrOwner(msg.sender, tokenId);\n        \n        validateLock(tokenId);   \n\n        if (enumerationExists(tokenId)) {\n            enumerateBurn(msg.sender,tokenId);\n            selfDestruct(tokenId);\n        }\n\n        packedBurn(tokenId);\n    }\n\n    /**\n     * Owner Utility and Managment of TREASURY \n     */  \n\n    /// @notice empower function\n    /// @param tokenId uint256 token id to empower\n    function empower(uint256 tokenId) external {\n        validateApprovedOrOwner(msg.sender, tokenId);\n\n        if (!enumerationExists(tokenId)) {\n            enumerateToken(msg.sender, tokenId);\n        }\n    }    \n\n    /// @notice max supply of tokens allowed\n    function maxSupply() external view returns (uint256) {\n        return getMaxSupply();\n    }       \n\n    function encodedTokenURI(uint256 tokenId) public view returns (string memory) {                \n        bytes memory dataURI = abi.encodePacked(\n            '{',\n                '\"name\": \"Horde OSM Pass #', tokenId.toString(),\n                '\",\"description\": \"',string(renderings.getDescription()),'\"', \n                ',\"image\":\"',string(renderings.getImage()),'\"',\n                ',\"external_url\":\"https://osm.tools\"',\n                ',\"attributes\":', string(renderings.getAttributes()),\n            '}'\n        );\n\n        return string(\n            abi.encodePacked(\n                \"data:application/json;base64,\",\n                Base64.encode(dataURI)\n            )\n        );\n    }  \n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {        \n        return encodedTokenURI(tokenId);\n    }       \n\n}\n\n/**\n * Ordo Signum Machina - 2023\n */"

    },

    "contracts/OSM/Ownable.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable {\n    address private _owner;\n\n    error CallerIsNotOwner(address caller);\n    error OwnerCannotBeZeroAddress();\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(msg.sender);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != msg.sender) {\n            revert CallerIsNotOwner(msg.sender);\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if(newOwner == address(0)) {\n            revert OwnerCannotBeZeroAddress();\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    \n}\n"

    },

    "contracts/OSM/OwnerEnumerable.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\nimport { SetOwnerEnumerable, OwnerEnumerableData, TokenNonOwner, InvalidOwner, TokenOwnership } from \"./SetOwnerEnumerable.sol\";\nimport { PackableOwnership } from \"./PackableOwnership.sol\";\n\n\nabstract contract OwnerEnumerable is PackableOwnership {  \n    using SetOwnerEnumerable for OwnerEnumerableData;\n    OwnerEnumerableData enumerable;      \n\n\n\n    function tokensOwnedBy(address holder) public view returns (uint256[] memory) {\n        uint256[] memory empty;        \n        if (enumerable.isOwnerEnumerated(holder)) {\n            return enumerable.findTokensOwned(holder);\n        } \n        return empty;\n    }\n\n    function enumeratedBalanceOf(address owner) public view virtual returns (uint256) {\n        validateNonZeroAddress(owner);\n        return enumerable.ownedTokens[owner].length;\n    }   \n\n    function validateNonZeroAddress(address owner) internal pure {\n        if(owner == address(0)) {\n            revert InvalidOwner();\n        }\n    }\n    \n    function enumerateToken(address to, uint256 tokenId) internal {\n        enumerable.addTokenToEnumeration(to, tokenId);\n    }\n\n    function enumerateMint(address to, uint256 quantity) internal returns (uint256) {\n        uint256 start = minted()+1;\n        uint256 end = packedMint(to,quantity);\n        for (uint256 i = start; i <= end; i++) {\n            enumerateToken(to, i);\n        }\n        return end;\n    }\n\n    function enumerateBurn(address from, uint256 tokenId) internal {\n        enumerable.addBurnToEnumeration(from, tokenId);\n        enumerable.removeTokenFromEnumeration(from, tokenId);\n    }\n\n    function swapOwner(address from, address to, uint256 tokenId) internal {\n        enumerable.removeTokenFromEnumeration(from, tokenId);\n        enumerable.addTokenToEnumeration(to, tokenId);\n    }\n    \n    function enumerationExists(uint256 tokenId) internal view virtual returns (bool) {\n        return enumerable.tokens[tokenId].exists;\n    }    \n\n    function selfDestruct(uint256 tokenId) internal {\n        delete enumerable.tokens[tokenId];\n    }    \n}"

    },

    "contracts/OSM/PackableOwnership.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\nimport { FlexibleMetadata } from \"./FlexibleMetadata.sol\";\nimport { PackableData, SetPackable } from \"./SetPackable.sol\";\n\n\nstruct TokenApproval {\n    address approval;\n    bool exists;\n}\n\nabstract contract PackableOwnership is FlexibleMetadata {\n    using SetPackable for PackableData;\n    PackableData packable;\n\n    constructor() {\n        packable._currentIndex = packable._startTokenId();     \n    } \n     \n\n\n    function numberMinted(address minter) public view returns (uint256) {\n        return packable._numberMinted(minter);\n    }\n\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        return packable.ownerOf(tokenId);\n    }\n\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        return packable.balanceOf(owner);\n    }         \n       \n    function totalSupply() public view virtual returns (uint256) {\n        return packable.totalSupply();\n    }    \n       \n    function minted() internal view virtual returns (uint256) {\n        return packable._currentIndex;\n    }\n    function exists(uint256 tokenId) internal view virtual returns (bool) {\n        return packable._exists(tokenId);\n    }\n    function packedTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal {\n        packable.transferFrom(from,to,tokenId);\n    }\n    function packedMint(address to, uint256 quantity) internal returns (uint256) {\n        return packable._mint(to,quantity);\n    }\n    function packedBurn(uint256 tokenId) internal  {\n        packable._burn(tokenId);\n    }\n    /**\n     * Returns the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\n     */\n    // function getAux(address owner) public view returns (uint32[2] memory) {\n    //     return packable.unpack64(packable._getAux(owner));\n    // }\n\n    function getAux16(address owner) internal view returns (uint16[4] memory) {\n        return packable.getAux16(owner);\n    }    \n    // function getAux8(address owner) public view returns (uint8[8] memory) {\n\n    //     uint32[2] memory pack32 = packable.unpack64(packable._getAux(owner));\n        \n    //     uint16[2] memory pack16a = packable.unpack32(pack32[0]);\n        \n    //     uint8[2] memory pack8a1 = packable.unpack16(pack16a[0]);\n    //     uint8[2] memory pack8a2 = packable.unpack16(pack16a[1]);\n        \n    //     uint16[2] memory pack16b = packable.unpack32(pack32[1]);\n        \n    //     uint8[2] memory pack8b1 = packable.unpack16(pack16b[0]);\n    //     uint8[2] memory pack8b2 = packable.unpack16(pack16b[1]);\n\n    //     return [pack8a1[0],pack8a1[1],pack8a2[0],pack8a2[1],pack8b1[0],pack8b1[1],pack8b2[0],pack8b2[1]];\n    // }    \n\n    /**\n     * Sets the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\n     * If there are multiple variables, please pack them into a uint64.\n     */\n    // function setAux(address owner, uint32[2] memory aux) internal {\n    //     packable._setAux(owner,packable.pack64(aux[0],aux[1]));\n    // }    \n\n    function setAux32(address owner, uint16[4] memory aux) internal {\n        packable._setAux(owner,packable.pack64(packable.pack32(aux[0],aux[1]),packable.pack32(aux[2],aux[3])));\n    }       \n    \n    // function setAux16(address owner, uint8[8] memory aux) internal {\n    //     packable._setAux(owner,packable.pack64(\n    //         packable.pack32(\n    //             packable.pack16(aux[0],aux[1]),\n    //             packable.pack16(aux[2],aux[3])\n    //         ),\n    //         packable.pack32(\n    //             packable.pack16(aux[4],aux[5]),\n    //             packable.pack16(aux[6],aux[7])\n    //         )\n    //     ));\n    // }        \n\n}\n"

    },

    "contracts/OSM/Phaseable.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\nimport { SetPhaseable, PhaseableData, MintIsNotAllowedRightNow, ExceedsMaxSupply, Phase } from \"./SetPhaseable.sol\";\nimport { OwnerEnumerable } from \"./OwnerEnumerable.sol\";\nimport \"./Mintable.sol\";\n\n\nabstract contract Phaseable is Mintable {  \n    using SetPhaseable for PhaseableData;\n    PhaseableData phaseables;    \n    \n    function canMint(uint64 phase, uint256 quantity) internal virtual returns(bool);\n\n    function initialize(Phase[] storage phases, uint256 maxSupply) internal {\n        phaseables.initialize(phases,maxSupply);\n    }\n\n    function phasedMint(uint64 phase, uint256 quantity, bool enumerate) internal returns (uint256) {\n        if (!canMint(phase, quantity)) {\n            revert MintIsNotAllowedRightNow();\n        }        \n        if (minted()+quantity > phaseables.getMaxSupply()) {\n            revert ExceedsMaxSupply();\n        }        \n        return _mint(msg.sender,quantity,enumerate);        \n    }\n\n    function airdrop(address recipient, uint256 quantity, bool enumerate) public onlyOwner {        \n        if (minted()+quantity > phaseables.getMaxSupply()) {\n            revert ExceedsMaxSupply();\n        }\n        _mint(recipient,quantity, enumerate);\n    }\n\n    function activePhase() internal view returns (uint64) {\n        return phaseables.getActivePhase();\n    }\n\n    function nextPhase() public onlyOwner {\n        phaseables.startNextPhase();\n    }\n\n    function previousPhase() public onlyOwner {\n        phaseables.revertPhase();\n    }    \n\n    function getPhases() internal view returns (Phase[] storage) {\n        return phaseables.getPhases();\n    }\n\n    function findPhase(uint256 phaseId) internal view returns (Phase memory) {\n        return phaseables.findPhase(phaseId);\n    }\n\n    function updatePhase(uint256 phaseId, Phase memory phase) internal {\n        Phase[] storage existing = phaseables.getPhases();\n        existing[phaseId] = phase;\n    }    \n\n    function getMaxSupply() internal view returns (uint256) {\n        return phaseables.getMaxSupply();\n    }  \n\n    function setMaxSupply(uint256 newMax) internal {\n        phaseables.setMaxSupply(newMax);\n    }    \n\n}"

    },

    "contracts/OSM/SetApprovable.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nstruct ApprovableData { \n\n    mapping(address => uint256) contractApprovals;\n    mapping(address => address[]) approvedForAll;\n    mapping(address => mapping(address => uint256)) approvedForAllIndex;\n\n    mapping(uint256 => uint256) tokenApprovals;\n    mapping(uint256 => TokenApproval[]) approvedForToken;\n    mapping(uint256 => mapping(address => uint256)) approvedForTokenIndex;\n\n    mapping(uint256 => TokenApproval) tokens;\n\n    bool exists;\n}    \n\nstruct TokenApproval {\n    address approval;\n    bool exists;\n}\n\nerror AlreadyApproved(address operator, uint256 tokenId);\nerror AlreadyApprovedContract(address operator);\nerror AlreadyRevoked(address operator, uint256 tokenId);\nerror AlreadyRevokedContract(address operator);\nerror TokenNonExistent(uint256 tokenId);\n\n\nlibrary SetApprovable {     \n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);    \n\n    function isApprovedForAll(ApprovableData storage self, address owner, address operator) public view returns (bool) {        \n        return self.approvedForAll[owner].length > self.approvedForAllIndex[owner][operator] ? \n            (self.approvedForAll[owner][self.approvedForAllIndex[owner][operator]] != address(0)) :\n            false;\n    }   \n\n    function revokeApprovals(ApprovableData storage self, address owner, uint256[] memory ownedTokens) public {            \n        \n        for (uint256 i = 0; i < ownedTokens.length; i++) {\n            revokeTokenApproval(self,ownedTokens[i]);\n        }\n        \n        address[] memory contractApprovals = self.approvedForAll[owner];\n        for (uint256 i = 0; i < contractApprovals.length; i++) {\n            address approved = contractApprovals[i];    \n            revokeApprovalForContract(self, approved, owner);             \n        }\n    }   \n\n    function revokeTokenApproval(ApprovableData storage self, uint256 token) public {            \n        TokenApproval[] memory approvals = self.approvedForToken[token];\n        for (uint256 j = 0; j < approvals.length; j++) {\n            revokeApprovalForToken(self, approvals[j].approval, token);\n        }         \n    }       \n\n    function getApproved(ApprovableData storage self, uint256 tokenId) public view returns (address) {\n        return self.approvedForToken[tokenId].length > 0 ? self.approvedForToken[tokenId][0].approval : address(0);\n    }     \n\n    function approveForToken(ApprovableData storage self, address operator, uint256 tokenId) public {\n        uint256 index = self.approvedForTokenIndex[tokenId][operator];\n        if (index < self.approvedForToken[tokenId].length) {\n            if (self.approvedForToken[tokenId][index].exists) {\n                revert AlreadyApproved(operator, tokenId);\n            }            \n        }\n   \n        self.approvedForToken[tokenId].push(TokenApproval(operator,true));\n        self.approvedForTokenIndex[tokenId][operator] = self.approvedForToken[tokenId].length-1;\n        self.tokenApprovals[tokenId]++;\n        \n        emit Approval(msg.sender, operator, tokenId); \n    } \n\n    function revokeApprovalForToken(ApprovableData storage self, address revoked, uint256 tokenId) public {\n        uint256 index = self.approvedForTokenIndex[tokenId][revoked];\n        if (!self.approvedForToken[tokenId][index].exists) {\n            revert AlreadyRevoked(revoked,tokenId);\n        }\n        \n        // When the token to delete is not the last token, the swap operation is unnecessary\n        if (index != self.approvedForToken[tokenId].length - 1) {\n            TokenApproval storage tmp = self.approvedForToken[tokenId][self.approvedForToken[tokenId].length - 1];\n            self.approvedForToken[tokenId][self.approvedForToken[tokenId].length - 1] = self.approvedForToken[tokenId][index];\n            self.approvedForToken[tokenId][index] = tmp;\n            self.approvedForTokenIndex[tokenId][tmp.approval] = index;            \n        }\n\n        // This also deletes the contents at the last position of the array\n        delete self.approvedForTokenIndex[tokenId][revoked];\n        self.approvedForToken[tokenId].pop();\n\n        self.tokenApprovals[tokenId]--;\n    }\n\n    function approveForContract(ApprovableData storage self, address operator) public {\n        uint256 index = self.approvedForAllIndex[msg.sender][operator];\n        if (self.approvedForAll[msg.sender].length > index) {\n            if (self.approvedForAll[msg.sender][index] != address(0)) {\n                revert AlreadyApprovedContract(self.approvedForAll[msg.sender][index]);\n            }\n        }\n   \n        self.approvedForAll[msg.sender].push(operator);\n        self.approvedForAllIndex[msg.sender][operator] = self.approvedForAll[msg.sender].length-1;\n        self.contractApprovals[msg.sender]++;\n\n        emit ApprovalForAll(msg.sender, operator, true); \n    } \n\n    function revokeApprovalForContract(ApprovableData storage self, address revoked, address owner) public {\n        uint256 index = self.approvedForAllIndex[owner][revoked];\n        address revokee = self.approvedForAll[owner][index];\n        if (revokee != revoked) {\n            revert AlreadyRevokedContract(revoked);\n        }\n        \n        // When the token to delete is not the last token, the swap operation is unnecessary\n        if (index != self.approvedForAll[owner].length - 1) {\n            address tmp = self.approvedForAll[owner][self.approvedForAll[owner].length - 1];\n            self.approvedForAll[owner][self.approvedForAll[owner].length - 1] = self.approvedForAll[owner][index];\n            self.approvedForAll[owner][index] = tmp;\n            self.approvedForAllIndex[owner][tmp] = index;            \n        }\n        // This also deletes the contents at the last position of the array\n        delete self.approvedForAllIndex[owner][revoked];\n        self.approvedForAll[owner].pop();\n\n        self.contractApprovals[owner]--;\n\n        emit ApprovalForAll(owner, revoked, false); \n    }    \n\n}"

    },

    "contracts/OSM/SetAssignable.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\nstruct AssignableData { \n    mapping(uint256 => address[]) assignments;\n\n    mapping(address => mapping(uint256 => uint256)) assignmentIndex; \n\n    mapping(address => uint256) assigned;\n}    \n\nerror AlreadyAssigned(uint256 tokenId);\nerror NotAssigned(address to);\nerror NotTokenOwner();\n\ninterface Supportable {\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n    function balanceOf(address owner) external view returns (uint256);\n    function ownerOf(uint256 tokenId) external view returns (address);\n    function balanceOf(address owner, uint256 tokenId) external view returns (uint256);\n}\n\nlibrary SetAssignable {\n\n    function findAssignees(AssignableData storage self, uint256 tokenId) public view returns (address[] memory) {\n        return self.assignments[tokenId];\n    }\n\n    function revokeAll(AssignableData storage self, uint256 tokenId) public {        \n        for (uint256 iterator = 0; iterator < self.assignments[tokenId].length; iterator++) {\n            address target = self.assignments[tokenId][iterator];\n            delete self.assignmentIndex[target][tokenId];\n            delete self.assigned[target];\n        }\n        while ( self.assignments[tokenId].length > 0) {\n            self.assignments[tokenId].pop();\n        }        \n    }\n\n    function iterateGuardiansBalance(AssignableData storage self, uint256[] memory guardians, address seeking, uint256 tokenId) public view returns (uint256)  {\n        uint256 balance = 0;\n        for (uint256 iterator = 0; iterator < guardians.length; iterator++) {\n            uint256 guardian = guardians[iterator];\n            balance += iterateAssignmentsBalance(self,guardian,seeking,tokenId);\n        }\n        return balance;\n    }\n\n    function iterateAssignmentsBalance(AssignableData storage self, uint256 guardian, address seeking, uint256 tokenId) public view returns (uint256)  {\n        uint256 balance = 0;\n        for (uint256 iterator = 0; iterator < self.assignments[guardian].length; iterator++) {\n            address assignment =self.assignments[guardian][iterator];\n            Supportable supporting = Supportable(seeking);\n            if (supporting.supportsInterface(type(IERC721).interfaceId)) {\n                balance += supporting.balanceOf(assignment); \n            }            \n            if (supporting.supportsInterface(type(IERC1155).interfaceId)) {\n                balance += supporting.balanceOf(assignment, tokenId); \n            }               \n        }       \n        return balance; \n    } \n\n    function addAssignment(AssignableData storage self, address to, uint256 tokenId) public {\n        uint256 assigned = findAssignment(self, to);\n        if (assigned > 0) {\n            revert AlreadyAssigned(assigned);\n        }\n        \n        self.assignments[tokenId].push(to);     \n        uint256 length = self.assignments[tokenId].length;\n        self.assignmentIndex[to][tokenId] = length-1;\n        self.assigned[to] = tokenId;\n    }    \n\n    function removeAssignment(AssignableData storage self, address to) public {\n        uint256 assigned = findAssignment(self, to);\n        if (assigned > 0) {\n            uint256 existingAddressIndex = self.assignmentIndex[to][assigned];\n            uint256 lastAssignmentIndex = self.assignments[assigned].length-1;\n            \n            if (existingAddressIndex != lastAssignmentIndex) {\n                address lastAssignment = self.assignments[assigned][lastAssignmentIndex];\n                self.assignments[assigned][existingAddressIndex] = lastAssignment; \n                self.assignmentIndex[lastAssignment][assigned] = existingAddressIndex;\n            }\n            delete self.assignmentIndex[to][assigned];\n            self.assignments[assigned].pop();\n        } else {\n            revert NotAssigned(to);\n        }\n    }\n\n    function findAssignment(AssignableData storage self, address to) public view returns (uint256) {\n        return self.assigned[to];\n    }     \n}"

    },

    "contracts/OSM/SetFlexibleMetadata.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nstruct FlexibleMetadataData { \n    string defaultTokenMetadata;\n    string prerevealTokenMetadata;\n    string flaggedTokenMetadata;\n    mapping(uint256 => string) supplementalTokenMetadata;\n    string contractMetadata;\n    mapping(uint256 => bool) tokenFlag;\n    mapping(uint256 => Supplement) supplemental;\n    bool tokenReveal; \n}    \nstruct Supplement {\n    uint256 key;\n    bool exists;\n}\nbytes16 constant _SYMBOLS = \"0123456789abcdef\";\nuint256 constant DEFAULT = 1;\nuint256 constant FLAG = 2;\nuint256 constant PRE = 3;\nlibrary SetFlexibleMetadata {\n    function setDefaultTokenMetadataURI(FlexibleMetadataData storage self, string memory uri) public {\n        self.defaultTokenMetadata = uri;\n    }  \n    function setPrerevealTokenMetadataURI(FlexibleMetadataData storage self, string memory uri) public {\n        self.prerevealTokenMetadata = uri;\n    }  \n    function setFlaggedTokenMetadataURI(FlexibleMetadataData storage self, string memory uri) public {\n        self.flaggedTokenMetadata = uri;\n    }  \n    function setSupplementalTokenMetadataURI(FlexibleMetadataData storage self, uint256 key, string memory uri) public {\n        self.supplementalTokenMetadata[key] = uri;\n    }      \n    function setContractMetadataURI(FlexibleMetadataData storage self, string memory uri) public {\n        self.contractMetadata = uri;\n    }  \n    function reveal(FlexibleMetadataData storage self, bool revealed) public {\n        self.tokenReveal = revealed;\n    }\n\n    function flagToken(FlexibleMetadataData storage self, uint256 tokenId, bool flagged) public {\n        self.tokenFlag[tokenId] = flagged;\n    }\n\n    function getTokenMetadata(FlexibleMetadataData storage self, uint256 tokenId) public view returns (string memory) {\n        if (self.tokenFlag[tokenId]) {\n            return encodeURI(self.flaggedTokenMetadata,tokenId);\n        } \n        if (!self.tokenReveal) {\n            return encodeURI(self.prerevealTokenMetadata,tokenId);\n        }\n        if (self.supplemental[tokenId].exists) {\n            return encodeURI(self.supplementalTokenMetadata[self.supplemental[tokenId].key],tokenId);\n        }\n        return encodeURI(self.defaultTokenMetadata,tokenId);\n    }\n\n    function getContractMetadata(FlexibleMetadataData storage self) public view returns (string memory) { \n        return self.contractMetadata;\n    }    \n\n    function encodeURI(string storage uri, uint256 tokenId) public pure returns (string memory) {\n        return string(abi.encodePacked(uri, \"/\", toString(tokenId)));\n    }\n\n    function toString(uint256 value) public pure returns (string memory) {\n        unchecked {\n            uint256 length = log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    function log10(uint256 value) public pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }        \n}"

    },

    "contracts/OSM/SetLockable.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport { InvalidOwner } from \"./SetOwnerEnumerable.sol\";\nstruct LockableData { \n\n    mapping(address => uint256) lockableStatusIndex; \n\n    mapping(address => LockableStatus) lockableStatus;  \n} \n\n\n\n\nstruct LockableStatus {\n    bool isLocked;\n    uint256 lockedAt;\n    address custodian;\n    uint256 balance;\n    address[] approvedAll;\n    bool exists;\n}\n\nuint64 constant MAX_INT = 2**64 - 1;\n\nerror OnlyCustodianCanLock();\n\nerror OnlyOwnerCanSetCustodian();\n\nerror WalletLockedByOwner();\n\nerror InvalidTransferRecipient();\n\nerror NotApprovedOrOwner();\n\nerror ContractIsNot721Receiver();\n\nlibrary SetLockable {           \n\n    function lockWallet(LockableData storage self, address holder) public {\n        LockableStatus storage status = self.lockableStatus[holder];    \n        if (msg.sender != status.custodian) {\n            revert OnlyCustodianCanLock();\n        }       \n        status.isLocked = true;\n        status.lockedAt = block.timestamp;\n    }\n\n    function unlockWallet(LockableData storage self, address holder) public {        \n        LockableStatus storage status = self.lockableStatus[holder];\n        if (msg.sender != status.custodian) {\n            revert OnlyCustodianCanLock();\n        }                   \n        \n        status.isLocked = false;\n        status.lockedAt = MAX_INT;\n    }\n\n    function setCustodian(LockableData storage self, address custodianAddress,  address holder) public {\n        if (msg.sender != holder) {\n            revert OnlyOwnerCanSetCustodian();\n        }    \n        LockableStatus storage status = self.lockableStatus[holder];\n        status.custodian = custodianAddress;\n    }\n\n    function findCustodian(LockableData storage self, address wallet) public view returns (address) {\n        return self.lockableStatus[wallet].custodian;\n    }\n\n    function forceUnlock(LockableData storage self, address owner) public {        \n        LockableStatus storage status = self.lockableStatus[owner];\n        status.isLocked = false;\n        status.lockedAt = MAX_INT;\n    }\n            \n}"

    },

    "contracts/OSM/SetMetadataRenderable.sol": {

      "content": " \n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nbytes constant description = abi.encodePacked(\"The OSM Pass is your key to osm tools for web3, a soul bound token brought to you by Horde AI\");\nbytes constant attributes = abi.encodePacked('[{\"value\": \"Horde of the Undead\"},{\"value\": \"OSM\"},{\"value\": \"Soulbound\"}]');\n    \nbytes constant b64image = abi.encodePacked('ipfs://QmWs7stQWDjZpaAH3kr7ALviabd4UbhFSShELhFNHvkjjv');\n\nstruct RenderableData {\n    bytes data;\n}\nlibrary SetMetadataRenderable {\n    function getDescription(RenderableData storage) public pure returns (bytes memory) {\n        return description;\n    }\n    function getAttributes(RenderableData storage) public pure returns (bytes memory) {\n        return attributes;\n    }    \n    function getImage(RenderableData storage) public pure returns (bytes memory)  {\n        return b64image;\n    }\n    \n}  "

    },

    "contracts/OSM/SetOwnerEnumerable.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nstruct OwnerEnumerableData { \n    mapping(uint256 => TokenOwnership) tokens;\n\n    mapping(address => bool) ownerEnumerated;\n    \n    mapping(address => uint256[]) ownedTokens;\n\n    mapping(address => mapping(uint256 => uint256)) ownedTokensIndex; \n\n    mapping(address => uint256[]) burnedTokens;\n\n    mapping(address => mapping(uint256 => uint256)) burnedTokensIndex; \n} \n\n\n\nstruct TokenOwnership {\n    address ownedBy;\n    bool exists;\n}\n\nerror TokenNonOwner(address requester, uint256 tokenId); \nerror InvalidOwner();\n\nlibrary SetOwnerEnumerable {\n    function addTokenToEnumeration(OwnerEnumerableData storage self, address to, uint256 tokenId) public {       \n        self.ownedTokens[to].push(tokenId);        \n        uint256 length = self.ownedTokens[to].length;\n        self.ownedTokensIndex[to][tokenId] = length-1;\n        self.tokens[tokenId] = TokenOwnership(to,true);\n        self.ownerEnumerated[to] = true;\n    }\n\n    function addBurnToEnumeration(OwnerEnumerableData storage self, address to, uint256 tokenId) public {       \n        self.burnedTokens[to].push(tokenId);        \n        uint256 length = self.burnedTokens[to].length;\n        self.burnedTokensIndex[to][tokenId] = length-1;        \n    }    \n\n    function removeTokenFromEnumeration(OwnerEnumerableData storage self, address to, uint256 tokenId) public {\n\n        uint256 length = self.ownedTokens[to].length;\n        if (self.ownedTokensIndex[to][tokenId] > 0) {\n            if (self.ownedTokensIndex[to][tokenId] != length - 1) {\n                uint256 lastTokenId = self.ownedTokens[to][length - 1];\n                self.ownedTokens[to][self.ownedTokensIndex[to][tokenId]] = lastTokenId; \n                self.ownedTokensIndex[to][lastTokenId] = self.ownedTokensIndex[to][tokenId];\n            }\n        }\n\n        delete self.ownedTokensIndex[to][tokenId];\n        if (self.ownedTokens[to].length > 0) {\n            self.ownedTokens[to].pop();\n        }\n    }    \n\n    function isOwnerEnumerated(OwnerEnumerableData storage self, address wallet) public view returns (bool) {        \n        return self.ownerEnumerated[wallet];\n    }  \n    \n    function findTokensOwned(OwnerEnumerableData storage self, address wallet) public view returns (uint256[] storage) {        \n        return self.ownedTokens[wallet];\n    }  \n\n    function tokenIndex(OwnerEnumerableData storage self, address wallet, uint256 index) public view returns (uint256) {\n        return self.ownedTokens[wallet][index];\n    }    \n\n    function ownerOf(OwnerEnumerableData storage self, uint256 tokenId) public view returns (address) {\n        address owner = self.tokens[tokenId].ownedBy;\n        if (owner == address(0)) {\n            revert TokenNonOwner(owner,tokenId);\n        }\n        return owner;\n    }      \n}"

    },

    "contracts/OSM/SetPackable.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n\n/**\n    * The caller must own the token or be an approved operator.\n    */\nerror ApprovalCallerNotOwnerNorApproved();\n\n/**\n    * The token does not exist.\n    */\nerror ApprovalQueryForNonexistentToken();\n\n/**\n    * Cannot query the balance for the zero address.\n    */\nerror BalanceQueryForZeroAddress();\n\n/**\n    * Cannot mint to the zero address.\n    */\nerror MintToZeroAddress();\n\n/**\n    * The quantity of tokens minted must be more than zero.\n    */\nerror MintZeroQuantity();\n\n/**\n    * The token does not exist.\n    */\nerror OwnerQueryForNonexistentToken();\n\n/**\n    * The caller must own the token or be an approved operator.\n    */\nerror TransferCallerNotOwnerNorApproved();\n\n/**\n    * The token must be owned by `from`.\n    */\nerror TransferFromIncorrectOwner();\n\n/**\n    * Cannot safely transfer to a contract that does not implement the\n    * ERC721Receiver interface.\n    */\nerror TransferToNonERC721ReceiverImplementer();\n\n/**\n    * Cannot transfer to the zero address.\n    */\nerror TransferToZeroAddress();\n\n/**\n    * The token does not exist.\n    */\nerror URIQueryForNonexistentToken();\n\n/**\n    * The `quantity` minted with ERC2309 exceeds the safety limit.\n    */\nerror MintERC2309QuantityExceedsLimit();\n\n/**\n    * The `extraData` cannot be set on an unintialized ownership slot.\n    */\nerror OwnershipNotInitializedForExtraData();\n\n// =============================================================\n//                            STRUCTS\n// =============================================================\n\nstruct TokenOwnership {\n    // The address of the owner.\n    address addr;\n    // Stores the start time of ownership with minimal overhead for tokenomics.\n    uint64 startTimestamp;\n    // Whether the token has been burned.\n    bool burned;\n    // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\n    uint24 extraData;\n}    \n\n\nstruct DualAuxData {\n    uint32 data1;\n    uint32 data2;\n}\n\nstruct QuadAuxData {\n    uint16 data1;\n    uint16 data2;\n    uint16 data3;\n    uint16 data4;\n}\nstruct OctAuxData {\n    uint8 data1;\n    uint8 data2;\n    uint8 data3;\n    uint8 data4;\n    uint8 data5;\n    uint8 data6;\n    uint8 data7;\n    uint8 data8;\n}\n\n// Mapping from token ID to ownership details\n// An empty struct value does not necessarily mean the token is unowned.\n// See {_packedOwnershipOf} implementation for details.\n//\n// Bits Layout:\n// - [0..159]   `addr`\n// - [160..223] `startTimestamp`\n// - [224]      `burned`\n// - [225]      `nextInitialized`\n// - [232..255] `extraData`\n\n// Mapping owner address to address data.\n//\n// Bits Layout:\n// - [0..63]    `balance`\n// - [64..127]  `numberMinted`\n// - [128..191] `numberBurned`\n// - [192..255] `aux`\nstruct PackableData {\n    mapping(uint256 => uint256) _packedOwnerships;\n    mapping(address => uint256) _packedAddressData;\n    uint256 _currentIndex;\n    uint256 _burnCounter;\n}\n\nlibrary SetPackable {\n\n    \n\n    // =============================================================\n    //                           CONSTANTS\n    // =============================================================\n\n    // Mask of an entry in packed address data.\n    uint256 private constant _BITMASK_ADDRESS_DATA_ENTRY = (1 << 64) - 1;\n\n    // The bit position of `numberMinted` in packed address data.\n    uint256 private constant _BITPOS_NUMBER_MINTED = 64;\n\n    // The bit position of `numberBurned` in packed address data.\n    uint256 private constant _BITPOS_NUMBER_BURNED = 128;\n\n    // The bit position of `aux` in packed address data.\n    uint256 private constant _BITPOS_AUX = 192;\n\n    // Mask of all 256 bits in packed address data except the 64 bits for `aux`.\n    uint256 private constant _BITMASK_AUX_COMPLEMENT = (1 << 192) - 1;\n\n    // The bit position of `startTimestamp` in packed ownership.\n    uint256 private constant _BITPOS_START_TIMESTAMP = 160;\n\n    // The bit mask of the `burned` bit in packed ownership.\n    uint256 private constant _BITMASK_BURNED = 1 << 224;\n\n    // The bit position of the `nextInitialized` bit in packed ownership.\n    uint256 private constant _BITPOS_NEXT_INITIALIZED = 225;\n\n    // The bit mask of the `nextInitialized` bit in packed ownership.\n    uint256 private constant _BITMASK_NEXT_INITIALIZED = 1 << 225;\n\n    // The bit position of `extraData` in packed ownership.\n    uint256 private constant _BITPOS_EXTRA_DATA = 232;\n\n    // Mask of all 256 bits in a packed ownership except the 24 bits for `extraData`.\n    uint256 private constant _BITMASK_EXTRA_DATA_COMPLEMENT = (1 << 232) - 1;\n\n    // The mask of the lower 160 bits for addresses.\n    uint256 private constant _BITMASK_ADDRESS = (1 << 160) - 1;\n\n    // The maximum `quantity` that can be minted with {_mintERC2309}.\n    // This limit is to prevent overflows on the address data entries.\n    // For a limit of 5000, a total of 3.689e15 calls to {_mintERC2309}\n    // is required to cause an overflow, which is unrealistic.\n    uint256 private constant _MAX_MINT_ERC2309_QUANTITY_LIMIT = 5000;\n\n    // The `Transfer` event signature is given by:\n    // `keccak256(bytes(\"Transfer(address,address,uint256)\"))`.\n    bytes32 private constant _TRANSFER_EVENT_SIGNATURE =\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\n\n\n    // =============================================================\n    //                    ADDRESS DATA OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Returns the number of tokens in `owner`'s account.\n     */\n    function balanceOf(PackableData storage self, address owner) public view returns (uint256) {\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\n        return self._packedAddressData[owner] & _BITMASK_ADDRESS_DATA_ENTRY;\n    }\n\n    /**\n     * Returns the number of tokens minted by `owner`.\n     */\n    function _numberMinted(PackableData storage self,address owner) public view returns (uint256) {\n        return (self._packedAddressData[owner] >> _BITPOS_NUMBER_MINTED) & _BITMASK_ADDRESS_DATA_ENTRY;\n    }\n\n    /**\n     * Returns the number of tokens burned by or on behalf of `owner`.\n     */\n    function _numberBurned(PackableData storage self,address owner) public view returns (uint256) {\n        return (self._packedAddressData[owner] >> _BITPOS_NUMBER_BURNED) & _BITMASK_ADDRESS_DATA_ENTRY;\n    }\n\n    /**\n     * Returns the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\n     */\n    function _getAux(PackableData storage self,address owner) public view returns (uint64 aux) {\n        return uint64(self._packedAddressData[owner] >> _BITPOS_AUX);\n    }\n\n    /**\n     * Sets the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).\n     * If there are multiple variables, please pack them into a uint64.\n     */\n    function _setAux(PackableData storage self, address owner, uint64 aux) public {\n        uint256 packed = self._packedAddressData[owner];\n        uint256 auxCasted;\n        // Cast `aux` with assembly to avoid redundant masking.\n        assembly {\n            auxCasted := aux\n        }\n        packed = (packed & _BITMASK_AUX_COMPLEMENT) | (auxCasted << _BITPOS_AUX);\n        self._packedAddressData[owner] = packed;\n    }\n\n    function getAux16(PackableData storage self, address owner) internal view returns (uint16[4] memory) {\n        \n        uint32[2] memory packed32 = unpack64(self,_getAux(self,owner));\n        uint16[2] memory pack16a = unpack32(self,packed32[0]);\n        uint16[2] memory pack16b = unpack32(self,packed32[1]);\n        \n        return [pack16a[0],pack16a[1],pack16b[0],pack16b[1]];\n    }   \n\n    function pack16(PackableData storage, uint8 pack1, uint8 pack2) public pure returns (uint16) {\n        return (uint16(pack2) << 8) | pack1;\n    }\n\n    function pack32(PackableData storage, uint16 pack1, uint16 pack2) public pure returns (uint32) {\n        return (uint32(pack2) << 16) | pack1;\n    }    \n\n    function pack64(PackableData storage, uint32 pack1, uint32 pack2) public pure returns (uint64) {\n        return (uint64(pack2) << 32) | pack1;\n    }        \n\n    function unpack64(PackableData storage, uint64 packed) public pure returns (uint32[2] memory unpacked){\n        uint32 pack2 = uint32(packed >> 32); \n        uint32 pack1 = uint32(packed);       \n        return [pack1, pack2];\n    }       \n\n    function unpack32(PackableData storage, uint32 packed) public pure returns (uint16[2] memory unpacked){\n        uint16 pack2 = uint16(packed >> 16); \n        uint16 pack1 = uint16(packed);       \n        return [pack1, pack2];\n    }        \n\n    function unpack16(PackableData storage, uint16 packed) public pure returns (uint8[2] memory unpacked){\n        uint8 pack2 = uint8(packed >> 8); \n        uint8 pack1 = uint8(packed);       \n        return [pack1, pack2];\n    }    \n\n    // =============================================================\n    //                     OWNERSHIPS OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(PackableData storage self, uint256 tokenId) public view returns (address) {\n        return address(uint160(_packedOwnershipOf(self,tokenId)));\n    }\n\n    /**\n     * @dev Gas spent here starts off proportional to the maximum mint batch size.\n     * It gradually moves to O(1) as tokens get transferred around over time.\n     */\n    function _ownershipOf(PackableData storage self, uint256 tokenId) internal view returns (TokenOwnership memory) {\n        return _unpackedOwnership(_packedOwnershipOf(self,tokenId));\n    }\n\n    /**\n     * @dev Returns the unpacked `TokenOwnership` struct at `index`.\n     */\n    function _ownershipAt(PackableData storage self, uint256 index) internal view returns (TokenOwnership memory) {\n        return _unpackedOwnership(self._packedOwnerships[index]);\n    }\n\n    /**\n     * @dev Initializes the ownership slot minted at `index` for efficiency purposes.\n     */\n    function _initializeOwnershipAt(PackableData storage self, uint256 index) internal {\n        if (self._packedOwnerships[index] == 0) {\n            self._packedOwnerships[index] = _packedOwnershipOf(self,index);\n        }\n    }\n\n    /**\n     * Returns the packed ownership data of `tokenId`.\n     */\n    function _packedOwnershipOf(PackableData storage self, uint256 tokenId) private view returns (uint256) {\n        uint256 curr = tokenId;\n\n        unchecked {\n            if (_startTokenId(self) <= curr)\n                if (curr < self._currentIndex) {\n                    uint256 packed = self._packedOwnerships[curr];\n                    // If not burned.\n                    if (packed & _BITMASK_BURNED == 0) {\n                        // Invariant:\n                        // There will always be an initialized ownership slot\n                        // (i.e. `ownership.addr != address(0) && ownership.burned == false`)\n                        // before an unintialized ownership slot\n                        // (i.e. `ownership.addr == address(0) && ownership.burned == false`)\n                        // Hence, `curr` will not underflow.\n                        //\n                        // We can directly compare the packed value.\n                        // If the address is zero, packed will be zero.\n                        while (packed == 0) {\n                            packed = self._packedOwnerships[--curr];\n                        }\n                        return packed;\n                    }\n                }\n        }\n        revert OwnerQueryForNonexistentToken();\n    }\n\n    /**\n     * @dev Returns the unpacked `TokenOwnership` struct from `packed`.\n     */\n    function _unpackedOwnership(uint256 packed) private pure returns (TokenOwnership memory ownership) {\n        ownership.addr = address(uint160(packed));\n        ownership.startTimestamp = uint64(packed >> _BITPOS_START_TIMESTAMP);\n        ownership.burned = packed & _BITMASK_BURNED != 0;\n        ownership.extraData = uint24(packed >> _BITPOS_EXTRA_DATA);\n    }\n\n    /**\n     * @dev Packs ownership data into a single uint256.\n     */\n    function _packOwnershipData(address owner, uint256 flags) private view returns (uint256 result) {\n        assembly {\n            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.\n            owner := and(owner, _BITMASK_ADDRESS)\n            // `owner | (block.timestamp << _BITPOS_START_TIMESTAMP) | flags`.\n            result := or(owner, or(shl(_BITPOS_START_TIMESTAMP, timestamp()), flags))\n        }\n    }\n\n\n\n    /**\n     * @dev Returns the `nextInitialized` flag set if `quantity` equals 1.\n     */\n    function _nextInitializedFlag(uint256 quantity) private pure returns (uint256 result) {\n        // For branchless setting of the `nextInitialized` flag.\n        assembly {\n            // `(quantity == 1) << _BITPOS_NEXT_INITIALIZED`.\n            result := shl(_BITPOS_NEXT_INITIALIZED, eq(quantity, 1))\n        }\n    }    \n\n    /**\n     * @dev Returns the starting token ID.\n     * To change the starting token ID, please override this function.\n     */\n    function _startTokenId(PackableData storage) internal pure returns (uint256) {\n        return 1;\n    }  \n\n/**\n     * @dev Returns the next token ID to be minted.\n     */\n    function _nextTokenId(PackableData storage self) public view returns (uint256) {\n        return self._currentIndex;\n    }\n\n    /**\n     * @dev Returns the total number of tokens in existence.\n     * Burned tokens will reduce the count.\n     * To get the total number of tokens minted, please see {_totalMinted}.\n     */\n    function totalSupply(PackableData storage self) public view returns (uint256) {\n        // Counter underflow is impossible as _burnCounter cannot be incremented\n        // more than `_currentIndex - _startTokenId()` times.\n        unchecked {\n            return self._currentIndex - self._burnCounter;\n        }\n    }\n\n    /**\n     * @dev Returns the total amount of tokens minted in the contract.\n     */\n    function _totalMinted(PackableData storage self) public view returns (uint256) {\n        // Counter underflow is impossible as `_currentIndex` does not decrement,\n        // and it is initialized to `_startTokenId()`.\n        unchecked {\n            return self._currentIndex;\n        }\n    }\n\n    /**\n     * @dev Returns the total number of tokens burned.\n     */\n    function _totalBurned(PackableData storage self) public view returns (uint256) {\n        return self._burnCounter;\n    }      \n\n/**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted. See {_mint}.\n     */\n    function _exists(PackableData storage self, uint256 tokenId) public view returns (bool) {\n        return\n            _startTokenId(self) <= tokenId &&\n            tokenId < self._currentIndex && // If within bounds,\n            self._packedOwnerships[tokenId] & _BITMASK_BURNED == 0; // and not burned.\n    }\n\n    // =============================================================\n    //                      TRANSFER OPERATIONS\n    // =============================================================\n\n    function transferFrom(\n        PackableData storage self,\n        address from,\n        address to,\n        uint256 tokenId\n    ) public {\n        uint256 prevOwnershipPacked = _packedOwnershipOf(self,tokenId);\n\n        if (address(uint160(prevOwnershipPacked)) != from) revert TransferFromIncorrectOwner();        \n\n        if (to == address(0)) revert TransferToZeroAddress();\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\n        unchecked {\n            // We can directly increment and decrement the balances.\n            --self._packedAddressData[from]; // Updates: `balance -= 1`.\n            ++self._packedAddressData[to]; // Updates: `balance += 1`.\n\n            // Updates:\n            // - `address` to the next owner.\n            // - `startTimestamp` to the timestamp of transfering.\n            // - `burned` to `false`.\n            // - `nextInitialized` to `true`.\n            self._packedOwnerships[tokenId] = _packOwnershipData(\n                to,\n                _BITMASK_NEXT_INITIALIZED | _nextExtraData(from, to, prevOwnershipPacked)\n            );\n\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\n                uint256 nextTokenId = tokenId + 1;\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\n                if (self._packedOwnerships[nextTokenId] == 0) {\n                    // If the next slot is within bounds.\n                    if (nextTokenId != self._currentIndex) {\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\n                        self._packedOwnerships[nextTokenId] = prevOwnershipPacked;\n                    }\n                }\n            }\n        }\n    }\n\n    \n\n    // =============================================================\n    //                        MINT OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Mints `quantity` tokens and transfers them to `to`.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `quantity` must be greater than 0.\n     *\n     * Emits a {Transfer} event for each mint.\n     */\n    function _mint(PackableData storage self, address to, uint256 quantity) public returns (uint256) {\n        uint256 startTokenId = self._currentIndex;\n        if (quantity == 0) revert MintZeroQuantity();        \n\n        // Overflows are incredibly unrealistic.\n        // `balance` and `numberMinted` have a maximum limit of 2**64.\n        // `tokenId` has a maximum limit of 2**256.\n        unchecked {\n            // Updates:\n            // - `balance += quantity`.\n            // - `numberMinted += quantity`.\n            //\n            // We can directly add to the `balance` and `numberMinted`.\n            self._packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);\n\n            // Updates:\n            // - `address` to the owner.\n            // - `startTimestamp` to the timestamp of minting.\n            // - `burned` to `false`.\n            // - `nextInitialized` to `quantity == 1`.\n            self._packedOwnerships[startTokenId] = _packOwnershipData(\n                to,\n                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)\n            );\n\n            uint256 toMasked;\n            uint256 end = startTokenId + quantity;\n\n            // Use assembly to loop and emit the `Transfer` event for gas savings.\n            // The duplicated `log4` removes an extra check and reduces stack juggling.\n            // The assembly, together with the surrounding Solidity code, have been\n            // delicately arranged to nudge the compiler into producing optimized opcodes.\n            assembly {\n                // Mask `to` to the lower 160 bits, in case the upper bits somehow aren't clean.\n                toMasked := and(to, _BITMASK_ADDRESS)\n                // Emit the `Transfer` event.\n                log4(\n                    0, // Start of data (0, since no data).\n                    0, // End of data (0, since no data).\n                    _TRANSFER_EVENT_SIGNATURE, // Signature.\n                    0, // `address(0)`.\n                    toMasked, // `to`.\n                    startTokenId // `tokenId`.\n                )\n\n                // The `iszero(eq(,))` check ensures that large values of `quantity`\n                // that overflows uint256 will make the loop run out of gas.\n                // The compiler will optimize the `iszero` away for performance.\n                for {\n                    let tokenId := add(startTokenId, 1)\n                } iszero(eq(tokenId, end)) {\n                    tokenId := add(tokenId, 1)\n                } {\n                    // Emit the `Transfer` event. Similar to above.\n                    log4(0, 0, _TRANSFER_EVENT_SIGNATURE, 0, toMasked, tokenId)\n                }\n            }\n            if (toMasked == 0) revert MintToZeroAddress();\n\n            self._currentIndex = end;\n        }     \n        return self._currentIndex;\n    }\n\n    \n\n    // =============================================================\n    //                        BURN OPERATIONS\n    // =============================================================\n\n    function _burn(PackableData storage self, uint256 tokenId) public {\n        uint256 prevOwnershipPacked = _packedOwnershipOf(self,tokenId);\n\n        address from = address(uint160(prevOwnershipPacked));\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.\n        unchecked {\n            // Updates:\n            // - `balance -= 1`.\n            // - `numberBurned += 1`.\n            //\n            // We can directly decrement the balance, and increment the number burned.\n            // This is equivalent to `packed -= 1; packed += 1 << _BITPOS_NUMBER_BURNED;`.\n            self._packedAddressData[from] += (1 << _BITPOS_NUMBER_BURNED) - 1;\n\n            // Updates:\n            // - `address` to the last owner.\n            // - `startTimestamp` to the timestamp of burning.\n            // - `burned` to `true`.\n            // - `nextInitialized` to `true`.\n            self._packedOwnerships[tokenId] = _packOwnershipData(\n                from,\n                (_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) | _nextExtraData(from, address(0), prevOwnershipPacked)\n            );\n\n            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .\n            if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {\n                uint256 nextTokenId = tokenId + 1;\n                // If the next slot's address is zero and not burned (i.e. packed value is zero).\n                if (self._packedOwnerships[nextTokenId] == 0) {\n                    // If the next slot is within bounds.\n                    if (nextTokenId != self._currentIndex) {\n                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.\n                        self._packedOwnerships[nextTokenId] = prevOwnershipPacked;\n                    }\n                }\n            }\n        }\n\n        // Overflow not possible, as _burnCounter cannot be exceed _currentIndex times.\n        unchecked {\n            self._burnCounter++;\n        }\n    }\n\n    // =============================================================\n    //                     EXTRA DATA OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Directly sets the extra data for the ownership data `index`.\n     */\n    function _setExtraDataAt(PackableData storage self, uint256 index, uint24 extraData) public {\n        uint256 packed = self._packedOwnerships[index];\n        if (packed == 0) revert OwnershipNotInitializedForExtraData();\n        uint256 extraDataCasted;\n        // Cast `extraData` with assembly to avoid redundant masking.\n        assembly {\n            extraDataCasted := extraData\n        }\n        packed = (packed & _BITMASK_EXTRA_DATA_COMPLEMENT) | (extraDataCasted << _BITPOS_EXTRA_DATA);\n        self._packedOwnerships[index] = packed;\n    }\n\n    /**\n     * @dev Called during each token transfer to set the 24bit `extraData` field.\n     * Intended to be overridden by the cosumer contract.\n     *\n     * `previousExtraData` - the value of `extraData` before transfer.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, `tokenId` will be burned by `from`.\n     * - `from` and `to` are never both zero.\n     */\n    function _extraData(\n        address from,\n        address to,\n        uint24 previousExtraData\n    ) public view returns (uint24) {}\n\n    /**\n     * @dev Returns the next extra data for the packed ownership data.\n     * The returned result is shifted into position.\n     */\n    function _nextExtraData(\n        address from,\n        address to,\n        uint256 prevOwnershipPacked\n    ) private view returns (uint256) {\n        uint24 extraData = uint24(prevOwnershipPacked >> _BITPOS_EXTRA_DATA);\n        return uint256(_extraData(from, to, extraData)) << _BITPOS_EXTRA_DATA;\n    }\n\n    // =============================================================\n    //                       OTHER OPERATIONS\n    // =============================================================\n\n    /**\n     * @dev Converts a uint256 to its ASCII string decimal representation.\n     */\n    function _toString(uint256 value) public pure returns (string memory str) {\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\n            // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.\n            let m := add(mload(0x40), 0xa0)\n            // Update the free memory pointer to allocate.\n            mstore(0x40, m)\n            // Assign the `str` to the end.\n            str := sub(m, 0x20)\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end of the memory to calculate the length later.\n            let end := str\n\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            // prettier-ignore\n            for { let temp := value } 1 {} {\n                str := sub(str, 1)\n                // Write the character to the pointer.\n                // The ASCII index of the '0' character is 48.\n                mstore8(str, add(48, mod(temp, 10)))\n                // Keep dividing `temp` until zero.\n                temp := div(temp, 10)\n                // prettier-ignore\n                if iszero(temp) { break }\n            }\n\n            let length := sub(end, str)\n            // Move the pointer 32 bytes leftwards to make room for the length.\n            str := sub(str, 0x20)\n            // Store the length.\n            mstore(str, length)\n        }\n    }    \n\n}    "

    },

    "contracts/OSM/SetPhaseable.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\nstruct PhaseableData { \n    Phase[] phases;\n    uint64 activePhase;\n    uint256 maxSupply;\n}    \n\nstruct Phase {\n    uint64 name;\n    uint64 maxPerWallet;\n    uint64 highestSupply;\n    uint64 cost;\n}\n\nerror MintIsNotAllowedRightNow();\nerror ExceedsMaxSupply();\nerror PhaseNotActiveYet();\nerror PhaseExhausted();\nerror WalletMintsFilled(uint256 requested);\n\nlibrary SetPhaseable {\n    function initialize(PhaseableData storage self, Phase[] storage phases, uint256 maxSupply) public {\n        self.phases = phases;\n        self.activePhase = 0;\n        self.maxSupply = maxSupply;\n    }\n    function getMaxSupply(PhaseableData storage self) public view returns (uint256) {\n        return self.maxSupply;\n    }\n    function setMaxSupply(PhaseableData storage self, uint256 newMax) public {\n        self.maxSupply = newMax;\n    }\n    function getPhases(PhaseableData storage self) public view returns (Phase[] storage) {\n        return self.phases;\n    }\n    function getActivePhase(PhaseableData storage self) public view returns (uint64) {\n        return self.activePhase;\n    }\n    function findPhase(PhaseableData storage self, uint256 phaseId) public view returns (Phase memory) {\n        return self.phases[phaseId];\n    }\n    function startNextPhase(PhaseableData storage self) public {\n        self.activePhase += 1;\n    }\n    function revertPhase(PhaseableData storage self) public {\n        self.activePhase -= 1;\n    }\n    function addPhase(PhaseableData storage self,Phase calldata nextPhase) public {\n        self.phases.push(nextPhase);\n    }\n}"

    }

  },

  "settings": {

    "optimizer": {

      "enabled": true,

      "runs": 100

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "metadata": {

      "useLiteralContent": true

    },

    "libraries": {

      "contracts/OSM/SetApprovable.sol": {

        "SetApprovable": "0x8eaf680cd929e8798160e18e33b1753703dd1f14"

      },

      "contracts/OSM/SetAssignable.sol": {

        "SetAssignable": "0x4b8874ef568caaa69e15ae3ced9b6d7987b2dad2"

      },

      "contracts/OSM/SetFlexibleMetadata.sol": {

        "SetFlexibleMetadata": "0xe5cd560be0e0fab2850ef38a1b1b86e9d4fa0346"

      },

      "contracts/OSM/SetLockable.sol": {

        "SetLockable": "0x6b0419e1420cb20a4118d13363c1f7c1578c5191"

      },

      "contracts/OSM/SetMetadataRenderable.sol": {

        "SetMetadataRenderable": "0xa87f185bb1d76386498a16eb24f0257df781deb1"

      },

      "contracts/OSM/SetOwnerEnumerable.sol": {

        "SetOwnerEnumerable": "0x16cc42f7b61853f2d2c5880c6a5402cf01960d42"

      },

      "contracts/OSM/SetPackable.sol": {

        "SetPackable": "0xe408468a947828e1592d0d12657c6437d93d2cfe"

      },

      "contracts/OSM/SetPhaseable.sol": {

        "SetPhaseable": "0x9cfe653040054af47692dfdf4c26f1ce9259b121"

      }

    }

  }

}}