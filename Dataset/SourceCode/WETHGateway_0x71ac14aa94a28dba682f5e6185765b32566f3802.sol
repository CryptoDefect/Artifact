{{

  "language": "Solidity",

  "sources": {

    "@openzeppelin/contracts/interfaces/IERC4626.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC4626.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\nimport \"../token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @dev Interface of the ERC4626 \"Tokenized Vault Standard\", as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n *\n * _Available since v4.7._\n */\ninterface IERC4626 is IERC20, IERC20Metadata {\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed sender,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is “managed” by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n}\n"

    },

    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"

    },

    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"

    },

    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"

    },

    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"

    },

    "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/utils/ERC721Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Receiver.sol\";\n\n/**\n * @dev Implementation of the {IERC721Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n */\ncontract ERC721Holder is IERC721Receiver {\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"

    },

    "contracts/interfaces/IAddressProvider.sol": {

      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity 0.8.19;\n\ninterface IAddressProvider {\n    function setLendingMarket(address market) external;\n\n    function getLendingMarket() external view returns (address);\n\n    function setTradingPoolFactory(address tradingPoolFactory) external;\n\n    function getTradingPoolFactory() external view returns (address);\n\n    function setSwapRouter(address swapRouter) external;\n\n    function getSwapRouter() external view returns (address);\n\n    function setGaugeController(address gaugeController) external;\n\n    function getGaugeController() external view returns (address);\n\n    function setLoanCenter(address loancenter) external;\n\n    function getLoanCenter() external view returns (address);\n\n    function setVotingEscrow(address nativeTokenVault) external;\n\n    function getVotingEscrow() external view returns (address);\n\n    function setNativeToken(address nativeToken) external;\n\n    function getNativeToken() external view returns (address);\n\n    function getNativeTokenVesting() external view returns (address);\n\n    function setInterestRate(address interestRate) external;\n\n    function getInterestRate() external view returns (address);\n\n    function setNFTOracle(address nftOracle) external;\n\n    function getNFTOracle() external view returns (address);\n\n    function setTokenOracle(address tokenOracle) external;\n\n    function getTokenOracle() external view returns (address);\n\n    function setFeeDistributor(address feeDistributor) external;\n\n    function getFeeDistributor() external view returns (address);\n\n    function setGenesisNFT(address genesisNFT) external;\n\n    function getGenesisNFT() external view returns (address);\n\n    function setWETH(address weth) external;\n\n    function getWETH() external view returns (address);\n\n    function setBribes(address bribes) external;\n\n    function getBribes() external view returns (address);\n\n    function setLiquidityPairMetadata(address liquidityPairMetadata) external;\n\n    function getLiquidityPairMetadata() external view returns (address);\n}\n"

    },

    "contracts/interfaces/IBribes.sol": {

      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity 0.8.19;\n\ninterface IBribes {\n    event DepositBribe(\n        address indexed briber,\n        address indexed token,\n        address indexed gauge,\n        uint256 amount\n    );\n    event WithdrawBribe(\n        address indexed receiver,\n        address indexed token,\n        address indexed gauge,\n        uint256 amount\n    );\n\n    event SalvageBribes(\n        address indexed token,\n        address indexed gauge,\n        uint256 indexed epoch,\n        uint256 amount\n    );\n\n    event ClaimBribes(\n        address indexed receiver,\n        address indexed token,\n        address indexed gauge,\n        uint256 tokenId,\n        uint256 amount\n    );\n\n    function depositBribe(\n        address briber,\n        address token,\n        address gauge,\n        uint256 amount\n    ) external;\n\n    function withdrawBribe(\n        address receiver,\n        address token,\n        address gauge,\n        uint256 amount\n    ) external;\n}\n"

    },

    "contracts/interfaces/ILendingMarket.sol": {

      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity 0.8.19;\n\nimport {Trustus} from \"../protocol/Trustus/Trustus.sol\";\n\ninterface ILendingMarket {\n    event Borrow(\n        address indexed user,\n        address indexed asset,\n        address indexed nftAddress,\n        uint256[] nftTokenIds,\n        uint256 amount\n    );\n\n    event Repay(address indexed user, uint256 indexed loanId);\n\n    event CreateLiquidationAuction(\n        address indexed user,\n        uint256 indexed loanId,\n        uint256 bid\n    );\n    event BidLiquidationAuction(\n        address indexed user,\n        uint256 indexed loanId,\n        uint256 bid\n    );\n\n    event ClaimLiquidation(address indexed user, uint256 indexed loanId);\n\n    event CreateLendingPool(\n        address indexed lendingPool,\n        address indexed colletction,\n        address indexed asset\n    );\n\n    event SetLendingPool(\n        address indexed collection,\n        address indexed asset,\n        address indexed lendingPool\n    );\n\n    function borrow(\n        address onBehalfOf,\n        address asset,\n        uint256 amount,\n        address nftAddress,\n        uint256[] memory nftTokenIds,\n        uint256 genesisNFTId,\n        bytes32 request,\n        Trustus.TrustusPacket calldata packet\n    ) external;\n\n    function repay(uint256 loanId, uint256 amount) external;\n\n    function createLiquidationAuction(\n        address onBehalfOf,\n        uint256 loanId,\n        uint256 bid,\n        bytes32 request,\n        Trustus.TrustusPacket calldata packet\n    ) external;\n\n    function bidLiquidationAuction(\n        address onBehalfOf,\n        uint256 loanId,\n        uint256 bid\n    ) external;\n\n    function claimLiquidation(uint256 loanId) external;\n\n    function getLendingPool(\n        address collection,\n        address asset\n    ) external view returns (address);\n\n    function getTVLSafeguard() external view returns (uint256);\n}\n"

    },

    "contracts/interfaces/ILoanCenter.sol": {

      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity 0.8.19;\n\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {Trustus} from \"../protocol/Trustus/Trustus.sol\";\n\ninterface ILoanCenter {\n    function createLoan(\n        address owner,\n        address lendingPool,\n        uint256 amount,\n        uint256 genesisNFTId,\n        address nftAddress,\n        uint256[] memory nftTokenIds,\n        uint256 borrowRate\n    ) external returns (uint256);\n\n    function getLoan(\n        uint256 loanId\n    ) external view returns (DataTypes.LoanData memory);\n\n    function getLoanState(\n        uint256 loanId\n    ) external view returns (DataTypes.LoanState);\n\n    function getLoanLiquidationData(\n        uint256 loanId\n    ) external view returns (DataTypes.LoanLiquidationData memory);\n\n    function getLoanAuctioneerFee(\n        uint256 loanId\n    ) external view returns (uint256);\n\n    function repayLoan(uint256 loanId) external;\n\n    function liquidateLoan(uint256 loanId) external;\n\n    function auctionLoan(uint256 loanId, address user, uint256 bid) external;\n\n    function updateLoanAuctionBid(\n        uint256 loanId,\n        address user,\n        uint256 bid\n    ) external;\n\n    function getLoansCount() external view returns (uint256);\n\n    function getNFTLoanId(\n        address nftAddress,\n        uint256 nftTokenID\n    ) external view returns (uint256);\n\n    function getLoanLendingPool(uint256 loanId) external view returns (address);\n\n    function getLoanMaxDebt(\n        uint256 loanId,\n        uint256 tokensPrice\n    ) external view returns (uint256);\n\n    function getLoanDebt(uint256 loanId) external view returns (uint256);\n\n    function getLoanInterest(uint256 loanId) external view returns (uint256);\n\n    function getLoanTokenIds(\n        uint256 loanId\n    ) external view returns (uint256[] memory);\n\n    function getLoanCollectionAddress(\n        uint256 loanId\n    ) external view returns (address);\n\n    function updateLoanDebtTimestamp(\n        uint256 loanId,\n        uint256 newDebtTimestamp\n    ) external;\n\n    function updateLoanAmount(uint256 loanId, uint256 newAmount) external;\n\n    function getCollectionLiquidationThreshold(\n        address collection\n    ) external view returns (uint256);\n\n    function getCollectionMaxLTV(\n        address collection\n    ) external view returns (uint256);\n}\n"

    },

    "contracts/interfaces/ISwapRouter.sol": {

      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity 0.8.19;\n\ninterface ISwapRouter {\n    function approveTradingPool(address token, address tradingPool) external;\n\n    function swap(\n        address buyPool,\n        address sellPool,\n        uint256[] memory buyNftIds,\n        uint256 maximumBuyPrice,\n        uint256[] memory sellNftIds,\n        uint256[] memory sellLps,\n        uint256 minimumSellPrice\n    ) external returns (uint256);\n}\n"

    },

    "contracts/interfaces/ITradingPool.sol": {

      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity 0.8.19;\n\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\n\ninterface ITradingPool {\n    event AddLiquidity(\n        address indexed user,\n        uint256 indexed id,\n        DataTypes.LPType indexed lpType,\n        uint256[] nftIds,\n        uint256 tokenAmount,\n        uint256 spotPrice,\n        address curve,\n        uint256 delta,\n        uint256 fee\n    );\n    event RemoveLiquidity(address indexed user, uint256 indexed lpId);\n\n    event Buy(address indexed user, uint256[] nftIds, uint256 price);\n\n    event Sell(address indexed user, uint256[] nftIds, uint256 price);\n\n    event SetLpSpotPrice(\n        address indexed user,\n        uint256 indexed lpId,\n        uint256 spotPrice\n    );\n\n    event SetLpPricingCurve(\n        address indexed user,\n        uint256 indexed lpId,\n        address curve,\n        uint256 delta\n    );\n\n    event SetLpFee(address indexed user, uint256 indexed lpId, uint256 fee);\n\n    function addLiquidity(\n        address receiver,\n        DataTypes.LPType lpType,\n        uint256[] memory nftIds,\n        uint256 tokenAmount,\n        uint256 initialPrice,\n        address curve,\n        uint256 delta,\n        uint256 fee\n    ) external;\n\n    function removeLiquidity(uint256 lpId) external;\n\n    function removeLiquidityBatch(uint256[] memory lpIds) external;\n\n    function buy(\n        address onBehalfOf,\n        uint256[] memory nftIds,\n        uint256 maximumPrice\n    ) external returns (uint256);\n\n    function sell(\n        address onBehalfOf,\n        uint256[] memory nftIds,\n        uint256[] memory liquidityPairs,\n        uint256 minimumPrice\n    ) external returns (uint256);\n\n    function getLP(\n        uint256 lpId\n    ) external view returns (DataTypes.LiquidityPair memory);\n\n    function getLpCount() external view returns (uint256);\n\n    function nftToLp(uint256 nftId) external view returns (uint256);\n\n    function getToken() external view returns (address);\n\n    function getNFT() external view returns (address);\n}\n"

    },

    "contracts/interfaces/IWETH.sol": {

      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.19;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title Interface for WETH9\ninterface IWETH is IERC20 {\n    /// @notice Deposit ether to get wrapped ether\n    function deposit() external payable;\n\n    /// @notice Withdraw wrapped ether to get ether\n    function withdraw(uint256) external;\n}\n"

    },

    "contracts/libraries/types/DataTypes.sol": {

      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity 0.8.19;\n\nimport {Trustus} from \"../../protocol/Trustus/Trustus.sol\";\n\n/// @title DataTypes library\n/// @author leNFT\n/// @notice Defines the data types used in the protocol\n/// @dev Library with the data types used in the protocol\nlibrary DataTypes {\n    /// @notice Struct to store the price data of an array of assets from the same collection\n    /// @param collection The address of the collection\n    /// @param tokenIds The tokenIds of the assets\n    /// @param amount The price of the assets\n    struct AssetsPrice {\n        address collection;\n        uint256[] tokenIds;\n        uint256 amount;\n    }\n\n    /// @notice Struct to store the risk parameters for a collection\n    /// @param maxLTV The maximum loan to value ratio\n    /// @param liquidationThreshold The threshold at which the loan can be liquidated\n    struct CollectionRiskParameters {\n        uint16 maxLTV;\n        uint16 liquidationThreshold;\n    }\n\n    /// @notice Enum of the liquidity pair types\n    /// @dev Trade: Can buy and sell and price can increase and decrease\n    /// @dev TradeUp: Can buy and sell and price can only increase\n    /// @dev TradeDown: Can buy and sell and price can only decrease\n    /// @dev Buy: Can only buy (price will only decrease)\n    /// @dev Sell: Can only sell (price will only increase)\n    enum LPType {\n        Trade,\n        TradeUp,\n        TradeDown,\n        Buy,\n        Sell\n    }\n\n    /// @notice Struct to store the liquidity pair data\n    /// @param nftIds The tokenIds of the assets\n    /// @param tokenAmount The amount of tokens in the liquidity pair\n    /// @param spotPrice The spot price of the liquidity pair\n    /// @param curve The address of the curve\n    /// @param delta The delta of the curve\n    /// @param fee The fee for the buy/sell trades\n    /// @param lpType The type of liquidity pair\n    struct LiquidityPair {\n        uint256[] nftIds;\n        uint128 tokenAmount;\n        uint128 spotPrice;\n        uint128 delta;\n        address curve;\n        uint16 fee;\n        LPType lpType;\n    }\n\n    /// @notice Struct serving as a pointer from an NFT to a liquidity pair\n    /// @param liquidityPair The index of the liquidity pair\n    /// @param index The index of the NFT in the liquidity pair\n    struct NftToLp {\n        uint128 liquidityPair;\n        uint128 index;\n    }\n\n    /// @notice Struct to store the working balance in gauges\n    /// @param amount The amount of tokens\n    /// @param weight The weight of the tokens\n    /// @param timestamp The timestamp of the update\n    struct WorkingBalance {\n        uint128 amount;\n        uint128 weight;\n        uint40 timestamp;\n    }\n\n    /// @notice Struct to store the locked balance in the voting escrow\n    /// @param amount The amount of tokens\n    /// @param end The timestamp of the end of the lock\n    struct LockedBalance {\n        uint128 amount;\n        uint40 end;\n    }\n\n    /// @notice Struct to store an abstract point in a weight curve\n    /// @param bias The bias of the point\n    /// @param slope The slope of the point\n    /// @param timestamp The timestamp of the point\n    struct Point {\n        uint128 bias;\n        uint128 slope;\n        uint40 timestamp;\n    }\n\n    /// @notice Enum of all the states a loan can be in\n    /// @dev State change flow: None -> Active -> Repaid -> Auction -> Liquidated\n    /// @dev None (Default Value): We need a default that is not 'Active' - this is the zero value\n    /// @dev Active: The loan has been initialized; funds have been delivered to the borrower and the collateral is held.\n    /// @dev Repaid: The loan has been repaid; and the collateral has been returned to the borrower.\n    /// @dev Auctioned: The loan's collateral has been auctioned off and its in the process of being liquidated.\n    /// @dev Liquidated: The loan's collateral was claimed by the liquidator.\n    enum LoanState {\n        None,\n        Active,\n        Repaid,\n        Auctioned,\n        Liquidated\n    }\n\n    /// @notice Stores the data for a loan\n    /// @param owner The owner of the loan\n    /// @param amount The amount borrowed\n    /// @param nftTokenIds The tokenIds of the NFT collaterals\n    /// @param nftAsset The address of the NFT asset\n    /// @param borrowRate The interest rate at which the loan was written\n    /// @param initTimestamp The timestamp for the initial creation of the loan\n    /// @param debtTimestamp The timestamp for debt computation\n    /// @param pool The address of the lending pool associated with the loan\n    /// @param genesisNFTId The genesis NFT id for the boost (0 if not used)\n    /// @param state The current state of the loan\n    struct LoanData {\n        address owner;\n        uint256 amount;\n        uint256[] nftTokenIds;\n        address nftAsset;\n        uint16 borrowRate;\n        uint40 initTimestamp;\n        uint40 debtTimestamp;\n        address pool;\n        uint16 genesisNFTId;\n        LoanState state;\n    }\n\n    /// @notice Stores the data for a loan auction\n    /// @param auctioneer The address of the auctioneer (user who first auctioned the loan)\n    /// @param liquidator The address of the liquidator (user with the highest bid)\n    /// @param auctionStartTimestamp The timestamp for the start of the auction\n    /// @param auctionMaxBid The maximum bid for the auction\n    struct LoanLiquidationData {\n        address auctioneer;\n        address liquidator;\n        uint40 auctionStartTimestamp;\n        uint256 auctionMaxBid;\n    }\n\n    /// @notice Struct to store mint details for each Genesis NFT\n    /// @param timestamp The timestamp of the mint\n    /// @param locktime The locktime of the mint\n    /// @param lpAmount The amount of LP tokens minted\n    struct MintDetails {\n        uint40 timestamp;\n        uint40 locktime;\n        uint128 lpAmount;\n    }\n\n    /// @notice Struct to store the parameters for a borrow call\n    /// @param caller The caller of the borrow function\n    /// @param onBehalfOf The address of the user on whose behalf the caller is borrowing\n    /// @param asset The address of the asset being borrowed\n    /// @param amount The amount of the asset being borrowed\n    /// @param nftAddress The address of the NFT asset\n    /// @param nftTokenIds The tokenIds of the NFT collaterals\n    /// @param genesisNFTId The genesis NFT id for the boost (0 if not used)\n    /// @param request The request ID for the borrow\n    /// @param packet The Trustus packet for the borrow\n    struct BorrowParams {\n        address caller;\n        address onBehalfOf;\n        address asset;\n        uint256 amount;\n        address nftAddress;\n        uint256[] nftTokenIds;\n        uint256 genesisNFTId;\n        bytes32 request;\n        Trustus.TrustusPacket packet;\n    }\n\n    /// @notice Struct to store the parameters for a repay call\n    /// @param caller The caller of the repay function\n    /// @param loanId The ID of the loan being repaid\n    /// @param amount The amount of debt being repaid\n    struct RepayParams {\n        address caller;\n        uint256 loanId;\n        uint256 amount;\n    }\n\n    /// @notice Struct to store the parameters for a create auction (liquidate) call\n    /// @param caller The caller of the create auction function\n    /// @param onBehalfOf The address of the user on whose behalf the caller is liquidating\n    /// @param loanId The ID of the loan being liquidated\n    /// @param bid The bid for the auction\n    /// @param request The request ID for the liquidation\n    /// @param packet The Trustus packet for the liquidation\n    struct CreateAuctionParams {\n        address caller;\n        address onBehalfOf;\n        uint256 loanId;\n        uint256 bid;\n        bytes32 request;\n        Trustus.TrustusPacket packet;\n    }\n\n    /// @notice Struct to store the parameters for an auction bid call\n    /// @param caller The caller of the auction bid function\n    /// @param onBehalfOf The address of the user on whose behalf the caller is bidding\n    /// @param loanId The ID of the loan being liquidated\n    /// @param bid The bid for the auction\n    struct BidAuctionParams {\n        address caller;\n        address onBehalfOf;\n        uint256 loanId;\n        uint256 bid;\n    }\n\n    /// @notice Struct to store the parameters for a claim liquidation call\n    /// @param loanId The ID of the loan whose liquidation is being claimed\n    struct ClaimLiquidationParams {\n        uint256 loanId;\n    }\n\n    /// @notice Struct to store the parameters a user's VestingParams\n    /// @param timestamp The timestamp of the vesting start\n    /// @param period The vesting period\n    /// @param cliff The vesting cliff\n    /// @param amount The amount of tokens to vest\n    struct VestingParams {\n        uint256 timestamp;\n        uint256 period;\n        uint256 cliff;\n        uint256 amount;\n    }\n\n    /// @notice Struct to store the parameters for the Genesis NFT balancer pool\n    /// @param poolId The ID of the balancer pool\n    /// @param pool The address of the balancer pool\n    /// @param vault The address of the balancer vault\n    /// @param queries The address of the balancer queries contract\n    struct BalancerDetails {\n        bytes32 poolId;\n        address pool;\n        address vault;\n        address queries;\n    }\n}\n"

    },

    "contracts/protocol/Trustus/Trustus.sol": {

      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.19;\n\n/// @title Trustus\n/// @author zefram.eth\n/// @notice Trust-minimized method for accessing offchain data onchain\nabstract contract Trustus {\n    /// -----------------------------------------------------------------------\n    /// Structs\n    /// -----------------------------------------------------------------------\n\n    /// @param v Part of the ECDSA signature\n    /// @param r Part of the ECDSA signature\n    /// @param s Part of the ECDSA signature\n    /// @param request Identifier for verifying the packet is what is desired\n    /// , rather than a packet for some other function/contract\n    /// @param deadline The Unix timestamp (in seconds) after which the packet\n    /// should be rejected by the contract\n    /// @param payload The payload of the packet\n    struct TrustusPacket {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        bytes32 request;\n        uint256 deadline;\n        bytes payload;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Immutable parameters\n    /// -----------------------------------------------------------------------\n\n    /// @notice The chain ID used by EIP-712\n    // solhint-disable-next-line var-name-mixedcase\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    /// @notice The domain separator used by EIP-712\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    /// -----------------------------------------------------------------------\n    /// Storage variables\n    /// -----------------------------------------------------------------------\n\n    /// @notice Records whether an address is trusted as a packet provider\n    /// @dev provider => value\n    mapping(address => bool) internal isTrusted;\n\n    /// -----------------------------------------------------------------------\n    /// Modifiers\n    /// -----------------------------------------------------------------------\n\n    /// @notice Verifies whether a packet is valid and returns the result.\n    /// Will revert if the packet is invalid.\n    /// @dev The deadline, request, and signature are verified.\n    /// @param request The identifier for the requested payload\n    /// @param packet The packet provided by the offchain data provider\n    modifier verifyPacket(bytes32 request, TrustusPacket calldata packet) {\n        _verifyPacket(request, packet);\n        _;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Constructor\n    /// -----------------------------------------------------------------------\n\n    constructor() {\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = _computeDomainSeparator();\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Packet verification\n    /// -----------------------------------------------------------------------\n\n    /// @notice Verifies whether a packet is valid and returns the result.\n    /// @dev The deadline, request, and signature are verified.\n    /// @param request The identifier for the requested payload\n    /// @param packet The packet provided by the offchain data provider\n    function _verifyPacket(\n        bytes32 request,\n        TrustusPacket calldata packet\n    ) internal view virtual {\n        // verify deadline\n        require(block.timestamp < packet.deadline, \"T:V:DEADLINE_EXCEEDED\");\n\n        // verify request\n        require(request == packet.request, \"T:V:INVALID_REQUEST\");\n\n        // verify signature\n        address recoveredAddress = ecrecover(\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(\n                        abi.encode(\n                            keccak256(\n                                \"VerifyPacket(bytes32 request,uint256 deadline,bytes payload)\"\n                            ),\n                            packet.request,\n                            packet.deadline,\n                            keccak256(packet.payload)\n                        )\n                    )\n                )\n            ),\n            packet.v,\n            packet.r,\n            packet.s\n        );\n\n        require(\n            recoveredAddress != address(0) && isTrusted[recoveredAddress],\n            \"T:V:INVALID_SIGNATURE\"\n        );\n    }\n\n    /// @notice Sets the trusted status of an offchain data provider.\n    /// @param signer The data provider's ECDSA public key as an Ethereum address\n    /// @param isTrusted_ The desired trusted status to set\n    function _setIsTrusted(address signer, bool isTrusted_) internal virtual {\n        isTrusted[signer] = isTrusted_;\n    }\n\n    function _isTrusted(address signer) internal view virtual returns (bool) {\n        return (isTrusted[signer]);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// EIP-712 compliance\n    /// -----------------------------------------------------------------------\n\n    /// @notice The domain separator used by EIP-712\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return\n            block.chainid == INITIAL_CHAIN_ID\n                ? INITIAL_DOMAIN_SEPARATOR\n                : _computeDomainSeparator();\n    }\n\n    /// @notice Computes the domain separator used by EIP-712\n    function _computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                    ),\n                    keccak256(\"leNFT\"),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n}\n"

    },

    "contracts/protocol/WETHGateway.sol": {

      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.19;\n\nimport {IWETH} from \"../interfaces/IWETH.sol\";\nimport {ILendingMarket} from \"../interfaces/ILendingMarket.sol\";\nimport {DataTypes} from \"../libraries/types/DataTypes.sol\";\nimport {ILoanCenter} from \"../interfaces/ILoanCenter.sol\";\nimport {IBribes} from \"../interfaces/IBribes.sol\";\nimport {ISwapRouter} from \"../interfaces/ISwapRouter.sol\";\nimport {ITradingPool} from \"../interfaces/ITradingPool.sol\";\nimport {IERC4626} from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {Trustus} from \"./Trustus/Trustus.sol\";\nimport {IAddressProvider} from \"../interfaces/IAddressProvider.sol\";\nimport {ERC721Holder} from \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\";\n\n/// @title WETHGateway Contract\n/// @author leNFT\n/// @notice This contract is the proxy for ETH interactions with the leNFT protocol\n/// @dev Interacts with the WETH in order to wrap and unwrap ETH\ncontract WETHGateway is ERC721Holder {\n    IAddressProvider private immutable _addressProvider;\n    IWETH private immutable _weth;\n\n    modifier lendingPoolETH(address lendingPool) {\n        _requireLendingPoolETH(lendingPool);\n        _;\n    }\n\n    modifier loanPoolETH(uint256 loanId) {\n        _requireLoanPoolETH(loanId);\n        _;\n    }\n\n    modifier tradingPoolETH(address tradingPool) {\n        _requireTradingPoolETH(tradingPool);\n        _;\n    }\n\n    /// @notice Constructor for the WETHGateway contract\n    /// @param addressProvider The address of the addressProvider contract\n    /// @param weth The address of the WETH contract\n    constructor(IAddressProvider addressProvider, IWETH weth) {\n        _addressProvider = addressProvider;\n        _weth = weth;\n    }\n\n    /// @notice Deposit ETH in a wETH lending pool\n    /// @param lendingPool Lending pool to deposit into\n    function depositLendingPool(\n        address lendingPool\n    ) external payable lendingPoolETH(lendingPool) {\n        IWETH weth = _weth;\n        // Deposit and approve WETH\n        weth.deposit{value: msg.value}();\n        weth.approve(lendingPool, msg.value);\n\n        IERC4626(lendingPool).deposit(msg.value, msg.sender);\n    }\n\n    /// @notice Withdraw ETH from a WETH lending pool\n    /// @param lendingPool Lending pool to withdraw from\n    /// @param amount Amount of ETH to be withdrawn\n    function withdrawLendingPool(\n        address lendingPool,\n        uint256 amount\n    ) external lendingPoolETH(lendingPool) {\n        IERC4626(lendingPool).withdraw(amount, address(this), msg.sender);\n        _weth.withdraw(amount);\n\n        (bool sent, ) = msg.sender.call{value: amount}(\"\");\n        require(sent, \"ETHG:WLP:ETH_TRANSFER_FAILED\");\n    }\n\n    /// @notice Borrow ETH from a WETH lending pool while an NFT as collateral\n    /// @dev NFT approval needs to be given to the LoanCenter contract\n    /// @param amount Amount of ETH to be borrowed\n    /// @param nftAddress Address of the NFT collateral\n    /// @param nftTokenIds Token ids of the NFT(s) collateral\n    /// @param genesisNFTId Token id of the genesis NFT to be used for the loan (0 if none)\n    /// @param request ID of the collateral price request sent by the trusted server\n    /// @param packet Signed collateral price request sent by the trusted server\n    function borrow(\n        uint256 amount,\n        address nftAddress,\n        uint256[] calldata nftTokenIds,\n        uint256 genesisNFTId,\n        bytes32 request,\n        Trustus.TrustusPacket calldata packet\n    ) external {\n        ILendingMarket market = ILendingMarket(\n            _addressProvider.getLendingMarket()\n        );\n\n        // Transfer the collateral to the WETH Gateway\n        for (uint256 i = 0; i < nftTokenIds.length; i++) {\n            IERC721(nftAddress).safeTransferFrom(\n                msg.sender,\n                address(this),\n                nftTokenIds[i]\n            );\n\n            // Approve the collateral to be moved by the market\n            IERC721(nftAddress).approve(address(market), nftTokenIds[i]);\n        }\n\n        // SLOAD the WETH address to save gas\n        IWETH weth = _weth;\n\n        market.borrow(\n            msg.sender,\n            address(weth),\n            amount,\n            nftAddress,\n            nftTokenIds,\n            genesisNFTId,\n            request,\n            packet\n        );\n\n        weth.withdraw(amount);\n\n        (bool sent, ) = msg.sender.call{value: amount}(\"\");\n        require(sent, \"ETHG:B:ETH_TRANSFER_FAILED\");\n    }\n\n    /// @notice Repay an an active loan with ETH\n    /// @param loanId The ID of the loan to be paid\n    function repay(uint256 loanId) external payable {\n        ILoanCenter loanCenter = ILoanCenter(_addressProvider.getLoanCenter());\n        address pool = loanCenter.getLoanLendingPool(loanId);\n\n        ILendingMarket market = ILendingMarket(\n            _addressProvider.getLendingMarket()\n        );\n\n        // SLOAD the WETH address to save gas\n        IWETH weth = _weth;\n\n        require(\n            IERC4626(pool).asset() == address(weth),\n            \"ETHG:R:UNDERLYING_NOT_WETH\"\n        );\n\n        // If we are repaying an auctioned loan we also need to pay the auctineer fee\n        uint256 auctioneerFee;\n        if (loanCenter.getLoanState(loanId) == DataTypes.LoanState.Auctioned) {\n            auctioneerFee = loanCenter.getLoanAuctioneerFee(loanId);\n            require(auctioneerFee < msg.value, \"ETHG:R:NO_AUCTIONEER_FEE\");\n            weth.approve(address(market), auctioneerFee);\n        }\n\n        // Deposit and approve WETH\n        weth.deposit{value: msg.value}();\n        weth.approve(pool, msg.value - auctioneerFee);\n\n        // Repay loan\n        market.repay(loanId, msg.value - auctioneerFee);\n    }\n\n    /// @notice Deposit ETH and/or NFTs into a trading pool to provide liquidity\n    /// @param pool The trading pool address\n    /// @param lpType The type of LP\n    /// @param nftIds Token ids of the NFTs to deposit\n    /// @param initialPrice The initial price of the liquidity provider tokens\n    /// @param curve The curve used to calculate the price of the LP tokens\n    /// @param delta The minimum price change to update the curve\n    /// @param fee The fee charged on trades in the pool\n    function depositTradingPool(\n        address pool,\n        DataTypes.LPType lpType,\n        uint256[] calldata nftIds,\n        uint256 initialPrice,\n        address curve,\n        uint256 delta,\n        uint256 fee\n    ) external payable tradingPoolETH(pool) {\n        // Transfer the NFTs to the WETH Gateway and approve them for use\n        IERC721 tradingPoolNFT = IERC721(ITradingPool(pool).getNFT());\n        if (nftIds.length > 0) {\n            for (uint i = 0; i < nftIds.length; i++) {\n                tradingPoolNFT.safeTransferFrom(\n                    msg.sender,\n                    address(this),\n                    nftIds[i]\n                );\n            }\n            tradingPoolNFT.setApprovalForAll(pool, true);\n        }\n\n        // Deposit and approve WETH\n        if (msg.value > 0) {\n            // SLOAD the WETH address to save gas\n            IWETH weth = _weth;\n\n            weth.deposit{value: msg.value}();\n            weth.approve(pool, msg.value);\n        }\n\n        ITradingPool(pool).addLiquidity(\n            msg.sender,\n            lpType,\n            nftIds,\n            msg.value,\n            initialPrice,\n            curve,\n            delta,\n            fee\n        );\n    }\n\n    /// @notice Withdraw liquidity from a trading pool\n    /// @param pool The trading pool address\n    /// @param lpId The ID of the liquidity provider tokens to withdraw\n    function withdrawTradingPool(\n        address pool,\n        uint256 lpId\n    ) external tradingPoolETH(pool) {\n        // Send LP NFT to this contract\n        IERC721(pool).safeTransferFrom(msg.sender, address(this), lpId);\n\n        // Get LP info so we can send the correct amounts back\n        DataTypes.LiquidityPair memory lp = ITradingPool(pool).getLP(lpId);\n\n        // Remove liquidity\n        ITradingPool(pool).removeLiquidity(lpId);\n\n        // Send NFTs back to the user\n        IERC721 tradingPoolNFT = IERC721(ITradingPool(pool).getNFT());\n        for (uint i = 0; i < lp.nftIds.length; i++) {\n            tradingPoolNFT.safeTransferFrom(\n                address(this),\n                msg.sender,\n                lp.nftIds[i]\n            );\n        }\n\n        // Send ETH back to the user\n        _weth.withdraw(lp.tokenAmount);\n\n        (bool sent, ) = msg.sender.call{value: lp.tokenAmount}(\"\");\n        require(sent, \"ETHG:WTP:ETH_TRANSFER_FAILED\");\n    }\n\n    /// @notice Withdraws liquidity from a trading pool for a batch of liquidity pairs.\n    /// @param pool The address of the trading pool.\n    /// @param lpIds The array of liquidity pair ids to withdraw.\n    function withdrawBatchTradingPool(\n        address pool,\n        uint256[] calldata lpIds\n    ) external tradingPoolETH(pool) {\n        uint256 totalAmount;\n        uint256[][] memory nftIds = new uint256[][](lpIds.length);\n\n        // Send LP NFTs to this contract\n        for (uint i = 0; i < lpIds.length; i++) {\n            IERC721(pool).safeTransferFrom(msg.sender, address(this), lpIds[i]);\n\n            // Get LP info so we can send the correct amounts back\n            DataTypes.LiquidityPair memory lp = ITradingPool(pool).getLP(\n                lpIds[i]\n            );\n\n            // Add up the total amount of ETH to withdraw\n            totalAmount += lp.tokenAmount;\n\n            // Add up the total amount of NFTs to withdraw\n            nftIds[i] = lp.nftIds;\n        }\n\n        // Remove liquidity in batch\n        ITradingPool(pool).removeLiquidityBatch(lpIds);\n\n        // Send NFTs back to the user\n        IERC721 tradingPoolNFT = IERC721(ITradingPool(pool).getNFT());\n        for (uint a = 0; a < nftIds.length; a++) {\n            for (uint b = 0; b < nftIds[a].length; b++) {\n                tradingPoolNFT.safeTransferFrom(\n                    address(this),\n                    msg.sender,\n                    nftIds[a][b]\n                );\n            }\n        }\n\n        // Send ETH back to the user\n        _weth.withdraw(totalAmount);\n\n        (bool sent, ) = msg.sender.call{value: totalAmount}(\"\");\n        require(sent, \"ETHG:WBTP:ETH_TRANSFER_FAILED\");\n    }\n\n    /// @notice Buys NFT from a trading pool by depositing WETH and specifying the NFT ids and maximum price to pay.\n    /// @param pool The address of the trading pool.\n    /// @param nftIds The array of NFT ids to buy.\n    /// @param maximumPrice The maximum amount of ETH to pay for the purchase.\n    function buy(\n        address pool,\n        uint256[] calldata nftIds,\n        uint256 maximumPrice\n    ) external payable tradingPoolETH(pool) {\n        require(msg.value == maximumPrice, \"ETHG:B:VALUE_NOT_MAXIMUM_PRICE\");\n\n        // SLOAD the WETH address to save gas\n        IWETH weth = _weth;\n\n        // Deposit and approve WETH\n        weth.deposit{value: msg.value}();\n        weth.approve(pool, msg.value);\n\n        uint256 finalPrice = ITradingPool(pool).buy(\n            msg.sender,\n            nftIds,\n            maximumPrice\n        );\n\n        // Send ETH back to the user\n        if (msg.value > finalPrice) {\n            weth.withdraw(msg.value - finalPrice);\n\n            (bool sent, ) = msg.sender.call{value: msg.value - finalPrice}(\"\");\n            require(sent, \"ETHG:B:ETH_TRANSFER_FAILED\");\n        }\n    }\n\n    /// @notice Sells NFTs against a pool's liquidity pairs, specifying the NFT ids, liquidity pairs, and minimum price expected.\n    /// @param pool The address of the trading pool.\n    /// @param nftIds The array of NFT ids to sell.\n    /// @param liquidityPairs The array of liquidity pair to sell the NFTs against.\n    /// @param minimumPrice The minimum amount of ETH to receive for the sale.\n    function sell(\n        address pool,\n        uint256[] calldata nftIds,\n        uint256[] calldata liquidityPairs,\n        uint256 minimumPrice\n    ) external tradingPoolETH(pool) {\n        // Send NFTs to this contract and approve them for pool use\n        IERC721 tradingPoolNFT = IERC721(ITradingPool(pool).getNFT());\n        for (uint i = 0; i < nftIds.length; i++) {\n            tradingPoolNFT.safeTransferFrom(\n                msg.sender,\n                address(this),\n                nftIds[i]\n            );\n        }\n        tradingPoolNFT.setApprovalForAll(pool, true);\n\n        // Sell NFTs\n        uint256 finalPrice = ITradingPool(pool).sell(\n            address(this),\n            nftIds,\n            liquidityPairs,\n            minimumPrice\n        );\n\n        // Send ETH back to the user\n        _weth.withdraw(finalPrice);\n\n        (bool sent, ) = msg.sender.call{value: finalPrice}(\"\");\n        require(sent, \"ETHG:S:ETH_TRANSFER_FAILED\");\n    }\n\n    /// @notice Swaps NFTs between two trading pools, with one pool acting as the buyer and the other as the seller.\n    /// @param buyPool The address of the buying trading pool.\n    /// @param sellPool The address of the selling trading pool.\n    /// @param buyNftIds The array of NFT ids to buy.\n    /// @param maximumBuyPrice The maximum amount of ETH to pay for the purchase.\n    /// @param sellNftIds The array of NFT ids to sell.\n    /// @param sellLps The array of liquidity pair to sell the NFTs against.\n    /// @param minimumSellPrice The minimum amount of ETH to receive for the sale.\n    function swap(\n        address buyPool,\n        address sellPool,\n        uint256[] calldata buyNftIds,\n        uint256 maximumBuyPrice,\n        uint256[] calldata sellNftIds,\n        uint256[] calldata sellLps,\n        uint256 minimumSellPrice\n    ) external payable {\n        // SLOAD the WETH address to save gas\n        IWETH weth = _weth;\n\n        require(\n            ITradingPool(buyPool).getToken() == address(weth),\n            \"ETHG:S:BUY_UNDERLYING_NOT_WETH\"\n        );\n        require(\n            ITradingPool(sellPool).getToken() == address(weth),\n            \"ETHG:S:SELL_UNDERLYING_NOT_WETH\"\n        );\n        // Make sure the msg.value covers the swap\n        if (maximumBuyPrice > minimumSellPrice) {\n            require(\n                msg.value == maximumBuyPrice - minimumSellPrice,\n                \"ETHG:S:INVALID_VALUE\"\n            );\n\n            // Deposit and approve WETH\n            weth.deposit{value: msg.value}();\n            weth.approve(_addressProvider.getSwapRouter(), msg.value);\n        }\n\n        // avoid stack too deep\n        {\n            // Send NFTs to this contract and approve them for pool use\n            IERC721 sellPoolNFT = IERC721(ITradingPool(sellPool).getNFT());\n            for (uint i = 0; i < sellNftIds.length; i++) {\n                sellPoolNFT.safeTransferFrom(\n                    msg.sender,\n                    address(this),\n                    sellNftIds[i]\n                );\n            }\n            sellPoolNFT.setApprovalForAll(sellPool, true);\n        }\n\n        // Swap\n        uint256 returnedAmount = ISwapRouter(_addressProvider.getSwapRouter())\n            .swap(\n                buyPool,\n                sellPool,\n                buyNftIds,\n                maximumBuyPrice,\n                sellNftIds,\n                sellLps,\n                minimumSellPrice\n            );\n\n        // Send NFTs back to the user\n        IERC721 buyPoolNFT = IERC721(ITradingPool(buyPool).getNFT());\n        for (uint i = 0; i < buyNftIds.length; i++) {\n            buyPoolNFT.safeTransferFrom(\n                address(this),\n                msg.sender,\n                buyNftIds[i]\n            );\n        }\n\n        // Send ETH back to the user\n        if (returnedAmount > 0) {\n            weth.withdraw(returnedAmount);\n            (bool sent, ) = msg.sender.call{value: returnedAmount}(\"\");\n            require(sent, \"ETHG:S:ETH_TRANSFER_FAILED\");\n        }\n    }\n\n    /// @notice Deposits ETH into the bribe contract to be used for bribing.\n    /// @dev Bribe is applied to the next epoch\n    /// @param gauge The address of the gauge to bribe.\n    function depositBribe(address gauge) external payable {\n        address bribes = _addressProvider.getBribes();\n        // SLOAD the WETH address to save gas\n        IWETH weth = _weth;\n        weth.deposit{value: msg.value}();\n        weth.approve(bribes, msg.value);\n        IBribes(bribes).depositBribe(\n            msg.sender,\n            address(weth),\n            gauge,\n            msg.value\n        );\n    }\n\n    /// @notice Liquidates a loan.\n    /// @param loanId The id of the loan to liquidate.\n    /// @param request The request id of the loan to liquidate.\n    /// @param packet The Trustus packet of the loan to liquidate.\n    function createLiquidationAuction(\n        uint256 loanId,\n        bytes32 request,\n        Trustus.TrustusPacket calldata packet\n    ) external payable loanPoolETH(loanId) {\n        address lendingMarket = _addressProvider.getLendingMarket();\n        // SLOAD the WETH address to save gas\n        IWETH weth = _weth;\n        // Deposit and approve WETH\n        weth.deposit{value: msg.value}();\n        weth.approve(lendingMarket, msg.value);\n\n        // Create auction\n        ILendingMarket(lendingMarket).createLiquidationAuction(\n            msg.sender,\n            loanId,\n            msg.value,\n            request,\n            packet\n        );\n    }\n\n    /// @notice Bids on a liquidation auction.\n    /// @param loanId The id of the loan to bid on.\n    function bidLiquidationAuction(\n        uint256 loanId\n    ) external payable loanPoolETH(loanId) {\n        address lendingMarket = _addressProvider.getLendingMarket();\n        // SLOAD the WETH address to save gas\n        IWETH weth = _weth;\n        // Deposit and approve WETH\n        weth.deposit{value: msg.value}();\n        weth.approve(lendingMarket, msg.value);\n\n        // Bid on auction\n        ILendingMarket(lendingMarket).bidLiquidationAuction(\n            msg.sender,\n            loanId,\n            msg.value\n        );\n    }\n\n    function _requireLendingPoolETH(address lendingPool) internal view {\n        require(\n            IERC4626(lendingPool).asset() == address(_weth),\n            \"ETHG:UNDERLYING_NOT_WETH\"\n        );\n    }\n\n    function _requireLoanPoolETH(uint256 loanId) internal view {\n        // Make sure the loan pool asset is WETH\n        require(\n            IERC4626(\n                ILoanCenter(_addressProvider.getLoanCenter())\n                    .getLoanLendingPool(loanId)\n            ).asset() == address(_weth),\n            \"ETHG:UNDERLYING_NOT_WETH\"\n        );\n    }\n\n    function _requireTradingPoolETH(address tradingPool) internal view {\n        require(\n            ITradingPool(tradingPool).getToken() == address(_weth),\n            \"ETHG:UNDERLYING_NOT_WETH\"\n        );\n    }\n\n    // Receive ETH function: Intended to receive ETH from WETH contract\n    receive() external payable {\n        require(msg.sender == address(_weth), \"ETHG:RECEIVE:NOT_WETH\");\n    }\n\n    /**\n     * @dev Revert fallback calls\n     */\n    fallback() external payable {\n        revert(\"ETHG:F:INVALID_CALL\");\n    }\n}\n"

    }

  },

  "settings": {

    "viaIR": false,

    "optimizer": {

      "enabled": true,

      "runs": 200,

      "details": {

        "yul": true

      }

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "libraries": {}

  }

}}