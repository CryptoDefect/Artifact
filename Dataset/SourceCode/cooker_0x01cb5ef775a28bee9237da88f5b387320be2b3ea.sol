{{

  "language": "Solidity",

  "sources": {

    "contracts/Cooker.sol": {

      "content": "\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.19;\r\n\r\nimport \"ERC20.sol\";\r\nimport \"Ownable.sol\";\r\nimport \"IERC20.sol\";\r\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\r\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\r\n\r\n\r\ncontract cooker is ERC20, Ownable {\r\n    struct User {\r\n        bool isBlacklisted;\r\n        bool isAutomatedMarketMaker;\r\n        bool isExcludedFromFees;\r\n        bool isExcludedFromMaxTransactionAmount;\r\n    }\r\n\r\n    struct Fees {\r\n        uint8 buy;\r\n        uint8 sell;\r\n        uint8 liquidity;\r\n        uint8 cooker;\r\n        uint8 team;\r\n    }\r\n\r\n    struct Settings {\r\n        bool limitsInEffect;\r\n        bool swapEnabled;\r\n        bool blacklistRenounced;\r\n        bool feeChangeRenounced;\r\n        bool tradingActive;\r\n        /// @dev Upon enabling trading, record the end block for bot protection fee\r\n        /// @dev This fee is a 90% fee that is reduced by 5% every block for 18 blocks.\r\n        uint216 endBlock;\r\n    }\r\n\r\n    IUniswapV2Router02 public immutable uniswapV2Router;\r\n    address public immutable uniswapV2Pair;\r\n\r\n    /// @dev Constant to access the allowance slot\r\n    uint256 private constant _ALLOWANCE_SLOT_SEED = 0x7f5e9f20;\r\n    uint256 public constant MAX_SUPPLY = 1_000_000_000 * 1e18;\r\n    uint256 public constant MIN_SWAP_AMOUNT = MAX_SUPPLY / 100_000; // 0.001%\r\n    uint256 public constant MAX_SWAP_AMOUNT = MAX_SUPPLY * 5 / 1_000; // 0.5%\r\n\r\n    uint256 public maxTransactionAmount;\r\n    uint256 public swapTokensAtAmount;\r\n    uint256 public maxWallet;\r\n\r\n    address public cookerWallet;\r\n    address public teamWallet;\r\n\r\n    bool private _swapping;\r\n\r\n    uint256 public tokensForBotProtection;\r\n\r\n    Fees public feeAmounts;\r\n\r\n    Settings private settings = Settings({\r\n        limitsInEffect: true,\r\n        swapEnabled: true,\r\n        blacklistRenounced: false,\r\n        feeChangeRenounced: false,\r\n        tradingActive: false,\r\n        endBlock: uint216(0)\r\n    });\r\n\r\n    mapping(address => User) private _users;\r\n\r\n    event ExcludeFromFees(address indexed account, bool isExcluded);\r\n    event ExcludeFromMaxTransaction(address indexed account, bool isExcluded);\r\n    event FailedSwapBackTransfer(address indexed destination, uint256 amount);\r\n    event FeesUpdated(uint8 buyFee, uint8 sellFee, uint8 cookerPercent, uint8 liquidityPercent, uint8 teamPercent);\r\n    event MaxTransactionAmountUpdated(uint256 newAmount, uint256 oldAmount);\r\n    event MaxWalletAmountUpdated(uint256 newAmount, uint256 oldAmount);\r\n    event cookerWalletUpdated(address indexed newWallet, address indexed oldWallet);\r\n    event SetAutomatedMarketMakerPair(address indexed pair, bool value);\r\n    event SwapAndLiquify(uint256 tokensSwapped, uint256 ethReceived);\r\n    event SwapTokensAtAmountUpdated(uint256 newAmount, uint256 oldAmount);\r\n    event TeamWalletUpdated(address indexed newWallet, address indexed oldWallet);\r\n    event UpdateUniswapV2Router(address indexed newAddress, address indexed oldAddress);\r\n\r\n    error cooker__BlacklistModificationDisabled();\r\n    error cooker__BuyAmountGreaterThanMax();\r\n    error cooker__CannotBlacklistLPPair();\r\n    error cooker__CannotBlacklistRouter();\r\n    error cooker__CannotRemovePairFromAMMs();\r\n    error cooker__CannotSetWalletToAddressZero();\r\n    error cooker__CannotTransferFromAddressZero();\r\n    error cooker__CannotTransferToAddressZero();\r\n    error cooker__ErrorWithdrawingEth();\r\n    error cooker__FeeChangeRenounced();\r\n    error cooker__MaxFeeFivePercent();\r\n    error cooker__MaxTransactionTooLow();\r\n    error cooker__MaxWalletAmountExceeded();\r\n    error cooker__MaxWalletAmountTooLow();\r\n    error cooker__OnlyOwner();\r\n    error cooker__ReceiverBlacklisted();\r\n    error cooker__ReceiverCannotBeAddressZero();\r\n    error cooker__SellAmountGreaterThanMax();\r\n    error cooker__SenderBlacklisted();\r\n    error cooker__StuckEthWithdrawError();\r\n    error cooker__SwapAmountGreaterThanMaximum();\r\n    error cooker__SwapAmountLowerThanMinimum();\r\n    error cooker__TokenAddressCannotBeAddressZero();\r\n    error cooker__TradingNotActive();\r\n\r\n    constructor(address ownerWallet, address teamWallet_, address cookerWallet_, address routerAddress) {\r\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(routerAddress);\r\n\r\n        uniswapV2Router = _uniswapV2Router;\r\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\r\n\r\n        maxTransactionAmount = MAX_SUPPLY * 5 / 1_000; // 0.5%\r\n        maxWallet = MAX_SUPPLY * 5 / 1_000; // 0.5%\r\n        swapTokensAtAmount = MAX_SUPPLY * 5 / 10_000; // 0.05%\r\n\r\n        feeAmounts = Fees({buy: 25, sell: 75, cooker: 0, liquidity: 0, team: 100});\r\n\r\n        cookerWallet = cookerWallet_;\r\n        teamWallet = teamWallet_;\r\n\r\n        _users[teamWallet_] = User({\r\n            isExcludedFromFees: true,\r\n            isExcludedFromMaxTransactionAmount: true,\r\n            isAutomatedMarketMaker: false,\r\n            isBlacklisted: false\r\n        });\r\n        _users[address(this)] = User({\r\n            isExcludedFromFees: true,\r\n            isExcludedFromMaxTransactionAmount: true,\r\n            isAutomatedMarketMaker: false,\r\n            isBlacklisted: false\r\n        });\r\n        _users[address(0xdead)] = User({\r\n            isExcludedFromFees: true,\r\n            isExcludedFromMaxTransactionAmount: true,\r\n            isAutomatedMarketMaker: false,\r\n            isBlacklisted: false\r\n        });\r\n        _users[address(ownerWallet)] = User({\r\n            isExcludedFromFees: true,\r\n            isExcludedFromMaxTransactionAmount: true,\r\n            isAutomatedMarketMaker: false,\r\n            isBlacklisted: false\r\n        });\r\n\r\n        _users[address(uniswapV2Router)] = User({\r\n            isExcludedFromMaxTransactionAmount: true,\r\n            isAutomatedMarketMaker: false,\r\n            isExcludedFromFees: false,\r\n            isBlacklisted: false\r\n        });\r\n        _users[address(uniswapV2Pair)] = User({\r\n            isExcludedFromMaxTransactionAmount: true,\r\n            isAutomatedMarketMaker: true,\r\n            isExcludedFromFees: false,\r\n            isBlacklisted: false\r\n        });\r\n\r\n        _mint(ownerWallet, MAX_SUPPLY);\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function name() public pure override returns (string memory) {\r\n        return \"COOKER\";\r\n    }\r\n\r\n    function symbol() public pure override returns (string memory) {\r\n        return \"COOKER\";\r\n    }\r\n\r\n    function enableTrading() public {\r\n        _requireIsOwner();\r\n        settings.endBlock = uint216(block.number) + 10;\r\n        settings.tradingActive = true;\r\n    }\r\n\r\n    // remove limits after token is stable\r\n    function removeLimits() external {\r\n        _requireIsOwner();\r\n        settings.limitsInEffect = false;\r\n    }\r\n\r\n    // change the minimum amount of tokens to sell from fees\r\n    function updateSwapTokensAtAmount(uint256 newAmount) external {\r\n        _requireIsOwner();\r\n        if (newAmount < MIN_SWAP_AMOUNT) {\r\n            revert cooker__SwapAmountLowerThanMinimum();\r\n        }\r\n        if (newAmount > MAX_SWAP_AMOUNT) {\r\n            revert cooker__SwapAmountGreaterThanMaximum();\r\n        }\r\n        uint256 oldSwapAmount = swapTokensAtAmount;\r\n        swapTokensAtAmount = newAmount;\r\n        emit SwapTokensAtAmountUpdated(newAmount, oldSwapAmount);\r\n    }\r\n\r\n    function updateMaxTransactionAmount(uint256 newAmount) external {\r\n        _requireIsOwner();\r\n        if (newAmount < MAX_SUPPLY * 5 / 1000) {\r\n            revert cooker__MaxTransactionTooLow();\r\n        }\r\n        uint256 oldMaxTransactionAmount = maxTransactionAmount;\r\n        maxTransactionAmount = newAmount;\r\n        emit MaxTransactionAmountUpdated(newAmount, oldMaxTransactionAmount);\r\n    }\r\n\r\n    function updateMaxWalletAmount(uint256 newNum) external {\r\n        _requireIsOwner();\r\n        if (newNum < MAX_SUPPLY / 100) {\r\n            revert cooker__MaxWalletAmountTooLow();\r\n        }\r\n        uint256 oldMaxWallet = maxWallet;\r\n        maxWallet = newNum;\r\n        emit MaxWalletAmountUpdated(newNum, oldMaxWallet);\r\n    }\r\n\r\n    // only use to disable contract sales if absolutely necessary (emergency use only)\r\n    function updateSwapEnabled(bool enabled) external {\r\n        _requireIsOwner();\r\n        settings.swapEnabled = enabled;\r\n    }\r\n\r\n    function updateBuyFees(uint8 cookerFee, uint8 liquidityFee, uint8 teamFee) external {\r\n        _requireIsOwner();\r\n\r\n        if (settings.feeChangeRenounced) {\r\n            revert cooker__FeeChangeRenounced();\r\n        }\r\n\r\n        uint8 totalFees = cookerFee + liquidityFee + teamFee;\r\n        if (totalFees > 99) {\r\n            revert cooker__MaxFeeFivePercent();\r\n        }\r\n\r\n        uint8 sellFee = feeAmounts.sell;\r\n        uint8 revPercent = cookerFee * 100 / totalFees;\r\n        uint8 liqPercent = liquidityFee * 100 / totalFees;\r\n        uint8 teamPercent = 100 - revPercent - liqPercent;\r\n\r\n        feeAmounts =\r\n            Fees({buy: totalFees, sell: sellFee, cooker: revPercent, liquidity: liqPercent, team: teamPercent});\r\n        emit FeesUpdated(totalFees, sellFee, revPercent, liqPercent, teamPercent);\r\n    }\r\n\r\n    function updateSellFees(uint8 cookerFee, uint8 liquidityFee, uint8 teamFee) external {\r\n        _requireIsOwner();\r\n\r\n        if (settings.feeChangeRenounced) {\r\n            revert cooker__FeeChangeRenounced();\r\n        }\r\n\r\n        uint8 totalFees = cookerFee + liquidityFee + teamFee;\r\n        if (totalFees > 99) {\r\n            revert cooker__MaxFeeFivePercent();\r\n        }\r\n\r\n        uint8 buyFee = feeAmounts.buy;\r\n        uint8 revPercent = cookerFee * 100 / totalFees;\r\n        uint8 liqPercent = liquidityFee * 100 / totalFees;\r\n        uint8 teamPercent = 100 - revPercent - liqPercent;\r\n\r\n        feeAmounts =\r\n            Fees({buy: buyFee, sell: totalFees, cooker: revPercent, liquidity: liqPercent, team: teamPercent});\r\n        emit FeesUpdated(buyFee, totalFees, revPercent, liqPercent, teamPercent);\r\n    }\r\n\r\n    function excludeFromFees(address account, bool excluded) external {\r\n        _requireIsOwner();\r\n        _users[account].isExcludedFromFees = excluded;\r\n        emit ExcludeFromFees(account, excluded);\r\n    }\r\n\r\n    function excludeFromMaxTransaction(address account, bool isExcluded) external {\r\n        _requireIsOwner();\r\n        _users[account].isExcludedFromMaxTransactionAmount = isExcluded;\r\n        emit ExcludeFromMaxTransaction(account, isExcluded);\r\n    }\r\n\r\n    function setAutomatedMarketMakerPair(address pair, bool value) external {\r\n        _requireIsOwner();\r\n        if (pair == uniswapV2Pair) {\r\n            revert cooker__CannotRemovePairFromAMMs();\r\n        }\r\n\r\n        _users[pair].isAutomatedMarketMaker = value;\r\n        emit SetAutomatedMarketMakerPair(pair, value);\r\n    }\r\n\r\n    function updateCookersWallet(address newWallet) external {\r\n        _requireIsOwner();\r\n        if (newWallet == address(0)) {\r\n            revert cooker__CannotSetWalletToAddressZero();\r\n        }\r\n        address oldWallet = cookerWallet;\r\n        cookerWallet = newWallet;\r\n        emit cookerWalletUpdated(newWallet, oldWallet);\r\n    }\r\n\r\n    function updateTeamWallet(address newWallet) external {\r\n        _requireIsOwner();\r\n        if (newWallet == address(0)) {\r\n            revert cooker__CannotSetWalletToAddressZero();\r\n        }\r\n        address oldWallet = teamWallet;\r\n        teamWallet = newWallet;\r\n        emit TeamWalletUpdated(newWallet, oldWallet);\r\n    }\r\n\r\n    function withdrawStuckCookerEth(uint256 amount) external {\r\n        _requireIsOwner();\r\n        uint256 transferAmount;\r\n        if (amount == 0) {\r\n            transferAmount = balanceOf(address(this));\r\n        } else {\r\n            transferAmount = amount;\r\n        }\r\n        super._transfer(address(this), msg.sender, transferAmount);\r\n    }\r\n\r\n    function withdrawStuckToken(address _token) external {\r\n        _requireIsOwner();\r\n        if (_token == address(0)) {\r\n            revert cooker__TokenAddressCannotBeAddressZero();\r\n        }\r\n        uint256 _contractBalance = IERC20(_token).balanceOf(address(this));\r\n        IERC20(_token).transfer(msg.sender, _contractBalance);\r\n    }\r\n\r\n    function withdrawStuckEth() external {\r\n        _requireIsOwner();\r\n        (bool success,) = msg.sender.call{value: address(this).balance}(\"\");\r\n        if (!success) {\r\n            revert cooker__ErrorWithdrawingEth();\r\n        }\r\n    }\r\n\r\n    function renounceBlacklist() external {\r\n        _requireIsOwner();\r\n        settings.blacklistRenounced = true;\r\n    }\r\n\r\n    function renounceFeeChange() external {\r\n        _requireIsOwner();\r\n        settings.feeChangeRenounced = true;\r\n    }\r\n\r\n    function blacklist(address account) external {\r\n        _requireIsOwner();\r\n        if (settings.blacklistRenounced) {\r\n            revert cooker__BlacklistModificationDisabled();\r\n        }\r\n        if (account == uniswapV2Pair) {\r\n            revert cooker__CannotBlacklistLPPair();\r\n        }\r\n        if (account == address(uniswapV2Router)) {\r\n            revert cooker__CannotBlacklistRouter();\r\n        }\r\n        _users[account].isBlacklisted = true;\r\n    }\r\n\r\n    // @dev unblacklist address; not affected by blacklistRenounced incase team wants to unblacklist v3 pools down the\r\n    // @dev road\r\n    function unblacklist(address account) external {\r\n        _requireIsOwner();\r\n        _users[account].isBlacklisted = false;\r\n    }\r\n\r\n    function isExcludedFromFees(address account) external view returns (bool) {\r\n        return _users[account].isExcludedFromFees;\r\n    }\r\n\r\n    function isExcludedFromMaxTransactionAmount(address account) external view returns (bool) {\r\n        return _users[account].isExcludedFromMaxTransactionAmount;\r\n    }\r\n\r\n    function isAutomatedMarketMakerPair(address pair) external view returns (bool) {\r\n        return _users[pair].isAutomatedMarketMaker;\r\n    }\r\n\r\n    function isBlacklisted(address account) external view returns (bool) {\r\n        return _users[account].isBlacklisted;\r\n    }\r\n\r\n    function isSwapEnabled() external view returns (bool) {\r\n        return settings.swapEnabled;\r\n    }\r\n\r\n    function isBlacklistRenounced() external view returns (bool) {\r\n        return settings.blacklistRenounced;\r\n    }\r\n\r\n    function isFeeChangeRenounced() external view returns (bool) {\r\n        return settings.feeChangeRenounced;\r\n    }\r\n\r\n    function isTradingActive() external view returns (bool) {\r\n        return settings.tradingActive;\r\n    }\r\n\r\n    function isLimitInEffect() external view returns (bool) {\r\n        return settings.limitsInEffect;\r\n    }\r\n\r\n    function transfer(address to, uint256 amount) public override returns (bool) {\r\n        _transfer(msg.sender, to, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 amount) public override returns (bool) {\r\n        // Check allowance and reduce it if used, reverts with `InsufficientAllowance()` if not approved.\r\n        assembly {\r\n            let from_ := shl(96, from)\r\n            // Compute the allowance slot and load its value.\r\n            mstore(0x20, caller())\r\n            mstore(0x0c, or(from_, _ALLOWANCE_SLOT_SEED))\r\n            let allowanceSlot := keccak256(0x0c, 0x34)\r\n            let allowance_ := sload(allowanceSlot)\r\n            // If the allowance is not the maximum uint256 value.\r\n            if iszero(eq(allowance_, not(0))) {\r\n                // Revert if the amount to be transferred exceeds the allowance.\r\n                if gt(amount, allowance_) {\r\n                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\r\n                    revert(0x1c, 0x04)\r\n                }\r\n                // Subtract and store the updated allowance.\r\n                sstore(allowanceSlot, sub(allowance_, amount))\r\n            }\r\n        }\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address from, address to, uint256 amount) internal override {\r\n        // Ignore mints, burns not enabled\r\n        if (from == address(0)) {\r\n            revert cooker__CannotTransferFromAddressZero();\r\n        }\r\n        if (to == address(0)) {\r\n            revert cooker__CannotTransferToAddressZero();\r\n        }\r\n\r\n        User memory fromData = _users[from];\r\n        User memory toData = _users[to];\r\n        Settings memory settingCache = settings;\r\n\r\n        if (!settingCache.tradingActive) {\r\n            if (!fromData.isExcludedFromFees) {\r\n                if (!toData.isExcludedFromFees) {\r\n                    revert cooker__TradingNotActive();\r\n                }\r\n            }\r\n        }\r\n\r\n        // Apply blacklist protection\r\n        if (fromData.isBlacklisted) {\r\n            revert cooker__SenderBlacklisted();\r\n        }\r\n        if (toData.isBlacklisted) {\r\n            revert cooker__ReceiverBlacklisted();\r\n        }\r\n\r\n        // If zero amount, continue\r\n        if (amount == 0) {\r\n            return;\r\n        }\r\n\r\n        bool excludedFromFees = fromData.isExcludedFromFees || toData.isExcludedFromFees;\r\n\r\n        // Cache transaction type for reference.\r\n        // 1 = Buy\r\n        // 2 = Sell\r\n        // 3 = Transfer\r\n        uint8 txType = 3;\r\n\r\n        if (fromData.isAutomatedMarketMaker) {\r\n            // Buys originate from the AMM pair\r\n            txType = 1;\r\n        } else if (toData.isAutomatedMarketMaker) {\r\n            // Sells send funds to AMM pair\r\n            txType = 2;\r\n        }\r\n\r\n        if (!_swapping) {\r\n            if (settingCache.limitsInEffect) {\r\n                //when buy\r\n                if (txType == 1 && !toData.isExcludedFromMaxTransactionAmount) {\r\n                    if (amount > maxTransactionAmount) {\r\n                        revert cooker__BuyAmountGreaterThanMax();\r\n                    }\r\n                    if (amount + balanceOf(to) > maxWallet) {\r\n                        revert cooker__MaxWalletAmountExceeded();\r\n                    }\r\n                }\r\n                //when sell\r\n                else if (txType == 2 && !fromData.isExcludedFromMaxTransactionAmount) {\r\n                    if (amount > maxTransactionAmount) {\r\n                        revert cooker__SellAmountGreaterThanMax();\r\n                    }\r\n                } else if (!toData.isExcludedFromMaxTransactionAmount) {\r\n                    if (amount + balanceOf(to) > maxWallet) {\r\n                        revert cooker__MaxWalletAmountExceeded();\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (settingCache.swapEnabled) {\r\n                // Only sells will trigger the fee swap\r\n                if (txType == 2) {\r\n                    if (balanceOf(address(this)) >= swapTokensAtAmount) {\r\n                        _swapping = true;\r\n                        _swapBack();\r\n                        _swapping = false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (txType < 3) {\r\n            bool takeFee = !_swapping;\r\n\r\n            // if any account belongs to _isExcludedFromFee account then remove the fee\r\n            if (excludedFromFees) {\r\n                takeFee = false;\r\n            }\r\n            uint256 fees = 0;\r\n            // only take fees on buys/sells, do not take on wallet transfers\r\n            if (takeFee) {\r\n                Fees memory feeCache = feeAmounts;\r\n                // on sell\r\n                if (txType == 2) {\r\n                    if (feeCache.sell > 0) {\r\n                        fees = amount * feeCache.sell / 100;\r\n                    }\r\n                }\r\n                // on buy\r\n                else if (txType == 1) {\r\n                    if (feeCache.buy > 0) {\r\n                        fees = amount * feeCache.buy / 100;\r\n                    }\r\n                }\r\n\r\n                if (block.number < settingCache.endBlock) {\r\n                    uint256 blocksLeft = settingCache.endBlock - block.number;\r\n                    uint256 botFeeMultiplier = 90;\r\n\r\n                    // Apply sniper protection - first 18 blocks have a fee reduced 5% each block.\r\n                    if (blocksLeft < 18) {\r\n                        botFeeMultiplier -= (5 * (18 - blocksLeft));\r\n                    }\r\n                    uint256 botFee = (amount * botFeeMultiplier) / 100;\r\n                    super._transfer(from, teamWallet, botFee);\r\n                    amount -= botFee;\r\n                    tokensForBotProtection += botFee;\r\n                }\r\n\r\n                amount -= fees;\r\n\r\n                if (fees > 0) {\r\n                    super._transfer(from, address(this), fees);\r\n                }\r\n            }\r\n        }\r\n        super._transfer(from, to, amount);\r\n    }\r\n\r\n    function _swapTokensForEth(uint256 tokenAmount) internal {\r\n        // generate the uniswap pair path of token -> weth\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = uniswapV2Router.WETH();\r\n\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n        // make the swap\r\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0, // accept any amount of ETH\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function _addLiquidity(uint256 tokenAmount, uint256 ethAmount) internal {\r\n        // approve token transfer to cover all possible scenarios\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n\r\n        // add the liquidity\r\n        uniswapV2Router.addLiquidityETH{value: ethAmount}(\r\n            address(this),\r\n            tokenAmount,\r\n            0, // slippage is unavoidable\r\n            0, // slippage is unavoidable\r\n            owner(),\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function _swapBack() internal {\r\n        // Cache values\r\n        uint256 contractBalance = balanceOf(address(this));\r\n        Fees memory feeCache = feeAmounts;\r\n        bool success;\r\n\r\n        if (contractBalance == 0) {\r\n            return;\r\n        }\r\n\r\n        // Prevent too many tokens from being swapped\r\n        uint256 maxAmount = swapTokensAtAmount * 20;\r\n        if (contractBalance > maxAmount) {\r\n            contractBalance = maxAmount;\r\n        }\r\n\r\n        uint256 liquidityAmount = contractBalance * feeCache.liquidity / 100;\r\n\r\n        // Halve the amount of liquidity tokens\r\n        uint256 liquidityTokens = liquidityAmount - (liquidityAmount / 2);\r\n        uint256 amountToSwapForETH = contractBalance - liquidityTokens;\r\n\r\n        uint256 initialETHBalance = address(this).balance;\r\n\r\n        _swapTokensForEth(amountToSwapForETH);\r\n\r\n        uint256 ethBalance = address(this).balance - initialETHBalance;\r\n\r\n        uint256 ethForcooker = ethBalance * feeCache.cooker / 100;\r\n        uint256 ethForTeam = ethBalance * feeCache.team / 100;\r\n        uint256 ethForLiquidity = ethBalance - ethForcooker - ethForTeam;\r\n\r\n        if (liquidityTokens > 0 && ethForLiquidity > 0) {\r\n            _addLiquidity(liquidityTokens, ethForLiquidity);\r\n            emit SwapAndLiquify(amountToSwapForETH, ethForLiquidity);\r\n        }\r\n\r\n        address teamWallet_ = teamWallet;\r\n\r\n        (success,) = address(teamWallet_).call{value: ethForTeam}(\"\");\r\n        if (!success) {\r\n            emit FailedSwapBackTransfer(teamWallet_, ethForTeam);\r\n        }\r\n\r\n        if (ethForcooker > 0) {\r\n            (success,) = address(cookerWallet).call{value: ethForcooker}(\"\");\r\n            if (!success) {\r\n                emit FailedSwapBackTransfer(cookerWallet, ethForcooker);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _requireIsOwner() internal view {\r\n        if (msg.sender != owner()) {\r\n            revert cooker__OnlyOwner();\r\n        }\r\n    }\r\n}"

    },

    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol": {

      "content": "pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"

    },

    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol": {

      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"

    },

    "IERC20.sol": {

      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}"

    },

    "Ownable.sol": {

      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"Context.sol\";\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby disabling any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}"

    },

    "ERC20.sol": {

      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\n/// @notice Simple ERC20 + EIP-2612 implementation.\r\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC20.sol)\r\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\r\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol)\r\n///\r\n/// @dev Note:\r\n/// The ERC20 standard allows minting and transferring to and from the zero address,\r\n/// minting and transferring zero tokens, as well as self-approvals.\r\n/// For performance, this implementation WILL NOT revert for such actions.\r\n/// Please add any checks with overrides if desired.\r\nabstract contract ERC20 {\r\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\r\n    /*                       CUSTOM ERRORS                        */\r\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\r\n\r\n    /// @dev The total supply has overflowed.\r\n    error TotalSupplyOverflow();\r\n\r\n    /// @dev The allowance has overflowed.\r\n    error AllowanceOverflow();\r\n\r\n    /// @dev The allowance has underflowed.\r\n    error AllowanceUnderflow();\r\n\r\n    /// @dev Insufficient balance.\r\n    error InsufficientBalance();\r\n\r\n    /// @dev Insufficient allowance.\r\n    error InsufficientAllowance();\r\n\r\n    /// @dev The permit is invalid.\r\n    error InvalidPermit();\r\n\r\n    /// @dev The permit has expired.\r\n    error PermitExpired();\r\n\r\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\r\n    /*                           EVENTS                           */\r\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\r\n\r\n    /// @dev Emitted when `amount` tokens is transferred from `from` to `to`.\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n\r\n    /// @dev Emitted when `amount` tokens is approved by `owner` to be used by `spender`.\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n\r\n    /// @dev `keccak256(bytes(\"Transfer(address,address,uint256)\"))`.\r\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\r\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\r\n\r\n    /// @dev `keccak256(bytes(\"Approval(address,address,uint256)\"))`.\r\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\r\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\r\n\r\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\r\n    /*                          STORAGE                           */\r\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\r\n\r\n    /// @dev The storage slot for the total supply.\r\n    uint256 private constant _TOTAL_SUPPLY_SLOT = 0x05345cdf77eb68f44c;\r\n\r\n    /// @dev The balance slot of `owner` is given by:\r\n    /// ```\r\n    ///     mstore(0x0c, _BALANCE_SLOT_SEED)\r\n    ///     mstore(0x00, owner)\r\n    ///     let balanceSlot := keccak256(0x0c, 0x20)\r\n    /// ```\r\n    uint256 private constant _BALANCE_SLOT_SEED = 0x87a211a2;\r\n\r\n    /// @dev The allowance slot of (`owner`, `spender`) is given by:\r\n    /// ```\r\n    ///     mstore(0x20, spender)\r\n    ///     mstore(0x0c, _ALLOWANCE_SLOT_SEED)\r\n    ///     mstore(0x00, owner)\r\n    ///     let allowanceSlot := keccak256(0x0c, 0x34)\r\n    /// ```\r\n    uint256 private constant _ALLOWANCE_SLOT_SEED = 0x7f5e9f20;\r\n\r\n    /// @dev The nonce slot of `owner` is given by:\r\n    /// ```\r\n    ///     mstore(0x0c, _NONCES_SLOT_SEED)\r\n    ///     mstore(0x00, owner)\r\n    ///     let nonceSlot := keccak256(0x0c, 0x20)\r\n    /// ```\r\n    uint256 private constant _NONCES_SLOT_SEED = 0x38377508;\r\n\r\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\r\n    /*                       ERC20 METADATA                       */\r\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\r\n\r\n    /// @dev Returns the name of the token.\r\n    function name() public view virtual returns (string memory);\r\n\r\n    /// @dev Returns the symbol of the token.\r\n    function symbol() public view virtual returns (string memory);\r\n\r\n    /// @dev Returns the decimals places of the token.\r\n    function decimals() public view virtual returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\r\n    /*                           ERC20                            */\r\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\r\n\r\n    /// @dev Returns the amount of tokens in existence.\r\n    function totalSupply() public view virtual returns (uint256 result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := sload(_TOTAL_SUPPLY_SLOT)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the amount of tokens owned by `owner`.\r\n    function balanceOf(address owner) public view virtual returns (uint256 result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x0c, _BALANCE_SLOT_SEED)\r\n            mstore(0x00, owner)\r\n            result := sload(keccak256(0x0c, 0x20))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the amount of tokens that `spender` can spend on behalf of `owner`.\r\n    function allowance(address owner, address spender)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256 result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x20, spender)\r\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\r\n            mstore(0x00, owner)\r\n            result := sload(keccak256(0x0c, 0x34))\r\n        }\r\n    }\r\n\r\n    /// @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n    ///\r\n    /// Emits a {Approval} event.\r\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Compute the allowance slot and store the amount.\r\n            mstore(0x20, spender)\r\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\r\n            mstore(0x00, caller())\r\n            sstore(keccak256(0x0c, 0x34), amount)\r\n            // Emit the {Approval} event.\r\n            mstore(0x00, amount)\r\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x2c)))\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /// @dev Atomically increases the allowance granted to `spender` by the caller.\r\n    ///\r\n    /// Emits a {Approval} event.\r\n    function increaseAllowance(address spender, uint256 difference) public virtual returns (bool) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Compute the allowance slot and load its value.\r\n            mstore(0x20, spender)\r\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\r\n            mstore(0x00, caller())\r\n            let allowanceSlot := keccak256(0x0c, 0x34)\r\n            let allowanceBefore := sload(allowanceSlot)\r\n            // Add to the allowance.\r\n            let allowanceAfter := add(allowanceBefore, difference)\r\n            // Revert upon overflow.\r\n            if lt(allowanceAfter, allowanceBefore) {\r\n                mstore(0x00, 0xf9067066) // `AllowanceOverflow()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Store the updated allowance.\r\n            sstore(allowanceSlot, allowanceAfter)\r\n            // Emit the {Approval} event.\r\n            mstore(0x00, allowanceAfter)\r\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x2c)))\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /// @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n    ///\r\n    /// Emits a {Approval} event.\r\n    function decreaseAllowance(address spender, uint256 difference) public virtual returns (bool) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Compute the allowance slot and load its value.\r\n            mstore(0x20, spender)\r\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\r\n            mstore(0x00, caller())\r\n            let allowanceSlot := keccak256(0x0c, 0x34)\r\n            let allowanceBefore := sload(allowanceSlot)\r\n            // Revert if will underflow.\r\n            if lt(allowanceBefore, difference) {\r\n                mstore(0x00, 0x8301ab38) // `AllowanceUnderflow()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Subtract and store the updated allowance.\r\n            let allowanceAfter := sub(allowanceBefore, difference)\r\n            sstore(allowanceSlot, allowanceAfter)\r\n            // Emit the {Approval} event.\r\n            mstore(0x00, allowanceAfter)\r\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x2c)))\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /// @dev Transfer `amount` tokens from the caller to `to`.\r\n    ///\r\n    /// Requirements:\r\n    /// - `from` must at least have `amount`.\r\n    ///\r\n    /// Emits a {Transfer} event.\r\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\r\n        _beforeTokenTransfer(msg.sender, to, amount);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Compute the balance slot and load its value.\r\n            mstore(0x0c, _BALANCE_SLOT_SEED)\r\n            mstore(0x00, caller())\r\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\r\n            let fromBalance := sload(fromBalanceSlot)\r\n            // Revert if insufficient balance.\r\n            if gt(amount, fromBalance) {\r\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Subtract and store the updated balance.\r\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\r\n            // Compute the balance slot of `to`.\r\n            mstore(0x00, to)\r\n            let toBalanceSlot := keccak256(0x0c, 0x20)\r\n            // Add and store the updated balance of `to`.\r\n            // Will not overflow because the sum of all user balances\r\n            // cannot exceed the maximum uint256 value.\r\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\r\n            // Emit the {Transfer} event.\r\n            mstore(0x20, amount)\r\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, caller(), shr(96, mload(0x0c)))\r\n        }\r\n        _afterTokenTransfer(msg.sender, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Transfers `amount` tokens from `from` to `to`.\r\n    ///\r\n    /// Note: Does not update the allowance if it is the maximum uint256 value.\r\n    ///\r\n    /// Requirements:\r\n    /// - `from` must at least have `amount`.\r\n    /// - The caller must have at least `amount` of allowance to transfer the tokens of `from`.\r\n    ///\r\n    /// Emits a {Transfer} event.\r\n    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\r\n        _beforeTokenTransfer(from, to, amount);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let from_ := shl(96, from)\r\n            // Compute the allowance slot and load its value.\r\n            mstore(0x20, caller())\r\n            mstore(0x0c, or(from_, _ALLOWANCE_SLOT_SEED))\r\n            let allowanceSlot := keccak256(0x0c, 0x34)\r\n            let allowance_ := sload(allowanceSlot)\r\n            // If the allowance is not the maximum uint256 value.\r\n            if iszero(eq(allowance_, not(0))) {\r\n                // Revert if the amount to be transferred exceeds the allowance.\r\n                if gt(amount, allowance_) {\r\n                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\r\n                    revert(0x1c, 0x04)\r\n                }\r\n                // Subtract and store the updated allowance.\r\n                sstore(allowanceSlot, sub(allowance_, amount))\r\n            }\r\n            // Compute the balance slot and load its value.\r\n            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\r\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\r\n            let fromBalance := sload(fromBalanceSlot)\r\n            // Revert if insufficient balance.\r\n            if gt(amount, fromBalance) {\r\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Subtract and store the updated balance.\r\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\r\n            // Compute the balance slot of `to`.\r\n            mstore(0x00, to)\r\n            let toBalanceSlot := keccak256(0x0c, 0x20)\r\n            // Add and store the updated balance of `to`.\r\n            // Will not overflow because the sum of all user balances\r\n            // cannot exceed the maximum uint256 value.\r\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\r\n            // Emit the {Transfer} event.\r\n            mstore(0x20, amount)\r\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\r\n        }\r\n        _afterTokenTransfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\r\n    /*                          EIP-2612                          */\r\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\r\n\r\n    /// @dev Returns the current nonce for `owner`.\r\n    /// This value is used to compute the signature for EIP-2612 permit.\r\n    function nonces(address owner) public view virtual returns (uint256 result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Compute the nonce slot and load its value.\r\n            mstore(0x0c, _NONCES_SLOT_SEED)\r\n            mstore(0x00, owner)\r\n            result := sload(keccak256(0x0c, 0x20))\r\n        }\r\n    }\r\n\r\n    /// @dev Sets `value` as the allowance of `spender` over the tokens of `owner`,\r\n    /// authorized by a signed approval by `owner`.\r\n    ///\r\n    /// Emits a {Approval} event.\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public virtual {\r\n        bytes32 domainSeparator = DOMAIN_SEPARATOR();\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Grab the free memory pointer.\r\n            let m := mload(0x40)\r\n            // Revert if the block timestamp greater than `deadline`.\r\n            if gt(timestamp(), deadline) {\r\n                mstore(0x00, 0x1a15a3cc) // `PermitExpired()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Clean the upper 96 bits.\r\n            owner := shr(96, shl(96, owner))\r\n            spender := shr(96, shl(96, spender))\r\n            // Compute the nonce slot and load its value.\r\n            mstore(0x0c, _NONCES_SLOT_SEED)\r\n            mstore(0x00, owner)\r\n            let nonceSlot := keccak256(0x0c, 0x20)\r\n            let nonceValue := sload(nonceSlot)\r\n            // Increment and store the updated nonce.\r\n            sstore(nonceSlot, add(nonceValue, 1))\r\n            // Prepare the inner hash.\r\n            // `keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")`.\r\n            // forgefmt: disable-next-item\r\n            mstore(m, 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9)\r\n            mstore(add(m, 0x20), owner)\r\n            mstore(add(m, 0x40), spender)\r\n            mstore(add(m, 0x60), value)\r\n            mstore(add(m, 0x80), nonceValue)\r\n            mstore(add(m, 0xa0), deadline)\r\n            // Prepare the outer hash.\r\n            mstore(0, 0x1901)\r\n            mstore(0x20, domainSeparator)\r\n            mstore(0x40, keccak256(m, 0xc0))\r\n            // Prepare the ecrecover calldata.\r\n            mstore(0, keccak256(0x1e, 0x42))\r\n            mstore(0x20, and(0xff, v))\r\n            mstore(0x40, r)\r\n            mstore(0x60, s)\r\n            pop(staticcall(gas(), 1, 0, 0x80, 0x20, 0x20))\r\n            // If the ecrecover fails, the returndatasize will be 0x00,\r\n            // `owner` will be be checked if it equals the hash at 0x00,\r\n            // which evaluates to false (i.e. 0), and we will revert.\r\n            // If the ecrecover succeeds, the returndatasize will be 0x20,\r\n            // `owner` will be compared against the returned address at 0x20.\r\n            if iszero(eq(mload(returndatasize()), owner)) {\r\n                mstore(0x00, 0xddafbaef) // `InvalidPermit()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Compute the allowance slot and store the value.\r\n            // The `owner` is already at slot 0x20.\r\n            mstore(0x40, or(shl(160, _ALLOWANCE_SLOT_SEED), spender))\r\n            sstore(keccak256(0x2c, 0x34), value)\r\n            // Emit the {Approval} event.\r\n            log3(add(m, 0x60), 0x20, _APPROVAL_EVENT_SIGNATURE, owner, spender)\r\n            mstore(0x40, m) // Restore the free memory pointer.\r\n            mstore(0x60, 0) // Restore the zero pointer.\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the EIP-2612 domains separator.\r\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32 result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := mload(0x40) // Grab the free memory pointer.\r\n        }\r\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\r\n        bytes32 nameHash = keccak256(bytes(name()));\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let m := result\r\n            // `keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")`.\r\n            // forgefmt: disable-next-item\r\n            mstore(m, 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f)\r\n            mstore(add(m, 0x20), nameHash)\r\n            // `keccak256(\"1\")`.\r\n            // forgefmt: disable-next-item\r\n            mstore(add(m, 0x40), 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6)\r\n            mstore(add(m, 0x60), chainid())\r\n            mstore(add(m, 0x80), address())\r\n            result := keccak256(m, 0xa0)\r\n        }\r\n    }\r\n\r\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\r\n    /*                  INTERNAL MINT FUNCTIONS                   */\r\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\r\n\r\n    /// @dev Mints `amount` tokens to `to`, increasing the total supply.\r\n    ///\r\n    /// Emits a {Transfer} event.\r\n    function _mint(address to, uint256 amount) internal virtual {\r\n        _beforeTokenTransfer(address(0), to, amount);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let totalSupplyBefore := sload(_TOTAL_SUPPLY_SLOT)\r\n            let totalSupplyAfter := add(totalSupplyBefore, amount)\r\n            // Revert if the total supply overflows.\r\n            if lt(totalSupplyAfter, totalSupplyBefore) {\r\n                mstore(0x00, 0xe5cfe957) // `TotalSupplyOverflow()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Store the updated total supply.\r\n            sstore(_TOTAL_SUPPLY_SLOT, totalSupplyAfter)\r\n            // Compute the balance slot and load its value.\r\n            mstore(0x0c, _BALANCE_SLOT_SEED)\r\n            mstore(0x00, to)\r\n            let toBalanceSlot := keccak256(0x0c, 0x20)\r\n            // Add and store the updated balance.\r\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\r\n            // Emit the {Transfer} event.\r\n            mstore(0x20, amount)\r\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, 0, shr(96, mload(0x0c)))\r\n        }\r\n        _afterTokenTransfer(address(0), to, amount);\r\n    }\r\n\r\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\r\n    /*                  INTERNAL BURN FUNCTIONS                   */\r\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\r\n\r\n    /// @dev Burns `amount` tokens from `from`, reducing the total supply.\r\n    ///\r\n    /// Emits a {Transfer} event.\r\n    function _burn(address from, uint256 amount) internal virtual {\r\n        _beforeTokenTransfer(from, address(0), amount);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Compute the balance slot and load its value.\r\n            mstore(0x0c, _BALANCE_SLOT_SEED)\r\n            mstore(0x00, from)\r\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\r\n            let fromBalance := sload(fromBalanceSlot)\r\n            // Revert if insufficient balance.\r\n            if gt(amount, fromBalance) {\r\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Subtract and store the updated balance.\r\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\r\n            // Subtract and store the updated total supply.\r\n            sstore(_TOTAL_SUPPLY_SLOT, sub(sload(_TOTAL_SUPPLY_SLOT), amount))\r\n            // Emit the {Transfer} event.\r\n            mstore(0x00, amount)\r\n            log3(0x00, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, shl(96, from)), 0)\r\n        }\r\n        _afterTokenTransfer(from, address(0), amount);\r\n    }\r\n\r\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\r\n    /*                INTERNAL TRANSFER FUNCTIONS                 */\r\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\r\n\r\n    /// @dev Moves `amount` of tokens from `from` to `to`.\r\n    function _transfer(address from, address to, uint256 amount) internal virtual {\r\n        _beforeTokenTransfer(from, to, amount);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let from_ := shl(96, from)\r\n            // Compute the balance slot and load its value.\r\n            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\r\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\r\n            let fromBalance := sload(fromBalanceSlot)\r\n            // Revert if insufficient balance.\r\n            if gt(amount, fromBalance) {\r\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Subtract and store the updated balance.\r\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\r\n            // Compute the balance slot of `to`.\r\n            mstore(0x00, to)\r\n            let toBalanceSlot := keccak256(0x0c, 0x20)\r\n            // Add and store the updated balance of `to`.\r\n            // Will not overflow because the sum of all user balances\r\n            // cannot exceed the maximum uint256 value.\r\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\r\n            // Emit the {Transfer} event.\r\n            mstore(0x20, amount)\r\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\r\n        }\r\n        _afterTokenTransfer(from, to, amount);\r\n    }\r\n\r\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\r\n    /*                INTERNAL ALLOWANCE FUNCTIONS                */\r\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\r\n\r\n    /// @dev Updates the allowance of `owner` for `spender` based on spent `amount`.\r\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Compute the allowance slot and load its value.\r\n            mstore(0x20, spender)\r\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\r\n            mstore(0x00, owner)\r\n            let allowanceSlot := keccak256(0x0c, 0x34)\r\n            let allowance_ := sload(allowanceSlot)\r\n            // If the allowance is not the maximum uint256 value.\r\n            if iszero(eq(allowance_, not(0))) {\r\n                // Revert if the amount to be transferred exceeds the allowance.\r\n                if gt(amount, allowance_) {\r\n                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\r\n                    revert(0x1c, 0x04)\r\n                }\r\n                // Subtract and store the updated allowance.\r\n                sstore(allowanceSlot, sub(allowance_, amount))\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Sets `amount` as the allowance of `spender` over the tokens of `owner`.\r\n    ///\r\n    /// Emits a {Approval} event.\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let owner_ := shl(96, owner)\r\n            // Compute the allowance slot and store the amount.\r\n            mstore(0x20, spender)\r\n            mstore(0x0c, or(owner_, _ALLOWANCE_SLOT_SEED))\r\n            sstore(keccak256(0x0c, 0x34), amount)\r\n            // Emit the {Approval} event.\r\n            mstore(0x00, amount)\r\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, shr(96, owner_), shr(96, mload(0x2c)))\r\n        }\r\n    }\r\n\r\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\r\n    /*                     HOOKS TO OVERRIDE                      */\r\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\r\n\r\n    /// @dev Hook that is called before any transfer of tokens.\r\n    /// This includes minting and burning.\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\r\n\r\n    /// @dev Hook that is called after any transfer of tokens.\r\n    /// This includes minting and burning.\r\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\r\n}"

    },

    "Context.sol": {

      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}"

    },

    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol": {

      "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"

    }

  },

  "settings": {

    "optimizer": {

      "enabled": true,

      "runs": 200

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    }

  }

}}