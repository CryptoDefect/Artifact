{{

  "language": "Solidity",

  "sources": {

    "CoboFactory.sol": {

      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity ^0.8.19;\n\nimport \"Clones.sol\";\n\nimport \"BaseOwnable.sol\";\n\n/// @title CoboFactory - A contract factory referenced by bytes32 name.\n/// @author Cobo Safe Dev Team https://www.cobo.com/\n/// @notice Mostly used to manage proxy logic contract. But ok to manage non-proxy contracts.\n/// @dev Contracts to add should extend IVersion interface, which implement `NAME()` function.\ncontract CoboFactory is BaseOwnable {\n    bytes32 public constant NAME = \"CoboFactory\";\n    uint256 public constant VERSION = 1;\n\n    bytes32[] public names;\n\n    // The last one added.\n    mapping(bytes32 => address) public latestImplementations;\n\n    // Name => All added contracts.\n    mapping(bytes32 => address[]) public implementations;\n\n    // deployer => name => proxy contract list\n    // This is expensive. Query ProxyCreated event in SubGraph is a better solution.\n    mapping(address => mapping(bytes32 => address[])) public records;\n\n    event ProxyCreated(address indexed deployer, bytes32 indexed name, address indexed implementation, address proxy);\n    event ImplementationAdded(bytes32 indexed name, address indexed implementation);\n\n    constructor(address _owner) BaseOwnable(_owner) {}\n\n    function _getLatestImplStrict(bytes32 name) internal view returns (address impl) {\n        impl = getLatestImplementation(name);\n        require(impl != address(0), \"No implementation\");\n    }\n\n    /// View functions.\n    function getLatestImplementation(bytes32 name) public view returns (address impl) {\n        impl = latestImplementations[name];\n    }\n\n    function getAllImplementations(bytes32 name) external view returns (address[] memory impls) {\n        impls = implementations[name];\n    }\n\n    function getAllNames() external view returns (bytes32[] memory _names) {\n        _names = names;\n    }\n\n    /// @dev For etherscan view.\n    function getNameString(uint i) public view returns (string memory _name) {\n        _name = string(abi.encodePacked(names[i]));\n    }\n\n    function getAllNameStrings() external view returns (string[] memory _names) {\n        _names = new string[](names.length);\n        for (uint i = 0; i < names.length; ++i) {\n            _names[i] = getNameString(i);\n        }\n    }\n\n    function getLastRecord(address deployer, bytes32 name) external view returns (address proxy) {\n        address[] storage record = records[deployer][name];\n        if (record.length == 0) return address(0);\n        proxy = record[record.length - 1];\n    }\n\n    function getRecordSize(address deployer, bytes32 name) external view returns (uint256 size) {\n        address[] storage record = records[deployer][name];\n        size = record.length;\n    }\n\n    function getAllRecord(address deployer, bytes32 name) external view returns (address[] memory proxies) {\n        return records[deployer][name];\n    }\n\n    function getRecords(\n        address deployer,\n        bytes32 name,\n        uint256 start,\n        uint256 end\n    ) external view returns (address[] memory proxies) {\n        address[] storage record = records[deployer][name];\n        uint256 size = record.length;\n        if (end > size) end = size;\n        require(end > start, \"end > start\");\n        proxies = new address[](end - start);\n        for (uint i = start; i < end; ++i) {\n            proxies[i - start] = record[i];\n        }\n    }\n\n    function getCreate2Address(address creator, bytes32 name, bytes32 salt) external view returns (address instance) {\n        address implementation = getLatestImplementation(name);\n        if (implementation == address(0)) return address(0);\n        salt = keccak256(abi.encode(creator, salt));\n        return Clones.predictDeterministicAddress(implementation, salt);\n    }\n\n    /// External functions.\n\n    /// @dev Create EIP 1167 proxy.\n    function create(bytes32 name) public returns (address instance) {\n        address implementation = _getLatestImplStrict(name);\n        instance = Clones.clone(implementation);\n        emit ProxyCreated(msg.sender, name, implementation, instance);\n    }\n\n    /// @dev Create EIP 1167 proxy with create2.\n    function create2(bytes32 name, bytes32 salt) public returns (address instance) {\n        address implementation = _getLatestImplStrict(name);\n        salt = keccak256(abi.encode(msg.sender, salt));\n        instance = Clones.cloneDeterministic(implementation, salt);\n        emit ProxyCreated(msg.sender, name, implementation, instance);\n    }\n\n    /// @notice Create and record the creation in contract.\n    function createAndRecord(bytes32 name) external returns (address instance) {\n        instance = create(name);\n        records[msg.sender][name].push(instance);\n    }\n\n    function create2AndRecord(bytes32 name, bytes32 salt) public returns (address instance) {\n        instance = create2(name, salt);\n        records[msg.sender][name].push(instance);\n    }\n\n    // Owner functions.\n    function addImplementation(address impl) external onlyOwner {\n        bytes32 name = IVersion(impl).NAME();\n\n        // If new name found, add to `names`.\n        if (latestImplementations[name] == address(0)) {\n            names.push(name);\n        }\n\n        latestImplementations[name] = impl;\n        implementations[name].push(impl);\n        emit ImplementationAdded(name, impl);\n    }\n}\n"

    },

    "Clones.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(0, 0x09, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(0, 0x09, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"

    },

    "BaseOwnable.sol": {

      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity ^0.8.19;\n\nimport \"Errors.sol\";\nimport \"BaseVersion.sol\";\n\n/// @title BaseOwnable - Provides simple ownership access control.\n/// @author Cobo Safe Dev Team https://www.cobo.com/\n/// @dev Can be used in both proxy and non-proxy mode.\nabstract contract BaseOwnable is BaseVersion {\n    address public owner;\n    address public pendingOwner;\n    bool private initialized = false;\n\n    event PendingOwnerSet(address indexed to);\n    event NewOwnerSet(address indexed owner);\n\n    modifier onlyOwner() {\n        require(owner == msg.sender, Errors.CALLER_IS_NOT_OWNER);\n        _;\n    }\n\n    /// @dev `owner` is set by argument, thus the owner can any address.\n    ///      When used in non-proxy mode, `initialize` can not be called\n    ///      after deployment.\n    constructor(address _owner) {\n        initialize(_owner);\n    }\n\n    /// @dev When used in proxy mode, `initialize` can be called by anyone\n    ///      to claim the ownership.\n    ///      This function can be called only once.\n    function initialize(address _owner) public {\n        require(!initialized, Errors.ALREADY_INITIALIZED);\n        _setOwner(_owner);\n        initialized = true;\n    }\n\n    /// @notice User should ensure the corrent owner address set, or the\n    ///         ownership may be transferred to blackhole. It is recommended to\n    ///         take a safer way with setPendingOwner() + acceptOwner().\n    function transferOwnership(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"New Owner is zero\");\n        _setOwner(newOwner);\n    }\n\n    /// @notice The original owner calls `setPendingOwner(newOwner)` and the new\n    ///         owner calls `acceptOwner()` to take the ownership.\n    function setPendingOwner(address to) external onlyOwner {\n        pendingOwner = to;\n        emit PendingOwnerSet(pendingOwner);\n    }\n\n    function acceptOwner() external {\n        require(msg.sender == pendingOwner);\n        _setOwner(pendingOwner);\n    }\n\n    /// @notice Make the contract immutable.\n    function renounceOwnership() external onlyOwner {\n        _setOwner(address(0));\n    }\n\n    // Internal functions\n\n    /// @dev Clear pendingOwner to prevent from reclaiming the ownership.\n    function _setOwner(address _owner) internal {\n        owner = _owner;\n        pendingOwner = address(0);\n        emit NewOwnerSet(owner);\n    }\n}\n"

    },

    "Errors.sol": {

      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity ^0.8.19;\n\n/// @dev Common errors. This helps reducing the contract size.\nlibrary Errors {\n    // \"E1\";\n\n    // Call/Static-call failed.\n    string constant CALL_FAILED = \"E2\";\n\n    // Argument's type not supported in View Variant.\n    string constant INVALID_VIEW_ARG_SOL_TYPE = \"E3\";\n\n    // Invalid length for variant raw data.\n    string constant INVALID_VARIANT_RAW_DATA = \"E4\";\n\n    // \"E5\";\n\n    // Invalid variant type.\n    string constant INVALID_VAR_TYPE = \"E6\";\n\n    // Rule not exists\n    string constant RULE_NOT_EXISTS = \"E7\";\n\n    // Variant name not found.\n    string constant VAR_NAME_NOT_FOUND = \"E8\";\n\n    // Rule: v1/v2 solType mismatch\n    string constant SOL_TYPE_MISMATCH = \"E9\";\n\n    // \"E10\";\n\n    // Invalid rule OP.\n    string constant INVALID_RULE_OP = \"E11\";\n\n    //  \"E12\";\n\n    // \"E13\";\n\n    //  \"E14\";\n\n    // \"E15\";\n\n    // \"E16\";\n\n    // \"E17\";\n\n    // \"E18\";\n\n    // \"E19\";\n\n    // \"E20\";\n\n    // checkCmpOp: OP not support\n    string constant CMP_OP_NOT_SUPPORT = \"E21\";\n\n    // checkBySolType: Invalid op for bool\n    string constant INVALID_BOOL_OP = \"E22\";\n\n    // checkBySolType: Invalid op\n    string constant CHECK_INVALID_OP = \"E23\";\n\n    // Invalid solidity type.\n    string constant INVALID_SOL_TYPE = \"E24\";\n\n    // computeBySolType: invalid vm op\n    string constant INVALID_VM_BOOL_OP = \"E25\";\n\n    // computeBySolType: invalid vm arith op\n    string constant INVALID_VM_ARITH_OP = \"E26\";\n\n    // onlyCaller: Invalid caller\n    string constant INVALID_CALLER = \"E27\";\n\n    // \"E28\";\n\n    // Side-effect is not allowed here.\n    string constant SIDE_EFFECT_NOT_ALLOWED = \"E29\";\n\n    // Invalid variant count for the rule op.\n    string constant INVALID_VAR_COUNT = \"E30\";\n\n    // extractCallData: Invalid op.\n    string constant INVALID_EXTRACTOR_OP = \"E31\";\n\n    // extractCallData: Invalid array index.\n    string constant INVALID_ARRAY_INDEX = \"E32\";\n\n    // extractCallData: No extract op.\n    string constant NO_EXTRACT_OP = \"E33\";\n\n    // extractCallData: No extract path.\n    string constant NO_EXTRACT_PATH = \"E34\";\n\n    // BaseOwnable: caller is not owner\n    string constant CALLER_IS_NOT_OWNER = \"E35\";\n\n    // BaseOwnable: Already initialized\n    string constant ALREADY_INITIALIZED = \"E36\";\n\n    // \"E37\";\n\n    // \"E38\";\n\n    // BaseACL: ACL check method should not return anything.\n    string constant ACL_FUNC_RETURNS_NON_EMPTY = \"E39\";\n\n    // \"E40\";\n\n    // BaseAccount: Invalid delegate.\n    string constant INVALID_DELEGATE = \"E41\";\n\n    // RootAuthorizer: delegateCallAuthorizer not set\n    string constant DELEGATE_CALL_AUTH_NOT_SET = \"E42\";\n\n    // RootAuthorizer: callAuthorizer not set.\n    string constant CALL_AUTH_NOT_SET = \"E43\";\n\n    // BaseAccount: Authorizer not set.\n    string constant AUTHORIZER_NOT_SET = \"E44\";\n\n    // BaseAccount: Invalid authorizer flag.\n    string constant INVALID_AUTHORIZER_FLAG = \"E45\";\n\n    // BaseAuthorizer: Authorizer paused.\n    string constant AUTHORIZER_PAUSED = \"E46\";\n\n    // Authorizer set: Invalid hint.\n    string constant INVALID_HINT = \"E47\";\n\n    // Authorizer set: All auth deny.\n    string constant ALL_AUTH_FAILED = \"E48\";\n\n    // BaseACL: Method not allow.\n    string constant METHOD_NOT_ALLOW = \"E49\";\n\n    // AuthorizerUnionSet: Invalid hint collected.\n    string constant INVALID_HINT_COLLECTED = \"E50\";\n\n    // AuthorizerSet: Empty auth set\n    string constant EMPTY_AUTH_SET = \"E51\";\n\n    // AuthorizerSet: hint not implement.\n    string constant HINT_NOT_IMPLEMENT = \"E52\";\n\n    // RoleAuthorizer: Empty role set\n    string constant EMPTY_ROLE_SET = \"E53\";\n\n    // RoleAuthorizer: No auth for the role\n    string constant NO_AUTH_FOR_THE_ROLE = \"E54\";\n\n    // BaseACL: No in contract white list.\n    string constant NOT_IN_CONTRACT_LIST = \"E55\";\n\n    // BaseACL: Same process not allowed to install twice.\n    string constant SAME_PROCESS_TWICE = \"E56\";\n\n    // BaseAuthorizer: Account not set (then can not find roleManger)\n    string constant ACCOUNT_NOT_SET = \"E57\";\n\n    // BaseAuthorizer: roleManger not set\n    string constant ROLE_MANAGER_NOT_SET = \"E58\";\n}\n"

    },

    "BaseVersion.sol": {

      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity ^0.8.19;\n\nimport \"IVersion.sol\";\n\n/// @title BaseVersion - Provides version information\n/// @author Cobo Safe Dev Team https://www.cobo.com/\n/// @dev\n///    Implement NAME() and VERSION() methods according to IVersion interface.\n///\n///    Or just:\n///      bytes32 public constant NAME = \"<Your contract name>\";\n///      uint256 public constant VERSION = <Your contract version>;\n///\n///    Change the NAME when writing new kind of contract.\n///    Change the VERSION when upgrading existing contract.\nabstract contract BaseVersion is IVersion {\n    /// @dev Convert to `string` which looks prettier on Etherscan viewer.\n    function _NAME() external view virtual returns (string memory) {\n        return string(abi.encodePacked(this.NAME()));\n    }\n}\n"

    },

    "IVersion.sol": {

      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity ^0.8.19;\n\ninterface IVersion {\n    function NAME() external view returns (bytes32 name);\n\n    function VERSION() external view returns (uint256 version);\n}\n"

    }

  },

  "settings": {

    "evmVersion": "istanbul",

    "optimizer": {

      "enabled": true,

      "runs": 200

    },

    "libraries": {

      "CoboFactory.sol": {}

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    }

  }

}}