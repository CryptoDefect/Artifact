//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWXK0000KXXK0KKXNWWWWWWWWWWWWWWWWWWWW

//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWX0kkOO00KKKKK0Ok0NWWWWWWWWWWWWWWWWWWW

//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWNKOOkxkOO0KKKKKOkONWWWWWWWWWWWWWWWWWWW

//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWKxddO0K00K000OkO0KKK0kxxkKWWWWWWWWWWWWWWWWWW

//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWN0l,:okOkkO0K0kkO000OxddxKWWWWWWWWWWWWWWWWWW

//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWMNkloooxkkkkO00OkOOkxxddOXWWWWWWWWWWWWWWWWWW

//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW0dllxkxxkOkkOOxddlccd0NWWWWWWWWWWWWWWWW

//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWXkddxKXk0NWWWWKc';dOkddoddddolcclldKWWWWWWWWWWWWWWWW

//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWKo:::cc;:ccd0kc'..,lxd:;clllcccldooKWWWWWWWWWWWWWWWW

//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWXKK0d;'....,,......,;;:lO0xdoollclKWWWWWWWWWWWWWWWW

//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWN0dccc:......;clxKNNWWWNX0kxxkXWWWWWWWWWWWWWWWW

//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWXx:....oNWWWWWWWWWWWWWWWWWNNNWWWWWWWWWWWW

//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWx'...oNWWWWWMWWWNXXXXXXXKKKXNWWMWWWWWWW

//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWNx,..,xNWWMWWWWWXOO0000KKKKKKK0XWWWWWWWW

//WWWWWWWWWNXXXNWWWNKXNWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWXkl,.;ONWWWWWWMWNKkkkO0000KKK000KNWWWWWWW

//WWWWWWWWWKOOkk0XNkclkNWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWMKl,,:xXWWWWWWWNXKK0kxkO000KKKK00OONWWWWWW

//WWWWWWWWWXOxdxxxkl'':dKWWWWWWWWWWWWWWWWWWWWWWWWWWWMWWWWWWNOl;:dKWWWWWWWWWKOO0K0kxkOO0KKKKK0kOXWWWWWW

//WWWWWWWX0OOxooddl;.'',dNWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWN0o;''oXWWWNNNNNWN0OO00K00OOOO0KKK0kxxkKWWWWW

//WWWWWWWNKkxkdlooc:;'.';oONWWWWN0O0XWWWWWWWWMWWWWWWWWWWKd:,''.,ckOolllllkK0OOOkkO0KKOkO000OxdddONWWWW

//WWWWWWWWW0kkxollcx0d;''',oKWWWN0kxk0NWWWWWWWWWWWWWWWW0d:,''....,,'..'',,,,:lxkkkkO00OkOOkxxddkKWWWWW

//WWWWWWWWWWWWKOkxxKWWk,...,lxOXN0dldxkkOOKWWWWWWWWWWXOl;,'..,c;..............;lxkxxkOOkkOkxdolcxNWWWW

//WWWWWWWWWWWWWWWWWWWWO;.....',ldo:;:;'.',cxKWWWWWNOxo:,'..'ckXKxdol;....,codddxOK0kddddxxddoclxKWWWWW

//WWWWWWWWWWWWWWWWWWWWXOc''..............'',oKNWNOo:;,,'..:xKWWWWWWNKx:'.,lONWWWWWWNKKkollllccdKWWWWWW

//WWWWWWWWWWWWWWWWWWWWWWX00x:,;,,,;,;'....',;lOkl:,''.....'c0WWWWWWWWWXx:,,;lk0XNWWWWWNXKKKOdkXWWWWWWW

//WWWWWWWWWWWWWWWWWWWWWWWWWWXXXXXXXXXkl:;'..',,'',,.......,l0WWMWWWWWWWWXKkocllxKWWWWWWWWWWWNWWWWWWWWW

//WWWWWWWWWWWWWWWWWWWWWWMWWWWWWWMWWWWWNW0:..''.........:lokNWWWWWWWWWWWWWWWWNNWWWWWWWWWWWWWWWWWWWWWWWW

//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWMK:............'xWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW

//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWN0o,..........'xNWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW

//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWN0c..........,oXWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW

//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWMWWWWWWNkcc;........:KWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW

//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWN0o,......:0WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW

//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWXl......'lONWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW

//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWNNNXOl,........,cldKNWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW

//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWMWWWNKKkc;;;,.....','.....';dKNWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW

//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWX000kl;;'........',:o;......'';oO00KNWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW

//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWXOo::;,,''''''..',;:c:;,,,'.',:;,,,::cxKNWWWWWWWWWWWWWWWWWWWWWWWWWWWWW

//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWW0l:ccc:::clolc;;:lddxddocc:;:lllcccoollxXMWWWWWWWWWWWWWWWWWWWWWWWWWWWW

//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWXOxxxxdddd                    xxddxkkxxONWWWWWWWWWWWWWWWWWWWWWWWWWWWWW

//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWNK0000OOkk   POTTED-POTTED    kkkkkkkkkkk0NWWWWWWWWWWWWWWWWWWWWWWWWWWW

//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWNK00000000     Powered by     kkkkkkkkk0NWWWWWWWWWWWWWWWWWWWWWWWWWWWWW

//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWNK00000000   @tamagogi_dapp   kkkkkk0NWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW

//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWNK000OO000                    kkkkkkkxx0NWWWWWWWWWWWWWWWWWWWWWWWWWWWWW

//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWNK00OkkkOO        2022        kkkkkxdlokNWWWWWWWWWWWWWWWWWWWWWWWWWWWWW

//WWWWWWWWWWWWWWWWWWWWWWWWWMWWWWN0Okxxkkkk                    kxddolc::dXMWWWWWWWWWWWWWWWWWWWWWWWWWWWW

//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWKdc::codxxddxxddooooooooooooooolc::;;;;oXMWWWWWWWWWWWWWWWWWWWWWWWWWWWW

//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWW0c;;;;;:cc::ccc:;;;;;;;;;;;;;;;::;;;;;;oXMWWWWWWWWWWWWWWWWWWWWWWWWWWWW

//WWWWWWWWWWWWWWWWWWWWWWWWMMWWWWN0dc:::::::::::::::::::::::::::::::::cxKWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW

//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWNKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKXNWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW

//WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW

// SPDX-License-Identifier: MIT



pragma solidity ^0.8.7;



import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";

import "@openzeppelin/contracts/access/Ownable.sol";

import "@openzeppelin/contracts/utils/Strings.sol";

import "erc721a/contracts/ERC721A.sol";

import "base64-sol/base64.sol";



import "./potted_types.sol";



interface PPRenderer {

    function drawUnrevealPP(PottedTypes.Gene memory gene) external view returns (string memory);

    function drawRevealPP(PottedTypes.Gene memory gene) external view returns (string memory);

    function drawNoBgPP(PottedTypes.Gene memory gene, uint scale) external view returns (string memory);

    function getPP(PottedTypes.Gene memory gene) external view returns (PottedTypes.MyPotted memory);

}



contract PottedPotted is Ownable, ERC721A, ReentrancyGuard{

    PPRenderer public renderer = PPRenderer(0x795Fe5BA6Be2D37F08Cb96c003D57F6089103CA9);

    

    struct Config {

        uint maxPotted;

        uint publicPrice;

        uint publicMaxMint;

        address petContract;

        bytes32 claimHash;

        bytes32 presaleHash;

        Phase phase;

    }



    Config public config;

    uint private _mintedId = 1;

    uint private _teamReserve = 200;

    uint public currentReserve = 0;

    mapping(address => bool) public claimed;

    mapping(address => bool) public presaleMinted;

    mapping(address => uint) public publicMinted;

    mapping(uint => PottedTypes.Gene) public potteds;

    mapping(uint => bool) public petForReroll;



    constructor() ERC721A("POTTED-POTTED", "POTTED-POTTED") {

        config.maxPotted = 7777;

        config.publicPrice = 0;

        config.publicMaxMint = 1;

        config.petContract = 0x4C534034a06f11ECB638BF71A097c168a052a659;

        config.claimHash = 0x0;

        config.presaleHash = 0x0;

        config.phase = Phase.PAUSED;

    }



    enum Phase {

        PAUSED,

        CLAIM,

        PRESALE,

        PUBLIC,

        REVEAL

    }



    /*******

    * Event

    *******/

    event EReveal(

       uint tokenId

    );



    /*******

    * Modifier

    *******/

    modifier validToken(uint tokenId) {

        require(tokenId >= _startTokenId() && tokenId <= _totalMinted(), "Not valid id");

        _;

    }



    modifier validOwner(uint tokenId) {

        require(ownerOf(tokenId) == msg.sender, "Not token's owner");

        _;

    }



    modifier mintable(uint quantity) {

        require(_totalMinted() + quantity <= config.maxPotted, "No potted left");

        _;

    }



    modifier onlyReveal(uint tokenId) {

        require(potteds[tokenId].revealNum != 0, "Potted not reveal yet");

        _;

    }



    /*******

    * PreSale 1, maxMint is pet balance, free.

    *******/

    function claimPotted(bytes32[] calldata _proof) external {

        uint max = ERC721A(config.petContract).balanceOf(msg.sender);

        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));



        require(!claimed[msg.sender], "Claimed");

        require(config.phase == Phase.CLAIM, "Invalid phase");

        require(MerkleProof.verify(_proof, config.claimHash, leaf), "invalid proof");

        require(_totalMinted() + max <= config.maxPotted, "No potted left");

        

        _mintPotted(max);

        claimed[msg.sender] = true;

    }



    /*******

    * PreSale 2, maxMint = 1, free.

    *******/

    function getPotted(bytes32[] calldata _proof) external mintable(1) payable {

        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));



        require(!presaleMinted[msg.sender], "Minted");

        require(config.phase == Phase.PRESALE, "Invalid phase");

        require(MerkleProof.verify(_proof, config.presaleHash, leaf), "invalid proof");

        

        _mintPotted(1);

        presaleMinted[msg.sender] = true;

    }



    /*******

    * PublicSale

    *******/

    function buyPotted(uint quantity) external mintable(quantity) payable {

        require(publicMinted[msg.sender] + quantity <= config.publicMaxMint, "Exceed max buy");

        require(config.phase == Phase.PUBLIC, "Invalid phase");

        require(quantity * config.publicPrice <= msg.value, "No enough eth.");

        

        publicMinted[msg.sender] += quantity;

        _mintPotted(quantity);

    }



    /*******

    * Reveal by owner

    *******/

    function setPottedReveal(uint tokenId, uint revealNum) external validOwner(tokenId) {

        require(config.phase == Phase.REVEAL, "Not in valid phase");

        require(revealNum >= 1 && revealNum <= 8, "Out of range");

        require(potteds[tokenId].revealNum == 0, "Potted revealed");



        potteds[tokenId] = PottedTypes.Gene(potteds[tokenId].dna, revealNum, potteds[tokenId].isReroll);



        emit EReveal(tokenId);

    }



    /*******

    * Reroll by owner

    *******/

    function rerollPotted(uint tokenId, uint petId) external validToken(tokenId) validOwner(tokenId) {

        address petOwner = ERC721A(config.petContract).ownerOf(petId);

        require(petOwner == msg.sender, "Not pet owner");

        require(petId >= 1 && petId <= 3825, "Not valid Tamagogi Pets id");

        require(!petForReroll[petId], "This pet has been rerolled for potted");



        potteds[tokenId] = PottedTypes.Gene(_getRandom(tokenId), potteds[tokenId].revealNum, true);

    }



    function _mintPotted(uint quantity) private {

        for (uint i = 0; i < quantity; i++) {

            uint tokenId = _mintedId;

            uint seed = _getRandom(tokenId);



            potteds[tokenId] = PottedTypes.Gene(seed, 0, false);

            _mintedId++;

        }



        _safeMint(msg.sender, quantity);

    }



    /*******

    * PreviewPotted with no bg / only Reveal

    *******/

    function previewPottedNoBg(uint tokenId, uint scale) external onlyReveal(tokenId) validOwner(tokenId) view returns (string memory) {

        PottedTypes.Gene memory gene = potteds[tokenId];

        return renderer.drawNoBgPP(gene, scale);

    }



    /*******

    * PreviewPotted / only owner

    *******/

    function previewPotted(uint tokenId, uint revealNum) external validOwner(tokenId) view returns (string memory) {

        require(revealNum >= 1 && revealNum <= 8, "Out of range");

        PottedTypes.Gene memory gene = PottedTypes.Gene(potteds[tokenId].dna, revealNum, false);

        return renderer.drawRevealPP(gene);

    }



    function _getUnreveal(PottedTypes.Gene memory gene, PottedTypes.MyPotted memory myPotted, uint tokenId) private view returns (string memory) {

        string memory json = 

                string(

                    abi.encodePacked(

                        '{"name": "#',Strings.toString(tokenId),' Unreveal POTTED-POTTED",',

                        '"description": "Japanese-style bonsai has its charm, whether the type of pot, the direction of growth of the branches or whether flowering or not, there are multiple set of styles. POTTED-POTTED is The first on-chain generated Potted artwork.",', 

                        '"attributes": [',

                            '{ "trait_type": "background", "value": "',myPotted.bg.traitName,'"},',

                            '{ "trait_type": "potted", "value": "',myPotted.potted.traitName,'"},',

                            '{ "trait_type": "isReveal", "value": "No"}',

                        '],'

                        '"image": "data:image/svg+xml;base64,', Base64.encode(bytes(renderer.drawUnrevealPP(gene))), '"}' 

                        )

                    );



        return Base64.encode(

            bytes(

                string(json)

                )

            );

    }



    function _getReveal(PottedTypes.Gene memory gene, PottedTypes.MyPotted memory myPotted, uint tokenId) private view returns (string memory) {

        string memory json = 

                string(

                    abi.encodePacked(

                        '{"name": "#',Strings.toString(tokenId),' POTTED-POTTED",',

                        '"description": "Japanese-style bonsai has its charm, whether the type of pot, the direction of growth of the branches or whether flowering or not, there are multiple set of styles. POTTED-POTTED is The first on-chain generated Potted artwork.",', 

                        _getRevealAttr(gene, myPotted),

                        '"image": "data:image/svg+xml;base64,', Base64.encode(bytes(renderer.drawRevealPP(gene))), '"}' 

                        )

                    );



        return Base64.encode(

            bytes(

                string(json)

                )

            );

    }



    function _getRevealAttr(PottedTypes.Gene memory gene, PottedTypes.MyPotted memory myPotted) private pure returns (string memory) {

        uint blossomCount = (gene.dna + gene.revealNum - 1) % myPotted.branch.pointX.length;

        string memory json = 

                string(

                    abi.encodePacked(

                        '"attributes": [',

                            '{ "trait_type": "background", "value": "',myPotted.bg.traitName,'"},',

                            '{ "trait_type": "potted", "value": "',myPotted.potted.traitName,'"},',

                            '{ "trait_type": "branch", "value": "',myPotted.branch.traitName,'"},',

                            '{ "trait_type": "blossom", "value": "',myPotted.blossom.traitName,'"},',

                            '{ "trait_type": "blossom amount", "display_type": "number", "value": ',Strings.toString(blossomCount),'}',

                        '],'

                        )

                    );



        return json;

    }



    function _tokenURI(uint256 tokenId) private view  returns (string memory) {

        PottedTypes.Gene memory gene = potteds[tokenId];

        string memory json = potteds[tokenId].revealNum == 0 ? _getUnreveal(gene, renderer.getPP(gene), tokenId) : _getReveal(gene, renderer.getPP(gene), tokenId);



        return string(abi.encodePacked('data:application/json;base64,', json));

    }



    function tokenURI(uint256 tokenId) override (ERC721A) public view validToken(tokenId) returns (string memory) {

        return _tokenURI(tokenId);

    }



    function numberMinted(address _addr) public view returns(uint256){

        return _numberMinted(_addr);

    }



    function _startTokenId() override internal pure virtual returns (uint256) {

        return 1;

    }

    

    function _getRandom(uint tokenId) private view returns (uint) {

        uint randomlize = uint(keccak256(abi.encodePacked(blockhash(block.number - 1), tokenId, msg.sender)));

        return randomlize;

    }

    

    /*******

    * ERC721AQueryable.sol

    *******/

    function tokensOfOwner(address owner) public view virtual returns (uint256[] memory) {

        unchecked {

            uint256 tokenIdsIdx;

            address currOwnershipAddr;

            uint256 tokenIdsLength = balanceOf(owner);

            uint256[] memory tokenIds = new uint256[](tokenIdsLength);

            TokenOwnership memory ownership;

            for (uint256 i = _startTokenId(); tokenIdsIdx != tokenIdsLength; ++i) {

                ownership = _ownershipAt(i);

                if (ownership.burned) {

                    continue;

                }

                if (ownership.addr != address(0)) {

                    currOwnershipAddr = ownership.addr;

                }

                if (currOwnershipAddr == owner) {

                    tokenIds[tokenIdsIdx++] = i;

                }

            }

            return tokenIds;

        }

    }



    /*******

    * Admin function

    *******/

    function setPublicPrice(uint data) external onlyOwner {

        config.publicPrice = data;

    }

    function setPublicMaxMint(uint data) external onlyOwner {

        config.publicMaxMint = data;

    }

    function setClaimHash(bytes32 data) external onlyOwner {

        config.claimHash = data;

    }

    function setPresaleHash(bytes32 data) external onlyOwner {

        config.presaleHash = data;

    }

    function setPhase(Phase phase) external onlyOwner {

        config.phase = phase;

    }

    function setRenderContract(address _address) external onlyOwner {

        renderer = PPRenderer(_address);

    }

    function teamReserve(uint quantity) external mintable(quantity) onlyOwner {

        require(currentReserve + quantity <= _teamReserve, "Exceed max reserve");

        currentReserve += quantity;

        _mintPotted(quantity);

    }

    function withdraw() external onlyOwner nonReentrant {

        (bool success, ) = msg.sender.call{value: address(this).balance}("");

        require(success, ".");

    }

}