// SPDX-License-Identifier: GPL-3.0



pragma solidity ^0.8.7;



library SafeMath {

    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {

        unchecked {

            uint256 c = a + b;

            if (c < a) return (false, 0);

            return (true, c);

        }

    }



    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {

        unchecked {

            if (b > a) return (false, 0);

            return (true, a - b);

        }

    }



    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {

        unchecked {

            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

            // benefit is lost if 'b' is also tested.

            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522

            if (a == 0) return (true, 0);

            uint256 c = a * b;

            if (c / a != b) return (false, 0);

            return (true, c);

        }

    }



    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {

        unchecked {

            if (b == 0) return (false, 0);

            return (true, a / b);

        }

    }



    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {

        unchecked {

            if (b == 0) return (false, 0);

            return (true, a % b);

        }

    }



    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        return a + b;

    }



    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        return a - b;

    }



    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        return a * b;

    }



    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        return a / b;

    }



    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        return a % b;

    }



    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        unchecked {

            require(b <= a, errorMessage);

            return a - b;

        }

    }



    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        unchecked {

            require(b > 0, errorMessage);

            return a / b;

        }

    }



    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        unchecked {

            require(b > 0, errorMessage);

            return a % b;

        }

    }

}



interface IERC20 {

    event Transfer(address indexed from, address indexed to, uint256 value);



    event Approval(address indexed owner, address indexed spender, uint256 value);



    function totalSupply() external view returns (uint256);



    function balanceOf(address account) external view returns (uint256);



    function transfer(address to, uint256 amount) external returns (bool);



    function allowance(address owner, address spender) external view returns (uint256);



    function approve(address spender, uint256 amount) external returns (bool);



    function transferFrom(address from, address to, uint256 amount) external returns (bool);

}



interface IERC20Metadata is IERC20 {

    /**

     * @dev Returns the name of the token.

     */

    function name() external view returns (string memory);



    /**

     * @dev Returns the symbol of the token.

     */

    function symbol() external view returns (string memory);



    /**

     * @dev Returns the decimals places of the token.

     */

    function decimals() external view returns (uint8);

}



abstract contract Context {

    function _msgSender() internal view virtual returns (address) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes calldata) {

        return msg.data;

    }

}



contract ERC20 is Context, IERC20, IERC20Metadata {

    mapping(address => uint256) private _balances;



    mapping(address => mapping(address => uint256)) private _allowances;



    uint256 private _totalSupply;



    string private _name;

    string private _symbol;



    /**

     * @dev Sets the values for {name} and {symbol}.

     *

     * The default value of {decimals} is 18. To select a different value for

     * {decimals} you should overload it.

     *

     * All two of these values are immutable: they can only be set once during

     * construction.

     */

    constructor(string memory name_, string memory symbol_) {

        _name = name_;

        _symbol = symbol_;

    }



    /**

     * @dev Returns the name of the token.

     */

    function name() public view virtual override returns (string memory) {

        return _name;

    }



    /**

     * @dev Returns the symbol of the token, usually a shorter version of the

     * name.

     */

    function symbol() public view virtual override returns (string memory) {

        return _symbol;

    }



    /**

     * @dev Returns the number of decimals used to get its user representation.

     * For example, if `decimals` equals `2`, a balance of `505` tokens should

     * be displayed to a user as `5.05` (`505 / 10 ** 2`).

     *

     * Tokens usually opt for a value of 18, imitating the relationship between

     * Ether and Wei. This is the value {ERC20} uses, unless this function is

     * overridden;

     *

     * NOTE: This information is only used for _display_ purposes: it in

     * no way affects any of the arithmetic of the contract, including

     * {IERC20-balanceOf} and {IERC20-transfer}.

     */

    function decimals() public view virtual override returns (uint8) {

        return 18;

    }



    /**

     * @dev See {IERC20-totalSupply}.

     */

    function totalSupply() public view virtual override returns (uint256) {

        return _totalSupply;

    }



    /**

     * @dev See {IERC20-balanceOf}.

     */

    function balanceOf(address account) public view virtual override returns (uint256) {

        return _balances[account];

    }



    /**

     * @dev See {IERC20-transfer}.

     *

     * Requirements:

     *

     * - `to` cannot be the zero address.

     * - the caller must have a balance of at least `amount`.

     */

    function transfer(address to, uint256 amount) public virtual override returns (bool) {

        address owner = _msgSender();

        _transfer(owner, to, amount);

        return true;

    }



    /**

     * @dev See {IERC20-allowance}.

     */

    function allowance(address owner, address spender) public view virtual override returns (uint256) {

        return _allowances[owner][spender];

    }



    /**

     * @dev See {IERC20-approve}.

     *

     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on

     * `transferFrom`. This is semantically equivalent to an infinite approval.

     *

     * Requirements:

     *

     * - `spender` cannot be the zero address.

     */

    function approve(address spender, uint256 amount) public virtual override returns (bool) {

        address owner = _msgSender();

        _approve(owner, spender, amount);

        return true;

    }



    /**

     * @dev See {IERC20-transferFrom}.

     *

     * Emits an {Approval} event indicating the updated allowance. This is not

     * required by the EIP. See the note at the beginning of {ERC20}.

     *

     * NOTE: Does not update the allowance if the current allowance

     * is the maximum `uint256`.

     *

     * Requirements:

     *

     * - `from` and `to` cannot be the zero address.

     * - `from` must have a balance of at least `amount`.

     * - the caller must have allowance for ``from``'s tokens of at least

     * `amount`.

     */

    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {

        address spender = _msgSender();

        _spendAllowance(from, spender, amount);

        _transfer(from, to, amount);

        return true;

    }



    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {

        address owner = _msgSender();

        _approve(owner, spender, allowance(owner, spender) + addedValue);

        return true;

    }



    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {

        address owner = _msgSender();

        uint256 currentAllowance = allowance(owner, spender);

        require(currentAllowance >= subtractedValue, 'ERC20: decreased allowance below zero');

        unchecked {

            _approve(owner, spender, currentAllowance - subtractedValue);

        }



        return true;

    }



    function _transfer(address from, address to, uint256 amount) internal virtual {

        require(from != address(0), 'ERC20: transfer from the zero address');

        require(to != address(0), 'ERC20: transfer to the zero address');



        _beforeTokenTransfer(from, to, amount);



        uint256 fromBalance = _balances[from];

        require(fromBalance >= amount, 'ERC20: transfer amount exceeds balance');

        unchecked {

            _balances[from] = fromBalance - amount;

        }

        _balances[to] += amount;



        emit Transfer(from, to, amount);



        _afterTokenTransfer(from, to, amount);

    }



    function _mint(address account, uint256 amount) internal virtual {

        require(account != address(0), 'ERC20: mint to the zero address');



        _beforeTokenTransfer(address(0), account, amount);



        _totalSupply += amount;

        _balances[account] += amount;

        emit Transfer(address(0), account, amount);



        _afterTokenTransfer(address(0), account, amount);

    }



    function _burn(address account, uint256 amount) internal virtual {

        require(account != address(0), 'ERC20: burn from the zero address');



        _beforeTokenTransfer(account, address(0), amount);



        uint256 accountBalance = _balances[account];

        require(accountBalance >= amount, 'ERC20: burn amount exceeds balance');

        unchecked {

            _balances[account] = accountBalance - amount;

        }

        _totalSupply -= amount;



        emit Transfer(account, address(0), amount);



        _afterTokenTransfer(account, address(0), amount);

    }



    function _approve(address owner, address spender, uint256 amount) internal virtual {

        require(owner != address(0), 'ERC20: approve from the zero address');

        require(spender != address(0), 'ERC20: approve to the zero address');



        _allowances[owner][spender] = amount;

        emit Approval(owner, spender, amount);

    }



    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {

        uint256 currentAllowance = allowance(owner, spender);

        if (currentAllowance != type(uint256).max) {

            require(currentAllowance >= amount, 'ERC20: insufficient allowance');

            unchecked {

                _approve(owner, spender, currentAllowance - amount);

            }

        }

    }



    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}



    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}

}



library Strings {

    bytes16 private constant _HEX_SYMBOLS = '0123456789abcdef';

    uint8 private constant _ADDRESS_LENGTH = 20;



    function toString(uint256 value) internal pure returns (string memory) {

        if (value == 0) {

            return '0';

        }

        uint256 temp = value;

        uint256 digits;

        while (temp != 0) {

            digits++;

            temp /= 10;

        }

        bytes memory buffer = new bytes(digits);

        while (value != 0) {

            digits -= 1;

            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));

            value /= 10;

        }

        return string(buffer);

    }



    function toHexString(uint256 value) internal pure returns (string memory) {

        if (value == 0) {

            return '0x00';

        }

        uint256 temp = value;

        uint256 length = 0;

        while (temp != 0) {

            length++;

            temp >>= 8;

        }

        return toHexString(value, length);

    }



    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {

        bytes memory buffer = new bytes(2 * length + 2);

        buffer[0] = '0';

        buffer[1] = 'x';

        for (uint256 i = 2 * length + 1; i > 1; --i) {

            buffer[i] = _HEX_SYMBOLS[value & 0xf];

            value >>= 4;

        }

        require(value == 0, 'Strings: hex length insufficient');

        return string(buffer);

    }



    function toHexString(address addr) internal pure returns (string memory) {

        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);

    }

}



library ECDSA {

    enum RecoverError {

        NoError,

        InvalidSignature,

        InvalidSignatureLength,

        InvalidSignatureS,

        InvalidSignatureV

    }



    function _throwError(RecoverError error) private pure {

        if (error == RecoverError.NoError) {

            return; // no error: do nothing

        } else if (error == RecoverError.InvalidSignature) {

            revert('ECDSA: invalid signature');

        } else if (error == RecoverError.InvalidSignatureLength) {

            revert('ECDSA: invalid signature length');

        } else if (error == RecoverError.InvalidSignatureS) {

            revert("ECDSA: invalid signature 's' value");

        } else if (error == RecoverError.InvalidSignatureV) {

            revert("ECDSA: invalid signature 'v' value");

        }

    }



    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {

        if (signature.length == 65) {

            bytes32 r;

            bytes32 s;

            uint8 v;



            assembly {

                r := mload(add(signature, 0x20))

                s := mload(add(signature, 0x40))

                v := byte(0, mload(add(signature, 0x60)))

            }

            return tryRecover(hash, v, r, s);

        } else {

            return (address(0), RecoverError.InvalidSignatureLength);

        }

    }



    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {

        (address recovered, RecoverError error) = tryRecover(hash, signature);

        _throwError(error);

        return recovered;

    }



    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {

        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);

        uint8 v = uint8((uint256(vs) >> 255) + 27);

        return tryRecover(hash, v, r, s);

    }



    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {

        (address recovered, RecoverError error) = tryRecover(hash, r, vs);

        _throwError(error);

        return recovered;

    }



    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {

        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {

            return (address(0), RecoverError.InvalidSignatureS);

        }

        if (v != 27 && v != 28) {

            return (address(0), RecoverError.InvalidSignatureV);

        }



        address signer = ecrecover(hash, v, r, s);

        if (signer == address(0)) {

            return (address(0), RecoverError.InvalidSignature);

        }



        return (signer, RecoverError.NoError);

    }



    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {

        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);

        _throwError(error);

        return recovered;

    }



    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {

        return keccak256(abi.encodePacked('\x19Ethereum Signed Message:\n32', hash));

    }



    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {

        return keccak256(abi.encodePacked('\x19Ethereum Signed Message:\n', Strings.toString(s.length), s));

    }



    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {

        return keccak256(abi.encodePacked('\x19\x01', domainSeparator, structHash));

    }

}



abstract contract EIP712 {

    /* solhint-disable var-name-mixedcase */

    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;

    uint256 private immutable _CACHED_CHAIN_ID;

    address private immutable _CACHED_THIS;



    bytes32 private immutable _HASHED_NAME;

    bytes32 private immutable _HASHED_VERSION;

    bytes32 private immutable _TYPE_HASH;



    constructor(string memory name, string memory version) {

        bytes32 hashedName = keccak256(bytes(name));

        bytes32 hashedVersion = keccak256(bytes(version));

        bytes32 typeHash = keccak256(

            'EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'

        );

        _HASHED_NAME = hashedName;

        _HASHED_VERSION = hashedVersion;

        _CACHED_CHAIN_ID = block.chainid;

        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);

        _CACHED_THIS = address(this);

        _TYPE_HASH = typeHash;

    }



    function _domainSeparatorV4() internal view returns (bytes32) {

        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {

            return _CACHED_DOMAIN_SEPARATOR;

        } else {

            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);

        }

    }



    function _buildDomainSeparator(

        bytes32 typeHash,

        bytes32 nameHash,

        bytes32 versionHash

    ) private view returns (bytes32) {

        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));

    }



    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {

        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);

    }

}



contract PLSXIOUToken is ERC20, EIP712 {

    using SafeMath for uint256;

    string private constant SIGNING_DOMAIN = 'PLSXIOU-VOUCHER';

    string private constant SIGNATURE_VERSION = '1';



    struct Voucher {

        address from;

        address to;

        uint256 amount;

        bytes signature;

    }



    constructor() ERC20('PulseX IOU', 'PLSXIOU') EIP712(SIGNING_DOMAIN, SIGNATURE_VERSION) {

        _mint(msg.sender, 1000000000 * 10 ** 18);

    }



    function burn(uint256 amount) external {

        _burn(msg.sender, amount);

    }



    function bulkTransfer(address[] calldata accounts, uint256[] calldata amounts) external {

        for (uint256 i = 0; i < accounts.length; i++) {

            transfer(accounts[i], amounts[i]);

        }

    }



    function permit(Voucher calldata voucher) external {

        address signer = _verify(voucher);

        require(signer == voucher.from, 'Invalid signature');



        _approve(voucher.from, voucher.to, voucher.amount);

    }



    function _hash(Voucher calldata voucher) internal view returns (bytes32) {

        return

            _hashTypedDataV4(

                keccak256(

                    abi.encode(

                        keccak256('Voucher(address from,address to,uint256 amount)'),

                        voucher.from,

                        voucher.to,

                        voucher.amount

                    )

                )

            );

    }



    function _verify(Voucher calldata voucher) internal view returns (address) {

        bytes32 digest = _hash(voucher);

        return ECDSA.recover(digest, voucher.signature);

    }

}