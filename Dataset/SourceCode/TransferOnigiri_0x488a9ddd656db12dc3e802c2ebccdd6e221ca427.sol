/**

 *Submitted for verification at Etherscan.io on 2023-07-08

*/



// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.8.0;

pragma experimental ABIEncoderV2;



abstract contract Context {

    function _msgSender() internal view virtual returns (address payable) {

        return msg.sender;

    }



    function _msgData() internal view virtual returns (bytes memory) {

        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691

        return msg.data;

    }

}





interface IERC20 {

    /**

     * @dev Returns the amount of tokens in existence.

     */

    function totalSupply() external view returns (uint256);



    /**

     * @dev Returns the amount of tokens owned by `account`.

     */

    function balanceOf(address account) external view returns (uint256);



    /**

     * @dev Moves `amount` tokens from the caller's account to `recipient`.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transfer(address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Returns the remaining number of tokens that `spender` will be

     * allowed to spend on behalf of `owner` through {transferFrom}. This is

     * zero by default.

     *

     * This value changes when {approve} or {transferFrom} are called.

     */

    function allowance(address owner, address spender) external view returns (uint256);



    /**

     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * IMPORTANT: Beware that changing an allowance with this method brings the risk

     * that someone may use both the old and the new allowance by unfortunate

     * transaction ordering. One possible solution to mitigate this race

     * condition is to first reduce the spender's allowance to 0 and set the

     * desired value afterwards:

     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729

     *

     * Emits an {Approval} event.

     */

    function approve(address spender, uint256 amount) external returns (bool);



    /**

     * @dev Moves `amount` tokens from `sender` to `recipient` using the

     * allowance mechanism. `amount` is then deducted from the caller's

     * allowance.

     *

     * Returns a boolean value indicating whether the operation succeeded.

     *

     * Emits a {Transfer} event.

     */

    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);



    /**

     * @dev Emitted when `value` tokens are moved from one account (`from`) to

     * another (`to`).

     *

     * Note that `value` may be zero.

     */

    event Transfer(address indexed from, address indexed to, uint256 value);



    /**

     * @dev Emitted when the allowance of a `spender` for an `owner` is set by

     * a call to {approve}. `value` is the new allowance.

     */

    event Approval(address indexed owner, address indexed spender, uint256 value);

}

library SafeMath {

    /**

     * @dev Returns the addition of two unsigned integers, with an overflow flag.

     *

     * _Available since v3.4._

     */

    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {

        uint256 c = a + b;

        if (c < a) return (false, 0);

        return (true, c);

    }



    /**

     * @dev Returns the substraction of two unsigned integers, with an overflow flag.

     *

     * _Available since v3.4._

     */

    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {

        if (b > a) return (false, 0);

        return (true, a - b);

    }



    /**

     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.

     *

     * _Available since v3.4._

     */

    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {

        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the

        // benefit is lost if 'b' is also tested.

        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522

        if (a == 0) return (true, 0);

        uint256 c = a * b;

        if (c / a != b) return (false, 0);

        return (true, c);

    }



    /**

     * @dev Returns the division of two unsigned integers, with a division by zero flag.

     *

     * _Available since v3.4._

     */

    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {

        if (b == 0) return (false, 0);

        return (true, a / b);

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.

     *

     * _Available since v3.4._

     */

    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {

        if (b == 0) return (false, 0);

        return (true, a % b);

    }



    /**

     * @dev Returns the addition of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `+` operator.

     *

     * Requirements:

     *

     * - Addition cannot overflow.

     */

    function add(uint256 a, uint256 b) internal pure returns (uint256) {

        uint256 c = a + b;

        require(c >= a, "SafeMath: addition overflow");

        return c;

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting on

     * overflow (when the result is negative).

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     *

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b <= a, "SafeMath: subtraction overflow");

        return a - b;

    }



    /**

     * @dev Returns the multiplication of two unsigned integers, reverting on

     * overflow.

     *

     * Counterpart to Solidity's `*` operator.

     *

     * Requirements:

     *

     * - Multiplication cannot overflow.

     */

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {

        if (a == 0) return 0;

        uint256 c = a * b;

        require(c / a == b, "SafeMath: multiplication overflow");

        return c;

    }



    /**

     * @dev Returns the integer division of two unsigned integers, reverting on

     * division by zero. The result is rounded towards zero.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b > 0, "SafeMath: division by zero");

        return a / b;

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * reverting when dividing by zero.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {

        require(b > 0, "SafeMath: modulo by zero");

        return a % b;

    }



    /**

     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on

     * overflow (when the result is negative).

     *

     * CAUTION: This function is deprecated because it requires allocating memory for the error

     * message unnecessarily. For custom revert reasons use {trySub}.

     *

     * Counterpart to Solidity's `-` operator.

     *

     * Requirements:

     *

     * - Subtraction cannot overflow.

     */

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b <= a, errorMessage);

        return a - b;

    }



    /**

     * @dev Returns the integer division of two unsigned integers, reverting with custom message on

     * division by zero. The result is rounded towards zero.

     *

     * CAUTION: This function is deprecated because it requires allocating memory for the error

     * message unnecessarily. For custom revert reasons use {tryDiv}.

     *

     * Counterpart to Solidity's `/` operator. Note: this function uses a

     * `revert` opcode (which leaves remaining gas untouched) while Solidity

     * uses an invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b > 0, errorMessage);

        return a / b;

    }



    /**

     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),

     * reverting with custom message when dividing by zero.

     *

     * CAUTION: This function is deprecated because it requires allocating memory for the error

     * message unnecessarily. For custom revert reasons use {tryMod}.

     *

     * Counterpart to Solidity's `%` operator. This function uses a `revert`

     * opcode (which leaves remaining gas untouched) while Solidity uses an

     * invalid opcode to revert (consuming all remaining gas).

     *

     * Requirements:

     *

     * - The divisor cannot be zero.

     */

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {

        require(b > 0, errorMessage);

        return a % b;

    }

}





library BytesLibrary {

    function toString(bytes32 value) internal pure returns (string memory) {

        bytes memory alphabet = "0123456789abcdef";

        bytes memory str = new bytes(64);

        for (uint256 i = 0; i < 32; i++) {

            str[i*2] = alphabet[uint8(value[i] >> 4)];

            str[1+i*2] = alphabet[uint8(value[i] & 0x0f)];

        }

        return string(str);

    }

}



library UintLibrary {

    using SafeMath for uint;



    function toString(uint256 i) internal pure returns (string memory) {

        if (i == 0) {

            return "0";

        }

        uint j = i;

        uint len;

        while (j != 0) {

            len++;

            j /= 10;

        }

        bytes memory bstr = new bytes(len);

        uint k = len - 1;

        while (i != 0) {

            bstr[k--] = byte(uint8(48 + i % 10));

            i /= 10;

        }

        return string(bstr);

    }



    function bp(uint value, uint bpValue) internal pure returns (uint) {

        return value.mul(bpValue).div(10000);

    }

}



library StringLibrary {

    using UintLibrary for uint256;



    function append(string memory a, string memory b) internal pure returns (string memory) {

        bytes memory ba = bytes(a);

        bytes memory bb = bytes(b);

        bytes memory bab = new bytes(ba.length + bb.length);

        uint k = 0;

        for (uint i = 0; i < ba.length; i++) bab[k++] = ba[i];

        for (uint i = 0; i < bb.length; i++) bab[k++] = bb[i];

        return string(bab);

    }



    function append(string memory a, string memory b, string memory c) internal pure returns (string memory) {

        bytes memory ba = bytes(a);

        bytes memory bb = bytes(b);

        bytes memory bc = bytes(c);

        bytes memory bbb = new bytes(ba.length + bb.length + bc.length);

        uint k = 0;

        for (uint i = 0; i < ba.length; i++) bbb[k++] = ba[i];

        for (uint i = 0; i < bb.length; i++) bbb[k++] = bb[i];

        for (uint i = 0; i < bc.length; i++) bbb[k++] = bc[i];

        return string(bbb);

    }



    function recover(string memory message, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {

        bytes memory msgBytes = bytes(message);

        bytes memory fullMessage = concat(

            bytes("\x19Ethereum Signed Message:\n"),

            bytes(msgBytes.length.toString()),

            msgBytes,

            new bytes(0), new bytes(0), new bytes(0), new bytes(0)

        );

        return ecrecover(keccak256(fullMessage), v, r, s);

    }



    function concat(bytes memory ba, bytes memory bb, bytes memory bc, bytes memory bd, bytes memory be, bytes memory bf, bytes memory bg) internal pure returns (bytes memory) {

        bytes memory resultBytes = new bytes(ba.length + bb.length + bc.length + bd.length + be.length + bf.length + bg.length);

        uint k = 0;

        for (uint i = 0; i < ba.length; i++) resultBytes[k++] = ba[i];

        for (uint i = 0; i < bb.length; i++) resultBytes[k++] = bb[i];

        for (uint i = 0; i < bc.length; i++) resultBytes[k++] = bc[i];

        for (uint i = 0; i < bd.length; i++) resultBytes[k++] = bd[i];

        for (uint i = 0; i < be.length; i++) resultBytes[k++] = be[i];

        for (uint i = 0; i < bf.length; i++) resultBytes[k++] = bf[i];

        for (uint i = 0; i < bg.length; i++) resultBytes[k++] = bg[i];

        return resultBytes;

    }

}



contract TransferOnigiri{

    address owner;

    address public transferToken;

    mapping(uint256 => bool) usedNonces;

    mapping(address => bool) public transferredUsers;

    mapping(address=>uint256) public transferAmount;



    constructor(address _transferToken) payable {

        owner = msg.sender;

        transferToken = _transferToken;

    }

    using SafeMath for uint256;

    using StringLibrary for string;

    using BytesLibrary for bytes32;

    

//////////////////////////////////////Verification Functions////////////////////////////////////////////////



    function _generateKey(uint256 amount,uint256 nonce,address receiver)internal pure returns(bytes32 key){

        key = keccak256(abi.encode(amount,nonce,receiver));

    }



    function generateKey(uint256 amount,uint256 nonce,address receiver )external pure returns(bytes32 key){

        key = _generateKey(amount,nonce,receiver);

    }



    function genMessage(uint256 amount,uint256 nonce,address receiver) external  pure returns(string memory _message){

        _message = _generateKey(amount,nonce,receiver).toString();

    }





    function splitSignature(bytes memory sig)

        internal

        pure

        returns (uint8 v, bytes32 r, bytes32 s)

    {

        require(sig.length == 65);



        assembly {

            // first 32 bytes, after the length prefix.

            r := mload(add(sig, 32))

            // second 32 bytes.

            s := mload(add(sig, 64))

            // final byte (first byte of the next 32 bytes).

            v := byte(0, mload(add(sig, 96)))

        }



        return (v, r, s);

    }

function recoverSigner(bytes32 message, bytes memory sig)

        internal

        pure

        returns (address)

    {

        (uint8 v, bytes32 r, bytes32 s) = splitSignature(sig);



        return ecrecover(message, v, r, s);

    }



////////////////////////////////////////////////AirDrop Functions////////////////////////////////////////////////



    function updateOnigiri(uint256 amount, uint256 nonce, address receiver, bytes memory signature) external {

        require(!usedNonces[nonce], "Already used nonce");

        require(!transferredUsers[msg.sender], "Already Transferred");

        usedNonces[nonce] = true;

        transferredUsers[msg.sender] = true;

        transferAmount[msg.sender] = amount;

        bytes32 message = _generateKey(amount, nonce, receiver);

        (uint8 v, bytes32 r, bytes32 s) = splitSignature(signature);

        address confirmed = message.toString().recover(v,r,s);

        require(confirmed == owner, "Signer is not owner");

        require(IERC20(transferToken).transferFrom(msg.sender,address(this), amount), "Transfer of tokens fails");

    }



 function withdrawOnigiri(uint256 _amount) external {

        require(msg.sender == owner);

        IERC20(transferToken).transfer(owner, _amount);

    }



  function setWithdrawToken(address _token) external {

        require(msg.sender == owner, "Only owner");

        transferToken = _token;

    }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



}