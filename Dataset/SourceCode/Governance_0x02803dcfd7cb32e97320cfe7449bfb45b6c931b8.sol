{{

  "language": "Solidity",

  "sources": {

    "polygongovernance/contracts/Governance.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.3;\n\nimport \"./interfaces/IOracle.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"usingtellor/contracts/UsingTellor.sol\";\n\n/**\n @author Tellor Inc.\n @title Governance\n @dev This is a governance contract to be used with TellorFlex. It handles disputing\n * Tellor oracle data and voting on those disputes\n*/\ncontract Governance is UsingTellor {\n    // Storage\n    IOracle public oracle; // Tellor oracle contract\n    IERC20 public token; // token used for dispute fees, same as reporter staking token\n    address public oracleAddress; //tellorFlex address\n    address public teamMultisig; // address of team multisig wallet, one of four stakeholder groups\n    uint256 public voteCount; // total number of votes initiated\n    bytes32 public autopayAddrsQueryId =\n        keccak256(abi.encode(\"AutopayAddresses\", abi.encode(bytes(\"\")))); // query id for autopay addresses array\n    mapping(uint256 => Dispute) private disputeInfo; // mapping of dispute IDs to the details of the dispute\n    mapping(bytes32 => uint256) private openDisputesOnId; // mapping of a query ID to the number of disputes on that query ID\n    mapping(uint256 => Vote) private voteInfo; // mapping of dispute IDs to the details of the vote\n    mapping(bytes32 => uint256[]) private voteRounds; // mapping of vote identifier hashes to an array of dispute IDs\n    mapping(address => uint256) private voteTallyByAddress; // mapping of addresses to the number of votes they have cast\n    mapping(address => uint256[]) private disputeIdsByReporter; // mapping of reporter addresses to an array of dispute IDs\n\n    enum VoteResult {\n        FAILED,\n        PASSED,\n        INVALID\n    } // status of a potential vote\n\n    // Structs\n    struct Dispute {\n        bytes32 queryId; // query ID of disputed value\n        uint256 timestamp; // timestamp of disputed value\n        bytes value; // disputed value\n        address disputedReporter; // reporter who submitted the disputed value\n        uint256 slashedAmount; // amount of tokens slashed from reporter\n    }\n\n    struct Tally {\n        uint256 doesSupport; // number of votes in favor\n        uint256 against; // number of votes against\n        uint256 invalidQuery; // number of votes for invalid\n    }\n\n    struct Vote {\n        bytes32 identifierHash; // identifier hash of the vote\n        uint256 voteRound; // the round of voting on a given dispute or proposal\n        uint256 startDate; // timestamp of when vote was initiated\n        uint256 blockNumber; // block number of when vote was initiated\n        uint256 fee; // fee paid to initiate the vote round\n        uint256 tallyDate; // timestamp of when the votes were tallied\n        Tally tokenholders; // vote tally of tokenholders\n        Tally users; // vote tally of users\n        Tally reporters; // vote tally of reporters\n        Tally teamMultisig; // vote tally of teamMultisig\n        bool executed; // boolean of whether the vote was executed\n        VoteResult result; // VoteResult after votes were tallied\n        address initiator; // address which initiated dispute/proposal\n        mapping(address => bool) voted; // mapping of address to whether or not they voted\n    }\n\n    // Events\n    event NewDispute(\n        uint256 _disputeId,\n        bytes32 _queryId,\n        uint256 _timestamp,\n        address _reporter\n    ); // Emitted when a new dispute is opened\n\n    event Voted(\n        uint256 _disputeId,\n        bool _supports,\n        address _voter,\n        bool _invalidQuery\n    ); // Emitted when an address casts their vote\n    event VoteExecuted(uint256 _disputeId, VoteResult _result); // Emitted when a vote is executed\n    event VoteTallied(\n        uint256 _disputeId,\n        VoteResult _result,\n        address _initiator,\n        address _reporter\n    ); // Emitted when all casting for a vote is tallied\n\n    /**\n     * @dev Initializes contract parameters\n     * @param _tellor address of tellor oracle contract to be governed\n     * @param _teamMultisig address of tellor team multisig, one of four voting\n     * stakeholder groups\n     */\n    constructor(address payable _tellor, address _teamMultisig)\n        UsingTellor(_tellor)\n    {\n        oracle = IOracle(_tellor);\n        token = IERC20(oracle.getTokenAddress());\n        oracleAddress = _tellor;\n        teamMultisig = _teamMultisig;\n    }\n\n    /**\n     * @dev Initializes a dispute/vote in the system\n     * @param _queryId being disputed\n     * @param _timestamp being disputed\n     */\n    function beginDispute(bytes32 _queryId, uint256 _timestamp) external {\n        // Ensure value actually exists\n        require(\n            oracle.getBlockNumberByTimestamp(_queryId, _timestamp) != 0,\n            \"no value exists at given timestamp\"\n        );\n        bytes32 _hash = keccak256(abi.encodePacked(_queryId, _timestamp));\n        // Push new vote round\n        uint256 _disputeId = voteCount + 1;\n        uint256[] storage _voteRounds = voteRounds[_hash];\n        _voteRounds.push(_disputeId);\n\n        // Create new vote and dispute\n        Vote storage _thisVote = voteInfo[_disputeId];\n        Dispute storage _thisDispute = disputeInfo[_disputeId];\n\n        // Initialize dispute information - query ID, timestamp, value, etc.\n        _thisDispute.queryId = _queryId;\n        _thisDispute.timestamp = _timestamp;\n        _thisDispute.disputedReporter = oracle.getReporterByTimestamp(\n            _queryId,\n            _timestamp\n        );\n        // Initialize vote information - hash, initiator, block number, etc.\n        _thisVote.identifierHash = _hash;\n        _thisVote.initiator = msg.sender;\n        _thisVote.blockNumber = block.number;\n        _thisVote.startDate = block.timestamp;\n        _thisVote.voteRound = _voteRounds.length;\n        disputeIdsByReporter[_thisDispute.disputedReporter].push(_disputeId);\n        uint256 _disputeFee = getDisputeFee();\n        if (_voteRounds.length == 1) {\n            require(\n                block.timestamp - _timestamp < 12 hours,\n                \"Dispute must be started within reporting lock time\"\n            );\n            openDisputesOnId[_queryId]++;\n            // calculate dispute fee based on number of open disputes on query ID\n            _disputeFee = _disputeFee * 2**(openDisputesOnId[_queryId] - 1);\n            // slash a single stakeAmount from reporter\n            _thisDispute.slashedAmount = oracle.slashReporter(_thisDispute.disputedReporter, address(this));\n            _thisDispute.value = oracle.retrieveData(_queryId, _timestamp);\n            oracle.removeValue(_queryId, _timestamp);\n        } else {\n            uint256 _prevId = _voteRounds[_voteRounds.length - 2];\n            require(\n                block.timestamp - voteInfo[_prevId].tallyDate < 1 days,\n                \"New dispute round must be started within a day\"\n            );\n            _disputeFee = _disputeFee * 2**(_voteRounds.length - 1);\n            _thisDispute.slashedAmount = disputeInfo[_voteRounds[0]].slashedAmount;\n            _thisDispute.value = disputeInfo[_voteRounds[0]].value;\n        }\n        _thisVote.fee = _disputeFee;\n        voteCount++;\n        require(\n            token.transferFrom(msg.sender, address(this), _disputeFee),\n            \"Fee must be paid\"\n        ); // This is the dispute fee. Returned if dispute passes\n        emit NewDispute(\n            _disputeId,\n            _queryId,\n            _timestamp,\n            _thisDispute.disputedReporter\n        );\n    }\n\n    /**\n     * @dev Executes vote and transfers corresponding balances to initiator/reporter\n     * @param _disputeId is the ID of the vote being executed\n     */\n    function executeVote(uint256 _disputeId) external {\n        // Ensure validity of vote ID, vote has been executed, and vote must be tallied\n        Vote storage _thisVote = voteInfo[_disputeId];\n        require(_disputeId <= voteCount && _disputeId > 0, \"Dispute ID must be valid\");\n        require(!_thisVote.executed, \"Vote has already been executed\");\n        require(_thisVote.tallyDate > 0, \"Vote must be tallied\");\n        // Ensure vote must be final vote and that time has to be pass (86400 = 24 * 60 * 60 for seconds in a day)\n        require(\n            voteRounds[_thisVote.identifierHash].length == _thisVote.voteRound,\n            \"Must be the final vote\"\n        );\n        //The time  has to pass after the vote is tallied\n        require(\n            block.timestamp - _thisVote.tallyDate >= 1 days,\n            \"1 day has to pass after tally to allow for disputes\"\n        );\n        _thisVote.executed = true;\n        Dispute storage _thisDispute = disputeInfo[_disputeId];\n        openDisputesOnId[_thisDispute.queryId]--;\n        uint256 _i;\n        uint256 _voteID;\n        if (_thisVote.result == VoteResult.PASSED) {\n            // If vote is in dispute and passed, iterate through each vote round and transfer the dispute to initiator\n            for (\n                _i = voteRounds[_thisVote.identifierHash].length;\n                _i > 0;\n                _i--\n            ) {\n                _voteID = voteRounds[_thisVote.identifierHash][_i - 1];\n                _thisVote = voteInfo[_voteID];\n                // If the first vote round, also make sure to transfer the reporter's slashed stake to the initiator\n                if (_i == 1) {\n                    token.transfer(\n                        _thisVote.initiator,\n                        _thisDispute.slashedAmount\n                    );\n                }\n                token.transfer(_thisVote.initiator, _thisVote.fee);\n            }\n        } else if (_thisVote.result == VoteResult.INVALID) {\n            // If vote is in dispute and is invalid, iterate through each vote round and transfer the dispute fee to initiator\n            for (\n                _i = voteRounds[_thisVote.identifierHash].length;\n                _i > 0;\n                _i--\n            ) {\n                _voteID = voteRounds[_thisVote.identifierHash][_i - 1];\n                _thisVote = voteInfo[_voteID];\n                token.transfer(_thisVote.initiator, _thisVote.fee);\n            }\n            // Transfer slashed tokens back to disputed reporter\n            token.transfer(\n                _thisDispute.disputedReporter,\n                _thisDispute.slashedAmount\n            );\n        } else if (_thisVote.result == VoteResult.FAILED) {\n            // If vote is in dispute and fails, iterate through each vote round and transfer the dispute fee to disputed reporter\n            uint256 _reporterReward = 0;\n            for (\n                _i = voteRounds[_thisVote.identifierHash].length;\n                _i > 0;\n                _i--\n            ) {\n                _voteID = voteRounds[_thisVote.identifierHash][_i - 1];\n                _thisVote = voteInfo[_voteID];\n                _reporterReward += _thisVote.fee;\n            }\n            _reporterReward += _thisDispute.slashedAmount;\n            token.transfer(_thisDispute.disputedReporter, _reporterReward);\n        }\n        emit VoteExecuted(_disputeId, voteInfo[_disputeId].result);\n    }\n\n    /**\n     * @dev Tallies the votes and begins the 1 day challenge period\n     * @param _disputeId is the dispute id\n     */\n    function tallyVotes(uint256 _disputeId) external {\n        // Ensure vote has not been executed and that vote has not been tallied\n        Vote storage _thisVote = voteInfo[_disputeId];\n        require(_thisVote.tallyDate == 0, \"Vote has already been tallied\");\n        require(_disputeId <= voteCount && _disputeId > 0, \"Vote does not exist\");\n        // Determine appropriate vote duration dispute round\n        // Vote time increases as rounds increase but only up to 6 days (withdrawal period)\n        require(\n            block.timestamp - _thisVote.startDate >=\n                86400 * _thisVote.voteRound ||\n                block.timestamp - _thisVote.startDate >= 86400 * 6,\n            \"Time for voting has not elapsed\"\n        );\n        // Get total votes from each separate stakeholder group.  This will allow\n        // normalization so each group's votes can be combined and compared to\n        // determine the vote outcome.\n        uint256 _tokenVoteSum = _thisVote.tokenholders.doesSupport +\n            _thisVote.tokenholders.against +\n            _thisVote.tokenholders.invalidQuery;\n        uint256 _reportersVoteSum = _thisVote.reporters.doesSupport +\n            _thisVote.reporters.against +\n            _thisVote.reporters.invalidQuery;\n        uint256 _multisigVoteSum = _thisVote.teamMultisig.doesSupport +\n            _thisVote.teamMultisig.against +\n            _thisVote.teamMultisig.invalidQuery;\n        uint256 _usersVoteSum = _thisVote.users.doesSupport +\n            _thisVote.users.against +\n            _thisVote.users.invalidQuery;\n        // Cannot divide by zero\n        if (_tokenVoteSum == 0) {\n            _tokenVoteSum++;\n        }\n        if (_reportersVoteSum == 0) {\n            _reportersVoteSum++;\n        }\n        if (_multisigVoteSum == 0) {\n            _multisigVoteSum++;\n        }\n        if (_usersVoteSum == 0) {\n            _usersVoteSum++;\n        }\n        // Normalize and combine each stakeholder group votes\n        uint256 _scaledDoesSupport = ((_thisVote.tokenholders.doesSupport *\n            1e18) / _tokenVoteSum) +\n            ((_thisVote.reporters.doesSupport * 1e18) / _reportersVoteSum) +\n            ((_thisVote.teamMultisig.doesSupport * 1e18) / _multisigVoteSum) +\n            ((_thisVote.users.doesSupport * 1e18) / _usersVoteSum);\n        uint256 _scaledAgainst = ((_thisVote.tokenholders.against * 1e18) /\n            _tokenVoteSum) +\n            ((_thisVote.reporters.against * 1e18) / _reportersVoteSum) +\n            ((_thisVote.teamMultisig.against * 1e18) / _multisigVoteSum) +\n            ((_thisVote.users.against * 1e18) / _usersVoteSum);\n        uint256 _scaledInvalid = ((_thisVote.tokenholders.invalidQuery * 1e18) /\n            _tokenVoteSum) +\n            ((_thisVote.reporters.invalidQuery * 1e18) / _reportersVoteSum) +\n            ((_thisVote.teamMultisig.invalidQuery * 1e18) / _multisigVoteSum) +\n            ((_thisVote.users.invalidQuery * 1e18) / _usersVoteSum);\n\n        // If votes in support outweight the sum of against and invalid, result is passed\n        if (_scaledDoesSupport > _scaledAgainst + _scaledInvalid) {\n            _thisVote.result = VoteResult.PASSED;\n        // If votes in against outweight the sum of support and invalid, result is failed\n        } else if (_scaledAgainst > _scaledDoesSupport + _scaledInvalid) {\n            _thisVote.result = VoteResult.FAILED;\n        // Otherwise, result is invalid\n        } else {\n            _thisVote.result = VoteResult.INVALID;\n        }\n\n        _thisVote.tallyDate = block.timestamp; // Update time vote was tallied\n        emit VoteTallied(\n            _disputeId,\n            _thisVote.result,\n            _thisVote.initiator,\n            disputeInfo[_disputeId].disputedReporter\n        );\n    }\n\n    /**\n     * @dev Enables the sender address to cast a vote\n     * @param _disputeId is the ID of the vote\n     * @param _supports is the address's vote: whether or not they support or are against\n     * @param _invalidQuery is whether or not the dispute is valid\n     */\n    function vote(\n        uint256 _disputeId,\n        bool _supports,\n        bool _invalidQuery\n    ) external {\n        // Ensure that dispute has not been executed and that vote does not exist and is not tallied\n        require(_disputeId <= voteCount && _disputeId > 0, \"Vote does not exist\");\n        Vote storage _thisVote = voteInfo[_disputeId];\n        require(_thisVote.tallyDate == 0, \"Vote has already been tallied\");\n        require(!_thisVote.voted[msg.sender], \"Sender has already voted\");\n        // Update voting status and increment total queries for support, invalid, or against based on vote\n        _thisVote.voted[msg.sender] = true;\n        uint256 _tokenBalance = token.balanceOf(msg.sender);\n        (, uint256 _stakedBalance, uint256 _lockedBalance, , , , , ) = oracle.getStakerInfo(msg.sender);\n        _tokenBalance += _stakedBalance + _lockedBalance;\n        if (_invalidQuery) {\n            _thisVote.tokenholders.invalidQuery += _tokenBalance;\n            _thisVote.reporters.invalidQuery += oracle\n                .getReportsSubmittedByAddress(msg.sender);\n            _thisVote.users.invalidQuery += _getUserTips(msg.sender);\n            if (msg.sender == teamMultisig) {\n                _thisVote.teamMultisig.invalidQuery += 1;\n            }\n        } else if (_supports) {\n            _thisVote.tokenholders.doesSupport += _tokenBalance;\n            _thisVote.reporters.doesSupport += oracle.getReportsSubmittedByAddress(msg.sender);\n            _thisVote.users.doesSupport += _getUserTips(msg.sender);\n            if (msg.sender == teamMultisig) {\n                _thisVote.teamMultisig.doesSupport += 1;\n            }\n        } else {\n            _thisVote.tokenholders.against += _tokenBalance;\n            _thisVote.reporters.against += oracle.getReportsSubmittedByAddress(\n                msg.sender\n            );\n            _thisVote.users.against += _getUserTips(msg.sender);\n            if (msg.sender == teamMultisig) {\n                _thisVote.teamMultisig.against += 1;\n            }\n        }\n        voteTallyByAddress[msg.sender]++;\n        emit Voted(_disputeId, _supports, msg.sender, _invalidQuery);\n    }\n\n    // *****************************************************************************\n    // *                                                                           *\n    // *                               Getters                                     *\n    // *                                                                           *\n    // *****************************************************************************\n\n    /**\n     * @dev Determines if an address voted for a specific vote\n     * @param _disputeId is the ID of the vote\n     * @param _voter is the address of the voter to check for\n     * @return bool of whether or note the address voted for the specific vote\n     */\n    function didVote(uint256 _disputeId, address _voter)\n        external\n        view\n        returns (bool)\n    {\n        return voteInfo[_disputeId].voted[_voter];\n    }\n\n    /**\n     * @dev Get the latest dispute fee\n     */\n    function getDisputeFee() public view returns (uint256) {\n        return (oracle.getStakeAmount() / 10);\n    }\n\n\n    function getDisputesByReporter(address _reporter) external view returns (uint256[] memory) {\n        return disputeIdsByReporter[_reporter];\n    }\n\n    /**\n     * @dev Returns info on a dispute for a given ID\n     * @param _disputeId is the ID of a specific dispute\n     * @return bytes32 of the data ID of the dispute\n     * @return uint256 of the timestamp of the dispute\n     * @return bytes memory of the value being disputed\n     * @return address of the reporter being disputed\n     */\n    function getDisputeInfo(uint256 _disputeId)\n        external\n        view\n        returns (\n            bytes32,\n            uint256,\n            bytes memory,\n            address\n        )\n    {\n        Dispute storage _d = disputeInfo[_disputeId];\n        return (_d.queryId, _d.timestamp, _d.value, _d.disputedReporter);\n    }\n\n    /**\n     * @dev Returns the number of open disputes for a specific query ID\n     * @param _queryId is the ID of a specific data feed\n     * @return uint256 of the number of open disputes for the query ID\n     */\n    function getOpenDisputesOnId(bytes32 _queryId)\n        external\n        view\n        returns (uint256)\n    {\n        return openDisputesOnId[_queryId];\n    }\n\n    /**\n     * @dev Returns the total number of votes\n     * @return uint256 of the total number of votes\n     */\n    function getVoteCount() external view returns (uint256) {\n        return voteCount;\n    }\n\n    /**\n     * @dev Returns info on a vote for a given vote ID\n     * @param _disputeId is the ID of a specific vote\n     * @return bytes32 identifier hash of the vote\n     * @return uint256[17] memory of the pertinent round info (vote rounds, start date, fee, etc.)\n     * @return bool memory of both whether or not the vote was executed\n     * @return VoteResult result of the vote\n     * @return address memory of the vote initiator\n     */\n    function getVoteInfo(uint256 _disputeId)\n        external\n        view\n        returns (\n            bytes32,\n            uint256[17] memory,\n            bool,\n            VoteResult,\n            address\n        )\n    {\n        Vote storage _v = voteInfo[_disputeId];\n        return (\n            _v.identifierHash,\n            [\n                _v.voteRound,\n                _v.startDate,\n                _v.blockNumber,\n                _v.fee,\n                _v.tallyDate,\n                _v.tokenholders.doesSupport,\n                _v.tokenholders.against,\n                _v.tokenholders.invalidQuery,\n                _v.users.doesSupport,\n                _v.users.against,\n                _v.users.invalidQuery,\n                _v.reporters.doesSupport,\n                _v.reporters.against,\n                _v.reporters.invalidQuery,\n                _v.teamMultisig.doesSupport,\n                _v.teamMultisig.against,\n                _v.teamMultisig.invalidQuery\n            ],\n            _v.executed,\n            _v.result,\n            _v.initiator\n        );\n    }\n\n    /**\n     * @dev Returns an array of voting rounds for a given vote\n     * @param _hash is the identifier hash for a vote\n     * @return uint256[] memory dispute IDs of the vote rounds\n     */\n    function getVoteRounds(bytes32 _hash)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        return voteRounds[_hash];\n    }\n\n    /**\n     * @dev Returns the total number of votes cast by an address\n     * @param _voter is the address of the voter to check for\n     * @return uint256 of the total number of votes cast by the voter\n     */\n    function getVoteTallyByAddress(address _voter)\n        external\n        view\n        returns (uint256)\n    {\n        return voteTallyByAddress[_voter];\n    }\n\n    // Internal\n    /**\n     * @dev Retrieves total tips contributed to autopay by a given address\n     * @param _user address of the user to check the tip count for\n     * @return _userTipTally uint256 of total tips contributed to autopay by the address\n     */\n    function _getUserTips(address _user) internal returns (uint256 _userTipTally) {\n        // get autopay addresses array from oracle\n        (bytes memory _autopayAddrsBytes, uint256 _timestamp) = getDataBefore(\n            autopayAddrsQueryId,\n            block.timestamp - 12 hours\n        );\n        if (_timestamp > 0) {\n            address[] memory _autopayAddrs = abi.decode(\n                _autopayAddrsBytes,\n                (address[])\n            );\n            // iterate through autopay addresses retrieve tips by user address\n            for (uint256 _i = 0; _i < _autopayAddrs.length; _i++) {\n                (bool _success, bytes memory _returnData) = _autopayAddrs[_i]\n                    .call(\n                        abi.encodeWithSignature(\n                            \"getTipsByAddress(address)\",\n                            _user\n                        )\n                    );\n                if (_success) {\n                    _userTipTally += abi.decode(_returnData, (uint256));\n                }\n            }\n        }\n    }\n}\n"

    },

    "usingtellor/contracts/UsingTellor.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"./interface/ITellor.sol\";\nimport \"./interface/IERC2362.sol\";\nimport \"./interface/IMappingContract.sol\";\n\n/**\n @author Tellor Inc\n @title UsingTellor\n @dev This contract helps smart contracts read data from Tellor\n */\ncontract UsingTellor is IERC2362 {\n    ITellor public tellor;\n    IMappingContract public idMappingContract;\n\n    /*Constructor*/\n    /**\n     * @dev the constructor sets the oracle address in storage\n     * @param _tellor is the Tellor Oracle address\n     */\n    constructor(address payable _tellor) {\n        tellor = ITellor(_tellor);\n    }\n\n    /*Getters*/\n    /**\n     * @dev Retrieves the next value for the queryId after the specified timestamp\n     * @param _queryId is the queryId to look up the value for\n     * @param _timestamp after which to search for next value\n     * @return _value the value retrieved\n     * @return _timestampRetrieved the value's timestamp\n     */\n    function getDataAfter(bytes32 _queryId, uint256 _timestamp)\n        public\n        view\n        returns (bytes memory _value, uint256 _timestampRetrieved)\n    {\n        (bool _found, uint256 _index) = getIndexForDataAfter(\n            _queryId,\n            _timestamp\n        );\n        if (!_found) {\n            return (\"\", 0);\n        }\n        _timestampRetrieved = getTimestampbyQueryIdandIndex(_queryId, _index);\n        _value = retrieveData(_queryId, _timestampRetrieved);\n        return (_value, _timestampRetrieved);\n    }\n\n    /**\n     * @dev Retrieves the latest value for the queryId before the specified timestamp\n     * @param _queryId is the queryId to look up the value for\n     * @param _timestamp before which to search for latest value\n     * @return _value the value retrieved\n     * @return _timestampRetrieved the value's timestamp\n     */\n    function getDataBefore(bytes32 _queryId, uint256 _timestamp)\n        public\n        view\n        returns (bytes memory _value, uint256 _timestampRetrieved)\n    {\n        (, _value, _timestampRetrieved) = tellor.getDataBefore(\n            _queryId,\n            _timestamp\n        );\n    }\n\n    /**\n     * @dev Retrieves next array index of data after the specified timestamp for the queryId\n     * @param _queryId is the queryId to look up the index for\n     * @param _timestamp is the timestamp after which to search for the next index\n     * @return _found whether the index was found\n     * @return _index the next index found after the specified timestamp\n     */\n    function getIndexForDataAfter(bytes32 _queryId, uint256 _timestamp)\n        public\n        view\n        returns (bool _found, uint256 _index)\n    {\n        (_found, _index) = tellor.getIndexForDataBefore(_queryId, _timestamp);\n        if (_found) {\n            _index++;\n        }\n        uint256 _valCount = tellor.getNewValueCountbyQueryId(_queryId);\n        // no value after timestamp\n        if (_valCount <= _index) {\n            return (false, 0);\n        }\n        uint256 _timestampRetrieved = tellor.getTimestampbyQueryIdandIndex(\n            _queryId,\n            _index\n        );\n        if (_timestampRetrieved > _timestamp) {\n            return (true, _index);\n        }\n        // if _timestampRetrieved equals _timestamp, try next value\n        _index++;\n        // no value after timestamp\n        if (_valCount <= _index) {\n            return (false, 0);\n        }\n        _timestampRetrieved = tellor.getTimestampbyQueryIdandIndex(\n            _queryId,\n            _index\n        );\n        return (true, _index);\n    }\n\n    /**\n     * @dev Retrieves latest array index of data before the specified timestamp for the queryId\n     * @param _queryId is the queryId to look up the index for\n     * @param _timestamp is the timestamp before which to search for the latest index\n     * @return _found whether the index was found\n     * @return _index the latest index found before the specified timestamp\n     */\n    // slither-disable-next-line calls-loop\n    function getIndexForDataBefore(bytes32 _queryId, uint256 _timestamp)\n        public\n        view\n        returns (bool _found, uint256 _index)\n    {\n        return tellor.getIndexForDataBefore(_queryId, _timestamp);\n    }\n\n    /**\n     * @dev Retrieves multiple uint256 values before the specified timestamp\n     * @param _queryId the unique id of the data query\n     * @param _timestamp the timestamp before which to search for values\n     * @param _maxAge the maximum number of seconds before the _timestamp to search for values\n     * @param _maxCount the maximum number of values to return\n     * @return _values the values retrieved, ordered from oldest to newest\n     * @return _timestamps the timestamps of the values retrieved\n     */\n    function getMultipleValuesBefore(\n        bytes32 _queryId,\n        uint256 _timestamp,\n        uint256 _maxAge,\n        uint256 _maxCount\n    )\n        public\n        view\n        returns (bytes[] memory _values, uint256[] memory _timestamps)\n    {\n        (bool _ifRetrieve, uint256 _startIndex) = getIndexForDataAfter(\n            _queryId,\n            _timestamp - _maxAge\n        );\n        // no value within range\n        if (!_ifRetrieve) {\n            return (new bytes[](0), new uint256[](0));\n        }\n        uint256 _endIndex;\n        (_ifRetrieve, _endIndex) = getIndexForDataBefore(_queryId, _timestamp);\n        // no value before _timestamp\n        if (!_ifRetrieve) {\n            return (new bytes[](0), new uint256[](0));\n        }\n        uint256 _valCount = _endIndex - _startIndex + 1;\n        // more than _maxCount values found within range\n        if (_valCount > _maxCount) {\n            _startIndex = _endIndex - _maxCount + 1;\n            _valCount = _maxCount;\n        }\n        bytes[] memory _valuesArray = new bytes[](_valCount);\n        uint256[] memory _timestampsArray = new uint256[](_valCount);\n        bytes memory _valueRetrieved;\n        for (uint256 _i = 0; _i < _valCount; _i++) {\n            _timestampsArray[_i] = getTimestampbyQueryIdandIndex(\n                _queryId,\n                (_startIndex + _i)\n            );\n            _valueRetrieved = retrieveData(_queryId, _timestampsArray[_i]);\n            _valuesArray[_i] = _valueRetrieved;\n        }\n        return (_valuesArray, _timestampsArray);\n    }\n\n    /**\n     * @dev Counts the number of values that have been submitted for the queryId\n     * @param _queryId the id to look up\n     * @return uint256 count of the number of values received for the queryId\n     */\n    function getNewValueCountbyQueryId(bytes32 _queryId)\n        public\n        view\n        returns (uint256)\n    {\n        return tellor.getNewValueCountbyQueryId(_queryId);\n    }\n\n    /**\n     * @dev Returns the address of the reporter who submitted a value for a data ID at a specific time\n     * @param _queryId is ID of the specific data feed\n     * @param _timestamp is the timestamp to find a corresponding reporter for\n     * @return address of the reporter who reported the value for the data ID at the given timestamp\n     */\n    function getReporterByTimestamp(bytes32 _queryId, uint256 _timestamp)\n        public\n        view\n        returns (address)\n    {\n        return tellor.getReporterByTimestamp(_queryId, _timestamp);\n    }\n\n    /**\n     * @dev Gets the timestamp for the value based on their index\n     * @param _queryId is the id to look up\n     * @param _index is the value index to look up\n     * @return uint256 timestamp\n     */\n    function getTimestampbyQueryIdandIndex(bytes32 _queryId, uint256 _index)\n        public\n        view\n        returns (uint256)\n    {\n        return tellor.getTimestampbyQueryIdandIndex(_queryId, _index);\n    }\n\n    /**\n     * @dev Determines whether a value with a given queryId and timestamp has been disputed\n     * @param _queryId is the value id to look up\n     * @param _timestamp is the timestamp of the value to look up\n     * @return bool true if queryId/timestamp is under dispute\n     */\n    function isInDispute(bytes32 _queryId, uint256 _timestamp)\n        public\n        view\n        returns (bool)\n    {\n        return tellor.isInDispute(_queryId, _timestamp);\n    }\n\n    /**\n     * @dev Retrieve value from oracle based on queryId/timestamp\n     * @param _queryId being requested\n     * @param _timestamp to retrieve data/value from\n     * @return bytes value for query/timestamp submitted\n     */\n    function retrieveData(bytes32 _queryId, uint256 _timestamp)\n        public\n        view\n        returns (bytes memory)\n    {\n        return tellor.retrieveData(_queryId, _timestamp);\n    }\n\n\n    /**\n     * @dev allows dev to set mapping contract for valueFor (EIP2362)\n     * @param _addy address of mapping contract\n     */\n     function setIdMappingContract(address _addy) external{\n         require(address(idMappingContract) == address(0));\n         idMappingContract = IMappingContract(_addy); \n     }\n\n    /**\n     * @dev Retrieve most recent int256 value from oracle based on queryId\n     * @param _id being requested\n     * @return _value most recent value submitted\n     * @return _timestamp timestamp of most recent value\n     * @return _statusCode 200 if value found, 404 if not found\n     */\n    function valueFor(bytes32 _id)\n        external\n        view\n        override\n        returns (\n            int256 _value,\n            uint256 _timestamp,\n            uint256 _statusCode\n        )\n    {\n        _id = idMappingContract.getTellorID(_id);\n        uint256 _count = getNewValueCountbyQueryId(_id);\n        if (_count == 0) {\n            return (0, 0, 404);\n        }\n        _timestamp = getTimestampbyQueryIdandIndex(_id, _count - 1);\n        bytes memory _valueBytes = retrieveData(_id, _timestamp);\n        if (_valueBytes.length == 0) {\n            return (0, 0, 404);\n        }\n        uint256 _valueUint = _sliceUint(_valueBytes);\n        _value = int256(_valueUint);\n        return (_value, _timestamp, 200);\n    }\n\n    // Internal functions\n    /**\n     * @dev Convert bytes to uint256\n     * @param _b bytes value to convert to uint256\n     * @return _number uint256 converted from bytes\n     */\n    function _sliceUint(bytes memory _b) internal pure returns(uint256 _number){\n        for (uint256 _i = 0; _i < _b.length; _i++) {\n            _number = _number * 256 + uint8(_b[_i]);\n        }\n    }\n}\n"

    },

    "polygongovernance/contracts/interfaces/IOracle.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.3;\n\n/**\n @author Tellor Inc.\n @title TellorFlex\n @dev This is a streamlined Tellor oracle system which handles staking, reporting,\n * slashing, and user data getters in one contract. This contract is controlled\n * by a single address known as 'governance', which could be an externally owned\n * account or a contract, allowing for a flexible, modular design.\n*/\ninterface IOracle {\n    /**\n     * @dev Removes a value from the oracle.\n     * Note: this function is only callable by the Governance contract.\n     * @param _queryId is ID of the specific data feed\n     * @param _timestamp is the timestamp of the data value to remove\n     */\n    function removeValue(bytes32 _queryId, uint256 _timestamp) external;\n\n    /**\n     * @dev Slashes a reporter and transfers their stake amount to the given recipient\n     * Note: this function is only callable by the governance address.\n     * @param _reporter is the address of the reporter being slashed\n     * @param _recipient is the address receiving the reporter's stake\n     * @return uint256 amount of token slashed and sent to recipient address\n     */\n    function slashReporter(address _reporter, address _recipient)\n        external\n        returns (uint256);\n\n    // *****************************************************************************\n    // *                                                                           *\n    // *                               Getters                                     *\n    // *                                                                           *\n    // *****************************************************************************\n\n    /**\n     * @dev Returns the block number at a given timestamp\n     * @param _queryId is ID of the specific data feed\n     * @param _timestamp is the timestamp to find the corresponding block number for\n     * @return uint256 block number of the timestamp for the given data ID\n     */\n    function getBlockNumberByTimestamp(bytes32 _queryId, uint256 _timestamp)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Returns the address of the reporter who submitted a value for a data ID at a specific time\n     * @param _queryId is ID of the specific data feed\n     * @param _timestamp is the timestamp to find a corresponding reporter for\n     * @return address of the reporter who reported the value for the data ID at the given timestamp\n     */\n    function getReporterByTimestamp(bytes32 _queryId, uint256 _timestamp)\n        external\n        view\n        returns (address);\n\n    /**\n     * @dev Returns the number of values submitted by a specific reporter address\n     * @param _reporter is the address of a reporter\n     * @return uint256 of the number of values submitted by the given reporter\n     */\n    function getReportsSubmittedByAddress(address _reporter)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Returns amount required to report oracle values\n     * @return uint256 stake amount\n     */\n    function getStakeAmount() external view returns (uint256);\n\n    /**\n     * @dev Allows users to retrieve all information about a staker\n     * @param _stakerAddress address of staker inquiring about\n     * @return uint startDate of staking\n     * @return uint current amount staked\n     * @return uint current amount locked for withdrawal\n     * @return uint reward debt used to calculate staking rewards\n     * @return uint reporter's last reported timestamp\n     * @return uint total number of reports submitted by reporter\n     * @return uint governance vote count when first staked\n     * @return uint number of votes cast by staker when first staked\n     */\n    function getStakerInfo(address _stakerAddress)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    /**\n     * @dev Retrieves the latest value for the queryId before the specified timestamp\n     * @param _queryId is the queryId to look up the value for\n     * @param _timestamp before which to search for latest value\n     * @return _ifRetrieve bool true if able to retrieve a non-zero value\n     * @return _value the value retrieved\n     * @return _timestampRetrieved the value's timestamp\n     */\n    function getDataBefore(bytes32 _queryId, uint256 _timestamp)\n        external\n        view\n        returns (\n            bool _ifRetrieve,\n            bytes memory _value,\n            uint256 _timestampRetrieved\n        );\n\n    /**\n     * @dev Returns the address of the token used for staking\n     * @return address of the token used for staking\n     */\n    function getTokenAddress() external view returns (address);\n\n    /**\n     * @dev Retrieve value from oracle based on timestamp\n     * @param _queryId being requested\n     * @param _timestamp to retrieve data/value from\n     * @return bytes value for timestamp submitted\n     */\n    function retrieveData(bytes32 _queryId, uint256 _timestamp)\n        external\n        view\n        returns (bytes memory);\n}\n"

    },

    "polygongovernance/contracts/interfaces/IERC20.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.3;\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n}\n"

    },

    "usingtellor/contracts/interface/ITellor.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface ITellor {\n    //Controller\n    function addresses(bytes32) external view returns (address);\n\n    function uints(bytes32) external view returns (uint256);\n\n    function burn(uint256 _amount) external;\n\n    function changeDeity(address _newDeity) external;\n\n    function changeOwner(address _newOwner) external;\n    function changeUint(bytes32 _target, uint256 _amount) external;\n\n    function migrate() external;\n\n    function mint(address _reciever, uint256 _amount) external;\n\n    function init() external;\n\n    function getAllDisputeVars(uint256 _disputeId)\n        external\n        view\n        returns (\n            bytes32,\n            bool,\n            bool,\n            bool,\n            address,\n            address,\n            address,\n            uint256[9] memory,\n            int256\n        );\n\n    function getDisputeIdByDisputeHash(bytes32 _hash)\n        external\n        view\n        returns (uint256);\n\n    function getDisputeUintVars(uint256 _disputeId, bytes32 _data)\n        external\n        view\n        returns (uint256);\n\n    function getLastNewValueById(uint256 _requestId)\n        external\n        view\n        returns (uint256, bool);\n\n    function retrieveData(uint256 _requestId, uint256 _timestamp)\n        external\n        view\n        returns (uint256);\n\n    function getNewValueCountbyRequestId(uint256 _requestId)\n        external\n        view\n        returns (uint256);\n\n    function getAddressVars(bytes32 _data) external view returns (address);\n\n    function getUintVar(bytes32 _data) external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function isMigrated(address _addy) external view returns (bool);\n\n    function allowance(address _user, address _spender)\n        external\n        view\n        returns (uint256);\n\n    function allowedToTrade(address _user, uint256 _amount)\n        external\n        view\n        returns (bool);\n\n    function approve(address _spender, uint256 _amount) external returns (bool);\n\n    function approveAndTransferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) external returns (bool);\n\n    function balanceOf(address _user) external view returns (uint256);\n\n    function balanceOfAt(address _user, uint256 _blockNumber)\n        external\n        view\n        returns (uint256);\n\n    function transfer(address _to, uint256 _amount)\n        external\n        returns (bool success);\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) external returns (bool success);\n\n    function depositStake() external;\n\n    function requestStakingWithdraw() external;\n\n    function withdrawStake() external;\n\n    function changeStakingStatus(address _reporter, uint256 _status) external;\n\n    function slashReporter(address _reporter, address _disputer) external;\n\n    function getStakerInfo(address _staker)\n        external\n        view\n        returns (uint256, uint256);\n\n    function getTimestampbyRequestIDandIndex(uint256 _requestId, uint256 _index)\n        external\n        view\n        returns (uint256);\n\n    function getNewCurrentVariables()\n        external\n        view\n        returns (\n            bytes32 _c,\n            uint256[5] memory _r,\n            uint256 _d,\n            uint256 _t\n        );\n\n    function getNewValueCountbyQueryId(bytes32 _queryId)\n        external\n        view\n        returns (uint256);\n\n    function getTimestampbyQueryIdandIndex(bytes32 _queryId, uint256 _index)\n        external\n        view\n        returns (uint256);\n\n    function retrieveData(bytes32 _queryId, uint256 _timestamp)\n        external\n        view\n        returns (bytes memory);\n\n    //Governance\n    enum VoteResult {\n        FAILED,\n        PASSED,\n        INVALID\n    }\n\n    function setApprovedFunction(bytes4 _func, bool _val) external;\n\n    function beginDispute(bytes32 _queryId, uint256 _timestamp) external;\n\n    function delegate(address _delegate) external;\n\n    function delegateOfAt(address _user, uint256 _blockNumber)\n        external\n        view\n        returns (address);\n\n    function executeVote(uint256 _disputeId) external;\n\n    function proposeVote(\n        address _contract,\n        bytes4 _function,\n        bytes calldata _data,\n        uint256 _timestamp\n    ) external;\n\n    function tallyVotes(uint256 _disputeId) external;\n\n    function governance() external view returns (address);\n\n    function updateMinDisputeFee() external;\n\n    function verify() external pure returns (uint256);\n\n    function vote(\n        uint256 _disputeId,\n        bool _supports,\n        bool _invalidQuery\n    ) external;\n\n    function voteFor(\n        address[] calldata _addys,\n        uint256 _disputeId,\n        bool _supports,\n        bool _invalidQuery\n    ) external;\n\n    function getDelegateInfo(address _holder)\n        external\n        view\n        returns (address, uint256);\n\n    function isFunctionApproved(bytes4 _func) external view returns (bool);\n\n    function isApprovedGovernanceContract(address _contract)\n        external\n        returns (bool);\n\n    function getVoteRounds(bytes32 _hash)\n        external\n        view\n        returns (uint256[] memory);\n\n    function getVoteCount() external view returns (uint256);\n\n    function getVoteInfo(uint256 _disputeId)\n        external\n        view\n        returns (\n            bytes32,\n            uint256[9] memory,\n            bool[2] memory,\n            VoteResult,\n            bytes memory,\n            bytes4,\n            address[2] memory\n        );\n\n    function getDisputeInfo(uint256 _disputeId)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            bytes memory,\n            address\n        );\n\n    function getOpenDisputesOnId(bytes32 _queryId)\n        external\n        view\n        returns (uint256);\n\n    function didVote(uint256 _disputeId, address _voter)\n        external\n        view\n        returns (bool);\n\n    //Oracle\n    function getReportTimestampByIndex(bytes32 _queryId, uint256 _index)\n        external\n        view\n        returns (uint256);\n\n    function getValueByTimestamp(bytes32 _queryId, uint256 _timestamp)\n        external\n        view\n        returns (bytes memory);\n\n    function getBlockNumberByTimestamp(bytes32 _queryId, uint256 _timestamp)\n        external\n        view\n        returns (uint256);\n\n    function getReportingLock() external view returns (uint256);\n\n    function getReporterByTimestamp(bytes32 _queryId, uint256 _timestamp)\n        external\n        view\n        returns (address);\n\n    function reportingLock() external view returns (uint256);\n\n    function removeValue(bytes32 _queryId, uint256 _timestamp) external;\n    function getTipsByUser(address _user) external view returns(uint256);\n    function tipQuery(bytes32 _queryId, uint256 _tip, bytes memory _queryData) external;\n    function submitValue(bytes32 _queryId, bytes calldata _value, uint256 _nonce, bytes memory _queryData) external;\n    function burnTips() external;\n\n    function changeReportingLock(uint256 _newReportingLock) external;\n    function getReportsSubmittedByAddress(address _reporter) external view returns(uint256);\n    function changeTimeBasedReward(uint256 _newTimeBasedReward) external;\n    function getReporterLastTimestamp(address _reporter) external view returns(uint256);\n    function getTipsById(bytes32 _queryId) external view returns(uint256);\n    function getTimeBasedReward() external view returns(uint256);\n    function getTimestampCountById(bytes32 _queryId) external view returns(uint256);\n    function getTimestampIndexByTimestamp(bytes32 _queryId, uint256 _timestamp) external view returns(uint256);\n    function getCurrentReward(bytes32 _queryId) external view returns(uint256, uint256);\n    function getCurrentValue(bytes32 _queryId) external view returns(bytes memory);\n    function getDataBefore(bytes32 _queryId, uint256 _timestamp) external view returns(bool _ifRetrieve, bytes memory _value, uint256 _timestampRetrieved);\n    function getTimeOfLastNewValue() external view returns(uint256);\n    function depositStake(uint256 _amount) external;\n    function requestStakingWithdraw(uint256 _amount) external;\n\n    //Test functions\n    function changeAddressVar(bytes32 _id, address _addy) external;\n\n    //parachute functions\n    function killContract() external;\n\n    function migrateFor(address _destination, uint256 _amount) external;\n\n    function rescue51PercentAttack(address _tokenHolder) external;\n\n    function rescueBrokenDataReporting() external;\n\n    function rescueFailedUpdate() external;\n\n    //Tellor 360\n    function addStakingRewards(uint256 _amount) external;\n\n    function _sliceUint(bytes memory _b)\n        external\n        pure\n        returns (uint256 _number);\n\n    function claimOneTimeTip(bytes32 _queryId, uint256[] memory _timestamps)\n        external;\n\n    function claimTip(\n        bytes32 _feedId,\n        bytes32 _queryId,\n        uint256[] memory _timestamps\n    ) external;\n\n    function fee() external view returns (uint256);\n\n    function feedsWithFunding(uint256) external view returns (bytes32);\n\n    function fundFeed(\n        bytes32 _feedId,\n        bytes32 _queryId,\n        uint256 _amount\n    ) external;\n\n    function getCurrentFeeds(bytes32 _queryId)\n        external\n        view\n        returns (bytes32[] memory);\n\n    function getCurrentTip(bytes32 _queryId) external view returns (uint256);\n\n    function getDataAfter(bytes32 _queryId, uint256 _timestamp)\n        external\n        view\n        returns (bytes memory _value, uint256 _timestampRetrieved);\n\n    function getDataFeed(bytes32 _feedId)\n        external\n        view\n        returns (Autopay.FeedDetails memory);\n\n    function getFundedFeeds() external view returns (bytes32[] memory);\n\n    function getFundedQueryIds() external view returns (bytes32[] memory);\n\n    function getIndexForDataAfter(bytes32 _queryId, uint256 _timestamp)\n        external\n        view\n        returns (bool _found, uint256 _index);\n\n    function getIndexForDataBefore(bytes32 _queryId, uint256 _timestamp)\n        external\n        view\n        returns (bool _found, uint256 _index);\n\n    function getMultipleValuesBefore(\n        bytes32 _queryId,\n        uint256 _timestamp,\n        uint256 _maxAge,\n        uint256 _maxCount\n    )\n        external\n        view\n        returns (uint256[] memory _values, uint256[] memory _timestamps);\n\n    function getPastTipByIndex(bytes32 _queryId, uint256 _index)\n        external\n        view\n        returns (Autopay.Tip memory);\n\n    function getPastTipCount(bytes32 _queryId) external view returns (uint256);\n\n    function getPastTips(bytes32 _queryId)\n        external\n        view\n        returns (Autopay.Tip[] memory);\n\n    function getQueryIdFromFeedId(bytes32 _feedId)\n        external\n        view\n        returns (bytes32);\n\n    function getRewardAmount(\n        bytes32 _feedId,\n        bytes32 _queryId,\n        uint256[] memory _timestamps\n    ) external view returns (uint256 _cumulativeReward);\n\n    function getRewardClaimedStatus(\n        bytes32 _feedId,\n        bytes32 _queryId,\n        uint256 _timestamp\n    ) external view returns (bool);\n\n    function getTipsByAddress(address _user) external view returns (uint256);\n\n    function isInDispute(bytes32 _queryId, uint256 _timestamp)\n        external\n        view\n        returns (bool);\n\n    function queryIdFromDataFeedId(bytes32) external view returns (bytes32);\n\n    function queryIdsWithFunding(uint256) external view returns (bytes32);\n\n    function queryIdsWithFundingIndex(bytes32) external view returns (uint256);\n\n    function setupDataFeed(\n        bytes32 _queryId,\n        uint256 _reward,\n        uint256 _startTime,\n        uint256 _interval,\n        uint256 _window,\n        uint256 _priceThreshold,\n        uint256 _rewardIncreasePerSecond,\n        bytes memory _queryData,\n        uint256 _amount\n    ) external;\n\n    function tellor() external view returns (address);\n\n    function tip(\n        bytes32 _queryId,\n        uint256 _amount,\n        bytes memory _queryData\n    ) external;\n\n    function tips(bytes32, uint256)\n        external\n        view\n        returns (uint256 amount, uint256 timestamp);\n\n    function token() external view returns (address);\n\n    function userTipsTotal(address) external view returns (uint256);\n\n    function valueFor(bytes32 _id)\n        external\n        view\n        returns (\n            int256 _value,\n            uint256 _timestamp,\n            uint256 _statusCode\n        );\n}\n\ninterface Autopay {\n    struct FeedDetails {\n        uint256 reward;\n        uint256 balance;\n        uint256 startTime;\n        uint256 interval;\n        uint256 window;\n        uint256 priceThreshold;\n        uint256 rewardIncreasePerSecond;\n        uint256 feedsWithFundingIndex;\n    }\n\n    struct Tip {\n        uint256 amount;\n        uint256 timestamp;\n    }\n    function getStakeAmount() external view returns(uint256);\n    function stakeAmount() external view returns(uint256);\n    function token() external view returns(address);\n}\n"

    },

    "usingtellor/contracts/interface/IERC2362.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/**\n    * @dev EIP2362 Interface for pull oracles\n    * https://github.com/tellor-io/EIP-2362\n*/\ninterface IERC2362\n{\n\t/**\n\t * @dev Exposed function pertaining to EIP standards\n\t * @param _id bytes32 ID of the query\n\t * @return int,uint,uint returns the value, timestamp, and status code of query\n\t */\n\tfunction valueFor(bytes32 _id) external view returns(int256,uint256,uint256);\n}"

    },

    "usingtellor/contracts/interface/IMappingContract.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IMappingContract{\n    function getTellorID(bytes32 _id) external view returns(bytes32);\n}"

    }

  },

  "settings": {

    "optimizer": {

      "enabled": true,

      "runs": 300

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "libraries": {}

  }

}}