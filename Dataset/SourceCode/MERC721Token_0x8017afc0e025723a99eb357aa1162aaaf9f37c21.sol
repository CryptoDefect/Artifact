{{

  "language": "Solidity",

  "sources": {

    "project:/contracts/ErrorReporter.sol": {

      "content": "pragma solidity ^0.5.16;\n\ncontract MtrollerErrorReporter {\n    enum Error {\n        NO_ERROR,\n        UNAUTHORIZED,\n        MTROLLER_MISMATCH,\n        INSUFFICIENT_SHORTFALL,\n        INSUFFICIENT_LIQUIDITY,\n        INVALID_CLOSE_FACTOR,\n        INVALID_COLLATERAL_FACTOR,\n        INVALID_LIQUIDATION_INCENTIVE,\n        MARKET_NOT_ENTERED,\n        MARKET_NOT_LISTED,\n        MARKET_ALREADY_LISTED,\n        MATH_ERROR,\n        NONZERO_BORROW_BALANCE,\n        PRICE_ERROR,\n        REJECTION,\n        SNAPSHOT_ERROR,\n        TOO_MANY_ASSETS,\n        TOO_MUCH_REPAY,\n        INVALID_TOKEN_TYPE\n    }\n\n    enum FailureInfo {\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n        ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,\n        EXIT_MARKET_BALANCE_OWED,\n        EXIT_MARKET_REJECTION,\n        SET_CLOSE_FACTOR_OWNER_CHECK,\n        SET_CLOSE_FACTOR_VALIDATION,\n        SET_COLLATERAL_FACTOR_OWNER_CHECK,\n        SET_COLLATERAL_FACTOR_NO_EXISTS,\n        SET_COLLATERAL_FACTOR_VALIDATION,\n        SET_COLLATERAL_FACTOR_WITHOUT_PRICE,\n        SET_IMPLEMENTATION_OWNER_CHECK,\n        SET_LIQUIDATION_INCENTIVE_OWNER_CHECK,\n        SET_LIQUIDATION_INCENTIVE_VALIDATION,\n        SET_MAX_ASSETS_OWNER_CHECK,\n        SET_PENDING_ADMIN_OWNER_CHECK,\n        SET_PENDING_IMPLEMENTATION_OWNER_CHECK,\n        SET_PRICE_ORACLE_OWNER_CHECK,\n        SUPPORT_MARKET_EXISTS,\n        SUPPORT_MARKET_OWNER_CHECK,\n        SET_PAUSE_GUARDIAN_OWNER_CHECK\n    }\n\n    /**\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n      **/\n    event Failure(uint error, uint info, uint detail);\n\n    /**\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n      */\n    function fail(Error err, FailureInfo info) internal returns (uint) {\n        emit Failure(uint(err), uint(info), 0);\n\n        return uint(err);\n    }\n\n    /**\n      * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n      */\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\n        emit Failure(uint(err), uint(info), opaqueError);\n\n        return uint(err);\n    }\n}\n\ncontract TokenErrorReporter {\n    enum Error {\n        NO_ERROR,\n        UNAUTHORIZED,\n        BAD_INPUT,\n        MTROLLER_REJECTION,\n        MTROLLER_CALCULATION_ERROR,\n        INTEREST_RATE_MODEL_ERROR,\n        INVALID_ACCOUNT_PAIR,\n        INVALID_CLOSE_AMOUNT_REQUESTED,\n        INVALID_COLLATERAL_FACTOR,\n        INVALID_COLLATERAL,\n        MATH_ERROR,\n        MARKET_NOT_FRESH,\n        MARKET_NOT_LISTED,\n        TOKEN_INSUFFICIENT_ALLOWANCE,\n        TOKEN_INSUFFICIENT_BALANCE,\n        TOKEN_INSUFFICIENT_CASH,\n        TOKEN_TRANSFER_IN_FAILED,\n        TOKEN_TRANSFER_OUT_FAILED\n    }\n\n    /*\n     * Note: FailureInfo (but not Error) is kept in alphabetical order\n     *       This is because FailureInfo grows significantly faster, and\n     *       the order of Error has some meaning, while the order of FailureInfo\n     *       is entirely arbitrary.\n     */\n    enum FailureInfo {\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n        ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\n        ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED,\n        ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\n        ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\n        ACCRUE_INTEREST_NEW_TOTAL_RESERVES_CALCULATION_FAILED,\n        ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\n        AUCTION_NOT_ALLOWED,\n        BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n        BORROW_ACCRUE_INTEREST_FAILED,\n        BORROW_CASH_NOT_AVAILABLE,\n        BORROW_FRESHNESS_CHECK,\n        BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n        BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n        BORROW_NEW_PLATFORM_FEE_CALCULATION_FAILED,\n        BORROW_MARKET_NOT_LISTED,\n        BORROW_MTROLLER_REJECTION,\n        FLASH_LOAN_BORROW_FAILED,\n        FLASH_OPERATION_NOT_DEFINED,\n        LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED,\n        LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED,\n        LIQUIDATE_COLLATERAL_FRESHNESS_CHECK,\n        LIQUIDATE_COLLATERAL_NOT_FUNGIBLE,\n        LIQUIDATE_COLLATERAL_NOT_EXISTING,\n        LIQUIDATE_MTROLLER_REJECTION,\n        LIQUIDATE_MTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED,\n        LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX,\n        LIQUIDATE_CLOSE_AMOUNT_IS_ZERO,\n        LIQUIDATE_FRESHNESS_CHECK,\n        LIQUIDATE_GRACE_PERIOD_NOT_EXPIRED,\n        LIQUIDATE_LIQUIDATOR_IS_BORROWER,\n        LIQUIDATE_NOT_PREFERRED_LIQUIDATOR,\n        LIQUIDATE_REPAY_BORROW_FRESH_FAILED,\n        LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED,\n        LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED,\n        LIQUIDATE_SEIZE_MTROLLER_REJECTION,\n        LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER,\n        LIQUIDATE_SEIZE_TOO_MUCH,\n        LIQUIDATE_SEIZE_NON_FUNGIBLE_ASSET,\n        MINT_ACCRUE_INTEREST_FAILED,\n        MINT_MTROLLER_REJECTION,\n        MINT_EXCHANGE_CALCULATION_FAILED,\n        MINT_EXCHANGE_RATE_READ_FAILED,\n        MINT_FRESHNESS_CHECK,\n        MINT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n        MINT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n        MINT_NEW_TOTAL_CASH_CALCULATION_FAILED,\n        MINT_TRANSFER_IN_FAILED,\n        MINT_TRANSFER_IN_NOT_POSSIBLE,\n        REDEEM_ACCRUE_INTEREST_FAILED,\n        REDEEM_MTROLLER_REJECTION,\n        REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,\n        REDEEM_EXCHANGE_AMOUNT_CALCULATION_FAILED,\n        REDEEM_EXCHANGE_RATE_READ_FAILED,\n        REDEEM_FRESHNESS_CHECK,\n        REDEEM_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n        REDEEM_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n        REDEEM_TRANSFER_OUT_NOT_POSSIBLE,\n        REDEEM_MARKET_EXIT_NOT_POSSIBLE,\n        REDEEM_NOT_OWNER,\n        REDUCE_RESERVES_ACCRUE_INTEREST_FAILED,\n        REDUCE_RESERVES_ADMIN_CHECK,\n        REDUCE_RESERVES_CASH_NOT_AVAILABLE,\n        REDUCE_RESERVES_FRESH_CHECK,\n        REDUCE_RESERVES_VALIDATION,\n        REPAY_BEHALF_ACCRUE_INTEREST_FAILED,\n        REPAY_BORROW_ACCRUE_INTEREST_FAILED,\n        REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n        REPAY_BORROW_MTROLLER_REJECTION,\n        REPAY_BORROW_FRESHNESS_CHECK,\n        REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n        REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n        REPAY_BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED,\n        REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,\n        SET_COLLATERAL_FACTOR_OWNER_CHECK,\n        SET_COLLATERAL_FACTOR_VALIDATION,\n        SET_GLOBAL_PARAMETERS_VALUE_CHECK,\n        SET_MTROLLER_OWNER_CHECK,\n        SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED,\n        SET_INTEREST_RATE_MODEL_FRESH_CHECK,\n        SET_INTEREST_RATE_MODEL_OWNER_CHECK,\n        SET_FLASH_WHITELIST_OWNER_CHECK,\n        SET_MAX_ASSETS_OWNER_CHECK,\n        SET_ORACLE_MARKET_NOT_LISTED,\n        SET_PENDING_ADMIN_OWNER_CHECK,\n        SET_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED,\n        SET_RESERVE_FACTOR_ADMIN_CHECK,\n        SET_RESERVE_FACTOR_FRESH_CHECK,\n        SET_RESERVE_FACTOR_BOUNDS_CHECK,\n        SET_TOKEN_AUCTION_OWNER_CHECK,\n        TRANSFER_MTROLLER_REJECTION,\n        TRANSFER_NOT_ALLOWED,\n        TRANSFER_NOT_ENOUGH,\n        TRANSFER_TOO_MUCH,\n        ADD_RESERVES_ACCRUE_INTEREST_FAILED,\n        ADD_RESERVES_FRESH_CHECK,\n        ADD_RESERVES_TOTAL_CASH_CALCULATION_FAILED,\n        ADD_RESERVES_TOTAL_RESERVES_CALCULATION_FAILED,\n        ADD_RESERVES_TRANSFER_IN_NOT_POSSIBLE\n    }\n\n    /**\n      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n      **/\n    event Failure(uint error, uint info, uint detail);\n\n    /**\n      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n      */\n    function fail(Error err, FailureInfo info) internal returns (uint) {\n        emit Failure(uint(err), uint(info), 0);\n\n        return uint(err);\n    }\n\n    /**\n      * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n      */\n    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\n        emit Failure(uint(err), uint(info), opaqueError);\n\n        return uint(err);\n    }\n}"

    },

    "project:/contracts/MDelegator.sol": {

      "content": "pragma solidity ^0.5.16;\n\nimport \"./ErrorReporter.sol\";\nimport \"./MtrollerInterface.sol\";\nimport \"./MTokenInterfaces.sol\";\nimport \"./MTokenStorage.sol\";\n\n/**\n * @title MDelegator\n * @dev Storage for the delegatee is at this contract, while execution is delegated.\n * @author mmo.finance\n */\ncontract MDelegator is MDelegatorIdentifier {\n\n    // Storage position of the address of the user part of the current implementation\n    bytes32 private constant mDelegatorUserImplementationPosition = \n        keccak256(\"com.mmo-finance.mDelegator.user.implementation.address\");\n    \n    // Storage position of the address of the admin part of the current implementation\n    bytes32 private constant mDelegatorAdminImplementationPosition = \n        keccak256(\"com.mmo-finance.mDelegator.admin.implementation.address\");\n    \n    // Storage position base of the implemented admin function selector verifiers\n    bytes32 private constant mDelegatorAdminImplementationSelectorPosition = \n        keccak256(\"com.mmo-finance.mDelegator.admin.implementation.selector.bool\");\n    \n    // Storage position of the enable implementation update flag\n    bytes32 private constant mDelegatorEnableUpdate = \n        keccak256(\"com.mmo-finance.mDelegator.enableUpdate.bool\");\n    \n    /**\n    * @dev the constructor sets the admin\n    */\n    constructor() public {\n        _setMDelegatorAdmin(msg.sender);\n        // initially enable implementation updates\n        bool _enable = true;\n        bytes32 position = mDelegatorEnableUpdate;\n        assembly {\n            sstore(position, _enable)\n        }\n    }\n    \n    /**\n     * @notice Tells the address of the current mDelegatorUserImplementation\n     * @return implementation The address of the current mDelegatorUserImplementation\n     */\n    function mDelegatorUserImplementation() public view returns (address implementation) {\n        bytes32 position = mDelegatorUserImplementationPosition;\n        assembly {\n            implementation := sload(position)\n        }\n    }\n    \n    /**\n     * @notice Tells the address of the current mDelegatorAdminImplementation\n     * @return implementation The address of the current mDelegatorAdminImplementation\n     */\n    function mDelegatorAdminImplementation() public view returns (address implementation) {\n        bytes32 position = mDelegatorAdminImplementationPosition;\n        assembly {\n            implementation := sload(position)\n        }\n    }\n    \n    /**\n     * @notice Tells if the current mDelegatorAdminImplementation supports the given function selector\n     * @param selector The function selector (signature) to check, e.g. bytes4(keccak256('func()'))\n     * @return supported Returns true if the selector is supported\n     */\n    function mDelegatorAdminImplementationSelectorSupported(bytes4 selector) public view returns (bool supported) {\n        bytes32 position = keccak256(abi.encode(selector, mDelegatorAdminImplementationSelectorPosition));\n        assembly {\n            supported := sload(position)\n        }\n    }\n\n    /**\n     * @notice Tells if updating implementations is enabled\n     * @return enabled Returns true if the admin and user implementations can be updated\n     */\n    function mDelegatorImplementationUpdateEnabled() public view returns (bool enabled) {\n        bytes32 position = mDelegatorEnableUpdate;\n        assembly {\n            enabled := sload(position)\n        }\n    }\n\n    /**\n     * @notice Tells the address of the current admin\n     * @return admin The address of the current admin\n     */\n    function mDelegatorAdmin() public view returns (address admin) {\n        bytes32 position = mDelegatorAdminPosition;\n        assembly {\n            admin := sload(position)\n        }\n    }\n    \n    /**\n     * @notice Sets the two addresses of the current implementation\n     * @dev Gets implementedSelectors[] from new admin implementation and marks them as supported\n     * @param _newUserImplementation address of the new mDelegatorUserImplementation\n     * @param _newAdminImplementation address of the new mDelegatorAdminImplementation\n     */\n    function _setImplementation(address _newUserImplementation, address _newAdminImplementation) public {\n        require(msg.sender == mDelegatorAdmin(), \"only admin\");\n        require(mDelegatorImplementationUpdateEnabled(), \"update disabled\");\n        require(MTokenInterface(_newUserImplementation).isMDelegatorUserImplementation(), \"invalid user implementation\");\n        require(MTokenInterface(_newAdminImplementation).isMDelegatorAdminImplementation(), \"invalid admin implementation\");\n        MDelegateeStorage oldAdminImpl = MDelegateeStorage(mDelegatorAdminImplementation());\n        MDelegateeStorage newAdminImpl = MDelegateeStorage(_newAdminImplementation);\n\n        // delete mapping entries for previously supported selectors (if needed)\n        if (address(oldAdminImpl) != address(0)) {\n            uint len = oldAdminImpl.implementedSelectorsLength();\n            for (uint i = 0; i < len; i++) {\n                _setAdminSelectorSupported(oldAdminImpl.implementedSelectors(i), false);\n            }\n        }\n\n        // change to new implementations\n        bytes32 positionUser = mDelegatorUserImplementationPosition;\n        bytes32 positionAdmin = mDelegatorAdminImplementationPosition;\n        assembly {\n            sstore(positionUser, _newUserImplementation)\n            sstore(positionAdmin, _newAdminImplementation)\n        }\n\n        // add mapping entries for newly supported selectors\n        uint len = newAdminImpl.implementedSelectorsLength();\n        for (uint i = 0; i < len; i++) {\n            _setAdminSelectorSupported(newAdminImpl.implementedSelectors(i), true);\n        }\n    }\n    \n    /**\n     * @notice Marks the given function selector as supported by the current mDelegatorAdminImplementation\n     * @param selector The function selector (signature) to mark as supported, e.g. bytes4(keccak256('func()'))\n     * @param supported Set true if to be marked as supported, else set to false\n     */\n    function _setAdminSelectorSupported(bytes4 selector, bool supported) public {\n        require(msg.sender == mDelegatorAdmin(), \"only admin\");\n        bytes32 position = keccak256(abi.encode(selector, mDelegatorAdminImplementationSelectorPosition));\n        assembly {\n            sstore(position, supported)\n        }\n    }\n\n    /**\n     * @notice Disable further implementation updates (NOTE: irreversible change!)\n     */\n    function _disableFurtherImplementationUpdates() public {\n        require(msg.sender == mDelegatorAdmin(), \"only admin\");\n        bool _enable = false;\n        bytes32 position = mDelegatorEnableUpdate;\n        assembly {\n            sstore(position, _enable)\n        }\n    }\n\n    /**\n     * @notice Sets the address of the admin\n     */\n    function _setMDelegatorAdmin(address _newAdmin) public {\n        if (mDelegatorAdmin() != address(0)) {\n            require(msg.sender == mDelegatorAdmin(), \"only admin\");\n            require(_newAdmin != address(0), \"invalid new admin\");\n        }\n        bytes32 position = mDelegatorAdminPosition;\n        assembly {\n            sstore(position, _newAdmin)\n        }\n    }\n\n    /**\n     * @notice Delegates execution of all other functions to an implementation contract.\n     * It returns to the external caller whatever the implementation returns\n     * or forwards reverts.\n     */\n    function () payable external {\n        address implementation;\n\n        // if the function selector msg.sig is supported by the admin implementation, choose the admin implementation\n        // else choose the user implementation (default)\n        if (mDelegatorAdminImplementationSelectorSupported(msg.sig)) {\n            implementation = mDelegatorAdminImplementation();\n        }\n        else {\n            implementation = mDelegatorUserImplementation();\n        }\n        \n        // delegate call to chosen implementation\n        (bool success, ) = implementation.delegatecall(msg.data);\n\n        assembly {\n              let free_mem_ptr := mload(0x40)\n              returndatacopy(free_mem_ptr, 0, returndatasize)\n\n              switch success\n              case 0 { revert(free_mem_ptr, returndatasize) }\n              default { return(free_mem_ptr, returndatasize) }\n        }\n    }\n}\n\n/* The three contracts that are currently using MDelegator */\n\ncontract Mtroller is MDelegator {\n    constructor(MtrollerUserInterface userImpl, MtrollerAdminInterface adminImpl) public MDelegator() {\n        _setImplementation(address(userImpl), address(adminImpl));\n    }\n}\n\ncontract MEther is MDelegator {\n    constructor(MEtherUserInterface userImpl, MEtherAdminInterface adminImpl) public MDelegator() {\n        _setImplementation(address(userImpl), address(adminImpl));\n    }\n}\n\ncontract MERC721Token is MDelegator {\n    constructor(MERC721UserInterface userImpl, MERC721AdminInterface adminImpl) public MDelegator() {\n        _setImplementation(address(userImpl), address(adminImpl));\n    }\n}\n"

    },

    "project:/contracts/MTokenInterfaces.sol": {

      "content": "pragma solidity ^0.5.16;\n\nimport \"./PriceOracle.sol\";\nimport \"./MtrollerInterface.sol\";\nimport \"./TokenAuction.sol\";\nimport \"./compound/InterestRateModel.sol\";\nimport \"./compound/EIP20NonStandardInterface.sol\";\nimport \"./open-zeppelin/token/ERC721/IERC721Metadata.sol\";\n\ncontract MTokenCommonInterface is MTokenIdentifier, MDelegatorIdentifier {\n\n    /*** Market Events ***/\n\n    /**\n     * @notice Event emitted when interest is accrued\n     */\n    event AccrueInterest(uint240 mToken, uint cashPrior, uint interestAccumulated, uint borrowIndex, uint totalBorrows);\n\n    /**\n     * @notice Events emitted when tokens are minted\n     */\n    event Mint(address minter, address beneficiary, uint mintAmountUnderlying, uint240 mTokenMinted, uint amountTokensMinted);\n\n    /**\n     * @notice Events emitted when tokens are transferred\n     */\n    event Transfer(address from, address to, uint240 mToken, uint amountTokens);\n\n    /**\n     * @notice Event emitted when tokens are redeemed\n     */\n    event Redeem(address redeemer, uint240 mToken, uint redeemTokens, uint256 underlyingID, uint underlyingRedeemAmount);\n\n    /**\n     * @notice Event emitted when underlying is borrowed\n     */\n    event Borrow(address borrower, uint256 underlyingID, uint borrowAmount, uint paidOutAmount, uint accountBorrows, uint totalBorrows);\n\n    /**\n     * @notice Event emitted when underlying is borrowed in a flash loan operation\n     */\n    event FlashBorrow(address borrower, uint256 underlyingID, address receiver, uint downPayment, uint borrowAmount, uint paidOutAmount);\n\n    /**\n     * @notice Event emitted when a borrow is repaid\n     */\n    event RepayBorrow(address payer, address borrower, uint256 underlyingID, uint repayAmount, uint accountBorrows, uint totalBorrows);\n\n    /**\n     * @notice Event emitted when a borrow is liquidated\n     */\n    event LiquidateBorrow(address liquidator, address borrower, uint240 mTokenBorrowed, uint repayAmountUnderlying, uint240 mTokenCollateral, uint seizeTokens);\n\n    /**\n     * @notice Event emitted when a grace period is started before liquidating a token with an auction\n     */\n    event GracePeriod(uint240 mTokenCollateral, uint lastBlockOfGracePeriod);\n\n\n    /*** Admin Events ***/\n\n    /**\n     * @notice Event emitted when flash receiver whitlist is changed\n     */\n    event FlashReceiverWhitelistChanged(address receiver, bool newState);\n\n    /**\n     * @notice Event emitted when interestRateModel is changed\n     */\n    event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);\n\n    /**\n     * @notice Event emitted when tokenAuction is changed\n     */\n    event NewTokenAuction(TokenAuction oldTokenAuction, TokenAuction newTokenAuction);\n\n    /**\n     * @notice Event emitted when mtroller is changed\n     */\n    event NewMtroller(MtrollerInterface oldMtroller, MtrollerInterface newMtroller);\n\n    /**\n     * @notice Event emitted when global protocol parameters are updated\n     */\n    event NewGlobalProtocolParameters(uint newInitialExchangeRateMantissa, uint newReserveFactorMantissa, uint newProtocolSeizeShareMantissa, uint newBorrowFeeMantissa);\n\n    /**\n     * @notice Event emitted when global auction parameters are updated\n     */\n    event NewGlobalAuctionParameters(uint newAuctionGracePeriod, uint newPreferredLiquidatorHeadstart, uint newMinimumOfferMantissa, uint newLiquidatorAuctionFeeMantissa, uint newProtocolAuctionFeeMantissa);\n\n    /**\n     * @notice Event emitted when the reserves are added\n     */\n    event ReservesAdded(address benefactor, uint240 mToken, uint addAmount, uint newTotalReserves);\n\n    /**\n     * @notice Event emitted when the reserves are reduced\n     */\n    event ReservesReduced(address admin, uint240 mToken, uint reduceAmount, uint newTotalReserves);\n\n    /**\n     * @notice Failure event\n     */\n    event Failure(uint error, uint info, uint detail);\n\n\n    function getAdmin() public view returns (address payable admin);\n    function accrueInterest(uint240 mToken) public returns (uint);\n}\n\ncontract MTokenAdminInterface is MTokenCommonInterface {\n\n    /// @notice Indicator that this is a admin part contract (for inspection)\n    function isMDelegatorAdminImplementation() public pure returns (bool);\n\n    /*** Admin Functions ***/\n\n    function _setInterestRateModel(InterestRateModel newInterestRateModel) public returns (uint);\n    function _setTokenAuction(TokenAuction newTokenAuction) public returns (uint);\n    function _setMtroller(MtrollerInterface newMtroller) public returns (uint);\n    function _setGlobalProtocolParameters(uint _initialExchangeRateMantissa, uint _reserveFactorMantissa, uint _protocolSeizeShareMantissa, uint _borrowFeeMantissa) public returns (uint);\n    function _setGlobalAuctionParameters(uint _auctionGracePeriod, uint _preferredLiquidatorHeadstart, uint _minimumOfferMantissa, uint _liquidatorAuctionFeeMantissa, uint _protocolAuctionFeeMantissa) public returns (uint);\n    function _reduceReserves(uint240 mToken, uint reduceAmount) external returns (uint);\n    function _sweepERC20(address tokenContract) external returns (uint);\n    function _sweepERC721(address tokenContract, uint256 tokenID) external;\n}\n\ncontract MTokenUserInterface is MTokenCommonInterface {\n\n    /// @notice Indicator that this is a user part contract (for inspection)\n    function isMDelegatorUserImplementation() public pure returns (bool);\n\n    /*** User Interface ***/\n\n    function balanceOf(address owner, uint240 mToken) external view returns (uint);\n    function getAccountSnapshot(address account, uint240 mToken) external view returns (uint, uint, uint, uint);\n    function borrowRatePerBlock(uint240 mToken) external view returns (uint);\n    function supplyRatePerBlock(uint240 mToken) external view returns (uint);\n    function totalBorrowsCurrent(uint240 mToken) external returns (uint);\n    function borrowBalanceCurrent(address account, uint240 mToken) external returns (uint);\n    function borrowBalanceStored(address account, uint240 mToken) public view returns (uint);\n    function exchangeRateCurrent(uint240 mToken) external returns (uint);\n    function exchangeRateStored(uint240 mToken) external view returns (uint);\n    function getCash(uint240 mToken) external view returns (uint);\n    function seize(uint240 mTokenBorrowed, address liquidator, address borrower, uint240 mTokenCollateral, uint seizeTokens) external returns (uint);\n}\n\ncontract MTokenInterface is MTokenAdminInterface, MTokenUserInterface {}\n\ncontract MFungibleTokenAdminInterface is MTokenAdminInterface {\n}\n\ncontract MFungibleTokenUserInterface is MTokenUserInterface{\n\n    /*** Market Events ***/\n\n    event Transfer(address indexed from, address indexed to, uint amount);\n    event Approval(address indexed owner, address indexed spender, uint amount);\n\n    /*** User Interface ***/\n\n    function transfer(address dst, uint amount) external returns (bool);\n    function transferFrom(address src, address dst, uint amount) external returns (bool);\n    function approve(address spender, uint amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function balanceOfUnderlying(address owner) external returns (uint);\n}\n\ncontract MFungibleTokenInterface is MFungibleTokenAdminInterface, MFungibleTokenUserInterface {}\n\ncontract MEtherAdminInterface is MFungibleTokenAdminInterface {\n\n    /*** Admin Functions ***/\n\n    function initialize(MtrollerInterface mtroller_,\n                InterestRateModel interestRateModel_,\n                uint reserveFactorMantissa_,\n                uint initialExchangeRateMantissa_,\n                uint protocolSeizeShareMantissa_,\n                string memory name_,\n                string memory symbol_,\n                uint8 decimals_) public;\n\n    /*** User Interface ***/\n\n    function redeem(uint redeemTokens) external returns (uint);\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\n    function borrow(uint borrowAmount) external returns (uint);\n    function flashBorrow(uint borrowAmount, address payable receiver, bytes calldata flashParams) external payable returns (uint);\n    function name() public view returns (string memory);\n    function symbol() public view returns (string memory);\n    function decimals() public view returns (uint8);\n}\n\ncontract MEtherUserInterface is MFungibleTokenUserInterface {\n\n    /*** Admin Functions ***/\n\n    function getProtocolAuctionFeeMantissa() external view returns (uint);\n    function _addReserves() external payable returns (uint);\n\n    /*** User Interface ***/\n\n    function mint() external payable returns (uint);\n    function mintTo(address beneficiary) external payable returns (uint);\n    function repayBorrow() external payable returns (uint);\n    function repayBorrowBehalf(address borrower) external payable returns (uint);\n    function liquidateBorrow(address borrower, uint240 mTokenCollateral) external payable returns (uint);\n}\n\ncontract MEtherInterface is MEtherAdminInterface, MEtherUserInterface {}\n\ncontract MERC721AdminInterface is MTokenAdminInterface, IERC721, IERC721Metadata {\n\n    event NewTokenAuctionContract(TokenAuction oldTokenAuction, TokenAuction newTokenAuction);\n\n    /*** Admin Functions ***/\n\n    function initialize(address underlyingContract_,\n                MtrollerInterface mtroller_,\n                InterestRateModel interestRateModel_,\n                TokenAuction tokenAuction_,\n                string memory name_,\n                string memory symbol_) public;\n\n    /*** User Interface ***/\n\n    function redeem(uint240 mToken) public returns (uint);\n    function redeemUnderlying(uint256 underlyingID) external returns (uint);\n    function redeemAndSell(uint240 mToken, uint sellPrice, address payable transferHandler, bytes memory transferParams) public returns (uint);\n    function borrow(uint256 borrowUnderlyingID) external returns (uint);\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\ncontract MERC721UserInterface is MTokenUserInterface, IERC721 {\n\n    event LiquidateToPaymentToken(address indexed oldOwner, address indexed newOwner, uint240 mToken, uint256 auctioneerTokens, uint256 oldOwnerTokens);\n\n    /*** Admin Functions ***/\n\n//    function _addReserves(uint240 mToken, uint addAmount) external payable returns (uint);\n\n    /*** User Interface ***/\n\n    function mint(uint256 underlyingTokenID) external returns (uint240);\n    function mintAndCollateralizeTo(address beneficiary, uint256 underlyingTokenID) external returns (uint240);\n    function mintTo(address beneficiary, uint256 underlyingTokenID) public returns (uint240);\n//    function repayBorrow(uint256 repayUnderlyingID) external payable returns (uint);\n//    function repayBorrowBehalf(address borrower, uint256 repayUnderlyingID) external payable returns (uint);\n//    function liquidateBorrow(address borrower, uint256 repayUnderlyingID, uint240 mTokenCollateral) external payable returns (uint);\n    function addAuctionBid(uint240 mToken) external payable;\n    function instantSellToHighestBidder(uint240 mToken, uint256 minimumPrice) public;\n    function setAskingPrice(uint240 mToken, uint256 newAskingPrice) external;\n    function startGracePeriod(uint240 mToken) external returns (uint);\n    function liquidateToPaymentToken(uint240 mToken) external returns (uint, uint240, uint, uint);\n}\n\ncontract MERC721Interface is MERC721AdminInterface, MERC721UserInterface {}\n\ncontract FlashLoanReceiverInterface {\n    function executeFlashOperation(address payable borrower, uint240 mToken, uint borrowAmount, uint paidOutAmount, bytes calldata flashParams) external returns (uint);\n    function executeTransfer(uint256 tokenId, address payable seller, uint sellPrice, bytes calldata transferParams) external returns (uint);\n}\n"

    },

    "project:/contracts/MTokenStorage.sol": {

      "content": "pragma solidity ^0.5.16;\n\nimport \"./MtrollerInterface.sol\";\nimport \"./TokenAuction.sol\";\nimport \"./compound/InterestRateModel.sol\";\n\ncontract MDelegateeStorage {\n    /**\n    * @notice List of all public function selectors implemented by \"admin type\" contract\n    * @dev Needs to be initialized in the constructor(s)\n    */\n    bytes4[] public implementedSelectors;\n\n    function implementedSelectorsLength() public view returns (uint) {\n        return implementedSelectors.length;\n    }\n}\n\ncontract MTokenV1Storage is MDelegateeStorage {\n\n    /**\n     * @dev Guard variable for re-entrancy checks\n     */\n    bool internal _notEntered;\n    bool internal _notEntered2;\n\n\n    /*** Global variables: addresses of other contracts to call. \n     *   These are set at contract initialization and can only be modified by a (timelock) admin\n    ***/\n\n    /**\n     * @notice Address of the underlying asset contract (this never changes again after initialization)\n     */\n    address public underlyingContract;\n\n    /**\n     * @notice Contract address of model which tells what the current interest rate(s) should be\n     */\n    InterestRateModel public interestRateModel;\n\n    /**\n     * @notice Contract used for (non-fungible) mToken auction (used only if applicable)\n     */ \n    TokenAuction public tokenAuction;\n\n    /**\n     * @notice Contract which oversees inter-mToken operations\n     */\n    MtrollerInterface public mtroller;\n\n\n    /*** Global variables: token identification constants. \n     *   These variables are set at contract initialization and never modified again\n    ***/\n\n    /**\n     * @notice EIP-20 token name for this token\n     */\n    string public mName;\n\n    /**\n     * @notice EIP-20 token symbol for this token\n     */\n    string public mSymbol;\n\n    /**\n     * @notice EIP-20 token decimals for this token\n     */\n    uint8 public mDecimals;\n\n\n    /*** Global variables: protocol control parameters. \n     *   These variables are set at contract initialization and can only be modified by a (timelock) admin\n    ***/\n\n    /**\n     * @notice Initial exchange rate used when minting the first mTokens (used when totalSupply = 0)\n     */\n    uint internal initialExchangeRateMantissa;\n\n    /**\n     * @notice Fraction of interest currently set aside for reserves\n     */\n    uint internal constant reserveFactorMaxMantissa = 50e16; // upper protocol limit (50%)\n    uint public reserveFactorMantissa;\n\n    /**\n     * @notice Fraction of seized (fungible) collateral that is added to reserves\n     */\n    uint internal constant protocolSeizeShareMaxMantissa = 5e16; // upper protocol limit (5%)\n    uint public protocolSeizeShareMantissa;\n\n    /**\n     * @notice Fraction of new borrow amount set aside for reserves (one-time fee)\n     */\n    uint internal constant borrowFeeMaxMantissa = 50e16; // upper protocol limit (50%)\n    uint public borrowFeeMantissa;\n\n    /**\n     * @notice Mapping of addresses that are whitelisted as receiver for flash loans\n     */\n    mapping (address => bool) public flashReceiverIsWhitelisted;\n\n\n    /*** Global variables: auction liquidation control parameters. \n     *   The variables are set at contract initialization and can only be changed by a (timelock) admin\n    ***/\n\n    /**\n     * @notice Minimum and maximum values that can ever be used for the grace period, which is\n     * the minimum time liquidators have to wait before they can seize a non-fungible mToken collateral\n     */ \n    uint256 public constant auctionMinGracePeriod = 2000; // lower limit (2000 blocks, i.e. about 8 hours)\n    uint256 public constant auctionMaxGracePeriod = 50000; // upper limit (50000 blocks, i.e. about 8.5 days)\n    uint256 public auctionGracePeriod;\n\n    /**\n     * @notice \"Headstart\" time in blocks the preferredLiquidator has available to liquidate a mToken\n     * exclusively before everybody else is also allowed to do it.\n     */\n    uint256 public constant preferredLiquidatorMaxHeadstart = 2000; // upper limit (2000 blocks, i.e. about 8 hours)\n    uint256 public preferredLiquidatorHeadstart;\n\n    /**\n     * @notice Minimum offer required to win liquidation auction, relative to the NFTs regular price.\n     */\n    uint public constant minimumOfferMaxMantissa = 80e16; // upper limit (80% of market price)\n    uint public minimumOfferMantissa;\n\n    /**\n     * @notice Fee for the liquidator executing liquidateToPaymentToken().\n     */\n    uint public constant liquidatorAuctionFeeMaxMantissa = 10e16; // upper limit (10%)\n    uint public liquidatorAuctionFeeMantissa;\n\n    /**\n     * @notice Fee for the protocol when executing liquidateToPaymentToken() or acceptHighestOffer().\n     * The funds are directly added to mEther reserves.\n     */\n    uint public constant protocolAuctionFeeMaxMantissa = 20e16; // upper limit (50%)\n    uint public protocolAuctionFeeMantissa;\n\n\n    /*** Token variables: basic token identification. \n     *   These variables are only initialized the first time the given token is minted\n    ***/\n\n    /**\n     * @notice Mapping of mToken to underlying tokenID\n     */\n    mapping (uint240 => uint256) public underlyingIDs;\n\n    /**\n     * @notice Mapping of underlying tokenID to mToken\n     */\n    mapping (uint256 => uint240) public mTokenFromUnderlying;\n\n    /**\n     * @notice Total number of (ever) minted mTokens. Note: Burning a mToken (when redeeming the \n     * underlying asset) DOES NOT reduce this count. The maximum possible amount of tokens that \n     * can ever be minted by this contract is limited to 2^88-1, which is finite but high enough \n     * to never be reached in realistic time spans.\n     */\n    uint256 public totalCreatedMarkets;\n\n    /**\n     * @notice Maps mToken to block number that interest was last accrued at\n     */\n    mapping (uint240 => uint) public accrualBlockNumber;\n\n    /**\n     * @notice Maps mToken to accumulator of the total earned interest rate since the opening of that market\n     */\n    mapping (uint240 => uint) public borrowIndex;\n\n\n    /*** Token variables: general token accounting. \n     *   These variables are initialized the first time the given token is minted and then adapted when needed\n    ***/\n\n    /**\n     * @notice Official record of token balances for each mToken, for each account\n     */\n    mapping (uint240 => mapping (address => uint)) internal accountTokens;\n\n    /**\n     * @notice Container for borrow balance information\n     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\n     * @member interestIndex Global borrowIndex as of the most recent balance-changing action\n     */\n    struct BorrowSnapshot {\n        uint principal;\n        uint interestIndex;\n    }\n\n    /**\n     * @notice Mapping of account addresses to outstanding borrow balances, for any given mToken\n     */\n    mapping(uint240 => mapping(address => BorrowSnapshot)) internal accountBorrows;\n\n    /**\n     * @notice Maximum borrow rate that can ever be applied (.0005% / block)\n     */\n    uint internal constant borrowRateMaxMantissa = 0.0005e16;\n\n    /**\n     * @notice Maps mToken to total amount of cash of the underlying in that market\n     */\n    mapping (uint240 => uint) public totalCashUnderlying;\n\n    /**\n     * @notice Maps mToken to total amount of outstanding borrows of the underlying in that market\n     */\n    mapping (uint240 => uint) public totalBorrows;\n\n    /**\n     * @notice Maps mToken to total amount of reserves of the underlying held in that market\n     */\n    mapping (uint240 => uint) public totalReserves;\n\n    /**\n     * @notice Maps mToken to total number of tokens in circulation in that market\n     */\n    mapping (uint240 => uint) public totalSupply;\n\n\n    /*** Token variables: Special variables used for fungible tokens (e.g. ERC-20). \n     *   These variables are initialized the first time the given token is minted and then adapted when needed\n    ***/\n\n    /**\n     * @notice Dummy ID for \"underlying asset\" in case of a (single) fungible token\n     */\n    uint256 internal constant dummyTokenID = 1;\n\n    /**\n     * @notice The mToken for a (single) fungible token\n     */\n    uint240 public thisFungibleMToken;\n\n    /**\n     * @notice Approved token transfer amounts on behalf of others (for fungible tokens)\n     */\n    mapping (address => mapping (address => uint)) internal transferAllowances;\n\n\n    /*** Token variables: Special variables used for non-fungible tokens (e.g. ERC-721). \n     *   These variables are initialized the first time the given token is minted and then adapted when needed\n    ***/\n\n    /**\n     * @notice Virtual amount of \"cash\" that corresponds to one underlying NFT. This is used as \n     * calculatory units internally for mTokens with strictly non-fungible underlying (such as ERC-721) \n     * to avoid loss of mathematical precision for calculations such as borrowing amounts. However, both \n     * underlying NFT and associated mToken are still non-fungible (ERC-721 compliant) tokens and can \n     * only be transferred as one item.\n     */\n    uint internal constant oneUnit = 1e18;\n\n    /**\n     * @notice Mapping of mToken to the block number of the last block in their grace period (zero\n     * if mToken is not in a grace period)\n     */\n    mapping (uint240 => uint256) public lastBlockGracePeriod;\n\n    /**\n     * @notice Mapping of mToken to the address that has \"fist mover\" rights to do the liquidation\n     * for the mToken (because that address first called startGracePeriod())\n     */\n    mapping (uint240 => address) public preferredLiquidator;\n\n    /**\n     * @notice Asking price that can be set by a mToken's current owner. At or above this price the mToken\n     * will be instantly sold. Set to zero to disable.\n     */\n    mapping (uint240 => uint256) public askingPrice;\n}\n"

    },

    "project:/contracts/MTokenTest_coins.sol": {

      "content": "pragma solidity ^0.5.16;\n\nimport \"./open-zeppelin/token/ERC721/ERC721.sol\";\nimport \"./open-zeppelin/token/ERC721/IERC721Metadata.sol\";\nimport \"./open-zeppelin/token/ERC20/ERC20.sol\";\n\ncontract TestNFT is ERC721, IERC721Metadata {\n\n    string internal constant _name = \"Glasses\";\n    string internal constant _symbol = \"GLSS\";\n    uint256 public constant price = 0.1e18;\n    uint256 public constant maxSupply = 1000;\n    uint256 public nextTokenID;\n    address payable public admin;\n    string internal _baseURI;\n    uint internal _digits;\n    string internal _suffix;\n\n    constructor(address payable _admin) ERC721(_name, _symbol) public {\n        admin = msg.sender;\n        _setMetadata(\"ipfs://QmWNi2ByeUbY1fWbMq841nvNW2tDTpNzyGAhxWDqoXTAEr\", 0, \"\");\n        admin = _admin;\n    }\n    \n    function mint() public payable returns (uint256 newTokenID) {\n        require(nextTokenID < maxSupply, \"all Glasses sold out\");\n        require(msg.value >= price, \"payment too low\");\n        newTokenID = nextTokenID;\n        nextTokenID++;\n        _safeMint(msg.sender, newTokenID);\n    }\n\n    function () external payable {\n        mint();\n    }\n\n//***** below this is just for trying out NFTX market functionality */\n    function buyAndRedeem(uint256 vaultId, uint256 amount, uint256[] calldata specificIds, address[] calldata path, address to) external payable {\n        path;\n        require(vaultId == 2, \"wrong vault\");\n        require(amount == 1, \"wrong amount\");\n        require(specificIds[0] == nextTokenID, \"wrong ID\");\n        require(to == msg.sender, \"wrong to\");\n        mint();\n    }\n//***** above this is just for trying out NFTX market functionality */\n\n    function name() external view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() external view returns (string memory) {\n        return _symbol;\n    }\n\n    function tokenURI(uint256 tokenId) external view returns (string memory) {\n        require(_exists(tokenId), \"URI query for nonexistent token\");\n        if (_digits == 0) {\n            return string(abi.encodePacked(_baseURI, _suffix));\n        }\n        else {\n            bytes memory _tokenID = new bytes(_digits);\n            uint _i = _digits;\n            while (_i != 0) {\n                _i--;\n                _tokenID[_i] = bytes1(48 + uint8(tokenId % 10));\n                tokenId /= 10;\n            }\n            return string(abi.encodePacked(_baseURI, string(_tokenID), _suffix));\n        }\n    }\n\n    /*** Admin functions ***/\n\n    function _setMetadata(string memory newBaseURI, uint newDigits, string memory newSuffix) public {\n        require(msg.sender == admin, \"only admin\");\n        require(newDigits < 10, \"newDigits too big\");\n        _baseURI = newBaseURI;\n        _digits = newDigits;\n        _suffix = newSuffix;\n    }\n\n    function _setAdmin(address payable newAdmin) public {\n        require(msg.sender == admin, \"only admin\");\n        admin = newAdmin;\n    }\n\n    function _withdraw() external {\n        require(msg.sender == admin, \"only admin\");\n        admin.transfer(address(this).balance);\n    }\n}\n\ncontract TestERC20 is ERC20 {\n    constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_) public {\n    }\n\n    function mint(uint256 amount) external {\n        _mint(msg.sender, amount);\n    }\n}\n\n"

    },

    "project:/contracts/MtrollerInterface.sol": {

      "content": "pragma solidity ^0.5.16;\n\nimport \"./PriceOracle.sol\";\n\ncontract MTokenIdentifier {\n    /* mToken identifier handling */\n    \n    enum MTokenType {\n        INVALID_MTOKEN,\n        FUNGIBLE_MTOKEN,\n        ERC721_MTOKEN\n    }\n\n    /*\n     * Marker for valid mToken contract. Derived MToken contracts need to override this returning \n     * the correct MTokenType for that MToken\n    */\n    function getTokenType() public pure returns (MTokenType) {\n        return MTokenType.INVALID_MTOKEN;\n    }\n}\n\ncontract MDelegatorIdentifier {\n    // Storage position of the admin of a delegator contract\n    bytes32 internal constant mDelegatorAdminPosition = \n        keccak256(\"com.mmo-finance.mDelegator.admin.address\");\n}\n\ncontract MtrollerCommonInterface is MTokenIdentifier, MDelegatorIdentifier {\n    /// @notice Emitted when an admin supports a market\n    event MarketListed(uint240 mToken);\n\n    /// @notice Emitted when a collateral factor is changed by admin\n    event NewCollateralFactor(uint240 mToken, uint oldCollateralFactorMantissa, uint newCollateralFactorMantissa);\n\n    /// @notice Emitted when an account enters a market\n    event MarketEntered(uint240 mToken, address account);\n\n    /// @notice Emitted when an account exits a market\n    event MarketExited(uint240 mToken, address account);\n\n    /// @notice Emitted when a new MMO speed is calculated for a market\n    event MmoSpeedUpdated(uint240 indexed mToken, uint newSpeed);\n\n    /// @notice Emitted when a new MMO speed is set for a contributor\n    event ContributorMmoSpeedUpdated(address indexed contributor, uint newSpeed);\n\n    /// @notice Emitted when MMO is distributed to a supplier\n    event DistributedSupplierMmo(uint240 indexed mToken, address indexed supplier, uint mmoDelta, uint MmoSupplyIndex);\n\n    /// @notice Emitted when MMO is distributed to a borrower\n    event DistributedBorrowerMmo(uint240 indexed mToken, address indexed borrower, uint mmoDelta, uint mmoBorrowIndex);\n\n    /// @notice Emitted when MMO is granted by admin\n    event MmoGranted(address recipient, uint amount);\n\n    /// @notice Emitted when close factor is changed by admin\n    event NewCloseFactor(uint oldCloseFactorMantissa, uint newCloseFactorMantissa);\n\n    /// @notice Emitted when liquidation incentive is changed by admin\n    event NewLiquidationIncentive(uint oldLiquidationIncentiveMantissa, uint newLiquidationIncentiveMantissa);\n\n    /// @notice Emitted when maxAssets is changed by admin\n    event NewMaxAssets(uint oldMaxAssets, uint newMaxAssets);\n\n    /// @notice Emitted when price oracle is changed\n    event NewPriceOracle(PriceOracle oldPriceOracle, PriceOracle newPriceOracle);\n\n    /// @notice Emitted when pause guardian is changed\n    event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\n\n    /// @notice Emitted when an action is paused globally\n    event ActionPaused(string action, bool pauseState);\n\n    /// @notice Emitted when an action is paused on a market\n    event ActionPaused(uint240 mToken, string action, bool pauseState);\n\n    /// @notice Emitted when borrow cap for a mToken is changed\n    event NewBorrowCap(uint240 indexed mToken, uint newBorrowCap);\n\n    /// @notice Emitted when borrow cap guardian is changed\n    event NewBorrowCapGuardian(address oldBorrowCapGuardian, address newBorrowCapGuardian);\n\n    function getAdmin() public view returns (address payable admin);\n\n    function underlyingContractETH() public pure returns (address);\n    function getAnchorToken(address mTokenContract) public pure returns (uint240);\n    function assembleToken(MTokenType mTokenType, uint72 mTokenSeqNr, address mTokenAddress) public pure returns (uint240 mToken);\n    function parseToken(uint240 mToken) public pure returns (MTokenType mTokenType, uint72 mTokenSeqNr, address mTokenAddress);\n\n    function collateralFactorMantissa(uint240 mToken) public view returns (uint);\n}\n\ncontract MtrollerUserInterface is MtrollerCommonInterface {\n\n    /// @notice Indicator that this is a user part contract (for inspection)\n    function isMDelegatorUserImplementation() public pure returns (bool);\n\n    /*** Assets You Are In ***/\n\n    function getAssetsIn(address account) external view returns (uint240[] memory);\n    function checkMembership(address account, uint240 mToken) external view returns (bool);\n    function enterMarkets(uint240[] calldata mTokens) external returns (uint[] memory);\n    function enterMarketOnBehalf(uint240 mToken, address owner) external returns (uint);\n    function exitMarket(uint240 mToken) external returns (uint);\n    function exitMarketOnBehalf(uint240 mToken, address owner) external returns (uint);\n    function _setCollateralFactor(uint240 mToken, uint newCollateralFactorMantissa) external returns (uint);\n\n    /*** Policy Hooks ***/\n\n    function auctionAllowed(uint240 mToken, address bidder) public returns (uint);\n    function mintAllowed(uint240 mToken, address minter, uint mintAmount) external returns (uint);\n    function mintVerify(uint240 mToken, address minter, uint actualMintAmount, uint mintTokens) external;\n    function redeemAllowed(uint240 mToken, address redeemer, uint redeemTokens) external returns (uint);\n    function redeemVerify(uint240 mToken, address redeemer, uint redeemAmount, uint redeemTokens) external;\n    function borrowAllowed(uint240 mToken, address borrower, uint borrowAmount) external returns (uint);\n    function borrowVerify(uint240 mToken, address borrower, uint borrowAmount) external;\n    function repayBorrowAllowed(uint240 mToken, address payer, address borrower, uint repayAmount) external returns (uint);\n    function repayBorrowVerify(uint240 mToken, address payer, address borrower, uint actualRepayAmount, uint borrowerIndex) external;\n    function liquidateBorrowAllowed(uint240 mTokenBorrowed, uint240 mTokenCollateral, address liquidator, address borrower, uint repayAmount) external returns (uint);\n    function liquidateERC721Allowed(uint240 mToken) external returns (uint);\n    function liquidateBorrowVerify(uint240 mTokenBorrowed, uint240 mTokenCollateral, address liquidator, address borrower, uint actualRepayAmount, uint seizeTokens) external;\n    function seizeAllowed(uint240 mTokenCollateral, uint240 mTokenBorrowed, address liquidator, address borrower, uint seizeTokens) external returns (uint);\n    function seizeVerify(uint240 mTokenCollateral, uint240 mTokenBorrowed, address liquidator, address borrower, uint seizeTokens) external;\n    function transferAllowed(uint240 mToken, address src, address dst, uint transferTokens) external returns (uint);\n    function transferVerify(uint240 mToken, address src, address dst, uint transferTokens) external;\n\n    /*** Price and Liquidity/Liquidation Calculations ***/\n    function getAccountLiquidity(address account) public view returns (uint, uint, uint);\n    function getHypotheticalAccountLiquidity(address account, uint240 mTokenModify, uint redeemTokens, uint borrowAmount) public view returns (uint, uint, uint);\n    function liquidateCalculateSeizeTokens(uint240 mTokenBorrowed, uint240 mTokenCollateral, uint actualRepayAmount) external view returns (uint, uint);\n    function getBlockNumber() public view returns (uint);\n    function getPrice(uint240 mToken) public view returns (uint);\n\n    /*** Mmo reward handling ***/\n    function updateContributorRewards(address contributor) public;\n    function claimMmo(address holder, uint240[] memory mTokens) public;\n    function claimMmo(address[] memory holders, uint240[] memory mTokens, bool borrowers, bool suppliers) public;\n\n    /*** Mmo admin functions ***/\n    function _grantMmo(address recipient, uint amount) public;\n    function _setMmoSpeed(uint240 mToken, uint mmoSpeed) public;\n    function _setContributorMmoSpeed(address contributor, uint mmoSpeed) public;\n    function getMmoAddress() public view returns (address);\n}\n\ncontract MtrollerAdminInterface is MtrollerCommonInterface {\n\n    function initialize(address _mmoTokenAddress, uint _maxAssets) public;\n\n    /// @notice Indicator that this is a admin part contract (for inspection)\n    function isMDelegatorAdminImplementation() public pure returns (bool);\n\n    function _supportMarket(uint240 mToken) external returns (uint);\n    function _setPriceOracle(PriceOracle newOracle) external returns (uint);\n    function _setCloseFactor(uint newCloseFactorMantissa) external returns (uint);\n    function _setLiquidationIncentive(uint newLiquidationIncentiveMantissa) external returns (uint);\n    function _setMaxAssets(uint newMaxAssets) external;\n    function _setBorrowCapGuardian(address newBorrowCapGuardian) external;\n    function _setMarketBorrowCaps(uint240[] calldata mTokens, uint[] calldata newBorrowCaps) external;\n    function _setPauseGuardian(address newPauseGuardian) public returns (uint);\n    function _setAuctionPaused(uint240 mToken, bool state) public returns (bool);\n    function _setMintPaused(uint240 mToken, bool state) public returns (bool);\n    function _setBorrowPaused(uint240 mToken, bool state) public returns (bool);\n    function _setTransferPaused(uint240 mToken, bool state) public returns (bool);\n    function _setSeizePaused(uint240 mToken, bool state) public returns (bool);\n}\n\ncontract MtrollerInterface is MtrollerAdminInterface, MtrollerUserInterface {}\n"

    },

    "project:/contracts/PriceOracle.sol": {

      "content": "pragma solidity ^0.5.16;\n\nimport \"./MTokenTest_coins.sol\";\n\ncontract PriceOracle {\n    /// @notice Indicator that this is a PriceOracle contract (for inspection)\n    bool public constant isPriceOracle = true;\n\n    /**\n      * @notice Get the price of an underlying token\n      * @param underlyingToken The address of the underlying token contract\n      * @param tokenID The ID of the underlying token if it is a NFT (0 for fungible tokens)\n      * @return The underlying asset price mantissa (scaled by 1e18). For fungible underlying tokens that\n      * means e.g. if one single underlying token costs 1 Wei then the asset price mantissa should be 1e18. \n      * In case of underlying (ERC-721 compliant) NFTs one NFT always corresponds to oneUnit = 1e18 \n      * internal calculatory units (see MTokenInterfaces.sol), therefore if e.g. one NFT costs 0.1 ETH \n      * then the asset price mantissa returned here should be 0.1e18.\n      * Zero means the price is unavailable.\n      */\n    function getUnderlyingPrice(address underlyingToken, uint256 tokenID) public view returns (uint);\n}\n\ncontract PriceOracleV0_1 is PriceOracle {\n\n    event NewCollectionFloorPrice(uint oldFloorPrice, uint newFloorPrice);\n\n    address admin;\n    TestNFT glassesContract;\n    IERC721 collectionContract;\n    uint collectionFloorPrice;\n\n    constructor(address _admin, TestNFT _glassesContract, IERC721 _collectionContract) public {\n        admin = _admin;\n        glassesContract = _glassesContract;\n        collectionContract = _collectionContract;\n    }\n\n    function getUnderlyingPrice(address underlyingToken, uint256 tokenID) public view returns (uint) {\n        tokenID;\n        if (underlyingToken == address(uint160(-1))) {\n            return 1.0e18; // relative price of MEther token is 1.0 (1 token = 1 Wei)\n        }\n        else if (underlyingToken == address(glassesContract)) {\n            return glassesContract.price(); // one unit (1e18) of NFT price in wei\n        }\n        else if (underlyingToken == address(collectionContract)) {\n            return collectionFloorPrice; // one unit (1e18) of NFT price in wei\n        }\n        else {\n            return 0;\n        }\n    }\n\n    function _setCollectionFloorPrice(uint newFloorPrice) external {\n        require(msg.sender == admin, \"only admin\");\n        uint oldFloorPrice = collectionFloorPrice;\n        collectionFloorPrice = newFloorPrice;\n\n        emit NewCollectionFloorPrice(oldFloorPrice, newFloorPrice);\n    }\n}\n\n"

    },

    "project:/contracts/TokenAuction.sol": {

      "content": "pragma solidity ^0.5.16;\n\nimport \"./MtrollerInterface.sol\";\nimport \"./MTokenInterfaces.sol\";\nimport \"./ErrorReporter.sol\";\nimport \"./compound/Exponential.sol\";\nimport \"./open-zeppelin/token/ERC721/IERC721.sol\";\n\ncontract TokenAuction is Exponential, TokenErrorReporter {\n\n    event NewAuctionOffer(uint240 tokenID, address offeror, uint256 totalOfferAmount);\n    event AuctionOfferCancelled(uint240 tokenID, address offeror, uint256 cancelledOfferAmount);\n    event HighestOfferAccepted(uint240 tokenID, address offeror, uint256 acceptedOfferAmount, uint256 auctioneerTokens, uint256 oldOwnerTokens);\n    event AuctionRefund(address beneficiary, uint256 amount);\n\n    struct Bidding {\n        mapping (address => uint256) offers;\n        mapping (address => uint256) offerIndex;\n        uint256 nextOffer;\n        mapping (uint256 => mapping (uint256 => address)) maxOfferor;\n    }\n\n    bool internal _notEntered; // re-entrancy check flag\n    \n    MEtherUserInterface public paymentToken;\n    MtrollerUserInterface public mtroller;\n\n    mapping (uint240 => Bidding) public biddings;\n\n    // ETH account for each participant\n    mapping (address => uint256) public refunds;\n\n    constructor(MtrollerUserInterface _mtroller, MEtherUserInterface _fungiblePaymentToken) public\n    {\n        mtroller = _mtroller;\n        paymentToken = _fungiblePaymentToken;\n        _notEntered = true; // Start true prevents changing from zero to non-zero (smaller gas cost)\n    }\n\n    function addOfferETH(\n        uint240 _mToken,\n        address _bidder,\n        address _oldOwner,\n        uint256 _askingPrice\n    )\n        external\n        nonReentrant\n        payable\n        returns (uint256)\n    {\n        require (msg.value > 0, \"No payment sent\");\n        require(mtroller.auctionAllowed(_mToken, _bidder) == uint(Error.NO_ERROR), \"Auction not allowed\");\n        ( , , address _tokenAddress) = mtroller.parseToken(_mToken);\n        require(msg.sender == _tokenAddress, \"Only token contract\");\n        uint256 _oldOffer = biddings[_mToken].offers[_bidder];\n        uint256 _newOffer = _oldOffer + msg.value;\n\n        /* if new offer is >= asking price of mToken, we do not enter the bid but sell directly */\n        if (_newOffer >= _askingPrice && _askingPrice > 0) {\n            if (_oldOffer > 0) {\n                require(cancelOfferInternal(_mToken, _bidder) == _oldOffer, \"Could not cancel offer\");\n            }\n            ( , uint256 oldOwnerTokens) = processPaymentInternal(_oldOwner, _newOffer, _oldOwner, 0);\n            emit HighestOfferAccepted(_mToken, _bidder, _newOffer, 0, oldOwnerTokens);\n            return _newOffer;\n        }\n        /* otherwise the new bid is entered normally */\n        else {\n            if (_oldOffer == 0) {\n                uint256 _nextIndex = biddings[_mToken].nextOffer;\n                biddings[_mToken].offerIndex[_bidder] = _nextIndex;\n                biddings[_mToken].nextOffer = _nextIndex + 1;\n            }\n            _updateOffer(_mToken, biddings[_mToken].offerIndex[_bidder], _bidder, _newOffer);\n            emit NewAuctionOffer(_mToken, _bidder, _newOffer);\n            return 0;\n        }\n    }\n\n    function cancelOffer(\n        uint240 _mToken\n    )\n        public\n        nonReentrant\n    {\n        // // for later version: if sender is the highest bidder try to start grace period \n        // // and do not allow to cancel bid during grace period (+ 2 times preferred liquidator delay)\n        // if (msg.sender == getMaxOfferor(_mToken)) {\n        //     ( , , address _mTokenAddress) = mtroller.parseToken(_mToken);\n        //     MERC721Interface(_mTokenAddress).startGracePeriod(_mToken);\n        // }\n        uint256 _oldOffer = cancelOfferInternal(_mToken, msg.sender);\n        refunds[msg.sender] += _oldOffer;\n        emit AuctionOfferCancelled(_mToken, msg.sender, _oldOffer);\n    }\n    \n    function acceptHighestOffer(\n        uint240 _mToken,\n        address _oldOwner,\n        address _auctioneer,\n        uint256 _auctioneerFeeMantissa,\n        uint256 _minimumPrice\n    )\n        external\n        nonReentrant\n        returns (address _maxOfferor, uint256 _maxOffer, uint256 auctioneerTokens, uint256 oldOwnerTokens)\n    {\n        require(mtroller.auctionAllowed(_mToken, _auctioneer) == uint(Error.NO_ERROR), \"Auction not allowed\");\n        ( , , address _tokenAddress) = mtroller.parseToken(_mToken);\n        require(msg.sender == _tokenAddress, \"Only token contract\");\n        _maxOfferor = getMaxOfferor(_mToken); // reverts if no valid offer found\n        _maxOffer = cancelOfferInternal(_mToken, _maxOfferor);\n        require(_maxOffer >= _minimumPrice, \"Best offer too low\");\n\n        /* process payment, reverts on error */\n        (auctioneerTokens, oldOwnerTokens) = processPaymentInternal(_oldOwner, _maxOffer, _auctioneer, _auctioneerFeeMantissa);\n\n        emit HighestOfferAccepted(_mToken, _maxOfferor, _maxOffer, auctioneerTokens, oldOwnerTokens);\n        \n        return (_maxOfferor, _maxOffer, auctioneerTokens, oldOwnerTokens);\n    }\n\n    function processPaymentInternal(\n        address _oldOwner,\n        uint256 _price,\n        address _broker,\n        uint256 _brokerFeeMantissa\n    )\n        internal\n        returns (uint256 brokerTokens, uint256 oldOwnerTokens) \n    {\n        require(_oldOwner != address(0), \"Invalid owner address\");\n        require(_price > 0, \"Invalid price\");\n        \n        /* calculate fees for protocol and add it to protocol's reserves (in underlying cash) */\n        uint256 _amountLeft = _price;\n        Exp memory _feeShare = Exp({mantissa: paymentToken.getProtocolAuctionFeeMantissa()});\n        (MathError _mathErr, uint256 _fee) = mulScalarTruncate(_feeShare, _price);\n        require(_mathErr == MathError.NO_ERROR, \"Invalid protocol fee\");\n        if (_fee > 0) {\n            (_mathErr, _amountLeft) = subUInt(_price, _fee);\n            require(_mathErr == MathError.NO_ERROR, \"Invalid protocol fee\");\n            paymentToken._addReserves.value(_fee)();\n        }\n\n        /* calculate and pay broker's fee (if any) by minting corresponding paymentToken amount */\n        _feeShare = Exp({mantissa: _brokerFeeMantissa});\n        (_mathErr, _fee) = mulScalarTruncate(_feeShare, _price);\n        require(_mathErr == MathError.NO_ERROR, \"Invalid broker fee\");\n        if (_fee > 0) {\n            require(_broker != address(0), \"Invalid broker address\");\n            (_mathErr, _amountLeft) = subUInt(_amountLeft, _fee);\n            require(_mathErr == MathError.NO_ERROR, \"Invalid broker fee\");\n            brokerTokens = paymentToken.mintTo.value(_fee)(_broker);\n        }\n\n        /* \n         * Pay anything left to the old owner by minting a corresponding paymentToken amount. In case \n         * of liquidation these paymentTokens can be liquidated in a next step. \n         * NEVER pay underlying cash to the old owner here!!\n         */\n        if (_amountLeft > 0) {\n            oldOwnerTokens = paymentToken.mintTo.value(_amountLeft)(_oldOwner);\n        }\n    }\n    \n    function cancelOfferInternal(\n        uint240 _mToken,\n        address _offeror\n    )\n        internal\n        returns (uint256 _oldOffer)\n    {\n        _oldOffer = biddings[_mToken].offers[_offeror];\n        require (_oldOffer > 0, \"No active offer found\");\n        uint256 _thisIndex = biddings[_mToken].offerIndex[_offeror];\n        uint256 _nextIndex = biddings[_mToken].nextOffer;\n        assert (_nextIndex > 0);\n        _nextIndex--;\n        if (_thisIndex != _nextIndex) {\n            address _swappedOfferor = biddings[_mToken].maxOfferor[0][_nextIndex];\n            biddings[_mToken].offerIndex[_swappedOfferor] = _thisIndex;\n            uint256 _newOffer = biddings[_mToken].offers[_swappedOfferor];\n            _updateOffer(_mToken, _thisIndex, _swappedOfferor, _newOffer);\n        }\n        _updateOffer(_mToken, _nextIndex, address(0), 0);\n        delete biddings[_mToken].offers[_offeror];\n        delete biddings[_mToken].offerIndex[_offeror];\n        biddings[_mToken].nextOffer = _nextIndex;\n        return _oldOffer;\n    }\n    \n    /**\n        @notice Withdraws any funds the contract has collected for the msg.sender from refunds\n                and proceeds of sales or auctions.\n    */\n    function withdrawAuctionRefund() \n        public\n        nonReentrant \n    {\n        require(refunds[msg.sender] > 0, \"No outstanding refunds found\");\n        uint256 _refundAmount = refunds[msg.sender];\n        refunds[msg.sender] = 0;\n        msg.sender.transfer(_refundAmount);\n        emit AuctionRefund(msg.sender, _refundAmount);\n    }\n\n    /**\n        @notice Convenience function to cancel and withdraw in one call\n    */\n    function cancelOfferAndWithdrawRefund(\n        uint240 _mToken\n    )\n        external\n    {\n        cancelOffer(_mToken);\n        withdrawAuctionRefund();\n    }\n\n    uint256 constant private clusterSize = (2**4);\n\n    function _updateOffer(\n        uint240 _mToken,\n        uint256 _offerIndex,\n        address _newOfferor,\n        uint256 _newOffer\n    )\n        internal\n    {\n        assert (biddings[_mToken].nextOffer > 0);\n        assert (biddings[_mToken].offers[address(0)] == 0);\n        uint256 _n = 0;\n        address _origOfferor = _newOfferor;\n        uint256 _origOffer = biddings[_mToken].offers[_newOfferor];\n        if (_newOffer != _origOffer) {\n            biddings[_mToken].offers[_newOfferor] = _newOffer;\n        }\n        \n        for (uint256 tmp = biddings[_mToken].nextOffer * clusterSize; tmp > 0; tmp = tmp / clusterSize) {\n\n            uint256 _oldOffer;\n            address _oldOfferor = biddings[_mToken].maxOfferor[_n][_offerIndex];\n            if (_oldOfferor != _newOfferor) {\n                biddings[_mToken].maxOfferor[_n][_offerIndex] = _newOfferor;\n            }\n\n            _offerIndex = _offerIndex / clusterSize;\n            address _maxOfferor = biddings[_mToken].maxOfferor[_n + 1][_offerIndex];\n            if (tmp < clusterSize) {\n                if (_maxOfferor != address(0)) {\n                    biddings[_mToken].maxOfferor[_n + 1][_offerIndex] = address(0);\n                }\n                return;\n            }\n            \n            if (_maxOfferor != address(0)) {\n                if (_oldOfferor == _origOfferor) {\n                    _oldOffer = _origOffer;\n                }\n                else {\n                    _oldOffer = biddings[_mToken].offers[_oldOfferor];\n                }\n                \n                if ((_oldOfferor != _maxOfferor) && (_newOffer <= _oldOffer)) {\n                    return;\n                }\n                if ((_oldOfferor == _maxOfferor) && (_newOffer > _oldOffer)) {\n                    _n++;\n                    continue;\n                }\n            }\n            uint256 _i = _offerIndex * clusterSize;\n            _newOfferor = biddings[_mToken].maxOfferor[_n][_i];\n            _newOffer = biddings[_mToken].offers[_newOfferor];\n            _i++;\n            while ((_i % clusterSize) != 0) {\n                address _tmpOfferor = biddings[_mToken].maxOfferor[_n][_i];\n                if (biddings[_mToken].offers[_tmpOfferor] > _newOffer) {\n                    _newOfferor = _tmpOfferor;\n                    _newOffer = biddings[_mToken].offers[_tmpOfferor];\n                }\n                _i++;\n            } \n            _n++;\n        }\n    }\n\n    function getMaxOffer(\n        uint240 _mToken\n    )\n        public\n        view\n        returns (uint256)\n    {\n        if (biddings[_mToken].nextOffer == 0) {\n            return 0;\n        }\n        return biddings[_mToken].offers[getMaxOfferor(_mToken)];\n    }\n\n    function getMaxOfferor(\n        uint240 _mToken\n    )\n        public\n        view\n        returns (address)\n    {\n        uint256 _n = 0;\n        for (uint256 tmp = biddings[_mToken].nextOffer * clusterSize; tmp > 0; tmp = tmp / clusterSize) {\n            _n++;\n        }\n        require (_n > 0, \"No valid offer found\");\n        _n--;\n        return biddings[_mToken].maxOfferor[_n][0];\n    }\n\n    function getMaxOfferor(\n        uint240 _mToken, \n        uint256 _level, \n        uint256 _offset\n    )\n        public\n        view\n        returns (address[10] memory _offerors)\n    {\n        for (uint256 _i = 0; _i < 10; _i++) {\n            _offerors[_i] = biddings[_mToken].maxOfferor[_level][_offset + _i];\n        }\n        return _offerors;\n    }\n\n    function getOffer(\n        uint240 _mToken,\n        address _account\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return biddings[_mToken].offers[_account];\n    }\n\n    function getOfferIndex(\n        uint240 _mToken\n    )\n        public\n        view\n        returns (uint256)\n    {\n        require (biddings[_mToken].offers[msg.sender] > 0, \"No active offer\");\n        return biddings[_mToken].offerIndex[msg.sender];\n    }\n\n    function getCurrentOfferCount(\n        uint240 _mToken\n    )\n        external\n        view\n        returns (uint256)\n    {\n        return(biddings[_mToken].nextOffer);\n    }\n\n    function getOfferAtIndex(\n        uint240 _mToken,\n        uint256 _offerIndex\n    )\n        external\n        view\n        returns (address offeror, uint256 offer)\n    {\n        require(biddings[_mToken].nextOffer > 0, \"No valid offer\");\n        require(_offerIndex < biddings[_mToken].nextOffer, \"Offer index out of range\");\n        offeror = biddings[_mToken].maxOfferor[0][_offerIndex];\n        offer = biddings[_mToken].offers[offeror];\n    }\n\n    /**\n     * @dev Block reentrancy (directly or indirectly)\n     */\n    modifier nonReentrant() {\n        require(_notEntered, \"Reentrance not allowed\");\n        _notEntered = false;\n        _;\n        _notEntered = true; // get a gas-refund post-Istanbul\n    }\n\n\n// ************************************************************\n//  Test functions only below this point, remove in production!\n\n    // function addOfferETH_Test(\n    //     uint240 _mToken,\n    //     address _sender,\n    //     uint256 _amount\n    // )\n    //     public\n    //     nonReentrant\n    // {\n    //     require (_amount > 0, \"No payment sent\");\n    //     uint256 _oldOffer = biddings[_mToken].offers[_sender];\n    //     uint256 _newOffer = _oldOffer + _amount;\n    //     if (_oldOffer == 0) {\n    //         uint256 _nextIndex = biddings[_mToken].nextOffer;\n    //         biddings[_mToken].offerIndex[_sender] = _nextIndex;\n    //         biddings[_mToken].nextOffer = _nextIndex + 1;\n    //     }\n    //     _updateOffer(_mToken, biddings[_mToken].offerIndex[_sender], _sender, _newOffer);\n    //     emit NewAuctionOffer(_mToken, _sender, _newOffer);\n    // }\n\n    // function cancelOfferETH_Test(\n    //     uint240 _mToken,\n    //     address _sender\n    // )\n    //     public\n    //     nonReentrant\n    // {\n    //     uint256 _oldOffer = biddings[_mToken].offers[_sender];\n    //     require (_oldOffer > 0, \"No active offer found\");\n    //     uint256 _thisIndex = biddings[_mToken].offerIndex[_sender];\n    //     uint256 _nextIndex = biddings[_mToken].nextOffer;\n    //     assert (_nextIndex > 0);\n    //     _nextIndex--;\n    //     if (_thisIndex != _nextIndex) {\n    //         address _swappedOfferor = biddings[_mToken].maxOfferor[0][_nextIndex];\n    //         biddings[_mToken].offerIndex[_swappedOfferor] = _thisIndex;\n    //         uint256 _newOffer = biddings[_mToken].offers[_swappedOfferor];\n    //         _updateOffer(_mToken, _thisIndex, _swappedOfferor, _newOffer);\n    //     }\n    //     _updateOffer(_mToken, _nextIndex, address(0), 0);\n    //     delete biddings[_mToken].offers[_sender];\n    //     delete biddings[_mToken].offerIndex[_sender];\n    //     biddings[_mToken].nextOffer = _nextIndex;\n    //     refunds[_sender] += _oldOffer;\n    //     emit AuctionOfferCancelled(_mToken, _sender, _oldOffer);\n    // }\n\n    // function testBidding(\n    //     uint256 _start,\n    //     uint256 _cnt\n    // )\n    //     public\n    // {\n    //     for (uint256 _i = _start; _i < (_start + _cnt); _i++) {\n    //         addOfferETH_Test(1, address(uint160(_i)), _i);\n    //     }\n    // }\n\n}\n"

    },

    "project:/contracts/compound/CarefulMath.sol": {

      "content": "pragma solidity ^0.5.16;\n\n/**\n  * @title Careful Math\n  * @author Compound\n  * @notice Derived from OpenZeppelin's SafeMath library\n  *         https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n  */\ncontract CarefulMath {\n\n    /**\n     * @dev Possible error codes that we can return\n     */\n    enum MathError {\n        NO_ERROR,\n        DIVISION_BY_ZERO,\n        INTEGER_OVERFLOW,\n        INTEGER_UNDERFLOW\n    }\n\n    /**\n    * @dev Multiplies two numbers, returns an error on overflow.\n    */\n    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        if (a == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        uint c = a * b;\n\n        if (c / a != b) {\n            return (MathError.INTEGER_OVERFLOW, 0);\n        } else {\n            return (MathError.NO_ERROR, c);\n        }\n    }\n\n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        if (b == 0) {\n            return (MathError.DIVISION_BY_ZERO, 0);\n        }\n\n        return (MathError.NO_ERROR, a / b);\n    }\n\n    /**\n    * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        if (b <= a) {\n            return (MathError.NO_ERROR, a - b);\n        } else {\n            return (MathError.INTEGER_UNDERFLOW, 0);\n        }\n    }\n\n    /**\n    * @dev Adds two numbers, returns an error on overflow.\n    */\n    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n        uint c = a + b;\n\n        if (c >= a) {\n            return (MathError.NO_ERROR, c);\n        } else {\n            return (MathError.INTEGER_OVERFLOW, 0);\n        }\n    }\n\n    /**\n    * @dev add a and b and then subtract c\n    */\n    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n        (MathError err0, uint sum) = addUInt(a, b);\n\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, 0);\n        }\n\n        return subUInt(sum, c);\n    }\n}"

    },

    "project:/contracts/compound/EIP20NonStandardInterface.sol": {

      "content": "pragma solidity ^0.5.16;\n\n/**\n * @title EIP20NonStandardInterface\n * @dev Version of ERC20 with no return values for `transfer` and `transferFrom`\n *  See https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n */\ninterface EIP20NonStandardInterface {\n\n    /**\n     * @notice Get the total number of tokens in circulation\n     * @return The supply of tokens\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @notice Gets the balance of the specified address\n     * @param owner The address from which the balance will be retrieved\n     * @return The balance\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    ///\n    /// !!!!!!!!!!!!!!\n    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n    /// !!!!!!!!!!!!!!\n    ///\n\n    /**\n      * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n      * @param dst The address of the destination account\n      * @param amount The number of tokens to transfer\n      */\n    function transfer(address dst, uint256 amount) external;\n\n    ///\n    /// !!!!!!!!!!!!!!\n    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n    /// !!!!!!!!!!!!!!\n    ///\n\n    /**\n      * @notice Transfer `amount` tokens from `src` to `dst`\n      * @param src The address of the source account\n      * @param dst The address of the destination account\n      * @param amount The number of tokens to transfer\n      */\n    function transferFrom(address src, address dst, uint256 amount) external;\n\n    /**\n      * @notice Approve `spender` to transfer up to `amount` from `src`\n      * @dev This will overwrite the approval amount for `spender`\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n      * @param spender The address of the account which may transfer tokens\n      * @param amount The number of tokens that are approved\n      * @return Whether or not the approval succeeded\n      */\n    function approve(address spender, uint256 amount) external returns (bool success);\n\n    /**\n      * @notice Get the current allowance from `owner` for `spender`\n      * @param owner The address of the account which owns the tokens to be spent\n      * @param spender The address of the account which may transfer tokens\n      * @return The number of tokens allowed to be spent\n      */\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n}\n"

    },

    "project:/contracts/compound/Exponential.sol": {

      "content": "pragma solidity ^0.5.16;\n\nimport \"./CarefulMath.sol\";\nimport \"./ExponentialNoError.sol\";\n\n/**\n * @title Exponential module for storing fixed-precision decimals\n * @author Compound\n * @dev Legacy contract for compatibility reasons with existing contracts that still use MathError\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\ncontract Exponential is CarefulMath, ExponentialNoError {\n    /**\n     * @dev Creates an exponential from numerator and denominator values.\n     *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\n     *            or if `denom` is zero.\n     */\n    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n        (MathError err0, uint scaledNumerator) = mulUInt(num, expScale);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        (MathError err1, uint rational) = divUInt(scaledNumerator, denom);\n        if (err1 != MathError.NO_ERROR) {\n            return (err1, Exp({mantissa: 0}));\n        }\n\n        return (MathError.NO_ERROR, Exp({mantissa: rational}));\n    }\n\n    /**\n     * @dev Adds two exponentials, returning a new exponential.\n     */\n    function addExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n        (MathError error, uint result) = addUInt(a.mantissa, b.mantissa);\n\n        return (error, Exp({mantissa: result}));\n    }\n\n    /**\n     * @dev Subtracts two exponentials, returning a new exponential.\n     */\n    function subExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n        (MathError error, uint result) = subUInt(a.mantissa, b.mantissa);\n\n        return (error, Exp({mantissa: result}));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, returning a new Exp.\n     */\n    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n        (MathError err0, uint scaledMantissa) = mulUInt(a.mantissa, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        return (MathError.NO_ERROR, Exp({mantissa: scaledMantissa}));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n     */\n    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (MathError.NO_ERROR, truncate(product));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n     */\n    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return addUInt(truncate(product), addend);\n    }\n\n    /**\n     * @dev Divide an Exp by a scalar, returning a new Exp.\n     */\n    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n        (MathError err0, uint descaledMantissa) = divUInt(a.mantissa, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        return (MathError.NO_ERROR, Exp({mantissa: descaledMantissa}));\n    }\n\n    /**\n     * @dev Divide a scalar by an Exp, returning a new Exp.\n     */\n    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n        /*\n          We are doing this as:\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\n\n          How it works:\n          Exp = a / b;\n          Scalar = s;\n          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\n        */\n        (MathError err0, uint numerator) = mulUInt(expScale, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n        return getExp(numerator, divisor.mantissa);\n    }\n\n    /**\n     * @dev Divide a scalar by an Exp, then truncate to return an unsigned integer.\n     */\n    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (MathError.NO_ERROR, truncate(fraction));\n    }\n\n    /**\n     * @dev Multiplies two exponentials, returning a new exponential.\n     */\n    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n\n        (MathError err0, uint doubleScaledProduct) = mulUInt(a.mantissa, b.mantissa);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        // We add half the scale before dividing so that we get rounding instead of truncation.\n        //  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717\n        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\n        (MathError err1, uint doubleScaledProductWithHalfScale) = addUInt(halfExpScale, doubleScaledProduct);\n        if (err1 != MathError.NO_ERROR) {\n            return (err1, Exp({mantissa: 0}));\n        }\n\n        (MathError err2, uint product) = divUInt(doubleScaledProductWithHalfScale, expScale);\n        // The only error `div` can return is MathError.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\n        assert(err2 == MathError.NO_ERROR);\n\n        return (MathError.NO_ERROR, Exp({mantissa: product}));\n    }\n\n    /**\n     * @dev Multiplies two exponentials given their mantissas, returning a new exponential.\n     */\n    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n        return mulExp(Exp({mantissa: a}), Exp({mantissa: b}));\n    }\n\n    /**\n     * @dev Multiplies three exponentials, returning a new exponential.\n     */\n    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n        (MathError err, Exp memory ab) = mulExp(a, b);\n        if (err != MathError.NO_ERROR) {\n            return (err, ab);\n        }\n        return mulExp(ab, c);\n    }\n\n    /**\n     * @dev Divides two exponentials, returning a new exponential.\n     *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\n     *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\n     */\n    function divExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n        return getExp(a.mantissa, b.mantissa);\n    }\n}\n"

    },

    "project:/contracts/compound/ExponentialNoError.sol": {

      "content": "pragma solidity ^0.5.16;\n\n/**\n * @title Exponential module for storing fixed-precision decimals\n * @author Compound\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\ncontract ExponentialNoError {\n    uint constant expScale = 1e18;\n    uint constant doubleScale = 1e36;\n    uint constant halfExpScale = expScale/2;\n    uint constant mantissaOne = expScale;\n\n    struct Exp {\n        uint mantissa;\n    }\n\n    struct Double {\n        uint mantissa;\n    }\n\n    /**\n     * @dev Truncates the given exp to a whole number value.\n     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\n     */\n    function truncate(Exp memory exp) pure internal returns (uint) {\n        // Note: We are not using careful math here as we're performing a division that cannot fail\n        return exp.mantissa / expScale;\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n     */\n    function mul_ScalarTruncate(Exp memory a, uint scalar) pure internal returns (uint) {\n        Exp memory product = mul_(a, scalar);\n        return truncate(product);\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n     */\n    function mul_ScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (uint) {\n        Exp memory product = mul_(a, scalar);\n        return add_(truncate(product), addend);\n    }\n\n    /**\n     * @dev Checks if first Exp is less than second Exp.\n     */\n    function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n        return left.mantissa < right.mantissa;\n    }\n\n    /**\n     * @dev Checks if left Exp <= right Exp.\n     */\n    function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n        return left.mantissa <= right.mantissa;\n    }\n\n    /**\n     * @dev Checks if left Exp > right Exp.\n     */\n    function greaterThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n        return left.mantissa > right.mantissa;\n    }\n\n    /**\n     * @dev returns true if Exp is exactly zero\n     */\n    function isZeroExp(Exp memory value) pure internal returns (bool) {\n        return value.mantissa == 0;\n    }\n\n    function safe224(uint n, string memory errorMessage) pure internal returns (uint224) {\n        require(n < 2**224, errorMessage);\n        return uint224(n);\n    }\n\n    function safe32(uint n, string memory errorMessage) pure internal returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    function add_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\n        return Exp({mantissa: add_(a.mantissa, b.mantissa)});\n    }\n\n    function add_(Double memory a, Double memory b) pure internal returns (Double memory) {\n        return Double({mantissa: add_(a.mantissa, b.mantissa)});\n    }\n\n    function add_(uint a, uint b) pure internal returns (uint) {\n        return add_(a, b, \"addition overflow\");\n    }\n\n    function add_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\n        uint c = a + b;\n        require(c >= a, errorMessage);\n        return c;\n    }\n\n    function sub_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\n        return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\n    }\n\n    function sub_(Double memory a, Double memory b) pure internal returns (Double memory) {\n        return Double({mantissa: sub_(a.mantissa, b.mantissa)});\n    }\n\n    function sub_(uint a, uint b) pure internal returns (uint) {\n        return sub_(a, b, \"subtraction underflow\");\n    }\n\n    function sub_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    function mul_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\n        return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});\n    }\n\n    function mul_(Exp memory a, uint b) pure internal returns (Exp memory) {\n        return Exp({mantissa: mul_(a.mantissa, b)});\n    }\n\n    function mul_(uint a, Exp memory b) pure internal returns (uint) {\n        return mul_(a, b.mantissa) / expScale;\n    }\n\n    function mul_(Double memory a, Double memory b) pure internal returns (Double memory) {\n        return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});\n    }\n\n    function mul_(Double memory a, uint b) pure internal returns (Double memory) {\n        return Double({mantissa: mul_(a.mantissa, b)});\n    }\n\n    function mul_(uint a, Double memory b) pure internal returns (uint) {\n        return mul_(a, b.mantissa) / doubleScale;\n    }\n\n    function mul_(uint a, uint b) pure internal returns (uint) {\n        return mul_(a, b, \"multiplication overflow\");\n    }\n\n    function mul_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\n        if (a == 0 || b == 0) {\n            return 0;\n        }\n        uint c = a * b;\n        require(c / a == b, errorMessage);\n        return c;\n    }\n\n    function div_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\n        return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});\n    }\n\n    function div_(Exp memory a, uint b) pure internal returns (Exp memory) {\n        return Exp({mantissa: div_(a.mantissa, b)});\n    }\n\n    function div_(uint a, Exp memory b) pure internal returns (uint) {\n        return div_(mul_(a, expScale), b.mantissa);\n    }\n\n    function div_(Double memory a, Double memory b) pure internal returns (Double memory) {\n        return Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});\n    }\n\n    function div_(Double memory a, uint b) pure internal returns (Double memory) {\n        return Double({mantissa: div_(a.mantissa, b)});\n    }\n\n    function div_(uint a, Double memory b) pure internal returns (uint) {\n        return div_(mul_(a, doubleScale), b.mantissa);\n    }\n\n    function div_(uint a, uint b) pure internal returns (uint) {\n        return div_(a, b, \"divide by zero\");\n    }\n\n    function div_(uint a, uint b, string memory errorMessage) pure internal returns (uint) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    function fraction(uint a, uint b) pure internal returns (Double memory) {\n        return Double({mantissa: div_(mul_(a, doubleScale), b)});\n    }\n}\n"

    },

    "project:/contracts/compound/InterestRateModel.sol": {

      "content": "pragma solidity ^0.5.16;\n\n/**\n  * @title Compound's InterestRateModel Interface\n  * @author Compound\n  */\ncontract InterestRateModel {\n    /// @notice Indicator that this is an InterestRateModel contract (for inspection)\n    bool public constant isInterestRateModel = true;\n\n    /**\n      * @notice Calculates the current borrow interest rate per block\n      * @param cash The total amount of cash the market has\n      * @param borrows The total amount of borrows the market has outstanding\n      * @param reserves The total amount of reserves the market has\n      * @return The borrow rate per block (as a percentage, and scaled by 1e18)\n      */\n    function getBorrowRate(uint cash, uint borrows, uint reserves) external view returns (uint);\n\n    /**\n      * @notice Calculates the current supply interest rate per block\n      * @param cash The total amount of cash the market has\n      * @param borrows The total amount of borrows the market has outstanding\n      * @param reserves The total amount of reserves the market has\n      * @param reserveFactorMantissa The current reserve factor the market has\n      * @return The supply rate per block (as a percentage, and scaled by 1e18)\n      */\n    function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) external view returns (uint);\n\n}\n"

    },

    "project:/contracts/open-zeppelin/GSN/Context.sol": {

      "content": "pragma solidity ^0.5.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"

    },

    "project:/contracts/open-zeppelin/drafts/Counters.sol": {

      "content": "pragma solidity ^0.5.0;\n\nimport \"../math/ZSafeMath.sol\";\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\n * directly accessed.\n */\nlibrary Counters {\n    using ZSafeMath for uint256;\n\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        // The {SafeMath} overflow check can be skipped here, see the comment at the top\n        counter._value += 1;\n    }\n\n    function decrement(Counter storage counter) internal {\n        counter._value = counter._value.sub(1);\n    }\n}\n"

    },

    "project:/contracts/open-zeppelin/introspection/ERC165.sol": {

      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\ncontract ERC165 is IERC165 {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    constructor () internal {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n"

    },

    "project:/contracts/open-zeppelin/introspection/IERC165.sol": {

      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"

    },

    "project:/contracts/open-zeppelin/math/ZSafeMath.sol": {

      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary ZSafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"

    },

    "project:/contracts/open-zeppelin/token/ERC20/ERC20.sol": {

      "content": "pragma solidity ^0.5.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/ZSafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20Mintable}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using ZSafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    constructor(string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See {_burn} and {_approve}.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\n    }\n}\n"

    },

    "project:/contracts/open-zeppelin/token/ERC20/IERC20.sol": {

      "content": "pragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"

    },

    "project:/contracts/open-zeppelin/token/ERC721/ERC721.sol": {

      "content": "pragma solidity ^0.5.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"../../math/ZSafeMath.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../drafts/Counters.sol\";\nimport \"../../introspection/ERC165.sol\";\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721 is Context, ERC165, IERC721 {\n    using ZSafeMath for uint256;\n    using Address for address;\n    using Counters for Counters.Counter;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n    // Mapping from token ID to owner\n    mapping (uint256 => address) private _tokenOwner;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to number of owned token\n    mapping (address => Counters.Counter) private _ownedTokensCount;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    /*\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n     *\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n     *        0xa22cb465 ^ 0xe985e9c ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n    constructor(string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721);\n    }\n\n    /**\n     * @dev Gets the balance of the specified address.\n     * @param owner address to query the balance of\n     * @return uint256 representing the amount owned by the passed address\n     */\n    function balanceOf(address owner) public view returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n\n        return _ownedTokensCount[owner].current();\n    }\n\n    /**\n     * @dev Gets the owner of the specified token ID.\n     * @param tokenId uint256 ID of the token to query the owner of\n     * @return address currently marked as the owner of the given token ID\n     */\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        address owner = _tokenOwner[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n\n        return owner;\n    }\n\n    /**\n     * @dev Approves another address to transfer the given token ID\n     * The zero address indicates there is no approved address.\n     * There can only be one approved address per token at a given time.\n     * Can only be called by the token owner or an approved operator.\n     * @param to address to be approved for the given token ID\n     * @param tokenId uint256 ID of the token to be approved\n     */\n    function approve(address to, uint256 tokenId) public {\n        address owner = ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    /**\n     * @dev Gets the approved address for a token ID, or zero if no address set\n     * Reverts if the token ID does not exist.\n     * @param tokenId uint256 ID of the token to query the approval of\n     * @return address currently approved for the given token ID\n     */\n    function getApproved(uint256 tokenId) public view returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev Sets or unsets the approval of a given operator\n     * An operator is allowed to transfer all tokens of the sender on their behalf.\n     * @param to operator address to set the approval\n     * @param approved representing the status of the approval to be set\n     */\n    function setApprovalForAll(address to, bool approved) public {\n        require(to != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][to] = approved;\n        emit ApprovalForAll(_msgSender(), to, approved);\n    }\n\n    /**\n     * @dev Tells whether an operator is approved by a given owner.\n     * @param owner owner address which you want to query the approval of\n     * @param operator operator address which you want to query the approval of\n     * @return bool whether the given operator is approved by the given owner\n     */\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev Transfers the ownership of a given token ID to another address.\n     * Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     * Requires the msg.sender to be the owner, approved, or operator.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transferFrom(from, to, tokenId);\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the msg.sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the _msgSender() to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes data to send along with a safe transfer check\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransferFrom(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the msg.sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes data to send along with a safe transfer check\n     */\n    function _safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) internal {\n        _transferFrom(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether the specified token exists.\n     * @param tokenId uint256 ID of the token to query the existence of\n     * @return bool whether the token exists\n     */\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        address owner = _tokenOwner[tokenId];\n        return owner != address(0);\n    }\n\n    /**\n     * @dev Returns whether the given spender can transfer a given token ID.\n     * @param spender address of the spender to query\n     * @param tokenId uint256 ID of the token to be transferred\n     * @return bool whether the msg.sender is approved for the given token ID,\n     * is an operator of the owner, or is the owner of the token\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Internal function to safely mint a new token.\n     * Reverts if the given token ID already exists.\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * @param to The address that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     */\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Internal function to safely mint a new token.\n     * Reverts if the given token ID already exists.\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n     * the transfer is reverted.\n     * @param to The address that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     * @param _data bytes data to send along with a safe transfer check\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Internal function to mint a new token.\n     * Reverts if the given token ID already exists.\n     * @param to The address that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _tokenOwner[tokenId] = to;\n        _ownedTokensCount[to].increment();\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token.\n     * Reverts if the token does not exist.\n     * Deprecated, use {_burn} instead.\n     * @param owner owner of the token to burn\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(address owner, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == owner, \"ERC721: burn of token that is not own\");\n\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[owner].decrement();\n        _tokenOwner[tokenId] = address(0);\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token.\n     * Reverts if the token does not exist.\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(uint256 tokenId) internal {\n        _burn(ownerOf(tokenId), tokenId);\n    }\n\n    /**\n     * @dev Internal function to transfer ownership of a given token ID to another address.\n     * As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[from].decrement();\n        _ownedTokensCount[to].increment();\n\n        _tokenOwner[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * This is an internal detail of the `ERC721` contract and its use is deprecated.\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        internal returns (bool)\n    {\n        if (!to.isContract()) {\n            return true;\n        }\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = to.call(abi.encodeWithSelector(\n            IERC721Receiver(to).onERC721Received.selector,\n            _msgSender(),\n            from,\n            tokenId,\n            _data\n        ));\n        if (!success) {\n            if (returndata.length > 0) {\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n            }\n        } else {\n            bytes4 retval = abi.decode(returndata, (bytes4));\n            return (retval == _ERC721_RECEIVED);\n        }\n    }\n\n    /**\n     * @dev Private function to clear current approval of a given token ID.\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function _clearApproval(uint256 tokenId) private {\n        if (_tokenApprovals[tokenId] != address(0)) {\n            _tokenApprovals[tokenId] = address(0);\n        }\n    }\n}\n"

    },

    "project:/contracts/open-zeppelin/token/ERC721/IERC721.sol": {

      "content": "pragma solidity ^0.5.0;\n\nimport \"../../introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ncontract IERC721 is IERC165 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of NFTs in `owner`'s account.\n     */\n    function balanceOf(address owner) public view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the NFT specified by `tokenId`.\n     */\n    function ownerOf(uint256 tokenId) public view returns (address owner);\n\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     *\n     *\n     * Requirements:\n     * - `from`, `to` cannot be zero.\n     * - `tokenId` must be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this\n     * NFT by either {approve} or {setApprovalForAll}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n    /**\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n     * another (`to`).\n     *\n     * Requirements:\n     * - If the caller is not `from`, it must be approved to move this NFT by\n     * either {approve} or {setApprovalForAll}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public;\n    function approve(address to, uint256 tokenId) public;\n    function getApproved(uint256 tokenId) public view returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) public;\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\n\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n}\n"

    },

    "project:/contracts/open-zeppelin/token/ERC721/IERC721Metadata.sol": {

      "content": "pragma solidity ^0.5.0;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ncontract IERC721Metadata is IERC721 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"

    },

    "project:/contracts/open-zeppelin/token/ERC721/IERC721Receiver.sol": {

      "content": "pragma solidity ^0.5.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ncontract IERC721Receiver {\n    /**\n     * @notice Handle the receipt of an NFT\n     * @dev The ERC721 smart contract calls this function on the recipient\n     * after a {IERC721-safeTransferFrom}. This function MUST return the function selector,\n     * otherwise the caller will revert the transaction. The selector to be\n     * returned can be obtained as `this.onERC721Received.selector`. This\n     * function MAY throw to revert and reject the transfer.\n     * Note: the ERC721 contract address is always the message sender.\n     * @param operator The address which called `safeTransferFrom` function\n     * @param from The address which previously owned the token\n     * @param tokenId The NFT identifier which is being transferred\n     * @param data Additional data with no specified format\n     * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\n    public returns (bytes4);\n}\n"

    },

    "project:/contracts/open-zeppelin/utils/Address.sol": {

      "content": "pragma solidity ^0.5.5;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following \n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Converts an `address` into `address payable`. Note that this is\n     * simply a type cast: the actual underlying value is not changed.\n     *\n     * _Available since v2.4.0._\n     */\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\n     * _Available since v2.4.0._\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n"

    }

  },

  "settings": {

    "remappings": [],

    "optimizer": {

      "enabled": true,

      "runs": 500

    },

    "evmVersion": "istanbul",

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "abi"

        ]

      }

    }

  }

}}