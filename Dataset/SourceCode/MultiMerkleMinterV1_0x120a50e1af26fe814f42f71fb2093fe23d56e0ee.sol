{{

  "language": "Solidity",

  "sources": {

    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"

    },

    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"

    },

    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     *\n     * _Available since v4.7._\n     */\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     *\n     * _Available since v4.7._\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/math/Math.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/Strings.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"

    },

    "contracts/tender/interfaces/IAdminACLV0.sol": {

      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\npragma solidity ^0.8.0;\n\ninterface IAdminACLV0 {\n    /**\n     * @notice Token ID `_tokenId` minted to `_to`.\n     * @param previousSuperAdmin The previous superAdmin address.\n     * @param newSuperAdmin The new superAdmin address.\n     * @param genArt721CoreAddressesToUpdate Array of genArt721Core\n     * addresses to update to the new superAdmin, for indexing purposes only.\n     */\n    event SuperAdminTransferred(\n        address indexed previousSuperAdmin,\n        address indexed newSuperAdmin,\n        address[] genArt721CoreAddressesToUpdate\n    );\n\n    /// Type of the Admin ACL contract, e.g. \"AdminACLV0\"\n    function AdminACLType() external view returns (string memory);\n\n    /// super admin address\n    function superAdmin() external view returns (address);\n\n    /**\n     * @notice Calls transferOwnership on other contract from this contract.\n     * This is useful for updating to a new AdminACL contract.\n     * @dev this function should be gated to only superAdmin-like addresses.\n     */\n    function transferOwnershipOn(\n        address _contract,\n        address _newAdminACL\n    ) external;\n\n    /**\n     * @notice Calls renounceOwnership on other contract from this contract.\n     * @dev this function should be gated to only superAdmin-like addresses.\n     */\n    function renounceOwnershipOn(address _contract) external;\n\n    /**\n     * @notice Checks if sender `_sender` is allowed to call function with selector\n     * `_selector` on contract `_contract`.\n     */\n    function allowed(\n        address _sender,\n        address _contract,\n        bytes4 _selector\n    ) external returns (bool);\n}\n"

    },

    "contracts/tender/interfaces/IFilteredMinterMerkleV0.sol": {

      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\nimport \"./IFilteredMinterV1.sol\";\n\npragma solidity ^0.8.0;\n\n/**\n * @title This interface extends the IFilteredMinterV1 interface in order to\n * add support for including Merkle proofs when purchasing.\n * @author Art Blocks Inc.\n */\ninterface IFilteredMinterMerkleV0 is IFilteredMinterV1 {\n    /**\n     * @notice Notifies of the contract's default maximum mints allowed per\n     * user for a given project, on this minter. This value can be overridden\n     * by the artist of any project at any time.\n     */\n    event DefaultMaxInvocationsPerAddress(\n        uint256 defaultMaxInvocationsPerAddress\n    );\n\n    // Triggers a purchase of a token from the desired project, to the\n    // TX-sending address. Requires Merkle proof.\n    function purchase(\n        uint256 _projectId,\n        bytes32[] memory _proof\n    ) external payable returns (uint256 tokenId);\n\n    // Triggers a purchase of a token from the desired project, to the specified\n    // receiving address. Requires Merkle proof.\n    function purchaseTo(\n        address _to,\n        uint256 _projectId,\n        bytes32[] memory _proof\n    ) external payable returns (uint256 tokenId);\n}\n"

    },

    "contracts/tender/interfaces/IFilteredMinterMerkleV1.sol": {

      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\nimport \"./IFilteredMinterMerkleV0.sol\";\n\npragma solidity ^0.8.0;\n\n/**\n * @title This interface extends the IFilteredMinterMerkleV0 interface in order\n * to add support for configuring and indexing the delegation registry address.\n * @author Art Blocks Inc.\n */\ninterface IFilteredMinterMerkleV1 is IFilteredMinterMerkleV0 {\n    /**\n     * @notice Notifies of the contract's configured delegation registry\n     * address.\n     */\n    event DelegationRegistryUpdated(address delegationRegistryAddress);\n}\n"

    },

    "contracts/tender/interfaces/IFilteredMinterMerkleV2.sol": {

      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\nimport \"./IFilteredMinterMerkleV1.sol\";\nimport \"./IFilteredMinterV2.sol\";\n\npragma solidity ^0.8.0;\n\n/**\n * @title This interface extends the IFilteredMinterMerkleV0 interface in order to\n * add support for manually setting project max invocations.\n * @author Art Blocks Inc.\n */\ninterface IFilteredMinterMerkleV2 is IFilteredMinterMerkleV1, IFilteredMinterV2 {}\n"

    },

    "contracts/tender/interfaces/IFilteredMinterV0.sol": {

      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\npragma solidity ^0.8.0;\n\ninterface IFilteredMinterV0 {\n    /**\n     * @notice Price per token in wei updated for project `_projectId` to\n     * `_pricePerTokenInWei`.\n     */\n    event PricePerTokenInWeiUpdated(\n        uint256 indexed _projectId,\n        uint256 indexed _pricePerTokenInWei\n    );\n\n    /**\n     * @notice Currency updated for project `_projectId` to symbol\n     * `_currencySymbol` and address `_currencyAddress`.\n     */\n    event ProjectCurrencyInfoUpdated(\n        uint256 indexed _projectId,\n        address indexed _currencyAddress,\n        string _currencySymbol\n    );\n\n    /// togglePurchaseToDisabled updated\n    event PurchaseToDisabledUpdated(\n        uint256 indexed _projectId,\n        bool _purchaseToDisabled\n    );\n\n    // getter function of public variable\n    function minterType() external view returns (string memory);\n\n    function genArt721CoreAddress() external returns (address);\n\n    function minterFilterAddress() external returns (address);\n\n    // Triggers a purchase of a token from the desired project, to the\n    // TX-sending address.\n    function purchase(\n        uint256 _projectId\n    ) external payable returns (uint256 tokenId);\n\n    // Triggers a purchase of a token from the desired project, to the specified\n    // receiving address.\n    function purchaseTo(\n        address _to,\n        uint256 _projectId\n    ) external payable returns (uint256 tokenId);\n\n    // Toggles the ability for `purchaseTo` to be called directly with a\n    // specified receiving address that differs from the TX-sending address.\n    function togglePurchaseToDisabled(uint256 _projectId) external;\n\n    // Called to make the minter contract aware of the max invocations for a\n    // given project.\n    function setProjectMaxInvocations(uint256 _projectId) external;\n\n    // Gets if token price is configured, token price in wei, currency symbol,\n    // and currency address, assuming this is project's minter.\n    // Supersedes any defined core price.\n    function getPriceInfo(\n        uint256 _projectId\n    )\n        external\n        view\n        returns (\n            bool isConfigured,\n            uint256 tokenPriceInWei,\n            string memory currencySymbol,\n            address currencyAddress\n        );\n}\n"

    },

    "contracts/tender/interfaces/IFilteredMinterV1.sol": {

      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\nimport \"./IFilteredMinterV0.sol\";\n\npragma solidity ^0.8.0;\n\n/**\n * @title This interface extends the IFilteredMinterV0 interface in order to\n * add support for generic project minter configuration updates.\n * @dev keys represent strings of finite length encoded in bytes32 to minimize\n * gas.\n * @author Art Blocks Inc.\n */\ninterface IFilteredMinterV1 is IFilteredMinterV0 {\n    /// ANY\n    /**\n     * @notice Generic project minter configuration event. Removes key `_key`\n     * for project `_projectId`.\n     */\n    event ConfigKeyRemoved(uint256 indexed _projectId, bytes32 _key);\n\n    /// BOOL\n    /**\n     * @notice Generic project minter configuration event. Sets value of key\n     * `_key` to `_value` for project `_projectId`.\n     */\n    event ConfigValueSet(uint256 indexed _projectId, bytes32 _key, bool _value);\n\n    /// UINT256\n    /**\n     * @notice Generic project minter configuration event. Sets value of key\n     * `_key` to `_value` for project `_projectId`.\n     */\n    event ConfigValueSet(\n        uint256 indexed _projectId,\n        bytes32 _key,\n        uint256 _value\n    );\n\n    /**\n     * @notice Generic project minter configuration event. Adds value `_value`\n     * to the set of uint256 at key `_key` for project `_projectId`.\n     */\n    event ConfigValueAddedToSet(\n        uint256 indexed _projectId,\n        bytes32 _key,\n        uint256 _value\n    );\n\n    /**\n     * @notice Generic project minter configuration event. Removes value\n     * `_value` to the set of uint256 at key `_key` for project `_projectId`.\n     */\n    event ConfigValueRemovedFromSet(\n        uint256 indexed _projectId,\n        bytes32 _key,\n        uint256 _value\n    );\n\n    /// ADDRESS\n    /**\n     * @notice Generic project minter configuration event. Sets value of key\n     * `_key` to `_value` for project `_projectId`.\n     */\n    event ConfigValueSet(\n        uint256 indexed _projectId,\n        bytes32 _key,\n        address _value\n    );\n\n    /**\n     * @notice Generic project minter configuration event. Adds value `_value`\n     * to the set of addresses at key `_key` for project `_projectId`.\n     */\n    event ConfigValueAddedToSet(\n        uint256 indexed _projectId,\n        bytes32 _key,\n        address _value\n    );\n\n    /**\n     * @notice Generic project minter configuration event. Removes value\n     * `_value` to the set of addresses at key `_key` for project `_projectId`.\n     */\n    event ConfigValueRemovedFromSet(\n        uint256 indexed _projectId,\n        bytes32 _key,\n        address _value\n    );\n\n    /// BYTES32\n    /**\n     * @notice Generic project minter configuration event. Sets value of key\n     * `_key` to `_value` for project `_projectId`.\n     */\n    event ConfigValueSet(\n        uint256 indexed _projectId,\n        bytes32 _key,\n        bytes32 _value\n    );\n\n    /**\n     * @notice Generic project minter configuration event. Adds value `_value`\n     * to the set of bytes32 at key `_key` for project `_projectId`.\n     */\n    event ConfigValueAddedToSet(\n        uint256 indexed _projectId,\n        bytes32 _key,\n        bytes32 _value\n    );\n\n    /**\n     * @notice Generic project minter configuration event. Removes value\n     * `_value` to the set of bytes32 at key `_key` for project `_projectId`.\n     */\n    event ConfigValueRemovedFromSet(\n        uint256 indexed _projectId,\n        bytes32 _key,\n        bytes32 _value\n    );\n\n    /**\n     * @dev Strings not supported. Recommend conversion of (short) strings to\n     * bytes32 to remain gas-efficient.\n     */\n}\n"

    },

    "contracts/tender/interfaces/IFilteredMinterV2.sol": {

      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\nimport \"./IFilteredMinterV1.sol\";\n\npragma solidity ^0.8.0;\n\n/**\n * @title This interface extends the IFilteredMinterV1 interface in order to\n * add support for manually setting project max invocations.\n * @author Art Blocks Inc.\n */\ninterface IFilteredMinterV2 is IFilteredMinterV1 {\n    /**\n     * @notice Local max invocations for project `_projectId`, tied to core contract `_coreContractAddress`,\n     * updated to `_maxInvocations`.\n     */\n    event ProjectMaxInvocationsLimitUpdated(\n        uint256 indexed _projectId,\n        uint256 _maxInvocations\n    );\n\n    // Sets the local max invocations for a given project, checking that the provided max invocations is\n    // less than or equal to the global max invocations for the project set on the core contract.\n    // This does not impact the max invocations value defined on the core contract.\n    function manuallyLimitProjectMaxInvocations(\n        uint256 _projectId,\n        uint256 _maxInvocations\n    ) external;\n}\n"

    },

    "contracts/tender/interfaces/IGenArt721CoreContractV3_Base.sol": {

      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\npragma solidity ^0.8.0;\n\nimport \"./IAdminACLV0.sol\";\n/// use the Royalty Registry's IManifold interface for token royalties\nimport \"./IManifold.sol\";\n\n/**\n * @title This interface is intended to house interface items that are common\n * across all GenArt721CoreContractV3 flagship and derivative implementations.\n * This interface extends the IManifold royalty interface in order to\n * add support the Royalty Registry by default.\n * @author Art Blocks Inc.\n */\ninterface IGenArt721CoreContractV3_Base is IManifold {\n    /**\n     * @notice Token ID `_tokenId` minted to `_to`.\n     */\n    event Mint(address indexed _to, uint256 indexed _tokenId);\n\n    /**\n     * @notice currentMinter updated to `_currentMinter`.\n     * @dev Implemented starting with V3 core\n     */\n    event MinterUpdated(address indexed _currentMinter);\n\n    /**\n     * @notice Platform updated on bytes32-encoded field `_field`.\n     */\n    event PlatformUpdated(bytes32 indexed _field);\n\n    /**\n     * @notice Project ID `_projectId` updated on bytes32-encoded field\n     * `_update`.\n     */\n    event ProjectUpdated(uint256 indexed _projectId, bytes32 indexed _update);\n\n    event ProposedArtistAddressesAndSplits(\n        uint256 indexed _projectId,\n        address _artistAddress,\n        address _additionalPayeePrimarySales,\n        uint256 _additionalPayeePrimarySalesPercentage,\n        address _additionalPayeeSecondarySales,\n        uint256 _additionalPayeeSecondarySalesPercentage\n    );\n\n    event AcceptedArtistAddressesAndSplits(uint256 indexed _projectId);\n\n    // version and type of the core contract\n    // coreVersion is a string of the form \"0.x.y\"\n    function coreVersion() external view returns (string memory);\n\n    // coreType is a string of the form \"GenArt721CoreV3\"\n    function coreType() external view returns (string memory);\n\n    // owner (pre-V3 was named admin) of contract\n    // this is expected to be an Admin ACL contract for V3\n    function owner() external view returns (address);\n\n    // Admin ACL contract for V3, will be at the address owner()\n    function adminACLContract() external returns (IAdminACLV0);\n\n    // backwards-compatible (pre-V3) admin - equal to owner()\n    function admin() external view returns (address);\n\n    /**\n     * Function determining if _sender is allowed to call function with\n     * selector _selector on contract `_contract`. Intended to be used with\n     * peripheral contracts such as minters, as well as internally by the\n     * core contract itself.\n     */\n    function adminACLAllowed(\n        address _sender,\n        address _contract,\n        bytes4 _selector\n    ) external returns (bool);\n\n    // getter function of public variable\n    function nextProjectId() external view returns (uint256);\n\n    // getter function of public mapping\n    function tokenIdToProjectId(\n        uint256 tokenId\n    ) external view returns (uint256 projectId);\n\n    // @dev this is not available in V0\n    function isMintWhitelisted(address minter) external view returns (bool);\n\n    function projectIdToArtistAddress(\n        uint256 _projectId\n    ) external view returns (address payable);\n\n    function projectIdToAdditionalPayeePrimarySales(\n        uint256 _projectId\n    ) external view returns (address payable);\n\n    function projectIdToAdditionalPayeePrimarySalesPercentage(\n        uint256 _projectId\n    ) external view returns (uint256);\n\n    // @dev new function in V3\n    function projectStateData(\n        uint256 _projectId\n    )\n        external\n        view\n        returns (\n            uint256 invocations,\n            uint256 maxInvocations,\n            bool active,\n            bool paused,\n            uint256 completedTimestamp,\n            bool locked\n        );\n\n    // function to set a token's hash (must be guarded)\n    function setTokenHash_8PT(uint256 _tokenId, bytes32 _hash) external;\n\n    // @dev gas-optimized signature in V3 for `mint`\n    function mint_Ecf(\n        address _to,\n        uint256 _projectId,\n        address _by\n    ) external returns (uint256 tokenId);\n}\n"

    },

    "contracts/tender/interfaces/IGenArt721CoreContractV3_Engine.sol": {

      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\npragma solidity ^0.8.0;\n\nimport \"./IAdminACLV0.sol\";\nimport \"./IGenArt721CoreContractV3_Base.sol\";\n\ninterface IGenArt721CoreContractV3_Engine is IGenArt721CoreContractV3_Base {\n    // @dev new function in V3\n    function getPrimaryRevenueSplits(\n        uint256 _projectId,\n        uint256 _price\n    )\n        external\n        view\n        returns (\n            uint256 renderProviderRevenue_,\n            address payable renderProviderAddress_,\n            uint256 platformProviderRevenue_,\n            address payable platformProviderAddress_,\n            uint256 artistRevenue_,\n            address payable artistAddress_,\n            uint256 additionalPayeePrimaryRevenue_,\n            address payable additionalPayeePrimaryAddress_\n        );\n\n    // @dev The render provider primary sales payment address\n    function renderProviderPrimarySalesAddress()\n        external\n        view\n        returns (address payable);\n\n    // @dev The platform provider primary sales payment address\n    function platformProviderPrimarySalesAddress()\n        external\n        view\n        returns (address payable);\n\n    // @dev Percentage of primary sales allocated to the render provider\n    function renderProviderPrimarySalesPercentage()\n        external\n        view\n        returns (uint256);\n\n    // @dev Percentage of primary sales allocated to the platform provider\n    function platformProviderPrimarySalesPercentage()\n        external\n        view\n        returns (uint256);\n\n    // @dev The render provider secondary sales royalties payment address\n    function renderProviderSecondarySalesAddress()\n        external\n        view\n        returns (address payable);\n\n    // @dev The platform provider secondary sales royalties payment address\n    function platformProviderSecondarySalesAddress()\n        external\n        view\n        returns (address payable);\n\n    // @dev Basis points of secondary sales allocated to the render provider\n    function renderProviderSecondarySalesBPS() external view returns (uint256);\n\n    // @dev Basis points of secondary sales allocated to the platform provider\n    function platformProviderSecondarySalesBPS()\n        external\n        view\n        returns (uint256);\n\n    // function to read the hash for a given tokenId\n    function tokenIdToHash(uint256 _tokenId) external view returns (bytes32);\n\n    // function to read the hash-seed for a given tokenId\n    function tokenIdToHashSeed(\n        uint256 _tokenId\n    ) external view returns (bytes12);\n}\n"

    },

    "contracts/tender/interfaces/IGenArt721CoreContractV3.sol": {

      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\npragma solidity ^0.8.0;\n\nimport \"./IAdminACLV0.sol\";\nimport \"./IGenArt721CoreContractV3_Base.sol\";\n\n/**\n * @title This interface extends IGenArt721CoreContractV3_Base with functions\n * that are part of the Art Blocks Flagship core contract.\n * @author Art Blocks Inc.\n */\n// This interface extends IGenArt721CoreContractV3_Base with functions that are\n// in part of the Art Blocks Flagship core contract.\ninterface IGenArt721CoreContractV3 is IGenArt721CoreContractV3_Base {\n    // @dev new function in V3\n    function getPrimaryRevenueSplits(\n        uint256 _projectId,\n        uint256 _price\n    )\n        external\n        view\n        returns (\n            uint256 artblocksRevenue_,\n            address payable artblocksAddress_,\n            uint256 artistRevenue_,\n            address payable artistAddress_,\n            uint256 additionalPayeePrimaryRevenue_,\n            address payable additionalPayeePrimaryAddress_\n        );\n\n    // @dev Art Blocks primary sales payment address\n    function artblocksPrimarySalesAddress()\n        external\n        view\n        returns (address payable);\n\n    /**\n     * @notice Backwards-compatible (pre-V3) function returning Art Blocks\n     * primary sales payment address (now called artblocksPrimarySalesAddress).\n     */\n    function artblocksAddress() external view returns (address payable);\n\n    // @dev Percentage of primary sales allocated to Art Blocks\n    function artblocksPrimarySalesPercentage() external view returns (uint256);\n\n    /**\n     * @notice Backwards-compatible (pre-V3) function returning Art Blocks\n     * primary sales percentage (now called artblocksPrimarySalesPercentage).\n     */\n    function artblocksPercentage() external view returns (uint256);\n\n    // @dev Art Blocks secondary sales royalties payment address\n    function artblocksSecondarySalesAddress()\n        external\n        view\n        returns (address payable);\n\n    // @dev Basis points of secondary sales allocated to Art Blocks\n    function artblocksSecondarySalesBPS() external view returns (uint256);\n\n    /**\n     * @notice Backwards-compatible (pre-V3) function  that gets artist +\n     * artist's additional payee royalty data for token ID `_tokenId`.\n     * WARNING: Does not include Art Blocks portion of royalties.\n     */\n    function getRoyaltyData(\n        uint256 _tokenId\n    )\n        external\n        view\n        returns (\n            address artistAddress,\n            address additionalPayee,\n            uint256 additionalPayeePercentage,\n            uint256 royaltyFeeByID\n        );\n}\n"

    },

    "contracts/tender/interfaces/IManifold.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @dev Royalty Registry interface, used to support the Royalty Registry.\n/// @dev Source: https://github.com/manifoldxyz/royalty-registry-solidity/blob/main/contracts/specs/IManifold.sol\n\n/// @author: manifold.xyz\n\n/**\n * @dev Royalty interface for creator core classes\n */\ninterface IManifold {\n    /**\n     * @dev Get royalites of a token.  Returns list of receivers and basisPoints\n     *\n     *  bytes4(keccak256('getRoyalties(uint256)')) == 0xbb3bafd6\n     *\n     *  => 0xbb3bafd6 = 0xbb3bafd6\n     */\n    function getRoyalties(\n        uint256 tokenId\n    ) external view returns (address payable[] memory, uint256[] memory);\n}\n"

    },

    "contracts/tender/interfaces/IMinterBaseV0.sol": {

      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\nimport \"./IFilteredMinterV2.sol\";\n\npragma solidity ^0.8.0;\n\n/**\n * @title This interface defines any events or functions required for a minter\n * to conform to the MinterBase contract.\n * @dev The MinterBase contract was not implemented from the beginning of the\n * MinterSuite contract suite, therefore early versions of some minters may not\n * conform to this interface.\n * @author Art Blocks Inc.\n */\ninterface IMinterBaseV0 {\n    // Function that returns if a minter is configured to integrate with a V3 flagship or V3 engine contract.\n    // Returns true only if the minter is configured to integrate with an engine contract.\n    function isEngine() external returns (bool isEngine);\n}\n"

    },

    "contracts/tender/interfaces/IMinterFilterV0.sol": {

      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\npragma solidity ^0.8.0;\n\ninterface IMinterFilterV0 {\n    /**\n     * @notice Approved minter `_minterAddress`.\n     */\n    event MinterApproved(address indexed _minterAddress, string _minterType);\n\n    /**\n     * @notice Revoked approval for minter `_minterAddress`\n     */\n    event MinterRevoked(address indexed _minterAddress);\n\n    /**\n     * @notice Minter `_minterAddress` of type `_minterType`\n     * registered for project `_projectId`.\n     */\n    event ProjectMinterRegistered(\n        uint256 indexed _projectId,\n        address indexed _minterAddress,\n        string _minterType\n    );\n\n    /**\n     * @notice Any active minter removed for project `_projectId`.\n     */\n    event ProjectMinterRemoved(uint256 indexed _projectId);\n\n    function genArt721CoreAddress() external returns (address);\n\n    function setMinterForProject(uint256, address) external;\n\n    function removeMinterForProject(uint256) external;\n\n    function mint(\n        address _to,\n        uint256 _projectId,\n        address sender\n    ) external returns (uint256);\n\n    function getMinterForProject(uint256) external view returns (address);\n\n    function projectHasMinter(uint256) external view returns (bool);\n}\n"

    },

    "contracts/tender/MinterBase_v0_1_1.sol": {

      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n// Created By: Art Blocks Inc.\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./interfaces/IMinterBaseV0.sol\";\nimport \"./interfaces/IGenArt721CoreContractV3_Base.sol\";\nimport \"./interfaces/IGenArt721CoreContractV3.sol\";\nimport \"./interfaces/IGenArt721CoreContractV3_Engine.sol\";\n\npragma solidity ^0.8.0;\n\n/**\n * @title Art Blocks Minter Base Class\n * @notice A base class for Art Blocks minter contracts that provides common\n * functionality used across minter contracts.\n * This contract is not intended to be deployed directly, but rather to be\n * inherited by other minter contracts.\n * From a design perspective, this contract is intended to remain simple and\n * easy to understand. It is not intended to cause a complex inheritance tree,\n * and instead should keep minter contracts as readable as possible for\n * collectors and developers.\n * @dev Semantic versioning is used in the solidity file name, and is therefore\n * controlled by contracts importing the appropriate filename version.\n * @author Art Blocks Inc.\n */\nabstract contract MinterBase is IMinterBaseV0 {\n    /// state variable that tracks whether this contract's associated core\n    /// contract is an Engine contract, where Engine contracts have an\n    /// additional revenue split for the platform provider\n    bool public immutable isEngine;\n\n    // @dev we do not track an initialization state, as the only state variable\n    // is immutable, which the compiler enforces to be assigned during\n    // construction.\n\n    /**\n     * @notice Initializes contract to ensure state variable `isEngine` is set\n     * appropriately based on the minter's associated core contract address.\n     * @param genArt721Address Art Blocks core contract address for\n     * which this contract will be a minter.\n     */\n    constructor(address genArt721Address) {\n        // set state variable isEngine\n        isEngine = _getV3CoreIsEngine(genArt721Address);\n    }\n\n    /**\n     * @notice splits ETH funds between sender (if refund), providers,\n     * artist, and artist's additional payee for a token purchased on\n     * project `_projectId`.\n     * WARNING: This function uses msg.value and msg.sender to determine\n     * refund amounts, and therefore may not be applicable to all use cases\n     * (e.g. do not use with Dutch Auctions with on-chain settlement).\n     * @dev possible DoS during splits is acknowledged, and mitigated by\n     * business practices, including end-to-end testing on mainnet, and\n     * admin-accepted artist payment addresses.\n     * @param projectId Project ID for which funds shall be split.\n     * @param pricePerTokenInWei Current price of token, in Wei.\n     */\n    function splitFundsETH(\n        uint256 projectId,\n        uint256 pricePerTokenInWei,\n        address genArt721CoreAddress\n    ) internal {\n        if (msg.value > 0) {\n            bool success_;\n            // send refund to sender\n            uint256 refund = msg.value - pricePerTokenInWei;\n            if (refund > 0) {\n                (success_, ) = msg.sender.call{value: refund}(\"\");\n                require(success_, \"Refund failed\");\n            }\n            // split revenues\n            splitRevenuesETH(\n                projectId,\n                pricePerTokenInWei,\n                genArt721CoreAddress\n            );\n        }\n    }\n\n    /**\n     * @notice splits ETH revenues between providers, artist, and artist's\n     * additional payee for revenue generated by project `_projectId`.\n     * @dev possible DoS during splits is acknowledged, and mitigated by\n     * business practices, including end-to-end testing on mainnet, and\n     * admin-accepted artist payment addresses.\n     * @param projectId Project ID for which funds shall be split.\n     * @param valueInWei Value to be split, in Wei.\n     */\n    function splitRevenuesETH(\n        uint256 projectId,\n        uint256 valueInWei,\n        address genArtCoreContract\n    ) internal {\n        if (valueInWei <= 0) {\n            return; // return early\n        }\n        bool success;\n        // split funds between platforms, artist, and artist's\n        // additional payee\n        uint256 renderProviderRevenue_;\n        address payable renderProviderAddress_;\n        uint256 artistRevenue_;\n        address payable artistAddress_;\n        uint256 additionalPayeePrimaryRevenue_;\n        address payable additionalPayeePrimaryAddress_;\n        if (isEngine) {\n            // get engine splits\n            uint256 platformProviderRevenue_;\n            address payable platformProviderAddress_;\n            (\n                renderProviderRevenue_,\n                renderProviderAddress_,\n                platformProviderRevenue_,\n                platformProviderAddress_,\n                artistRevenue_,\n                artistAddress_,\n                additionalPayeePrimaryRevenue_,\n                additionalPayeePrimaryAddress_\n            ) = IGenArt721CoreContractV3_Engine(genArtCoreContract)\n                .getPrimaryRevenueSplits(projectId, valueInWei);\n            // Platform Provider payment (only possible if engine)\n            if (platformProviderRevenue_ > 0) {\n                (success, ) = platformProviderAddress_.call{\n                    value: platformProviderRevenue_\n                }(\"\");\n                require(success, \"Platform Provider payment failed\");\n            }\n        } else {\n            // get flagship splits\n            (\n                renderProviderRevenue_, // artblocks revenue\n                renderProviderAddress_, // artblocks address\n                artistRevenue_,\n                artistAddress_,\n                additionalPayeePrimaryRevenue_,\n                additionalPayeePrimaryAddress_\n            ) = IGenArt721CoreContractV3(genArtCoreContract)\n                .getPrimaryRevenueSplits(projectId, valueInWei);\n        }\n        // Render Provider / Art Blocks payment\n        if (renderProviderRevenue_ > 0) {\n            (success, ) = renderProviderAddress_.call{\n                value: renderProviderRevenue_\n            }(\"\");\n            require(success, \"Render Provider payment failed\");\n        }\n        // artist payment\n        if (artistRevenue_ > 0) {\n            (success, ) = artistAddress_.call{value: artistRevenue_}(\"\");\n            require(success, \"Artist payment failed\");\n        }\n        // additional payee payment\n        if (additionalPayeePrimaryRevenue_ > 0) {\n            (success, ) = additionalPayeePrimaryAddress_.call{\n                value: additionalPayeePrimaryRevenue_\n            }(\"\");\n            require(success, \"Additional Payee payment failed\");\n        }\n    }\n\n    /**\n     * @notice splits ERC-20 funds between providers, artist, and artist's\n     * additional payee, for a token purchased on project `_projectId`.\n     * @dev possible DoS during splits is acknowledged, and mitigated by\n     * business practices, including end-to-end testing on mainnet, and\n     * admin-accepted artist payment addresses.\n     */\n    function splitFundsERC20(\n        uint256 projectId,\n        uint256 pricePerTokenInWei,\n        address currencyAddress,\n        address genArtCoreContract\n    ) internal {\n        IERC20 _projectCurrency = IERC20(currencyAddress);\n        // split remaining funds between foundation, artist, and artist's\n        // additional payee\n        uint256 renderProviderRevenue_;\n        address payable renderProviderAddress_;\n        uint256 artistRevenue_;\n        address payable artistAddress_;\n        uint256 additionalPayeePrimaryRevenue_;\n        address payable additionalPayeePrimaryAddress_;\n        if (isEngine) {\n            // get engine splits\n            uint256 platformProviderRevenue_;\n            address payable platformProviderAddress_;\n            (\n                renderProviderRevenue_,\n                renderProviderAddress_,\n                platformProviderRevenue_,\n                platformProviderAddress_,\n                artistRevenue_,\n                artistAddress_,\n                additionalPayeePrimaryRevenue_,\n                additionalPayeePrimaryAddress_\n            ) = IGenArt721CoreContractV3_Engine(genArtCoreContract)\n                .getPrimaryRevenueSplits(projectId, pricePerTokenInWei);\n            // Platform Provider payment (only possible if engine)\n            if (platformProviderRevenue_ > 0) {\n                _projectCurrency.transferFrom(\n                    msg.sender,\n                    platformProviderAddress_,\n                    platformProviderRevenue_\n                );\n            }\n        } else {\n            // get flagship splits\n            (\n                renderProviderRevenue_, // artblocks revenue\n                renderProviderAddress_, // artblocks address\n                artistRevenue_,\n                artistAddress_,\n                additionalPayeePrimaryRevenue_,\n                additionalPayeePrimaryAddress_\n            ) = IGenArt721CoreContractV3(genArtCoreContract)\n                .getPrimaryRevenueSplits(projectId, pricePerTokenInWei);\n        }\n        // Art Blocks payment\n        if (renderProviderRevenue_ > 0) {\n            _projectCurrency.transferFrom(\n                msg.sender,\n                renderProviderAddress_,\n                renderProviderRevenue_\n            );\n        }\n        // artist payment\n        if (artistRevenue_ > 0) {\n            _projectCurrency.transferFrom(\n                msg.sender,\n                artistAddress_,\n                artistRevenue_\n            );\n        }\n        // additional payee payment\n        if (additionalPayeePrimaryRevenue_ > 0) {\n            _projectCurrency.transferFrom(\n                msg.sender,\n                additionalPayeePrimaryAddress_,\n                additionalPayeePrimaryRevenue_\n            );\n        }\n    }\n\n    /**\n     * @notice Returns whether a V3 core contract is an Art Blocks Engine\n     * contract or not. Return value of false indicates that the core is a\n     * flagship contract.\n     * @dev this function reverts if a core contract does not return the\n     * expected number of return values from getPrimaryRevenueSplits() for\n     * either a flagship or engine core contract.\n     * @dev this function uses the length of the return data (in bytes) to\n     * determine whether the core is an engine or not.\n     * @param genArt721CoreV3 The address of the deployed core contract.\n     */\n    function _getV3CoreIsEngine(\n        address genArt721CoreV3\n    ) private returns (bool) {\n        // call getPrimaryRevenueSplits() on core contract\n        bytes memory payload = abi.encodeWithSignature(\n            \"getPrimaryRevenueSplits(uint256,uint256)\",\n            0,\n            0\n        );\n        (bool success, bytes memory returnData) = genArt721CoreV3.call(payload);\n        require(success, \"getPrimaryRevenueSplits() call failed\");\n        // determine whether core is engine or not, based on return data length\n        uint256 returnDataLength = returnData.length;\n        if (returnDataLength == 6 * 32) {\n            // 6 32-byte words returned if flagship (not engine)\n            // @dev 6 32-byte words are expected because the non-engine core\n            // contracts return a payout address and uint256 payment value for\n            // the artist, and artist's additional payee, and Art Blocks.\n            // also note that per Solidity ABI encoding, the address return\n            // values are padded to 32 bytes.\n            return false;\n        } else if (returnDataLength == 8 * 32) {\n            // 8 32-byte words returned if engine\n            // @dev 8 32-byte words are expected because the engine core\n            // contracts return a payout address and uint256 payment value for\n            // the artist, artist's additional payee, render provider\n            // typically Art Blocks, and platform provider (partner).\n            // also note that per Solidity ABI encoding, the address return\n            // values are padded to 32 bytes.\n            return true;\n        } else {\n            // unexpected return value length\n            revert(\"Unexpected revenue split bytes\");\n        }\n    }\n}\n"

    },

    "contracts/tender/MultiMerkleMinterV1.sol": {

      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity 0.8.17;\n\n// Created By: @backseats_eth\n\n// Forked from and inspired by ArtBlocks' MerkleMinterV1 contract\n// https://github.com/ArtBlocks/artblocks-contracts/blob/32738da594e7b9d18e25011b1c7fefa4abb1bda9/contracts/archive/minter-suite/Minters/MinterMerkle/MinterMerkleV1.sol\n\nimport { ECDSA } from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport { MerkleProof } from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"./interfaces/IGenArt721CoreContractV3_Base.sol\";\nimport \"./interfaces/IFilteredMinterMerkleV2.sol\";\nimport \"./interfaces/IMinterFilterV0.sol\";\nimport \"./MinterBase_v0_1_1.sol\";\n\n/**\n * @title Filtered Minter contract that allows tokens to be minted with ETH\n * for addresses in a Merkle allowlist.\n * This is designed to be used with GenArt721CoreContractV3 flagship or\n * engine contracts.\n * @notice Privileged Roles and Ownership:\n * This contract is designed to be managed, with limited powers.\n * Privileged roles and abilities are controlled by the project's artist, which\n * can be modified by the core contract's Admin ACL contract. Both of these\n * roles hold extensive power and can modify minter details.\n * Care must be taken to ensure that the admin ACL contract and artist\n * addresses are secure behind a multi-sig or other access control mechanism.\n * ----------------------------------------------------------------------------\n * The following functions are restricted to a project's artist:\n * - createNewStage\n * - manuallyLimitProjectMaxInvocations\n * - setProjectMaxInvocations\n * - teamMint\n * - updateMerkleRoot\n * - updatePricePerTokenInWei\n * - updateSystemAddress\n * ----------------------------------------------------------------------------\n * Additional admin and artist privileged roles may be described on other\n * contracts that this minter integrates with.\n * ----------------------------------------------------------------------------\n */\ncontract MultiMerkleMinterV1 is ReentrancyGuard, MinterBase, IFilteredMinterMerkleV2 {\n    using MerkleProof for bytes32[];\n    using ECDSA for bytes32;\n\n    // Used for unneeded protocol-conformance functions\n    error ActionNotSupported();\n\n    /*//////////////////////////////////////////////////////////////\n                                STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// Core contract address this minter interacts with\n    address public immutable genArt721CoreAddress;\n\n    /// The core contract integrates with V3 contracts\n    IGenArt721CoreContractV3_Base private immutable genArtCoreContract_Base;\n\n    /// Minter filter address this minter interacts with\n    address public immutable minterFilterAddress;\n\n    /// Minter filter this minter may interact with.\n    IMinterFilterV0 private immutable minterFilter;\n\n    /// minterType for this minter\n    string public constant minterType = \"MultiMerkleMinterV1\";\n\n    /// The theoretical total number of tokens that can be minted for a project on GenArt721Core\n    uint256 constant ONE_MILLION = 1_000_000;\n\n    // A mapping of project ids to their Project Config\n    mapping(uint256 => ProjectConfig) public projectConfig;\n\n    /*//////////////////////////////////////////////////////////////\n                                STRUCTS\n    //////////////////////////////////////////////////////////////*/\n\n    // A ProjectConfig is specific to the MultiMerkleMinter so that it can be re-used to mint\n    // multiple GenArtCoreV3-conforming projects\n    struct ProjectConfig {\n        // If the project has minted out\n        bool maxHasBeenInvoked;\n\n        // If the creator or artist has configured the price\n        bool priceIsConfigured;\n\n        // The id of the current stage of the mint. If 0, the project is minted out or not started\n        uint8 currentStageId;\n\n        // The count of the stages for the project. Starts at 0 for no Stages created\n        uint8 stagesCount;\n\n        // The maximum amount of tokens that can be minted for the project\n        uint24 maxInvocations;\n\n        // Which system address is the signer for the project id\n        address systemAddress;\n\n        // If a nonce has been used or not to mint the project\n        mapping(string => bool) usedNonces;\n\n        // How many times an address has minted for the project at this Stage\n        mapping(uint8 => mapping(address => uint)) addressMintedCount;\n\n        // A mapping of the id of the Stage to the Stage, sequentially from 1.\n        mapping(uint8 => Stage) stages;\n    }\n\n    struct Stage {\n        // The id of the Stage. Starts at 1. 0 is the null state\n        uint8 id;\n\n        // The maximum amount of tokens a wallet can mint in that stage\n        uint8 transactionMaxInvocations;\n\n        // The Unix timestamp of when the stage starts. Suffers from the 2038 problem but we'll be fine\n        uint32 stageStartTime;\n\n        // Optional Merkle Root. Use 0x if not used\n        bytes32 merkleRoot;\n\n        // The price of the token for that stage\n        uint256 pricePerTokenInWei;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                MODIFIER\n    //////////////////////////////////////////////////////////////*/\n\n    modifier onlyArtist(uint256 _projectId) {\n        require(msg.sender == genArtCoreContract_Base.projectIdToArtistAddress(_projectId), \"Only Artist\");\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Initializes contract to be a Filtered Minter for\n     * `_minterFilter`, integrated with Art Blocks core contract\n     * at address `_genArt721Address`.\n     * @param _genArt721Address Art Blocks core contract address for\n     * which this contract will be a minter.\n     * @param _minterFilter Minter filter for which this will be a\n     * filtered minter.\n     */\n    constructor(\n        address _genArt721Address,\n        address _minterFilter\n    ) ReentrancyGuard() MinterBase(_genArt721Address) {\n        genArt721CoreAddress = _genArt721Address;\n        // always populate immutable engine contracts, but only use appropriate\n        // interface based on isEngine in the rest of the contract\n        genArtCoreContract_Base = IGenArt721CoreContractV3_Base(\n            _genArt721Address\n        );\n\n        minterFilterAddress = _minterFilter;\n        minterFilter = IMinterFilterV0(_minterFilter);\n\n        require(minterFilter.genArt721CoreAddress() == _genArt721Address, \"Illegal Contract Pairing\");\n    }\n\n    /**\n     * @notice Update the Merkle root for project `_projectId`.\n     * @param _projectId Project ID to be updated.\n     * @param _stageId Stage ID to be updated.\n     * @param _root root of Merkle tree defining addresses allowed to mint\n     * on project `_projectId`.\n     */\n    function updateMerkleRoot(\n        uint256 _projectId,\n        uint8 _stageId,\n        bytes32 _root\n    ) external onlyArtist(_projectId) {\n        ProjectConfig storage _projectConfig = projectConfig[_projectId];\n        _projectConfig.stages[_stageId].merkleRoot = _root;\n    }\n\n    function updateStartingTimeForStage(\n        uint256 _projectId,\n        uint8 _stageId,\n        uint32 _newStartingTime\n    ) external onlyArtist(_projectId) {\n        require(_stageId > 0, \"Can't be 0\");\n        ProjectConfig storage _projectConfig = projectConfig[_projectId];\n        require(_projectConfig.stagesCount > 0, \"No Stages exist for project\");\n        require(_newStartingTime > 0, \"Can't be 0\");\n        require(_newStartingTime > block.timestamp, \"Must be in the future\");\n        require(_stageId <= _projectConfig.stagesCount, \"Stage doesn't exist\");\n\n        if (_stageId == _projectConfig.stagesCount) {\n            _projectConfig.stages[_stageId].stageStartTime = _newStartingTime;\n\n        } else if (_stageId + 1 <= _projectConfig.stagesCount) {\n            // Ensure future stage exists and it doesn't collide\n            Stage memory futureStage = _projectConfig.stages[_stageId + 1];\n            require(_newStartingTime < futureStage.stageStartTime, \"Stage can't start after next one\");\n\n            _projectConfig.stages[_stageId].stageStartTime = _newStartingTime;\n        }\n    }\n\n    /**\n     * @notice Returns hashed address (to be used as merkle tree leaf).\n     * Included as a public function to enable users to calculate their hashed\n     * address in Solidity when generating proofs off-chain.\n     * @param _address address to be hashed\n     * @return bytes32 hashed address, via keccak256 (using encodePacked)\n     */\n    function hashAddress(address _address) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_address));\n    }\n\n    /**\n     * @notice Verify if address is allowed to mint on project `_projectId`.\n     * @param _merkleRoot The Merkle root for the project.\n     * @param _proof Merkle proof for address.\n     * @param _address Addrexss to check.\n     * @return inAllowlist true only if address is allowed to mint and valid\n     * Merkle proof was provided\n     */\n    function verifyAddress(\n        bytes32 _merkleRoot,\n        bytes32[] calldata _proof,\n        address _address\n    ) public pure returns (bool) {\n        return _proof.verifyCalldata(_merkleRoot, hashAddress(_address));\n    }\n\n    /**\n     * @notice Syncs local maximum invocations of project `_projectId` based on\n     * the value currently defined in the core contract.\n     * @param _projectId Project ID to set the maximum invocations for.\n     * @dev this enables gas reduction after maxInvocations have been reached -\n     * core contracts shall still enforce a maxInvocation check during mint.\n     */\n    function setProjectMaxInvocations(uint256 _projectId) external onlyArtist(_projectId) {\n        uint256 maxInvocations;\n        uint256 invocations;\n        (invocations, maxInvocations, , , , ) = genArtCoreContract_Base\n            .projectStateData(_projectId);\n        // update storage with results\n        projectConfig[_projectId].maxInvocations = uint24(maxInvocations);\n\n        // We need to ensure maxHasBeenInvoked is correctly set after manually syncing the\n        // local maxInvocations value with the core contract's maxInvocations value.\n        // This synced value of maxInvocations from the core contract will always be greater\n        // than or equal to the previous value of maxInvocations stored locally.\n        projectConfig[_projectId].maxHasBeenInvoked =\n            invocations == maxInvocations;\n\n        emit ProjectMaxInvocationsLimitUpdated(_projectId, maxInvocations);\n    }\n\n    /**\n     * @notice Manually sets the local maximum invocations of project `_projectId`\n     * with the provided `_maxInvocations`, checking that `_maxInvocations` is less\n     * than or equal to the value of project `_project_id`'s maximum invocations that is\n     * set on the core contract.\n     * @dev Note that a `_maxInvocations` of 0 can only be set if the current `invocations`\n     * value is also 0 and this would also set `maxHasBeenInvoked` to true, correctly short-circuiting\n     * this minter's purchase function, avoiding extra gas costs from the core contract's maxInvocations check.\n     * @param _projectId Project ID to set the maximum invocations for.\n     * @param _maxInvocations Maximum invocations to set for the project.\n     */\n    function manuallyLimitProjectMaxInvocations(\n        uint256 _projectId,\n        uint256 _maxInvocations\n    ) external onlyArtist(_projectId) {\n        // CHECKS\n        // ensure that the manually set maxInvocations is not greater than what is set on the core contract\n        uint256 maxInvocations;\n        uint256 invocations;\n        (invocations, maxInvocations, , , , ) = genArtCoreContract_Base.projectStateData(_projectId);\n        require(\n            _maxInvocations <= maxInvocations,\n            \"Cannot increase project max invocations above core contract set project max invocations\"\n        );\n        require(\n            _maxInvocations >= invocations,\n            \"Cannot set project max invocations to less than current invocations\"\n        );\n\n        // EFFECTS\n        // update storage with results\n        projectConfig[_projectId].maxInvocations = uint24(_maxInvocations);\n        // We need to ensure maxHasBeenInvoked is correctly set after manually setting the\n        // local maxInvocations value.\n        projectConfig[_projectId].maxHasBeenInvoked =\n            invocations == _maxInvocations;\n\n        emit ProjectMaxInvocationsLimitUpdated(_projectId, _maxInvocations);\n    }\n\n    /**\n     * @notice projectId => has project reached its maximum number of\n     * invocations? Note that this returns a local cache of the core contract's\n     * state, and may be out of sync with the core contract. This is\n     * intentional, as it only enables gas optimization of mints after a\n     * project's maximum invocations has been reached. A false negative will\n     * only result in a gas cost increase, since the core contract will still\n     * enforce a maxInvocation check during minting. A false positive is not\n     * possible because the V3 core contract only allows maximum invocations\n     * to be reduced, not increased. Based on this rationale, we intentionally\n     * do not do input validation in this method as to whether or not the input\n     * `_projectId` is an existing project ID.\n     */\n    function projectMaxHasBeenInvoked(\n        uint256 _projectId\n    ) external view returns (bool) {\n        return projectConfig[_projectId].maxHasBeenInvoked;\n    }\n\n    // Returns the number of tokens minted for an address for a project id\n    function getAddressMintedCount(uint256 _projectId, uint8 _stageId, address _address) external view returns (uint) {\n        return projectConfig[_projectId].addressMintedCount[_stageId][_address];\n    }\n\n    /**\n     * @notice projectId => project's maximum number of invocations.\n     * Optionally synced with core contract value, for gas optimization.\n     * Note that this returns a local cache of the core contract's\n     * state, and may be out of sync with the core contract. This is\n     * intentional, as it only enables gas optimization of mints after a\n     * project's maximum invocations has been reached.\n     * @dev A number greater than the core contract's project max invocations\n     * will only result in a gas cost increase, since the core contract will\n     * still enforce a maxInvocation check during minting. A number less than\n     * the core contract's project max invocations is only possible when the\n     * project's max invocations have not been synced on this minter, since the\n     * V3 core contract only allows maximum invocations to be reduced, not\n     * increased. When this happens, the minter will enable minting, allowing\n     * the core contract to enforce the max invocations check. Based on this\n     * rationale, we intentionally do not do input validation in this method as\n     * to whether or not the input `_projectId` is an existing project ID.\n     */\n    function projectMaxInvocations(\n        uint256 _projectId\n    ) external view returns (uint256) {\n        return uint256(projectConfig[_projectId].maxInvocations);\n    }\n\n    /**\n     * @notice Updates this minter's price per token of project `_projectId`\n     * to be '_pricePerTokenInWei`, in Wei.\n     * This price supersedes any legacy core contract price per token value.\n     * @dev Note that it is intentionally supported here that the configured\n     * price may be explicitly set to `0`.\n     */\n    function updatePricePerTokenInWei(\n        uint256 _projectId,\n        uint8 _stageId,\n        uint256 _pricePerTokenInWei\n    ) external onlyArtist(_projectId) {\n        ProjectConfig storage _projectConfig = projectConfig[_projectId];\n        _projectConfig.priceIsConfigured = true;\n        _projectConfig.stages[_stageId].pricePerTokenInWei = _pricePerTokenInWei;\n    }\n\n    /**\n    * @notice Purchases 1 or more tokens from a project\n    * @param _projectId The project id\n    * @param _amount The number of tokens to purchase\n    * @param _signature A signature, generated from the minting site\n    * @param _data abi-encoded data, generated from the minting site\n    * @param _nonce A nonce, to accompany the signature\n    */\n    function purchaseMMM(\n        uint256 _projectId,\n        uint256 _amount,\n        bytes calldata _signature,\n        bytes calldata _data,\n        bytes32[] calldata _merkleProof,\n        string calldata _nonce\n    ) public payable nonReentrant() {\n        uint256 pid = _projectId;\n        uint256 amount = _amount;\n        bytes memory sig = _signature;\n\n        // CHECKS\n        ProjectConfig storage _projectConfig = projectConfig[pid];\n\n        // Note that `maxHasBeenInvoked` is only checked here to reduce gas\n        // consumption after a project has been fully minted.\n        // `_projectConfig.maxHasBeenInvoked` is locally cached to reduce\n        // gas consumption, but if not in sync with the core contract's value,\n        // the core contract also enforces its own max invocation check during\n        // minting.\n        require(!_projectConfig.maxHasBeenInvoked, \"Max Invocations Reached\");\n\n        // Gets the current Stage by timestamp\n        Stage memory _currentStage = currentStage(pid);\n\n        // If what we have set in storage is not the current Stage, update it\n        if (_projectConfig.currentStageId != _currentStage.id) {\n            _projectConfig.currentStageId = _currentStage.id;\n        }\n\n        // See function `createNewStage`\n        require(_currentStage.stageStartTime != 0, \"Create A Stage To Begin\");\n\n        // require artist to have configured price of token on this minter\n        require(_projectConfig.priceIsConfigured, \"Price Not Configured\");\n\n        // Check the price is correct\n        uint256 expectedPrice = currentStagePrice(pid) * amount;\n        require(msg.value == expectedPrice, \"Wrong Price\");\n\n        // Ensure the nonce coming from the server hasn't already been used\n        require(!_projectConfig.usedNonces[_nonce], \"Nonce Used\");\n\n        // Ensure the data signed from the server is valid\n        require(isValidSignature(\n            _projectConfig.systemAddress, keccak256(abi.encodePacked(msg.sender, amount, _nonce)), sig),\n            \"Invalid Signature\"\n        );\n\n        // Decode a tuple of the address and the max they can mint and ensure the data coming from the server is correct\n        (address _address, uint256 maxMintCount) = abi.decode(_data, (address, uint256));\n        require(_address == msg.sender, \"Bad Data\");\n\n        // If server sends through a maxMintCount > 0, check how many they've minted this stage\n        bool doMaxCheckForStage = maxMintCount > 0;\n\n        // Check to see if the msg.sender is on the allowlist if the Stage has an allowlist. First checks to see if the merkle root is the 0 address\n        if (address(uint160(uint256(currentStage(pid).merkleRoot))) != address(0)) {\n            bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n            require(MerkleProof.verify(_merkleProof, _currentStage.merkleRoot, leaf), \"Not On Allowlist\");\n        }\n\n        // Ensure the amount they're minting doesn't exceed their max for the stage\n        if (doMaxCheckForStage) {\n            require(_projectConfig.addressMintedCount[_currentStage.id][msg.sender] + amount <= maxMintCount, \"Can't Mint That Many\");\n        }\n\n        // Update the record of the nonce and the overall msg.sender mint count\n        _projectConfig.usedNonces[_nonce] = true;\n\n        // Increment user's minted count for this project\n        unchecked {\n            _projectConfig.addressMintedCount[_currentStage.id][msg.sender] += amount;\n        }\n\n        // Mint tokens\n        uint i;\n        do {\n            uint256 tokenId = minterFilter.mint(msg.sender, pid, msg.sender);\n\n            // If the max has been reached, set the flag to true\n            unchecked {\n                if (tokenId % ONE_MILLION == _projectConfig.maxInvocations - 1) {\n                    _projectConfig.maxHasBeenInvoked = true;\n                    // If minted out, set this to 0.\n                    _projectConfig.currentStageId = 0;\n                }\n            }\n\n            unchecked { ++i; }\n        } while (i < amount);\n\n        // INTERACTIONS\n        splitFundsETH(pid, msg.value, genArt721CoreAddress);\n    }\n\n    function teamMint(\n        uint256 _projectId,\n        address[] calldata _addresses,\n        uint256[] calldata _counts\n    ) external onlyArtist(_projectId) {\n        require(_addresses.length == _counts.length, \"Unequal arrays\");\n\n        uint256 length = _addresses.length;\n        // Outer loop iterator\n        uint256 i;\n        // Inner loop iterator\n        uint256 n;\n\n        // Loops through the addresses\n        do {\n            // Loops through the tokens to mint the address\n            do {\n                // This will fail in the underlying contract if exceeds project invocations\n                minterFilter.mint(_addresses[i], _projectId, msg.sender);\n                unchecked { ++n; }\n            } while (n < _counts[i]);\n\n            unchecked { ++i; }\n        } while (i < length);\n    }\n\n    function createNewStage(\n        uint256 _projectId,\n        uint32 _stageStartTime,\n        bytes32 _merkleRoot,\n        uint256 _pricePerTokenInWei,\n        uint8 _transactionMaxInvocations\n    ) onlyArtist(_projectId) external {\n        // Ensure the Stage start time is in the future\n        require(_stageStartTime > block.timestamp, \"No Start Block In Past\");\n\n        // Get ProjectConfig from mapping\n        ProjectConfig storage config = projectConfig[_projectId];\n\n        // Don't create a new Stage if minted out\n        require(!config.maxHasBeenInvoked, \"Minted Out Cant Create New Stage\");\n\n        // Start the `stages` mapping IDs at 1 so that 0 can be a null state\n        // Set the ProjectConfig's `priceIsConfigured` if this is the first Stage\n        uint8 nextStageId;\n        if (config.stagesCount == 0) {\n             nextStageId = 1;\n             config.priceIsConfigured = true;\n        } else {\n            nextStageId = config.stagesCount + 1;\n        }\n\n        // Increment the ProjectConfig's Stages count (i.e. 2 stages, stagesCount = 2)\n        unchecked { ++config.stagesCount; }\n\n        // Store the new Stage\n        config.stages[nextStageId] = Stage({\n            id: nextStageId,\n            transactionMaxInvocations: _transactionMaxInvocations,\n            stageStartTime: _stageStartTime,\n            merkleRoot: _merkleRoot,\n            pricePerTokenInWei: _pricePerTokenInWei\n        });\n    }\n\n    // Returns an array of all of the Stages for a given Project id\n    function allStages(uint256 _projectId) public view returns (Stage[] memory) {\n        ProjectConfig storage config = projectConfig[_projectId];\n\n        // i.e. 2 stages, length = 2\n        uint8 length = config.stagesCount;\n        Stage[] memory stages = new Stage[](length);\n\n        for(uint8 i; i < length;) {\n            // Add 1 to `i` here because Stages start at 1; 0 is the null state\n            stages[i] = getStage(_projectId, i + 1);\n            unchecked { ++i; }\n        }\n\n        return stages;\n    }\n\n    function getStage(uint256 _productId, uint8 _stageId) public view returns (Stage memory) {\n        return projectConfig[_productId].stages[_stageId];\n    }\n\n    // Returns the current Stage in progress for a mint. If a Project is finished, it will return an empty Stage\n    function currentStage(uint256 _projectId) public view returns (Stage memory) {\n        Stage[] memory _stages = allStages(_projectId); // 0 indexed\n        uint length = _stages.length;\n\n        for(uint i; i < length;) {\n            if (block.timestamp >= _stages[i].stageStartTime) {\n                // If there is no subsequent stage, return the current one\n                if (i + 1 >= length) {\n                    return _stages[i];\n                }\n\n                // If the next stage's start time is in the future, return the current one\n                if (block.timestamp < _stages[i + 1].stageStartTime) {\n                    return _stages[i];\n                }\n            }\n\n            unchecked { ++i; }\n        }\n\n        Stage memory empty;\n        return empty;\n    }\n\n    // Returns the current Stage's id\n    function currentStageId(uint256 _projectId) public view returns (uint8) {\n        return currentStage(_projectId).id;\n    }\n\n    // Returns the current Stage price in wei\n    function currentStagePrice(uint256  _projectId) public view returns (uint256) {\n        return currentStage(_projectId).pricePerTokenInWei;\n    }\n\n    // Returns the next Stage as a struct\n    function nextStage(uint256  _projectId) public view returns (Stage memory) {\n        ProjectConfig storage config = projectConfig[_projectId];\n        Stage memory _currentStage = currentStage(_projectId);\n\n        if (_currentStage.id == 0) {\n            return _currentStage;\n        } else if (config.stages[config.currentStageId + 1].id != 0) {\n            return config.stages[config.currentStageId + 1];\n        } else {\n            Stage memory empty;\n            return empty;\n        }\n    }\n\n    // Returns the next Stage's price in wei\n    function nextStagePrice(uint256 _projectId) external view returns (uint256) {\n        return nextStage(_projectId).pricePerTokenInWei;\n    }\n\n    // Returns the next stage start time as a Unix timestamp in seconds\n    function startingTimeOfNextStage(uint256 _projectId) external view returns (uint256) {\n        return nextStage(_projectId).stageStartTime;\n    }\n\n    /**\n     * @notice Process proof for an address. Returns Merkle root. Included to\n     * enable users to easily verify a proof's validity.\n     * @param _proof Merkle proof for address.\n     * @param _address Address to process.\n     * @return merkleRoot Merkle root for `_address` and `_proof`\n     */\n    function processProofForAddress(\n        bytes32[] calldata _proof,\n        address _address\n    ) external pure returns (bytes32) {\n        return _proof.processProofCalldata(hashAddress(_address));\n    }\n\n    /**\n     * @notice Gets if price of token is configured, price of minting a\n     * token on project `_projectId`, and currency symbol and address to be\n     * used as payment. Supersedes any core contract price information.\n     * @param _projectId Project ID to get price information for.\n     * @return isConfigured true only if token price has been configured on\n     * this minter\n     * @return tokenPriceInWei current price of token on this minter - invalid\n     * if price has not yet been configured\n     * @return currencySymbol currency symbol for purchases of project on this\n     * minter. This minter always returns \"ETH\"\n     * @return currencyAddress currency address for purchases of project on\n     * this minter. This minter always returns null address, reserved for ether\n     */\n    function getPriceInfo(uint256 _projectId) external view returns (\n        bool isConfigured,\n        uint256 tokenPriceInWei,\n        string memory currencySymbol,\n        address currencyAddress\n    ) {\n        ProjectConfig storage _projectConfig = projectConfig[_projectId];\n        isConfigured = _projectConfig.priceIsConfigured;\n        tokenPriceInWei = currentStagePrice(_projectId);\n        currencySymbol = \"ETH\";\n        currencyAddress = address(0);\n    }\n\n    function updateSystemAddress(uint256 _projectId, address _address) external onlyArtist(_projectId) {\n        ProjectConfig storage _projectConfig = projectConfig[_projectId];\n        _projectConfig.systemAddress = _address;\n    }\n\n    /// @notice Checks if the private key that singed the nonce matches the system address of the contract\n    function isValidSignature(\n        address _systemAddress,\n        bytes32 hash,\n        bytes memory signature\n    ) internal pure returns (bool) {\n        // Artist Owner should call `updateSystemAddress` with\n        // the address corresponding to the private key that\n        // signs the data payload from the backend being fed into the mint function.\n        require(_systemAddress != address(0), \"Missing System Address\");\n\n        bytes32 signedHash = hash.toEthSignedMessageHash();\n        return signedHash.recover(signature) == _systemAddress;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              UNSUPPORTED\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n    * @notice Inactive function - requires Merkle proof to purchase.\n    */\n    function purchase(uint256) external payable returns (uint256) {\n        revert ActionNotSupported();\n    }\n\n    /**\n    * @notice Inactive function - requires Merkle proof to purchase.\n    */\n    function purchaseTo(address, uint256) public payable returns (uint256) {\n        revert ActionNotSupported();\n    }\n\n    /**\n    * @notice Inactive function\n    */\n    function purchase(uint256, bytes32[] calldata) external payable returns (uint256) {\n        revert ActionNotSupported();\n    }\n\n    /**\n    * @notice Inactive function\n    */\n    function purchaseTo(address, uint256, bytes32[] calldata) external payable returns (uint256) {\n        revert ActionNotSupported();\n    }\n\n    /**\n    * @notice Inactive function\n    */\n    function togglePurchaseToDisabled(uint256) external pure {\n        revert ActionNotSupported();\n    }\n\n}\n"

    }

  },

  "settings": {

    "optimizer": {

      "enabled": false,

      "runs": 200

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "libraries": {}

  }

}}