{{

  "language": "Solidity",

  "sources": {

    "@openzeppelin/contracts/access/Ownable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"

    },

    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/Context.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"

    },

    "contracts/core/ToVInfos.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\ninterface ToVInfos {\n    struct ToV {\n        uint64 season;\n        uint64 seasonTraitCount;\n        uint256 dna;\n    }\n    \n    struct ContractData {\n        string name;\n        string collectionName;\n        string description;\n        string image;\n        string banner;\n        string website;\n        string royalties;\n        string royaltiesRecipient;\n    }\n}"

    },

    "contracts/lib/Base64.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library to encode strings in Base64.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Base64.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Base64.sol)\n/// @author Modified from (https://github.com/Brechtpd/base64/blob/main/base64.sol) by Brecht Devos - <brecht@loopring.org>.\nlibrary Base64 {\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// See: https://datatracker.ietf.org/doc/html/rfc4648\n    /// @param fileSafe  Whether to replace '+' with '-' and '/' with '_'.\n    /// @param noPadding Whether to strip away the padding.\n    function encode(bytes memory data, bool fileSafe, bool noPadding)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let dataLength := mload(data)\n\n            if dataLength {\n                // Multiply by 4/3 rounded up.\n                // The `shl(2, ...)` is equivalent to multiplying by 4.\n                let encodedLength := shl(2, div(add(dataLength, 2), 3))\n\n                // Set `result` to point to the start of the free memory.\n                result := mload(0x40)\n\n                // Store the table into the scratch space.\n                // Offsetted by -1 byte so that the `mload` will load the character.\n                // We will rewrite the free memory pointer at `0x40` later with\n                // the allocated size.\n                // The magic constant 0x0230 will translate \"-_\" + \"+/\".\n                mstore(0x1f, \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\")\n                mstore(0x3f, sub(\"ghijklmnopqrstuvwxyz0123456789-_\", mul(iszero(fileSafe), 0x0230)))\n\n                // Skip the first slot, which stores the length.\n                let ptr := add(result, 0x20)\n                let end := add(ptr, encodedLength)\n\n                // Run over the input, 3 bytes at a time.\n                for {} 1 {} {\n                    data := add(data, 3) // Advance 3 bytes.\n                    let input := mload(data)\n\n                    // Write 4 bytes. Optimized for fewer stack operations.\n                    mstore8(0, mload(and(shr(18, input), 0x3F)))\n                    mstore8(1, mload(and(shr(12, input), 0x3F)))\n                    mstore8(2, mload(and(shr(6, input), 0x3F)))\n                    mstore8(3, mload(and(input, 0x3F)))\n                    mstore(ptr, mload(0x00))\n\n                    ptr := add(ptr, 4) // Advance 4 bytes.\n\n                    if iszero(lt(ptr, end)) { break }\n                }\n\n                // Allocate the memory for the string.\n                // Add 31 and mask with `not(31)` to round the\n                // free memory pointer up the next multiple of 32.\n                mstore(0x40, and(add(end, 31), not(31)))\n\n                // Equivalent to `o = [0, 2, 1][dataLength % 3]`.\n                let o := div(2, mod(dataLength, 3))\n\n                // Offset `ptr` and pad with '='. We can simply write over the end.\n                mstore(sub(ptr, o), shl(240, 0x3d3d))\n                // Set `o` to zero if there is padding.\n                o := mul(iszero(iszero(noPadding)), o)\n                // Zeroize the slot after the string.\n                mstore(sub(ptr, o), 0)\n                // Write the length of the string.\n                mstore(result, sub(encodedLength, o))\n            }\n        }\n    }\n\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// Equivalent to `encode(data, false, false)`.\n    function encode(bytes memory data) internal pure returns (string memory result) {\n        result = encode(data, false, false);\n    }\n\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// Equivalent to `encode(data, fileSafe, false)`.\n    function encode(bytes memory data, bool fileSafe)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = encode(data, fileSafe, false);\n    }\n\n    /// @dev Encodes base64 encoded `data`.\n    ///\n    /// Supports:\n    /// - RFC 4648 (both standard and file-safe mode).\n    /// - RFC 3501 (63: ',').\n    ///\n    /// Does not support:\n    /// - Line breaks.\n    ///\n    /// Note: For performance reasons,\n    /// this function will NOT revert on invalid `data` inputs.\n    /// Outputs for invalid inputs will simply be undefined behaviour.\n    /// It is the user's responsibility to ensure that the `data`\n    /// is a valid base64 encoded string.\n    function decode(string memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let dataLength := mload(data)\n\n            if dataLength {\n                let decodedLength := mul(shr(2, dataLength), 3)\n\n                for {} 1 {} {\n                    // If padded.\n                    if iszero(and(dataLength, 3)) {\n                        let t := xor(mload(add(data, dataLength)), 0x3d3d)\n                        // forgefmt: disable-next-item\n                        decodedLength := sub(\n                            decodedLength,\n                            add(iszero(byte(30, t)), iszero(byte(31, t)))\n                        )\n                        break\n                    }\n                    // If non-padded.\n                    decodedLength := add(decodedLength, sub(and(dataLength, 3), 1))\n                    break\n                }\n                result := mload(0x40)\n\n                // Write the length of the bytes.\n                mstore(result, decodedLength)\n\n                // Skip the first slot, which stores the length.\n                let ptr := add(result, 0x20)\n                let end := add(ptr, decodedLength)\n\n                // Load the table into the scratch space.\n                // Constants are optimized for smaller bytecode with zero gas overhead.\n                // `m` also doubles as the mask of the upper 6 bits.\n                let m := 0xfc000000fc00686c7074787c8084888c9094989ca0a4a8acb0b4b8bcc0c4c8cc\n                mstore(0x5b, m)\n                mstore(0x3b, 0x04080c1014181c2024282c3034383c4044484c5054585c6064)\n                mstore(0x1a, 0xf8fcf800fcd0d4d8dce0e4e8ecf0f4)\n\n                for {} 1 {} {\n                    // Read 4 bytes.\n                    data := add(data, 4)\n                    let input := mload(data)\n\n                    // Write 3 bytes.\n                    // forgefmt: disable-next-item\n                    mstore(ptr, or(\n                        and(m, mload(byte(28, input))),\n                        shr(6, or(\n                            and(m, mload(byte(29, input))),\n                            shr(6, or(\n                                and(m, mload(byte(30, input))),\n                                shr(6, mload(byte(31, input)))\n                            ))\n                        ))\n                    ))\n\n                    ptr := add(ptr, 3)\n\n                    if iszero(lt(ptr, end)) { break }\n                }\n\n                // Allocate the memory for the string.\n                // Add 31 and mask with `not(31)` to round the\n                // free memory pointer up the next multiple of 32.\n                mstore(0x40, and(add(end, 31), not(31)))\n                // Zeroize the slot after the bytes.\n                mstore(end, 0)\n                // Restore the zero slot.\n                mstore(0x60, 0)\n            }\n        }\n    }\n}\n"

    },

    "contracts/lib/DynamicBuffer.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// Copyright (c) 2021 the ethier authors (github.com/divergencetech/ethier)\n\npragma solidity >=0.8.0;\n\n/// @title DynamicBuffer\n/// @author David Huber (@cxkoda) and Simon Fremaux (@dievardump). See also\n///         https://raw.githubusercontent.com/dievardump/solidity-dynamic-buffer\n/// @notice This library is used to allocate a big amount of container memory\n//          which will be subsequently filled without needing to reallocate\n///         memory.\n/// @dev First, allocate memory.\n///      Then use `buffer.appendUnchecked(theBytes)` or `appendSafe()` if\n///      bounds checking is required.\nlibrary DynamicBuffer {\n    /// @notice Allocates container space for the DynamicBuffer\n    /// @param capacity_ The intended max amount of bytes in the buffer\n    /// @return buffer The memory location of the buffer\n    /// @dev Allocates `capacity_ + 0x60` bytes of space\n    ///      The buffer array starts at the first container data position,\n    ///      (i.e. `buffer = container + 0x20`)\n    function allocate(uint256 capacity_)\n        internal\n        pure\n        returns (bytes memory buffer)\n    {\n        assembly {\n            // Get next-free memory address\n            let container := mload(0x40)\n\n            // Allocate memory by setting a new next-free address\n            {\n                // Add 2 x 32 bytes in size for the two length fields\n                // Add 32 bytes safety space for 32B chunked copy\n                let size := add(capacity_, 0x60)\n                let newNextFree := add(container, size)\n                mstore(0x40, newNextFree)\n            }\n\n            // Set the correct container length\n            {\n                let length := add(capacity_, 0x40)\n                mstore(container, length)\n            }\n\n            // The buffer starts at idx 1 in the container (0 is length)\n            buffer := add(container, 0x20)\n\n            // Init content with length 0\n            mstore(buffer, 0)\n        }\n\n        return buffer;\n    }\n\n    /// @notice Appends data to buffer, and update buffer length\n    /// @param buffer the buffer to append the data to\n    /// @param data the data to append\n    /// @dev Does not perform out-of-bound checks (container capacity)\n    ///      for efficiency.\n    function appendUnchecked(bytes memory buffer, bytes memory data)\n        internal\n        pure\n    {\n        assembly {\n            let length := mload(data)\n            for {\n                data := add(data, 0x20)\n                let dataEnd := add(data, length)\n                let copyTo := add(buffer, add(mload(buffer), 0x20))\n            } lt(data, dataEnd) {\n                data := add(data, 0x20)\n                copyTo := add(copyTo, 0x20)\n            } {\n                // Copy 32B chunks from data to buffer.\n                // This may read over data array boundaries and copy invalid\n                // bytes, which doesn't matter in the end since we will\n                // later set the correct buffer length, and have allocated an\n                // additional word to avoid buffer overflow.\n                mstore(copyTo, mload(data))\n            }\n\n            // Update buffer length\n            mstore(buffer, add(mload(buffer), length))\n        }\n    }\n\n    /// @notice Appends data to buffer, and update buffer length\n    /// @param buffer the buffer to append the data to\n    /// @param data the data to append\n    /// @dev Performs out-of-bound checks and calls `appendUnchecked`.\n    function appendSafe(bytes memory buffer, bytes memory data) internal pure {\n        checkOverflow(buffer, data.length);\n        appendUnchecked(buffer, data);\n    }\n\n    /// @notice Appends data encoded as Base64 to buffer.\n    /// @param fileSafe  Whether to replace '+' with '-' and '/' with '_'.\n    /// @param noPadding Whether to strip away the padding.\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// See: https://datatracker.ietf.org/doc/html/rfc4648\n    /// Author: Modified from Solady (https://github.com/vectorized/solady/blob/main/src/utils/Base64.sol)\n    /// Author: Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Base64.sol)\n    /// Author: Modified from (https://github.com/Brechtpd/base64/blob/main/base64.sol) by Brecht Devos.\n    function appendSafeBase64(\n        bytes memory buffer,\n        bytes memory data,\n        bool fileSafe,\n        bool noPadding\n    ) internal pure {\n        uint256 dataLength = data.length;\n\n        if (data.length == 0) {\n            return;\n        }\n\n        uint256 encodedLength;\n        uint256 r;\n        assembly {\n            // For each 3 bytes block, we will have 4 bytes in the base64\n            // encoding: `encodedLength = 4 * divCeil(dataLength, 3)`.\n            // The `shl(2, ...)` is equivalent to multiplying by 4.\n            encodedLength := shl(2, div(add(dataLength, 2), 3))\n\n            r := mod(dataLength, 3)\n            if noPadding {\n                // if r == 0 => no modification\n                // if r == 1 => encodedLength -= 2\n                // if r == 2 => encodedLength -= 1\n                encodedLength := sub(\n                    encodedLength,\n                    add(iszero(iszero(r)), eq(r, 1))\n                )\n            }\n        }\n\n        checkOverflow(buffer, encodedLength);\n\n        assembly {\n            let nextFree := mload(0x40)\n\n            // Store the table into the scratch space.\n            // Offsetted by -1 byte so that the `mload` will load the character.\n            // We will rewrite the free memory pointer at `0x40` later with\n            // the allocated size.\n            mstore(0x1f, \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\")\n            mstore(\n                0x3f,\n                sub(\n                    \"ghijklmnopqrstuvwxyz0123456789-_\",\n                    // The magic constant 0x0230 will translate \"-_\" + \"+/\".\n                    mul(iszero(fileSafe), 0x0230)\n                )\n            )\n\n            // Skip the first slot, which stores the length.\n            let ptr := add(add(buffer, 0x20), mload(buffer))\n            let end := add(data, dataLength)\n\n            // Run over the input, 3 bytes at a time.\n            // prettier-ignore\n            // solhint-disable-next-line no-empty-blocks\n            for {} 1 {} {\n                    data := add(data, 3) // Advance 3 bytes.\n                    let input := mload(data)\n\n                    // Write 4 bytes. Optimized for fewer stack operations.\n                    mstore8(    ptr    , mload(and(shr(18, input), 0x3F)))\n                    mstore8(add(ptr, 1), mload(and(shr(12, input), 0x3F)))\n                    mstore8(add(ptr, 2), mload(and(shr( 6, input), 0x3F)))\n                    mstore8(add(ptr, 3), mload(and(        input , 0x3F)))\n                    \n                    ptr := add(ptr, 4) // Advance 4 bytes.\n                    // prettier-ignore\n                    if iszero(lt(data, end)) { break }\n                }\n\n            if iszero(noPadding) {\n                // Offset `ptr` and pad with '='. We can simply write over the end.\n                mstore8(sub(ptr, iszero(iszero(r))), 0x3d) // Pad at `ptr - 1` if `r > 0`.\n                mstore8(sub(ptr, shl(1, eq(r, 1))), 0x3d) // Pad at `ptr - 2` if `r == 1`.\n            }\n\n            mstore(buffer, add(mload(buffer), encodedLength))\n            mstore(0x40, nextFree)\n        }\n    }\n\n    /// @notice Returns the capacity of a given buffer.\n    function capacity(bytes memory buffer) internal pure returns (uint256) {\n        uint256 cap;\n        assembly {\n            cap := sub(mload(sub(buffer, 0x20)), 0x40)\n        }\n        return cap;\n    }\n\n    /// @notice Reverts if the buffer will overflow after appending a given\n    /// number of bytes.\n    function checkOverflow(bytes memory buffer, uint256 addedLength)\n        internal\n        pure\n    {\n        uint256 cap = capacity(buffer);\n        uint256 newLength = buffer.length + addedLength;\n        if (cap < newLength) {\n            revert(\"DynamicBuffer: Appending out of bounds.\");\n        }\n    }\n}\n"

    },

    "contracts/lib/SSTORE2.sol": {

      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Read and write to persistent storage at a fraction of the cost.\n/// @author Solady (https://github.com/vectorized/solmady/blob/main/src/utils/SSTORE2.sol)\n/// @author Saw-mon-and-Natalie (https://github.com/Saw-mon-and-Natalie)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\nlibrary SSTORE2 {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev We skip the first byte as it's a STOP opcode,\n    /// which ensures the contract can't be called.\n    uint256 internal constant DATA_OFFSET = 1;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Unable to deploy the storage contract.\n    error DeploymentFailed();\n\n    /// @dev The storage contract address is invalid.\n    error InvalidPointer();\n\n    /// @dev Attempt to read outside of the storage contract's bytecode bounds.\n    error ReadOutOfBounds();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         WRITE LOGIC                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Writes `data` into the bytecode of a storage contract and returns its address.\n    function write(bytes memory data) internal returns (address pointer) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let originalDataLength := mload(data)\n\n            // Add 1 to data size since we are prefixing it with a STOP opcode.\n            let dataSize := add(originalDataLength, DATA_OFFSET)\n\n            /**\n             * ------------------------------------------------------------------------------+\n             * Opcode      | Mnemonic        | Stack                   | Memory              |\n             * ------------------------------------------------------------------------------|\n             * 61 codeSize | PUSH2 codeSize  | codeSize                |                     |\n             * 80          | DUP1            | codeSize codeSize       |                     |\n             * 60 0xa      | PUSH1 0xa       | 0xa codeSize codeSize   |                     |\n             * 3D          | RETURNDATASIZE  | 0 0xa codeSize codeSize |                     |\n             * 39          | CODECOPY        | codeSize                | [0..codeSize): code |\n             * 3D          | RETURNDATASIZE  | 0 codeSize              | [0..codeSize): code |\n             * F3          | RETURN          |                         | [0..codeSize): code |\n             * 00          | STOP            |                         |                     |\n             * ------------------------------------------------------------------------------+\n             * @dev Prefix the bytecode with a STOP opcode to ensure it cannot be called.\n             * Also PUSH2 is used since max contract size cap is 24,576 bytes which is less than 2 ** 16.\n             */\n            mstore(\n                data,\n                or(\n                    0x61000080600a3d393df300,\n                    // Left shift `dataSize` by 64 so that it lines up with the 0000 after PUSH2.\n                    shl(0x40, dataSize)\n                )\n            )\n\n            // Deploy a new contract with the generated creation code.\n            pointer := create(0, add(data, 0x15), add(dataSize, 0xa))\n\n            // If `pointer` is zero, revert.\n            if iszero(pointer) {\n                // Store the function selector of `DeploymentFailed()`.\n                mstore(0x00, 0x30116425)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Restore original length of the variable size `data`.\n            mstore(data, originalDataLength)\n        }\n    }\n\n    /// @dev Writes `data` into the bytecode of a storage contract with `salt`\n    /// and returns its deterministic address.\n    function writeDeterministic(bytes memory data, bytes32 salt)\n        internal\n        returns (address pointer)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let originalDataLength := mload(data)\n            let dataSize := add(originalDataLength, DATA_OFFSET)\n\n            mstore(data, or(0x61000080600a3d393df300, shl(0x40, dataSize)))\n\n            // Deploy a new contract with the generated creation code.\n            pointer := create2(0, add(data, 0x15), add(dataSize, 0xa), salt)\n\n            // If `pointer` is zero, revert.\n            if iszero(pointer) {\n                // Store the function selector of `DeploymentFailed()`.\n                mstore(0x00, 0x30116425)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Restore original length of the variable size `data`.\n            mstore(data, originalDataLength)\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the storage contract for `data`.\n    /// Used for mining vanity addresses with create2crunch.\n    function initCodeHash(bytes memory data) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let originalDataLength := mload(data)\n            let dataSize := add(originalDataLength, DATA_OFFSET)\n\n            mstore(data, or(0x61000080600a3d393df300, shl(0x40, dataSize)))\n\n            hash := keccak256(add(data, 0x15), add(dataSize, 0xa))\n\n            // Restore original length of the variable size `data`.\n            mstore(data, originalDataLength)\n        }\n    }\n\n    /// @dev Returns the address of the storage contract for `data`\n    /// deployed with `salt` by `deployer`.\n    function predictDeterministicAddress(bytes memory data, bytes32 salt, address deployer)\n        internal\n        pure\n        returns (address predicted)\n    {\n        bytes32 hash = initCodeHash(data);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, hash)\n            mstore(0x01, shl(96, deployer))\n            mstore(0x15, salt)\n            predicted := keccak256(0x00, 0x55)\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x35, 0)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         READ LOGIC                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns all the `data` from the bytecode of the storage contract at `pointer`.\n    function read(address pointer) internal view returns (bytes memory data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let pointerCodesize := extcodesize(pointer)\n            if iszero(pointerCodesize) {\n                // Store the function selector of `InvalidPointer()`.\n                mstore(0x00, 0x11052bb4)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            // Offset all indices by 1 to skip the STOP opcode.\n            let size := sub(pointerCodesize, DATA_OFFSET)\n\n            // Get the pointer to the free memory and allocate\n            // enough 32-byte words for the data and the length of the data,\n            // then copy the code to the allocated memory.\n            // Masking with 0xffe0 will suffice, since contract size is less than 16 bits.\n            data := mload(0x40)\n            mstore(0x40, add(data, and(add(size, 0x3f), 0xffe0)))\n            mstore(data, size)\n            mstore(add(add(data, 0x20), size), 0) // Zeroize the last slot.\n            extcodecopy(pointer, add(data, 0x20), DATA_OFFSET, size)\n        }\n    }\n\n    /// @dev Returns the `data` from the bytecode of the storage contract at `pointer`,\n    /// from the byte at `start`, to the end of the data stored.\n    function read(address pointer, uint256 start) internal view returns (bytes memory data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let pointerCodesize := extcodesize(pointer)\n            if iszero(pointerCodesize) {\n                // Store the function selector of `InvalidPointer()`.\n                mstore(0x00, 0x11052bb4)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // If `!(pointer.code.size > start)`, reverts.\n            // This also handles the case where `start + DATA_OFFSET` overflows.\n            if iszero(gt(pointerCodesize, start)) {\n                // Store the function selector of `ReadOutOfBounds()`.\n                mstore(0x00, 0x84eb0dd1)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            let size := sub(pointerCodesize, add(start, DATA_OFFSET))\n\n            // Get the pointer to the free memory and allocate\n            // enough 32-byte words for the data and the length of the data,\n            // then copy the code to the allocated memory.\n            // Masking with 0xffe0 will suffice, since contract size is less than 16 bits.\n            data := mload(0x40)\n            mstore(0x40, add(data, and(add(size, 0x3f), 0xffe0)))\n            mstore(data, size)\n            mstore(add(add(data, 0x20), size), 0) // Zeroize the last slot.\n            extcodecopy(pointer, add(data, 0x20), add(start, DATA_OFFSET), size)\n        }\n    }\n\n    /// @dev Returns the `data` from the bytecode of the storage contract at `pointer`,\n    /// from the byte at `start`, to the byte at `end` (exclusive) of the data stored.\n    function read(address pointer, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes memory data)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let pointerCodesize := extcodesize(pointer)\n            if iszero(pointerCodesize) {\n                // Store the function selector of `InvalidPointer()`.\n                mstore(0x00, 0x11052bb4)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // If `!(pointer.code.size > end) || (start > end)`, revert.\n            // This also handles the cases where\n            // `end + DATA_OFFSET` or `start + DATA_OFFSET` overflows.\n            if iszero(\n                and(\n                    gt(pointerCodesize, end), // Within bounds.\n                    iszero(gt(start, end)) // Valid range.\n                )\n            ) {\n                // Store the function selector of `ReadOutOfBounds()`.\n                mstore(0x00, 0x84eb0dd1)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n            let size := sub(end, start)\n\n            // Get the pointer to the free memory and allocate\n            // enough 32-byte words for the data and the length of the data,\n            // then copy the code to the allocated memory.\n            // Masking with 0xffe0 will suffice, since contract size is less than 16 bits.\n            data := mload(0x40)\n            mstore(0x40, add(data, and(add(size, 0x3f), 0xffe0)))\n            mstore(data, size)\n            mstore(add(add(data, 0x20), size), 0) // Zeroize the last slot.\n            extcodecopy(pointer, add(data, 0x20), add(start, DATA_OFFSET), size)\n        }\n    }\n}\n"

    },

    "contracts/lib/Strings.sol": {

      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}"

    },

    "contracts/TeddiesOnVacationRenderer.sol": {

      "content": "//  _____         _     _ _                                                _   _             \n// /__   \\___  __| | __| (_) ___  ___     ___  _ __    /\\   /\\__ _  ___ __ _| |_(_) ___  _ __  \n//   / /\\/ _ \\/ _` |/ _` | |/ _ \\/ __|   / _ \\| '_ \\   \\ \\ / / _` |/ __/ _` | __| |/ _ \\| '_ \\ \n//  / / |  __/ (_| | (_| | |  __/\\__ \\  | (_) | | | |   \\ V / (_| | (_| (_| | |_| | (_) | | | |\n//  \\/   \\___|\\__,_|\\__,_|_|\\___||___/   \\___/|_| |_|    \\_/ \\__,_|\\___\\__,_|\\__|_|\\___/|_| |_|\n// // // // // // // //                             =########             \n// // // // // // // //       :********.   :**********#######**.          \n// // // // // // // //     -+*********+++++*************====##.          \n// // // // // // // //   -+*#*****====******************++--##.          \n// // // // // // // //   +##****==--++********************++--           \n// // // // // // // //   +##****--++************************             \n// // // // // // // //   -=+##**==**************************--           \n// // // // // // // //     -++##***************##*******##****.          \n// // // // // // // //       :+****************%%*******%%****.          \n// // // // // // // //         .##*************##=-----=##****.          \n// // // // // // // //         .##*************-------======**.          \n// // // // // // // //         .##***********--------*%%%%%%--           \n// // // // // // // //         .##***********----------=%#----           \n// // // // // // // //            ##***********---------=---             \n// // // // // // // //            ..*#**********************             \n// // // // // // // //              *######**************+..             \n// // // // // // // //            ==*##########***********++             \n// // // // // // // //          --****###########*********##====.        \n// // // // // // // //       .--********#########***********####+-:      \n// // // // // // // //     .:=********#########***************####+-:    \n// // // // // // // //     =**********#######*****************######*::  \n// // // // // // // //   ..=**********#######*******************#######  \n// // // // // // // //   +**********#######*********************#######  \n// // // // // // // //   +**********#######*********************#########\n// // // // // // // // ***********#########*********************#########\n/**\n * @title TeddiesOnVacationRenderer\n * @author numo <@numo_0> <info@numo.art>\n */\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./core/ToVInfos.sol\";\nimport \"./lib/DynamicBuffer.sol\";\nimport \"./lib/Base64.sol\";\nimport \"./lib/SSTORE2.sol\";\nimport \"./lib/Strings.sol\";\n\ncontract TeddiesOnVacationRenderer is Ownable, ReentrancyGuard {\n    using DynamicBuffer for bytes;\n\n    error InvalidSeason();\n\n    struct TraitDTO {\n        string name;\n        string mimetype;\n        bytes data;\n        bool hide;\n        bool useExistingData;\n        uint existingDataIndex;\n    }\n\n    struct Trait {\n        string name;\n        string mimetype;\n        bool hide;\n    }\n\n    struct OneOfOne { \n        uint256 tokenId;\n        uint256 dna;\n    }\n\n    bool private shouldWrapSVG = true;\n    string private backgroundColor = \"transparent\";\n    string private placeholderImage = \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiB2aWV3Qm94PSIwIDAgMTIwMCAxMjAwIiB2ZXJzaW9uPSIxLjIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGltYWdlIHdpZHRoPSIxMjAwIiBoZWlnaHQ9IjEyMDAiIGhyZWY9ImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1USXdNQ0lnYUdWcFoyaDBQU0l4TWpBd0lpQjJhV1YzUW05NFBTSXdJREFnTVRJd01DQXhNakF3SWlCMlpYSnphVzl1UFNJeExqSWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SWdjM1I1YkdVOUltSmhZMnRuY205MWJtUXRZMjlzYjNJNmRISmhibk53WVhKbGJuUTdZbUZqYTJkeWIzVnVaQzFwYldGblpUcDFjbXdvWkdGMFlUcHBiV0ZuWlM5d2JtYzdZbUZ6WlRZMExHbFdRazlTZHpCTFIyZHZRVUZCUVU1VFZXaEZWV2RCUVVGRFFVRkJRVUZuUTBGWlFVRkJRbnBsYm5Jd1FVRkJRVUZZVGxOU01FbEJjbk0wWXpaUlFVRkNVRlpLVWtWR1ZWZEpWMlJzTURGMlNFVlZVV2h3SzNGSWRTdDFOMWxxUldwdFRWUktlVWhvVVVWRWFVTjFTVk5KV2tOR1JrOVlRMUFyVlVWVFFXZHBTV05uYUVWeU9FRndTa0ZSWmpZeGFuZzBOR3BtTW5neWNEWnpOR1JOTDNNNU9YQlJNRzFxWVRka05UWXpNM0Z5Y1hKMFNGZHNPVGcxYlZONmQzbFBiVzFUTkhablUzQmhWRGhxZDBGcmRIVkVUVUp6Y1hBNVVrdDVORVZHTUVaRlMwbHZRV3QxUWtaa1dIaGtRVVJrVEVKR1ZYZDNUWGQyU2taT1RVRjBabXhLVmxOV1pVaHBSVnBCVEhnMlNtcEhObXR3VGtscE0wMDBkMjlyUWtoRVJFTkJVbnBXUVhoVVFWaE9jME53Um1sa1JVcFljbkZOY1hGRGFHaGlXbFkwT0VKd1JWVkNSVEJHUldkc0wxTkRVa1JCZW1kc2RFcHJXWFpSVDFoMVVIVTVVMUJNVXpKUFMwUkNSVkZGV1c5UmEzTlRXbWhQWTNoRFIwWjFUSEpOVlZKd1RtZG9SbEZJUVdONVRYVk1LMUJ4YlV4MU5FazJORFF3WkhaalJFNXJObVJ2ZDJkVmNIbDZaVUZoUVhGeFMzRkNRbFl3TVdsdkx6a3JXRXMyZEdoVWIwTTJSRzV3TjJVMlowZEVSVkI0YkVGTVVEbGFSRGxXVTJ4S1FrTnlkMGx4UTFOQlZVOW5aa3hXVUVOSmNVa3djbmt4YW5GeFFUVkZORmxLUWtsQlRYZDZiemRNV1ZKRVdXYzNTV3BETTNSdllWb3daRE5hZUZaVVFraFVkRFpuZVRWa2R6aDNiMmhwU1ZoU1dYVkJhVVpNZFRkNVQzRmtVa1ZYU1ZWQ1YxcGhaMlJDTVVsUmVrNUtkbU56Tm1KT09XUjRUVEZEYUhOWU5sUmljblZPVWxWek1VWlZTbGRSUzFWMkszZEROR2wwV1VVMWRTOWpVbXhTVVRGaFVrRkdaakZCUTNGeVF6QTJRelJLT1cxTVJVUkJWbkJMZVRCR2FsRnZVbTAxYkU0MGIydDFaVkU0U25kVlIzZFNablV6YTJ0d1JXOVZhVWxLUkVkQmVXNVpLeXR1ZUd0Q2IzSkhkemgzVGpoM1RYSmpRa3hGYm1rd01VWkZjWFZEYlVZMVFUSnRhVzVCVVM5UGVsQmFNMU5tWWpsbFR6RjROWFJ2UTNKelpuWTRUSE1yZW1jNFVrNVhkblpyVTBwT1YwWnNkRVJhTWpBd1FrdG9VbkpPTkdoc1VrRnZiMDVDWTJoWFVXeFNhRkYzSzJGdWN5OVFhRFppUnpkUmR6RjNRV2M1Y25CSlEwdHNUMWhFYkhSaU9XTTNTMnRNUjJOdmFVZEVhMXBtYTJWbk9UTTJXbTkwUTJkaGNtUndlRFZZZVZkNFZqWXpTR3hsWkdSTU5qbFhlR1Y1YVU1Q1kxZzJPV0pJVGtoVlFtTlFVa3N5VnpOVmVuUnhUSEkwTXpWMmQybEZkWFptVUd0NlZrUTBhVUZ2TkdjMmVtWldZbGRKZVc5SE1scEthR0pSVUd0SFUyaFZiVXBIV2sxQlVWRmhRbGR4YnpRcmFFcFNOM1F4ZUdab2NIWnJibVJJUVVaRFZWTkJVMWd6WkZVd1JYVlFUSEF2VlhWRVZqTlBSRGd4ZG1ZdlZrUTNhM0JHTXk5NmFGQkJXVGhrVW1kQlRHUXlOWG8xWkRRNVJHNDNLMkpUWWpSUmNsQkNNbUp6SzNkaGRVdzRlSGxtYm0xalFVRldUM1ZtU0dsUU1rOTBhSE5UVTFkalVYaHlkM05JWlhRM1ZraEhNVkJDYVRCaFRDdFpWa1pPUWxReFl6TTFNazkxWW1vMVRWVXZia3czWXpWSGVIcGhlVXhIVkVGTVZFeG9UbFo2YXlzMmEySnVWMUZxTTJaTFlUTm1UR1ZpY0dsSVlXWTFTMHgyUXpOTlVXYzJjSGRaVDJjNWVsVmlZbk5zVjJ0WFQxbGlaMUpOWVRsWE9UazFSak0zVGtWMlltUlVWM0IxVkhCT2FrZERVek5uVUROMmRFWkxTRGRXVDJGaVVVczFZVk5pT0hWNGJXMUViVXhJT1hkdGJISkdaa0V4YlZwcGIybGhSMlF4TW0wNE5VOXRPRGN5UkhBeWRHSlVkM1pqYms1MVVGQjROa2x0UkZaSVlqTlBWMWdyZFZORFVsaElNelpHZUZscFdrUm1iRXMzTUZOTk5uRjZiemRpTTNFek9XNWpZMGhtVDA1eVl6Um1ZbTFLZUZKTFVHTlRjVXBrTm1SMmMxWnFWMVFyZURGcFlqRjFTSHA1YlhsTk1ITlFNek5uYVd4RWFHZE1iV3BsUzNGWU5uWnZWVEF3VEVWS2JHSnhkRTB4Ynpka1JrZEpjRFpFVFdwUE9HcENUMnBPTUVKaGJqbDRNMVpoVmpVNEx6RXdRM2h4TlVONWVtTjJZMDlpV0RVdlQwcEVRbUZJTkZCSWMxcGplR3BqZGtrcll6VlBkWEJDYTFseWNUaG9SRkV2TDNOblltRTJkRlJNZVZNNVJucHpWRFZhT1VadlRFdHlSSG8wWmtJNFpYaFhTMnhvUzA4M2NHcDRhWGhOZFVwMVYwUlVUV3BtVHk4dmNEZHZLMHhLTWk5UFVWQTBhRkozZWpka2JHeGhWbkpYU1hsS1VrZGhURWRrTVc1TU1tTTJjalEzY21rNWNubzNaVGxRS3pkS1NFazVlVFJVY21rcldFcE9VVk5RWkRScGVFVjJTVGt6TWxoeWNFTk5OM1l6Y1hkT2J6QjFSVEIwZG1KR1JuVmhaV2ROZFVsNFZtZ3ZSeTlUTDBSak1rbHlkemhTVmxoNGVqa3dTMjR2T1ZoamNrb3ZjV2RUTWlzM2FrRTNVRTFMT1M5M01UTnJZbE5ZZEZOd1RsbG1LMWxqWjFGalNtNHdZblJuT0hWQ1pqWXZRMEUyUVZaNEwwVXZkMG9yZEVOTlMyeERjRko2VVVGQlFVRkNTbEpWTlVWeWEwcG5aMmM5UFNrN1ltRmphMmR5YjNWdVpDMXlaWEJsWVhRNmJtOHRjbVZ3WldGME8ySmhZMnRuY205MWJtUXRjMmw2WlRwamIyNTBZV2x1TzJKaFkydG5jbTkxYm1RdGNHOXphWFJwYjI0NlkyVnVkR1Z5TzJsdFlXZGxMWEpsYm1SbGNtbHVaem90ZDJWaWEybDBMVzl3ZEdsdGFYcGxMV052Ym5SeVlYTjBPeTF0Y3kxcGJuUmxjbkJ2YkdGMGFXOXVMVzF2WkdVNmJtVmhjbVZ6ZEMxdVpXbG5hR0p2Y2p0cGJXRm5aUzF5Wlc1a1pYSnBibWM2TFcxdmVpMWpjbWx6Y0MxbFpHZGxjenRwYldGblpTMXlaVzVrWlhKcGJtYzZjR2w0Wld4aGRHVmtPeUkrUEM5emRtYysiPjwvaW1hZ2U+PC9zdmc+\";\n    string[] private layerNames =   [   \n                                        unicode\"1/1\", \n                                        unicode\"Handheld\", \n                                        unicode\"Head\", \n                                        unicode\"Head\", // mask & helmet\n                                        unicode\"Eyes\", \n                                        unicode\"Snout\", \n                                        unicode\"Body\", \n                                        unicode\"Type\", \n                                        unicode\"Background\"\n                                    ];\n\n    bytes32 public SEASON1_ONE_OF_ONE_IDS_HASH = 0x1980099be486d3bcdb0216af2c717f8dae73c16812d94dc1ac4c1972c9f78195;\n    bytes32 public SEASON2_ONE_OF_ONE_IDS_HASH = 0x82998fb94fcc4699e39f14bcb230450ef96ee7f522d72bfb40f6dc283b545417;\n    bytes32 public SEASON3_ONE_OF_ONE_IDS_HASH = 0xfdce05748e2384f41f03ee9eba3b81b6a7af2786dabb77f01597948f00cb82f7;\n\n    uint256 public constant NUM_LAYERS = 9;\n    uint256 public constant NUM_SEASONS = 4;\n    uint16[][NUM_LAYERS] WEIGHTS;\n    uint16[NUM_SEASONS][NUM_LAYERS] WEIGHTS_START_INDEX;\n\n    // After contract sealed, no changes are possible anymore\n    bool public isContractSealed;\n    bool[NUM_SEASONS] public isRevealed;\n\n    // on-chain data for the art\n    mapping(uint => address[]) private _traitDataPointers;\n    // on-chain data for the metadata\n    mapping(uint => mapping(uint => Trait)) private _traitDetails;\n    // information about the one of ones for each season\n    mapping(uint => OneOfOne[]) public oneOfOnes;\n\n    constructor() {\n        // Start index for each season per trait\n        WEIGHTS_START_INDEX[0] = [0, 4, 7, 10];\n        WEIGHTS_START_INDEX[1] = [23, 35, 45, 23];\n        WEIGHTS_START_INDEX[2] = [36, 43, 51, 36];\n        WEIGHTS_START_INDEX[3] = [2, 23, 41, 1];\n        WEIGHTS_START_INDEX[4] = [23, 28, 33, 23];\n        WEIGHTS_START_INDEX[5] = [25, 28, 30, 25];\n        WEIGHTS_START_INDEX[6] = [20, 33, 43, 20];\n        WEIGHTS_START_INDEX[7] = [7, 7, 7, 7];\n        WEIGHTS_START_INDEX[8] = [5, 5, 5, 5];\n    \n        \n        WEIGHTS[0] = [/* 1 */ 2500, 2500, 2500, 2500,\n                      /* 2 */ 3334, 3333, 3333,\n                      /* 3 */ 3334, 3333, 3333];\n        WEIGHTS[1] = [/* Basic */   170, 175, 175, 175, 175, 175, 175, 175, 175, 175, 175, 175, 175, 175, 175, 175, 175, 175, 175, 175, 125, 125, 175,\n                      /* 1 */       100, 80, 80, 100, 100, 100, 80, 80, 80, 100, 80, 100,\n                      /* 2 */       118, 90, 110, 90, 120, 112, 120, 80, 120, 120,\n                      /* 3 */       77, 77, 77, 77, 77, 77, 77, 78, 77, 77, 77, 77, 77, 78,\n                      /* None */    5000];\n        WEIGHTS[2] = [/* Basic */   277, 277, 277, 277, 277, 227, 227, 227, 227, 227, 177, 277, 277, 227, 187, 177, 177, 277, 137, 137, 137, 137, 137, 227, 177, 277, 277, 277, 1195, 177, 227, 227, 127, 227, 177, 177,\n                      /* 1 */       150, 150, 200, 200, 200, 150, 150,\n                      /* 2 */       150, 150, 150, 150, 150, 150, 150, 150,\n                      /* 3 */       160, 160, 130, 130, 115, 115, 130, 130, 130];\n        WEIGHTS[3] = [/* Basic */   63, 13,\n                      /* 1 */       20, 6, 20, 6, 20, 20, 20, 6, 20, 6, 20, 20, 6, 20, 20, 7, 20, 20, 7, 20, 20,\n                      /* 2 */       23, 10, 15, 9, 20, 25, 25, 9, 25, 24, 10, 15, 20, 10, 24, 25, 10, 25,\n                      /* 3 */       47, 14, 47, 47, 14, 47, 14, 47, 47,\n                      /* None */    9600];\n        WEIGHTS[4] = [/* Basic */   436, 386, 636, 432, 386, 386, 386, 386, 386, 436, 386, 386, 386, 336, 386, 386, 386, 386, 436, 280, 330, 380, 380,\n                      /* 1 */       200, 200, 150, 200, 150,\n                      /* 2 */       180, 180, 180, 180, 180,\n                      /* 3 */       150, 150, 150, 150, 150, 150];\n        WEIGHTS[5] = [/* Basic */   594, 444, 434, 194, 434, 394, 424, 444, 394, 444, 284, 294, 294, 284, 444, 344, 434, 444, 384, 384, 394, 394, 284, 244, 194,\n                      /* 1 */       250, 250, 200,\n                      /* 2 */       350, 350,\n                      /* 3 */       100, 100, 100, 100, 100, 100, 100];\n        WEIGHTS[6] = [/* Basic */   460, 305, 410, 460, 365, 365, 415, 415, 415, 660, 415, 395, 285, 285, 285, 285, 285, 415, 415, 415,\n                      /* 1 */       150, 200, 200, 150, 200, 200, 150, 150, 150, 200, 150, 200, 150,\n                      /* 2 */       225, 225, 225, 225, 225, 155, 225, 260, 260, 225,\n                      /* 3 */       187, 190, 187, 187, 187, 187, 187, 187, 190, 187, 187, 187];\n        WEIGHTS[7] = [/* Basic */   5000, 900, 500, 900, 900, 900, 900,\n                      /* Special */ 10000];\n        WEIGHTS[8] = [/* Basic */ 1625, 3500, 1625, 1625, 1625];\n    }\n\n    /**\n     * Checks if the contract is sealed.\n     */\n    modifier whenUnsealed() {\n        require(!isContractSealed, \"Contract is sealed\");\n        _;\n    }\n\n    /**\n     * Function to retrieve the metadata & art for a given token.\n     * @param tokenId The tokenID to get the data for\n     * @param tovData Addition information for retrieving the correct data\n     * @param contractData The contract information of the calling contract\n     */\n    function tokenURI(uint256 tokenId, ToVInfos.ToV memory tovData, ToVInfos.ContractData memory contractData) \n        public \n        view \n        returns (string memory) \n    {\n        bool oneOfOne;\n        uint256 tovDna;\n\n        (oneOfOne, tovDna) = isOneOfOneTokenId(tokenId, tovData.season);\n\n        uint16[NUM_LAYERS] memory dna;\n        if (oneOfOne) {\n            dna = getRarityWeights(tovDna);\n        } else {            \n            dna = getRarityWeights(tovData.dna);\n            dna[0] = 0;\n        }\n\n        bytes memory jsonBytes = DynamicBuffer.allocate(1024 * 128);\n\n        jsonBytes.appendSafe(\n            abi.encodePacked(\n                '{\"name\":\"',\n                contractData.name,\n                \" #\",\n                Strings.toString(tokenId),\n                '\",\"description\":\"',\n                contractData.description,\n                '\",'\n            )\n        );\n\n        if (!isRevealed[tovData.season-1]) {\n            jsonBytes.appendSafe(\n                abi.encodePacked(\n                    '\"image\":\"',\n                    placeholderImage,\n                    '\"}'\n                )\n            );\n        } else {\n            string memory svgCode = \"\";\n            if (shouldWrapSVG) {\n                string memory svgString = getSVG(dna, tovData.season);\n\n                svgCode = string(\n                    abi.encodePacked(\n                        \"data:image/svg+xml;base64,\",\n                        Base64.encode(\n                            abi.encodePacked(\n                                '<svg width=\"100%\" height=\"100%\" viewBox=\"0 0 1200 1200\" version=\"1.2\" xmlns=\"http://www.w3.org/2000/svg\"><image width=\"1200\" height=\"1200\" href=\"',\n                                svgString,\n                                '\"></image></svg>'\n                            )\n                        )\n                    )\n                );\n            } else {\n                svgCode = getSVG(dna, tovData.season);\n            }\n\n            jsonBytes.appendSafe(\n                abi.encodePacked(\n                    '\"image_data\":\"',\n                    svgCode,\n                    '\",'\n                )\n            );\n\n            jsonBytes.appendSafe(\n                abi.encodePacked(\n                    '\"attributes\":',\n                    getMetaData(dna, tovData.season),\n                    \"}\"\n                )\n            );\n        }\n\n        return string(\n            abi.encodePacked(\n                \"data:application/json;base64,\",\n                Base64.encode(jsonBytes)\n            )\n        );\n    }\n\n    /**\n     * Gets the SVG image of a certain DNA.\n     * @param _dna The DNA used to retrieve the art of it\n     * @param _season The current season of the DNA\n     */\n    function getSVG(uint16[NUM_LAYERS] memory _dna, uint256 _season) public view returns (string memory) {\n        uint256 traitIndex;\n        bool oneOfOne = hasOneOfOne(_dna[0]);\n        bool handheld = hasHandHeld(_dna[1]);\n        bool mask = hasMask(_dna[3]);\n        bool eyesOnTop;\n\n        bytes memory svgBytes = DynamicBuffer.allocate(1024 * 128);\n\n        svgBytes.appendSafe('<svg width=\"1200\" height=\"1200\" viewBox=\"0 0 1200 1200\" version=\"1.2\" xmlns=\"http://www.w3.org/2000/svg\" style=\"background-color:');\n        svgBytes.appendSafe(\n            abi.encodePacked(\n                backgroundColor,\n                \";background-image:url(\"\n            )\n        );\n\n        // Put eyes on top if necessary/defined\n        (traitIndex, ) = getTraitIndex(_dna[4], 4, _season);\n\n        if (!oneOfOne && !mask && ((traitIndex > 18 && traitIndex < 23) \n        || (_season == 1 && traitIndex == 27 ))) {\n            svgBytes.appendSafe(\n                abi.encodePacked(\n                    \"data:\",\n                    _traitDetails[4][traitIndex].mimetype,\n                    \";base64,\",\n                    Base64.encode(SSTORE2.read(_traitDataPointers[4][traitIndex])),\n                    \"),url(\"\n                )\n            );\n            eyesOnTop = true;\n        }\n\n        uint16[][NUM_LAYERS] memory weights = WEIGHTS;\n        uint256 weightsLength;\n        uint256 layerIndexFactor = oneOfOne ? 0 : NUM_LAYERS - 1;\n\n        if (!oneOfOne) {\n            for (uint8 i = 1; i < NUM_LAYERS - 1; i++) {\n                weightsLength = weights[i].length;\n                    \n                (traitIndex, ) = getTraitIndex(_dna[i], i, _season);            \n                \n                // Add layer only for a valid index\n                if (traitIndex < weightsLength) {\n                    // Make sure there is no mask, eyes or snout when DNA has mask trait\n                    // Skip eyes trait if eyes is on top because already appended above\n                    if (((i == 2 || i == 4 || i == 5) && !mask) || (i < 4 || (i > 5 && i < 8))) {\n                        if (!handheld && i == 1) continue;\n                        if (mask && i == 2) continue;\n                        if (!mask && i == 3) continue;\n                        if (eyesOnTop && i == 4) continue;\n                        svgBytes.appendSafe(\n                            abi.encodePacked(\n                                \"data:\",\n                                _traitDetails[i][traitIndex].mimetype,\n                                \";base64,\",\n                                Base64.encode(SSTORE2.read(_traitDataPointers[i][traitIndex])),\n                                \"),url(\"\n                            )\n                        );\n                    }\n                }\n            }\n        }\n\n        (traitIndex, ) = getTraitIndex(_dna[layerIndexFactor], uint8(layerIndexFactor), _season);\n\n        svgBytes.appendSafe(\n            abi.encodePacked(\n                \"data:\",\n                _traitDetails[layerIndexFactor][traitIndex].mimetype,\n                \";base64,\",\n                Base64.encode(SSTORE2.read(_traitDataPointers[layerIndexFactor][traitIndex])),\n                ');background-repeat:no-repeat;background-size:contain;background-position:center;image-rendering:-webkit-optimize-contrast;-ms-interpolation-mode:nearest-neighbor;image-rendering:-moz-crisp-edges;image-rendering:pixelated;\"></svg>'\n            )\n        );\n\n        return string(\n            abi.encodePacked(\n                \"data:image/svg+xml;base64,\",\n                Base64.encode(svgBytes)\n            )\n        );\n    }\n\n    /**\n     * Gets the metadata of a certain tokenId.\n     * @param _tokenId The DNA used to retrieve the metadata of it\n     * @param _tovData Data of the ToV\n     */\n    function getMetaDataFromTokenID(uint256 _tokenId, ToVInfos.ToV memory _tovData) public view returns (string memory) {\n        if (isRevealed[_tovData.season-1]) {\n            bool oneOfOne;\n            uint256 tovDna;\n            (oneOfOne, tovDna) = isOneOfOneTokenId(_tokenId, _tovData.season);\n\n            uint16[NUM_LAYERS] memory dna;\n            if (oneOfOne) {\n                dna = getRarityWeights(tovDna);\n            } else {            \n                dna = getRarityWeights(_tovData.dna);\n                dna[0] = 0;\n            }\n            return getMetaData(dna, _tovData.season);\n        }\n        return \"\";\n    }\n\n    /**\n     * Gets the metadata of a certain DNA.\n     * @param _dna The DNA used to retrieve the metadata of it\n     * @param _season The current season of the DNA\n     */\n    function getMetaData(uint16[NUM_LAYERS] memory _dna, uint256 _season) public view returns (string memory) {\n        bytes memory metadataBytes = DynamicBuffer.allocate(1024 * 128);\n        uint256 traitIndex;\n        uint64 seasonTraitCount;\n        bool afterFirstTrait;\n        bool oneOfOne = hasOneOfOne(_dna[0]);\n        bool handheld = hasHandHeld(_dna[1]);\n        bool mask = hasMask(_dna[3]);\n        bool isSeasonTrait;\n        uint8 layerIndexFactor = oneOfOne ? 0 : 1;\n        \n        uint16[][NUM_LAYERS] memory weights = WEIGHTS;\n        uint256 weightsLength;\n\n        metadataBytes.appendSafe(\"[\");\n        \n        for (uint8 i = layerIndexFactor; i < NUM_LAYERS; i++) {\n            weightsLength = weights[i].length;\n\n            (traitIndex, isSeasonTrait) = getTraitIndex(_dna[i], i, _season);\n\n            // Add layer only for a valid index\n            if (traitIndex < weightsLength) {   \n                // Make sure there is no mask, eyes or snout when DNA has mask trait\n                if (((oneOfOne && i == 0) || (!oneOfOne && i > 0)) && (_traitDetails[i][traitIndex].hide == false) &&\n                (((i == 2 || i == 4 || i == 5) && !mask) || (i < 4 || (i > 5 && i < 9)))) {\n                    if (!handheld && i == 1) continue;\n                    if (mask && i == 2) continue;\n                    if (!mask && i == 3) continue;\n                    if (afterFirstTrait) {\n                        metadataBytes.appendSafe(\",\");\n                    }\n\n                    if (isSeasonTrait) {\n                        ++seasonTraitCount;\n                    }\n\n                    metadataBytes.appendSafe(\n                        abi.encodePacked(\n                            '{\"trait_type\":\"',\n                            layerNames[i],\n                            '\",\"value\":\"',\n                            _traitDetails[i][traitIndex].name,\n                            '\"}'\n                        )\n                    );\n                    if (afterFirstTrait == false) {\n                        afterFirstTrait = true;\n                    }\n                    isSeasonTrait = false;\n                }\n\n                if (i == NUM_LAYERS - 1) {\n                    if (!oneOfOne) {\n                        metadataBytes.appendSafe(\n                            abi.encodePacked(\n                                ',{\"trait_type\":\"',\n                                \"Season Traits\",\n                                '\",\"value\":\"',\n                                Strings.toString(seasonTraitCount),\n                                '\"}'\n                            )\n                        );\n                    }\n\n                    metadataBytes.appendSafe(\n                        abi.encodePacked(\n                            ',{\"trait_type\":\"',\n                            \"Season\",\n                            '\",\"value\":\"',\n                            Strings.toString(_season),\n                            '\"}'\n                        )\n                    );\n                  \n                    metadataBytes.appendSafe(\"]\");\n                }\n            }\n        }       \n\n        return string(metadataBytes);\n    }\n\n    /**\n     * Checks if a certain tokenID is a one of one and returns the DNA of it.\n     * @param _tokenId  The tokenID to check\n     * @param _season The season of the one of one\n     * @return bool Returns if an one of one was found\n     * @return uint256 The DNA of the one of one \n     */\n    function isOneOfOneTokenId(uint256 _tokenId, uint256 _season) public view returns (bool, uint256) {\n        OneOfOne[] memory seasonOneOfOnes = oneOfOnes[_season];\n        for (uint256 i = 0; i < seasonOneOfOnes.length; i++) {\n            if (seasonOneOfOnes[i].tokenId == _tokenId) {\n                return (true, seasonOneOfOnes[i].dna);\n            }\n        }\n        return (false, 0);\n    }\n\n    /**\n     * Gets the rarity weights of a certain DNA.\n     * @param _dna DNA to get the weights.\n     */\n    function getRarityWeights(uint256 _dna) internal pure returns (uint16[NUM_LAYERS] memory rarityWeights) {\n        for (uint256 i = 0; i < rarityWeights.length; i++) {\n            rarityWeights[i] = uint16(_dna % 10000);\n            _dna >>= 14;\n        }\n        return rarityWeights;\n    }\n\n    /**\n     * Retrieves the trait index for a certain trait weight and season.\n     * @param _traitWeight The trait weight to determine the trait index for\n     * @param _index Determines which trait type\n     * @param _season The season of the trait index\n     * @return uint256 returns the trait index\n     * @return bool returns if the trait is a season trait\n     */\n    function getTraitIndex(uint16 _traitWeight, uint8 _index, uint256 _season) public view returns (uint256, bool) {\n        uint16 i;\n        uint16 lowerBound;\n        uint16 percentage;\n        uint16[] memory currentWeights = WEIGHTS[_index];\n        uint16[NUM_SEASONS] memory startIndices = WEIGHTS_START_INDEX[_index];\n        uint256 maxIndex;\n        bool seasonTrait;\n\n        if (_season == NUM_SEASONS) {\n            maxIndex = currentWeights.length;\n           \n            // Traits only from the last season except for Background\n            if (_index == 8) {\n                i = 0;\n            } else {\n                i = startIndices[_season-1];\n            }\n\n            _traitWeight = uint16(multiplyByFactor(_traitWeight, _index));\n        } else {\n            // take start index of the next season as max of the current season.\n            if (_season == 3) {\n                maxIndex = currentWeights.length;\n            } else {\n                maxIndex = startIndices[_season];\n            }\n            // Traits only from the certain season for one on ones\n            if (_index == 0) {\n                i = startIndices[_season-1];\n            } else {\n                i = 0;                \n            }\n        }\n\n        for (; i < maxIndex; i++) {\n            percentage = currentWeights[i];  \n    \n            if (_traitWeight >= lowerBound && _traitWeight < lowerBound + percentage) {\n                if (i >= startIndices[_season-1] && i < maxIndex && _index != 7 && _index != 8) {\n                    seasonTrait = true;\n                }\n\n                return (i, seasonTrait);\n            }\n            lowerBound += percentage;\n            \n            // jump to the correct season index\n            // startIndices[0] - 1 stands for the base trait max index\n            // Don't jump for OneOfOnes, Background and Type traits\n            if((_index != 0 && _index != 7 && _index != 8) && i == (startIndices[0] - 1)) {\n                i = startIndices[_season-1] - 1;\n            }\n        }\n        \n        // If not found, return index higher than available layers. Will get filtered out.\n        return (currentWeights.length, false);\n    }\n\n    function hasMask(uint256 _traitWeight) public view returns (bool) {\n        return _traitWeight < (10000 - WEIGHTS[3][50]);\n    }\n\n    function hasHandHeld(uint256 _traitWeight) public view returns (bool) {\n        return _traitWeight < (10000 - WEIGHTS[1][59]);\n    }\n    \n    function hasOneOfOne(uint256 _traitWeight) public pure returns (bool) {\n        return _traitWeight > 0;\n    }\n\n    /**\n     * A factor to keep the trait weight in correct range for the last season.\n     * @param _value The value which should be transformed\n     * @param _index Determines the trait type\n     */\n    function multiplyByFactor(uint256 _value, uint256 _index) public pure returns (uint) {\n        if (_index == 1) {\n            return (_value * 648) / 1000;\n        } else if (_index == 2) {\n            return (_value * 36) / 100;\n        } else if (_index == 3) {\n            return (_value * 24) / 100;\n        } else if (_index == 4) {\n            return (_value * 27) / 100;\n        } else if (_index == 5) {\n            return (_value * 21) / 100;\n        } else if (_index == 6) {\n            return (_value * 675) / 1000;\n        } else {\n            return _value;\n        }\n    }\n\n    // =========================================================================\n    //                             Owner Functions\n    // =========================================================================\n\n    /**\n     * Function to add the different metadata and art for the layers (trait types) on-chain\n     * @param layerIndex Describes which trait type\n     * @param traits Array of the metadata and art of the layer\n     */\n    function addLayer(uint layerIndex, TraitDTO[] calldata traits) public onlyOwner whenUnsealed {\n        require(WEIGHTS[layerIndex].length == traits.length, \"Traits length is incorrect\");\n        address[] memory dataPointers = new address[](traits.length);\n        for (uint i = 0; i < traits.length; i++) {\n            if (traits[i].useExistingData) {\n                dataPointers[i] = dataPointers[traits[i].existingDataIndex];\n            } else {\n                dataPointers[i] = SSTORE2.write(traits[i].data);\n            }\n            _traitDetails[layerIndex][i] = Trait(traits[i].name, traits[i].mimetype, traits[i].hide);\n        }\n        _traitDataPointers[layerIndex] = dataPointers;\n        return;\n    }\n\n    /**\n     * Function to add/Update the metadata and art of one trait on-chain.\n     * @param layerIndex Describes which trait type\n     * @param traitIndex The certain trait which should be updated\n     * @param trait Metadata and art of the new/updated trait\n     */\n    function addTrait(uint layerIndex, uint traitIndex, TraitDTO calldata trait) public onlyOwner whenUnsealed {\n        _traitDetails[layerIndex][traitIndex] = Trait(trait.name, trait.mimetype, trait.hide);\n        address[] memory dataPointers = _traitDataPointers[layerIndex];\n        if (trait.useExistingData) {\n            dataPointers[traitIndex] = dataPointers[trait.existingDataIndex];\n        } else {\n            dataPointers[traitIndex] = SSTORE2.write(trait.data);\n        }\n        _traitDataPointers[layerIndex] = dataPointers;\n        return;\n    }\n\n    /**\n     * Set the unique hash for the encrypted one of ones. \n     * @param _hash Holds the hash for the one of ones\n     * @param _season One of ones for a certain season\n     */\n    function setOneOfOneHash(bytes32 _hash, uint256 _season) public onlyOwner whenUnsealed {\n        if (_season == 1) {\n            SEASON1_ONE_OF_ONE_IDS_HASH = _hash;\n        } else if (_season == 2) {\n            SEASON2_ONE_OF_ONE_IDS_HASH = _hash;\n        } else {\n            SEASON3_ONE_OF_ONE_IDS_HASH = _hash;\n        }\n    }\n\n    /**\n     * Set the one of one data.\n     * @param _oneOfOnes Holds the data for the one of ones\n     * @param _season One of ones for a certain season\n     */\n    function commitOneOfOnes(OneOfOne[] calldata _oneOfOnes, uint256 _season) public onlyOwner whenUnsealed {\n        bytes32 hashedOneOfOnes = keccak256(abi.encode(_oneOfOnes));\n        if (SEASON1_ONE_OF_ONE_IDS_HASH == hashedOneOfOnes ||\n            SEASON2_ONE_OF_ONE_IDS_HASH == hashedOneOfOnes ||\n            SEASON3_ONE_OF_ONE_IDS_HASH == hashedOneOfOnes ) {\n            oneOfOnes[_season] =  _oneOfOnes;\n        }\n    }\n    \n    /**\n     * Reveals or unreveals a certain season.\n     * @param _season The season which should be revealed\n     * @param _reveal Value if reveal or unreveal\n     */\n    function setRevealSeason(uint256 _season, bool _reveal) public onlyOwner {\n        if (_season <= 0 || _season > NUM_SEASONS) revert InvalidSeason();\n        isRevealed[_season-1] = _reveal;\n    }\n\n    /**\n     * Seals the contract, so no changes are possible anymore.\n     */\n    function sealRendererContract() external whenUnsealed onlyOwner {\n        isContractSealed = true;\n    }\n    function toggleWrapSVG() external onlyOwner {\n        shouldWrapSVG = !shouldWrapSVG;\n    }\n    function setBackgroundColor(string calldata color) external onlyOwner {\n        backgroundColor = color;\n    }\n    function setPlaceholderImage(string calldata placeholder) external onlyOwner {\n        placeholderImage = placeholder;\n    }    \n}"

    }

  },

  "settings": {

    "optimizer": {

      "enabled": true,

      "runs": 1000

    },

    "viaIR": true,

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "metadata": {

      "useLiteralContent": true

    },

    "libraries": {}

  }

}}