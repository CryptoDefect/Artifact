{{

  "language": "Solidity",

  "sources": {

    "contracts/Governor.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2023.\npragma solidity ^0.8.17;\n\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {IGovernor} from \"./interfaces/IGovernor.sol\";\nimport {ITimeLock} from \"./interfaces/ITimeLock.sol\";\n\n/// @title Governor\n/// @notice Extends Uniswap's timelock contract with batch queueing/execution and reworked permissions model where,\n///         instead of a single admin to perform all actions, there are multiple queue admins, a single veto admin,\n///         and permissionless execution (which can optionally be restricted to non-contract accounts to prevent\n///         unintended execution of governance proposals inside protocol functions)\ncontract Governor is IGovernor {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @inheritdoc IGovernor\n    address public immutable override timeLock;\n\n    /// @dev Set of queue admins\n    EnumerableSet.AddressSet internal _queueAdminsSet;\n\n    /// @inheritdoc IGovernor\n    address public override vetoAdmin;\n\n    /// @inheritdoc IGovernor\n    bool public isExecutionByContractsAllowed;\n\n    /// @inheritdoc IGovernor\n    mapping(uint256 => BatchInfo) public override batchInfo;\n\n    /// @inheritdoc IGovernor\n    mapping(bytes32 => BatchedTxInfo) public override batchedTxInfo;\n\n    /// @dev Ensures that function can only be called by the timelock contract\n    modifier timeLockOnly() {\n        if (msg.sender != timeLock) revert CallerNotTimelockException();\n        _;\n    }\n\n    /// @dev Ensures that function can only be called by one of queue admins\n    modifier queueAdminOnly() {\n        if (!_queueAdminsSet.contains(msg.sender)) revert CallerNotQueueAdminException();\n        _;\n    }\n\n    /// @dev Ensures that function can only be called by the veto admin\n    modifier vetoAdminOnly() {\n        if (msg.sender != vetoAdmin) revert CallerNotVetoAdminException();\n        _;\n    }\n\n    /// @dev Ensures that function can't be called by contracts unless explicitly allowed\n    modifier allowedCallerTypeOnly() {\n        if (!isExecutionByContractsAllowed && msg.sender != tx.origin) revert CallerMustNotBeContractException();\n        _;\n    }\n\n    /// @notice Constructs a new governor contract\n    /// @param _timeLock Timelock contract address\n    /// @param _queueAdmin Address to add as the first queue admin, can't be `address(0)`\n    /// @param _vetoAdmin Address to set as the veto admin, can't be `address(0)`\n    /// @param _allowExecutionByContracts Whether to allow transaction/batch execution by contracts\n    constructor(address _timeLock, address _queueAdmin, address _vetoAdmin, bool _allowExecutionByContracts) {\n        timeLock = _timeLock;\n        _addQueueAdmin(_queueAdmin);\n        _updateVetoAdmin(_vetoAdmin);\n\n        if (_allowExecutionByContracts) {\n            isExecutionByContractsAllowed = true;\n            emit AllowExecutionByContracts();\n        } else {\n            emit ForbidExecutionByContracts();\n        }\n    }\n\n    /// @inheritdoc IGovernor\n    function queueAdmins() external view override returns (address[] memory) {\n        return _queueAdminsSet.values();\n    }\n\n    // ------- //\n    // ACTIONS //\n    // ------- //\n\n    /// @inheritdoc IGovernor\n    function queueTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) external override queueAdminOnly returns (bytes32 txHash) {\n        txHash = _getTxHash(target, value, signature, data, eta);\n        if (ITimeLock(timeLock).queuedTransactions(txHash)) revert TransactionAlreadyQueuedException();\n\n        BatchInfo memory info = batchInfo[block.number];\n        if (info.initiator != address(0)) {\n            if (msg.sender != info.initiator) revert CallerNotBatchInitiatorException();\n            if (eta != info.eta) revert ETAMistmatchException();\n\n            batchedTxInfo[txHash] = BatchedTxInfo({batchBlock: uint64(block.number), index: info.length});\n            batchInfo[block.number].length = info.length + 1;\n        }\n\n        ITimeLock(timeLock).queueTransaction(target, value, signature, data, eta);\n    }\n\n    /// @inheritdoc IGovernor\n    function startBatch(uint80 eta) external override queueAdminOnly {\n        if (batchInfo[block.number].initiator != address(0)) revert BatchAlreadyStartedException();\n        batchInfo[block.number] = BatchInfo({initiator: msg.sender, length: 0, eta: eta});\n        emit QueueBatch(msg.sender, block.number);\n    }\n\n    /// @inheritdoc IGovernor\n    function executeTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) external payable override allowedCallerTypeOnly returns (bytes memory) {\n        return _transactionAction(target, value, signature, data, eta, TxAction.Execute);\n    }\n\n    /// @inheritdoc IGovernor\n    function executeBatch(TxParams[] calldata txs) external payable override allowedCallerTypeOnly {\n        uint256 batchBlock = _batchAction(txs, TxAction.Execute);\n        emit ExecuteBatch(msg.sender, batchBlock);\n    }\n\n    /// @inheritdoc IGovernor\n    function cancelTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) external override vetoAdminOnly {\n        _transactionAction(target, value, signature, data, eta, TxAction.Cancel);\n    }\n\n    /// @inheritdoc IGovernor\n    function cancelBatch(TxParams[] calldata txs) external override vetoAdminOnly {\n        uint256 batchBlock = _batchAction(txs, TxAction.Cancel);\n        emit CancelBatch(msg.sender, batchBlock);\n    }\n\n    // ------------- //\n    // CONFIGURATION //\n    // ------------- //\n\n    /// @inheritdoc IGovernor\n    function addQueueAdmin(address admin) external override timeLockOnly {\n        _addQueueAdmin(admin);\n    }\n\n    /// @inheritdoc IGovernor\n    function removeQueueAdmin(address admin) external override timeLockOnly {\n        if (_queueAdminsSet.contains(admin)) {\n            if (_queueAdminsSet.length() == 1) revert CantRemoveLastQueueAdminException();\n            _queueAdminsSet.remove(admin);\n            emit RemoveQueueAdmin(admin);\n        }\n    }\n\n    /// @inheritdoc IGovernor\n    function updateVetoAdmin(address admin) external override timeLockOnly {\n        _updateVetoAdmin(admin);\n    }\n\n    /// @inheritdoc IGovernor\n    function allowExecutionByContracts() external override timeLockOnly {\n        if (!isExecutionByContractsAllowed) {\n            isExecutionByContractsAllowed = true;\n            emit AllowExecutionByContracts();\n        }\n    }\n\n    /// @inheritdoc IGovernor\n    function forbidExecutionByContracts() external override timeLockOnly {\n        if (isExecutionByContractsAllowed) {\n            isExecutionByContractsAllowed = false;\n            emit ForbidExecutionByContracts();\n        }\n    }\n\n    /// @inheritdoc IGovernor\n    function claimTimeLockOwnership() external override queueAdminOnly {\n        ITimeLock(timeLock).acceptAdmin();\n    }\n\n    // --------- //\n    // INTERNALS //\n    // --------- //\n\n    /// @dev Executes or cancels a transaction, ensures that it is not part of any batch\n    function _transactionAction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta,\n        TxAction action\n    ) internal returns (bytes memory result) {\n        bytes32 txHash = _getTxHash(target, value, signature, data, eta);\n        if (batchedTxInfo[txHash].batchBlock != 0) revert CantPerformActionOutsideBatchException();\n        return _performAction(target, value, signature, data, eta, action);\n    }\n\n    /// @dev Executes or cancels a batch of transactions, ensures that all transactions are processed in the correct order\n    function _batchAction(TxParams[] calldata txs, TxAction action) internal returns (uint256 batchBlock) {\n        uint256 len = txs.length;\n        if (len == 0) revert IncorrectBatchException();\n\n        batchBlock = batchedTxInfo[_getTxHash(txs[0])].batchBlock;\n        if (batchBlock == 0) revert IncorrectBatchException();\n\n        if (len != batchInfo[batchBlock].length) revert IncorrectBatchException();\n\n        unchecked {\n            for (uint256 i; i < len; ++i) {\n                TxParams calldata tx_ = txs[i];\n                bytes32 txHash = _getTxHash(tx_);\n\n                BatchedTxInfo memory info = batchedTxInfo[txHash];\n                if (info.batchBlock != batchBlock || info.index != i) revert UnexpectedTransactionException(txHash);\n\n                _performAction(tx_.target, tx_.value, tx_.signature, tx_.data, tx_.eta, action);\n                delete batchedTxInfo[txHash];\n            }\n        }\n\n        delete batchInfo[batchBlock];\n    }\n\n    /// @dev Executes or cancels a transaction\n    function _performAction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta,\n        TxAction action\n    ) internal returns (bytes memory result) {\n        if (action == TxAction.Execute) {\n            result = ITimeLock(timeLock).executeTransaction{value: value}(target, value, signature, data, eta);\n        } else {\n            ITimeLock(timeLock).cancelTransaction(target, value, signature, data, eta);\n        }\n    }\n\n    /// @dev `addQueueAdmin` implementation\n    function _addQueueAdmin(address admin) internal {\n        if (admin == address(0)) revert AdminCantBeZeroAddressException();\n        if (!_queueAdminsSet.contains(admin)) {\n            _queueAdminsSet.add(admin);\n            emit AddQueueAdmin(admin);\n        }\n    }\n\n    /// @dev `updateVetoAdmin` implementation\n    function _updateVetoAdmin(address admin) internal {\n        if (admin == address(0)) revert AdminCantBeZeroAddressException();\n        if (vetoAdmin != admin) {\n            vetoAdmin = admin;\n            emit UpdateVetoAdmin(admin);\n        }\n    }\n\n    /// @dev Computes transaction hash\n    function _getTxHash(address target, uint256 value, string calldata signature, bytes calldata data, uint256 eta)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encode(target, value, signature, data, eta));\n    }\n\n    /// @dev Computes transaction hash\n    function _getTxHash(TxParams calldata tx_) internal pure returns (bytes32) {\n        return _getTxHash(tx_.target, tx_.value, tx_.signature, tx_.data, tx_.eta);\n    }\n}\n"

    },

    "node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"

    },

    "contracts/interfaces/IGovernor.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2023.\npragma solidity ^0.8.0;\n\n/// @title Governor interface\ninterface IGovernor {\n    // ----- //\n    // TYPES //\n    // ----- //\n\n    /// @notice Timelock contract transaction params packed in a struct\n    /// @param target Target contract to call\n    /// @param value Value to send in the call\n    /// @param signature Signature of the target contract's function to call\n    /// @param data ABI-encoded parameters to call the function with\n    /// @param eta Transaction ETA (timestamp after which it can be executed)\n    struct TxParams {\n        address target;\n        uint256 value;\n        string signature;\n        bytes data;\n        uint256 eta;\n    }\n\n    /// @notice Batch information\n    /// @param initiator Queue admin that initiated the batch\n    /// @param length Number of transactions in the batch\n    /// @param eta ETA of transactions in the batch\n    struct BatchInfo {\n        address initiator;\n        uint16 length;\n        uint80 eta;\n    }\n\n    /// @notice Batched transaction information\n    /// @param batchBlock Block the batch was initiated in\n    /// @param index Index of transaction within the batch\n    struct BatchedTxInfo {\n        uint64 batchBlock;\n        uint16 index;\n    }\n\n    /// @notice Action that can be performed with a queued transaction\n    enum TxAction {\n        Execute,\n        Cancel\n    }\n\n    // ------ //\n    // EVENTS //\n    // ------ //\n\n    /// @notice Emitted when `caller` initiates a batch in `batchBlock`\n    event QueueBatch(address indexed caller, uint256 indexed batchBlock);\n\n    /// @notice Emitted when `caller` executes a batch initiated in `batchBlock`\n    event ExecuteBatch(address indexed caller, uint256 indexed batchBlock);\n\n    /// @notice Emitted when `caller` cancels a batch initiated in `batchBlock`\n    event CancelBatch(address indexed caller, uint256 indexed batchBlock);\n\n    /// @notice Emitted when `admin` is added to the list of queue admins\n    event AddQueueAdmin(address indexed admin);\n\n    /// @notice Emitted when `admin` is removed from the list of queue admins\n    event RemoveQueueAdmin(address indexed admin);\n\n    /// @notice Emitted when `admin` is set as the new veto admin\n    event UpdateVetoAdmin(address indexed admin);\n\n    /// @notice Emitted when transaction/batch execution by contracts is allowed\n    event AllowExecutionByContracts();\n\n    /// @notice Emitted when transaction/batch execution by contracts is forbidden\n    event ForbidExecutionByContracts();\n\n    // ------ //\n    // ERRORS //\n    // ------ //\n\n    /// @notice Thrown when an account that is not a queue admin tries to queue a transaction or initiate a batch\n    error CallerNotQueueAdminException();\n\n    /// @notice Thrown when an account that is not the timelock contract tries to configure the governor\n    error CallerNotTimelockException();\n\n    /// @notice Thrown when an account that is not the veto admin tries to cancel a transaction or a batch\n    error CallerNotVetoAdminException();\n\n    /// @notice Thrown when trying to execute a trasaction or a batch from the contract when it's forbidden\n    error CallerMustNotBeContractException();\n\n    /// @notice Thrown when a queue admin tries to add transactions to the batch not initiated by themselves\n    error CallerNotBatchInitiatorException();\n\n    /// @notice Thrown when trying to queue a transaction that is already queued\n    error TransactionAlreadyQueuedException();\n\n    /// @notice Thrown when batched transaction's ETA differs from the batch ETA\n    error ETAMistmatchException();\n\n    /// @notice Thrown when trying to initiate a batch more than once in a block\n    error BatchAlreadyStartedException();\n\n    /// @notice Thrown when trying to execute or cancel a transaction individually while it's part of some batch\n    error CantPerformActionOutsideBatchException();\n\n    /// @notice Thrown when a passed list of transactions doesn't represent a valid queued batch\n    error IncorrectBatchException();\n\n    /// @notice Thrown when a passed list of transactions contains a transaction different from those in the queued batch\n    error UnexpectedTransactionException(bytes32 txHash);\n\n    /// @notice Thrown when trying to set zero address as a queue or veto admin\n    error AdminCantBeZeroAddressException();\n\n    /// @notice Thrown when trying to remove the last queue admin\n    error CantRemoveLastQueueAdminException();\n\n    // ----- //\n    // STATE //\n    // ----- //\n\n    /// @notice Returns an address of the timelock contract\n    function timeLock() external view returns (address);\n\n    /// @notice Returns an array of addresses of queue admins\n    function queueAdmins() external view returns (address[] memory);\n\n    /// @notice Returns an address of the veto admin\n    function vetoAdmin() external view returns (address);\n\n    /// @notice Whether transaction/batch execution by contracts is allowed\n    function isExecutionByContractsAllowed() external view returns (bool);\n\n    /// @notice Returns info for the batch initiated in `batchBlock`\n    /// @dev `initiator == address(0)` means that there was no batch initiated in that block\n    function batchInfo(uint256 batchBlock) external view returns (address initiator, uint16 length, uint80 eta);\n\n    /// @notice Returns batch info for the transaction with given `txHash`\n    /// @dev `batchBlock == 0` means that transaction is not part of any batch\n    function batchedTxInfo(bytes32 txHash) external view returns (uint64 batchBlock, uint16 index);\n\n    // ------- //\n    // ACTIONS //\n    // ------- //\n\n    /// @notice Queues a transaction in the timelock. Ensures that it's not already queued. When no batch is initiated,\n    ///         simply forwards the call to the timelock contract. Otherwise, appends the transaction to the batch after\n    ///         checking that caller is the account that initiated the batch and ETAs of all transactions are the same.\n    /// @dev See `TxParams` for params description\n    /// @dev Can only be called by queue admins\n    function queueTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) external returns (bytes32 txHash);\n\n    /// @notice Initiates a batch of transactions. All the transactions that are queued after this call in the same block\n    ///         will form a batch that can only be executed/cancelled as a whole. Typically, this will be the first call\n    ///         in a multicall that queues a batch, followed by multiple `queueTransaction` calls.\n    /// @param eta ETA of transactions in the batch\n    /// @dev Can only be called by queue admins\n    function startBatch(uint80 eta) external;\n\n    /// @notice Executes a queued transaction. Ensures that it is not part of any batch and forwards the call to the\n    ///         timelock contract.\n    /// @dev See `TxParams` for params description\n    /// @dev Can only be called by EOAs unless execution by contracts is allowed\n    function executeTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) external payable returns (bytes memory result);\n\n    /// @notice Executes a queued batch of transactions. Ensures that `txs` is the same ordered list of transactions as\n    ///         the one that was queued, and forwards all calls to the timelock contract.\n    /// @dev Can only be called by EOAs unless execution by contracts is allowed\n    function executeBatch(TxParams[] calldata txs) external payable;\n\n    /// @notice Cancels a queued transaction. Ensures that it is not part of any batch and forwards the call to the\n    ///         timelock contract.\n    /// @dev See `TxParams` for params description\n    /// @dev Can only be called by the veto admin\n    function cancelTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) external;\n\n    /// @notice Cancels a queued batch of transactions. Ensures that `txs` is the same ordered list of transactions as\n    ///         the one that was queued, and forwards all calls to the timelock contract.\n    /// @dev Can only be called by the veto admin\n    function cancelBatch(TxParams[] calldata txs) external;\n\n    // ------------- //\n    // CONFIGURATION //\n    // ------------- //\n\n    /// @notice Adds `admin` to the list of queue admins, ensures that it's not zero address\n    /// @dev Can only be called by the timelock contract\n    function addQueueAdmin(address admin) external;\n\n    /// @notice Removes `admin` from the list of queue admins, ensures that it's not the last admin\n    /// @dev Can only be called by the timelock contract\n    function removeQueueAdmin(address admin) external;\n\n    /// @notice Sets `admin` as the new veto admin, ensures that it's not zero address\n    /// @dev Can only be called by the timelock contract\n    /// @dev It's assumed that veto admin is a contract that has means to prevent it from blocking its' own update,\n    ///      for example, it might be a multisig that can remove malicious signers\n    function updateVetoAdmin(address admin) external;\n\n    /// @notice Allows transactions/batches to be executed by contracts\n    /// @dev Can only be called by the timelock contract\n    function allowExecutionByContracts() external;\n\n    /// @notice Forbids transactions/batches to be executed by contracts\n    /// @dev Can only be called by the timelock contract\n    function forbidExecutionByContracts() external;\n\n    /// @notice Claims ownership ower the `timeLock` contract\n    /// @dev Must be executed by the first queue admin after deploying this contract and setting it as timelock's owner\n    function claimTimeLockOwnership() external;\n}\n"

    },

    "contracts/interfaces/ITimeLock.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2023.\npragma solidity ^0.8.0;\n\n/// @title Timelock interface\ninterface ITimeLock {\n    function admin() external view returns (address);\n\n    function delay() external view returns (uint256);\n\n    function queuedTransactions(bytes32 txHash) external view returns (bool);\n\n    function queueTransaction(address target, uint256 value, string memory signature, bytes memory data, uint256 eta)\n        external\n        returns (bytes32 txHash);\n\n    function executeTransaction(address target, uint256 value, string memory signature, bytes memory data, uint256 eta)\n        external\n        payable\n        returns (bytes memory result);\n\n    function cancelTransaction(address target, uint256 value, string memory signature, bytes memory data, uint256 eta)\n        external;\n\n    function setPendingAdmin(address newPendingAdmin) external;\n\n    function acceptAdmin() external;\n}\n"

    }

  },

  "settings": {

    "remappings": [

      "forge-std/=node_modules/forge-std/src/",

      "ds-test/=node_modules/ds-test/src/",

      "@openzeppelin/=node_modules/@openzeppelin/"

    ],

    "optimizer": {

      "enabled": true,

      "runs": 200

    },

    "metadata": {

      "useLiteralContent": false,

      "bytecodeHash": "ipfs"

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "evmVersion": "london",

    "libraries": {}

  }

}}