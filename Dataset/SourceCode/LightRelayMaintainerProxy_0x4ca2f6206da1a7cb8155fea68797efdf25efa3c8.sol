{{

  "language": "Solidity",

  "sources": {

    "@keep-network/bitcoin-spv-sol/contracts/BTCUtils.sol": {

      "content": "pragma solidity ^0.8.4;\n\n/** @title BitcoinSPV */\n/** @author Summa (https://summa.one) */\n\nimport {BytesLib} from \"./BytesLib.sol\";\nimport {SafeMath} from \"./SafeMath.sol\";\n\nlibrary BTCUtils {\n    using BytesLib for bytes;\n    using SafeMath for uint256;\n\n    // The target at minimum Difficulty. Also the target of the genesis block\n    uint256 public constant DIFF1_TARGET = 0xffff0000000000000000000000000000000000000000000000000000;\n\n    uint256 public constant RETARGET_PERIOD = 2 * 7 * 24 * 60 * 60;  // 2 weeks in seconds\n    uint256 public constant RETARGET_PERIOD_BLOCKS = 2016;  // 2 weeks in blocks\n\n    uint256 public constant ERR_BAD_ARG = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /* ***** */\n    /* UTILS */\n    /* ***** */\n\n    /// @notice         Determines the length of a VarInt in bytes\n    /// @dev            A VarInt of >1 byte is prefixed with a flag indicating its length\n    /// @param _flag    The first byte of a VarInt\n    /// @return         The number of non-flag bytes in the VarInt\n    function determineVarIntDataLength(bytes memory _flag) internal pure returns (uint8) {\n        return determineVarIntDataLengthAt(_flag, 0);\n    }\n\n    /// @notice         Determines the length of a VarInt in bytes\n    /// @dev            A VarInt of >1 byte is prefixed with a flag indicating its length\n    /// @param _b       The byte array containing a VarInt\n    /// @param _at      The position of the VarInt in the array\n    /// @return         The number of non-flag bytes in the VarInt\n    function determineVarIntDataLengthAt(bytes memory _b, uint256 _at) internal pure returns (uint8) {\n        if (uint8(_b[_at]) == 0xff) {\n            return 8;  // one-byte flag, 8 bytes data\n        }\n        if (uint8(_b[_at]) == 0xfe) {\n            return 4;  // one-byte flag, 4 bytes data\n        }\n        if (uint8(_b[_at]) == 0xfd) {\n            return 2;  // one-byte flag, 2 bytes data\n        }\n\n        return 0;  // flag is data\n    }\n\n    /// @notice     Parse a VarInt into its data length and the number it represents\n    /// @dev        Useful for Parsing Vins and Vouts. Returns ERR_BAD_ARG if insufficient bytes.\n    ///             Caller SHOULD explicitly handle this case (or bubble it up)\n    /// @param _b   A byte-string starting with a VarInt\n    /// @return     number of bytes in the encoding (not counting the tag), the encoded int\n    function parseVarInt(bytes memory _b) internal pure returns (uint256, uint256) {\n        return parseVarIntAt(_b, 0);\n    }\n\n    /// @notice     Parse a VarInt into its data length and the number it represents\n    /// @dev        Useful for Parsing Vins and Vouts. Returns ERR_BAD_ARG if insufficient bytes.\n    ///             Caller SHOULD explicitly handle this case (or bubble it up)\n    /// @param _b   A byte-string containing a VarInt\n    /// @param _at  The position of the VarInt\n    /// @return     number of bytes in the encoding (not counting the tag), the encoded int\n    function parseVarIntAt(bytes memory _b, uint256 _at) internal pure returns (uint256, uint256) {\n        uint8 _dataLen = determineVarIntDataLengthAt(_b, _at);\n\n        if (_dataLen == 0) {\n            return (0, uint8(_b[_at]));\n        }\n        if (_b.length < 1 + _dataLen + _at) {\n            return (ERR_BAD_ARG, 0);\n        }\n        uint256 _number;\n        if (_dataLen == 2) {\n            _number = reverseUint16(uint16(_b.slice2(1 + _at)));\n        } else if (_dataLen == 4) {\n            _number = reverseUint32(uint32(_b.slice4(1 + _at)));\n        } else if (_dataLen == 8) {\n            _number = reverseUint64(uint64(_b.slice8(1 + _at)));\n        }\n        return (_dataLen, _number);\n    }\n\n    /// @notice          Changes the endianness of a byte array\n    /// @dev             Returns a new, backwards, bytes\n    /// @param _b        The bytes to reverse\n    /// @return          The reversed bytes\n    function reverseEndianness(bytes memory _b) internal pure returns (bytes memory) {\n        bytes memory _newValue = new bytes(_b.length);\n\n        for (uint i = 0; i < _b.length; i++) {\n            _newValue[_b.length - i - 1] = _b[i];\n        }\n\n        return _newValue;\n    }\n\n    /// @notice          Changes the endianness of a uint256\n    /// @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n    /// @param _b        The unsigned integer to reverse\n    /// @return v        The reversed value\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v = ((v >> 8) & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\n        // swap 2-byte long pairs\n        v = ((v >> 16) & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\n        // swap 4-byte long pairs\n        v = ((v >> 32) & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);\n        // swap 8-byte long pairs\n        v = ((v >> 64) & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) << 64);\n        // swap 16-byte long pairs\n        v = (v >> 128) | (v << 128);\n    }\n\n    /// @notice          Changes the endianness of a uint64\n    /// @param _b        The unsigned integer to reverse\n    /// @return v        The reversed value\n    function reverseUint64(uint64 _b) internal pure returns (uint64 v) {\n        v = _b;\n\n        // swap bytes\n        v = ((v >> 8) & 0x00FF00FF00FF00FF) |\n            ((v & 0x00FF00FF00FF00FF) << 8);\n        // swap 2-byte long pairs\n        v = ((v >> 16) & 0x0000FFFF0000FFFF) |\n            ((v & 0x0000FFFF0000FFFF) << 16);\n        // swap 4-byte long pairs\n        v = (v >> 32) | (v << 32);\n    }\n\n    /// @notice          Changes the endianness of a uint32\n    /// @param _b        The unsigned integer to reverse\n    /// @return v        The reversed value\n    function reverseUint32(uint32 _b) internal pure returns (uint32 v) {\n        v = _b;\n\n        // swap bytes\n        v = ((v >> 8) & 0x00FF00FF) |\n            ((v & 0x00FF00FF) << 8);\n        // swap 2-byte long pairs\n        v = (v >> 16) | (v << 16);\n    }\n\n    /// @notice          Changes the endianness of a uint24\n    /// @param _b        The unsigned integer to reverse\n    /// @return v        The reversed value\n    function reverseUint24(uint24 _b) internal pure returns (uint24 v) {\n        v =  (_b << 16) | (_b & 0x00FF00) | (_b >> 16);\n    }\n\n    /// @notice          Changes the endianness of a uint16\n    /// @param _b        The unsigned integer to reverse\n    /// @return v        The reversed value\n    function reverseUint16(uint16 _b) internal pure returns (uint16 v) {\n        v =  (_b << 8) | (_b >> 8);\n    }\n\n\n    /// @notice          Converts big-endian bytes to a uint\n    /// @dev             Traverses the byte array and sums the bytes\n    /// @param _b        The big-endian bytes-encoded integer\n    /// @return          The integer representation\n    function bytesToUint(bytes memory _b) internal pure returns (uint256) {\n        uint256 _number;\n\n        for (uint i = 0; i < _b.length; i++) {\n            _number = _number + uint8(_b[i]) * (2 ** (8 * (_b.length - (i + 1))));\n        }\n\n        return _number;\n    }\n\n    /// @notice          Get the last _num bytes from a byte array\n    /// @param _b        The byte array to slice\n    /// @param _num      The number of bytes to extract from the end\n    /// @return          The last _num bytes of _b\n    function lastBytes(bytes memory _b, uint256 _num) internal pure returns (bytes memory) {\n        uint256 _start = _b.length.sub(_num);\n\n        return _b.slice(_start, _num);\n    }\n\n    /// @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n    /// @dev             abi.encodePacked changes the return to bytes instead of bytes32\n    /// @param _b        The pre-image\n    /// @return          The digest\n    function hash160(bytes memory _b) internal pure returns (bytes memory) {\n        return abi.encodePacked(ripemd160(abi.encodePacked(sha256(_b))));\n    }\n\n    /// @notice          Implements bitcoin's hash160 (sha2 + ripemd160)\n    /// @dev             sha2 precompile at address(2), ripemd160 at address(3)\n    /// @param _b        The pre-image\n    /// @return res      The digest\n    function hash160View(bytes memory _b) internal view returns (bytes20 res) {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            pop(staticcall(gas(), 2, add(_b, 32), mload(_b), 0x00, 32))\n            pop(staticcall(gas(), 3, 0x00, 32, 0x00, 32))\n            // read from position 12 = 0c\n            res := mload(0x0c)\n        }\n    }\n\n    /// @notice          Implements bitcoin's hash256 (double sha2)\n    /// @dev             abi.encodePacked changes the return to bytes instead of bytes32\n    /// @param _b        The pre-image\n    /// @return          The digest\n    function hash256(bytes memory _b) internal pure returns (bytes32) {\n        return sha256(abi.encodePacked(sha256(_b)));\n    }\n\n    /// @notice          Implements bitcoin's hash256 (double sha2)\n    /// @dev             sha2 is precompiled smart contract located at address(2)\n    /// @param _b        The pre-image\n    /// @return res      The digest\n    function hash256View(bytes memory _b) internal view returns (bytes32 res) {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            pop(staticcall(gas(), 2, add(_b, 32), mload(_b), 0x00, 32))\n            pop(staticcall(gas(), 2, 0x00, 32, 0x00, 32))\n            res := mload(0x00)\n        }\n    }\n\n    /// @notice          Implements bitcoin's hash256 on a pair of bytes32\n    /// @dev             sha2 is precompiled smart contract located at address(2)\n    /// @param _a        The first bytes32 of the pre-image\n    /// @param _b        The second bytes32 of the pre-image\n    /// @return res      The digest\n    function hash256Pair(bytes32 _a, bytes32 _b) internal view returns (bytes32 res) {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            mstore(0x00, _a)\n            mstore(0x20, _b)\n            pop(staticcall(gas(), 2, 0x00, 64, 0x00, 32))\n            pop(staticcall(gas(), 2, 0x00, 32, 0x00, 32))\n            res := mload(0x00)\n        }\n    }\n\n    /// @notice          Implements bitcoin's hash256 (double sha2)\n    /// @dev             sha2 is precompiled smart contract located at address(2)\n    /// @param _b        The array containing the pre-image\n    /// @param at        The start of the pre-image\n    /// @param len       The length of the pre-image\n    /// @return res      The digest\n    function hash256Slice(\n        bytes memory _b,\n        uint256 at,\n        uint256 len\n    ) internal view returns (bytes32 res) {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            pop(staticcall(gas(), 2, add(_b, add(32, at)), len, 0x00, 32))\n            pop(staticcall(gas(), 2, 0x00, 32, 0x00, 32))\n            res := mload(0x00)\n        }\n    }\n\n    /* ************ */\n    /* Legacy Input */\n    /* ************ */\n\n    /// @notice          Extracts the nth input from the vin (0-indexed)\n    /// @dev             Iterates over the vin. If you need to extract several, write a custom function\n    /// @param _vin      The vin as a tightly-packed byte array\n    /// @param _index    The 0-indexed location of the input to extract\n    /// @return          The input as a byte array\n    function extractInputAtIndex(bytes memory _vin, uint256 _index) internal pure returns (bytes memory) {\n        uint256 _varIntDataLen;\n        uint256 _nIns;\n\n        (_varIntDataLen, _nIns) = parseVarInt(_vin);\n        require(_varIntDataLen != ERR_BAD_ARG, \"Read overrun during VarInt parsing\");\n        require(_index < _nIns, \"Vin read overrun\");\n\n        uint256 _len = 0;\n        uint256 _offset = 1 + _varIntDataLen;\n\n        for (uint256 _i = 0; _i < _index; _i ++) {\n            _len = determineInputLengthAt(_vin, _offset);\n            require(_len != ERR_BAD_ARG, \"Bad VarInt in scriptSig\");\n            _offset = _offset + _len;\n        }\n\n        _len = determineInputLengthAt(_vin, _offset);\n        require(_len != ERR_BAD_ARG, \"Bad VarInt in scriptSig\");\n        return _vin.slice(_offset, _len);\n    }\n\n    /// @notice          Determines whether an input is legacy\n    /// @dev             False if no scriptSig, otherwise True\n    /// @param _input    The input\n    /// @return          True for legacy, False for witness\n    function isLegacyInput(bytes memory _input) internal pure returns (bool) {\n        return _input[36] != hex\"00\";\n    }\n\n    /// @notice          Determines the length of a scriptSig in an input\n    /// @dev             Will return 0 if passed a witness input.\n    /// @param _input    The LEGACY input\n    /// @return          The length of the script sig\n    function extractScriptSigLen(bytes memory _input) internal pure returns (uint256, uint256) {\n        return extractScriptSigLenAt(_input, 0);\n    }\n\n    /// @notice          Determines the length of a scriptSig in an input\n    ///                  starting at the specified position\n    /// @dev             Will return 0 if passed a witness input.\n    /// @param _input    The byte array containing the LEGACY input\n    /// @param _at       The position of the input in the array\n    /// @return          The length of the script sig\n    function extractScriptSigLenAt(bytes memory _input, uint256 _at) internal pure returns (uint256, uint256) {\n        if (_input.length < 37 + _at) {\n            return (ERR_BAD_ARG, 0);\n        }\n\n        uint256 _varIntDataLen;\n        uint256 _scriptSigLen;\n        (_varIntDataLen, _scriptSigLen) = parseVarIntAt(_input, _at + 36);\n\n        return (_varIntDataLen, _scriptSigLen);\n    }\n\n    /// @notice          Determines the length of an input from its scriptSig\n    /// @dev             36 for outpoint, 1 for scriptSig length, 4 for sequence\n    /// @param _input    The input\n    /// @return          The length of the input in bytes\n    function determineInputLength(bytes memory _input) internal pure returns (uint256) {\n        return determineInputLengthAt(_input, 0);\n    }\n\n    /// @notice          Determines the length of an input from its scriptSig,\n    ///                  starting at the specified position\n    /// @dev             36 for outpoint, 1 for scriptSig length, 4 for sequence\n    /// @param _input    The byte array containing the input\n    /// @param _at       The position of the input in the array\n    /// @return          The length of the input in bytes\n    function determineInputLengthAt(bytes memory _input, uint256 _at) internal pure returns (uint256) {\n        uint256 _varIntDataLen;\n        uint256 _scriptSigLen;\n        (_varIntDataLen, _scriptSigLen) = extractScriptSigLenAt(_input, _at);\n        if (_varIntDataLen == ERR_BAD_ARG) {\n            return ERR_BAD_ARG;\n        }\n\n        return 36 + 1 + _varIntDataLen + _scriptSigLen + 4;\n    }\n\n    /// @notice          Extracts the LE sequence bytes from an input\n    /// @dev             Sequence is used for relative time locks\n    /// @param _input    The LEGACY input\n    /// @return          The sequence bytes (LE uint)\n    function extractSequenceLELegacy(bytes memory _input) internal pure returns (bytes4) {\n        uint256 _varIntDataLen;\n        uint256 _scriptSigLen;\n        (_varIntDataLen, _scriptSigLen) = extractScriptSigLen(_input);\n        require(_varIntDataLen != ERR_BAD_ARG, \"Bad VarInt in scriptSig\");\n        return _input.slice4(36 + 1 + _varIntDataLen + _scriptSigLen);\n    }\n\n    /// @notice          Extracts the sequence from the input\n    /// @dev             Sequence is a 4-byte little-endian number\n    /// @param _input    The LEGACY input\n    /// @return          The sequence number (big-endian uint)\n    function extractSequenceLegacy(bytes memory _input) internal pure returns (uint32) {\n        uint32 _leSeqence = uint32(extractSequenceLELegacy(_input));\n        uint32 _beSequence = reverseUint32(_leSeqence);\n        return _beSequence;\n    }\n    /// @notice          Extracts the VarInt-prepended scriptSig from the input in a tx\n    /// @dev             Will return hex\"00\" if passed a witness input\n    /// @param _input    The LEGACY input\n    /// @return          The length-prepended scriptSig\n    function extractScriptSig(bytes memory _input) internal pure returns (bytes memory) {\n        uint256 _varIntDataLen;\n        uint256 _scriptSigLen;\n        (_varIntDataLen, _scriptSigLen) = extractScriptSigLen(_input);\n        require(_varIntDataLen != ERR_BAD_ARG, \"Bad VarInt in scriptSig\");\n        return _input.slice(36, 1 + _varIntDataLen + _scriptSigLen);\n    }\n\n\n    /* ************* */\n    /* Witness Input */\n    /* ************* */\n\n    /// @notice          Extracts the LE sequence bytes from an input\n    /// @dev             Sequence is used for relative time locks\n    /// @param _input    The WITNESS input\n    /// @return          The sequence bytes (LE uint)\n    function extractSequenceLEWitness(bytes memory _input) internal pure returns (bytes4) {\n        return _input.slice4(37);\n    }\n\n    /// @notice          Extracts the sequence from the input in a tx\n    /// @dev             Sequence is a 4-byte little-endian number\n    /// @param _input    The WITNESS input\n    /// @return          The sequence number (big-endian uint)\n    function extractSequenceWitness(bytes memory _input) internal pure returns (uint32) {\n        uint32 _leSeqence = uint32(extractSequenceLEWitness(_input));\n        uint32 _inputeSequence = reverseUint32(_leSeqence);\n        return _inputeSequence;\n    }\n\n    /// @notice          Extracts the outpoint from the input in a tx\n    /// @dev             32-byte tx id with 4-byte index\n    /// @param _input    The input\n    /// @return          The outpoint (LE bytes of prev tx hash + LE bytes of prev tx index)\n    function extractOutpoint(bytes memory _input) internal pure returns (bytes memory) {\n        return _input.slice(0, 36);\n    }\n\n    /// @notice          Extracts the outpoint tx id from an input\n    /// @dev             32-byte tx id\n    /// @param _input    The input\n    /// @return          The tx id (little-endian bytes)\n    function extractInputTxIdLE(bytes memory _input) internal pure returns (bytes32) {\n        return _input.slice32(0);\n    }\n\n    /// @notice          Extracts the outpoint tx id from an input\n    ///                  starting at the specified position\n    /// @dev             32-byte tx id\n    /// @param _input    The byte array containing the input\n    /// @param _at       The position of the input\n    /// @return          The tx id (little-endian bytes)\n    function extractInputTxIdLeAt(bytes memory _input, uint256 _at) internal pure returns (bytes32) {\n        return _input.slice32(_at);\n    }\n\n    /// @notice          Extracts the LE tx input index from the input in a tx\n    /// @dev             4-byte tx index\n    /// @param _input    The input\n    /// @return          The tx index (little-endian bytes)\n    function extractTxIndexLE(bytes memory _input) internal pure returns (bytes4) {\n        return _input.slice4(32);\n    }\n\n    /// @notice          Extracts the LE tx input index from the input in a tx\n    ///                  starting at the specified position\n    /// @dev             4-byte tx index\n    /// @param _input    The byte array containing the input\n    /// @param _at       The position of the input\n    /// @return          The tx index (little-endian bytes)\n    function extractTxIndexLeAt(bytes memory _input, uint256 _at) internal pure returns (bytes4) {\n        return _input.slice4(32 + _at);\n    }\n\n    /* ****** */\n    /* Output */\n    /* ****** */\n\n    /// @notice          Determines the length of an output\n    /// @dev             Works with any properly formatted output\n    /// @param _output   The output\n    /// @return          The length indicated by the prefix, error if invalid length\n    function determineOutputLength(bytes memory _output) internal pure returns (uint256) {\n        return determineOutputLengthAt(_output, 0);\n    }\n\n    /// @notice          Determines the length of an output\n    ///                  starting at the specified position\n    /// @dev             Works with any properly formatted output\n    /// @param _output   The byte array containing the output\n    /// @param _at       The position of the output\n    /// @return          The length indicated by the prefix, error if invalid length\n    function determineOutputLengthAt(bytes memory _output, uint256 _at) internal pure returns (uint256) {\n        if (_output.length < 9 + _at) {\n            return ERR_BAD_ARG;\n        }\n        uint256 _varIntDataLen;\n        uint256 _scriptPubkeyLength;\n        (_varIntDataLen, _scriptPubkeyLength) = parseVarIntAt(_output, 8 + _at);\n\n        if (_varIntDataLen == ERR_BAD_ARG) {\n            return ERR_BAD_ARG;\n        }\n\n        // 8-byte value, 1-byte for tag itself\n        return 8 + 1 + _varIntDataLen + _scriptPubkeyLength;\n    }\n\n    /// @notice          Extracts the output at a given index in the TxOuts vector\n    /// @dev             Iterates over the vout. If you need to extract multiple, write a custom function\n    /// @param _vout     The _vout to extract from\n    /// @param _index    The 0-indexed location of the output to extract\n    /// @return          The specified output\n    function extractOutputAtIndex(bytes memory _vout, uint256 _index) internal pure returns (bytes memory) {\n        uint256 _varIntDataLen;\n        uint256 _nOuts;\n\n        (_varIntDataLen, _nOuts) = parseVarInt(_vout);\n        require(_varIntDataLen != ERR_BAD_ARG, \"Read overrun during VarInt parsing\");\n        require(_index < _nOuts, \"Vout read overrun\");\n\n        uint256 _len = 0;\n        uint256 _offset = 1 + _varIntDataLen;\n\n        for (uint256 _i = 0; _i < _index; _i ++) {\n            _len = determineOutputLengthAt(_vout, _offset);\n            require(_len != ERR_BAD_ARG, \"Bad VarInt in scriptPubkey\");\n            _offset += _len;\n        }\n\n        _len = determineOutputLengthAt(_vout, _offset);\n        require(_len != ERR_BAD_ARG, \"Bad VarInt in scriptPubkey\");\n        return _vout.slice(_offset, _len);\n    }\n\n    /// @notice          Extracts the value bytes from the output in a tx\n    /// @dev             Value is an 8-byte little-endian number\n    /// @param _output   The output\n    /// @return          The output value as LE bytes\n    function extractValueLE(bytes memory _output) internal pure returns (bytes8) {\n        return _output.slice8(0);\n    }\n\n    /// @notice          Extracts the value from the output in a tx\n    /// @dev             Value is an 8-byte little-endian number\n    /// @param _output   The output\n    /// @return          The output value\n    function extractValue(bytes memory _output) internal pure returns (uint64) {\n        uint64 _leValue = uint64(extractValueLE(_output));\n        uint64 _beValue = reverseUint64(_leValue);\n        return _beValue;\n    }\n\n    /// @notice          Extracts the value from the output in a tx\n    /// @dev             Value is an 8-byte little-endian number\n    /// @param _output   The byte array containing the output\n    /// @param _at       The starting index of the output in the array\n    /// @return          The output value\n    function extractValueAt(bytes memory _output, uint256 _at) internal pure returns (uint64) {\n        uint64 _leValue = uint64(_output.slice8(_at));\n        uint64 _beValue = reverseUint64(_leValue);\n        return _beValue;\n    }\n\n    /// @notice          Extracts the data from an op return output\n    /// @dev             Returns hex\"\" if no data or not an op return\n    /// @param _output   The output\n    /// @return          Any data contained in the opreturn output, null if not an op return\n    function extractOpReturnData(bytes memory _output) internal pure returns (bytes memory) {\n        if (_output[9] != hex\"6a\") {\n            return hex\"\";\n        }\n        bytes1 _dataLen = _output[10];\n        return _output.slice(11, uint256(uint8(_dataLen)));\n    }\n\n    /// @notice          Extracts the hash from the output script\n    /// @dev             Determines type by the length prefix and validates format\n    /// @param _output   The output\n    /// @return          The hash committed to by the pk_script, or null for errors\n    function extractHash(bytes memory _output) internal pure returns (bytes memory) {\n        return extractHashAt(_output, 8, _output.length - 8);\n    }\n\n    /// @notice          Extracts the hash from the output script\n    /// @dev             Determines type by the length prefix and validates format\n    /// @param _output   The byte array containing the output\n    /// @param _at       The starting index of the output script in the array\n    ///                  (output start + 8)\n    /// @param _len      The length of the output script\n    ///                  (output length - 8)\n    /// @return          The hash committed to by the pk_script, or null for errors\n    function extractHashAt(\n        bytes memory _output,\n        uint256 _at,\n        uint256 _len\n    ) internal pure returns (bytes memory) {\n        uint8 _scriptLen = uint8(_output[_at]);\n\n        // don't have to worry about overflow here.\n        // if _scriptLen + 1 overflows, then output length would have to be < 1\n        // for this check to pass. if it's < 1, then we errored when assigning\n        // _scriptLen\n        if (_scriptLen + 1 != _len) {\n            return hex\"\";\n        }\n\n        if (uint8(_output[_at + 1]) == 0) {\n            if (_scriptLen < 2) {\n                return hex\"\";\n            }\n            uint256 _payloadLen = uint8(_output[_at + 2]);\n            // Check for maliciously formatted witness outputs.\n            // No need to worry about underflow as long b/c of the `< 2` check\n            if (_payloadLen != _scriptLen - 2 || (_payloadLen != 0x20 && _payloadLen != 0x14)) {\n                return hex\"\";\n            }\n            return _output.slice(_at + 3, _payloadLen);\n        } else {\n            bytes3 _tag = _output.slice3(_at);\n            // p2pkh\n            if (_tag == hex\"1976a9\") {\n                // Check for maliciously formatted p2pkh\n                // No need to worry about underflow, b/c of _scriptLen check\n                if (uint8(_output[_at + 3]) != 0x14 ||\n                    _output.slice2(_at + _len - 2) != hex\"88ac\") {\n                    return hex\"\";\n                }\n                return _output.slice(_at + 4, 20);\n            //p2sh\n            } else if (_tag == hex\"17a914\") {\n                // Check for maliciously formatted p2sh\n                // No need to worry about underflow, b/c of _scriptLen check\n                if (uint8(_output[_at + _len - 1]) != 0x87) {\n                    return hex\"\";\n                }\n                return _output.slice(_at + 3, 20);\n            }\n        }\n        return hex\"\";  /* NB: will trigger on OPRETURN and any non-standard that doesn't overrun */\n    }\n\n    /* ********** */\n    /* Witness TX */\n    /* ********** */\n\n\n    /// @notice      Checks that the vin passed up is properly formatted\n    /// @dev         Consider a vin with a valid vout in its scriptsig\n    /// @param _vin  Raw bytes length-prefixed input vector\n    /// @return      True if it represents a validly formatted vin\n    function validateVin(bytes memory _vin) internal pure returns (bool) {\n        uint256 _varIntDataLen;\n        uint256 _nIns;\n\n        (_varIntDataLen, _nIns) = parseVarInt(_vin);\n\n        // Not valid if it says there are too many or no inputs\n        if (_nIns == 0 || _varIntDataLen == ERR_BAD_ARG) {\n            return false;\n        }\n\n        uint256 _offset = 1 + _varIntDataLen;\n\n        for (uint256 i = 0; i < _nIns; i++) {\n            // If we're at the end, but still expect more\n            if (_offset >= _vin.length) {\n                return false;\n            }\n\n            // Grab the next input and determine its length.\n            uint256 _nextLen = determineInputLengthAt(_vin, _offset);\n            if (_nextLen == ERR_BAD_ARG) {\n                return false;\n            }\n\n            // Increase the offset by that much\n            _offset += _nextLen;\n        }\n\n        // Returns false if we're not exactly at the end\n        return _offset == _vin.length;\n    }\n\n    /// @notice      Checks that the vout passed up is properly formatted\n    /// @dev         Consider a vout with a valid scriptpubkey\n    /// @param _vout Raw bytes length-prefixed output vector\n    /// @return      True if it represents a validly formatted vout\n    function validateVout(bytes memory _vout) internal pure returns (bool) {\n        uint256 _varIntDataLen;\n        uint256 _nOuts;\n\n        (_varIntDataLen, _nOuts) = parseVarInt(_vout);\n\n        // Not valid if it says there are too many or no outputs\n        if (_nOuts == 0 || _varIntDataLen == ERR_BAD_ARG) {\n            return false;\n        }\n\n        uint256 _offset = 1 + _varIntDataLen;\n\n        for (uint256 i = 0; i < _nOuts; i++) {\n            // If we're at the end, but still expect more\n            if (_offset >= _vout.length) {\n                return false;\n            }\n\n            // Grab the next output and determine its length.\n            // Increase the offset by that much\n            uint256 _nextLen = determineOutputLengthAt(_vout, _offset);\n            if (_nextLen == ERR_BAD_ARG) {\n                return false;\n            }\n\n            _offset += _nextLen;\n        }\n\n        // Returns false if we're not exactly at the end\n        return _offset == _vout.length;\n    }\n\n\n\n    /* ************ */\n    /* Block Header */\n    /* ************ */\n\n    /// @notice          Extracts the transaction merkle root from a block header\n    /// @dev             Use verifyHash256Merkle to verify proofs with this root\n    /// @param _header   The header\n    /// @return          The merkle root (little-endian)\n    function extractMerkleRootLE(bytes memory _header) internal pure returns (bytes32) {\n        return _header.slice32(36);\n    }\n\n    /// @notice          Extracts the target from a block header\n    /// @dev             Target is a 256-bit number encoded as a 3-byte mantissa and 1-byte exponent\n    /// @param _header   The header\n    /// @return          The target threshold\n    function extractTarget(bytes memory _header) internal pure returns (uint256) {\n        return extractTargetAt(_header, 0);\n    }\n\n    /// @notice          Extracts the target from a block header\n    /// @dev             Target is a 256-bit number encoded as a 3-byte mantissa and 1-byte exponent\n    /// @param _header   The array containing the header\n    /// @param at        The start of the header\n    /// @return          The target threshold\n    function extractTargetAt(bytes memory _header, uint256 at) internal pure returns (uint256) {\n        uint24 _m = uint24(_header.slice3(72 + at));\n        uint8 _e = uint8(_header[75 + at]);\n        uint256 _mantissa = uint256(reverseUint24(_m));\n        uint _exponent = _e - 3;\n\n        return _mantissa * (256 ** _exponent);\n    }\n\n    /// @notice          Calculate difficulty from the difficulty 1 target and current target\n    /// @dev             Difficulty 1 is 0x1d00ffff on mainnet and testnet\n    /// @dev             Difficulty 1 is a 256-bit number encoded as a 3-byte mantissa and 1-byte exponent\n    /// @param _target   The current target\n    /// @return          The block difficulty (bdiff)\n    function calculateDifficulty(uint256 _target) internal pure returns (uint256) {\n        // Difficulty 1 calculated from 0x1d00ffff\n        return DIFF1_TARGET.div(_target);\n    }\n\n    /// @notice          Extracts the previous block's hash from a block header\n    /// @dev             Block headers do NOT include block number :(\n    /// @param _header   The header\n    /// @return          The previous block's hash (little-endian)\n    function extractPrevBlockLE(bytes memory _header) internal pure returns (bytes32) {\n        return _header.slice32(4);\n    }\n\n    /// @notice          Extracts the previous block's hash from a block header\n    /// @dev             Block headers do NOT include block number :(\n    /// @param _header   The array containing the header\n    /// @param at        The start of the header\n    /// @return          The previous block's hash (little-endian)\n    function extractPrevBlockLEAt(\n        bytes memory _header,\n        uint256 at\n    ) internal pure returns (bytes32) {\n        return _header.slice32(4 + at);\n    }\n\n    /// @notice          Extracts the timestamp from a block header\n    /// @dev             Time is not 100% reliable\n    /// @param _header   The header\n    /// @return          The timestamp (little-endian bytes)\n    function extractTimestampLE(bytes memory _header) internal pure returns (bytes4) {\n        return _header.slice4(68);\n    }\n\n    /// @notice          Extracts the timestamp from a block header\n    /// @dev             Time is not 100% reliable\n    /// @param _header   The header\n    /// @return          The timestamp (uint)\n    function extractTimestamp(bytes memory _header) internal pure returns (uint32) {\n        return reverseUint32(uint32(extractTimestampLE(_header)));\n    }\n\n    /// @notice          Extracts the expected difficulty from a block header\n    /// @dev             Does NOT verify the work\n    /// @param _header   The header\n    /// @return          The difficulty as an integer\n    function extractDifficulty(bytes memory _header) internal pure returns (uint256) {\n        return calculateDifficulty(extractTarget(_header));\n    }\n\n    /// @notice          Concatenates and hashes two inputs for merkle proving\n    /// @param _a        The first hash\n    /// @param _b        The second hash\n    /// @return          The double-sha256 of the concatenated hashes\n    function _hash256MerkleStep(bytes memory _a, bytes memory _b) internal view returns (bytes32) {\n        return hash256View(abi.encodePacked(_a, _b));\n    }\n\n    /// @notice          Concatenates and hashes two inputs for merkle proving\n    /// @param _a        The first hash\n    /// @param _b        The second hash\n    /// @return          The double-sha256 of the concatenated hashes\n    function _hash256MerkleStep(bytes32 _a, bytes32 _b) internal view returns (bytes32) {\n        return hash256Pair(_a, _b);\n    }\n\n\n    /// @notice          Verifies a Bitcoin-style merkle tree\n    /// @dev             Leaves are 0-indexed. Inefficient version.\n    /// @param _proof    The proof. Tightly packed LE sha256 hashes. The last hash is the root\n    /// @param _index    The index of the leaf\n    /// @return          true if the proof is valid, else false\n    function verifyHash256Merkle(bytes memory _proof, uint _index) internal view returns (bool) {\n        // Not an even number of hashes\n        if (_proof.length % 32 != 0) {\n            return false;\n        }\n\n        // Special case for coinbase-only blocks\n        if (_proof.length == 32) {\n            return true;\n        }\n\n        // Should never occur\n        if (_proof.length == 64) {\n            return false;\n        }\n\n        bytes32 _root = _proof.slice32(_proof.length - 32);\n        bytes32 _current = _proof.slice32(0);\n        bytes memory _tree = _proof.slice(32, _proof.length - 64);\n\n        return verifyHash256Merkle(_current, _tree, _root, _index);\n    }\n\n    /// @notice          Verifies a Bitcoin-style merkle tree\n    /// @dev             Leaves are 0-indexed. Efficient version.\n    /// @param _leaf     The leaf of the proof. LE sha256 hash.\n    /// @param _tree     The intermediate nodes in the proof.\n    ///                  Tightly packed LE sha256 hashes.\n    /// @param _root     The root of the proof. LE sha256 hash.\n    /// @param _index    The index of the leaf\n    /// @return          true if the proof is valid, else false\n    function verifyHash256Merkle(\n        bytes32 _leaf,\n        bytes memory _tree,\n        bytes32 _root,\n        uint _index\n    ) internal view returns (bool) {\n        // Not an even number of hashes\n        if (_tree.length % 32 != 0) {\n            return false;\n        }\n\n        // Should never occur\n        if (_tree.length == 0) {\n            return false;\n        }\n\n        uint _idx = _index;\n        bytes32 _current = _leaf;\n\n        // i moves in increments of 32\n        for (uint i = 0; i < _tree.length; i += 32) {\n            if (_idx % 2 == 1) {\n                _current = _hash256MerkleStep(_tree.slice32(i), _current);\n            } else {\n                _current = _hash256MerkleStep(_current, _tree.slice32(i));\n            }\n            _idx = _idx >> 1;\n        }\n        return _current == _root;\n    }\n\n    /*\n    NB: https://github.com/bitcoin/bitcoin/blob/78dae8caccd82cfbfd76557f1fb7d7557c7b5edb/src/pow.cpp#L49-L72\n    NB: We get a full-bitlength target from this. For comparison with\n        header-encoded targets we need to mask it with the header target\n        e.g. (full & truncated) == truncated\n    */\n    /// @notice                 performs the bitcoin difficulty retarget\n    /// @dev                    implements the Bitcoin algorithm precisely\n    /// @param _previousTarget  the target of the previous period\n    /// @param _firstTimestamp  the timestamp of the first block in the difficulty period\n    /// @param _secondTimestamp the timestamp of the last block in the difficulty period\n    /// @return                 the new period's target threshold\n    function retargetAlgorithm(\n        uint256 _previousTarget,\n        uint256 _firstTimestamp,\n        uint256 _secondTimestamp\n    ) internal pure returns (uint256) {\n        uint256 _elapsedTime = _secondTimestamp.sub(_firstTimestamp);\n\n        // Normalize ratio to factor of 4 if very long or very short\n        if (_elapsedTime < RETARGET_PERIOD.div(4)) {\n            _elapsedTime = RETARGET_PERIOD.div(4);\n        }\n        if (_elapsedTime > RETARGET_PERIOD.mul(4)) {\n            _elapsedTime = RETARGET_PERIOD.mul(4);\n        }\n\n        /*\n          NB: high targets e.g. ffff0020 can cause overflows here\n              so we divide it by 256**2, then multiply by 256**2 later\n              we know the target is evenly divisible by 256**2, so this isn't an issue\n        */\n\n        uint256 _adjusted = _previousTarget.div(65536).mul(_elapsedTime);\n        return _adjusted.div(RETARGET_PERIOD).mul(65536);\n    }\n}\n"

    },

    "@keep-network/bitcoin-spv-sol/contracts/BytesLib.sol": {

      "content": "pragma solidity ^0.8.4;\n\n/*\n\nhttps://github.com/GNSPS/solidity-bytes-utils/\n\nThis is free and unencumbered software released into the public domain.\n\nAnyone is free to copy, modify, publish, use, compile, sell, or\ndistribute this software, either in source code form or as a compiled\nbinary, for any purpose, commercial or non-commercial, and by any\nmeans.\n\nIn jurisdictions that recognize copyright laws, the author or authors\nof this software dedicate any and all copyright interest in the\nsoftware to the public domain. We make this dedication for the benefit\nof the public at large and to the detriment of our heirs and\nsuccessors. We intend this dedication to be an overt act of\nrelinquishment in perpetuity of all present and future rights to this\nsoftware under copyright law.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\nOTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\nARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n\nFor more information, please refer to <https://unlicense.org>\n*/\n\n\n/** @title BytesLib **/\n/** @author https://github.com/GNSPS **/\n\nlibrary BytesLib {\n    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n                add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n                not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n            // Read the first 32 bytes of _preBytes storage, which is the length\n            // of the array. (We don't need to use the offset into the slot\n            // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n                // Since the new array still fits in the slot, we just need to\n                // update the contents of the slot.\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                    _preBytes.slot,\n                    // all the modifications to the slot are inside this\n                    // next block\n                    add(\n                        // we can just add to the slot contents because the\n                        // bytes we want to change are the LSBs\n                        fslot,\n                        add(\n                            mul(\n                                div(\n                                    // load the bytes from memory\n                                    mload(add(_postBytes, 0x20)),\n                                    // zero all bytes to the right\n                                    exp(0x100, sub(32, mlength))\n                        ),\n                        // and now shift left the number of bytes to\n                        // leave space for the length in the slot\n                        exp(0x100, sub(32, newlength))\n                        ),\n                        // increase length by the double of the memory\n                        // bytes length\n                        mul(mlength, 2)\n                        )\n                    )\n                )\n            }\n            case 1 {\n                // The stored value fits in the slot, but the combined value\n                // will exceed it.\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // The contents of the _postBytes array start 32 bytes into\n                // the structure. Our first read should obtain the `submod`\n                // bytes that can fit into the unused space in the last word\n                // of the stored array. To get this, we read 32 bytes starting\n                // from `submod`, so the data we read overlaps with the array\n                // contents by `submod` bytes. Masking the lowest-order\n                // `submod` bytes allows us to add that value directly to the\n                // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                    sc,\n                    add(\n                        and(\n                            fslot,\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                    ),\n                    and(mload(mc), mask)\n                    )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // Copy over the first `submod` bytes of the new data as in\n                // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(bytes memory _bytes, uint _start, uint _length) internal  pure returns (bytes memory res) {\n        if (_length == 0) {\n            return hex\"\";\n        }\n        uint _end = _start + _length;\n        require(_end > _start && _bytes.length >= _end, \"Slice out of bounds\");\n\n        assembly {\n            // Alloc bytes array with additional 32 bytes afterspace and assign it's size\n            res := mload(0x40)\n            mstore(0x40, add(add(res, 64), _length))\n            mstore(res, _length)\n\n            // Compute distance between source and destination pointers\n            let diff := sub(res, add(_bytes, _start))\n\n            for {\n                let src := add(add(_bytes, 32), _start)\n                let end := add(src, _length)\n            } lt(src, end) {\n                src := add(src, 32)\n            } {\n                mstore(add(src, diff), mload(src))\n            }\n        }\n    }\n\n    /// @notice Take a slice of the byte array, overwriting the destination.\n    /// The length of the slice will equal the length of the destination array.\n    /// @dev Make sure the destination array has afterspace if required.\n    /// @param _bytes The source array\n    /// @param _dest The destination array.\n    /// @param _start The location to start in the source array.\n    function sliceInPlace(\n        bytes memory _bytes,\n        bytes memory _dest,\n        uint _start\n    ) internal pure {\n        uint _length = _dest.length;\n        uint _end = _start + _length;\n        require(_end > _start && _bytes.length >= _end, \"Slice out of bounds\");\n\n        assembly {\n            for {\n                let src := add(add(_bytes, 32), _start)\n                let res := add(_dest, 32)\n                let end := add(src, _length)\n            } lt(src, end) {\n                src := add(src, 32)\n                res := add(res, 32)\n            } {\n                mstore(res, mload(src))\n            }\n        }\n    }\n\n    // Static slice functions, no bounds checking\n    /// @notice take a 32-byte slice from the specified position\n    function slice32(bytes memory _bytes, uint _start) internal pure returns (bytes32 res) {\n        assembly {\n            res := mload(add(add(_bytes, 32), _start))\n        }\n    }\n\n    /// @notice take a 20-byte slice from the specified position\n    function slice20(bytes memory _bytes, uint _start) internal pure returns (bytes20) {\n        return bytes20(slice32(_bytes, _start));\n    }\n\n    /// @notice take a 8-byte slice from the specified position\n    function slice8(bytes memory _bytes, uint _start) internal pure returns (bytes8) {\n        return bytes8(slice32(_bytes, _start));\n    }\n\n    /// @notice take a 4-byte slice from the specified position\n    function slice4(bytes memory _bytes, uint _start) internal pure returns (bytes4) {\n        return bytes4(slice32(_bytes, _start));\n    }\n\n    /// @notice take a 3-byte slice from the specified position\n    function slice3(bytes memory _bytes, uint _start) internal pure returns (bytes3) {\n        return bytes3(slice32(_bytes, _start));\n    }\n\n    /// @notice take a 2-byte slice from the specified position\n    function slice2(bytes memory _bytes, uint _start) internal pure returns (bytes2) {\n        return bytes2(slice32(_bytes, _start));\n    }\n\n    function toAddress(bytes memory _bytes, uint _start) internal  pure returns (address) {\n        uint _totalLen = _start + 20;\n        require(_totalLen > _start && _bytes.length >= _totalLen, \"Address conversion out of bounds.\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint(bytes memory _bytes, uint _start) internal  pure returns (uint256) {\n        uint _totalLen = _start + 32;\n        require(_totalLen > _start && _bytes.length >= _totalLen, \"Uint conversion out of bounds.\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                    // the next line is the loop condition:\n                    // while(uint(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // slength can contain both the length and contents of the array\n                // if length < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while(uint(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function toBytes32(bytes memory _source) pure internal returns (bytes32 result) {\n        if (_source.length == 0) {\n            return 0x0;\n        }\n\n        assembly {\n            result := mload(add(_source, 32))\n        }\n    }\n\n    function keccak256Slice(bytes memory _bytes, uint _start, uint _length) pure internal returns (bytes32 result) {\n        uint _end = _start + _length;\n        require(_end > _start && _bytes.length >= _end, \"Slice out of bounds\");\n\n        assembly {\n            result := keccak256(add(add(_bytes, 32), _start), _length)\n        }\n    }\n}\n"

    },

    "@keep-network/bitcoin-spv-sol/contracts/SafeMath.sol": {

      "content": "pragma solidity ^0.8.4;\n\n/*\nThe MIT License (MIT)\n\nCopyright (c) 2016 Smart Contract Solutions, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n    /**\n     * @dev Multiplies two numbers, throws on overflow.\n     */\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (_a == 0) {\n            return 0;\n        }\n\n        c = _a * _b;\n        require(c / _a == _b, \"Overflow during multiplication.\");\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two numbers, truncating the quotient.\n     */\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        // assert(_b > 0); // Solidity automatically throws when dividing by 0\n        // uint256 c = _a / _b;\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n        return _a / _b;\n    }\n\n    /**\n     * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        require(_b <= _a, \"Underflow during subtraction.\");\n        return _a - _b;\n    }\n\n    /**\n     * @dev Adds two numbers, throws on overflow.\n     */\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n        c = _a + _b;\n        require(c >= _a, \"Overflow during addition.\");\n        return c;\n    }\n}\n"

    },

    "@keep-network/bitcoin-spv-sol/contracts/ValidateSPV.sol": {

      "content": "pragma solidity ^0.8.4;\n\n/** @title ValidateSPV*/\n/** @author Summa (https://summa.one) */\n\nimport {BytesLib} from \"./BytesLib.sol\";\nimport {SafeMath} from \"./SafeMath.sol\";\nimport {BTCUtils} from \"./BTCUtils.sol\";\n\n\nlibrary ValidateSPV {\n\n    using BTCUtils for bytes;\n    using BTCUtils for uint256;\n    using BytesLib for bytes;\n    using SafeMath for uint256;\n\n    enum InputTypes { NONE, LEGACY, COMPATIBILITY, WITNESS }\n    enum OutputTypes { NONE, WPKH, WSH, OP_RETURN, PKH, SH, NONSTANDARD }\n\n    uint256 constant ERR_BAD_LENGTH = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n    uint256 constant ERR_INVALID_CHAIN = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe;\n    uint256 constant ERR_LOW_WORK = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd;\n\n    function getErrBadLength() internal pure returns (uint256) {\n        return ERR_BAD_LENGTH;\n    }\n\n    function getErrInvalidChain() internal pure returns (uint256) {\n        return ERR_INVALID_CHAIN;\n    }\n\n    function getErrLowWork() internal pure returns (uint256) {\n        return ERR_LOW_WORK;\n    }\n\n    /// @notice                     Validates a tx inclusion in the block\n    /// @dev                        `index` is not a reliable indicator of location within a block\n    /// @param _txid                The txid (LE)\n    /// @param _merkleRoot          The merkle root (as in the block header)\n    /// @param _intermediateNodes   The proof's intermediate nodes (digests between leaf and root)\n    /// @param _index               The leaf's index in the tree (0-indexed)\n    /// @return                     true if fully valid, false otherwise\n    function prove(\n        bytes32 _txid,\n        bytes32 _merkleRoot,\n        bytes memory _intermediateNodes,\n        uint _index\n    ) internal view returns (bool) {\n        // Shortcut the empty-block case\n        if (_txid == _merkleRoot && _index == 0 && _intermediateNodes.length == 0) {\n            return true;\n        }\n\n        // If the Merkle proof failed, bubble up error\n        return BTCUtils.verifyHash256Merkle(\n            _txid,\n            _intermediateNodes,\n            _merkleRoot,\n            _index\n        );\n    }\n\n    /// @notice             Hashes transaction to get txid\n    /// @dev                Supports Legacy and Witness\n    /// @param _version     4-bytes version\n    /// @param _vin         Raw bytes length-prefixed input vector\n    /// @param _vout        Raw bytes length-prefixed output vector\n    /// @param _locktime    4-byte tx locktime\n    /// @return             32-byte transaction id, little endian\n    function calculateTxId(\n        bytes4 _version,\n        bytes memory _vin,\n        bytes memory _vout,\n        bytes4 _locktime\n    ) internal view returns (bytes32) {\n        // Get transaction hash double-Sha256(version + nIns + inputs + nOuts + outputs + locktime)\n        return abi.encodePacked(_version, _vin, _vout, _locktime).hash256View();\n    }\n\n    /// @notice                  Checks validity of header chain\n    /// @notice                  Compares the hash of each header to the prevHash in the next header\n    /// @param headers           Raw byte array of header chain\n    /// @return totalDifficulty  The total accumulated difficulty of the header chain, or an error code\n    function validateHeaderChain(\n        bytes memory headers\n    ) internal view returns (uint256 totalDifficulty) {\n\n        // Check header chain length\n        if (headers.length % 80 != 0) {return ERR_BAD_LENGTH;}\n\n        // Initialize header start index\n        bytes32 digest;\n\n        totalDifficulty = 0;\n\n        for (uint256 start = 0; start < headers.length; start += 80) {\n\n            // After the first header, check that headers are in a chain\n            if (start != 0) {\n                if (!validateHeaderPrevHash(headers, start, digest)) {return ERR_INVALID_CHAIN;}\n            }\n\n            // ith header target\n            uint256 target = headers.extractTargetAt(start);\n\n            // Require that the header has sufficient work\n            digest = headers.hash256Slice(start, 80);\n            if(uint256(digest).reverseUint256() > target) {\n                return ERR_LOW_WORK;\n            }\n\n            // Add ith header difficulty to difficulty sum\n            totalDifficulty = totalDifficulty + target.calculateDifficulty();\n        }\n    }\n\n    /// @notice             Checks validity of header work\n    /// @param digest       Header digest\n    /// @param target       The target threshold\n    /// @return             true if header work is valid, false otherwise\n    function validateHeaderWork(\n        bytes32 digest,\n        uint256 target\n    ) internal pure returns (bool) {\n        if (digest == bytes32(0)) {return false;}\n        return (uint256(digest).reverseUint256() < target);\n    }\n\n    /// @notice                     Checks validity of header chain\n    /// @dev                        Compares current header prevHash to previous header's digest\n    /// @param headers              The raw bytes array containing the header\n    /// @param at                   The position of the header\n    /// @param prevHeaderDigest     The previous header's digest\n    /// @return                     true if the connect is valid, false otherwise\n    function validateHeaderPrevHash(\n        bytes memory headers,\n        uint256 at,\n        bytes32 prevHeaderDigest\n    ) internal pure returns (bool) {\n\n        // Extract prevHash of current header\n        bytes32 prevHash = headers.extractPrevBlockLEAt(at);\n\n        // Compare prevHash of current header to previous header's digest\n        if (prevHash != prevHeaderDigest) {return false;}\n\n        return true;\n    }\n}\n"

    },

    "@keep-network/random-beacon/contracts/Reimbursable.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-only\n//\n// ▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n//   ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n// ▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n//\n//                           Trust math, not hardware.\n\npragma solidity 0.8.17;\n\nimport \"./ReimbursementPool.sol\";\n\nabstract contract Reimbursable {\n    // The variable should be initialized by the implementing contract.\n    // slither-disable-next-line uninitialized-state\n    ReimbursementPool public reimbursementPool;\n\n    // Reserved storage space in case we need to add more variables,\n    // since there are upgradeable contracts that inherit from this one.\n    // See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n    // slither-disable-next-line unused-state\n    uint256[49] private __gap;\n\n    event ReimbursementPoolUpdated(address newReimbursementPool);\n\n    modifier refundable(address receiver) {\n        uint256 gasStart = gasleft();\n        _;\n        reimbursementPool.refund(gasStart - gasleft(), receiver);\n    }\n\n    modifier onlyReimbursableAdmin() virtual {\n        _;\n    }\n\n    function updateReimbursementPool(ReimbursementPool _reimbursementPool)\n        external\n        onlyReimbursableAdmin\n    {\n        emit ReimbursementPoolUpdated(address(_reimbursementPool));\n\n        reimbursementPool = _reimbursementPool;\n    }\n}\n"

    },

    "@keep-network/random-beacon/contracts/ReimbursementPool.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-only\n//\n// ▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n//   ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n//   ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n// ▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n// ▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n//\n//                           Trust math, not hardware.\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract ReimbursementPool is Ownable, ReentrancyGuard {\n    /// @notice Authorized contracts that can interact with the reimbursment pool.\n    ///         Authorization can be granted and removed by the owner.\n    mapping(address => bool) public isAuthorized;\n\n    /// @notice Static gas includes:\n    ///         - cost of the refund function\n    ///         - base transaction cost\n    uint256 public staticGas;\n\n    /// @notice Max gas price used to reimburse a transaction submitter. Protects\n    ///         against malicious operator-miners.\n    uint256 public maxGasPrice;\n\n    event StaticGasUpdated(uint256 newStaticGas);\n\n    event MaxGasPriceUpdated(uint256 newMaxGasPrice);\n\n    event SendingEtherFailed(uint256 refundAmount, address receiver);\n\n    event AuthorizedContract(address thirdPartyContract);\n\n    event UnauthorizedContract(address thirdPartyContract);\n\n    event FundsWithdrawn(uint256 withdrawnAmount, address receiver);\n\n    constructor(uint256 _staticGas, uint256 _maxGasPrice) {\n        staticGas = _staticGas;\n        maxGasPrice = _maxGasPrice;\n    }\n\n    /// @notice Receive ETH\n    receive() external payable {}\n\n    /// @notice Refunds ETH to a spender for executing specific transactions.\n    /// @dev Ignoring the result of sending ETH to a receiver is made on purpose.\n    ///      For EOA receiving ETH should always work. If a receiver is a smart\n    ///      contract, then we do not want to fail a transaction, because in some\n    ///      cases the refund is done at the very end of multiple calls where all\n    ///      the previous calls were already paid off. It is a receiver's smart\n    ///      contract resposibility to make sure it can receive ETH.\n    /// @dev Only authorized contracts are allowed calling this function.\n    /// @param gasSpent Gas spent on a transaction that needs to be reimbursed.\n    /// @param receiver Address where the reimbursment is sent.\n    function refund(uint256 gasSpent, address receiver) external nonReentrant {\n        require(\n            isAuthorized[msg.sender],\n            \"Contract is not authorized for a refund\"\n        );\n        require(receiver != address(0), \"Receiver's address cannot be zero\");\n\n        uint256 gasPrice = tx.gasprice < maxGasPrice\n            ? tx.gasprice\n            : maxGasPrice;\n\n        uint256 refundAmount = (gasSpent + staticGas) * gasPrice;\n\n        /* solhint-disable avoid-low-level-calls */\n        // slither-disable-next-line low-level-calls,unchecked-lowlevel\n        (bool sent, ) = receiver.call{value: refundAmount}(\"\");\n        /* solhint-enable avoid-low-level-calls */\n        if (!sent) {\n            // slither-disable-next-line reentrancy-events\n            emit SendingEtherFailed(refundAmount, receiver);\n        }\n    }\n\n    /// @notice Authorize a contract that can interact with this reimbursment pool.\n    ///         Can be authorized by the owner only.\n    /// @param _contract Authorized contract.\n    function authorize(address _contract) external onlyOwner {\n        isAuthorized[_contract] = true;\n\n        emit AuthorizedContract(_contract);\n    }\n\n    /// @notice Unauthorize a contract that was previously authorized to interact\n    ///         with this reimbursment pool. Can be unauthorized by the\n    ///         owner only.\n    /// @param _contract Authorized contract.\n    function unauthorize(address _contract) external onlyOwner {\n        delete isAuthorized[_contract];\n\n        emit UnauthorizedContract(_contract);\n    }\n\n    /// @notice Setting a static gas cost for executing a transaction. Can be set\n    ///         by the owner only.\n    /// @param _staticGas Static gas cost.\n    function setStaticGas(uint256 _staticGas) external onlyOwner {\n        staticGas = _staticGas;\n\n        emit StaticGasUpdated(_staticGas);\n    }\n\n    /// @notice Setting a max gas price for transactions. Can be set by the\n    ///         owner only.\n    /// @param _maxGasPrice Max gas price used to reimburse tx submitters.\n    function setMaxGasPrice(uint256 _maxGasPrice) external onlyOwner {\n        maxGasPrice = _maxGasPrice;\n\n        emit MaxGasPriceUpdated(_maxGasPrice);\n    }\n\n    /// @notice Withdraws all ETH from this pool which are sent to a given\n    ///         address. Can be set by the owner only.\n    /// @param receiver An address where ETH is sent.\n    function withdrawAll(address receiver) external onlyOwner {\n        withdraw(address(this).balance, receiver);\n    }\n\n    /// @notice Withdraws ETH amount from this pool which are sent to a given\n    ///         address. Can be set by the owner only.\n    /// @param amount Amount to withdraw from the pool.\n    /// @param receiver An address where ETH is sent.\n    function withdraw(uint256 amount, address receiver) public onlyOwner {\n        require(\n            address(this).balance >= amount,\n            \"Insufficient contract balance\"\n        );\n        require(receiver != address(0), \"Receiver's address cannot be zero\");\n\n        emit FundsWithdrawn(amount, receiver);\n\n        /* solhint-disable avoid-low-level-calls */\n        // slither-disable-next-line low-level-calls,arbitrary-send\n        (bool sent, ) = receiver.call{value: amount}(\"\");\n        /* solhint-enable avoid-low-level-calls */\n        require(sent, \"Failed to send Ether\");\n    }\n}\n"

    },

    "@openzeppelin/contracts/access/Ownable.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"

    },

    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"

    },

    "@openzeppelin/contracts/utils/Context.sol": {

      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"

    },

    "contracts/bridge/IRelay.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\n// ██████████████     ▐████▌     ██████████████\n// ██████████████     ▐████▌     ██████████████\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n// ██████████████     ▐████▌     ██████████████\n// ██████████████     ▐████▌     ██████████████\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n\npragma solidity 0.8.17;\n\n/// @title Interface for the Bitcoin relay\n/// @notice Contains only the methods needed by tBTC v2. The Bitcoin relay\n///         provides the difficulty of the previous and current epoch. One\n///         difficulty epoch spans 2016 blocks.\ninterface IRelay {\n    /// @notice Returns the difficulty of the current epoch.\n    function getCurrentEpochDifficulty() external view returns (uint256);\n\n    /// @notice Returns the difficulty of the previous epoch.\n    function getPrevEpochDifficulty() external view returns (uint256);\n}\n"

    },

    "contracts/relay/LightRelay.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\n// ██████████████     ▐████▌     ██████████████\n// ██████████████     ▐████▌     ██████████████\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n// ██████████████     ▐████▌     ██████████████\n// ██████████████     ▐████▌     ██████████████\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {BytesLib} from \"@keep-network/bitcoin-spv-sol/contracts/BytesLib.sol\";\nimport {BTCUtils} from \"@keep-network/bitcoin-spv-sol/contracts/BTCUtils.sol\";\nimport {ValidateSPV} from \"@keep-network/bitcoin-spv-sol/contracts/ValidateSPV.sol\";\n\nimport \"../bridge/IRelay.sol\";\n\nstruct Epoch {\n    uint32 timestamp;\n    // By definition, bitcoin targets have at least 32 leading zero bits.\n    // Thus we can only store the bits that aren't guaranteed to be 0.\n    uint224 target;\n}\n\ninterface ILightRelay is IRelay {\n    event Genesis(uint256 blockHeight);\n    event Retarget(uint256 oldDifficulty, uint256 newDifficulty);\n    event ProofLengthChanged(uint256 newLength);\n    event AuthorizationRequirementChanged(bool newStatus);\n    event SubmitterAuthorized(address submitter);\n    event SubmitterDeauthorized(address submitter);\n\n    function retarget(bytes memory headers) external;\n\n    function validateChain(bytes memory headers)\n        external\n        view\n        returns (uint256 startingHeaderTimestamp, uint256 headerCount);\n\n    function getBlockDifficulty(uint256 blockNumber)\n        external\n        view\n        returns (uint256);\n\n    function getEpochDifficulty(uint256 epochNumber)\n        external\n        view\n        returns (uint256);\n\n    function getRelayRange()\n        external\n        view\n        returns (uint256 relayGenesis, uint256 currentEpochEnd);\n}\n\nlibrary RelayUtils {\n    using BytesLib for bytes;\n\n    /// @notice Extract the timestamp of the header at the given position.\n    /// @param headers Byte array containing the header of interest.\n    /// @param at The start of the header in the array.\n    /// @return The timestamp of the header.\n    /// @dev Assumes that the specified position contains a valid header.\n    /// Performs no validation whatsoever.\n    function extractTimestampAt(bytes memory headers, uint256 at)\n        internal\n        pure\n        returns (uint32)\n    {\n        return BTCUtils.reverseUint32(uint32(headers.slice4(68 + at)));\n    }\n}\n\n/// @dev THE RELAY MUST NOT BE USED BEFORE GENESIS AND AT LEAST ONE RETARGET.\ncontract LightRelay is Ownable, ILightRelay {\n    using BytesLib for bytes;\n    using BTCUtils for bytes;\n    using ValidateSPV for bytes;\n    using RelayUtils for bytes;\n\n    bool public ready;\n    // Whether the relay requires the address submitting a retarget to be\n    // authorised in advance by governance.\n    bool public authorizationRequired;\n    // Number of blocks required for each side of a retarget proof:\n    // a retarget must provide `proofLength` blocks before the retarget\n    // and `proofLength` blocks after it.\n    // Governable\n    // Should be set to a fairly high number (e.g. 20-50) in production.\n    uint64 public proofLength;\n    // The number of the first epoch recorded by the relay.\n    // This should equal the height of the block starting the genesis epoch,\n    // divided by 2016, but this is not enforced as the relay has no\n    // information about block numbers.\n    uint64 public genesisEpoch;\n    // The number of the latest epoch whose difficulty is proven to the relay.\n    // If the genesis epoch's number is set correctly, and retargets along the\n    // way have been legitimate, this equals the height of the block starting\n    // the most recent epoch, divided by 2016.\n    uint64 public currentEpoch;\n\n    uint256 internal currentEpochDifficulty;\n    uint256 internal prevEpochDifficulty;\n\n    // Each epoch from genesis to the current one, keyed by their numbers.\n    mapping(uint256 => Epoch) internal epochs;\n\n    mapping(address => bool) public isAuthorized;\n\n    modifier relayActive() {\n        require(ready, \"Relay is not ready for use\");\n        _;\n    }\n\n    /// @notice Establish a starting point for the relay by providing the\n    /// target, timestamp and blockheight of the first block of the relay\n    /// genesis epoch.\n    /// @param genesisHeader The first block header of the genesis epoch.\n    /// @param genesisHeight The block number of the first block of the epoch.\n    /// @param genesisProofLength The number of blocks required to accept a\n    /// proof.\n    /// @dev If the relay is used by querying the current and previous epoch\n    /// difficulty, at least one retarget needs to be provided after genesis;\n    /// otherwise the prevEpochDifficulty will be uninitialised and zero.\n    function genesis(\n        bytes calldata genesisHeader,\n        uint256 genesisHeight,\n        uint64 genesisProofLength\n    ) external onlyOwner {\n        require(!ready, \"Genesis already performed\");\n\n        require(genesisHeader.length == 80, \"Invalid genesis header length\");\n\n        require(\n            genesisHeight % 2016 == 0,\n            \"Invalid height of relay genesis block\"\n        );\n\n        require(genesisProofLength < 2016, \"Proof length excessive\");\n        require(genesisProofLength > 0, \"Proof length may not be zero\");\n\n        genesisEpoch = uint64(genesisHeight / 2016);\n        currentEpoch = genesisEpoch;\n        uint256 genesisTarget = genesisHeader.extractTarget();\n        uint256 genesisTimestamp = genesisHeader.extractTimestamp();\n        epochs[genesisEpoch] = Epoch(\n            uint32(genesisTimestamp),\n            uint224(genesisTarget)\n        );\n        proofLength = genesisProofLength;\n        currentEpochDifficulty = BTCUtils.calculateDifficulty(genesisTarget);\n        ready = true;\n\n        emit Genesis(genesisHeight);\n    }\n\n    /// @notice Set the number of blocks required to accept a header chain.\n    /// @param newLength The required number of blocks. Must be less than 2016.\n    /// @dev For production, a high number (e.g. 20-50) is recommended.\n    /// Small numbers are accepted but should only be used for testing.\n    function setProofLength(uint64 newLength) external relayActive onlyOwner {\n        require(newLength < 2016, \"Proof length excessive\");\n        require(newLength > 0, \"Proof length may not be zero\");\n        require(newLength != proofLength, \"Proof length unchanged\");\n        proofLength = newLength;\n        emit ProofLengthChanged(newLength);\n    }\n\n    /// @notice Set whether the relay requires retarget submitters to be\n    /// pre-authorised by governance.\n    /// @param status True if authorisation is to be required, false if not.\n    function setAuthorizationStatus(bool status) external onlyOwner {\n        authorizationRequired = status;\n        emit AuthorizationRequirementChanged(status);\n    }\n\n    /// @notice Authorise the given address to submit retarget proofs.\n    /// @param submitter The address to be authorised.\n    function authorize(address submitter) external onlyOwner {\n        isAuthorized[submitter] = true;\n        emit SubmitterAuthorized(submitter);\n    }\n\n    /// @notice Rescind the authorisation of the submitter to retarget.\n    /// @param submitter The address to be deauthorised.\n    function deauthorize(address submitter) external onlyOwner {\n        isAuthorized[submitter] = false;\n        emit SubmitterDeauthorized(submitter);\n    }\n\n    /// @notice Add a new epoch to the relay by providing a proof\n    /// of the difficulty before and after the retarget.\n    /// @param headers A chain of headers including the last X blocks before\n    /// the retarget, followed by the first X blocks after the retarget,\n    /// where X equals the current proof length.\n    /// @dev Checks that the first X blocks are valid in the most recent epoch,\n    /// that the difficulty of the new epoch is calculated correctly according\n    /// to the block timestamps, and that the next X blocks would be valid in\n    /// the new epoch.\n    /// We have no information of block heights, so we cannot enforce that\n    /// retargets only happen every 2016 blocks; instead, we assume that this\n    /// is the case if a valid proof of work is provided.\n    /// It is possible to cheat the relay by providing X blocks from earlier in\n    /// the most recent epoch, and then mining X new blocks after them.\n    /// However, each of these malicious blocks would have to be mined to a\n    /// higher difficulty than the legitimate ones.\n    /// Alternatively, if the retarget has not been performed yet, one could\n    /// first mine X blocks in the old difficulty with timestamps set far in\n    /// the future, and then another X blocks at a greatly reduced difficulty.\n    /// In either case, cheating the realy requires more work than mining X\n    /// legitimate blocks.\n    /// Only the most recent epoch is vulnerable to these attacks; once a\n    /// retarget has been proven to the relay, the epoch is immutable even if a\n    /// contradictory proof were to be presented later.\n    function retarget(bytes memory headers) external relayActive {\n        if (authorizationRequired) {\n            require(isAuthorized[msg.sender], \"Submitter unauthorized\");\n        }\n\n        require(\n            // Require proofLength headers on both sides of the retarget\n            headers.length == (proofLength * 2 * 80),\n            \"Invalid header length\"\n        );\n\n        Epoch storage latest = epochs[currentEpoch];\n\n        uint256 oldTarget = latest.target;\n\n        bytes32 previousHeaderDigest = bytes32(0);\n\n        // Validate old chain\n        for (uint256 i = 0; i < proofLength; i++) {\n            (\n                bytes32 currentDigest,\n                uint256 currentHeaderTarget\n            ) = validateHeader(headers, i * 80, previousHeaderDigest);\n\n            require(\n                currentHeaderTarget == oldTarget,\n                \"Invalid target in pre-retarget headers\"\n            );\n\n            previousHeaderDigest = currentDigest;\n        }\n\n        // get timestamp of retarget block\n        uint256 epochEndTimestamp = headers.extractTimestampAt(\n            (proofLength - 1) * 80\n        );\n\n        // An attacker could produce blocks with timestamps in the future,\n        // in an attempt to reduce the difficulty after the retarget\n        // to make mining the second part of the retarget proof easier.\n        // In particular, the attacker could reuse all but one block\n        // from the legitimate chain, and only mine the last block.\n        // To hinder this, require that the epoch end timestamp does not\n        // exceed the ethereum timestamp.\n        // NOTE: both are unix seconds, so this comparison should be valid.\n        require(\n            /* solhint-disable-next-line not-rely-on-time */\n            epochEndTimestamp < block.timestamp,\n            \"Epoch cannot end in the future\"\n        );\n\n        // Expected target is the full-length target\n        uint256 expectedTarget = BTCUtils.retargetAlgorithm(\n            oldTarget,\n            latest.timestamp,\n            epochEndTimestamp\n        );\n\n        // Mined target is the header-encoded target\n        uint256 minedTarget = 0;\n\n        uint256 epochStartTimestamp = headers.extractTimestampAt(\n            proofLength * 80\n        );\n\n        // validate new chain\n        for (uint256 j = proofLength; j < proofLength * 2; j++) {\n            (\n                bytes32 _currentDigest,\n                uint256 _currentHeaderTarget\n            ) = validateHeader(headers, j * 80, previousHeaderDigest);\n\n            if (minedTarget == 0) {\n                // The new target has not been set, so check its correctness\n                minedTarget = _currentHeaderTarget;\n                require(\n                    // Although the target is a 256-bit number, there are only 32 bits of\n                    // space in the Bitcoin header. Because of that, the version stored in\n                    // the header is a less-precise representation of the actual target\n                    // using base-256 version of scientific notation.\n                    //\n                    // The 256-bit unsigned integer returned from BTCUtils.retargetAlgorithm\n                    // is the precise target value.\n                    // The 256-bit unsigned integer returned from validateHeader is the less\n                    // precise target value because it was read from 32 bits of space of\n                    // Bitcoin block header.\n                    //\n                    // We can't compare the precise and less precise representations together\n                    // so we first mask them to obtain the less precise version:\n                    //   (full & truncated) == truncated\n                    _currentHeaderTarget ==\n                        (expectedTarget & _currentHeaderTarget),\n                    \"Invalid target in new epoch\"\n                );\n            } else {\n                // The new target has been set, so remaining targets should match.\n                require(\n                    _currentHeaderTarget == minedTarget,\n                    \"Unexpected target change after retarget\"\n                );\n            }\n\n            previousHeaderDigest = _currentDigest;\n        }\n\n        currentEpoch = currentEpoch + 1;\n\n        epochs[currentEpoch] = Epoch(\n            uint32(epochStartTimestamp),\n            uint224(minedTarget)\n        );\n\n        uint256 oldDifficulty = currentEpochDifficulty;\n        uint256 newDifficulty = BTCUtils.calculateDifficulty(minedTarget);\n\n        prevEpochDifficulty = oldDifficulty;\n        currentEpochDifficulty = newDifficulty;\n\n        emit Retarget(oldDifficulty, newDifficulty);\n    }\n\n    /// @notice Check whether a given chain of headers should be accepted as\n    /// valid within the rules of the relay.\n    /// If the validation fails, this function throws an exception.\n    /// @param headers A chain of 2 to 2015 bitcoin headers.\n    /// @return startingHeaderTimestamp The timestamp of the first header.\n    /// @return headerCount The number of headers.\n    /// @dev A chain of headers is accepted as valid if:\n    /// - Its length is between 2 and 2015 headers.\n    /// - Headers in the chain are sequential and refer to previous digests.\n    /// - Each header is mined with the correct amount of work.\n    /// - The difficulty in each header matches an epoch of the relay,\n    ///   as determined by the headers' timestamps. The headers must be between\n    ///   the genesis epoch and the latest proven epoch (inclusive).\n    /// If the chain contains a retarget, it is accepted if the retarget has\n    /// already been proven to the relay.\n    /// If the chain contains blocks of an epoch that has not been proven to\n    /// the relay (after a retarget within the header chain, or when the entire\n    /// chain falls within an epoch that has not been proven yet), it will be\n    /// rejected.\n    /// One exception to this is when two subsequent epochs have exactly the\n    /// same difficulty; headers from the latter epoch will be accepted if the\n    /// previous epoch has been proven to the relay.\n    /// This is because it is not possible to distinguish such headers from\n    /// headers of the previous epoch.\n    ///\n    /// If the difficulty increases significantly between relay genesis and the\n    /// present, creating fraudulent proofs for earlier epochs becomes easier.\n    /// Users of the relay should check the timestamps of valid headers and\n    /// only accept appropriately recent ones.\n    function validateChain(bytes memory headers)\n        external\n        view\n        returns (uint256 startingHeaderTimestamp, uint256 headerCount)\n    {\n        require(headers.length % 80 == 0, \"Invalid header length\");\n\n        headerCount = headers.length / 80;\n\n        require(\n            headerCount > 1 && headerCount < 2016,\n            \"Invalid number of headers\"\n        );\n\n        startingHeaderTimestamp = headers.extractTimestamp();\n\n        // Short-circuit the first header's validation.\n        // We validate the header here to get the target which is needed to\n        // precisely identify the epoch.\n        (\n            bytes32 previousHeaderDigest,\n            uint256 currentHeaderTarget\n        ) = validateHeader(headers, 0, bytes32(0));\n\n        Epoch memory nullEpoch = Epoch(0, 0);\n\n        uint256 startingEpochNumber = currentEpoch;\n        Epoch memory startingEpoch = epochs[startingEpochNumber];\n        Epoch memory nextEpoch = nullEpoch;\n\n        // Find the correct epoch for the given chain\n        // Fastest with recent epochs, but able to handle anything after genesis\n        //\n        // The rules for bitcoin timestamps are:\n        // - must be greater than the median of the last 11 blocks' timestamps\n        // - must be less than the network-adjusted time +2 hours\n        //\n        // Because of this, the timestamp of a header may be smaller than the\n        // starting time, or greater than the ending time of its epoch.\n        // However, a valid timestamp is guaranteed to fall within the window\n        // formed by the epochs immediately before and after its timestamp.\n        // We can identify cases like these by comparing the targets.\n        while (startingHeaderTimestamp < startingEpoch.timestamp) {\n            startingEpochNumber -= 1;\n            nextEpoch = startingEpoch;\n            startingEpoch = epochs[startingEpochNumber];\n        }\n\n        // We have identified the centre of the window,\n        // by reaching the most recent epoch whose starting timestamp\n        // or reached before the genesis where epoch slots are empty.\n        // Therefore check that the timestamp is nonzero.\n        require(\n            startingEpoch.timestamp > 0,\n            \"Cannot validate chains before relay genesis\"\n        );\n\n        // The targets don't match. This could be because the block is invalid,\n        // or it could be because of timestamp inaccuracy.\n        // To cover the latter case, check adjacent epochs.\n        if (currentHeaderTarget != startingEpoch.target) {\n            // The target matches the next epoch.\n            // This means we are right at the beginning of the next epoch,\n            // and retargets during the chain should not be possible.\n            if (currentHeaderTarget == nextEpoch.target) {\n                startingEpoch = nextEpoch;\n                nextEpoch = nullEpoch;\n            }\n            // The target doesn't match the next epoch.\n            // Therefore the only valid epoch is the previous one.\n            // Because the timestamp can't be more than 2 hours into the future\n            // we must be right near the end of the epoch,\n            // so a retarget is possible.\n            else {\n                startingEpochNumber -= 1;\n                nextEpoch = startingEpoch;\n                startingEpoch = epochs[startingEpochNumber];\n\n                // We have failed to find a match,\n                // therefore the target has to be invalid.\n                require(\n                    currentHeaderTarget == startingEpoch.target,\n                    \"Invalid target in header chain\"\n                );\n            }\n        }\n\n        // We've found the correct epoch for the first header.\n        // Validate the rest.\n        for (uint256 i = 1; i < headerCount; i++) {\n            bytes32 currentDigest;\n            (currentDigest, currentHeaderTarget) = validateHeader(\n                headers,\n                i * 80,\n                previousHeaderDigest\n            );\n\n            // If the header's target does not match the expected target,\n            // check if a retarget is possible.\n            //\n            // If next epoch timestamp exists, a valid retarget is possible\n            // (if next epoch timestamp doesn't exist, either a retarget has\n            // already happened in this chain, the relay needs a retarget\n            // before this chain can be validated, or a retarget is not allowed\n            // because we know the headers are within a timestamp irregularity\n            // of the previous retarget).\n            //\n            // In this case the target must match the next epoch's target,\n            // and the header's timestamp must match the epoch's start.\n            if (currentHeaderTarget != startingEpoch.target) {\n                uint256 currentHeaderTimestamp = headers.extractTimestampAt(\n                    i * 80\n                );\n\n                require(\n                    nextEpoch.timestamp != 0 &&\n                        currentHeaderTarget == nextEpoch.target &&\n                        currentHeaderTimestamp == nextEpoch.timestamp,\n                    \"Invalid target in header chain\"\n                );\n\n                startingEpoch = nextEpoch;\n                nextEpoch = nullEpoch;\n            }\n\n            previousHeaderDigest = currentDigest;\n        }\n\n        return (startingHeaderTimestamp, headerCount);\n    }\n\n    /// @notice Get the difficulty of the specified block.\n    /// @param blockNumber The number of the block. Must fall within the relay\n    /// range (at or after the relay genesis, and at or before the end of the\n    /// most recent epoch proven to the relay).\n    /// @return The difficulty of the epoch.\n    function getBlockDifficulty(uint256 blockNumber)\n        external\n        view\n        returns (uint256)\n    {\n        return getEpochDifficulty(blockNumber / 2016);\n    }\n\n    /// @notice Get the range of blocks the relay can accept proofs for.\n    /// @dev Assumes that the genesis has been set correctly.\n    /// Additionally, if the next epoch after the current one has the exact\n    /// same difficulty, headers for it can be validated as well.\n    /// This function should be used for informative purposes,\n    /// e.g. to determine whether a retarget must be provided before submitting\n    /// a header chain for validation.\n    /// @return relayGenesis The height of the earliest block that can be\n    /// included in header chains for the relay to validate.\n    /// @return currentEpochEnd The height of the last block that can be\n    /// included in header chains for the relay to validate.\n    function getRelayRange()\n        external\n        view\n        returns (uint256 relayGenesis, uint256 currentEpochEnd)\n    {\n        relayGenesis = genesisEpoch * 2016;\n        currentEpochEnd = (currentEpoch * 2016) + 2015;\n    }\n\n    /// @notice Returns the difficulty of the current epoch.\n    /// @dev returns 0 if the relay is not ready.\n    /// @return The difficulty of the current epoch.\n    function getCurrentEpochDifficulty()\n        external\n        view\n        virtual\n        returns (uint256)\n    {\n        return currentEpochDifficulty;\n    }\n\n    /// @notice Returns the difficulty of the previous epoch.\n    /// @dev Returns 0 if the relay is not ready or has not had a retarget.\n    /// @return The difficulty of the previous epoch.\n    function getPrevEpochDifficulty() external view virtual returns (uint256) {\n        return prevEpochDifficulty;\n    }\n\n    function getCurrentAndPrevEpochDifficulty()\n        external\n        view\n        returns (uint256 current, uint256 previous)\n    {\n        return (currentEpochDifficulty, prevEpochDifficulty);\n    }\n\n    /// @notice Get the difficulty of the specified epoch.\n    /// @param epochNumber The number of the epoch (the height of the first\n    /// block of the epoch, divided by 2016). Must fall within the relay range.\n    /// @return The difficulty of the epoch.\n    function getEpochDifficulty(uint256 epochNumber)\n        public\n        view\n        returns (uint256)\n    {\n        require(epochNumber >= genesisEpoch, \"Epoch is before relay genesis\");\n        require(\n            epochNumber <= currentEpoch,\n            \"Epoch is not proven to the relay yet\"\n        );\n        return BTCUtils.calculateDifficulty(epochs[epochNumber].target);\n    }\n\n    /// @notice Check that the specified header forms a correct chain with the\n    /// digest of the previous header (if provided), and has sufficient work.\n    /// @param headers The byte array containing the header of interest.\n    /// @param start The start of the header in the array.\n    /// @param prevDigest The digest of the previous header\n    /// (optional; providing zeros for the digest skips the check).\n    /// @return digest The digest of the current header.\n    /// @return target The PoW target of the header.\n    /// @dev Throws an exception if the header's chain or PoW are invalid.\n    /// Performs no other validation.\n    function validateHeader(\n        bytes memory headers,\n        uint256 start,\n        bytes32 prevDigest\n    ) internal view returns (bytes32 digest, uint256 target) {\n        // If previous block digest has been provided, require that it matches\n        if (prevDigest != bytes32(0)) {\n            require(\n                headers.validateHeaderPrevHash(start, prevDigest),\n                \"Invalid chain\"\n            );\n        }\n\n        // Require that the header has sufficient work for its stated target\n        target = headers.extractTargetAt(start);\n        digest = headers.hash256Slice(start, 80);\n        require(ValidateSPV.validateHeaderWork(digest, target), \"Invalid work\");\n\n        return (digest, target);\n    }\n}\n"

    },

    "contracts/relay/LightRelayMaintainerProxy.sol": {

      "content": "// SPDX-License-Identifier: GPL-3.0-only\n\n// ██████████████     ▐████▌     ██████████████\n// ██████████████     ▐████▌     ██████████████\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n// ██████████████     ▐████▌     ██████████████\n// ██████████████     ▐████▌     ██████████████\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n//               ▐████▌    ▐████▌\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@keep-network/random-beacon/contracts/Reimbursable.sol\";\nimport \"@keep-network/random-beacon/contracts/ReimbursementPool.sol\";\n\nimport \"./LightRelay.sol\";\n\n/// @title LightRelayMaintainerProxy\n/// @notice The proxy contract that allows the relay maintainers to be refunded\n///         for the spent gas from the `ReimbursementPool`. When proving the\n///         next Bitcoin difficulty epoch, the maintainer calls the\n///         `LightRelayMaintainerProxy` which in turn calls the actual `LightRelay`\n///         contract.\ncontract LightRelayMaintainerProxy is Ownable, Reimbursable {\n    ILightRelay public lightRelay;\n\n    /// @notice Stores the addresses that can maintain the relay. Those\n    ///         addresses are attested by the DAO.\n    /// @dev The goal is to prevent a griefing attack by frontrunning relay\n    ///      maintainer which is responsible for retargetting the relay in the\n    ///      given round. The maintainer's transaction would revert with no gas\n    ///      refund. Having the ability to restrict maintainer addresses is also\n    ///      important in case the underlying relay contract has authorization\n    ///      requirements for callers.\n    mapping(address => bool) public isAuthorized;\n\n    /// @notice Gas that is meant to balance the retarget overall cost. Can be\n    //          updated by the governance based on the current market conditions.\n    uint256 public retargetGasOffset;\n\n    event LightRelayUpdated(address newRelay);\n\n    event MaintainerAuthorized(address indexed maintainer);\n\n    event MaintainerDeauthorized(address indexed maintainer);\n\n    event RetargetGasOffsetUpdated(uint256 retargetGasOffset);\n\n    modifier onlyRelayMaintainer() {\n        require(isAuthorized[msg.sender], \"Caller is not authorized\");\n        _;\n    }\n\n    modifier onlyReimbursableAdmin() override {\n        require(owner() == msg.sender, \"Caller is not the owner\");\n        _;\n    }\n\n    constructor(ILightRelay _lightRelay, ReimbursementPool _reimbursementPool) {\n        require(\n            address(_lightRelay) != address(0),\n            \"Light relay must not be zero address\"\n        );\n        require(\n            address(_reimbursementPool) != address(0),\n            \"Reimbursement pool must not be zero address\"\n        );\n\n        lightRelay = _lightRelay;\n        reimbursementPool = _reimbursementPool;\n\n        retargetGasOffset = 54000;\n    }\n\n    /// @notice Allows the governance to upgrade the `LightRelay` address.\n    /// @dev The function does not implement any governance delay and does not\n    ///      check the status of the `LightRelay`. The Governance implementation\n    ///      needs to ensure all requirements for the upgrade are satisfied\n    ///      before executing this function.\n    function updateLightRelay(ILightRelay _lightRelay) external onlyOwner {\n        require(\n            address(_lightRelay) != address(0),\n            \"New light relay must not be zero address\"\n        );\n\n        lightRelay = _lightRelay;\n        emit LightRelayUpdated(address(_lightRelay));\n    }\n\n    /// @notice Authorizes the given address as a maintainer. Can only be called\n    ///         by the owner and the address of the maintainer must not be\n    ///         already authorized.\n    /// @dev The function does not implement any governance delay.\n    /// @param maintainer The address of the maintainer to be authorized.\n    function authorize(address maintainer) external onlyOwner {\n        require(!isAuthorized[maintainer], \"Maintainer is already authorized\");\n\n        isAuthorized[maintainer] = true;\n        emit MaintainerAuthorized(maintainer);\n    }\n\n    /// @notice Deauthorizes the given address as a maintainer. Can only be\n    ///         called by the owner and the address of the maintainer must be\n    ///         authorized.\n    /// @dev The function does not implement any governance delay.\n    /// @param maintainer The address of the maintainer to be deauthorized.\n    function deauthorize(address maintainer) external onlyOwner {\n        require(isAuthorized[maintainer], \"Maintainer is not authorized\");\n\n        isAuthorized[maintainer] = false;\n        emit MaintainerDeauthorized(maintainer);\n    }\n\n    /// @notice Updates the values of retarget gas offset.\n    /// @dev Can be called only by the contract owner. The caller is responsible\n    ///      for validating the parameter. The function does not implement any\n    ///      governance delay.\n    /// @param newRetargetGasOffset New retarget gas offset.\n    function updateRetargetGasOffset(uint256 newRetargetGasOffset)\n        external\n        onlyOwner\n    {\n        retargetGasOffset = newRetargetGasOffset;\n        emit RetargetGasOffsetUpdated(retargetGasOffset);\n    }\n\n    /// @notice Wraps `LightRelay.retarget` call and reimburses the caller's\n    ///         transaction cost. Can only be called by an authorized relay\n    ///         maintainer.\n    /// @dev See `LightRelay.retarget` function documentation.\n    function retarget(bytes memory headers) external onlyRelayMaintainer {\n        uint256 gasStart = gasleft();\n\n        lightRelay.retarget(headers);\n\n        reimbursementPool.refund(\n            (gasStart - gasleft()) + retargetGasOffset,\n            msg.sender\n        );\n    }\n}\n"

    }

  },

  "settings": {

    "optimizer": {

      "enabled": true,

      "runs": 1000

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "metadata": {

      "useLiteralContent": true

    },

    "libraries": {}

  }

}}