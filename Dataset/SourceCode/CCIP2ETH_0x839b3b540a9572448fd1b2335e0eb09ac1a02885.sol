{{

  "language": "Solidity",

  "sources": {

    "src/CCIP2ETH.sol": {

      "content": "// SPDX-License-Identifier: WTFPL.ETH\npragma solidity >0.8.0 <0.9.0;\n\nimport \"./Interface.sol\";\n\n/**\n * @title Off-Chain ENS Records Manager\n * @author freetib.eth, sshmatrix.eth [https://github.com/namesys-eth]\n * Github : https://github.com/namesys-eth/ccip2-eth-resolver\n * Client : https://namesys.eth.limo\n */\ncontract CCIP2ETH is iCCIP2ETH {\n    /// @dev - Revert on fallback\n    fallback() external payable {\n        revert();\n    }\n\n    /// @dev - Receive donation\n    receive() external payable {\n        emit ThankYou(msg.sender, msg.value);\n    }\n\n    /// Events\n    event ThankYou(address indexed addr, uint256 indexed value);\n    event GatewayUpdated(address indexed oldAddr, address indexed newAddr);\n    event RecordhashUpdated(address indexed owner, bytes32 indexed node, bytes contenthash);\n    event UpdatedWrapper(address indexed newAddr, bool indexed status);\n    event ApprovedSigner(address owner, bytes32 indexed node, address indexed delegate, bool indexed approved);\n    event InterfaceUpdated(bytes4 indexed sig, bool indexed status);\n\n    /// Errors\n    error InvalidSignature(string _message);\n    error InvalidRequest(string _message);\n    error BadConfig(string _message);\n    error NotAuthorised(string _message);\n    error PlsFundDevs();\n\n    /// @dev - ENS Legacy Registry\n    iENS public immutable ENS = iENS(0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e);\n    /// @dev - CCIP-Read Gateways\n    iGatewayManager public gateway;\n    /// @dev - Deployed Chain ID\n    string chainID;\n    /// @dev - Fee to set ownerhash\n    uint256 public ownerhashFees = 0;\n\n    /// Mappings\n    /**\n     * @dev - Domain-specific contenthash storing all other records\n     * @notice - Should be in generic ENS contenthash format or base32/base36 string URL format\n     */\n    mapping(bytes32 => bytes) public recordhash;\n    /// @dev - On-chain singular Manager database\n    /// Note - Manager (= isApprovedSigner) is someone who can manage off-chain records for a domain on behalf of its owner\n    mapping(address => mapping(bytes32 => mapping(address => bool))) public isApprovedSigner;\n    /// @dev - List of all wrapping contracts to be declared in contructor\n    mapping(address => bool) public isWrapper;\n\n    /// Interfaces\n    mapping(bytes4 => bool) public supportsInterface;\n\n    /// @dev - Constructor\n    constructor(address _gateway) {\n        gateway = iGatewayManager(_gateway);\n        chainID = block.chainid == 1 ? \"1\" : \"5\"; // Set ChainID\n        /// @dev - Sets ENS Mainnet wrapper as Wrapper\n        isWrapper[0xD4416b13d2b3a9aBae7AcD5D6C2BbDBE25686401] = true;\n        emit UpdatedWrapper(0xD4416b13d2b3a9aBae7AcD5D6C2BbDBE25686401, true);\n\n        /// @dev - Set necessary interfaces\n        supportsInterface[iERC165.supportsInterface.selector] = true;\n        supportsInterface[iENSIP10.resolve.selector] = true;\n        supportsInterface[type(iERC173).interfaceId] = true;\n        supportsInterface[iCCIP2ETH.setRecordhash.selector] = true;\n        supportsInterface[iCCIP2ETH.setOwnerhash.selector] = true;\n        supportsInterface[iCallbackType.signedRecord.selector] = true;\n        supportsInterface[iCallbackType.signedRedirect.selector] = true;\n    }\n\n    /**\n     * @dev Gets recordhash for a node\n     * @param _node - Namehash of domain.eth, or bytes32(address _Owner)\n     * @return _recordhash - IPNS contenthash that is set as recordhash\n     */\n    function getRecordhash(bytes32 _node) external view returns (bytes memory _recordhash) {\n        _recordhash = recordhash[_node];\n        if (_recordhash.length == 0) {\n            address _owner = ENS.owner(_node);\n            if (isWrapper[_owner]) {\n                _owner = iToken(_owner).ownerOf(uint256(_node));\n            }\n            _recordhash = recordhash[bytes32(uint256(uint160(_owner)))];\n        }\n        if (_recordhash.length == 32 && !gateway.isWeb2(_recordhash)) {\n            _recordhash = abi.encodePacked(hex\"e5010172002408011220\", _recordhash);\n        }\n    }\n\n    /**\n     * @dev Sets regular recordhash for a node\n     * Note - Only ENS owner or manager of node can call\n     * @param _node - Namehash of domain.eth\n     * @param _recordhash - Regular IPNS contenthash to set as recordhash\n     */\n    function setRecordhash(bytes32 _node, bytes calldata _recordhash) external payable {\n        address _owner = ENS.owner(_node);\n        if (isWrapper[_owner]) {\n            _owner = iToken(_owner).ownerOf(uint256(_node));\n        }\n        if (msg.sender != _owner && !isApprovedSigner[_owner][_node][msg.sender]) {\n            revert NotAuthorised(\"NOT_APPROVED\");\n        }\n        recordhash[_node] = _recordhash;\n        emit RecordhashUpdated(msg.sender, _node, _recordhash);\n    }\n\n    /**\n     * @dev Sets short recordhash for a node\n     * Note - Without the constant prefix hex'e5010172002408011220'\n     * Note - Only ENS owner or manager of node can call\n     * @param _node - Namehash of domain.eth\n     * @param _recordhash - Short IPNS contenthash to set as recordhash\n     */\n    function setShortRecordhash(bytes32 _node, bytes32 _recordhash) external payable {\n        address _owner = ENS.owner(_node);\n        if (isWrapper[_owner]) {\n            _owner = iToken(_owner).ownerOf(uint256(_node));\n        }\n        if (msg.sender != _owner && !isApprovedSigner[_owner][_node][msg.sender]) {\n            revert NotAuthorised(\"NOT_APPROVED\");\n        }\n        recordhash[_node] = abi.encodePacked(_recordhash);\n        emit RecordhashUpdated(msg.sender, _node, abi.encodePacked(hex\"e5010172002408011220\", _recordhash));\n    }\n\n    /**\n     * @dev Sets ownerhash for an owner\n     * Note - Wallet-specific fallback recordhash\n     * @param _recordhash - Regular IPNS contenthash to set as ownerhash\n     */\n    function setOwnerhash(bytes calldata _recordhash) external payable {\n        if (msg.value < ownerhashFees) {\n            revert PlsFundDevs();\n        }\n        recordhash[bytes32(uint256(uint160(msg.sender)))] = _recordhash;\n        emit RecordhashUpdated(msg.sender, bytes32(uint256(uint160(msg.sender))), _recordhash);\n    }\n\n    /**\n     * @dev Sets short ownerhash for an owner\n     * Note - Without the constant prefix hex'e5010172002408011220'\n     * Note - Wallet-specific fallback recordhash\n     * @param _recordhash - Short IPNS contenthash to set as ownerhash\n     */\n    function setShortOwnerhash(bytes32 _recordhash) external payable {\n        if (msg.value < ownerhashFees) {\n            revert PlsFundDevs();\n        }\n        recordhash[bytes32(uint256(uint160(msg.sender)))] = abi.encodePacked(_recordhash);\n        emit RecordhashUpdated(\n            msg.sender, bytes32(uint256(uint160(msg.sender))), abi.encodePacked(hex\"e5010172002408011220\", _recordhash)\n        );\n    }\n\n    /**\n     * @dev Sets recordhash for a subnode\n     * Note - Only ENS owner or manager of parent node can call\n     * @param _node - Namehash of domain.eth\n     * @param _subdomain - Subdomain labels; sub.domain.eth = \"sub\"\n     * @param _recordhash - Regular IPNS contenthash to set as recordhash\n     */\n    function setSubRecordhash(bytes32 _node, string calldata _subdomain, bytes calldata _recordhash) external payable {\n        address _owner = ENS.owner(_node);\n        if (isWrapper[_owner]) {\n            _owner = iToken(_owner).ownerOf(uint256(_node));\n        }\n        if (msg.sender != _owner && !isApprovedSigner[_owner][_node][msg.sender]) {\n            revert NotAuthorised(\"NOT_APPROVED\");\n        }\n        bytes32 _namehash = keccak256(abi.encodePacked(_node, keccak256(bytes(_subdomain))));\n        recordhash[_namehash] = _recordhash;\n        emit RecordhashUpdated(msg.sender, _namehash, _recordhash);\n    }\n\n    /**\n     * @dev Sets recordhash for a subnode\n     * Note - Only ENS owner or manager of parent node can call\n     * @param _node - Namehash of domain.eth\n     * @param _subdomain - Subdomain labels; a.b.c.domain.eth = [a, b, c]\n     * @param _recordhash - Regular IPNS contenthash to set as recordhash\n     */\n    function setDeepSubRecordhash(bytes32 _node, string[] calldata _subdomain, bytes calldata _recordhash)\n        external\n        payable\n    {\n        bytes32 _namehash = _node;\n        address _owner = ENS.owner(_node);\n        if (isWrapper[_owner]) {\n            _owner = iToken(_owner).ownerOf(uint256(_node));\n        }\n        if (msg.sender != _owner && !isApprovedSigner[_owner][_node][msg.sender]) {\n            revert NotAuthorised(\"NOT_APPROVED\");\n        }\n        uint256 len = _subdomain.length;\n        unchecked {\n            while (len > 0) {\n                _namehash = keccak256(abi.encodePacked(_namehash, keccak256(bytes(_subdomain[--len]))));\n            }\n        }\n        recordhash[_namehash] = _recordhash;\n        emit RecordhashUpdated(msg.sender, _namehash, _recordhash);\n    }\n\n    /**\n     * @dev EIP-2544/EIP-3668 core resolve() function; aka CCIP-Read\n     * @param name - ENS domain to resolve; must be DNS encoded\n     * @param request - Encoding-specific function to resolve\n     * @return result - Triggers Off-chain Lookup\n     * Note - Return value is not used\n     */\n    function resolve(bytes calldata name, bytes calldata request) external view returns (bytes memory) {\n        unchecked {\n            /// @dev - DNSDecode() routine\n            uint256 index = 1;\n            uint256 n = 1;\n            uint256 len = uint8(bytes1(name[0]));\n            bytes[] memory _labels = new bytes[](42);\n            _labels[0] = name[1:n += len];\n            string memory _path = string(_labels[0]);\n            string memory _domain = _path;\n            while (name[n] > 0x0) {\n                len = uint8(bytes1(name[n:++n]));\n                _labels[index] = name[n:n += len];\n                _domain = string.concat(_domain, \".\", string(_labels[index]));\n                _path = string.concat(string(_labels[index++]), \"/\", _path);\n            }\n            bytes32 _namehash = keccak256(abi.encodePacked(bytes32(0), keccak256(_labels[--index])));\n            bytes32 _node;\n            bytes memory _recordhash;\n            // Evaluate 'closest-set' parent node\n            while (index > 0) {\n                _namehash = keccak256(abi.encodePacked(_namehash, keccak256(_labels[--index])));\n                // Check if sub(domain) exists on-chain or off-chain\n                if (ENS.recordExists(_namehash)) {\n                    _node = _namehash;\n                    _recordhash = recordhash[_namehash];\n                } else if (bytes(recordhash[_namehash]).length > 0) {\n                    _recordhash = recordhash[_namehash];\n                }\n            }\n            address _owner = ENS.owner(_node);\n            // Update ownership if domain is wrapped\n            if (isWrapper[_owner]) {\n                _owner = iToken(_owner).ownerOf(uint256(_node));\n            }\n            if (_recordhash.length == 0) {\n                _recordhash = recordhash[bytes32(uint256(uint160(_owner)))];\n            }\n            string memory _recType = gateway.funcToJson(request); // Filename for the requested record\n            bytes32 _checkhash =\n                keccak256(abi.encodePacked(this, blockhash(block.number - 1), _owner, _domain, _recType, request));\n            revert OffchainLookup(\n                address(this),\n                gateway.randomGateways(\n                    _recordhash, string.concat(\"/.well-known/\", _path, \"/\", _recType), uint256(_checkhash)\n                ), // Generate pseudo-random list of gateways for record resolution\n                abi.encodePacked(uint16(block.timestamp / 60)), // Cache = 60 seconds\n                iCCIP2ETH.__callback.selector, // Callback function\n                abi.encode(_node, block.number - 1, _checkhash, _domain, _recType, _path, name, request)\n            );\n        }\n    }\n\n    /**\n     * @dev Default Callback function\n     * @param response - Response of CCIP-Read call\n     * @param extradata - Extra data used by callback\n     * @return result - Concludes Off-chain Lookup\n     * Note - Return value is not used\n     */\n    function __callback(bytes calldata response, bytes calldata extradata)\n        external\n        view\n        returns (bytes memory result)\n    {\n        /// Get signer-type from response identifier\n        bytes4 _type = bytes4(response[:4]);\n        if (!supportsInterface[_type]) {\n            /// @dev Future features in __fallback\n            return gateway.__fallback(response, extradata);\n        }\n        (\n            bytes32 _node, // Namehash of base owned ENS domain\n            uint256 _blocknumber, // Blocknumber for timeout checks\n            bytes32 _checkhash, // Extra checkhash\n            string memory _domain, // String-formatted complete 'a.b.c.domain.eth'\n            string memory _recType, // Record type\n            , // Complete reverse-DNS path for __fallback()\n            , // DNS-encoded domain.eth\n            bytes memory _request // Format: <bytes4> + <namehash> + <extradata>\n        ) = abi.decode(extradata, (bytes32, uint256, bytes32, string, string, string, bytes, bytes));\n        address _owner = ENS.owner(_node);\n        if (isWrapper[_owner]) {\n            _owner = iToken(_owner).ownerOf(uint256(_node));\n        }\n        /// @dev - Timeout in 6 blocks\n        if (block.number > _blocknumber + 7) {\n            revert InvalidRequest(\"BLOCK_TIMEOUT\");\n        }\n        /// @dev - Verify checkhash\n        if (\n            _checkhash\n                != keccak256(abi.encodePacked(this, blockhash(_blocknumber), _owner, _domain, _recType, _request))\n        ) {\n            revert InvalidRequest(\"BAD_CHECKSUM\");\n        }\n        // Signer could be:\n        // a) Owner\n        // OR, b) On-chain approved manager\n        // OR, c) Off-chain approved signer\n        address _signer;\n        /// Signature associated with the record\n        bytes memory _recordSignature;\n        /// Init off-chain manager's signature request\n        string memory signRequest;\n        /// Off-chain signature approving record signer (if signer != owner or on-chain manager)\n        bytes memory _approvedSig;\n        /// @dev CCIP-Read response decode\n        (_signer, _recordSignature, _approvedSig, result) = abi.decode(response[4:], (address, bytes, bytes, bytes));\n        if (_approvedSig.length < 64) {\n            if (_signer != _owner && !isApprovedSigner[_owner][_node][_signer]) {\n                revert NotAuthorised(\"NOT_APPROVED\");\n            }\n        } else if (!approvedSigner(_owner, _signer, _node, _approvedSig, _domain)) {\n            revert NotAuthorised(\"BAD_APPROVAL\");\n        }\n        if (_type == iCallbackType.signedRecord.selector) {\n            /// @dev If 'signedRecord()' bytes4 selector; handles signed records\n            signRequest = string.concat(\n                \"Requesting Signature To Update ENS Record\\n\",\n                \"\\nOrigin: \",\n                _domain,\n                \"\\nRecord Type: \",\n                _recType,\n                \"\\nExtradata: 0x\",\n                gateway.bytesToHexString(abi.encodePacked(keccak256(result)), 0),\n                \"\\nSigned By: eip155:\",\n                chainID,\n                \":\",\n                gateway.toChecksumAddress(_signer)\n            );\n            if (_signer != iCCIP2ETH(this).getSigner(signRequest, _recordSignature)) {\n                revert InvalidRequest(\"BAD_SIGNED_RECORD\");\n            }\n        } else if (_type == iCallbackType.signedRedirect.selector) {\n            /// @dev If 'signedRedirect()' bytes4 selector; handles redirected records\n            if (result[0] == 0x0 || result[result.length - 1] != 0x0) {\n                revert InvalidRequest(\"BAD_REDIRECT_REQUEST\");\n            }\n            // ENS dApp redirect\n            // Result should be DNS encoded; result should NOT be ABI-encoded\n            // Note Last byte is 0x00, meaning end of DNS-encoded stream\n            (bytes4 _req, bytes32 _redirectNamehash, bytes memory _redirectRequest, string memory _redirectDomain) =\n                iCCIP2ETH(this).redirectService(result, _request);\n            signRequest = string.concat(\n                \"Requesting Signature To Install dApp Service\\n\",\n                \"\\nOrigin: \",\n                _domain, // e.g. ens.domain.eth\n                \"\\nApp: \",\n                _redirectDomain, // e.g. app.ens.eth\n                \"\\nExtradata: 0x\",\n                gateway.bytesToHexString(abi.encodePacked(keccak256(result)), 0),\n                \"\\nSigned By: eip155:\",\n                chainID,\n                \":\",\n                gateway.toChecksumAddress(_signer)\n            );\n            if (_signer != iCCIP2ETH(this).getSigner(signRequest, _recordSignature)) {\n                revert InvalidRequest(\"BAD_DAPP_SIGNATURE\");\n            }\n            address _resolver = ENS.resolver(_redirectNamehash); // Owned node\n            if (iERC165(_resolver).supportsInterface(iENSIP10.resolve.selector)) {\n                return iENSIP10(_resolver).resolve(result, _redirectRequest);\n            } else if (iERC165(_resolver).supportsInterface(_req)) {\n                bool ok;\n                (ok, result) = _resolver.staticcall(_redirectRequest);\n                if (!ok) {\n                    revert InvalidRequest(\"BAD_RESOLVER\");\n                }\n            } else {\n                revert InvalidRequest(\"BAD_FUNCTION\");\n            }\n        } else {\n            /// @dev Future features in __fallback\n            return gateway.__fallback(response, extradata);\n        }\n    }\n\n    /**\n     * @dev Redirects the CCIP-Read request to another ENS Domain\n     * @param _encoded - ENS domain to resolve; must be DNS encoded\n     * @param _requested - Originally requested encoding-specific function to resolve\n     * @return _selector - Redirected function selector\n     * @return _namehash - Redirected namehash\n     * @return _redirectRequest - Redirected request\n     * @return domain - String-formatted ENS domain\n     */\n    function redirectService(bytes calldata _encoded, bytes calldata _requested)\n        external\n        view\n        returns (bytes4 _selector, bytes32 _namehash, bytes memory _redirectRequest, string memory domain)\n    {\n        uint256 index = 1;\n        uint256 n = 1;\n        uint256 len = uint8(bytes1(_encoded[0]));\n        bytes[] memory _labels = new bytes[](42);\n        _labels[0] = _encoded[1:n += len];\n        domain = string(_labels[0]);\n        while (_encoded[n] > 0x0) {\n            len = uint8(bytes1(_encoded[n:++n]));\n            _labels[index] = _encoded[n:n += len];\n            domain = string.concat(domain, \".\", string(_labels[index]));\n        }\n        bytes32 _owned;\n        _namehash = keccak256(abi.encodePacked(bytes32(0), keccak256(_labels[--index])));\n        while (index > 0) {\n            _namehash = keccak256(abi.encodePacked(_namehash, keccak256(_labels[--index])));\n            if (ENS.recordExists(_namehash)) {\n                _owned = _namehash;\n            }\n        }\n        if (_owned == bytes32(0)) {\n            revert InvalidRequest(\"NOT_REGISTERED\");\n        }\n        _selector = bytes4(_requested[:4]);\n        _redirectRequest = abi.encodePacked(_selector, _namehash, _requested.length > 36 ? _requested[36:] : bytes(\"\"));\n        _namehash = _owned;\n    }\n\n    /**\n     * @dev Checks for manager access to an ENS domain for record management\n     * @param _owner - Owner of ENS domain\n     * @param _approvedSigner - Manager address to check\n     * @param _node - Namehash of ENS domain\n     * @param _signature - Signature to verify\n     * @param _domain - String-formatted ENS domain\n     * @return  - Whether manager is approved by the owner\n     */\n    function approvedSigner(\n        address _owner,\n        address _approvedSigner,\n        bytes32 _node,\n        bytes memory _signature,\n        string memory _domain\n    ) public view returns (bool) {\n        address _signer = iCCIP2ETH(this).getSigner(\n            string.concat(\n                \"Requesting Signature To Approve ENS Records Signer\\n\",\n                \"\\nOrigin: \",\n                _domain,\n                \"\\nApproved Signer: eip155:\",\n                chainID,\n                \":\",\n                gateway.toChecksumAddress(_approvedSigner),\n                \"\\nApproved By: eip155:\",\n                chainID,\n                \":\",\n                gateway.toChecksumAddress(_owner)\n            ),\n            _signature\n        );\n        return (_signer == _owner || isApprovedSigner[_owner][_node][_signer]);\n    }\n\n    /**\n     * @dev Checks if a signature is valid\n     * @param _message - String-formatted message that was signed\n     * @param _signature - Compact signature to verify\n     * @return _signer - Signer of message\n     * @notice - Signature Format:\n     * a) 64 bytes - bytes32(r) + bytes32(vs) ~ compact, or\n     * b) 65 bytes - bytes32(r) + bytes32(s) + uint8(v) ~ packed, or\n     * c) 96 bytes - bytes32(r) + bytes32(s) + uint256(v) ~ longest\n     */\n    function getSigner(string calldata _message, bytes calldata _signature) external view returns (address _signer) {\n        bytes32 r = bytes32(_signature[:32]);\n        bytes32 s;\n        uint8 v;\n        uint256 len = _signature.length;\n        if (len == 64) {\n            bytes32 vs = bytes32(_signature[32:]);\n            s = vs & bytes32(0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n            v = uint8((uint256(vs) >> 255) + 27);\n        } else if (len == 65) {\n            s = bytes32(_signature[32:64]);\n            v = uint8(bytes1(_signature[64:]));\n        } else if (len == 96) {\n            s = bytes32(_signature[32:64]);\n            v = uint8(uint256(bytes32(_signature[64:])));\n        } else {\n            revert InvalidSignature(\"BAD_SIG_LENGTH\");\n        }\n        if (s > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            revert InvalidSignature(\"INVALID_S_VALUE\");\n        }\n        bytes32 digest = keccak256(\n            abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", gateway.uintToString(bytes(_message).length), _message)\n        );\n        _signer = ecrecover(digest, v, r, s);\n        if (_signer == address(0)) {\n            revert InvalidSignature(\"ZERO_ADDR\");\n        }\n    }\n\n    /**\n     * @dev Sets a signer (= manager) as approved to manage records for a node\n     * @param _node - Namehash of ENS domain\n     * @param _signer - Address of signer (= manager)\n     * @param _approval - Status to set\n     */\n    function approve(bytes32 _node, address _signer, bool _approval) external {\n        isApprovedSigner[msg.sender][_node][_signer] = _approval;\n        emit ApprovedSigner(msg.sender, _node, _signer, _approval);\n    }\n\n    /**\n     * @dev Sets multiple signers (= managers) as approved to manage records for a node\n     * @param _node - Namehash[] of ENS domains\n     * @param _signer - Address[] of signers (= managers)\n     * @param _approval - Status[] to set\n     */\n    function multiApprove(bytes32[] calldata _node, address[] calldata _signer, bool[] calldata _approval) external {\n        uint256 len = _node.length;\n        for (uint256 i = 0; i < len; i++) {\n            isApprovedSigner[msg.sender][_node[i]][_signer[i]] = _approval[i];\n            emit ApprovedSigner(msg.sender, _node[i], _signer[i], _approval[i]);\n        }\n    }\n\n    /**\n     * @dev Checks if a signer (= manager) is approved to manage records for a node\n     * @param _node - Namehash of ENS domain\n     * @param _signer - Address of signer (= manager)\n     */\n    function approved(bytes32 _node, address _signer) public view returns (bool) {\n        address _owner = ENS.owner(_node);\n        if (isWrapper[_owner]) {\n            _owner = iToken(_owner).ownerOf(uint256(_node));\n        }\n        return _owner == _signer || isApprovedSigner[_owner][_node][_signer];\n    }\n\n    /// @dev : Management functions\n\n    /// @dev - Checks for admin privileges\n    modifier OnlyDev() {\n        if (msg.sender != gateway.owner()) {\n            revert NotAuthorised(\"NOT_DEV\");\n        }\n        _;\n    }\n\n    /// @dev - Returns owner of the contract\n    function owner() public view returns (address) {\n        return gateway.owner();\n    }\n\n    /// @dev - Updates ChainID in case of a hardfork\n    function updateChainID() public {\n        chainID = gateway.uintToString(block.chainid);\n    }\n    /**\n     * @dev Sets fees for ownerhash\n     * Note - Set to 0 at launch\n     * @param _wei - Fees in WEI per EOA\n     */\n\n    function updateOwnerhashFees(uint256 _wei) external OnlyDev {\n        ownerhashFees = _wei;\n    }\n\n    /**\n     * @dev Updates supported interfaces\n     * @param _sig - 4-byte interface selector\n     * @param _set - State to set for selector\n     */\n    function updateInterface(bytes4 _sig, bool _set) external OnlyDev {\n        if (_sig == iCallbackType.signedRecord.selector || _sig == iENSIP10.resolve.selector) {\n            revert BadConfig(\"LOCKED_CALLBACK\");\n        }\n        supportsInterface[_sig] = _set;\n        emit InterfaceUpdated(_sig, _set);\n    }\n\n    /**\n     * @dev Set new Gateway Manager Contract\n     * @param _gateway - Address of new Gateway Manager Contract\n     */\n    function updateGateway(address _gateway) external OnlyDev {\n        if (_gateway.code.length == 0) {\n            revert BadConfig(\"BAD_GATEWAY\");\n        }\n        if (msg.sender != iGatewayManager(_gateway).owner()) {\n            revert NotAuthorised(\"BAD_OWNER\");\n        }\n        emit GatewayUpdated(address(gateway), _gateway);\n        gateway = iGatewayManager(_gateway);\n    }\n\n    /**\n     * @dev Add or remove ENS wrapper\n     * @param _addr - Address of ENS wrapper\n     * @param _set - State to set for new ENS wrapper\n     */\n    function updateWrapper(address _addr, bool _set) external OnlyDev {\n        if (_addr.code.length == 0) {\n            revert BadConfig(\"BAD_WRAPPER\");\n        }\n        isWrapper[_addr] = _set;\n        emit UpdatedWrapper(_addr, _set);\n    }\n\n    /**\n     * @dev Withdraw Ether to owner; to be used for tips or in case some Ether gets locked in the contract\n     */\n    function withdraw() external {\n        payable(gateway.owner()).transfer(address(this).balance);\n    }\n\n    /**\n     * @dev To be used for tips or in case some fungible tokens get locked in the contract\n     * @param _contract - Token contract address\n     * @param _balance - Amount to release\n     */\n    function withdraw(address _contract, uint256 _balance) external {\n        iToken(_contract).transferFrom(address(this), gateway.owner(), _balance);\n    }\n\n    /**\n     * @dev To be used for tips or in case some non-fungible tokens get locked in the contract\n     * @param _contract - Token contract address\n     * @param _token - Token ID to release\n     */\n    function safeWithdraw(address _contract, uint256 _token) external {\n        iToken(_contract).safeTransferFrom(address(this), gateway.owner(), _token);\n    }\n}\n"

    },

    "src/Interface.sol": {

      "content": "// SPDX-License-Identifier: WTFPL.ETH\npragma solidity >0.8.0 <0.9.0;\n\ninterface iERC165 {\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n\ninterface iERC173 {\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function owner() external view returns (address);\n    function transferOwnership(address _newOwner) external;\n}\n\ninterface iENS {\n    function owner(bytes32 node) external view returns (address);\n    function resolver(bytes32 node) external view returns (address);\n    function ttl(bytes32 node) external view returns (uint64);\n    function recordExists(bytes32 node) external view returns (bool);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n\ninterface iENSIP10 {\n    error OffchainLookup(address _to, string[] _gateways, bytes _data, bytes4 _callbackFunction, bytes _extradata);\n\n    function resolve(bytes memory _name, bytes memory _data) external view returns (bytes memory);\n}\n\ninterface iCCIP2ETH is iENSIP10 {\n    function __callback(bytes calldata _response, bytes calldata _extraData)\n        external\n        view\n        returns (bytes memory _result);\n\n    function getSigner(string calldata _signRequest, bytes calldata _signature)\n        external\n        view\n        returns (address _signer);\n    function setRecordhash(bytes32 _node, bytes calldata _recordhash) external payable;\n    function setShortRecordhash(bytes32 _node, bytes32 _recordhash) external payable;\n    function setSubRecordhash(bytes32 _node, string memory _subdomain, bytes calldata _recordhash) external payable;\n    function setDeepSubRecordhash(bytes32 _node, string[] memory _subdomains, bytes calldata _recordhash)\n        external\n        payable;\n    function setOwnerhash(bytes calldata _recordhash) external payable;\n    function redirectService(bytes calldata _encoded, bytes calldata _requested)\n        external\n        view\n        returns (bytes4 _selector, bytes32 _namehash, bytes memory _redirectRequest, string memory _domain);\n}\n\ninterface iGatewayManager is iERC173 {\n    function randomGateways(bytes calldata _recordhash, string memory _path, uint256 k)\n        external\n        view\n        returns (string[] memory gateways);\n    function uintToString(uint256 value) external pure returns (string memory);\n    function bytesToHexString(bytes calldata _buffer, uint256 _start) external pure returns (string memory);\n    function bytes32ToHexString(bytes32 _buffer) external pure returns (string memory);\n    function funcToJson(bytes calldata _request) external view returns (string memory _jsonPath);\n    function toChecksumAddress(address _addr) external pure returns (string memory);\n    function __fallback(bytes calldata response, bytes calldata extradata)\n        external\n        view\n        returns (bytes memory result);\n    function addFuncMap(bytes4 _func, string calldata _name) external;\n    function listWeb2Gateways() external view returns (string[] memory list);\n    function addWeb2Gateway(string calldata _domain) external;\n    function removeWeb2Gateway(uint256 _index) external;\n    function replaceWeb2Gateway(uint256 _index, string calldata _domain) external;\n    function listWeb3Gateways() external view returns (string[] memory list);\n    function addWeb3Gateway(string calldata _domain) external;\n    function removeWeb3Gateway(uint256 _index) external;\n    function replaceWeb3Gateway(uint256 _index, string calldata _domain) external;\n    function formatSubdomain(bytes calldata _recordhash) external pure returns (string memory result);\n    function isWeb2(bytes calldata _recordhash) external pure returns (bool);\n}\n\ninterface iResolver {\n    function contenthash(bytes32 node) external view returns (bytes memory);\n    function addr(bytes32 node) external view returns (address payable);\n    function pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y);\n    function text(bytes32 node, string calldata key) external view returns (string memory value);\n    function name(bytes32 node) external view returns (string memory);\n    function ABI(bytes32 node, uint256 contentTypes) external view returns (uint256, bytes memory);\n    function interfaceImplementer(bytes32 node, bytes4 interfaceID) external view returns (address);\n    function zonehash(bytes32 node) external view returns (bytes memory);\n    function dnsRecord(bytes32 node, bytes32 name, uint16 resource) external view returns (bytes memory);\n    function recordVersions(bytes32 node) external view returns (uint64);\n    function approved(bytes32 _node, address _signer) external view returns (bool);\n}\n\ninterface iOverloadResolver {\n    function addr(bytes32 node, uint256 coinType) external view returns (bytes memory);\n    function dnsRecord(bytes32 node, bytes memory name, uint16 resource) external view returns (bytes memory);\n}\n\ninterface iToken {\n    function ownerOf(uint256 id) external view returns (address);\n    function transferFrom(address from, address to, uint256 bal) external;\n    function safeTransferFrom(address from, address to, uint256 bal) external;\n}\n\n// Note - Owner = Owner of domain.eth\n// Note - Manager = On-/Off-Chain address approved by Owner\n// Note - Signer = Record signer\ninterface iCallbackType {\n    function signedRecord(\n        address recordSigner, // Owner OR On-Chain Manager OR Off-Chain Manager\n        bytes memory recordSignature, // Signature from signer for result value\n        bytes memory approvedSignature, // bytes length >0 & <64 IF signer is owner or on-chain approved manager\n        bytes memory result // ABI-encoded result\n    ) external view returns (bytes memory);\n\n    function signedRedirect(\n        address recordSigner, // Owner OR On-Chain Manager OR Off-Chain Manager\n        bytes memory recordSignature, // Signature from signer for redirect value\n        bytes memory approvedSignature, // bytes length >0 & <64 IF signer is owner or on-chain approved manager\n        bytes memory redirect // DNS-encoded sub/domain.eth to redirect\n    ) external view returns (bytes memory);\n}\n"

    }

  },

  "settings": {

    "remappings": [

      "ds-test/=lib/forge-std/lib/ds-test/src/",

      "forge-std/=lib/forge-std/src/"

    ],

    "optimizer": {

      "enabled": true,

      "runs": 200

    },

    "metadata": {

      "bytecodeHash": "ipfs",

      "appendCBOR": true

    },

    "outputSelection": {

      "*": {

        "*": [

          "evm.bytecode",

          "evm.deployedBytecode",

          "devdoc",

          "userdoc",

          "metadata",

          "abi"

        ]

      }

    },

    "evmVersion": "paris",

    "viaIR": true,

    "libraries": {}

  }

}}